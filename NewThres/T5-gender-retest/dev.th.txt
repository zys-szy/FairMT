Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Induction.Module NatList.Inductive natprod : Type := | pair : nat -> nat -> natprod.Instance dec_natprod (p q : natprod) : Dec (p = q). Proof. constructor; unfold decidable; repeat decide equality. Defined.Derive (Arbitrary, Show) for natprod. Derive (Sized, CanonicalSized) for natprod. Derive SizeMonotonic for natprod using genSnatprod. Derive SizedMonotonic for natprod. Derive SizedCorrect for natprod using genSnatprod and SizeMonotonicnatprod.Definition fst (p : natprod) : nat := match p with | pair x y => x end.Definition snd (p : natprod) : nat := match p with | pair x y => y end.Notation "( x , y )" := (pair x y).Definition fst' (p : natprod) : nat := match p with | (x,y) => x end.Definition snd' (p : natprod) : nat := match p with | (x,y) => y end.Definition swap_pair (p : natprod) : natprod := match p with | (x,y) => (y,x) end.Theorem surjective_pairing' : forall (n m : nat), (n,m) = (fst (n,m), snd (n,m)). Admitted. Theorem surjective_pairing : forall (p : natprod), p = (fst p, snd p). Admitted. Theorem snd_fst_is_swap : forall (p : natprod), (snd p, fst p) = swap_pair p. Admitted. Theorem fst_swap_is_snd : forall (p : natprod), fst (swap_pair p) = snd p. 
@NTerm p) bts, isprogram (oterm o ((bt1)::(bterm [] nt2):: bts)) -> isprogram nt2. Proof. intros ? ? ? ? Hisp. apply is_program_ot_nth_nobnd with (nt1:=nt2) in Hisp; simpl; sp. Qed. Theorem is_program_ot_subst1 {p} : forall o (nt1 : @NTerm p) bts nt1r, isprogram (oterm o ((bterm [] nt1):: bts)) -> isprogram nt1r -> isprogram (oterm o ((bterm [] nt1r):: bts)). Proof. intros ? ? ? ? Hisp Hispst. unfold isprogram. unfold closed. simpl. inverts Hisp as Hclos Hisp. unfold closed in Hclos. simpl in Hclos. apply app_eq_nil in Hclos. repnd. rewrite remove_var_nil in Hclos0. inverts Hispst as Hclosst Hispst. unfold closed in Hclosst. rewrite remove_var_nil. rewrite Hclosst. rewrite Hclos. split;auto. invertsn Hisp. constructor;auto. intros ? Hin. inverts Hin. constructor; auto. apply Hisp. right; auto. Qed.Theorem is_program_ot_subst2 {p} : forall o bt1 (nt2 : @NTerm p) bts nt2r, isprogram (oterm o (bt1::(bterm [] nt2):: bts)) -> isprogram nt2r -> isprogram (oterm o (bt1::(bterm [] nt2r):: bts)). Proof. intros ? ? ? ? ? Hisp Hispst. unfold isprogram. unfold closed. simpl. inverts Hisp as Hclos Hisp. inverts Hispst as Hclosst Hwfst. allunfold @closed. simpl. unfold closed in Hclos. allsimpl. simpl_vlist. rewrite Hclosst. rewrite Hclos0. simpl. split;auto. inverts Hisp as Hisp Hm. constructor;simpl; auto. intros ? Hin. dorn Hin;subst;auto. apply Hisp; auto. left; auto. dorn Hin; subst; auto. apply Hisp. right;right;auto. Qed. Theorem is_program_ot_nth_wf {p} : forall lv o (nt1 : @NTerm p) bts, isprogram (oterm o bts) -> LIn (bterm lv nt1) bts -> nt_wf nt1. Proof. intros ? ? ? ? Hisp Hin. apply isprogram_ot_iff in Hisp. repnd. assert (isprogram_bt (bterm lv nt1)) as Hass by (apply Hisp; auto). inverts Hass as Hass Hbt. inversion Hbt; auto. Qed.Lemma combine_vars_map_sp {p} : forall vars, combine vars (map vterm vars) = map (fun v => (v, @vterm p v)) vars. Proof. induction vars; simpl; sp. rewrite IHvars; sp. Qed.Lemma combine_vars_map : forall A, forall f : NVar -> A, forall vars, combine vars (map f vars) = map (fun v => (v, f v)) vars. Proof. induction vars; simpl; sp. rewrite IHvars; sp. Qed. Theorem in_selectbt {p} : forall (bt : @BTerm p) bts, LIn bt bts -> {n : nat $ n < length bts # selectbt bts n = bt}. Proof. intros ? ? Hin. induction bts. inverts Hin. invertsn Hin. - exists 0. split; simpl; auto. omega. - destruct IHbts; auto. exists (S x). repnd. split; simpl; try omega. auto. Qed. Theorem ntot_wf_iff {p} : forall o (bts : list (@BTerm p)), nt_wf (oterm o bts) <=> map num_bvars bts = OpBindings o # forall n : nat, n < length bts -> bt_wf (selectbt bts n). 
{X Y} (y : X) (u : F (X -> Y)), u <*> pure y = pure (fun f => f y) <*> u; app_fmap_unit : forall {X Y} (f : X -> Y), ap (pure f) = fmap f }.Notation "pure/ M" := (@pure M _ _) (at level 28). Notation "pure/ M N" := (@pure (fun X => M (N X)) _ _) (at level 26).Notation "ap[ M ] f" := (@ap M _ _ _ f) (at level 28). Notation "ap[ M N ] f" := (@ap (fun X => M (N X)) _ _ _ f) (at level 26). Notation "ap[ M N O ] f" := (@ap (fun X => M (N (O X))) _ _ _ f) (at level 24).Notation "f <*> g" := (ap f g) (at level 28, left associativity).Notation "[| f x y .. z |]" := (.. (f <$> x <*> y) .. <*> z) (at level 9, left associativity, f at level 9, x at level 9, y at level 9, z at level 9).Definition app_merge {X Y Z W} (f : X -> Y) (g : Z -> W) (t : X * Z) : Y * W := match t with (x, z) => (f x, g z) end.Definition app_prod {F : Type -> Type} `{Applicative F} {X Y} (x : F X) (y : F Y) : F (X * Y) := pair <$> x <*> y.Notation "f *** g" := (app_merge f g) (at level 28, left associativity).Notation "f ** g" := (app_prod f g) (at level 28, left associativity).Ltac rewrite_app_homomorphisms := (repeat (rewrite <- app_fmap_unit); rewrite app_homomorphism; repeat (rewrite app_fmap_unit)).Section Applicatives. Variable F : Type -> Type. Context `{Applicative F}. Theorem app_fmap_compose : forall A B (f : A -> B), pure ∘ f = fmap f ∘ pure. Proof. intros. extensionality x. unfold compose. rewrite <- app_homomorphism. rewrite app_fmap_unit. reflexivity. Qed. Theorem app_fmap_compose_x : forall A B (f : A -> B) (x : A), pure (f x) = fmap f (pure x). Proof. intros. assert (pure (f x) = (pure ∘ f) x). unfold compose. reflexivity. assert (fmap f (pure x) = (fmap f ∘ pure) x). unfold compose. reflexivity. rewrite H0. rewrite H1. rewrite app_fmap_compose. reflexivity. Qed. Theorem app_identity_x : forall {X} {x : F X}, ap (pure (@id X)) x = id x. Proof. intros. rewrite app_fmap_unit. apply fun_identity_x. Qed. Theorem app_homomorphism_2 : forall {X Y Z} (x : X) (y : Y) (f : X -> Y -> Z), f <$> pure x <*> pure y = pure (f x y). 
33 tan_ub_MaxBank (4 / 5) (Rlt_le 0 g H3) (Rlt_le 0 tan_ub_MaxBank H4) H2 H1)... intro H6; generalize (Rmult_lt_0_compat g tan_ub_MaxBank H3 H4); intro H7... assert (H8 := Rmult_le_0_lt_compat (g * tan_ub_MaxBank) (33 * (4 / 5)) (/ h) (/ 200) (Rlt_le 0 (g * tan_ub_MaxBank) H7) (Rlt_le 0 (/ h) H5) H6 H0)... apply Rlt_trans with (33 * / 200 * (4 / 5) * t)%R... apply Rmult_lt_compat_r... apply Rlt_le_trans with MinT... apply MinT_is_pos... apply (cond_1 t)... rewrite Rmult_assoc; rewrite (Rmult_comm (/ 200)); unfold Rdiv in |- *; do 2 rewrite <- Rmult_assoc... apply Rle_lt_trans with (33 * / 200 * (4 / 5) * 10)%R... apply Rmult_le_compat_l... left; apply Rmult_lt_0_compat... apply Rmult_lt_0_compat; [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]... unfold Rdiv in |- *; apply Rmult_lt_0_compat; [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]... apply Rmult_lt_reg_l with 2%R... prove_sup... apply Rmult_lt_reg_l with 200%R... prove_sup... apply Rmult_lt_reg_l with 5%R... prove_sup... set (x := 200%R); set (y := 33%R); set (z := 10%R); set (u := 5%R); set (v := 4%R); set (w := 2%R)... unfold Rdiv in |- *; replace (u * (x * (w * (PI_lb * / w))))%R with (x * PI_lb * u * (w * / w))%R; [ idtac | ring ]... replace (u * (x * (w * (y * / x * (v * / u) * z))))%R with (w * y * v * z * (u * / u) * (x * / x))%R; [ idtac | ring ]... repeat rewrite <- Rinv_r_sym; unfold x, y, z, u, v, w in |- *; try discrR... unfold PI_lb in |- *; prove_sup... apply Rinv_lt_contravar... apply Rmult_lt_0_compat... prove_sup... apply Rlt_le_trans with MinSpeed... unfold MinSpeed in |- *; prove_sup... apply (v_cond1 h)... apply Rlt_le_trans with MinSpeed... unfold MinSpeed in |- *; prove_sup... apply (v_cond1 h)... unfold tan_ub_MaxBank in |- *; unfold Rdiv in |- *... apply Rmult_lt_reg_l with 10%R... prove_sup... rewrite (Rmult_comm 10); rewrite Rmult_assoc; rewrite <- Rinv_l_sym... rewrite Rmult_1_r; apply Rmult_lt_reg_l with 5%R... prove_sup... pattern 5%R at 1 in |- *; rewrite (Rmult_comm 5); do 2 rewrite Rmult_assoc; rewrite <- Rinv_l_sym... prove_sup... discrR... discrR... unfold g in |- *; unfold Rdiv in |- *; apply Rmult_lt_reg_l with 10%R... prove_sup... rewrite <- Rmult_comm; rewrite Rmult_assoc; rewrite <- Rinv_l_sym... rewrite Rmult_1_r; prove_sup... discrR... unfold Rdiv in |- *; repeat rewrite <- (Rmult_comm (/ 2)); apply Rmult_lt_compat_l... apply Rinv_0_lt_compat; prove_sup... assert (H0 := PI_approx); elim H0... Qed. Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R. 
: R x y -> leftTrans x y | LTStep : forall z, R x z -> leftTrans z y -> leftTrans x y. Inductive rightTrans (x y : T) : Prop := | RTFin : R x y -> rightTrans x y | RTStep : forall z, rightTrans x z -> R z y -> rightTrans x y. Fixpoint leftTrans_rightTrans_acc x y (l : leftTrans y x) : forall z, rightTrans z y -> rightTrans z x := match l with | LTFin pf => fun z pfR => RTStep pfR pf | LTStep _ pf pfL => fun z pfR => leftTrans_rightTrans_acc pfL (RTStep pfR pf) end. Fixpoint rightTrans_leftTrans_acc x y (l : rightTrans x y) : forall z, leftTrans y z -> leftTrans x z := match l with | RTFin pf => fun z pfR => LTStep pf pfR | RTStep _ pf pfL => fun z pfR => rightTrans_leftTrans_acc pf (LTStep pfL pfR) end. Theorem leftTrans_rightTrans : forall x y, leftTrans x y <-> rightTrans x y. Proof. split. { destruct 1. apply RTFin; assumption. eapply leftTrans_rightTrans_acc. eassumption. eapply RTFin. eassumption. } { destruct 1. apply LTFin. assumption. eapply rightTrans_leftTrans_acc. eassumption. eapply LTFin. eassumption. } Qed. Fixpoint leftTrans_makeTrans_acc x y (l : leftTrans x y) : makeTrans x y := match l with | LTFin pf => TStep pf | LTStep _ pf pfL => TTrans (TStep pf) (leftTrans_makeTrans_acc pfL) end. Fixpoint leftTrans_trans x y (l : leftTrans x y) : forall z (r : leftTrans y z), leftTrans x z := match l with | LTFin pf => fun _ pfL => LTStep pf pfL | LTStep _ pf pfL => fun _ pfR => LTStep pf (leftTrans_trans pfL pfR) end. Theorem makeTrans_leftTrans : forall s s', makeTrans s s' <-> leftTrans s s'. Proof. split; intros. { induction H. eapply LTFin. eassumption. eapply leftTrans_trans; eassumption. } { apply leftTrans_makeTrans_acc. assumption. } Qed. Theorem makeTrans_rightTrans : forall s s', makeTrans s s' <-> rightTrans s s'. Proof. intros. etransitivity. apply makeTrans_leftTrans. apply leftTrans_rightTrans. Qed. Definition RTStep_left : forall x y z : T, R x y -> rightTrans y z -> rightTrans x z. intros. revert H. revert x. induction H0. { intros. eapply RTStep. eapply RTFin. eassumption. eassumption. } { intros. eapply RTStep. eapply IHrightTrans. eassumption. eassumption. } Defined.End parametric.Section param. Variable T : Type. Variable R : T -> T -> Prop. Theorem makeTrans_idem : forall s s', makeTrans (makeTrans R) s s' <-> makeTrans R s s'. 
n) (p q : list (Term A n)), ltT ltM a b -> pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q) = minuspf (pX a p) (pX b q). intros a b p q H'; try assumption. rewrite (minusP_inv2 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3a_eq : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> minuspf p q = minuspf (pX a p) (pX b q). intros a b p q H' Z; try assumption. rewrite (minusP_inv3a a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3b_eq : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> pX (minusTerm (A:=A) minusA (n:=n) a b) (minuspf p q) = minuspf (pX a p) (pX b q). intros a b p q H' Z; try assumption. rewrite (minusP_inv3b a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv1 : forall (a b : Term A n) (p q : list (Term A n)), ltT ltM b a -> eqP A eqA n (pX a (minuspf p (pX b q))) (minuspf (pX a p) (pX b q)). intros a b p q H'; try assumption. rewrite (minusP_inv1 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv2 : forall (a b : Term A n) (p q : list (Term A n)), ltT ltM a b -> eqP A eqA n (pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q)) (minuspf (pX a p) (pX b q)). intros a b p q H'; try assumption. rewrite (minusP_inv2 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3a : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> eqP A eqA n (minuspf p q) (minuspf (pX a p) (pX b q)). intros a b p q H' Z; try assumption. rewrite (minusP_inv3a a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3b : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> eqP A eqA n (pX (minusTerm (A:=A) minusA (n:=n) a b) (minuspf p q)) (minuspf (pX a p) (pX b q)). 
Proof with auto with typeclass_instances. intros x y Fy Hlt. apply round_DN_pt... apply Rnot_lt_le. contradict Hlt. apply RIneq.Rle_not_lt. apply round_UP_pt... now apply Rlt_le. Qed. Theorem round_UP_le_gt_DN : forall x y, F y -> (round beta fexp Zfloor x < y -> round beta fexp Zceil x <= y)%R. Proof with auto with typeclass_instances. intros x y Fy Hlt. apply round_UP_pt... apply Rnot_lt_le. contradict Hlt. apply RIneq.Rle_not_lt. apply round_DN_pt... now apply Rlt_le. Qed.Theorem pred_UP_le_DN : forall x, (pred (round beta fexp Zceil x) <= round beta fexp Zfloor x)%R. Proof with auto with typeclass_instances. intros x. destruct (generic_format_EM beta fexp x) as [Fx|Fx]. rewrite !round_generic... apply pred_le_id. case (Req_dec (round beta fexp Zceil x) 0); intros Zx. rewrite Zx; unfold pred; rewrite Ropp_0. unfold succ; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l; unfold ulp; rewrite Req_bool_true; trivial. case negligible_exp_spec'. intros (H1,H2). contradict Zx; apply round_neq_0_negligible_exp... intros L; apply Fx; rewrite L; apply generic_format_0. intros (n,(H1,Hn)); rewrite H1. case (Rle_or_lt (- bpow (fexp n)) (round beta fexp Zfloor x)); trivial; intros K. absurd (round beta fexp Zceil x <= - bpow (fexp n))%R. apply Rlt_not_le. rewrite Zx, <- Ropp_0. apply Ropp_lt_contravar, bpow_gt_0. apply round_UP_le_gt_DN; try assumption. apply generic_format_opp, generic_format_bpow. now apply valid_exp. assert (let u := round beta fexp Zceil x in pred u < u)%R as Hup. now apply pred_lt_id. apply le_round_DN_lt_UP... apply generic_format_pred... now apply round_UP_pt. Qed.Theorem pred_UP_eq_DN : forall x, ~ F x -> (pred (round beta fexp Zceil x) = round beta fexp Zfloor x)%R. Proof with auto with typeclass_instances. intros x Fx. apply Rle_antisym. now apply pred_UP_le_DN. apply le_pred_lt; try apply generic_format_round... pose proof round_DN_UP_lt _ _ _ Fx as HE. now apply Rlt_trans with (1 := proj1 HE) (2 := proj2 HE). Qed.Theorem succ_DN_eq_UP : forall x, ~ F x -> (succ (round beta fexp Zfloor x) = round beta fexp Zceil x)%R. Proof with auto with typeclass_instances. intros x Fx. rewrite <- pred_UP_eq_DN; trivial. rewrite succ_pred; trivial. apply generic_format_round... Qed.Theorem round_DN_eq_betw: forall x d, F d -> (d <= x < succ d)%R -> round beta fexp Zfloor x = d. Proof with auto with typeclass_instances. intros x d Fd (Hxd1,Hxd2). generalize (round_DN_pt beta fexp x); intros (T1,(T2,T3)). apply sym_eq, Rle_antisym. now apply T3. destruct (generic_format_EM beta fexp x) as [Fx|NFx]. rewrite round_generic... apply succ_le_inv; try assumption. apply succ_le_lt; try assumption. apply generic_format_succ... apply succ_le_inv; try assumption. rewrite succ_DN_eq_UP; trivial. apply round_UP_pt... apply generic_format_succ... now left. Qed. Theorem round_UP_eq_betw: forall x u, F u -> (pred u < x <= u)%R -> round beta fexp Zceil x = u. 
H. - destruct a; simpl. destruct (string_dec s name); subst. + simpl. destruct (string_dec name name); try congruence. rewrite find_subtree_head in H. inversion H; eauto. + simpl. destruct (string_dec s name); try congruence. unfold find_subtree in IHl at 2; simpl. case_eq (update_subtree ([name] ++ path) subtree (TreeDir n l)); intros. eapply IHl; eauto. rewrite find_subtree_head_ne in H; eauto. eapply IHl; eauto. rewrite find_subtree_head_ne in H; eauto. Qed. Lemma find_subtree_update_trim_head: forall name path subtree tree subtree_head, find_subtree [name] tree = Some subtree_head -> find_subtree [name] (update_subtree ([name] ++ path) subtree tree) = Some (update_subtree path subtree subtree_head). Proof. intros. case_eq tree; intros. - exfalso. subst. unfold find_subtree in H; simpl. inversion H. - erewrite update_subtree_update_trim_head_dir; eauto. subst; eauto. Qed. Lemma update_subtree_update_trim_head_ne: forall tree name s path subtree, s <> name -> find_subtree [name] (update_subtree (s::path) subtree tree) = find_subtree [name] tree. Proof. intros; simpl. destruct tree; subst; eauto. induction l; subst; simpl in *; eauto. destruct a; simpl. unfold find_subtree_helper at 1; simpl. destruct (string_dec s0 s); subst; simpl. + destruct (string_dec s name); simpl in *; try congruence. + destruct (string_dec s name); simpl in *; try congruence. destruct (string_dec s0 name); try congruence. Qed. Lemma find_subtree_update_subtree_child: forall path suffix tree subtree subtree_child, find_subtree path tree = Some subtree_child -> find_subtree path (update_subtree (path++suffix) subtree tree) = Some (update_subtree suffix subtree subtree_child). Proof. induction path; intros; subst; auto. - rewrite app_nil_l. simpl in *. inversion H; eauto. - rewrite cons_app in *. eapply find_subtree_app' in H. deex. erewrite find_subtree_app with (subtree := (update_subtree (path ++ suffix) subtree subtree_base)). eapply IHpath; eauto. eapply find_subtree_update_trim_head; eauto. Qed. Lemma find_subtree_update_trim: forall p1 p2 a tree elem subtree d, find_subtree [a] tree = Some subtree -> find_subtree p2 subtree = Some d -> find_subtree p1 (update_subtree p2 elem subtree) = find_subtree p1 subtree -> find_subtree (a :: p1) (update_subtree (a::p2) elem tree) = find_subtree (a :: p1) tree. Proof. intros. destruct tree. - rewrite cons_app. erewrite find_subtree_app. 2: eauto. erewrite find_subtree_app. 2: eauto. reflexivity. - rewrite cons_app. erewrite find_subtree_app. erewrite find_subtree_app. 2: eauto. eauto. setoid_rewrite cons_app at 2. erewrite find_subtree_update_subtree_child; eauto. Qed. Theorem find_subtree_update_subtree_oob'' : forall pn tree a subtree, pn <> nil -> (~ pathname_prefix [a] pn) -> find_subtree [a] (update_subtree pn subtree tree) = find_subtree [a] tree. Proof. intros. destruct pn; try congruence. destruct (string_dec a s); subst. + exfalso. eapply H0. unfold pathname_prefix. eexists pn. eauto. + erewrite update_subtree_update_trim_head_ne; eauto. Qed. Theorem find_subtree_update_subtree_none : forall tree a suffix subtree, find_subtree [a] tree = None -> find_subtree [a] (update_subtree ([a]++suffix) subtree tree) = None. 
s; extensionality v. remember (string_eq s (ds __ (S n))) as sn; destruct sn. - destruct (dropPs _ _ _); auto. apply string_eq_dec_eq in Heqsn; subst. unfold dropI; rewrite string_eq_true; auto. - destruct (dropPs _ _ _); auto. apply string_eq_dec_neq in Heqsn. unfold dropI; rewrite string_eq_dec_false; auto. Qed. Lemma dropPs_disj: forall ds1 ds2 dom1 dom2, DisjList dom1 ds2 -> DisjList dom2 ds1 -> DisjLabelMap (dropPs ds1) (dropPs ds2) dom1 dom2. Proof. unfold DisjLabelMap; intros; split; unfold EquivalentLabelMapElem, compLabelMaps; intros. - remember (dropPs ds2 s v) as dv; destruct dv. + apply eq_sym, dropPs_Some in Heqdv; dest; subst; auto. + exfalso; apply eq_sym, dropPs_None in Heqdv. specialize (H s); destruct H; auto. - remember (dropPs ds2 s v) as dv; destruct dv; auto. apply eq_sym, dropPs_Some in Heqdv; dest; subst. remember (dropPs ds1 s s0) as ds; destruct ds. + apply eq_sym, dropPs_Some in Heqds; dest; subst; auto. + exfalso; apply eq_sym, dropPs_None in Heqds. specialize (H0 s); destruct H0; auto. Qed.End LabelDrop.Section StepToRefinement. Variable imp spec: Modules. Variable p: MethsT -> MethsT. Variable ruleMap: RegsT -> string -> option string. Variable theta: RegsT -> RegsT. Variable thetaInit: theta (initRegs (getRegInits imp)) = initRegs (getRegInits spec). Definition liftPLabel o l := match l with | {| annot := a; defs := dfs; calls := clls |} => {| annot := match a with | Some (Some r) => Some (ruleMap o r) | Some None => Some None | None => None end; defs := p dfs; calls := p clls |} end. Variable stepMap: forall o u l, reachable o imp -> Step imp o u l -> exists uspec, Step spec (theta o) uspec (liftPLabel o l) /\ theta (M.union u o) = M.union uspec (theta o). Theorem stepRefinement': forall s sig, Behavior imp s sig -> exists sigSpec, Behavior spec (theta s) sigSpec /\ equivalentLabelSeq p sig sigSpec. Proof. intros. dependent induction H. dependent induction HMultistepBeh; subst. - exists nil; rewrite thetaInit; repeat constructor. - specialize (IHHMultistepBeh thetaInit stepMap eq_refl). assert (reachable n imp) by (eexists; constructor; eauto). pose proof (stepMap H HStep) as [uSpec [stepSpec upd]]. destruct IHHMultistepBeh as [sigSpec [behSpec eqv]]. inversion behSpec; subst. pose proof (BehaviorIntro (Multi HMultistepBeh0 stepSpec)) as sth. rewrite <- upd in sth. exists (liftPLabel n l :: sigSpec). constructor. + intuition. + constructor. * unfold equivalentLabel, liftPLabel; simpl. destruct l; destruct annot; simpl; intuition. destruct o; simpl; intuition. * intuition. Qed. Theorem stepRefinement: traceRefines p imp spec. 
:= list (K * V). Definition alist_remove (k : K) (m : alist) : alist := List.filter (fun x => negb (k ?[ R ] (fst x))) m. Definition alist_add (k : K) (v : V) (m : alist) : alist := (k, v) :: alist_remove k m. Fixpoint alist_find (k : K) (m : alist) : option V := match m with | nil => None | (k',v) :: ms => if k ?[ R ] k' then Some v else alist_find k ms end. Definition alist_find' (k: K) : alist -> option V := fmap snd ∘ find (rel_dec k ∘ fst). Lemma alist_find_alt (m: alist) : forall k: K, alist_find k m = alist_find' k m. Proof. induction m; intuition. unfold alist_find', compose. simpl. destruct (k ?[ R ] a0) eqn:Heq; [intuition|]. rewrite IHm. reflexivity. Qed. Section fold. Import MonadNotation. Local Open Scope monad_scope. Variables T : Type. Variable f : K -> V -> T -> T. Fixpoint fold_alist (acc : T) (map : alist) : T := match map with | nil => acc | (k,v) :: m => let acc := f k v acc in fold_alist acc m end. Definition fold_alist' : T -> alist -> T := flip $ fold_left (flip $ uncurry f). Lemma fold_alist_alt (map: alist) : forall acc: T, fold_alist acc map = fold_alist' acc map. Proof. induction map; intuition. simpl. rewrite IHmap. reflexivity. Qed. End fold. Definition alist_union (m1 m2 : alist) : alist := fold_alist alist_add m2 m1. Global Instance Map_alist : Map K V alist := { empty := nil ; add := @alist_add ; remove := alist_remove ; lookup := alist_find ; union := @alist_union }. Section proofs. Hypothesis RDC_K : RelDec_Correct RD_K. Hypothesis Refl : Reflexive R. Hypothesis Sym : Symmetric R. Hypothesis Trans : Transitive R. Definition mapsto_alist (m : alist) k v : Prop := alist_find k m = Some v. Lemma mapsto_alist_cons : forall k v m k' v', mapsto_alist ((k',v') :: m) k v <-> ( (mapsto_alist m k v /\ ~R k k') \/ (R k k' /\ v = v')). Proof. unfold mapsto_alist; intuition; simpl in *. { consider (k ?[ R ] k'); intros. { right. inversion H0; auto. } { left. auto. } } { consider (k ?[ R ] k'); intros; intuition. } { consider (k ?[ R ] k'); intros; intuition. congruence. } Qed. Theorem mapsto_lookup_alist : forall (k : K) (v : V) (m : list (K * V)), lookup k m = Some v <-> mapsto_alist m k v. 
Require Import abp_base. Require Import abp_defs. Require Import abp_lem1.Theorem Lem1 : D + (fun d : D => seq (ia D r1 d) (X1 d)) = X. unfold X at 1 in |- *. elim ProcS; elim ProcR. elim EXPH4. elim LmerSn. elim LmerK. elim LmerL. elim LmerRn. elim CommLRn. elim CommKL. elim CommKRn. elim CommSnK. elim CommSnL. elim CommSnRn. repeat elim A6. elim (A6 (D + (fun d : D => seq (ia D r1 d) (enc H (mer (seq (Sn_d d e0) (seq (Sn e1) (S i))) (mer (K i) (mer (L i) (seq (Rn e1) (seq (Rn e0) (R i)))))))))). unfold X1 in |- *. pattern (R i) at 1 in |- *. elim ProcR. apply refl_equal. Qed. Theorem Lem2 : D + (fun d : D => seq (ia D r1 d) (Y1 d)) = Y. unfold Y in |- *. elim ProcS. elim EXPH4. elim LmerSn. elim LmerK. elim LmerL. elim LmerRn. elim CommLRn. elim CommKL. elim CommKRn. elim CommSnK. elim CommSnL. elim CommSnRn. repeat elim A6. elim (A6 (D + (fun d : D => seq (ia D r1 d) (enc H (mer (seq (Sn_d d e1) (seq (Sn e0) (seq (Sn e1) (S i)))) (mer (K i) (mer (L i) (seq (Rn e0) (R i))))))))).unfold Y1 in |- *. pattern (S i) at 1 in |- *. elim ProcS. apply refl_equal. Qed. Theorem Lem3 : forall d : D, seq (ia Frame c2 (Tuple e0 d)) (enc H (mer (seq (Tn_d d e0) (seq (Sn e1) (S i))) (mer (seq (alt (seq (ia one int i) (ia Frame s3 (Tuple e0 d))) (seq (ia one int i) (ia Frame s3 lce))) (K i)) (mer (L i) (R i))))) = X1 d. 
: forall x : E, { y | op_is_inv x y } := fun x => Monoid.op_neg_strong op_monoid x (op_inv_ex x). Definition op_neg : E -> E := fun x => Monoid.op_neg op_monoid x (op_inv_ex x).Notation "{-}" := (op_neg) : group_scope.Notation "- x" := (op_neg x) : group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof fun x => Monoid.op_neg_def op_monoid x (op_inv_ex x).Theorem op_neg_inj : is_injective E E op_neg. Proof fun x y => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y). Theorem op_cancel_neg : forall x : E, - (- x) = x. Proof fun x => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)). Theorem op_neg_onto : is_onto E E {-}. Proof fun x => ex_intro (fun y => - y = x) (- x) (op_cancel_neg x). Theorem op_neg_bijective : is_bijective E E {-}. Proof conj op_neg_inj op_neg_onto. Theorem op_neg_rev : forall x y : E, - x = y -> - y = x. Proof fun x y H => eq_sym (f_equal {-} H || a = - y @a by <- op_cancel_neg x). Theorem op_neg_distrib_inv_l : forall x y : E, op_is_inv_l (x + y) (- y + - x). Proof fun x y => ((proj2 (op_neg_def (- y))) || - y + a = 0 @a by <- op_cancel_neg y || - y + a = 0 @a by op_id_l y || - y + (a + y) = 0 @a by proj2 (op_neg_def (- x)) || - y + ((- x + a) + y) = 0 @a by <- op_cancel_neg x || - y + a = 0 @a by op_is_assoc (- x) x y || a = 0 @a by <- op_is_assoc (- y) (- x) (x + y)). Theorem op_neg_distrib_inv_r : forall x y : E, op_is_inv_r (x + y) (- y + - x). Proof fun x y => ((proj2 (op_neg_def x)) || x + a = 0 @a by op_id_l (- x) || x + (a + - x) = 0 @a by proj2 (op_neg_def y) || x + a = 0 @a by op_is_assoc y (- y) (- x) || a = 0 @a by <- op_is_assoc x y (- y + - x)). Theorem op_neg_distrib_inv : forall x y : E, op_is_inv (x + y) (- y + - x). Proof fun x y => conj (op_neg_distrib_inv_l x y) (op_neg_distrib_inv_r x y). Theorem op_neg_distrib : forall x y : E, - (x + y) = - y + - x. 
forall (x : Z) (Hx : (0 < x)%Z), nat. intros [| px| px] Hx; try abstract (discriminate Hx). exact (pred (nat_of_P px)). Defined.Lemma pred_nat_equal : forall (x : Z) (Hx1 Hx2 : (0 < x)%Z), pred_nat x Hx1 = pred_nat x Hx2. Proof. intros [| px| px] Hx1 Hx2; try (discriminate Hx1); trivial. Qed.Let pred_nat_unfolded_subproof px : Pos.to_nat px <> 0. Proof. apply sym_not_equal; apply lt_O_neq; apply lt_O_nat_of_P. Qed.Lemma pred_nat_unfolded : forall (x : Z) (Hx : (0 < x)%Z), x = S (pred_nat x Hx). Proof. intros [| px| px] Hx; try discriminate Hx. unfold pred_nat in |- *. rewrite S_predn. symmetry in |- *; apply ZL9. clear Hx; apply pred_nat_unfolded_subproof. Qed.Lemma absolu_pred_nat : forall (m : Z) (Hm : (0 < m)%Z), S (pred_nat m Hm) = Z.abs_nat m. Proof. intros [| px| px] Hx; try discriminate Hx. unfold pred_nat in |- *. rewrite S_predn. reflexivity. apply pred_nat_unfolded_subproof. Qed.Lemma pred_nat_absolu : forall (m : Z) (Hm : (0 < m)%Z), pred_nat m Hm = Z.abs_nat (m - 1). Proof. intros [| px| px] Hx; try discriminate Hx. unfold pred_nat in |- *. rewrite <- pred_absolu; reflexivity || assumption. Qed.Lemma minus_pred_nat : forall (n m : Z) (Hn : (0 < n)%Z) (Hm : (0 < m)%Z) (Hnm : (0 < n - m)%Z), S (pred_nat n Hn) - S (pred_nat m Hm) = S (pred_nat (n - m) Hnm). Proof. intros. simpl in |- *. destruct n; try discriminate Hn. destruct m; try discriminate Hm. unfold pred_nat at 1 2 in |- *. rewrite minus_pred; try apply lt_O_nat_of_P. apply eq_inj. rewrite <- pred_nat_unfolded. rewrite Znat.inj_minus1. repeat rewrite ZL9. reflexivity. apply le_inj. apply Zlt_le_weak. repeat rewrite ZL9. apply Zlt_O_minus_lt. assumption. Qed.Lemma Zsgn_1 : forall x : Z, {Z.sgn x = 0%Z} + {Z.sgn x = 1%Z} + {Z.sgn x = (-1)%Z}. Proof. intros. case x. left. left. unfold Z.sgn in |- *. reflexivity. intro. simpl in |- *. left. right. reflexivity. intro. right. simpl in |- *. reflexivity. Qed. Lemma Zsgn_2 : forall x : Z, Z.sgn x = 0%Z -> x = 0%Z. Proof. intros [| p1| p1]; simpl in |- *; intro H; constructor || discriminate H. Qed. Lemma Zsgn_3 : forall x : Z, x <> 0%Z -> Z.sgn x <> 0%Z. Proof. intro. case x. intros. apply False_ind. apply H. reflexivity. intros. simpl in |- *. discriminate. intros. simpl in |- *. discriminate. Qed. Theorem Zsgn_4 : forall a : Z, a = (Z.sgn a * Z.abs_nat a)%Z. 
as Hin'. eapply reset_insts_in in Hin as (me_x & ? & ?); eauto. * exists me_x; split; auto. eapply IH; eauto. * apply not_None_is_Some; eauto. - inversion_clear 1 as [????? Find' ? Insts]; rewrite Find' in Find; inv Find. econstructor; eauto. + eapply call_reset_state_closed_lasts; eauto. + intros * Sub. eapply call_reset_inv in Rst as (Rst & ?); eauto; apply translate_reset_comp in Rst as (?& Rst). pose proof Rst. eapply find_inst_reset_insts_inv in Rst as [Hin|]; eauto. apply InMembers_In in Hin as (b' & Hin). eapply Ordered_systems_find_In_systems in Ord as (?&?& Find); eauto. pose proof Hin as Hin'. eapply reset_insts_in in Hin as (me_x & ? & Sub'); eauto. * eexists; split; eauto. rewrite Sub' in Sub; inv Sub. eapply IH; eauto. rewrite find_inst_add_mems. destruct (find_inst i me) eqn: E; [|eapply state_closed_empty; eauto]. apply Insts in E as (b'' &?&?). assert (b' = b'') as ->; auto. eapply NoDupMembers_det in Hin'; eauto. apply s_nodup_subs. * apply not_None_is_Some; eauto. Qed. Lemma reset_insts_exists: forall s P me ve, (forall me' f s' P', find_system f P = Some (s', P') -> exists me'', stmt_call_eval (translate P) me' f reset [] me'' []) -> (forall i g, In (i, g) s.(s_subs) -> exists s P', find_system g P = Some (s, P')) -> exists me', stmt_eval (translate (P)) me ve (reset_insts s.(s_subs)) (me', ve). Proof. unfold reset_insts. intro; induction s.(s_subs) as [|(x, b')]; simpl in *; intros * IH Spec; eauto using stmt_eval. setoid_rewrite stmt_eval_fold_left_lift. edestruct Spec as (?&?& Find); eauto. eapply IH in Find as (?&?). edestruct IHl; eauto 7. do 3 eexists; split; eauto. econstructor; eauto. change ve with (Env.adds_opt [] [] ve). econstructor; eauto. Qed. Lemma reset_exists: forall P f s P' me, Ordered_systems P -> find_system f P = Some (s, P') -> exists me', stmt_call_eval (translate P) me f reset [] me' []. Proof. induction P as [|system]; try now inversion 2. intros * Ord Find. pose proof Find as Find'; apply find_system_translate in Find' as (?&?& Find' &?&?); subst. simpl in Find; destruct (ident_eqb (s_name system) f) eqn: E. - inv Find. edestruct reset_insts_exists; eauto using Ordered_systems. + inv Ord; eauto. + eapply Ordered_systems_find_In_systems; eauto. simpl; now rewrite ident_eqb_refl. + eexists; econstructor; eauto. * apply exists_reset_method. * simpl; auto. * simpl; rewrite Env.adds_opt_nil_nil. apply translate_reset_comp; split; eauto. apply reset_mems_spec. * simpl; auto. - simpl; inv Ord. edestruct IHP; eauto. eexists; rewrite stmt_call_eval_cons; eauto. apply ident_eqb_neq in E; auto. Qed. Theorem reset_spec: forall P me f s P', Ordered_systems P -> find_system f P = Some (s, P') -> exists me', stmt_call_eval (translate P) me f reset [] me' [] /\ initial_state P f me' /\ (state_closed P f me -> state_closed P f me'). 
f init nil) = evalExpr init); utila_sem_foldr_cons_correct : forall (j k : Kind) (f : j @# type -> k @# type -> k @# type) (init : k @# type) (x0 : utila_m utila_sem_m j) (xs : list (utila_m utila_sem_m j)), (utila_sem_interp k (utila_mfoldr f init (x0 :: xs)) = (evalExpr (f (Var type (SyntaxKind j) (utila_sem_interp j x0)) (Var type (SyntaxKind k) (utila_sem_interp k (utila_mfoldr f init xs)))))) }. Arguments utila_sem_interp {u} {k} x. Arguments utila_sem_bind_correct {u} {j} {k} x f. Arguments utila_sem_unit_correct {u} {k} x. Arguments utila_sem_foldr_nil_correct {u} {j} {k}. Arguments utila_sem_foldr_cons_correct {u} {j} {k}. Section monad_ver. Import EqIndNotations. Variable sem : utila_sem_type. Let monad : utila_monad_type type := utila_sem_m sem. Let m := utila_m monad. Let mbind := utila_mbind monad. Let munit := utila_munit monad. Local Notation "{{ X }}" := (evalExpr X). Local Notation "[[ X ]]" := (@utila_sem_interp sem _ X). Local Notation "#{{ X }}" := (Var type (SyntaxKind _) {{X}}). Local Notation "#[[ X ]]" := (Var type (SyntaxKind _) [[X]]). Hint Rewrite (@utila_sem_bind_correct sem) (@utila_sem_unit_correct sem) (@utila_sem_foldr_cons_correct sem) (@utila_sem_unit_correct sem) : utila_sem_rewrite_db. Let utila_is_true (x : m Bool) : Prop := [[x]] = true. Lemma utila_mall_nil : [[utila_mall ([] : list (m Bool))]] = true. Proof utila_sem_foldr_nil_correct (fun x acc => x && acc) (Const type true). Lemma utila_mall_cons : forall (x0 : m Bool) (xs : list (m Bool)), [[utila_mall (x0 :: xs)]] = andb [[x0]] [[utila_mall xs]]. Proof utila_sem_foldr_cons_correct (fun x acc => x && acc) (Const type true). Theorem utila_mall_correct : forall xs : list (m Bool), [[utila_mall xs]] = true <-> Forall utila_is_true xs. Proof. intro. split. - induction xs. + intro; exact (Forall_nil utila_is_true). + intro H; assert (H0 : [[a]] = true /\ [[utila_mall xs]] = true). apply (@andb_prop [[a]] [[utila_mall xs]]). rewrite <- (utila_mall_cons a xs). assumption. apply (Forall_cons a). apply H0. apply IHxs; apply H0. - apply (Forall_ind (fun ys => [[utila_mall ys]] = true)). + apply utila_mall_nil. + intros y0 ys H H0 F. rewrite utila_mall_cons. apply andb_true_intro. auto. Qed. Lemma utila_many_nil : [[utila_many ([] : list (m Bool)) ]] = false. Proof utila_sem_foldr_nil_correct (fun x acc => (@Kor _ Bool) [x; acc]) (Const type false). Lemma utila_many_cons : forall (x0 : m Bool) (xs : list (m Bool)), [[utila_many (x0 :: xs)]] = orb [[x0]] [[utila_many xs]]. Proof utila_sem_foldr_cons_correct (fun x acc => (@Kor _ Bool) [x; acc]) (Const type false). Theorem utila_many_correct : forall xs : list (m Bool), [[utila_many xs]] = true <-> Exists utila_is_true xs. 
( is : isaprop X ) : isofhlevel (S n) X. Proof. intros n X X0. simpl. unfold isaprop in X0. simpl in X0. intros x x' . apply isofhlevelcontr. apply (X0 x x'). Defined. Lemma iscontraprop1 { X : UU } ( is : isaprop X ) ( x : X ) : iscontr X . Proof. intros . unfold iscontr. split with x . intro t . unfold isofhlevel in is . set (is' := is t x ). apply ( pr1 is' ). Defined. Lemma iscontraprop1inv { X : UU } ( f : X -> iscontr X ) : isaprop X . Proof. intros X X0. assert ( H : X -> isofhlevel (S O) X). intro X1. apply (hlevelntosn O _ ( X0 X1 ) ) . apply ( isofhlevelsn O H ) . Defined.Lemma proofirrelevance ( X : UU ) ( is : isaprop X ) : forall x x' : X , paths x x' . Proof. intros . unfold isaprop in is . unfold isofhlevel in is . apply ( pr1 ( is x x' ) ). Defined. Lemma invproofirrelevance ( X : UU ) ( ee : forall x x' : X , paths x x' ) : isaprop X. Proof. intros . unfold isaprop. unfold isofhlevel . intro x . assert ( is1 : iscontr X ). split with x. intro t . apply ( ee t x). assert ( is2 : isaprop X). apply isapropifcontr. assumption. unfold isaprop in is2. unfold isofhlevel in is2. apply (is2 x). Defined. Lemma isweqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) : isweq f. Proof. intros. assert (isx0: forall x:X, paths (g (f x)) x). intro. apply proofirrelevance . apply isx . assert (isy0 : forall y : Y, paths (f (g y)) y). intro. apply proofirrelevance . apply isy . apply (gradth f g isx0 isy0). Defined. Definition weqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) := weqpair _ ( isweqimplimpl f g isx isy ) .Theorem isapropempty: isaprop empty. Proof. unfold isaprop. unfold isofhlevel. intros x x' . destruct x. Defined. Theorem isapropifnegtrue { X : UU } ( a : X -> empty ) : isaprop X . 
as [HBA|HAB]; [left|right]; intro HC; destruct (HCAB HC) as [HA|HB]; [ | apply HBA | apply HAB | ]; assumption. intros Distr A B. destruct (Distr A B (A\/B)) as [HABA|HABB]. intro HAB; exact HAB. right; intro HB; apply HABA; right; assumption. left; intro HA; apply HABB; left; assumption. Qed.Lemma Godel_Dummett_weak_excluded_middle : GodelDummett -> weak_excluded_middle. Proof. intros GD A. destruct (GD (~A) A) as [HnotAA|HAnotA]. left; intro HnotA; apply (HnotA (HnotAA HnotA)). right; intro HA; apply (HAnotA HA HA). Qed.Definition IndependenceOfGeneralPremises := forall (A:Type) (P:A -> Prop) (Q:Prop), inhabited A -> (Q -> exists x, P x) -> exists x, Q -> P x.Lemma independence_general_premises_right_distr_implication_over_disjunction : IndependenceOfGeneralPremises -> RightDistributivityImplicationOverDisjunction. Proof. intros IP A B C HCAB. destruct (IP bool (fun b => if b then A else B) C true) as ([|],H). intro HC; destruct (HCAB HC); [exists true|exists false]; assumption. left; assumption. right; assumption. Qed.Lemma independence_general_premises_Godel_Dummett : IndependenceOfGeneralPremises -> GodelDummett. Proof. destruct Godel_Dummett_iff_right_distr_implication_over_disjunction. auto using independence_general_premises_right_distr_implication_over_disjunction. Qed.Definition DrinkerParadox := forall (A:Type) (P:A -> Prop), inhabited A -> exists x, (exists x, P x) -> P x.Lemma independence_general_premises_drinker : IndependenceOfGeneralPremises <-> DrinkerParadox. Proof. split. intros IP A P InhA; apply (IP A P (exists x, P x) InhA); intro Hx; exact Hx. intros Drinker A P Q InhA H; destruct (Drinker A P InhA) as (x,Hx). exists x; intro HQ; apply (Hx (H HQ)). Qed.Definition generalized_excluded_middle := forall A B:Prop, A \/ (A -> B).Lemma excluded_middle_independence_general_premises : generalized_excluded_middle -> DrinkerParadox. Proof. intros GEM A P x0. destruct (GEM (exists x, P x) (P x0)) as [(x,Hx)|Hnot]. exists x; intro; exact Hx. exists x0; exact Hnot. Qed.Require Import Coq.Arith.PeanoNat.Definition Minimal (P:nat -> Prop) (n:nat) : Prop := P n /\ forall k, P k -> n<=k.Definition Minimization_Property (P : nat -> Prop) : Prop := forall n, P n -> exists m, Minimal P m.Section Unrestricted_minimization_entails_excluded_middle. Hypothesis unrestricted_minimization: forall P, Minimization_Property P. Theorem unrestricted_minimization_entails_excluded_middle : forall A, A\/~A. Proof. intros A. pose (P := fun n:nat => n=0/\A \/ n=1). assert (P 1) as h. { unfold P. intuition. } assert (P 0 <-> A) as p₀. { split. + intros [[_ h₀]|[=]]. assumption. + unfold P. tauto. } apply unrestricted_minimization in h as ([|[|m]] & hm & hmm). + intuition. + right. intros HA. apply p₀, hmm, PeanoNat.Nat.nle_succ_0 in HA. assumption. + destruct hm as [([=],_) | [=] ]. Qed.End Unrestricted_minimization_entails_excluded_middle.Require Import Wf_nat.Section Excluded_middle_entails_unrestricted_minimization. Hypothesis em : forall A, A\/~A. Theorem excluded_middle_entails_unrestricted_minimization : forall P, Minimization_Property P. 
inversion H'3. apply Spoly_10 with (Cp := H'2) (Cq := H'1); auto. apply red_com; auto. intros P0 a0 b0 c. case c; case b0; case a0; simpl in |- *. intros x; case x; simpl in |- *; auto. intros c0 x0 c1 x1 c2 H'0 H'1 H'2 H'3 H'4 H'5; elim H'5. intros a1 l c0 x0; case x0; simpl in |- *. intros c1 x1 c2 H'0 H'1 H'2 H'3 H'4 H'5; elim H'5. intros a2 l0 c1 x1; case x1; simpl in |- *. intros c2 H'0 H'1 H'2 H'3 H'4 H'5; elim H'5. intros a3 l1 c2 H'0 H'1 H'2 H'3 H'4 H'5. change (Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P0 (pX a1 l) (pX a2 l0)) in |- *. apply Spoly_11 with (d := a3) (t := l1); auto. change (inPolySet A A0 eqA n ltM (s2p A A0 eqA n ltM (mks A A0 eqA n ltM (pX a3 l1) c2)) P0) in |- *. apply in_inPolySet; simpl in |- *; auto. red in |- *; intros H; inversion H. Qed. Theorem imp_in : forall (P : list (poly A0 eqA ltM)) (a : list (Term A n)), inPolySet A A0 eqA n ltM a P -> exists b : poly A0 eqA ltM, In b P /\ a = s2p A A0 eqA n ltM b. intros P a H'; elim H'; auto. intros a0 p H P0; exists (exist (fun l0 : list (Term A n) => canonical A0 eqA ltM l0) (pX a0 p) H); split; auto. simpl in |- *; auto. intros a0 p P0 H'0 H'1; elim H'1; intros b E; elim E; intros H'2 H'3; clear E H'1; auto. exists b; split; auto with datatypes. Qed. Theorem reds_SpolyQ1 : forall P : list (poly A0 eqA ltM), (forall a b : poly A0 eqA ltM, In a P -> In b P -> reds a b P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P. intros P H'. apply SpolyQ0; auto. intros p q H'0 H'1 H'2 H'3. elim (imp_in P p); [ intros b E; elim E; intros H'7 H'8; clear E | idtac ]; auto. rewrite H'8. elim (imp_in P q); [ intros b0 E; elim E; intros H'9 H'10; clear E | idtac ]; auto. rewrite H'10. apply reds_SpolyQ; auto. Qed. Theorem buch_spolyQ : forall P : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (buch P). 
auto with float; intros H10; clear H12. lapply H10; auto; intros H12; clear H10. lapply H12; [ intros H10 | unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real ]; clear H12. lapply H10; auto; intros H12; clear H10. lapply H12; [ intros H10 | simpl in |- *; auto ]; clear H12. lapply H10; [ intros H12 | idtac ]; clear H10. 2: replace (Fopp p * q)%R with (- (p * q))%R; [ apply MaxOppMin; auto | idtac ]. 2: unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. elim H12; intros r H10; clear H12; elim H10; intros H11 H12; clear H10. elim H12; clear H12; intros H10 H12. exists (Fopp r); split; [ generalize H11 | split; auto with float ]. unfold FtoRradix in |- *; repeat rewrite Fopp_correct; intros H13; rewrite H13; ring. Qed. Theorem errorBoundedMult : forall P, RoundedModeP b radix P -> forall p q f : float, Fbounded b p -> Fbounded b q -> (- dExp b <= Fexp p + Fexp q)%Z -> P (p * q)%R f -> exists r : float, r = (p * q - f)%R :>R /\ Fbounded b r /\ Fexp r = (Fexp p + Fexp q)%Z. intros P H p q f H0 H1 H2 H3. case (Rle_or_lt 0 p); intros H4; case (Rle_or_lt 0 q); intros H5. apply errorBoundedMultPos with P; auto. replace (Fexp p) with (Fexp (Fopp p)); auto with float. replace (Fexp q) with (Fexp (Fopp q)); auto with float. cut ((p * q)%R = (Fopp p * Fopp q)%R); [ intros H6; rewrite H6 | idtac ]. apply errorBoundedMultNeg with P; auto with float real. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. rewrite <- H6; auto. unfold FtoRradix in |- *; repeat rewrite Fopp_correct; ring. apply errorBoundedMultNeg with P; auto with float real. replace (Fexp p) with (Fexp (Fopp p)); auto with float. replace (Fexp q) with (Fexp (Fopp q)); auto with float. cut ((p * q)%R = (Fopp p * Fopp q)%R); [ intros H6; rewrite H6 | idtac ]. apply errorBoundedMultPos with P; auto with float real. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. rewrite <- H6; auto. unfold FtoRradix in |- *; repeat rewrite Fopp_correct; ring. Qed. Theorem errorBoundedMultExp_aux : forall n1 n2 : Z, (Zabs n1 < Zpos (vNum b))%Z -> (Zabs n2 < Zpos (vNum b))%Z -> (exists ny : Z, (exists ey : Z, (n1 * n2)%R = (ny * powerRZ radix ey)%R :>R /\ (Zabs ny < Zpos (vNum b))%Z)) -> exists nx : Z, (exists ex : Z, (n1 * n2)%R = (nx * powerRZ radix ex)%R :>R /\ (Zabs nx < Zpos (vNum b))%Z /\ (0 <= ex)%Z /\ (ex <= precision)%Z). 
t l1)). Proof using. intros a1 l1; elim l1; simpl in |- *; auto. intros b; case b; simpl in |- *; auto. intros l H t; case t; simpl in |- *; auto. intros a H0 H1; rewrite all_pbleaves_pbleaf; simpl in |- *; auto. rewrite all_pbleaves_pbleaf; intros p H0 H1. apply ulist_app; simpl in |- *; auto. intros a H2 [H3| H3]; auto; (case H0; rewrite H3); auto. apply all_pbleaves_inpb; auto. intros p p0 H0 H1; apply ulist_app; auto. apply ulist_app_inv_l with (1 := H1); auto. apply H. Contradict H0; auto. apply ulist_app_inv_r with (1 := H1); auto. intros a H2 H3; case all_pbleaves_pbadd with (1 := H3). intros H4; Contradict H0; rewrite <- H4; apply all_pbleaves_inpb; simpl in |- *; auto with datatypes. intros H4; apply ulist_app_inv with (1 := H1) (a := a); auto. intros l H t; case t; simpl in |- *; auto. intros a H0 H1; rewrite all_pbleaves_pbleaf; simpl in |- *; auto. rewrite all_pbleaves_pbleaf; intros p H0 H1. apply ulist_app; simpl in |- *; auto. intros a [H3| H3] H2; auto; (case H0; rewrite H3); auto. apply all_pbleaves_inpb; auto. intros p p0 H0 H1; apply ulist_app; auto. apply H. Contradict H0; auto. apply ulist_app_inv_l with (1 := H1); auto. apply ulist_app_inv_r with (1 := H1); auto. intros a H2 H3; case all_pbleaves_pbadd with (1 := H2). intros H4; Contradict H0; rewrite <- H4; apply all_pbleaves_inpb; simpl in |- *; auto with datatypes. intros H4; apply ulist_app_inv with (1 := H1) (a := a); auto. Qed. Theorem distinct_pbleaves_pbadd_prop2 : forall a1 l1 l, ~ inpb (pbleaf a1) l -> distinct_pbleaves l -> distinct_pbleaves (pbadd a1 l l1). Proof using. intros a1 l1 l H H0; apply all_pbleaves_unique. apply ulist_pbadd_prop2; auto. apply all_pbleaves_ulist; auto. Qed. Theorem fold_pbadd_prop_left : forall l a, l <> nil -> fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) (map (fun v => match v with | (a1, b1) => (a1, false :: b1) end) l) = pbleft (fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) l). Proof using. intros l; elim l. intros a H; elim H; simpl in |- *; auto. simpl in |- *; intros (a1, l1) l0; case l0. case l1; simpl in |- *; auto. intros p l2 H a H0. rewrite H; auto. red in |- *; intros H1; discriminate. Qed. Theorem fold_pbadd_prop_right : forall l a, l <> nil -> fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) (map (fun v => match v with | (a1, b1) => (a1, true :: b1) end) l) = pbright (fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) l). 
a) :: x)), x0. split. cbn. now rewrite <- app_assoc. now rewrite <- app_assoc, H1. * exists ((M.xelements l (xO j)) ++ x), x0. split; auto. cbn. now rewrite <- app_assoc. now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. rewrite xelements_set_node_xO, !M.xelements_Node. apply IHm with (j := xO j) in H0; destructAll. destruct o as [a|]. * exists x, (x0 ++ ((M.prev j, a)::M.xelements r (xI j))). split; auto. cbn. change ((M.prev_append j (xO i), v') :: x0 ++ (M.prev j, a) :: M.xelements r (xI j)) with (((M.prev_append j (xO i), v') :: nil) ++ x0 ++ (M.prev j, a) :: M.xelements r (xI j)). rewrite H0, !app_assoc. f_equal. now rewrite <- app_assoc. change ((M.prev_append j (xO i), v) :: x0 ++ (M.prev j, a) :: M.xelements r (xI j)) with (((M.prev_append j (xO i), v) :: nil) ++ x0 ++ (M.prev j, a) :: M.xelements r (xI j)). rewrite H1, !app_assoc. cbn. rewrite <- app_assoc. simpl. now rewrite <- (app_assoc x _ x0). * exists x, (x0 ++ M.xelements r (xI j)). split; auto. simpl. now rewrite H0, <- app_assoc. now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. subst o. exists (M.xelements l (xO j)), (M.xelements r (xI j)). rewrite xelements_set_node_xH, !M.xelements_Node. split; auto. Qed. Theorem elements_set_some: forall (A: Type) i v v' (m: M.t A), M.get i m = Some v' -> exists l1 l2, M.elements m = l1 ++ (i, v') :: l2 /\ M.elements (M.set i v m) = l1 ++ (i,v)::l2. Proof. unfold M.elements. intros. eapply xelements_set_some with (j := xH) in H. simpl in H. apply H. Qed. End DES. Section EQMAP. Definition map_get_r: forall t, relation (M.t t) := fun t => fun sub sub' => forall v, M.get v sub = M.get v sub'. Infix " <~m_get~> " := (map_get_r _) (at level 50). Theorem smg_refl: forall t, Reflexive (map_get_r t). Proof. intros; intro; intro; reflexivity. Qed. Theorem smg_sym: forall t, Symmetric (map_get_r t). Proof. intro; intro; intros; intro; auto. Qed. Theorem smg_trans: forall t, Transitive (map_get_r t). Proof. intros t sub sub' sub''. unfold map_get_r. intros. specialize (H v). specialize (H0 v). rewrite H. assumption. Qed. Instance map_get_r_equiv : forall t, Equivalence (map_get_r t). Proof. intro. split; [apply smg_refl | apply smg_sym | apply smg_trans]. Qed.Theorem remove_empty: forall t x, map_get_r t (M.remove x (M.empty t)) (M.empty t). Proof. unfold map_get_r; intros. now rewrite !M.gempty. Qed. Theorem remove_none: forall t v x, M.get x v = None -> map_get_r t (M.remove x v) v. 
Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Monoid.op_inv_uniq prod_monoid. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Monoid.op_has_inv_l_0 prod_monoid. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Monoid.op_has_inv_r_0 prod_monoid. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Monoid.op_has_inv_0 prod_monoid. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Monoid.op_inv_0_eq_0 prod_monoid. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Monoid.op_inv_0_uniq prod_monoid. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_r prod_monoid. Theorem recipr_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_sum_distrib : is_distrib E prod sum. Proof conj prod_sum_distrib_l prod_sum_distrib_r. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof fun x => let H : (0 # x) + (0 # x) = (0 # x) + 0 := eq_refl (0 # x) || a # x = 0 # x @a by (sum_id_l 0) || a = 0 # x @a by <- prod_sum_distrib_r x 0 0 || (0 # x) + (0 # x) = a @a by sum_id_r (0 # x) in sum_cancel_l (0 # x) 0 (0 # x) H. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof fun x => let H : (x # 0) + (x # 0) = 0 + (x # 0) := eq_refl (x # 0) || x # a = x # 0 @a by sum_id_r 0 || a = x # 0 @a by <- prod_sum_distrib_l x 0 0 || (x # 0) + (x # 0) = a @a by sum_id_l (x # 0) in sum_cancel_r (x # 0) 0 (x # 0) H. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof ex_ind (fun x (H : x # 0 = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_r x)). Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof ex_ind (fun x (H : 0 # x = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_l x)). Theorem prod_0_inv : ~ prod_has_inv 0. Proof ex_ind (fun x H => prod_0_inv_l (ex_intro (fun x => prod_is_inv_l 0 x) x (proj1 H))). Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. 
Require Import VST.msl.base. Require Import VST.msl.sepalg. Require Import VST.msl.psepalg. Require Import VST.msl.sepalg_generators. Require Import VST.msl.cjoins. Require Import VST.msl.eq_dec. Definition sa_distributive (A: Type) {JOIN: Join A} := forall a b x z, join a b z -> constructive_join_sub x z -> {a' : A & {b' : A & (constructive_join_sub a' a * constructive_join_sub b' b * join a' b' x)%type}}. Definition weak_cross_split `{sepalg A} := forall a b c d z : A, join a b z -> join c d z -> exists x:(A*A*A*A), match x with (ac,ad,bc,bd) => join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d end. *) Theorem cross_split_distibutive {A} `{Perm_alg A}{SA: Sep_alg A}{CS: Cross_alg A} : sa_distributive A. Proof. intros ? ? ? ? H1 [x0 H2]. destruct (CS _ _ _ _ _ H1 H2) as [[[[? ?] ?] ?] ?]. intuition eauto. exists a0. exists a2. intuition eauto. econstructor; eauto. econstructor; eauto. Qed. Theorem distributive_cross_split {A} `{Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}: sa_distributive A -> Cross_alg A. 
M.gro. reflexivity. assumption. assumption. assumption. Qed. Theorem remove_remove: forall t x y sub, map_get_r t (M.remove x (M.remove y sub)) (M.remove y (M.remove x sub)). Proof. unfold map_get_r; intros. destruct (var_dec v x); destruct (var_dec v y); subst. - subst. reflexivity. - rewrite M.grs. rewrite M.gro. rewrite M.grs. reflexivity. assumption. - rewrite M.gro. rewrite M.grs. rewrite M.grs. reflexivity. assumption. - rewrite M.gro. rewrite M.gro. rewrite M.gro. rewrite M.gro. reflexivity. assumption. assumption. assumption. assumption. Qed.Theorem set_set: forall t e e' x y sub, x <> y -> map_get_r t (M.set x e (M.set y e' sub)) (M.set y e' (M.set x e sub)). Proof. unfold map_get_r; intros. destruct (var_dec v x); destruct (var_dec v y); try (subst x || subst y). - exfalso; auto. - rewrite M.gss. rewrite M.gso. rewrite M.gss. reflexivity. assumption. - rewrite M.gso. rewrite M.gss. rewrite M.gss. reflexivity. assumption. - rewrite M.gso. rewrite M.gso. rewrite M.gso. rewrite M.gso. reflexivity. assumption. assumption. assumption. assumption. Qed. Theorem inv_set: forall t e sub sub' v, map_get_r t (M.remove v sub) (M.remove v sub') -> map_get_r t (M.set v e sub) (M.set v e sub'). Proof. unfold map_get_r; intros. specialize (H v0). destruct (var_dec v0 v). - subst. rewrite 2 M.gss. reflexivity. - rewrite 2 M.gso. rewrite 2 M.gro in H. assumption. assumption. assumption. assumption. assumption. Qed.Theorem set_remove: forall t x e sub, map_get_r t (M.set x e (M.remove x sub)) (M.set x e sub). Proof. unfold map_get_r; intros. destruct (var_dec v x). + subst. rewrite M.gss. rewrite M.gss. reflexivity. + rewrite M.gso. rewrite M.gro. rewrite M.gso. reflexivity. assumption. assumption. assumption. Qed.Theorem proper_remove: forall t v, Proper (map_get_r t ==> map_get_r t) (M.remove v). Proof. intros t v r. unfold map_get_r; intros. destruct (var_dec v0 v). - subst. rewrite 2 M.grs. reflexivity. - rewrite 2 M.gro. apply H. assumption. assumption. Qed.Theorem proper_set: forall t v e, Proper (map_get_r t ==> map_get_r t) (M.set v e). Proof. intros t v e r. unfold map_get_r; intros. destruct (var_dec v0 v). - subst. rewrite 2 M.gss. reflexivity. - rewrite 2 M.gso. apply H. assumption. assumption. Qed.End EQMAP. Section GETD. Definition getd {A:Type} (d:A) := fun v sub => match M.get v sub with | None => d | Some e => e end. Theorem e_getd: forall A (d:A) v sub, exists e, getd d v sub = e. Proof. unfold getd; intros; destruct (M.get v sub); [ exists a; reflexivity | exists d; reflexivity]. Qed. Theorem getd_det: forall A v (a1 a2 d:A) sub, getd d v sub = a1 -> getd d v sub = a2 -> a1 = a2. 
| xH => match m with | Leaf => Leaf | Node Leaf o Leaf => Leaf | Node l o r => Node l None r end | xO ii => match m with | Leaf => Leaf | Node l None Leaf => match remove ii l with | Leaf => Leaf | mm => Node mm None Leaf end | Node l o r => Node (remove ii l) o r end | xI ii => match m with | Leaf => Leaf | Node Leaf None r => match remove ii r with | Leaf => Leaf | mm => Node Leaf None mm end | Node l o r => Node l o (remove ii r) end end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. induction i; simpl; auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x. Proof. induction i; destruct m; simpl; auto. Qed. Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None. Proof. exact gempty. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. induction i; intros; destruct j; destruct m; simpl; try rewrite <- (gleaf A i); auto; try apply IHi; congruence. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then Some x else get i m. Proof. intros. destruct (peq i j); [ rewrite e; apply gss | apply gso; auto ]. Qed. Theorem gsident: forall (A: Type) (i: positive) (m: t A) (v: A), get i m = Some v -> set i v m = m. Proof. induction i; intros; destruct m; simpl; simpl in H; try congruence. rewrite (IHi m2 v H); congruence. rewrite (IHi m1 v H); congruence. Qed. Theorem set2: forall (A: Type) (i: elt) (m: t A) (v1 v2: A), set i v2 (set i v1 m) = set i v2 m. Proof. induction i; intros; destruct m; simpl; try (rewrite IHi); auto. Qed. Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf. Proof. destruct i; simpl; auto. Qed. Theorem grs: forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None. 
Require Export approx.Definition compute_to_same_name {o} lib (a b : @NTerm o) := {n : get_patom_set o & (a =v>(lib) (mk_utoken n)) # (b =v>(lib) (mk_utoken n))}.Definition computes_to_same_name {o} lib (a b : @NTerm o) := forall (n : get_patom_set o), (a =v>(lib) (mk_utoken n)) -> (b =v>(lib) (mk_utoken n)). Definition ex_close_compute_exc {o} lib ex (R: @NTrel o) (tl tr : @NTerm o) : [univ]:= forall a e, (tl =e>(a,lib) e) -> R a ex + {a' : NTerm & {e' : NTerm & (tr =e>(a',lib) e') # R a a' # R e e' }}.Definition ex_close_comput {p} lib ex (R: NTrel) (tl tr : @NTerm p) : [univ]:= isprogram tl # isprogram tr # close_compute_val lib R tl tr # ex_close_compute_exc lib ex R tl tr # close_compute_seq lib R tl tr # True .CoInductive ex_approx_bad {o} : @library o -> @NTerm o -> @NTerm o -> @NTerm o -> [univ] := | ex_approxC: forall lib ex tl tr, ex_close_comput lib ex (ex_approx_bad lib ex) tl tr -> ex_approx_bad lib ex tl tr.CoInductive ex_approx_aux {p} (lib : library) (ex : NTerm) (R : bin_rel NTerm) (tl tr: @NTerm p): [univ] := | ex_approx_fold: ex_close_comput lib ex (ex_approx_aux lib ex R \2/ R) tl tr -> ex_approx_aux lib ex R tl tr.Definition ex_approx {p} lib ex := @ex_approx_aux p lib ex bot2. Theorem ex_approx_acc {p} : forall (lib : library) (ex : NTerm) (l r0 : bin_rel (@NTerm p)) (OBG: forall (r: bin_rel NTerm) (INC: r0 =2> r) (CIH: l =2> r), l =2> ex_approx_aux lib ex r), l =2> ex_approx_aux lib ex r0. 
apply Zlt_reg_mult_l. Flip. assumption. ring. ring. replace (c * b * f)%Z with (f * (c * b))%Z. replace (d * (a * f))%Z with (f * (a * d))%Z. apply Z.lt_gt. apply Zlt_reg_mult_l. Flip. assumption. ring. ring. Qed. Lemma square_pos : forall a : Z, a <> 0%Z -> (0 < a * a)%Z. Proof. intros [| p| p]; intros; [ Falsum | constructor | constructor ]. Qed. Hint Resolve square_pos: zarith. Definition Z2positive (z : Z) := match z with | Zpos p => p | Zneg p => p | Z0 => 1%positive end. Lemma ZL9 : forall p : positive, Z_of_nat (nat_of_P p) = Zpos p. Proof. intro. cut (exists h : nat, nat_of_P p = S h). intro. case H. intros. unfold Z_of_nat in |- *. rewrite H0. apply f_equal with (A := positive) (B := Z) (f := Zpos). cut (P_of_succ_nat (nat_of_P p) = P_of_succ_nat (S x)). intro. rewrite P_of_succ_nat_o_nat_of_P_eq_succ in H1. cut (Pos.pred (Pos.succ p) = Pos.pred (P_of_succ_nat (S x))). intro. rewrite Pos.pred_succ in H2. simpl in H2. rewrite Pos.pred_succ in H2. apply sym_eq. assumption. apply f_equal with (A := positive) (B := positive) (f := Pos.pred). assumption. apply f_equal with (f := P_of_succ_nat). assumption. apply ZL4. Qed.Coercion Z_of_nat : nat >-> Z.Lemma ZERO_lt_POS : forall p : positive, (0 < Zpos p)%Z. Proof. intros. constructor. Qed. Lemma POS_neq_ZERO : forall p : positive, Zpos p <> 0%Z. Proof. intros. apply sym_not_eq. apply Zorder.Zlt_not_eq. apply ZERO_lt_POS. Qed.Lemma NEG_neq_ZERO : forall p : positive, Zneg p <> 0%Z. Proof. intros. apply Zorder.Zlt_not_eq. unfold Z.lt in |- *. constructor. Qed. Lemma POS_resp_eq : forall p0 p1 : positive, Zpos p0 = Zpos p1 -> p0 = p1. Proof. intros. injection H. trivial. Qed.Lemma nat_nat_pos : forall m n : nat, ((m + 1) * (n + 1) > 0)%Z. Proof. intros. apply Z.lt_gt. cut (Z_of_nat m + 1 > 0)%Z. intro. cut (0 < Z_of_nat n + 1)%Z. intro. cut ((Z_of_nat m + 1) * 0 < (Z_of_nat m + 1) * (Z_of_nat n + 1))%Z. rewrite Zmult_0_r. intro. assumption. apply Zlt_reg_mult_l. assumption. assumption. change (0 < Z.succ (Z_of_nat n))%Z in |- *. apply Zle_lt_succ. change (Z_of_nat 0 <= Z_of_nat n)%Z in |- *. apply Znat.inj_le. apply le_O_n. apply Z.lt_gt. change (0 < Z.succ (Z_of_nat m))%Z in |- *. apply Zle_lt_succ. change (Z_of_nat 0 <= Z_of_nat m)%Z in |- *. apply Znat.inj_le. apply le_O_n. Qed. Theorem S_predn : forall m : nat, m <> 0 -> S (pred m) = m. 
simpl in *. replace d with (snd (nwState {| nwPackets := ps'; nwState := st' |} (pDst p))) by (simpl; find_higher_order_rewrite; rewrite_update; reflexivity). eauto. Qed. Lemma log_properties_hold_on_ghost_logs_append_entries_reply : msg_refined_raft_net_invariant_append_entries_reply' log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. find_apply_hyp_hyp; intuition; repeat find_rewrite; try solve [eapply_prop_hyp msg_log_property msg_log_property; eauto]. do_in_map. subst. simpl in *. unfold add_ghost_msg, write_ghost_msg in *. do_in_map. subst. simpl in *. unfold write_ghost_log. simpl in *. replace d with (snd (nwState {| nwPackets := ps'; nwState := st' |} (pDst p))) by (simpl; find_higher_order_rewrite; rewrite_update; reflexivity). eauto. Qed. Lemma log_properties_hold_on_ghost_logs_client_request : msg_refined_raft_net_invariant_client_request' log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. find_apply_hyp_hyp; intuition; repeat find_rewrite; try solve [eapply_prop_hyp msg_log_property msg_log_property; eauto]. do_in_map. subst. simpl in *. unfold add_ghost_msg, write_ghost_msg in *. do_in_map. subst. simpl in *. unfold write_ghost_log. simpl in *. replace d with (snd (nwState {| nwPackets := ps'; nwState := st' |} h)) by (simpl; find_higher_order_rewrite; rewrite_update; reflexivity). eauto. Qed. Lemma log_properties_hold_on_ghost_logs_timeout : msg_refined_raft_net_invariant_timeout' log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. find_apply_hyp_hyp; intuition; repeat find_rewrite; try solve [eapply_prop_hyp msg_log_property msg_log_property; eauto]. do_in_map. subst. simpl in *. unfold add_ghost_msg, write_ghost_msg in *. do_in_map. subst. simpl in *. unfold write_ghost_log. simpl in *. replace d with (snd (nwState {| nwPackets := ps'; nwState := st' |} h)) by (simpl; find_higher_order_rewrite; rewrite_update; reflexivity). eauto. Qed. Lemma log_properties_hold_on_ghost_logs_do_leader : msg_refined_raft_net_invariant_do_leader' log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. find_apply_hyp_hyp; intuition; repeat find_rewrite; try solve [eapply_prop_hyp msg_log_property msg_log_property; eauto]. do_in_map. subst. simpl in *. unfold add_ghost_msg, write_ghost_msg in *. do_in_map. subst. simpl in *. unfold write_ghost_log. simpl in *. replace d' with (snd (nwState {| nwPackets := ps'; nwState := st' |} h)) by (simpl; find_higher_order_rewrite; rewrite_update; reflexivity). eauto. Qed. Lemma log_properties_hold_on_ghost_logs_do_generic_server : msg_refined_raft_net_invariant_do_generic_server' log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. find_apply_hyp_hyp; intuition; repeat find_rewrite; try solve [eapply_prop_hyp msg_log_property msg_log_property; eauto]. do_in_map. subst. simpl in *. unfold add_ghost_msg, write_ghost_msg in *. do_in_map. subst. simpl in *. unfold write_ghost_log. simpl in *. replace d' with (snd (nwState {| nwPackets := ps'; nwState := st' |} h)) by (simpl; find_higher_order_rewrite; rewrite_update; reflexivity). eauto. Qed. Lemma log_properties_hold_on_ghost_logs_reboot : msg_refined_raft_net_invariant_reboot log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. repeat find_reverse_rewrite. eapply_prop_hyp msg_log_property msg_log_property; eauto. Qed. Lemma log_properties_hold_on_ghost_logs_state_same_packet_subset : msg_refined_raft_net_invariant_state_same_packet_subset log_properties_hold_on_ghost_logs. Proof using. red. unfold log_properties_hold_on_ghost_logs. intros. simpl in *. subst. repeat find_reverse_rewrite. eapply_prop_hyp msg_log_property msg_log_property; eauto. Qed. Theorem log_properties_hold_on_ghost_logs_invariant : forall net, msg_refined_raft_intermediate_reachable net -> log_properties_hold_on_ghost_logs net. 
Z.succ. rewrite Hrec. simpl; auto. + simpl; auto. - intros p' Hd; elim Hd;auto. Qed.Theorem check_range_correct : forall (v:Z)(r:nat)(rz:Z), (0 < v)%Z -> Z_of_nat (S r) = rz -> check_range v r rz = true -> ~ (exists k:nat, k <= (S r) /\ k <> 1 /\ (exists q:nat, Z.abs_nat v = q*k)). Proof. intros v r; elim r. - intros rz Hlt H1 H2 Hex; case Hex; intros k; case k. + intros (Hle, (Hne1, (q, Heq))). rewrite mult_comm in Heq; simpl in Heq. rewrite (Zabs_nat_0 _ Heq) in Hlt. elim (Z.lt_irrefl 0); assumption. + intros k' (Hle, (Hne1, (q, Heq))). inversion Hle. assert (H':k'=0). * assumption. * rewrite H' in Hne1; elim Hne1;auto. * assert (H': S k' <= 0) by assumption. inversion H'. - intros r' Hrec rz Hlt H1 H2 Hex; case Hex; intros k; case k. + intros (Hle, (Hne1, (q, Heq))). rewrite mult_comm in Heq; simpl in Heq. rewrite (Zabs_nat_0 _ Heq) in Hlt. elim (Z.lt_irrefl 0); assumption. + intros k' (Hle, (Hne1, (q, Heq))). inversion Hle. rewrite <- H1 in H2. rewrite <- (Z_to_nat_and_back v) in H2. assert (Hmod:(Z_of_nat (Z.abs_nat v) mod Z.of_nat (S (S r')) = 0)%Z). * apply verif_divide. replace 0 with (Z.abs_nat 0%Z). apply Zabs_nat_lt. lia. simpl; auto. auto with arith. exists q. assert (H': k' = S r') by assumption. rewrite <- H';auto. * unfold check_range in H2. rewrite Hmod in H2; discriminate H2. * lia. * unfold check_range in H2; fold check_range in H2. case_eq ((v mod rz)%Z). intros Heqmod. rewrite Heqmod in H2. discriminate H2. intros pmod Heqmod; rewrite Heqmod in H2. elim (Hrec (Z.pred rz) Hlt). rewrite <- H1. rewrite inj_S. rewrite inj_S. rewrite inj_S. rewrite <- Zpred_succ. auto. assumption. exists (S k'). repeat split;auto. exists q; assumption. intros p Hmod. elim (Z_mod_lt v rz). rewrite Hmod. unfold Z.le; simpl; intros Hle'; elim Hle';auto. rewrite <- H1. rewrite inj_S. unfold Z.succ. generalize (Zle_0_nat (S r')). intros; lia. Qed.Theorem nat_of_P_Psucc : forall p:positive, nat_of_P (Pos.succ p) = S (nat_of_P p). Proof. intros p; elim p. - simpl; intros p'; rewrite nat_of_P_xO. intros Heq; rewrite Heq; rewrite nat_of_P_xI; ring. - intros p' Heq; simpl. rewrite nat_of_P_xI. rewrite nat_of_P_xO;auto. - auto. Qed.Theorem nat_to_Z_and_back: forall n:nat, Z.abs_nat (Z.of_nat n) = n. Proof. intros n; elim n. - auto. - intros n'; simpl; case n'. + simpl; auto. + intros n''; simpl; rewrite nat_of_P_Psucc. intros Heq; rewrite Heq; auto. Qed. Theorem check_correct : forall p:nat, 0 < p -> check_primality p = true -> ~(exists k:nat, k <> 1 /\ k <> p /\ (exists q:nat, p = q*k)). 
x. Infix "%=" := equiv (at level 70, no associativity). Definition incl (b1 b2 : bag) : Prop := forall x, (b1 x <= b2 x)%nat. Infix "%<=" := incl (at level 70, no associativity). Definition add (b : bag) (x : A) : bag := fun x' => if eq_dec x' x then S (b x') else b x'. Infix "%+" := add (at level 50, left associativity). Definition del (b : bag) (x : A) : bag := fun x' => if eq_dec x' x then pred (b x') else b x'. Infix "%-" := del (at level 50, left associativity). Ltac bags := subst; repeat match goal with | [ H : _ %= _ |- _ ] => generalize dependent H | [ H : _ %<= _ |- _ ] => generalize dependent H | [ H : _ %in _ |- _ ] => generalize dependent H | [ H : ~ _ %in _ |- _ ] => generalize dependent H | [ H : _ \is _ |- _ ] => generalize dependent H | [ H : @eq W _ _ |- _ ] => generalize dependent H | [ H : ~(@eq W _ _) |- _ ] => generalize dependent H end; clear; unfold equiv, empty, incl, mem, add, del, propToWord, IF_then_else; intuition idtac; repeat (match goal with | [ H : (_, _) = (_, _) |- _ ] => injection H; clear H; intros; subst | [ |- context[if ?E then _ else _] ] => destruct E; subst | [ _ : context[if ?E then _ else _] |- _ ] => destruct E; subst | [ H : forall p : W * W, _ |- _ ] => rewrite H in * end; intuition idtac); try match goal with | [ |- _ \/ _ ] => right; intuition idtac end; repeat match goal with | [ H : forall p : A, _ |- _ ] => rewrite H in * end; auto; try (discriminate || omega). Hint Extern 5 (_ %= _) => bags. Hint Extern 5 (_ %<= _) => bags. Hint Extern 5 (_ %in _) => bags. Hint Extern 5 (~ _ %in _) => bags. Hint Extern 5 (_ \is _) => bags. Theorem equiv_symm : forall b1 b2, b1 %= b2 -> b2 %= b1. bags. Qed. Theorem equiv_trans : forall b1 b2 b3, b1 %= b2 -> b2 %= b3 -> b1 %= b3. 
:= match E2 with | sup A f => EXType _ (fun y : A => EQ E1 (f y)) end. Definition INC : Ens -> Ens -> Prop. intros E1 E2. exact (forall E : Ens, IN E E1 -> IN E E2). Defined.Theorem EQ_refl : forall E : Ens, EQ E E. simple induction E. intros A f HR. simpl in |- *. split; intros. exists x; auto.exists y; auto. Qed.Theorem EQ_tran : forall E1 E2 E3 : Ens, EQ E1 E2 -> EQ E2 E3 -> EQ E1 E3. simple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2; simple induction E3; intros A3 f3 r3; simpl in |- *; intros e1 e2. split; (elim e1; intros I1 I2; elim e2; intros I3 I4). intros a1; elim (I1 a1); intros a2. elim (I3 a2); intros a3. exists a3. apply r1 with (f2 a2); auto. intros a3; elim (I4 a3); intros a2; elim (I2 a2); intros a1; exists a1. apply r1 with (f2 a2); auto. Qed.Theorem EQ_sym : forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1. simple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2; simpl in |- *; simple induction 1; intros e1 e2; split. intros a2; elim (e2 a2); intros a1 H1; exists a1; auto. intros a1; elim (e1 a1); intros a2 H2; exists a2; auto. Qed.Theorem EQ_INC : forall E E' : Ens, EQ E E' -> INC E E'. simple induction E; intros A f r; simple induction E'; intros A' f' r'; simpl in |- *; simple induction 1; intros e1 e2; unfold INC in |- *; simpl in |- *. intros C; simple induction 1; intros a ea; elim (e1 a); intros a' ea'; exists a'. apply EQ_tran with (f a); assumption. Qed.Hint Resolve EQ_sym EQ_refl EQ_INC: zfc.Theorem INC_EQ : forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'. simple induction E; intros A f r; simple induction E'; intros A' f' r'; unfold INC in |- *; simpl in |- *; intros I1 I2; split. intros a; apply I1. exists a; auto with zfc. intros a'; cut (EXType A (fun x : A => EQ (f' a') (f x))). simple induction 1; intros a ea; exists a; auto with zfc. apply I2; exists a'; auto with zfc. Qed.Hint Resolve INC_EQ: zfc. Theorem IN_sound_left : forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''. 
Require Grammar. Require Automaton. Require Interpreter_safe. Require Interpreter_correct. Require Interpreter_complete. Require Import Syntax.Module Make(Export Aut:Automaton.T). Export Aut.Gram. Export Aut.GramDefs.Module Import Inter := Interpreter.Make Aut. Module Safe := Interpreter_safe.Make Aut Inter. Module Correct := Interpreter_correct.Make Aut Inter. Module Complete := Interpreter_complete.Make Aut Inter.Definition complete_validator:unit->bool := Complete.Valid.is_complete. Definition safe_validator:unit->bool := Safe.Valid.is_safe. Definition parse (safe:safe_validator ()=true) init n_steps buffer : parse_result init:= Safe.parse_with_safe (Safe.Valid.is_safe_correct safe) init buffer n_steps. Theorem parse_correct (safe:safe_validator ()= true) init n_steps buffer: match parse safe init n_steps buffer with | Parsed_pr sem buffer_new => exists word, buffer = word ++ buffer_new /\ inhabited (parse_tree (NT (start_nt init)) word sem) | _ => True end. 
forall (A B C E: nat -> Type)(f1 : forall n, (A n) -> (B n * C n))(f2 : forall n, (A n) -> B n -> C n -> E n), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => [x1, x2] <-2 (f1 n a); f2 n a x1 x2); expected_poly_time_let_f : forall (A : nat -> Type)(B : nat -> Set)(C : nat -> Type)(f1 : forall n, (A n) -> B n)(f2 : forall n, (A n) -> B n -> C n), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => x <- (f1 n a); f2 n a x); expected_poly_time_fst : forall (A B : nat -> Type), efficient _ (fun n (a : A n * B n) => fst a); expected_poly_time_snd : forall (A B : nat -> Type), efficient _ (fun n (a : A n * B n) => snd a); expected_poly_time_if : forall (A : nat -> Type), efficient _ (fun n (b : bool)(a1 a2 : A n) => if b then a1 else a2); expected_poly_time_bvxor : efficient _ BVxor; expected_poly_time_eqb_bool : efficient _ (fun n (x y : bool) => eqb x y)}.Section expected_poly_time_theory. Context `{ept : expected_poly_time_predicate}. Theorem expected_poly_time_compose_simp : forall (A B C : nat -> Type)(f1 : forall n, A n -> B n)(f2 : forall n, B n -> C n), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => f2 n (f1 n a)). intuition. eapply (@expected_poly_time_compose _ _ _ _ _ _ (fun n a b => (f2 n b))); eauto. eapply expected_poly_time_const; eauto. Qed. Theorem expected_poly_time_compose_binary : forall (A B C D : nat -> Type)(f1 : forall n, A n -> B n)(f2 : forall n, A n -> C n)(f3 : forall n, B n -> C n -> D n) , efficient _ f1 -> efficient _ f2 -> efficient _ f3 -> efficient _ (fun n (a : A n) => f3 n (f1 n a) (f2 n a)). intuition. eapply (@expected_poly_time_compose _ _ _ _ _ _ (fun n a b => f3 n (f1 n a) b)); eauto. eapply (@expected_poly_time_compose _ _ _ _ _ _ (fun n a b => f3 n b)); eauto. eapply expected_poly_time_const. eauto. Qed. Theorem expected_poly_time_pair_f : forall (A B C : nat -> Type)(f1 : forall n, A n -> B n)(f2 : forall n, A n -> C n), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => (f1 n a, f2 n a)). 
flatid_addr_map fm am -> ([∗ map] fa↦b ∈ fm, Φ fa b) -∗ [∗ map] a↦b ∈ am, Φ (addr2flat a) b. Proof. rewrite <- (list_to_map_to_list fm). pose proof (NoDup_fst_map_to_list fm); revert H0. generalize (map_to_list fm); intros l H0. clear fm; intros. iIntros "H". iInduction l as [|] "IH" forall (am H0 H1). - simpl in *. apply flatid_addr_empty_1 in H1. rewrite H1. repeat rewrite big_sepM_empty. done. - simpl in *. inversion H0; clear H0; subst. apply flatid_addr_insert_inv_1 in H1; destruct H1; intuition subst. iDestruct (big_sepM_insert_delete with "H") as "[Ha H]". erewrite <- (insert_id am) by eauto. iApply big_sepM_insert_delete. iSplitL "Ha". { rewrite H0. iFrame. } rewrite delete_notin. 2: { apply not_elem_of_list_to_map_1; eauto. } rewrite -> (delete_notin (list_to_map _)) in H6. 2: { apply not_elem_of_list_to_map_1; eauto. } iDestruct ("IH" $! _ H5 H6 with "H") as "H". iFrame. Qed.End map. Section gmap_addr_by_block. Variable (T : Type). Definition gmap_addr_by_block (m : gmap addr T) : gmap u64 (gmap u64 T) := gmap_curry m. Theorem gmap_addr_by_block_empty : gmap_addr_by_block  =  . Proof. rewrite /gmap_addr_by_block /gmap_curry. apply map_fold_empty. Qed. Theorem gmap_addr_by_block_insert (m : gmap addr T) (a : addr) (v : T) : m !! a = None -> gmap_addr_by_block (<[a:=v]> m) = <[a.(addrBlock) := <[a.(addrOff) := v]> (default  ((gmap_addr_by_block m) !! a.(addrBlock)))]> (gmap_addr_by_block m). Proof. intros. destruct a as [b o]. rewrite /gmap_addr_by_block. rewrite gmap_curry_insert; eauto. Qed. Theorem gmap_addr_by_block_filter (m : gmap addr T) (P : u64 -> Prop) `{! ∀ blkno, Decision (P blkno)} : gmap_addr_by_block (filter (λ x, P (fst x).(addrBlock)) m) = filter (λ x, P (fst x)) (gmap_addr_by_block m). Proof. induction m using map_ind. - rewrite /gmap_addr_by_block /gmap_curry. rewrite map_filter_empty. rewrite map_fold_empty. rewrite map_filter_empty. eauto. - destruct i as [b o]. rewrite gmap_addr_by_block_insert; eauto; simpl. destruct (decide (P b)). 2: { rewrite map_filter_insert_not; eauto. rewrite map_filter_insert_not; eauto. } rewrite map_filter_insert_True; eauto. rewrite map_filter_insert_True; eauto. rewrite -IHm; clear IHm. rewrite gmap_addr_by_block_insert; eauto; simpl. 2: { rewrite map_filter_lookup_None; eauto. } f_equal. f_equal. f_equal. rewrite /gmap_addr_by_block. clear H0. induction m using map_ind. + rewrite map_filter_empty. eauto. + destruct (decide (P (addrBlock i))). * rewrite map_filter_insert_True; eauto. repeat rewrite gmap_curry_insert; eauto. 2: rewrite map_filter_lookup_None; eauto. destruct (decide (i.1 = b)); subst. { repeat rewrite lookup_insert. f_equal. f_equal. rewrite IHm. eauto. } repeat rewrite lookup_insert_ne; eauto. * rewrite map_filter_insert_not; eauto. rewrite IHm. rewrite gmap_curry_insert; eauto. destruct (decide (i.1 = b)); subst. { exfalso. apply n. eauto. } rewrite lookup_insert_ne; eauto. Qed. Theorem gmap_addr_by_block_off_not_empty (m : gmap addr T) (blkno : u64) (offmap : gmap u64 T) : gmap_addr_by_block m !! blkno = Some offmap -> offmap   . 
simRel: RegsT -> RegsT -> Prop. Variable simRelGood: forall oImp oSpec, simRel oImp oSpec -> getKindAttr oSpec = getKindAttr (getRegisters spec). Variable simRelImpGood: forall oImp oSpec, simRel oImp oSpec -> getKindAttr oImp = getKindAttr (getRegisters imp). Variable initRel: forall rimp, Forall2 regInit rimp (getRegisters imp) -> exists rspec, Forall2 regInit rspec (getRegisters spec) /\ simRel rimp rspec. Variable NoMeths: getMethods imp = []. Variable NoMethsSpec: getMethods spec = []. Variable simulation: forall oImp rImp uImp rleImp csImp aImp, In (rleImp, aImp) (getRules imp) -> SemAction oImp (aImp type) rImp uImp csImp WO -> forall oSpec, simRel oImp oSpec -> ((simRel (doUpdRegs uImp oImp) oSpec /\ csImp = []) \/ (exists rleSpec aSpec, In (rleSpec, aSpec) (getRules spec) /\ exists rSpec uSpec, SemAction oSpec (aSpec type) rSpec uSpec csImp WO /\ simRel (doUpdRegs uImp oImp) (doUpdRegs uSpec oSpec))). Theorem simulationZeroAction: TraceInclusion (Base imp) (Base spec). Proof. eapply simulationZeroA; eauto; intros. specialize (@simulation _ _ _ _ _ _ H H0 _ H1). destruct simulation; auto. right. dest. exists x, x0; split; auto. exists x1, x2; split; auto. exists (doUpdRegs x2 oSpec); split; auto. pose proof (SemAction_NoDup_u H3) as sth. destruct (wfBaseModule spec); dest. pose proof (simRelGood H1) as sth2. apply (f_equal (map fst)) in sth2. rewrite ?map_map in *; simpl in *. assert (sth3: forall A B, (fun x: (A * B) => fst x) = fst) by (intros; extensionality y; intros; auto). rewrite <- sth3 in H8. rewrite <- sth2 in H8. rewrite sth3 in H8. pose proof (SemActionUpdSub H3). eapply doUpdRegs_UpdRegs; eauto. Qed. End SimulationZeroAction.Section SimulationZeroAction_new. Variable imp spec: BaseModuleWf_new type. Variable simRel: RegsT -> RegsT -> Prop. Variable simRelGood: forall oImp oSpec, simRel oImp oSpec -> getKindAttr oSpec = getKindAttr (getRegisters spec). Variable simRelImpGood: forall oImp oSpec, simRel oImp oSpec -> getKindAttr oImp = getKindAttr (getRegisters imp). Variable initRel: forall rimp, Forall2 regInit rimp (getRegisters imp) -> exists rspec, Forall2 regInit rspec (getRegisters spec) /\ simRel rimp rspec. Variable NoMeths: getMethods imp = []. Variable NoMethsSpec: getMethods spec = []. Variable simulation: forall oImp rImp uImp rleImp csImp aImp, In (rleImp, aImp) (getRules imp) -> SemAction oImp (aImp type) rImp uImp csImp WO -> forall oSpec, simRel oImp oSpec -> ((simRel (doUpdRegs uImp oImp) oSpec /\ csImp = []) \/ (exists rleSpec aSpec, In (rleSpec, aSpec) (getRules spec) /\ exists rSpec uSpec, SemAction oSpec (aSpec type) rSpec uSpec csImp WO /\ simRel (doUpdRegs uImp oImp) (doUpdRegs uSpec oSpec))). Theorem simulationZeroAction_new : TraceInclusion (Base imp) (Base spec). 
exploit in_xkeys. eexact H0. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H0. destruct H0. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall (A: Type) (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil. Proof. induction m; intros. auto. rewrite xelements_node. rewrite IHm1, IHm2. destruct o; auto. generalize (H xH); simpl; congruence. intros. apply (H (xI i0)). intros. apply (H (xO i0)). Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros until n. unfold elements. generalize 1%positive. revert m n. induction m; intros. - simpl. rewrite xelements_empty. constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. - destruct n as [ | n1 o' n2 ]. + rewrite (xelements_empty (Node m1 o m2)). simpl; constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. + rewrite ! xelements_node. repeat apply list_forall2_app. apply IHm1. intros. apply (H (xO i)). generalize (H xH); simpl; intros OR; inv OR. constructor. constructor. auto. constructor. apply IHm2. intros. apply (H (xI i)). Qed. Theorem elements_canonical_order: forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) -> (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros. apply elements_canonical_order'. intros. destruct (get i m) as [x|] eqn:GM. exploit H; eauto. intros (y & P & Q). rewrite P; constructor; auto. destruct (get i n) as [y|] eqn:GN. exploit H0; eauto. intros (x & P & Q). congruence. constructor. Qed. Theorem elements_extensional: forall (A: Type) (m n: t A), (forall i, get i m = get i n) -> elements m = elements n. 
unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. intros. apply PTree.gro. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. 
: circuit A A | Comp {A B C: Type} : circuit B C -> circuit A B -> circuit A C | Fst {A B : Type} : circuit (A * B) A | Snd {A B : Type} : circuit (A * B) B.Definition par {A B C D : Type} (f : A -> B) (g : C -> D) (x : A * C) : (B * D) := match x with (pair a b) => pair (f a) (g b) end.Definition dup {A : Type} (x : A) : (A * A) := pair x x.Definition fan {A B C: Type} (f : A -> B) (g : A -> C) (x : A) : (B * C) := (par f g) (dup x).Definition nandb := fun x y => negb (andb x y).Require Import Program.About prod_curry. About andb. Check prod_curry andb. About id. Compute id 3. Fixpoint ceval {a b : Type} (circ : circuit a b) : a -> b := match circ with | Nand => (prod_curry nandb) | Dup => dup | Par f g => par (ceval f) (ceval g) | Id => fun x => x | Comp f g => compose (ceval f) (ceval g) | Fst => fst | Snd => snd end. Require Import Bool.Definition assoc {a b c : Type} : circuit ((a * b) * c) (a * (b * c)) := Comp (Par (Comp Fst Fst) (Par Snd Id)) Dup.Definition assoc' {a b c : Type} : circuit (a * (b * c)) ((a * b) * c) := Comp (Par (Par Id Fst) (Comp Snd Snd)) Dup.Fixpoint Bvector' (n : nat) : Type := match n with | S n' => bool * (Bvector' n') | Z => bool end.Fixpoint Btree (n : nat) : Type := match n with | S n' => (Btree n') * (Btree n') | Z => bool end. Compute Nat.shiftl 1 3. Compute Nat.pow 2 3.Fixpoint pow2 (n : nat) : nat := match n with | S n' => Nat.double (pow2 n') | Z => 1 end. Hint Resolve negb_involutive. Theorem emulate {A B C : Type} : forall x : A, forall f : circuit B C, forall g : circuit A B, ceval (Comp f g) x = (ceval f) ((ceval g) x). Proof. auto. Qed. Hint Resolve emulate. Definition nandc := Nand. Theorem nandb_equiv : forall (b1 b2 : bool), ceval nandc (pair b1 b2) = nandb b1 b2. 
list (Term A n)) (Q : list (poly A0 eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> forall x : poly A0 eqA ltM, s2p A A0 eqA n ltM x = b -> CombLinear (x :: Q) a. intros a b Q H'; elim H'; auto. intros x y H'0 H'1 x0 H'2. apply CombLinear_comp with (p := y); auto. rewrite <- H'2; case x0; simpl in |- *; auto. intros x1; case x1; simpl in |- *; auto. intros t l c; apply CombLinear_id; auto. change (inPolySet A A0 eqA n ltM (pX t l) (exist (fun l0 => canonical A0 eqA ltM l0) (pX t l) c :: Q)) in |- *; apply incons; auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. intros x y z H'0 H'1 H'2 H'3 x0 H'4. lapply H'2; [ intros H'5; lapply (H'5 x0); [ intros H'7; clear H'2 | clear H'2 ] | clear H'2 ]; auto. cut (canonical A0 eqA ltM y). intros H'2. lapply (reduce_cb2 (mks A A0 eqA n ltM x H'3) (mks A A0 eqA n ltM y H'2) Q); simpl in |- *; [ intros H'9 | idtac ]; auto. apply CombLinear_trans_cons_lem with (R := mks A A0 eqA n ltM y H'2 :: x0 :: Q) (b := mks A A0 eqA n ltM y H'2); auto. apply CombLinear_incl with (P := mks A A0 eqA n ltM y H'2 :: Q); auto. intros a0 H'6. apply Incl_inp_inPolySet with (P := mks A A0 eqA n ltM y H'2 :: Q); auto. red in |- *; simpl in |- *; auto with datatypes. intros a1 H'8; elim H'8; auto. apply canonical_reduce with (1 := cs) (3 := H'0); auto. apply canonical_reduce with (1 := cs) (3 := H'0); auto. Qed. Theorem reduceplus_cb2 : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) -> CombLinear (b :: Q) (s2p A A0 eqA n ltM a). intros a b Q H'. apply reduceplus_cb2_lem with (b := s2p A A0 eqA n ltM b); auto. case a; auto. Qed. Theorem reducestar_cb2 : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (s2p A A0 eqA n ltM a) (s2p A A0 eqA n ltM b) -> CombLinear (b :: Q) (s2p A A0 eqA n ltM a). 
Require Import VerdiRaft.Raft.Require Import VerdiRaft.SortedInterface.Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.UniqueIndicesInterface.Section UniqueIndices. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {si : sorted_interface}. Theorem UniqueIndices_invariant : forall net, raft_intermediate_reachable net -> UniqueIndices net. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Import Coq.Bool.Bool. Require Import Coq.Arith.Arith. Require Import Coq.Arith.EqNat. Require Import Coq.omega.Omega. Require Import Imp. Require Import Maps. Definition Assertion := state -> Prop.Definition assert_implies (P Q : Assertion) : Prop := forall st, P st -> Q st.Notation "P ->> Q" := (assert_implies P Q) (at level 80) : hoare_spec_scope. Open Scope hoare_spec_scope.Notation "P <<->> Q" := (P ->> Q /\ Q ->> P) (at level 80) : hoare_spec_scope.Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop := forall st st', c / st \\ st' -> P st -> Q st'.Notation "{{ P }} c {{ Q }}" := (hoare_triple P c Q) (at level 90, c at next level) : hoare_spec_scope.Theorem hoare_post_true : forall (P Q : Assertion) c, (forall st, Q st) -> {{P}} c {{Q}}. Admitted. Theorem hoare_pre_false : forall (P Q : Assertion) c, (forall st, ~(P st)) -> {{P}} c {{Q}}. 
} x, ulp (round beta fexp rnd x) = ulp x \/ Rabs (round beta fexp rnd x) = bpow (mag beta x). Proof with auto with typeclass_instances. intros Not_FTZ_ rnd Zrnd x. case (Rtotal_order x 0); intros Zx. case (ulp_round_pos (Zrnd_opp rnd) (-x)). now apply Ropp_0_gt_lt_contravar. rewrite ulp_opp, <- ulp_opp. rewrite <- round_opp, Ropp_involutive. intros Y;now left. rewrite mag_opp. intros Y; right. rewrite <- (Ropp_involutive x) at 1. rewrite round_opp, Y. rewrite Rabs_Ropp, Rabs_right... apply Rle_ge, bpow_ge_0. destruct Zx as [Zx|Zx]. left; rewrite Zx; rewrite round_0... rewrite Rabs_right. apply ulp_round_pos... apply Rle_ge, round_ge_generic... apply generic_format_0... now apply Rlt_le. Qed.Lemma succ_round_ge_id : forall rnd { Zrnd : Valid_rnd rnd } x, (x <= succ (round beta fexp rnd x))%R. Proof. intros rnd Vrnd x. apply (Rle_trans _ (round beta fexp Raux.Zceil x)). { now apply round_UP_pt. } destruct (round_DN_or_UP beta fexp rnd x) as [Hr|Hr]; rewrite Hr. { now apply UP_le_succ_DN. } apply succ_ge_id. Qed.Lemma pred_round_le_id : forall rnd { Zrnd : Valid_rnd rnd } x, (pred (round beta fexp rnd x) <= x)%R. Proof. intros rnd Vrnd x. apply (Rle_trans _ (round beta fexp Raux.Zfloor x)). 2: now apply round_DN_pt. destruct (round_DN_or_UP beta fexp rnd x) as [Hr|Hr]; rewrite Hr. 2: now apply pred_UP_le_DN. apply pred_le_id. Qed.Theorem round_N_le_midp: forall choice u v, F u -> (v < (u + succ u)/2)%R -> (round beta fexp (Znearest choice) v <= u)%R. Proof with auto with typeclass_instances. intros choice u v Fu H.assert (V: ((succ u = 0 /\ u = 0) \/ u < succ u)%R). specialize (succ_ge_id u); intros P; destruct P as [P|P]. now right. case (Req_dec u 0); intros Zu. left; split; trivial. now rewrite <- P. right; now apply succ_gt_id.destruct V as [(V1,V2)|V]. rewrite V2; apply round_le_generic... apply generic_format_0. left; apply Rlt_le_trans with (1:=H). rewrite V1,V2; right; field.assert (T: (u < (u + succ u) / 2 < succ u)%R) by lra. destruct T as (T1,T2). apply Rnd_N_pt_monotone with F v ((u + succ u) / 2)%R... apply round_N_pt... apply Rnd_N_pt_DN with (succ u)%R. pattern u at 3; replace u with (round beta fexp Zfloor ((u + succ u) / 2)). apply round_DN_pt... apply round_DN_eq; trivial. split; try left; assumption. pattern (succ u) at 2; replace (succ u) with (round beta fexp Zceil ((u + succ u) / 2)). apply round_UP_pt... apply round_UP_eq; trivial. apply generic_format_succ... rewrite pred_succ; trivial. split; try left; assumption. right; field. Qed. Theorem round_N_ge_midp: forall choice u v, F u -> ((u + pred u)/2 < v)%R -> (u <= round beta fexp (Znearest choice) v)%R. 
DBlocks_type) := Map.remove inum dblocks. Definition write lxp ixp inum off v fms := let '(al, ms, alc, ialc, icache, cache, dblocks) := (MSAlloc fms, MSLL fms, MSAllocC fms, MSIAllocC fms, MSICache fms, MSCache fms, MSDBlocks fms) in let^ (icache, ms, bn) <-INODE.getbnum lxp ixp inum off icache ms; ms <- LOG.write lxp (# bn) v ms; Ret (mk_memstate al ms alc ialc icache cache dblocks). Definition dwrite lxp ixp inum off v fms := let '(al, ms, alc, ialc, icache, cache, dblocks) := (MSAlloc fms, MSLL fms, MSAllocC fms, MSIAllocC fms, MSICache fms, MSCache fms, MSDBlocks fms) in let^ (icache, ms, bn) <- INODE.getbnum lxp ixp inum off icache ms; ms <- LOG.dwrite lxp (# bn) v ms; let dblocks := put_dirty inum (# bn) dblocks in Ret (mk_memstate al ms alc ialc icache cache dblocks). Definition datasync lxp (ixp : INODE.IRecSig.xparams) inum fms := let '(al, ms, alc, ialc, icache, cache, dblocks) := (MSAlloc fms, MSLL fms, MSAllocC fms, MSIAllocC fms, MSICache fms, MSCache fms, MSDBlocks fms) in let bns := (SS.elements (get_dirty inum dblocks)) in ms <- LOG.dsync_vecs lxp bns ms; let dblocks := clear_dirty inum dblocks in Ret (mk_memstate al ms alc ialc icache cache dblocks). Definition sync lxp (ixp : INODE.IRecSig.xparams) fms := let '(al, ms, alc, ialc, icache, cache, dblocks) := (MSAlloc fms, MSLL fms, MSAllocC fms, MSIAllocC fms, MSICache fms, MSCache fms, MSDBlocks fms) in ms <- LOG.flushall lxp ms; Ret (mk_memstate (negb al) ms alc ialc icache cache dblocks). Definition sync_noop lxp (ixp : INODE.IRecSig.xparams) fms := let '(al, ms, alc, ialc, icache, cache, dblocks) := (MSAlloc fms, MSLL fms, MSAllocC fms, MSIAllocC fms, MSICache fms, MSCache fms, MSDBlocks fms) in ms <- LOG.flushall_noop lxp ms; Ret (mk_memstate (negb al) ms alc ialc icache cache dblocks). Definition pick_balloc A (a : A * A) (flag : bool) := if flag then fst a else snd a. Definition upd_balloc A (a : A * A) (new : A) (flag : bool) := (if flag then new else fst a, if flag then snd a else new). Theorem pick_upd_balloc_negb : forall A flag p (new : A), pick_balloc p flag = pick_balloc (upd_balloc p new (negb flag)) flag. Proof. destruct flag, p; intros; reflexivity. Qed. Theorem pick_negb_upd_balloc : forall A flag p (new : A), pick_balloc p (negb flag) = pick_balloc (upd_balloc p new flag) (negb flag). Proof. destruct flag, p; intros; reflexivity. Qed. Theorem pick_upd_balloc_lift : forall A flag p (new : A), new = pick_balloc (upd_balloc p new flag) flag. 
m)%R -> (m <= n)%R. intros n m p H H1; case (Rle_or_lt m n); auto; intros H2. absurd (p * n <= p * m)%R; auto with real. apply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto. Qed.Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R. intros n m p H H1; case (Rle_or_lt m n); auto; intros H2. absurd (p * n < p * m)%R; auto with real. apply Rle_not_lt; apply Rmult_le_compat_l; auto with real. Qed.Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R. intros n m p H H1; case (Rle_or_lt n m); auto; intros H2. absurd (p * n < p * m)%R; auto with real. apply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real. Qed.Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real. Qed.Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R. intros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R. intros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real. Qed.Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.Section Monic_Iso_Monic_Factorization. Context {A B : Type} {f : A → B} (fm : @is_Monic Type_Cat _ _ f) . Definition Monic_Image_of : Type := {x : B & {a : A | f a = x}}. Definition Monic_From_Image_forward : Monic_Image_of → B := fun x => projT1 x. Program Definition Monic_Iso_Monic_Factor_Monic : @Monic Type_Cat Monic_Image_of B := {| mono_morphism := Monic_From_Image_forward; mono_morphism_monomorphic := fun T g h => _ |} . Next Obligation. Proof. extensionality x. assert (H' := equal_f H x); cbn in H'. destruct (g x) as [gx Hgx]; destruct (h x) as [hx Hhx]. cbn in *. destruct H'. cutrewrite (Hgx = Hhx); trivial. apply sig_proof_irrelevance. destruct Hgx as [y Hy]; destruct Hhx as [z Hz]. cbn in *. refine (equal_f (fm (unit : Type) (fun _ => y) (fun _ => z) _) tt). FunExt; cbn; auto. Qed. Definition Monic_To_Image : A → Monic_Image_of := fun a => existT _ (f a) (exist _ a eq_refl). Definition Monic_From_Image_back : Monic_Image_of → A := fun x => proj1_sig (projT2 x). Theorem Monic_From_Image_back_is_Monic : @is_Monic Type_Cat _ _ Monic_To_Image. 
divA eqA_dec n ltM ltM_dec Q p (pO A n) -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (pO A n). intros Q p H' H'0. elim reduce0_reducestar with (1 := cs) (eqA_dec := eqA_dec) (ltM_dec := ltM_dec) (Q := Q) (p := pO A n); auto. intros t E; apply reducestar0; auto. apply pO_irreducible; auto. Qed. Definition spO : poly A0 eqA ltM. exists (pO A n); simpl in |- *; auto. Defined. Definition sp1 : poly A0 eqA ltM. exists (pX (A1, M1 n) nil); auto. Defined. Definition sgen : nat -> poly A0 eqA ltM. intros m; exists (pX (A1, gen_mon n m) (pO A n)). apply canonicalp1; auto. Defined. Definition sscal : A -> poly A0 eqA ltM -> poly A0 eqA ltM. intros a p; case p. intros x H'1; exists (tmults A0 multA eqA_dec (a, M1 n) x); auto. unfold tmults in |- *; case (zeroP_dec A A0 eqA eqA_dec n (a, M1 n)); simpl in |- *; auto. Qed. Theorem red_cons : forall (a : poly A0 eqA ltM) (p : list (poly A0 eqA ltM)), In a p -> red a p. intros a; case (seqp_dec A A0 eqA eqA_dec n ltM a spO). case a; unfold red, spO, seqP in |- *; simpl in |- *. intros x c H' p H'0; inversion H'; auto. apply reducestar_pO_is_pO with (p := x); auto. case a; unfold red, spO, seqP in |- *; simpl in |- *. intros x c H' p H'0. apply rstar_rtopO; auto. apply Rstar_n with (y := pO A n); auto. apply reduce_in_pO with (1 := cs); auto. change (inPolySet A A0 eqA n ltM (s2p A A0 eqA n ltM (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c)) p) in |- *; apply In_inp_inPolySet; auto. red in |- *; intros H'2; apply H'; apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply Rstar_0; auto. Qed. Theorem red_id : forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), red (spolyp a a) aL. intros a P; case a. unfold red in |- *; simpl in |- *; auto. intros x H'. apply rstar_rtopO; auto. apply spolyf_canonical with (1 := cs); auto. apply Rstar_0; auto. apply spolyf_pO with (1 := cs); auto. Qed. Theorem inP_reduce : forall P Q : list (poly A0 eqA ltM), (forall a : list (Term A n), inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) -> forall a b : list (Term A n), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b. 
intuitionistic_is_classical. eapply transport_prove. exact Hφ. Qed. Lemma classicalProvabilityInverseTransport : nil ⊢C F (h10:=h10) -> H10UPC_SAT h10. Proof using LEM. intros H%(classical_soundness LEM). apply inverseTransport. intros D I rho. apply H. easy. Qed. End classical_provability. Section satisfiability. Context {h10 : list h10upc}. Lemma satisTransport : (~ H10UPC_SAT h10) -> satis ((F (ff:=falsity_on) (h10:=h10)) --> falsity). Proof. intros H. exists dom. exists (IB (h10:=h10)). exists (fun _ => Num 0). intros HF. apply H. eapply IB_fulfills. easy. Qed. Lemma satisInverseTransport : satis ((F (ff:=falsity_on) (h10:=h10)) --> falsity) -> (~ H10UPC_SAT h10). Proof. intros [D [I [rho HF]]] H. apply HF, (transport (ff:=falsity_on) H). Qed. End satisfiability. Section ksatisfiability. Context {h10 : list h10upc}. Lemma ksatisTransport : (~ H10UPC_SAT h10) -> ksatis ((F (ff:=falsity_on) (h10:=h10)) --> falsity). Proof. intros H. exists dom. pose (kripke_tarski (ff:=falsity_on) (IB (h10:=h10))) as Hk. exists (interp_kripke (IB (h10:=h10))). exists tt. exists (fun _ => Num 0). rewrite <- Hk. intros HF. apply H. eapply IB_fulfills. easy. Qed. Lemma ksatisInverseTransport : ksatis ((F (ff:=falsity_on) (h10:=h10)) --> falsity) -> (~ H10UPC_SAT h10). Proof. intros [D [M [u [rho HF]]]] H. specialize (HF u). apply HF. - apply reach_refl. - apply (kripkeTransport (ff:=falsity_on) H). Qed. End ksatisfiability.Require Import Undecidability.Synthetic.Definitions. Section undecResults. Definition minimalSignature (f:funcs_signature) (p:preds_signature) : Prop := match f,p with {|syms := F; ar_syms := aF|},{|preds := P; ar_preds := aP|} => (F -> False) /\ exists pp : P, aP pp = 2 end. Lemma sig_is_minimal : minimalSignature sig_empty sig_binary. Proof. split. * intros []. * now exists tt. Qed. Theorem validReduction : H10UPC_SAT ⪯ @valid sig_empty sig_binary falsity_off. Proof. exists (fun l => @F falsity_off l). split. * apply transport. * apply inverseTransport. Qed. Theorem satisReduction : complement H10UPC_SAT ⪯ @satis sig_empty sig_binary falsity_on. Proof. exists (fun l => @F falsity_on l --> falsity). split. * apply satisTransport. * apply satisInverseTransport. Qed. Theorem proveReduction : H10UPC_SAT ⪯ (fun (k:@form sig_empty sig_binary frag_operators falsity_off) => nil ⊢M k). Proof. exists (fun l => @F falsity_off l). split. * apply proofTransport. * apply inverseProofTransport. Qed. Theorem classicalProveReduction (LEM : forall P:Prop, P \/ ~P) : H10UPC_SAT ⪯ (fun (k:@form sig_empty sig_binary frag_operators falsity_off) => nil ⊢C k). Proof. exists (fun l => @F falsity_off l). split. * apply classicalProvabilityTransport, LEM. * apply classicalProvabilityInverseTransport, LEM. Qed. Theorem kripkeValidReduction : H10UPC_SAT ⪯ @kvalid sig_empty sig_binary falsity_off. Proof. exists (fun l => @F falsity_off l). split. * apply kripkeTransport. * apply kripkeInverseTransport. Qed. Theorem kripkeSatisReduction : complement H10UPC_SAT ⪯ @ksatis sig_empty sig_binary falsity_on. 
reflexivity. - simpl. destruct (string_dec s s0); try congruence. Qed. Lemma update_subtree_update_trim_head_dir: forall l name path n subtree_head subtree, find_subtree [name] (TreeDir n l) = Some subtree_head -> find_subtree [name] (update_subtree ([name]++path) subtree (TreeDir n l)) = Some (update_subtree path subtree subtree_head). Proof. induction l; intros. - exfalso. simpl in H. inversion H. - destruct a; simpl. destruct (string_dec s name); subst. + simpl. destruct (string_dec name name); try congruence. rewrite find_subtree_head in H. inversion H; eauto. + simpl. destruct (string_dec s name); try congruence. unfold find_subtree in IHl at 2; simpl. case_eq (update_subtree ([name] ++ path) subtree (TreeDir n l)); intros. eapply IHl; eauto. rewrite find_subtree_head_ne in H; eauto. eapply IHl; eauto. rewrite find_subtree_head_ne in H; eauto. Qed. Lemma find_subtree_update_trim_head: forall name path subtree tree subtree_head, find_subtree [name] tree = Some subtree_head -> find_subtree [name] (update_subtree ([name] ++ path) subtree tree) = Some (update_subtree path subtree subtree_head). Proof. intros. case_eq tree; intros. - exfalso. subst. unfold find_subtree in H; simpl. inversion H. - erewrite update_subtree_update_trim_head_dir; eauto. subst; eauto. Qed. Lemma update_subtree_update_trim_head_ne: forall tree name s path subtree, s <> name -> find_subtree [name] (update_subtree (s::path) subtree tree) = find_subtree [name] tree. Proof. intros; simpl. destruct tree; subst; eauto. induction l; subst; simpl in *; eauto. destruct a; simpl. unfold find_subtree_helper at 1; simpl. destruct (string_dec s0 s); subst; simpl. + destruct (string_dec s name); simpl in *; try congruence. + destruct (string_dec s name); simpl in *; try congruence. destruct (string_dec s0 name); try congruence. Qed. Lemma find_subtree_update_subtree_child: forall path suffix tree subtree subtree_child, find_subtree path tree = Some subtree_child -> find_subtree path (update_subtree (path++suffix) subtree tree) = Some (update_subtree suffix subtree subtree_child). Proof. induction path; intros; subst; auto. - rewrite app_nil_l. simpl in *. inversion H; eauto. - rewrite cons_app in *. eapply find_subtree_app' in H. deex. erewrite find_subtree_app with (subtree := (update_subtree (path ++ suffix) subtree subtree_base)). eapply IHpath; eauto. eapply find_subtree_update_trim_head; eauto. Qed. Lemma find_subtree_update_trim: forall p1 p2 a tree elem subtree d, find_subtree [a] tree = Some subtree -> find_subtree p2 subtree = Some d -> find_subtree p1 (update_subtree p2 elem subtree) = find_subtree p1 subtree -> find_subtree (a :: p1) (update_subtree (a::p2) elem tree) = find_subtree (a :: p1) tree. Proof. intros. destruct tree. - rewrite cons_app. erewrite find_subtree_app. 2: eauto. erewrite find_subtree_app. 2: eauto. reflexivity. - rewrite cons_app. erewrite find_subtree_app. erewrite find_subtree_app. 2: eauto. eauto. setoid_rewrite cons_app at 2. erewrite find_subtree_update_subtree_child; eauto. Qed. Theorem find_subtree_update_subtree_oob'' : forall pn tree a subtree, pn <> nil -> (~ pathname_prefix [a] pn) -> find_subtree [a] (update_subtree pn subtree tree) = find_subtree [a] tree. 
app_assoc. simpl. reflexivity. unfold bf_measure_list. simpl. destruct x. apply lex1. unfold natNodes_lt. eapply match_decr_size. symmetry. inversion Heqx; subst. apply M. destruct x. inversion Heqx; subst. simpl. reflexivity. * erewrite H. reflexivity. unfold bf_measure_list. apply lex2. unfold natNodes_eq. symmetry. eapply match_none_size. apply M. unfold list_length_lt. simpl. omega. simpl. reflexivity. Qed. Theorem level_tail_equiv: forall v g, get_dists (bfs_tail (start g v)) = level v g. Proof. intros. unfold level. rewrite <- leveln_leveln'_equiv. rewrite leveln_tail_equiv. simpl. reflexivity. Qed.Lemma level_invalid: forall v (g: gr a b), vIn g v = false -> level v g = nil. Proof. intros. unfold level. rewrite <- leveln_leveln'_equiv. simpl. rewrite unfold_leveln'. simpl. destruct (isEmpty g). reflexivity. destruct (match_ v g) eqn : M. destruct m. - assert (vIn g v = true). rewrite <- match_in. exists c. exists g0. assumption. rewrite H0 in H. inversion H. - rewrite unfold_leveln'. simpl. reflexivity. Qed. Theorem level_finds_shortest_path: forall v g v', match (find_dist_list (level v g) v') with | Some n => Some (n+1) | None => None end = distance g v v'. Proof. intros. destruct (vIn g v) eqn : H. assert (V: valid (bfs_tail (start g v)) g v). eapply multi_valid. apply v_start. assumption. eapply bfs_tail_multi. assert (D': done (bfs_tail (start g v)) = true). eapply bfs_tail_done. rewrite <- level_tail_equiv. destruct (vIn g v') eqn : D. - pose proof bfs_tail_correct. unfold dist_plus_one in H0. unfold find_dist in H0. specialize (H0 (bfs_tail (start g v)) g v). specialize (H0 V D' v' D). rewrite <- H0. reflexivity. - replace (find_dist_list (get_dists (bfs_tail (start g v))) v') with (find_dist (bfs_tail (start g v)) v') by (unfold find_dist; reflexivity). destruct (find_dist (bfs_tail (start g v)) v') eqn : F. + rewrite find_dist_in in F. pose proof output_iff_reachable. assert (exists l, path' g v v' l). rewrite <- H0. rewrite in_map_iff. exists (v', Z.of_nat n). solve_assume. apply F. assumption. assumption. destruct_all. apply path_implies_in_graph in H1. destruct_all. rewrite H2 in D. inversion D. apply V. + destruct (distance g v v') eqn : DI. * apply distance_some in DI. destruct_all. unfold shortest_path in H0. destruct_all. apply path_implies_in_graph in H0. destruct_all. rewrite H3 in D. inversion D. * reflexivity. - assert (A:= H). apply level_invalid in H. rewrite H. simpl. destruct (distance g v v') eqn : D. + apply distance_some in D. destruct_all. unfold shortest_path in H0. destruct_all. apply path_implies_in_graph in H0. destruct_all. rewrite H0 in A. inversion A. + reflexivity. Qed. Theorem level_sorted_by_dist: forall v (g: gr a b), Sorted Z.le (map snd (level v g)). 
(k_ge_43). intros. cut (k */ x' > 1). { intros. set (p := k */ x'). assert (p > 1). rewrite /p. auto. nra. } apply Rlt_gt, (Rmult_lt_reg_r x'); first fourier. rewrite Rmult_assoc Rinv_l; first fourier. apply Rgt_not_eq; fourier. * rewrite //=. nra. * rewrite //=. nra. } assert (x = 4/3) as ->. { apply (Rmult_le_compat_r (/(3/4))) in Hc2; last fourier. rewrite Rmult_assoc Rinv_r in Hc2; last first. { apply Rgt_not_eq. fourier. } replace (/ (3/4)) with (4/3) in Hc2 by field. rewrite Rmult_1_l Rmult_1_r in Hc2. apply Rle_antisym; nra. } destruct (Rlt_dec); last by nra. intros; rewrite -kinv Rinv_r; first fourier. apply Rgt_not_eq, kgt0. - assert (0 < ln x) by (apply Rlt_0_ln; nra). rewrite /g. destruct (Rle_dec); first by nra; intros. destruct (Rlt_dec); first by nra; intros. intros; rewrite ln_mult; try nra. rewrite (Rmult_plus_distr_l k _). assert (k * ln (3 / 4) = -1) as ->. { rewrite /k. field. apply Rlt_not_eq. rewrite -(ln_1). apply ln_increasing; fourier. } destruct Rlt_dec. * field_simplify; last nra. try rewrite /Rdiv Rinv_1 Rmult_1_r. nra. * rewrite /Rdiv Rinv_r; first fourier. apply Rgt_not_eq; fourier. Qed. Lemma alower: ∀ x, x ≤ d → a x = 0. Proof. rewrite /a => x; destruct (Rle_dec) => //=; nra. Qed. Lemma ainc: ∀ x x', d ≤ x → x < x' → a x < a x'. Proof. rewrite /a/d => x x' Hle Hlt. assert (Hgt: x' > 1) by fourier. do 2 destruct (Rle_dec) => //=; try nra. Qed. Lemma a_nonneg: ∀ x, a x ≥ 0. Proof. intros. rewrite /a. destruct (Rle_dec); nra. Qed. Lemma a_pos: ∀ x, d < x → 0 < a x. Proof. rewrite /d/a => ??. destruct (Rle_dec); nra. Qed. Lemma a_mono: Rmono a. Proof. rewrite /Rmono. intros x x' Hle. inversion Hle; subst; try reflexivity. destruct (Rle_dec d x) as [?|?%Rnot_le_gt]. * left. apply ainc; eauto. * rewrite alower; auto; try fourier. rewrite /a. destruct (Rle_dec); nra. Qed. Lemma mnondec: ∀ y y', 0 < y → y ≤ y' → (m y / y) ≤ (m y' / y'). Proof. intros y y' Hlt Hle. rewrite /m. destruct (Rlt_dec). { destruct (Rlt_dec). - intros. rewrite /Rdiv ?Rmult_0_l. fourier. - intros. rewrite /Rdiv ?Rmult_0_l. rewrite Rmult_comm -Rmult_assoc Rinv_l; nra. } destruct (Rlt_dec); first by nra. intros. right. field. split; apply Rgt_not_eq; fourier. Qed. Lemma d_non_neg: 0 ≤ d. Proof. rewrite /d. fourier. Qed. Theorem qs_work_bound x w: size x > 1 → pr_gt (T x) (size x * (k * ln (size x) + 1) + INR w * (size x)) ≤ (size x) * (3/4)^w. 
tpsc. Proof. intros. unfold bare_init, tpf_init in *. simpl in *. unfold BareMachine.init_mach, DryHybridMachine.init_mach in *. destruct HinitSC as [? [csc [HinitSC Htpsc]]]. destruct HinitF as [? [csf [HinitF Htpf]]]. simpl in *. unfold OrdinalPool.mkPool in *. simpl in *. econstructor; subst; simpl; unfold OrdinalPool.containsThread; simpl; [tauto|]. assert (Heq: csf = csc) by (eapply initial_core_det; eauto); subst. intros. apply core_erasure_refl; now auto. Qed. Lemma execution_sim: forall U U' tpf tpf' mf mf' tpsc msc tr tr' trsc (Hexec: fexecution (U, tr, tpf) mf (U', tr', tpf') mf') (HerasedPool: threadPool_erasure tpf tpsc) (Hmem_erasure: mem_erasure mf msc), exists tpsc' msc' trsc', sc_execution (U, trsc, tpsc) msc (U', trsc', tpsc') msc' /\ threadPool_erasure tpf' tpsc' /\ mem_erasure mf' msc' /\ (trace_erasure tr trsc -> trace_erasure tr' trsc'). Proof with eauto. intros U. induction U. - intros. inversion Hexec; subst. exists tpsc, msc, trsc. split. econstructor 1. simpl; auto. split... - intros. inversion Hexec; subst. + simpl in H5; by exfalso. + eapply sc_sim with (tr1' := trsc) in H8; eauto. destruct H8 as (tpsc0 & msc0 & tr0 & Hstep0 & HerasedPool0 & Hmem_erasure0 & Htrace_erasure0). specialize (IHU _ _ _ _ _ _ _ _ _ tr0 H9 HerasedPool0 Hmem_erasure0). destruct IHU as (tpsc2' & msc2' & trsc2' & Hsexec & HerasedPool' & Hmem_erasure' & Htrace_erasure2'). exists tpsc2', msc2', trsc2'. split... pose proof (step_trace_monotone Hstep0) as Htr0. destruct Htr0 as [trsc' Htrsc']; subst. pose proof (fine_execution_schedule Hsexec); subst. pose proof (fine_execution_multi_step Hsexec). eapply multi_step_trace_monotone in H. destruct H as [tr''' ?]. subst. rewrite <- catA. rewrite <- catA in Hsexec. econstructor; simpl in *; now eauto. Qed. Lemma fsafe_implies_scsafe: forall n sched tpsc tpf mf msc (Hsafe: fsafe tpf mf sched n) (HerasedPool: threadPool_erasure tpf tpsc) (Hmem_erasure: mem_erasure mf msc), sc_safe tpsc msc sched n. Proof. intro n. induction n; intros. - simpl in *. inversion Hsafe; subst. econstructor. eapply @HybridFineMachine.HaltedSafe with (tr := tr); simpl; now auto. - destruct sched. + inv Hsafe. eapply @HybridFineMachine.HaltedSafe with (tr := tr); simpl; now auto. simpl in H0. inv H0; simpl in *; discriminate. + inv Hsafe. simpl in H; by exfalso. simpl in *. eapply step_trace_irr with (tr'' := [::]) in H0. destruct H0 as [ev Hstep]. simpl in Hstep. eapply sc_sim with (tr1' := [::]) in Hstep; eauto. destruct Hstep as (tpsc2' & msc2' & ? & Hstep & HerasedPool' & Hmem_erasure' & ?). econstructor 3; simpl in *; now eauto. Qed. Theorem sc_erasure: forall f arg tpsc tpf m m' (HinitSC: bare_init initU m (initU, [::], tpsc) m' f arg) (HinitF: tpf_init initU m (initU, [::], tpf) m' f arg) (HsafeF: forall n, fsafe tpf (@diluteMem FineDilMem m') initU n), (forall n, sc_safe tpsc (@diluteMem BareDilMem m') initU n) /\ (forall tpf' mf' tr, fexecution (initU, [::], tpf) (@diluteMem FineDilMem m') ([::], tr, tpf') mf' -> exists tpsc' msc' tr', sc_execution (initU, [::], tpsc) (@diluteMem BareDilMem m') ([::], tr', tpsc') msc' /\ threadPool_erasure tpf' tpsc' /\ mem_erasure mf' msc' /\ trace_erasure tr tr'). 
k, t0, p2) * tree len key sk1 (keepLt ts key k) p1 * tuples0 len (keepEq ts key k) t0 * tree len key sk2 (keepGt ts key k) p2 end. Fixpoint stack (len key : W) (tss : list (tuples * W)) (p : W) : HProp := match tss with | nil => [| p = 0 |] | (ts, tp) :: tss' => [| p <> 0 |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p' end. Definition tuples1 (len key : W) (ts : tuples) (c : W) : HProp := [| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]. Theorem stack_nil_fwd : forall len key tss (p : W), p = 0 -> stack len key tss p ===> [| tss = nil |]. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_nil_bwd : forall len key tss (p : W), p = 0 -> [| tss = nil |] ===> stack len key tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_fwd : forall len key tss (p : W), p <> 0 -> stack len key tss p ===> Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p'. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_bwd : forall len key tss (p : W), p <> 0 -> (Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p') ===> stack len key tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. injection H0; sepLemma; auto. injection H0; sepLemma. Qed. Theorem tuples1_fwd : forall len key ts c, tuples1 len key ts c ===> [| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]. 
auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_multTerm_l; auto. apply eqTerm_divTerm_comp; auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (1 := H4); auto. apply divP_inv2 with (a := a); auto. Qed. Hint Resolve divP_trans. Theorem divP_nZero : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b), divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). intros a b nZb H'; inversion H'; auto. Qed. Hint Resolve divP_nZero. Theorem divP_eqTerm_comp : forall a b c : Term A n, divP a c -> eqTerm (A:=A) eqA (n:=n) a b -> divP b c. intros a b c H' H'0. cut (~ zeroP (A:=A) A0 eqA (n:=n) c); [ intros nZc | auto ]. apply divTerm_def with (nZb := nZc); auto. apply nzeroP_comp_eqTerm with (1 := cs) (a := a); auto. apply divP_inv1 with (b := c); auto. 2: apply divP_inv2 with (a := a); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a nZc) c); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := a); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem divP_on_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqT a b -> divP a b. intros a b H' nZb H'1; apply divTerm_def with (nZb := nZb); auto. apply divTerm_on_eqT; auto. Qed. Theorem divP_on_eqT_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqT (divTerm a nZb) (T1 A1 n). intros a b H nZb H0; apply divTerm_on_eqT_eqT; auto. Qed. Hint Resolve divP_on_eqT divP_on_eqT_eqT. Inductive ppcm (p q : Term A n) : Term A n -> Prop := ppcm0 : forall s : Term A n, (forall r : Term A n, divP r p -> divP r q -> divP r s) -> divP s p -> divP s q -> ppcm p q s. Hint Resolve ppcm0. Theorem ppc_is_ppcm : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> ppcm a b (ppc a b). 
: natFlector.flist) (IHl : appendF l0 natFlector.nilF = l0) => @eq_ind_r natFlector.flist l0 (fun (l1 : natFlector.flist) => natFlector.consF a l1 = natFlector.consF a l0) (@eq_refl natFlector.flist (natFlector.consF a l0)) (appendF l0 natFlector.nilF) IHl) l. Lift natFlector.flist natFlector.flector in app_nil_rF as app_nil_r_vectF_lifted.Theorem test_app_nil_r_vectF_exact: forall (pv : sigT natFlector.flector), append_vectF_lifted (existT natFlector.flector (projT1 pv) (projT2 pv)) (existT natFlector.flector 0 natFlector.nilFV) = (existT natFlector.flector (projT1 pv) (projT2 pv)). Proof. exact app_nil_r_vectF_lifted. Qed.Theorem in_split : forall A x (l:list A), In A x l -> exists l1 l2, l = append A l1 (x::l2). Proof. induction l; simpl; destruct 1. subst a; auto. exists nil, l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Defined.Preprocess in_split as in_split'. Lift list vector in in_split' as in_split_vect_lifted.Theorem test_in_split_vect_exact: forall (A : Type) (x : A) (pv : sigT (vector A)), In_vect_lifted A x (existT (vector A) (projT1 pv) (projT2 pv)) -> exists pv1 pv2 : sigT (vector A), existT (vector A) (projT1 pv) (projT2 pv) = append_vect_lifted A pv1 (existT (vector A) (S (projT1 pv2)) (consV A (projT1 pv2) x (projT2 pv2))). Proof. exact in_split_vect_lifted. Qed.Definition is_cons (A : Type) (l : list A) := list_rect (fun (_ : list A) => Prop) False (fun (_ : A) (_ : list A) (_ : Prop) => True) l.Lift list vector in is_cons as is_cons_lifted.Lemma hd_error_some_nil : forall A l (a:A), hd_error A l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Defined.Preprocess hd_error_some_nil as hd_error_some_nil'. Lift list vector in hd_error_some_nil' as hd_error_some_nil_vect_lifted.Theorem test_hd_error_some_nil_vect_exact: forall (A : Type) (l : {H : nat & vector A H}) (a : A), hd_vect_error A (existT (vector A) (projT1 l) (projT2 l)) = Some a -> existT (vector A) (projT1 l) (projT2 l) <> existT (vector A) 0 (nilV A). Proof. exact hd_error_some_nil_vect_lifted. Qed. Definition test_letin (A : Type) (xs : {n:nat & vector A n}) : {n:nat & vector A n} := let n := projT1 xs in existT _ n (projT2 xs).Lift vector list in test_letin as test_letin_list_lifted.Lemma test_letin_list_lifted_ok (A : Type) (xs : list A) : test_letin_list_lifted A xs = xs. Proof. reflexivity. Defined.Lemma tl_ok: forall (A : Type) (x : A) (xs xs' : list A), xs = cons x xs' -> tl A xs = xs'. Proof. intros A a xs xs' E. rewrite E. reflexivity. Defined.Lift list vector in tl_ok as tlV_ok. Theorem test_tlV_ok: forall (A : Type) (x : A) (xs xs' : sigT (vector A)), existT (vector A) (projT1 xs) (projT2 xs) = existT (vector A) (S (projT1 xs')) (consV A (projT1 xs') x (projT2 xs')) -> tl_vect_lifted A (existT (vector A) (projT1 xs) (projT2 xs)) = (existT (vector A) (projT1 xs') (projT2 xs')). 
y; unfold Zfloor. unfold Zminus; rewrite Zplus_assoc; f_equal. apply sym_eq, tech_up. rewrite plus_IZR. apply Rplus_lt_compat_l. apply archimed. rewrite plus_IZR, Rplus_assoc. apply Rplus_le_compat_l. apply Rplus_le_reg_r with (-y)%R. ring_simplify (y+1+-y)%R. apply archimed. Qed.Lemma Zceil_plus: forall (n:Z) y, (Zceil (IZR n+y) = n + Zceil y)%Z. Proof. intros n y; unfold Zceil. rewrite Ropp_plus_distr, <- Ropp_Ropp_IZR. rewrite Zfloor_plus. ring. Qed. Lemma Zeven_abs: forall z, Z.even (Z.abs z) = Z.even z. Proof. intros z; case (Zle_or_lt z 0); intros H1. rewrite Z.abs_neq; try assumption. apply Z.even_opp. rewrite Z.abs_eq; auto with zarith. Qed. Lemma Zrnd_odd_plus: forall x y, (x = IZR (Zfloor x)) -> Z.even (Zfloor x) = true -> (IZR (Zrnd_odd (x+y)) = x+IZR (Zrnd_odd y))%R. Proof. intros x y Hx H. unfold Zrnd_odd; rewrite Hx, Zfloor_plus. case (Req_EM_T y (IZR (Zfloor y))); intros Hy. rewrite Hy; repeat rewrite <- plus_IZR. repeat rewrite Zfloor_IZR. case (Req_EM_T _ _); intros K; easy. case (Req_EM_T _ _); intros K. contradict Hy. apply Rplus_eq_reg_l with (IZR (Zfloor x)). now rewrite K, plus_IZR. rewrite Z.even_add, H; simpl. case (Z.even (Zfloor y)). now rewrite Zceil_plus, plus_IZR. now rewrite plus_IZR. Qed. Section Fcore_rnd_odd.Variable beta : radix.Notation bpow e := (bpow beta e).Variable fexp : Z -> Z.Context { valid_exp : Valid_exp fexp }. Context { exists_NE_ : Exists_NE beta fexp }.Notation format := (generic_format beta fexp). Notation canonical := (canonical beta fexp). Notation cexp := (cexp beta fexp). Definition Rnd_odd_pt (x f : R) := format f /\ ((f = x)%R \/ ((Rnd_DN_pt format x f \/ Rnd_UP_pt format x f) /\ exists g : float beta, f = F2R g /\ canonical g /\ Z.even (Fnum g) = false)).Definition Rnd_odd (rnd : R -> R) := forall x : R, Rnd_odd_pt x (rnd x).Theorem Rnd_odd_pt_opp_inv : forall x f : R, Rnd_odd_pt (-x) (-f) -> Rnd_odd_pt x f. Proof with auto with typeclass_instances. intros x f (H1,H2). split. replace f with (-(-f))%R by ring. now apply generic_format_opp. destruct H2. left. replace f with (-(-f))%R by ring. rewrite H; ring. right. destruct H as (H2,(g,(Hg1,(Hg2,Hg3)))). split. destruct H2. right. replace f with (-(-f))%R by ring. replace x with (-(-x))%R by ring. apply Rnd_UP_pt_opp... apply generic_format_opp. left. replace f with (-(-f))%R by ring. replace x with (-(-x))%R by ring. apply Rnd_DN_pt_opp... apply generic_format_opp. exists (Float beta (-Fnum g) (Fexp g)). split. rewrite F2R_Zopp. replace f with (-(-f))%R by ring. rewrite Hg1; reflexivity. split. now apply canonical_opp. simpl. now rewrite Z.even_opp. Qed. Theorem round_odd_opp : forall x, round beta fexp Zrnd_odd (-x) = (- round beta fexp Zrnd_odd x)%R. 
Require Import Undecidability.Synthetic.Undecidability.Require Import Undecidability.StackMachines.SSM.Require Undecidability.StackMachines.Reductions.SMNdl_UB_to_CSSM_UB. Require Import Undecidability.StackMachines.SMN_undec. Theorem CSSM_UB_undec : undecidable CSSM_UB. 
X. Proof. red in |- *; intros X x H'; elim H'. Qed. Hint Resolve Empty_set_minimal. Theorem Power_set_non_empty : forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A). Proof. intro A'; apply Non_empty_intro with (Empty_set U); auto. Qed. Hint Resolve Power_set_non_empty. Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U). Proof. auto 8. Qed. Hint Resolve Inclusion_is_an_order. Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U). elim Inclusion_is_an_order; auto. Qed. Hint Resolve Inclusion_is_transitive. Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U). Proof. generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H'; auto. Qed. Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U). Proof. elim Same_set_equivalence; auto. Qed. Hint Resolve Same_set_reflexive. Theorem Power_set_PO : PO (Ensemble U). Proof. apply Definition_of_PO with (Power_set A) (Included U); auto. Defined. Theorem Union_minimal : forall a b X : Ensemble U, Included U a X -> Included U b X -> Included U (Union U a b) X. Proof. intros a b X H' H'0; red in |- *; (intros x H'1; elim H'1); auto. Qed. Hint Resolve Union_minimal. Theorem Intersection_maximal : forall a b X : Ensemble U, Included U X a -> Included U X b -> Included U X (Intersection U a b). Proof. auto. Qed. Theorem Union_increases_l : forall a b : Ensemble U, Included U a (Union U a b). Proof. auto. Qed. Theorem Union_increases_r : forall a b : Ensemble U, Included U b (Union U a b). Proof. auto. Qed. Theorem Intersection_decreases_l : forall a b : Ensemble U, Included U (Intersection U a b) a. Proof. intros a b; red in |- *; auto. intros x H'; elim H'; auto. Qed. Theorem Intersection_decreases_r : forall a b : Ensemble U, Included U (Intersection U a b) b. Proof. intros a b; red in |- *; auto. intros x H'; elim H'; auto. Qed. Hint Resolve Union_increases_l Union_increases_r Intersection_decreases_l Intersection_decreases_r. Theorem Empty_set_is_Bottom : Bottom (Ensemble U) Power_set_PO (Empty_set U). Proof. apply Bottom_definition; simpl in |- *; auto. Qed. Hint Resolve Empty_set_is_Bottom. Theorem Union_is_Lub : forall a b : Ensemble U, Included U a A -> Included U b A -> Lub (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Union U a b). Proof. intros a b H' H'0. apply Lub_definition; simpl in |- *. apply Upper_Bound_definition; simpl in |- *. auto. intros y H'1; elim H'1; auto. intros y H'1; elim H'1; simpl in |- *; auto. Qed. Theorem Intersection_is_Glb : forall a b : Ensemble U, Included U a A -> Included U b A -> Glb (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Intersection U a b). 
rewrite valulen_is. compute. reflexivity. Qed. Definition superblock0 := @Rec.of_word superblock_type (wzero _). Definition superblock_pad0 := @Rec.of_word superblock_padded (wzero _). Definition pickle_superblock (fsxp : fs_xparams) : word (Rec.len superblock_padded) := let (lxp, ixp, dbxp1, dbxp2, ibxp, rootinum, maxblock, magic) := fsxp in let sb := superblock0 :=> "data_start" := addr2w (DataStart lxp) :=> "log_header" := addr2w (LogHeader lxp) :=> "log_descr" := addr2w (LogDescriptor lxp) :=> "log_descrlen":= addr2w (LogDescLen lxp) :=> "log_data" := addr2w (LogData lxp) :=> "log_len" := addr2w (LogLen lxp) :=> "ixstart" := addr2w (IXStart ixp) :=> "ixlen" := addr2w (IXLen ixp) :=> "bastart1" := addr2w (BmapStart dbxp1) :=> "banblocks1" := addr2w (BmapNBlocks dbxp1) :=> "bastart2" := addr2w (BmapStart dbxp2) :=> "banblocks2" := addr2w (BmapNBlocks dbxp2) :=> "iastart" := addr2w (BmapStart ibxp) :=> "ianblocks" := addr2w (BmapNBlocks ibxp) :=> "root_inum" := addr2w rootinum :=> "maxblock" := addr2w maxblock :=> "magic" := addr2w magic in Rec.to_word (superblock_pad0 :=> "sb" := sb). Definition unpickle_superblock (sbp : word (Rec.len superblock_padded)) : fs_xparams := let sb := ((Rec.of_word sbp) :-> "sb") in let lxp := Build_log_xparams # (sb :-> "data_start") # (sb :-> "log_header") # (sb :-> "log_descr") # (sb :-> "log_descrlen") # (sb :-> "log_data") # (sb :-> "log_len") in let ixp := Build_inode_xparams # (sb :-> "ixstart") # (sb :-> "ixlen") in let dbxp1 := Build_balloc_xparams # (sb :-> "bastart1") # (sb :-> "banblocks1") in let dbxp2 := Build_balloc_xparams # (sb :-> "bastart2") # (sb :-> "banblocks2") in let ibxp := Build_balloc_xparams # (sb :-> "iastart") # (sb :-> "ianblocks") in let rootinum := # (sb :-> "root_inum") in let maxblock := # (sb :-> "maxblock") in let magic := # (sb :-> "magic") in Build_fs_xparams lxp ixp dbxp1 dbxp2 ibxp rootinum maxblock magic. Theorem pickle_unpickle_superblock : forall fsxp, fs_xparams_ok fsxp -> unpickle_superblock (pickle_superblock fsxp) = fsxp. Proof. unfold pickle_superblock, unpickle_superblock. destruct fsxp. repeat rewrite Rec.of_to_id. destruct FSXPLog. destruct FSXPInode. destruct FSXPInodeAlloc. destruct FSXPBlockAlloc1. destruct FSXPBlockAlloc2. unfold Rec.recget', Rec.recset'. unfold addr2w; simpl; intros. repeat rewrite wordToNat_natToWord_idempotent' by xparams_ok. auto. unfold Rec.well_formed. simpl. intuition. Qed. Definition v_pickle_superblock (fsxp : fs_xparams) : valu. remember (pickle_superblock fsxp) as sb; clear Heqsb. rewrite superblock_padded_len in *. exact sb. Defined. Definition v_unpickle_superblock (v : valu) : fs_xparams. rewrite <- superblock_padded_len in *. exact (unpickle_superblock v). Defined. Theorem v_pickle_unpickle_superblock : forall fsxp, fs_xparams_ok fsxp -> v_unpickle_superblock (v_pickle_superblock fsxp) = fsxp. Proof. intros. unfold v_pickle_superblock, v_unpickle_superblock. unfold eq_rec_r, eq_rec. rewrite eq_rect_nat_double. rewrite <- (eq_rect_eq_dec eq_nat_dec). apply pickle_unpickle_superblock; auto. Qed. Theorem goodSize_magic_number : goodSize addrlen magic_number. 
intros H; destruct H. apply Rle_trans with (1:=error_le_half_ulp _ _). apply Rmult_le_compat_l. apply Rlt_le, pos_half_prf. apply ulp_le_pos; trivial. case (Rle_or_lt 0 x); trivial. intros H1; contradict H. apply Rle_not_lt. apply round_le_generic... apply generic_format_0. now left. rewrite Hx; apply (round_UP_pt beta fexp x). rewrite Hx in Hfx; contradict Hfx; auto with real. intros H. rewrite Hx at 2; rewrite <- (ulp_opp (round beta fexp Zceil x)). rewrite <- round_DN_opp. rewrite ulp_DN; trivial. pattern x at 1 2; rewrite <- Ropp_involutive. rewrite round_N_opp. unfold Rminus. rewrite <- Ropp_plus_distr, Rabs_Ropp. apply error_le_half_ulp. rewrite round_DN_opp; apply Ropp_0_gt_lt_contravar; apply Rlt_gt; assumption. Qed.Theorem pred_le : forall x y, F x -> F y -> (x <= y)%R -> (pred x <= pred y)%R. Proof. intros x y Fx Fy [Hxy| ->]. 2: apply Rle_refl. apply le_pred_lt with (2 := Fy). now apply generic_format_pred. apply Rle_lt_trans with (2 := Hxy). apply pred_le_id. Qed.Theorem succ_le: forall x y, F x -> F y -> (x <= y)%R -> (succ x <= succ y)%R. Proof. intros x y Fx Fy Hxy. rewrite 2!succ_eq_opp_pred_opp. apply Ropp_le_contravar, pred_le; try apply generic_format_opp; try assumption. now apply Ropp_le_contravar. Qed.Theorem pred_le_inv: forall x y, F x -> F y -> (pred x <= pred y)%R -> (x <= y)%R. Proof. intros x y Fx Fy Hxy. rewrite <- (succ_pred x), <- (succ_pred y); try assumption. apply succ_le; trivial; now apply generic_format_pred. Qed.Theorem succ_le_inv: forall x y, F x -> F y -> (succ x <= succ y)%R -> (x <= y)%R. Proof. intros x y Fx Fy Hxy. rewrite <- (pred_succ x), <- (pred_succ y); try assumption. apply pred_le; trivial; now apply generic_format_succ. Qed.Theorem pred_lt : forall x y, F x -> F y -> (x < y)%R -> (pred x < pred y)%R. Proof. intros x y Fx Fy Hxy. apply Rnot_le_lt. intros H. apply Rgt_not_le with (1 := Hxy). now apply pred_le_inv. Qed.Theorem succ_lt : forall x y, F x -> F y -> (x < y)%R -> (succ x < succ y)%R. Proof. intros x y Fx Fy Hxy. apply Rnot_le_lt. intros H. apply Rgt_not_le with (1 := Hxy). now apply succ_le_inv. Qed. Theorem le_round_DN_lt_UP : forall x y, F y -> (y < round beta fexp Zceil x -> y <= round beta fexp Zfloor x)%R. Proof with auto with typeclass_instances. intros x y Fy Hlt. apply round_DN_pt... apply Rnot_lt_le. contradict Hlt. apply RIneq.Rle_not_lt. apply round_UP_pt... now apply Rlt_le. Qed. Theorem round_UP_le_gt_DN : forall x y, F y -> (round beta fexp Zfloor x < y -> round beta fexp Zceil x <= y)%R. 
(inj_abs x) in H'0. rewrite H'0. repeat rewrite <- INR_IZR_INZ; auto. apply le_IZR; simpl in |- *. rewrite <- H'0; auto. apply RleRoundedR0 with (P := P) (r := INR n); auto. replace 0%R with (INR 0); auto with real arith. Qed. Theorem FUlp_Le_LSigB : forall x : float, Fbounded b x -> (Fulp x <= Float 1%nat (LSB radix x))%R. intros x H; unfold is_Fzero, Fulp, Fnormalize in |- *; case (Z_zerop (Fnum x)); intros ZH. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_l. apply Rle_powerRZ. replace 1%R with (INR 1); auto with real arith. apply Zle_trans with (Fexp x); auto. case H; auto. apply Fexp_le_LSB; auto. rewrite LSB_shift with (n := min (precision - Fdigit radix x) (Zabs_nat (dExp b + Fexp x))); auto. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_l. apply Rle_powerRZ; auto with arith. replace 1%R with (INR 1); auto with real arith. exact (Fexp_le_LSB radix (Fshift radix (min (precision - Fdigit radix x) (Zabs_nat (dExp b + Fexp x))) x)). Qed. Theorem MSBisMin : forall f1 f2 : float, (0 <= f1)%R -> isMin b radix f1 f2 -> ~ is_Fzero f1 -> ~ is_Fzero f2 -> MSB radix f1 = MSB radix f2. intros f1 f2 H' H'0 H'1 H'2. apply Zle_antisym. 2: apply MSB_monotone; auto. 2: repeat rewrite Fabs_correct1; auto with arith. 2: apply isMin_inv1 with (1 := H'0). 2: apply RleRoundedR0 with (P := isMin b radix) (r := FtoRradix f1); auto. 2: apply MinRoundedModeP with (precision := precision); auto. case (Zle_or_lt (MSB radix f1) (MSB radix f2)); auto. intros H'3; absurd (Float 1%nat (Zsucc (MSB radix f2)) <= f2)%R. apply Rgt_not_le. red in |- *; unfold FtoRradix in |- *; rewrite <- Fabs_correct1; auto with float arith. apply abs_lt_MSB; auto. apply RleRoundedR0 with (P := isMin b radix) (r := FtoRradix f1); auto with float. apply MinRoundedModeP with (precision := precision); auto. case H'0. intros H'4 H'5; elim H'5; intros H'6 H'7; apply H'7; clear H'5; auto. apply (FboundedOne _ radixMoreThanOne b precision); auto with arith. apply Zle_trans with (Fexp f2). case H'4; auto. apply Zle_trans with (MSB radix f2); auto with zarith. apply Fexp_le_MSB; auto. apply Rle_trans with (FtoR radix (Float 1%nat (MSB radix f1))); auto. apply oneExp_le; auto with zarith. unfold FtoRradix in |- *; rewrite <- Fabs_correct1 with (x := f1); auto with float arith. apply MSB_le_abs; auto. Qed. Theorem MSBtoZero : forall f1 f2 : float, ToZeroP b radix f1 f2 -> ~ is_Fzero f1 -> ~ is_Fzero f2 -> MSB radix f1 = MSB radix f2. 
destruct Dex as [ H | H ]. + left. destruct H as (v & Hv). exists (vec_pos v); auto. + right; contradict H. destruct H as (P & HP). exists (vec_set_pos P). revert HP; apply HK. intro; rew vec. Qed.End decidable_fun_pos_bool.Section decidable_fun_finite_bool. Variable (X : Type) (H1 : finite_t X) (H2 : discrete X) (K : (X -> bool) -> Prop) (HK : forall P Q, (forall x, P x = Q x) -> K P <-> K Q) (Dec : forall P, decidable (K P)). Let D : { n : nat & bij_t X (pos n) }. Proof. apply finite_t_discrete_bij_t_pos; auto. Qed. Let n := projT1 D. Let i : X -> pos n := projT1 (projT2 D). Let j : pos n -> X := proj1_sig (projT2 (projT2 D)). Let Hji : forall x, j (i x) = x. Proof. apply (proj2_sig (projT2 (projT2 D))). Qed. Let Hij : forall y, i (j y) = y. Proof. apply (proj2_sig (projT2 (projT2 D))). Qed. Let T P := K (fun p => P (i p)). Let T_ext P Q : (forall x, P x = Q x) -> T P <-> T Q. Proof. intros H; apply HK; intro; apply H. Qed. Let T_dec P : decidable (T P). Proof. apply Dec. Qed. Theorem fa_fun_bool_decidable : decidable (forall P, K P). Proof using HK H2 H1 Dec. assert (H : decidable (forall P, T P)). { apply fa_fun_pos_bool_decidable; auto. } destruct H as [ H | H ]; [ left | right ]. + intros P. generalize (H (fun p => P (j p))). apply HK; intro; rewrite Hji; auto. + contradict H; intros P; apply H. Qed. Theorem ex_fun_bool_decidable : decidable (exists P, K P). Proof using HK H2 H1 Dec. assert (H : decidable (exists P, T P)). { apply ex_fun_pos_bool_decidable; auto. } destruct H as [ H | H ]; [ left | right ]. + destruct H as (P & H). exists (fun x => P (i x)); auto. + contradict H. destruct H as (P & H). exists (fun p => P (j p)). revert H; apply HK. intro; rewrite Hji; auto. Qed.End decidable_fun_finite_bool.Section decidable_upto. Variable (X : Type) (R : X -> X -> Prop) (P : X -> Prop) (HP : forall x, decidable (P x)) (HR : forall x y, R x y -> P x <-> P y). Theorem decidable_list_upto_fa l : (forall x, exists y, In y l /\ R x y) -> decidable (forall x, P x). 
forall x:A, sorted (x :: nil) | sorted2 : forall (x y:A) (l:list A), Ale x y -> sorted (y :: l) -> sorted (x :: y :: l).Inductive permutation : list A -> list A -> Prop := | transpose_first : forall (a b:A) (l:list A), permutation (a :: b :: l) (b :: a :: l) | permutation_same_head : forall (a:A) (l1 l2:list A), permutation l1 l2 -> permutation (a :: l1) (a :: l2) | permutation_empty : permutation nil nil | permutation_transitive : forall l1 l2 l3:list A, permutation l1 l2 -> permutation l2 l3 -> permutation l1 l3.Parameter sort_sorted : forall l:list A, sorted (sort l).Parameter sort_permutation : forall l:list A, permutation (sort l) l.End SORTING_BASICS.Module merge_sort_basics (Data: Comparable_data) : SORTING_BASICS with Definition A := Data.A with Definition Ale := Data.Ale with Definition Ale_dec := Data.Ale_dec.Definition A := Data.A. Definition Ale := Data.Ale. Definition Ale_dec := Data.Ale_dec.Fixpoint merge_aux (l1 l2:list A) (b:nat) {struct b} : list A := match b with | O => nil (A:=A) | S b' => match l1, l2 with | nil, l => l | l, nil => l | a :: l, b :: l' => match Ale_dec a b with | left _ => a :: merge_aux l (b :: l') b' | right _ => b :: merge_aux (a :: l) l' b' end end end.Definition merge (l1 l2:list A) := merge_aux l1 l2 (length l1 + length l2).Fixpoint mk_singletons (l:list A) : list (list A) := match l with | nil => nil (A:=(list A)) | a :: tl => (a :: nil) :: mk_singletons tl end.Fixpoint sort_aux1 (l:list (list A)) : list (list A) := match l with | l1 :: l2 :: tl => merge l1 l2 :: sort_aux1 tl | _ => l end. Fixpoint sort_aux2 (l:list (list A)) (b:nat) {struct b} : list A := match b with | O => nil (A:=A) | S b' => match l with | nil => nil (A:=A) | l' :: nil => l' | _ => sort_aux2 (sort_aux1 l) b' end end.Definition sort (l:list A) := sort_aux2 (mk_singletons l) (length l).Inductive sorted : list A -> Prop := | sorted0 : sorted nil | sorted1 : forall x:A, sorted (x :: nil) | sorted2 : forall (x y:A) (l:list A), Ale x y -> sorted (y :: l) -> sorted (x :: y :: l). Theorem sorted_inv : forall (a:A) (l:list A), sorted (a :: l) -> sorted l. 
(length (a :: l) - S n). inversion H. rewrite <- minus_n_n; simpl. rewrite <- rev_length. rewrite app_nth2; auto. rewrite <- minus_n_n; auto. rewrite app_nth1; auto. rewrite (minus_plus_simpl_l_reverse (length l) n 1). replace (1 + length l) with (S (length l)); auto with arith. rewrite <- minus_Sn_m; [|auto with arith]. apply IHl ; auto with arith. rewrite rev_length; auto. Qed. Fixpoint rev_append (l l': list A) {struct l} : list A := match l with | nil => l' | a::l => rev_append l (a::l') end. Definition rev' l : list A := rev_append l nil. Notation rev_acc := rev_append (only parsing). Lemma rev_append_rev : forall l l', rev_acc l l' = rev l ++ l'. Proof. induction l; simpl; auto; intros. rewrite <- ass_app; firstorder. Qed. Notation rev_acc_rev := rev_append_rev (only parsing). Lemma rev_alt : forall l, rev l = rev_append l nil. Proof. intros; rewrite rev_append_rev. apply app_nil_end. Qed. Section Reverse_Induction. Unset Implicit Arguments. Lemma rev_list_ind : forall P:list A-> Prop, P nil -> (forall (a:A) (l:list A), P (rev l) -> P (rev (a :: l))) -> forall l:list A, P (rev l). Proof. induction l; auto. Qed. Set Implicit Arguments. Theorem rev_ind : forall P:list A -> Prop, P nil -> (forall (x:A) (l:list A), P l -> P (l ++ x :: nil)) -> forall l:list A, P l. Proof. intros. generalize (rev_involutive l). intros E; rewrite <- E. apply (rev_list_ind P). auto. simpl in |- *. intros. apply (H0 a (rev l0)). auto. Qed. End Reverse_Induction. Section Permutation. Inductive Permutation : list A -> list A -> Prop := | perm_nil: Permutation nil nil | perm_skip: forall (x:A) (l l':list A), Permutation l l' -> Permutation (cons x l) (cons x l') | perm_swap: forall (x y:A) (l:list A), Permutation (cons y (cons x l)) (cons x (cons y l)) | perm_trans: forall (l l' l'':list A), Permutation l l' -> Permutation l' l'' -> Permutation l l''. Hint Constructors Permutation. Theorem Permutation_nil : forall (l : list A), Permutation nil l -> l = nil. Proof. intros l HF. set (m:=@nil A) in HF; assert (m = nil); [reflexivity|idtac]; clearbody m. induction HF; try elim (nil_cons (sym_eq H)); auto. Qed. Theorem Permutation_nil_cons : forall (l : list A) (x : A), ~ Permutation nil (x::l). Proof. unfold not; intros l x HF. elim (@nil_cons A x l). apply sym_eq. exact (Permutation_nil HF). Qed. Theorem Permutation_refl : forall l : list A, Permutation l l. 
Require Import Iron.Language.SystemF2Data.Exp. Require Import Iron.Language.SystemF2Data.Step.Step. Require Import Iron.Language.SystemF2Data.Step.Steps. Require Import Iron.Language.SystemF2Data.Step.Stepsl. Lemma preservation_prim : forall ds p vsArg vResult t , Forall wnfX vsArg -> STEP (XPrim p vsArg) vResult -> TYPE ds nil nil (XPrim p vsArg) t -> TYPE ds nil nil vResult t. Proof. intros ds p vs vResult t HV HS HT. inverts HT. inverts HS. - inverts H0; nope. inverts H. have (wnfX x) by (eapply exps_ctx_Forall; eauto). eapply step_wnfX in H; eauto. subst. eauto. - destruct p. + SCase "PAdd". simpl in H1. inverts H1. inverts H3. inverts H6. have (wnfX x). have (wnfX x0). eapply value_form_nat in H4; eauto. destruct H4 as [n1]. eapply value_form_nat in H3; eauto. destruct H3 as [n2]. subst. snorm. + SCase "PIsZero". simpl in H1. inverts H1. inverts H3. inverts H6. have (wnfX x). eapply value_form_nat in H4; eauto. destruct H4 as [n1]. subst. snorm. Qed. Theorem preservation : forall ds x x' t , TYPE ds nil nil x t -> STEP x x' -> TYPE ds nil nil x' t. 
∈ (Func 𝜇 (𝜆 ⟶  ) (λ b, Func 𝜆  (λ a, g[<a, b>])))). { intros x Hx. apply SepI; zfc_simple. - apply CPrdI. rewrite <- Hdf... apply Hrf. eapply ap_ran... split... - apply H1... } assert (H3: dom (Func 𝜇 (𝜆 ⟶  ) (λ y, Func 𝜆  (λ x, g[<x, y>]))) = dom f). { ext Hx. - apply domE in Hx as [y Hp]. apply SepE in Hp as [Hx _]. apply CPrdE2 in Hx as [Hx _]... - eapply domI. apply H2... } exists g. split. + apply SepI. { apply PowerAx. intros p Hp. apply SepE1 in Hp... } apply meta_function. intros p Hp. apply CPrdE1 in Hp as [a [Ha [b [Hb Hp]]]]. subst p. zfc_simple. rewrite <- Hdf in Hb. apply func_correct in Hb... apply ranI in Hb. apply Hrf in Hb. apply arrow_iff in Hb as [_ [_ Hr]]. apply Hr... + apply func_ext_intro... apply func_is_func. intros x Hx. rewrite H3 in Hx. apply func_ap. apply func_is_func. apply H2... Qed.Lemma cardAdd_suc : ∀  𝜆,  + (𝜆 + 1) = ( + 𝜆) + 1. Proof. intros. rewrite cardAdd_assoc. auto. Qed.Lemma cardMul_suc : ∀ ⋵ 𝐂𝐃, ∀ 𝜆,   (𝜆 + 1) =   𝜆 +  . Proof. intros  H 𝜆. rewrite cardMul_distr, cardMul_1_r; auto. Qed.Lemma cardExp_suc : ∀ ⋵ 𝐂𝐃, ∀ 𝜆,  ^ (𝜆 + 1) =  ^ 𝜆   . Proof. intros  H 𝜆. rewrite cardExp_add, cardExp_1_r; auto. Qed.Lemma card_suc : ∀n ∈ ω, n + 1 = n⁺. Proof with auto; try easy. intros n Hn. rewrite (card_of_nat n⁺); [|apply ω_inductive]... apply CardAx1. apply cardAdd_well_defined. - rewrite <- eqnum_cprd_single... - rewrite <- eqnum_cprd_single, eqnum_single... - apply disjointify_0_1. - apply nat_disjoint... Qed. Theorem fin_cardAdd_eq_add : ∀ m n ∈ ω, m + n = (m + n)%ω. Proof with auto. intros m Hm n Hn. generalize dependent m. ω_induction n; intros k Hk. - rewrite cardAdd_0_r, add_0_r... apply nat_is_card... - rewrite <- card_suc at 1... rewrite <- cardAdd_assoc, IH, card_suc, add_suc... apply add_ran... Qed. Theorem fin_cardMul_eq_mul : ∀ m n ∈ ω, m  n = (m  n)%ω. Proof with auto. intros m Hm n Hn. generalize dependent m. ω_induction n; intros k Hk. - rewrite cardMul_0_r_r, mul_0_r... - rewrite <- card_suc at 1... rewrite cardMul_suc, IH, fin_cardAdd_eq_add, mul_suc, add_comm... apply mul_ran... apply mul_ran... apply nat_is_card... Qed. Theorem fin_cardExp_eq_exp : ∀ m n ∈ ω, m ^ n = (m ^ n)%ω. 
Require Import List. Import ListNotations.Require Import Undecidability.SemiUnification.SemiU.Require Import ssreflect ssrfun ssrbool.Require Import Undecidability.Synthetic.Definitions. Theorem reduction : RU2SemiU ⪯ SemiU. 
Qed. Require Import Bedrock.Platform.Cito.GLabelMap. Import GLabelMap. Require Import Bedrock.Platform.Cito.GLabelMapFacts. Import FMapNotations. Require Import ConvertLabelMap. Lemma to_blm_Submap : forall elt m1 m2, @LabelMapFacts.Submap elt (to_blm m1) (to_blm m2) <-> m1 <= m2. Proof. unfold Submap, LabelMapFacts.Submap. intros; split; intros. { repeat erewrite <- to_blm_spec in *; eauto. } destruct k. destruct l; simpl in *. { replace ((s, Labels.Global s0)) with (to_bedrock_label (s, s0)) in * by eauto. repeat erewrite to_blm_spec in *. eauto. } repeat rewrite to_blm_no_local in *. discriminate. Qed. Theorem make_module_exports_submap : LabelMapFacts.Submap (to_blm (mapi (foreign_func_spec) (map_aug_mod_name ax_mod_name exports))) (Exports make_module). Proof. simpl. rewrite exps_spec. eapply to_blm_Submap. intros k v Hk. eapply find_mapsto_iff in Hk. eapply mapi_mapsto_iff in Hk; [ | intros; subst; eauto]. destruct Hk as [ax [? Hk] ]. subst. eapply find_mapsto_iff in Hk. eapply map_aug_mod_name_elim in Hk. destruct Hk as [x [? Hx] ]. subst. unfold func_to_import; simpl in *. unfold stubs. rewrite map_map. simpl. eapply find_mapsto_iff. eapply MapsTo_to_map. { eapply NoDupKey_aug_mod_name. intros; simpl; eauto. } eapply in_map_iff. unfold stub_spec; simpl. Require Import Bedrock.Platform.Cito.StringMap. Import StringMap. Require Import Bedrock.Platform.Cito.StringMapFacts. Import FMapNotations. assert (Hx' : In x (Funs m)). { eapply exports_sub_domain; eauto. eapply find_Some_in; eauto. } eapply in_find_Some in Hx'. destruct Hx' as [f Hx']. exists (x, (f, ax)); split; eauto. eapply find_in_elements. eapply find_inter_intro; eauto. Qed. Import LabelMap. Import LabelMapFacts. Import FMapNotations. Lemma Submap_Equal elt (m1 m2 : t elt) : m1 <= m2 -> m2 <= m1 -> m1 == m2. Proof. intros H1 H2. intros k. eapply option_univalence. intros v; split; eauto. Qed. Require Import Bedrock.Platform.Cito.GLabelMap. Import GLabelMap. Require Import Bedrock.Platform.Cito.GLabelMapFacts. Import FMapNotations. Theorem make_module_exports_submap2 : LabelMapFacts.Submap (Exports make_module) (to_blm (mapi (foreign_func_spec) (map_aug_mod_name ax_mod_name exports))). Proof. simpl. rewrite exps_spec. eapply to_blm_Submap. intros k v Hk. unfold func_to_import in *; simpl in *. unfold stubs in *. rewrite map_map in Hk. simpl in *. eapply find_mapsto_iff in Hk. eapply MapsTo_to_map_elim in Hk. Focus 2. { eapply NoDupKey_aug_mod_name. intros; simpl; eauto. } Unfocus. eapply in_map_iff in Hk. unfold stub_spec in *; simpl in *. Require Import Bedrock.Platform.Cito.StringMap. Import StringMap. Require Import Bedrock.Platform.Cito.StringMapFacts. Import FMapNotations. destruct Hk as [ [x [f ax] ] [Hinj Hx] ]. simpl in *. inject Hinj. eapply in_elements_find in Hx. eapply find_inter_elim in Hx; eauto. destruct Hx as [H1 H2]. Require Import Bedrock.Platform.Cito.GLabelMap. Import GLabelMap. Require Import Bedrock.Platform.Cito.GLabelMapFacts. Import FMapNotations. eapply find_mapsto_iff. eapply mapi_mapsto_iff; [ intros; subst; eauto | ]. exists ax; split; eauto. eapply find_mapsto_iff. eapply map_aug_mod_name_intro; eauto. Qed. Theorem make_module_exports_equal : LabelMap.Equal (Exports make_module) (to_blm (mapi (foreign_func_spec) (map_aug_mod_name ax_mod_name exports))). 
Require Import Coq.Relations.Relation_Operators. Require Import Main.Experiments.Overtree.Overtree. Require Import Main.Experiments.Overtree.OvertreeTheorems. Require Import Main.Tactics.Module TrivialOvertree <: Overtree. #[local] Arguments clos_refl_trans {A} _ _ _. #[local] Hint Resolve rt_refl : main. Definition node := unit. #[export] Hint Unfold node : main. Definition edge (n1 n2 : node) := True. #[export] Hint Unfold edge : main. Definition proxy (n : node) := tt. #[export] Hint Unfold proxy : main. Definition covalent n1 n2 := edge n1 n2 /\ proxy n1 = proxy n2. #[export] Hint Unfold covalent : main. Definition horizontallyReachable := clos_refl_trans covalent. #[export] Hint Unfold horizontallyReachable : main. Definition proxies n1 n2 := proxy n2 = n1 /\ exists n3, edge n1 n3 /\ horizontallyReachable n3 n2. #[export] Hint Unfold proxies : main. Definition verticallyReachable := clos_refl_trans proxies. #[export] Hint Unfold verticallyReachable : main. Definition root := tt. #[export] Hint Unfold root : main. Theorem rootLoop : edge root root. Proof. magic. Qed. #[export] Hint Resolve rootLoop : main. Theorem rootProxy : proxy root = root. 
Require Export Pcomb. Require Export Pcrit. Require Export Buch. Require Export Fred. Require Import Buch.Local Unset Injection On Proofs.Section BuchRed. Load "hCoefStructure". Load "hOrderStructure". Load "hBuch". Theorem Cb_addEnd_cons : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L). intros L p q H; apply Cb_incl with (1 := cs) (P := addEnd A A0 eqA n ltM p L); auto. elim L; simpl in |- *; auto. intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto. case (H0 a0); auto. Qed. Theorem Cb_cons_addEnd : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L). intros L p q H; apply Cb_incl with (1 := cs) (P := p :: L); auto. elim L; simpl in |- *; auto. intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto. case H1; auto. Qed. Theorem Cb_trans_cons : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L. 
Require Export Fround. Require Export MSB. Section FRoundP. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Coercion FtoRradix : float >-> R. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition Fulp (p : float) := powerRZ radix (Fexp (Fnormalize radix b precision p)). Theorem FulpComp : forall p q : float, Fbounded b p -> Fbounded b q -> p = q :>R -> Fulp p = Fulp q. intros p q H' H'0 H'1; unfold Fulp in |- *. rewrite FcanonicUnique with (p := Fnormalize radix b precision p) (q := Fnormalize radix b precision q) (3 := pGivesBound); auto with float arith. apply trans_eq with (FtoR radix p). apply FnormalizeCorrect; auto. apply trans_eq with (FtoR radix q); auto. apply sym_eq; apply FnormalizeCorrect; auto. Qed. Theorem FulpLe : forall p : float, Fbounded b p -> (Fulp p <= Float 1 (Fexp p))%R. 
"∸" := Ropp. Add Ring Rring : R_is_ring. Definition M22 := (R * R * R * R)%type. Definition ID_22 : M22 := (o,z,z,o). Definition ZE_22 : M22 := (z,z,z,z). Definition PL22 : M22 -> M22 -> M22. Proof. intros (((a,b),c),d) (((a',b'),c'),d'). exact (a⊕a',b⊕b', c⊕c',d⊕d'). Defined. Infix "⊞" := PL22 (at level 50, left associativity). Definition MI22 : M22 -> M22. Proof. intros (((a,b),c),d). exact (∸a,∸b, ∸c,∸d). Defined. Notation "⊟" := MI22. Fact M22_equal (a b c d a' b' c' d' : R) : a = a' -> b = b' -> c = c' -> d = d' -> (a,b,c,d) = (a',b',c',d'). Proof. intros; subst; trivial. Qed. Fact M22plus_zero : forall m, ZE_22 ⊞ m = m. Proof. intros (((a,b),c),d); apply M22_equal; ring. Qed. Fact M22plus_comm : forall x y, x ⊞ y = y ⊞ x. Proof. intros (((a,b),c),d) (((a',b'),c'),d'); apply M22_equal; ring. Qed. Fact M22plus_assoc : forall x y u, x ⊞ (y ⊞ u) = x ⊞ y ⊞ u. Proof. intros (((a,b),c),d) (((a',b'),c'),d') (((a'',b''),c''),d''); simpl; apply M22_equal; ring. Qed. Fact M22minus : forall x, x ⊞ ⊟ x = ZE_22. Proof. intros (((a,b),c),d); apply M22_equal; ring. Qed. Fact M22plus_cancel : forall x a b, x ⊞ a = x ⊞ b -> a = b. Proof. intros x a b H. rewrite <- (M22plus_zero a), <- (M22minus x), (M22plus_comm x), <- M22plus_assoc, H, M22plus_assoc, (M22plus_comm _ x), M22minus, M22plus_zero. trivial. Qed. Theorem M22plus_monoid : monoid_theory PL22 ZE_22. Proof. exists. + apply M22plus_zero. + intro; rewrite M22plus_comm; apply M22plus_zero. + intros; apply M22plus_assoc. Qed. Definition MU22 : M22 -> M22 -> M22. Proof. intros (((a,b),c),d) (((a',b'),c'),d'). exact (a⊗a' ⊕ b⊗c' , a⊗b' ⊕ b⊗d', c⊗a' ⊕ d⊗c' , c⊗b' ⊕ d⊗d' ). Defined. Infix " " := MU22 (at level 40, left associativity). Tactic Notation "myauto" integer(n) := do n intros (((?&?)&?)&?); apply M22_equal; ring. Fact M22mult_one_l : forall x, ID_22  x = x. Proof. myauto 1. Qed. Fact M22mult_one_r : forall x, x  ID_22 = x. Proof. myauto 1. Qed. Fact M22mult_assoc : forall x y u, x  (y  u) = x  y  u. Proof. myauto 3. Qed. Fact M22_mult_distr_l : forall x y u, x  (y⊞u) = x y ⊞ x u. Proof. myauto 3. Qed. Fact M22_mult_distr_r : forall x y u, (y⊞u)  x = y x ⊞ u x. Proof. myauto 3. Qed. Theorem M22mult_monoid : monoid_theory MU22 ID_22. 
Require Import Verdi.GhostSimulations. Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.LeaderLogsContiguousInterface. Require Import VerdiRaft.LogMatchingInterface.Section LeaderLogsContiguous. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lmi : log_matching_interface}. Lemma update_elections_data_client_request_leaderLogs : forall h st client id c, leaderLogs (update_elections_data_client_request h st client id c) = leaderLogs (fst st). Proof using. unfold update_elections_data_client_request in *. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma update_elections_data_timeout_leaderLogs : forall h st, leaderLogs (update_elections_data_timeout h st) = leaderLogs (fst st). Proof using. unfold update_elections_data_timeout. intros. repeat break_match; simpl in *; auto. Qed. Lemma update_elections_data_appendEntries_leaderLogs : forall h st t h' pli plt es ci, leaderLogs (update_elections_data_appendEntries h st t h' pli plt es ci) = leaderLogs (fst st). Proof using. intros. unfold update_elections_data_appendEntries. repeat break_match; subst; simpl in *; auto. Qed. Lemma update_elections_data_requestVote_leaderLogs : forall h h' t lli llt st, leaderLogs (update_elections_data_requestVote h h' t h' lli llt st) = leaderLogs (fst st). Proof using. unfold update_elections_data_requestVote. intros. repeat break_match; auto. Qed. Lemma handleRequestVoteReply_spec : forall h st h' t v st', st' = handleRequestVoteReply h st h' t v -> log st' = log st /\ (currentTerm st' = currentTerm st \/ (currentTerm st <= currentTerm st' /\ type st' = Follower)). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition. Qed. Lemma update_elections_data_requestVoteReply_leaderLogs : forall h h' t r st, leaderLogs (update_elections_data_requestVoteReply h h' t r st) = leaderLogs (fst st) \/ leaderLogs (update_elections_data_requestVoteReply h h' t r st) = (currentTerm (snd st), log (snd st)) :: leaderLogs (fst st). Proof using. intros. unfold update_elections_data_requestVoteReply in *. repeat break_match; intuition. simpl in *. match goal with | |- context [handleRequestVoteReply ?h ?s ?h' ?t ?r] => pose proof handleRequestVoteReply_spec h s h' t r (handleRequestVoteReply h s h' t r) end. intuition; repeat find_rewrite; intuition. congruence. Qed. Theorem lift_log_matching : forall net, refined_raft_intermediate_reachable net -> log_matching (deghost net). 
Proof. revert n φ; induction A as [ | r v | b A HA B HB | q A HA ]; intros n φ. + simpl; tauto. + simpl. rewrite vec_map_map. apply fol_equiv_ext; f_equal. apply vec_pos_ext; intros p; rew vec. + simpl; apply fol_bin_sem_ext; auto. + simpl; apply fol_quant_sem_ext; intro; auto. Qed. Hypothesis (Xfin : finite_t X) (Mdec : fo_model_dec M) (φ : nat -> X) (A : fol_form Σ) (HA : fol_sem M φ A). Local Lemma Σrem_constants_soundness : fo_form_fin_dec_SAT_in (Σrem_constants 0 A) X. Proof using Xfin Mdec HA. exists M', Xfin, Mdec, φ. apply Σrem_constants_sound; auto. Qed. End soundness. Section completeness. Variable (M' : fo_model Σ' X) (φ : nat -> X). Let M : fo_model Σ X. Proof. split. + simpl; intros s. destruct (choice (ar_syms _ s)) as [ [ H | H ] | H ]. * exact (fun _ => fom_syms M' s (φ 0##ø)). * exact (fun v => fom_syms M' s (cast v H)). * abstract (intros; exfalso; generalize (HΣ s); lia). + apply (fom_rels M'). Defined. Let fot_rem_cst_complete n t ψ : ψ n = φ 0 -> fo_term_sem M ψ t = fo_term_sem M' ψ (fot_rem_cst n t). Proof. intros H0; induction t as [ i | s v IHv ]. + simpl; auto. + simpl. destruct (choice (ar_syms Σ s)) as [ [ E | E ] | E ]. * simpl; now do 2 f_equal. * simpl fo_term_sem; f_equal. revert E v IHv; intros -> v IHv. apply vec_pos_ext; intros p; rew vec. analyse pos p; simpl; rew vec. * exfalso; clear v IHv. generalize (HΣ s); lia. Qed. Local Fact Σrem_constants_complete n A ψ : ψ n = φ 0 -> fol_sem M ψ A <-> fol_sem M' ψ (Σrem_constants n A). Proof. revert n ψ; induction A as [ | r v | b A HA B HB | q A HA ]; intros n ψ H. + simpl; tauto. + simpl; apply fol_equiv_ext; f_equal; rewrite vec_map_map. apply vec_pos_ext; intros p; rewrite !vec_pos_map; auto. + simpl; apply fol_bin_sem_ext; auto. + simpl; apply fol_quant_sem_ext; intro; apply HA; simpl; auto. Qed. Hypothesis (Xfin : finite_t X) (M'dec : fo_model_dec M') (A : fol_form Σ) (HA : fol_sem M' φ (Σrem_constants 0 A)). Local Lemma Σrem_constants_completeness : fo_form_fin_dec_SAT_in A X. Proof using Xfin M'dec HA. exists M, Xfin, M'dec, φ. revert HA; apply Σrem_constants_complete; auto. Qed. End completeness. Theorem Σrem_constants_correct A : fo_form_fin_dec_SAT_in A X <-> fo_form_fin_dec_SAT_in (Σrem_constants 0 A) X. 
{ exists γ. apply SepI... } apply SepE in Hμ as [Hμ [HFμ Hβμ]]. exists μ. repeat split... apply (ord_is_ords γ⁺)... intros ξ [Hoξ HFξ] Hβξ. destruct (classic (ξ = γ⁺)) as [|Hnq]. left. congruence. apply ord_connected in Hnq as [Hlt|Hne]... - assert (Hξ: ξ ∈ Ω). apply SepI... apply Hmμ in Hξ as []... apply binRelE3 in H... - left. eapply ord_trans... Qed. Corollary fixed_point_class_unbounded : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → unbounded (fixed_point F). Proof with eauto. intros F HF Hnml α Hoα. assert (Hoα': α⁺ ⋵ 𝐎𝐍)... apply (ex_least_fixed_point F) in Hoα' as [β [[Hoβ HFβ] [Hle _]]]... exists β. repeat split... destruct Hle. eapply ord_trans... rewrite <- H... Qed. Local Hint Resolve fixed_point_class_unbounded : core. Lemma fixed_point_class_sub_on : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → fixed_point F ⫃ 𝐎𝐍. Proof. intros F HF α [Hoα HFα]. rewrite <- HFα. apply HF. apply Hoα. Qed. Local Hint Resolve fixed_point_class_sub_on : core.Import 𝐎𝐍Separation. Definition FixedPoint := λ F, Enumerate (fixed_point F). Lemma fixedPoint_monotone : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → monotone (FixedPoint F). Proof with auto. intros F HF Hnml. apply enum_monotone... apply fixed_point_class_sub_on... Qed. Lemma fixedPoint_continuous : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → continuous (FixedPoint F). Proof with eauto; try congruence. intros F HF Hnml. apply (monotone_operation_continuous_if_range_closed _ (fixed_point F))... apply enum_onto_class... apply fixedPoint_monotone... intros A Hne HA. split. - apply union_of_ords_is_ord. intros x Hx. apply HA... - assert (Hos: A ⪽ 𝐎𝐍). intros x Hx. apply HA... assert (Hou: sup A ⋵ 𝐎𝐍). apply union_of_ords_is_ord... ext Hx. + ord_destruct (sup A). * apply union_eq_empty in H0 as [|HeqA]... rewrite HeqA in HA, Hx. unfold sup in Hx. rewrite union_one in Hx. assert ( ⋵ fixed_point F). apply HA. apply SingI. destruct H as [_ HF0]. rewrite HF0 in Hx. exfalso0. * apply sup_ords_is_sucord_impl_in in Hsuc... apply HA in Hsuc as [_ HFu]... * destruct Hnml as [Hmono Hcon]. rewrite Hcon in Hx... apply FUnionE in Hx as [α [Hα Hx]]. apply UnionAx in Hα as [β [Hβ Hα]]. apply UnionAx. exists β. split... apply HA in Hβ as [Hoβ HFβ]. apply Hmono in Hα... rewrite <- HFβ. eapply ord_trans... + apply UnionAx in Hx as [α [Hα Hx]]. assert (α ⋸ sup A). apply ord_sup_is_ub... apply HA in Hα as [Hoα HFα]. rewrite <- HFα in Hx. destruct H... eapply ord_trans... apply Hnml... Qed. Theorem fixedPoint_normal : ∀ F, F:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → normal F → normal (FixedPoint F). 
From RecordUpdate Require Import RecordSet.From stdpp Require Import gmap. From iris.algebra Require Import ofe.From Perennial.Helpers Require Import Tactics Integers. From Perennial.program_proof Require Import disk_lib. From Perennial.goose_lang Require Import ffi.disk.Module update. Record t := mk { addr: u64; b: Block; }. Global Instance _eta: Settable _ := settable! mk <addr; b>. Global Instance _witness: Inhabited t := populate!. End update.Definition LogSz: Z := 511. #[global] Hint Unfold LogSz : word.Definition disk := gmap Z Block. Canonical Structure diskO := leibnizO disk.Definition txn_upds (txns: list (u64 * list update.t)) : list update.t := concat (snd <$> txns).Definition is_txn (txns: list (u64 * list update.t)) (txn_id: nat) (pos: u64): Prop := fst <$> txns !! txn_id = Some pos.Theorem is_txn_bound txns txn_id pos : is_txn txns txn_id pos -> (txn_id < length txns)%nat. Proof. rewrite /is_txn -list_lookup_fmap. intros H%lookup_lt_Some. autorewrite with len in H; lia. Qed.Module log_state. Record t := mk { d: disk; txns: list (u64 * list update.t); installed_lb: nat; durable_lb: nat; }. Global Instance _eta: Settable _ := settable! mk <d; txns; installed_lb; durable_lb>. Global Instance _witness: Inhabited t := populate!. Definition updates σ : list update.t := txn_upds σ.(txns). End log_state.Definition addr_wf (a: u64) (d: disk) := 2 + LogSz ≤ int.Z a ∧ ∃ (b: Block), d !! (int.Z a) = Some b.Definition addrs_wf (updates: list update.t) (d: disk) := Forall (λ u, addr_wf u.(update.addr) d) updates. Section list_mono. Context {A} (ltR: A → A → Prop) {Htrans: Transitive ltR}. Implicit Types (l: list A). Definition list_mono l := ∀ (i1 i2: nat) (x1 x2: A) (Hlt: (i1 < i2)%nat) (Hx1: l !! i1 = Some x1) (Hx2: l !! i2 = Some x2), ltR x1 x2. Theorem list_mono_app l1 l2 : list_mono (l1 ++ l2) <-> list_mono l1 ∧ list_mono l2 ∧ (∀ i1 i2 x1 x2 (Hx1: l1 !! i1 = Some x1) (Hx2: l2 !! i2 = Some x2), ltR x1 x2). 
Set Warnings "-notation-overridden". From Coq Require Import ssreflect ssrbool ssrfun. From mathcomp Require Import ssrnat seq eqtype. Set Bullet Behavior "Strict Subproofs". Require Import Coq.Sorting.Sorted. Require Import GHC.Base Proofs.GHC.Base. Require Import Data.Foldable Proofs.Data.Foldable. Require Import Data.Bits Proofs.Data.Bits.Popcount. Require Import Data.IntSet.Internal. Require Import Utils.Containers.Internal.BitUtil. Require Import DyadicIntervals. Require Import IntSetProofs. Require Import BitUtils. Require Import HSUtil SortedUtil. Notation list := Coq.Init.Datatypes.list. Notation seq := Coq.Lists.List.seq. Notation reflect := ssrbool.reflect. Theorem bitcount_0_1_power (n : Word) : bitcount #0 n = #1 <-> exists i, n = (2^i)%N. Proof. rewrite /bitcount /popCount /=. split=> [/N_popcount_1_pow2 [i def_n] | [i ->{n}]]. - by exists i. - apply N_popcount_pow2. Qed.Theorem WF_Bin_mask_power_N {p : Prefix} {m : Mask} {l r : IntSet} : WF (Bin p m l r) -> ex (fun i => m = 2^i)%N. Proof. move=> /valid_maskPowerOfTwo /= /and3P [/Eq_eq BITS _ _]. by apply bitcount_0_1_power. Qed. Theorem WF_Bin_children (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF l /\ WF r. 
h1 k with | Some x => Some x | None => lookup h2 k end.Definition hemp : assertion := fun v h => h = empty_heap. Definition hpto (p x : exp) : assertion := fun v h => h = add empty_heap (eval p v) (Some (eval x v)). Definition hstar (p q : assertion) : assertion := fun v h => exists h1 h2, hsplit h h1 h2 /\ p v h1 /\ q v h2.Definition hand (p q : assertion) : assertion := fun v h => p v h /\ q v h. Definition himp (p q : assertion) : Prop := forall v h, p v h -> q v h. Definition heq (p q : assertion) : Prop := forall v h, p v h <-> q v h. Definition hlift (p : Prop) : assertion := fun v h => p.Infix "|->" := hpto (at level 30) : sep_scope. Infix "/~\" := hand (at level 40) : sep_scope. Infix "**" := hstar (at level 40) : sep_scope. Delimit Scope sep_scope with sep. Notation "p ==> q" := (himp p%sep q%sep) (no associativity, at level 70). Notation "p <==> q" := (heq p%sep q%sep) (no associativity, at level 70).Open Scope sep_scope.Ltac hsimpl := unfold hemp, empty_heap, hpto, hstar, hsplit, hdsj, hcov, huni, hand, himp, heq, hlift, add, lookup in *. Ltac hsolver := match goal with | [ |- context[ if ?c then _ else _ ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ if ?c then _ else _ ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ |- context[ match ?c with Some _ => _ | None => _ end ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ match ?c with Some _ => _ | None => _ end ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ H : (?x <? ?y) = true |- _ ] => rewrite Nat.ltb_lt in H | [ H : (?x <? ?y) = false |- _ ] => rewrite Nat.ltb_nlt in H end; subst; auto.Lemma heap_extensionality : forall (h1 h2 : heap), h1 = h2 -> forall (x : nat), h1 x = h2 x. Proof. crush. Qed.Module SeparationProperty. Theorem pt2same_sep : forall (p x y : exp), p |-> x ** p |-> y ==> hlift False. 
Proof. intros A B; unfold not. apply imp_trans. Qed. Theorem disj4_3' : forall P Q R S:Prop, R -> P \/ Q \/ R \/ S. Proof. right; right; left; assumption. Qed.Lemma and_commutes : forall A B:Prop, A /\ B -> B /\ A. Proof. intros A B H; destruct H. split; assumption. Qed.Lemma or_commutes : forall A B:Prop, A\/B->B\/A. Proof. intros A B H; destruct H as [H | H]; auto. Qed.Lemma ex_imp_ex : forall (A:Type)(P Q:A->Prop), (ex P)->(forall x:A, P x -> Q x)->(ex Q). Proof. intros A P Q H H0; destruct H as [a Ha]. exists a; apply H0; assumption. Qed. Lemma L36 : 6 * 6 =9 * 4. Proof. reflexivity. Qed.Lemma diff_of_squares : forall a b:Z, ((a + b) * (a - b) = a * a - b * b)%Z. Proof. intros; ring. Qed.Theorem eq_sym' : forall (A:Type)(a b:A), a = b -> b = a. Proof. intros A a b e; rewrite e; reflexivity. Qed.Lemma Zmult_distr_1 : forall n x:Z, n * x + x = ( n + 1) * x. Proof. intros n x ; rewrite Zmult_plus_distr_l. now rewrite Zmult_1_l. Qed.Lemma regroup : forall x:Z, x + x + x + x + x = 5 * x. Proof. intro x; pattern x at 1. rewrite <- Zmult_1_l. repeat rewrite Zmult_distr_1. reflexivity. Qed. Open Scope nat_scope. Theorem le_lt_S_eq : forall n p:nat, n <= p -> p < S n -> n = p. Proof. intros; lia. Qed.Lemma conditional_rewrite_example : forall n:nat, 8 <= n + 6 -> 3 + n < 6 -> n * n = n + n. Proof. intros n H H0. rewrite <- (le_lt_S_eq 2 n). - reflexivity. - apply plus_le_reg_l with (p := 6). rewrite plus_comm in H; auto with arith. - apply plus_lt_reg_l with (p:= 3); auto with arith. Qed.Lemma conditional_rewrite_example' : forall n:nat, 8 <= n + 6 -> 3 + n < 6 -> n * n = n + n. Proof. intros n H H0. assert (n = 2) by lia. now subst n. Qed. Theorem eq_trans : forall (A:Type)(x y z:A), x = y -> y = z -> x = z. Proof. intros A x y z H; rewrite H; auto. Qed. Definition my_True : Prop := forall P:Prop, P -> P.Definition my_False : Prop := forall P:Prop, P.Theorem my_I : my_True. Proof. intros P p; assumption. Qed. Theorem my_False_ind : forall P:Prop, my_False->P. 
|- *. apply trans_sym_eq. Defined. Theorem eq_proofs_unicity : forall (y:A) (p1 p2:x = y), p1 = p2. Proof. intros. elim nu_left_inv with (u := p1). elim nu_left_inv with (u := p2). elim nu_constant with y p1 p2. reflexivity. Defined. Theorem K_dec : forall P:x = x -> Type, P refl_equal -> forall p:x = x, P p. Proof. intros. elim eq_proofs_unicity with x refl_equal p. trivial. Defined. Lemma eq_dec_refl : eq_dec x x = left _ eq_refl. Proof. case eq_dec. intros. f_equal. apply eq_proofs_unicity. intro. congruence. Defined. Let proj (P:A -> Type) (exP:sigT P) (def:P x) : P x := match exP with | existT _ x' prf => match eq_dec x' x with | left eqprf => eq_rect x' P prf x eqprf | _ => def end end. Theorem inj_right_pair : forall (P:A -> Type) (y y':P x), existT P x y = existT P x y' -> y = y'. Proof. intros. cut (proj (existT P x y) y = proj (existT P x y') y). simpl in |- *. case (eq_dec x x). intro e. elim e using K_dec; trivial. intros. case n; trivial. case H0. reflexivity. Defined. Lemma inj_right_pair_refl (P : A -> Type) (y : P x) : inj_right_pair (y:=y) (y':=y) eq_refl = eq_refl. Proof. unfold inj_right_pair. intros. unfold eq_rect. unfold proj. rewrite eq_dec_refl. unfold K_dec. simpl. unfold eq_proofs_unicity. subst proj. simpl. unfold nu_inv, comp, nu. simpl. unfold eq_ind, nu_left_inv, trans_sym_eq, eq_rect, nu_constant. rewrite eq_dec_refl. reflexivity. Defined.End EqdepDec.Section PointEqdepDec. Context {A : Type} {x : A} `{EqDecPoint A x}. Let comp (x y y':A) (eq1:x = y) (eq2:x = y') : y = y' := eq_ind _ (fun a => a = y') eq2 _ eq1. Remark point_trans_sym_eq : forall (x y:A) (u:x = y), comp u u = refl_equal. Proof. intros. case u; trivial. Defined. Let nu (y:A) (u:x = y) : x = y := match eq_dec_point y with | left eqxy => eqxy | right neqxy => False_ind _ (neqxy u) end. Let nu_constant : forall (y:A) (u v:x = y), nu u = nu v. intros. unfold nu in |- *. case (eq_dec_point y); intros. reflexivity. case n; trivial. Defined. Let nu_inv (y:A) (v:x = y) : x = y := comp (nu refl_equal) v. Remark nu_left_inv_point : forall (y:A) (u:x = y), nu_inv (nu u) = u. Proof. intros. case u; unfold nu_inv in |- *. apply trans_sym_eq. Defined. Theorem eq_proofs_unicity_point : forall (y:A) (p1 p2:x = y), p1 = p2. 
Relations. Require Export Inverse_Image. Require Export Transitive_Closure. Require Export Zdiv. Open Scope nat_scope. Inductive bin : Set := | node: bin -> bin -> bin | leaf: nat -> bin | neutral: bin . Fixpoint flatten_aux (t fin : bin) {struct t} : bin := match t with | node t1 t2 => flatten_aux t1 (flatten_aux t2 fin) | x => node x fin end. Fixpoint flatten (t : bin) : bin := match t with node t1 t2 => flatten_aux t1 (flatten t2) | x => x end. Fixpoint remove_neutral1 (t : bin) : bin := match t with leaf n => leaf n | neutral => neutral | node neutral t' => remove_neutral1 t' | node t t' => node t (remove_neutral1 t') end. Fixpoint remove_neutral2 (t : bin) : bin := match t with leaf n => leaf n | neutral => neutral | node t neutral => t | node t1 t2 => node t1 (remove_neutral2 t2) end. Definition remove_neutral (t : bin) := remove_neutral2 (remove_neutral1 t). Section assoc_eq. Variables (A : Set) (f : A -> A -> A) (zero_A : A) (assoc : forall (x y z : A), f x (f y z) = f (f x y) z) (zero_left : forall (x : A), f zero_A x = x) (zero_right : forall (x : A), f x zero_A = x). Fixpoint bin_A (l : list A) (t : bin) {struct t} : A := match t with node t1 t2 => f (bin_A l t1) (bin_A l t2) | leaf n => nth n l zero_A | neutral => zero_A end. Theorem flatten_aux_valid_A: forall (l : list A) (t t' : bin), f (bin_A l t) (bin_A l t') = bin_A l (flatten_aux t t'). Proof. intros l t; elim t; simpl; auto. intros t1 IHt1 t2 IHt2 t'; rewrite <- IHt1; rewrite <- IHt2. symmetry; apply assoc. Qed. Theorem flatten_valid_A: forall (l : list A) (t : bin), bin_A l t = bin_A l (flatten t). Proof. intros l t; elim t; simpl; trivial. intros t1 IHt1 t2 IHt2; rewrite <- flatten_aux_valid_A; now rewrite <- IHt2. Qed. Theorem flatten_valid_A_2: forall (t t' : bin) (l : list A), bin_A l (flatten t) = bin_A l (flatten t') -> bin_A l t = bin_A l t'. Proof. intros t t' l Heq. rewrite (flatten_valid_A l t); now rewrite (flatten_valid_A l t'). Qed. Theorem remove_neutral1_valid_A: forall (l : list A) (t : bin), bin_A l (remove_neutral1 t) = bin_A l t. 
v))%I (|NC={⊤}=> j ⤇ K NONEV)%I with "[$Htwophase Hj]" )). 1-2: refine _. { iSplit. - iIntros "?". iNamed. iAssert ( [∗ map] a ↦ o ∈ jrnlData σj1, "Hmapsto" ∷ jrnl_mapsto a 1 o ∗ "Htok" ∷ jrnl_crash_tok a )%I with "[Hcommitted]" as "Hcommitted". { destruct Hjrnl_maps_mt as [<- _]. rewrite !big_sepM_fmap //. } iDestruct (big_sepM_sep with "Hcommitted") as "[Hmapstos Htoks]". destruct Hjrnl_maps_kinds as [<- _]. iDestruct ( ghost_step_jrnl_atomically_crash with "Hspec_crash_ctx Hmapstos Htoks Hjrnl_kinds_lb Hjrnl_allocs Hjrnl_open Hj" ) as "H"; [eassumption|set_solver|]. iMod (cfupd_weaken_mask with "H") as "[Hmapstos Htoks]". { auto. } iModIntro. iApply big_sepM_sep. destruct Hjrnl_maps_mt as [<- <-]. rewrite !big_sepM_fmap. iFrame. - iIntros "!> ?". iNamed. iAssert ( [∗ map] a ↦ o ∈ jrnlData σj1, "Hmapsto" ∷ jrnl_mapsto a 1 o ∗ "Htok" ∷ jrnl_crash_tok a )%I with "[Hcommitted]" as "Hcommitted". { destruct Hjrnl_maps_mt as [<- _]. rewrite !big_sepM_fmap //. } iDestruct (big_sepM_sep with "Hcommitted") as "[Hmapstos Htoks]". destruct Hjrnl_maps_kinds as [<- _]. iSplit. 2: { iFrame. iSplitR "Hj"; last first. { iMod (ghost_step_jrnl_atomically_abort with "[$] [$] [$]") as "$"; auto. } iApply big_sepM_sep. destruct Hjrnl_maps_mt as [<- _]. rewrite !big_sepM_fmap. iFrame. } iDestruct ( ghost_step_jrnl_atomically with "Hspec_ctx Hmapstos Hjrnl_kinds_lb Hjrnl_allocs Hjrnl_open Hj" ) as "> [Hj Hmapstos]"; [eassumption|set_solver|]. iModIntro. iFrame. destruct Hjrnl_maps_mt as [<- <-]. rewrite !big_sepM_fmap. iApply big_sepM_sep. iFrame. } iIntros (?) "Hpost". iNamed "Hpost". iApply "HΦ". iSplitL "Hlocks Hlinvs". { iExists _, _, _, _. iDestruct (is_twophase_locks_get_pures with "Hlocks") as "#Hlocks_pures". iNamed "Hlocks_pures". iFrame "∗ %". iModIntro. iSplit; last by auto. iApply big_sepS_set_map; last by iFrame. intros a1 a2 Hacc1 Hacc2 Heq. apply elem_of_dom in Hacc1. apply elem_of_dom in Hacc2. destruct Hacc1 as [vo1 Hacc1]. destruct Hacc2 as [vo2 Hacc2]. apply Hvalids in Hacc1. apply Hvalids in Hacc2. rewrite /mapsto_valid in Hacc1. rewrite /mapsto_valid in Hacc2. apply addr2flat_eq; intuition. } destruct ok; first by iFrame. iMod "HQ"; eauto. Qed. Lemma na_crash_inv_status_wand_sepM {A} `{Countable K} (m: gmap K A) Q P : ([∗ map] i ↦ x ∈ m, crash_borrow (Q i x) (P i x)) -∗ □ ( [∗ map] i ↦ x ∈ m, Q i x -∗ P i x ). Proof. iInduction m as [|i x m] "IH" using map_ind. { iIntros "_ !>". iApply big_sepM_empty. trivial. } iIntros "Hcrash_invs". iDestruct (big_sepM_insert with "Hcrash_invs") as "[Hcrash_inv Hcrash_invs]"; first by assumption. iDestruct ("IH" with "Hcrash_invs") as "#Hstatuses". iDestruct (crash_borrow_crash_wand with "Hcrash_inv") as "#Hstatus". iModIntro. iApply big_sepM_insert; first by assumption. iFrame "#". Qed. Theorem twophase_started_abort l γ γ' dinit objs_dom j K e1 e2 : is_twophase_started l γ γ' dinit objs_dom j K e1 e2 -∗ wpc_nval ⊤ (is_twophase_releasable l γ γ' objs_dom ∗ j ⤇ K NONEV). 
auto with zarith. intros p1; left; apply OddOpp; exists (Zpos p1); rewrite Zplus_comm; simpl in |- *; auto. intros p1; right; apply EvenOpp; exists (Zpos p1); simpl in |- *; auto. Qed. Theorem OddNEven : forall n : Z, Odd n -> ~ Even n. intros n H1; red in |- *; intros H2; case H1; case H2; intros z1 Hz1 z2 Hz2. absurd (n = n); auto. pattern n at 1 in |- *; rewrite Hz1; rewrite Hz2; repeat rewrite (fun x => Zplus_comm x 1). case z1; case z2; simpl in |- *; try (intros; red in |- *; intros; discriminate). intros p p0; case p; simpl in |- *; try (intros; red in |- *; intros; discriminate). Qed. Theorem EvenNOdd : forall n : Z, Even n -> ~ Odd n. intros n H1; red in |- *; intros H2; case H1; case H2; intros z1 Hz1 z2 Hz2. absurd (n = n); auto. pattern n at 1 in |- *; rewrite Hz1; rewrite Hz2; repeat rewrite (fun x => Zplus_comm x 1). case z1; case z2; simpl in |- *; try (intros; red in |- *; intros; discriminate). intros p p0; case p0; simpl in |- *; try (intros; red in |- *; intros; discriminate). Qed. Hint Resolve OddNEven EvenNOdd: zarith. Theorem EvenPlus1 : forall n m : Z, Even n -> Even m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem EvenPlus2 : forall n m : Z, Odd n -> Odd m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1 + 1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus1 : forall n m : Z, Odd n -> Even m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus2 : forall n m : Z, Even n -> Odd m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Hint Resolve EvenPlus1 EvenPlus2 OddPlus1 OddPlus2: zarith. Theorem EvenPlusInv1 : forall n m : Z, Even (n + m) -> Even n -> Even m. 
p. Fact prime_2 : prime 2. Proof. split; try omega. apply divides_2_inv. Qed. Fact prime_ge_2 p : prime p -> 2 <= p. Proof. destruct p as [ | [ | p ] ]; try omega. + intros [ _ H ]; subst. destruct (H 2); auto; discriminate. + intros [ [] _ ]; auto. Qed. Fact prime_gcd p q : prime p -> is_gcd p q 1 \/ p <d q. Proof. intros H. generalize (gcd p q) (gcd_spec p q); intros g Hg. destruct (proj2 H _ (proj1 Hg)); subst; auto. right; apply Hg. Qed. Fact prime_div_mult p x y : prime p -> p <d x*y -> p <d x \/ p <d y. Proof. intros H1 H2. destruct (prime_gcd x H1); auto. right; revert H H2; apply is_rel_prime_div. Qed. Definition prime_or_div p : 2 <= p -> { q | 2 <= q < p /\ q <d p } + { prime p }. Proof. intros Hp. destruct bounded_search with (m := S p) (P := fun n => 2 <= n < p /\ n <d p) as [ (q & H1 & H2) | H1 ]. + intros n _. destruct (le_lt_dec p n). { right; intros; omega. } destruct (le_lt_dec 2 n). * destruct (divides_dec p n) as [ (?&?) | ]. - left; subst; auto. - right; tauto. * right; omega. + left; exists q; split; try tauto; try omega. + right; split; auto. * omega. * intros q Hq. destruct q as [ | q]; auto. - apply divides_0_inv in Hq; auto. - assert (~ 2 <= S q < p) as H2. { intros H; apply (H1 (S q)); auto. apply le_n_S, divides_le; auto; omega. } apply divides_le in Hq; omega. Qed. Theorem prime_factor n : 2 <= n -> { p | prime p /\ p <d n }. Proof. induction on n as IHn with measure n; intro Hn. destruct (prime_or_div Hn) as [ (q & H1 & H2) | H1 ]. 2: exists n; auto. destruct (IHn q) as (p & H3 & H4); try omega. exists p; split; auto. apply divides_trans with (1 := H4); auto. Qed. Section prime_rect. Variables (P : nat -> Type) (HP0 : P 0) (HP1 : P 1) (HPp : forall p, prime p -> P p) (HPm : forall x y, P x -> P y -> P (x*y)). Theorem prime_rect n : P n. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main.Local Open Scope morphism_scope.Section Algebras. Context {C : Category} (T : (C –≻ C)%functor). Record Algebra : Type := { Alg_Carrier : C; Constructors : (T _o Alg_Carrier)%object –≻ Alg_Carrier }. Record Algebra_Hom (alg alg' : Algebra) : Type := { Alg_map : (Alg_Carrier alg) –≻ (Alg_Carrier alg'); Alg_map_com : ((Constructors alg') ∘ (T _a Alg_map) = Alg_map ∘ (Constructors alg))%morphism }. Arguments Alg_map {_ _} _. Arguments Alg_map_com {_ _} _. Program Definition Algebra_Hom_compose {alg alg' alg'' : Algebra} (h : Algebra_Hom alg alg') (h' : Algebra_Hom alg' alg'') : Algebra_Hom alg alg'' := {| Alg_map := ((Alg_map h') ∘ (Alg_map h))%morphism |}. Next Obligation. Proof. destruct h as [alm almcm]; destruct h' as [alm' almcm']; cbn. rewrite F_compose. rewrite assoc_sym. rewrite almcm'. rewrite assoc. rewrite almcm. auto. Qed. Lemma Algebra_Hom_eq_simplify (alg alg' : Algebra) (ah ah' : Algebra_Hom alg alg') : (Alg_map ah) = (Alg_map ah') -> ah = ah'. Proof. intros; destruct ah; destruct ah'; cbn in *. ElimEq. PIR. trivial. Qed. Theorem Algebra_Hom_compose_assoc {alg alg' alg'' alg''' : Algebra} (f : Algebra_Hom alg alg') (g : Algebra_Hom alg' alg'') (h : Algebra_Hom alg'' alg''') : (Algebra_Hom_compose f (Algebra_Hom_compose g h)) = (Algebra_Hom_compose (Algebra_Hom_compose f g) h). Proof. apply Algebra_Hom_eq_simplify; cbn; auto. Qed. Program Definition Algebra_Hom_id (alg : Algebra) : Algebra_Hom alg alg := {| Alg_map := id |}. Theorem Algebra_Hom_id_unit_left {alg alg' : Algebra} (f : Algebra_Hom alg alg') : (Algebra_Hom_compose f (Algebra_Hom_id alg')) = f. Proof. apply Algebra_Hom_eq_simplify; cbn; auto. Qed. Theorem Algebra_Hom_id_unit_right {alg alg' : Algebra} (f : Algebra_Hom alg alg') : (Algebra_Hom_compose (Algebra_Hom_id alg) f) = f. 
as "$". { apply step_count_next_incr. } iMod (na_heap_alloc_list tls _ l (Block_to_vals (latest vm)) (Reading O) with "Hσ") as "(Hσ & Hblock & Hl)". { rewrite length_Block_to_vals. rewrite /block_bytes. lia. } { destruct H0 as (?&?); eauto. } { destruct H0 as (H'&?); eauto. eapply H'. } { destruct H0 as (H'&?); eauto. destruct (H' 0) as (?&Hfresh). by rewrite (loc_add_0) in Hfresh. } { eauto. } iModIntro; iSplit; first done. iFrame. iApply "HΦ". iFrame. { rewrite /mapsto_block. iApply seq_mapsto_to_heap_array. iApply (big_sepL_mono with "Hl"). iIntros (k x Heq) "(Hli&Hmt)". iApply (na_mapsto_to_heap with "Hli"). destruct H0 as (H'&?). eapply H'. } Qed. Definition bindex_of_Z (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : fin block_bytes. cut (Z.to_nat i < 4096)%nat. { apply nat_to_fin. } change 4096%nat with (Z.to_nat 4096%Z). abstract (apply Z2Nat.inj_lt; auto; vm_compute; inversion 1). Defined. Theorem block_byte_index {ext: ffi_syntax} (b: Block) (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : Block_to_vals b !! Z.to_nat i = Some (LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi). Proof. unfold Block_to_vals. rewrite ?list_lookup_fmap. unfold bindex_of_Z. destruct (vlookup_lookup' b (Z.to_nat i) (b !!! bindex_of_Z i Hlow Hhi)) as [H _]. rewrite H; eauto. Qed. Theorem mapsto_block_extract i l q b : (0 <= i)%Z -> (i < 4096)%Z -> ⊢ mapsto_block l q b -∗ ∃ v, (l +ₗ i) ↦{q} v ∗ ⌜Block_to_vals b !! Z.to_nat i = Some v⌝. Proof. unfold mapsto_block; intros Hlow Hhi. iIntros "Hm". pose proof (block_byte_index b i ltac:(auto) ltac:(auto)) as Hi. assert (heap_array l (Block_to_vals b) !! (l +ₗ i) = Some $ LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi) as Hha. { apply heap_array_lookup. eexists; intuition eauto. } iDestruct (big_sepM_lookup_acc _ _ _ _ Hha with "Hm") as "(Hmi&_)". iExists _. iFrame "Hmi". destruct_with_eqn (Block_to_vals b !! Z.to_nat i); auto. Qed. Theorem heap_valid_block l b q σ : na_heap.na_heap_ctx tls σ -∗ mapsto_block l q b -∗ ⌜ (forall (i:Z), (0 <= i)%Z -> (i < 4096)%Z -> match σ !! (l +ₗ i) with | Some (Reading _, v) => Block_to_vals b !! Z.to_nat i = Some v | _ => False end) ⌝. Proof. iIntros "Hσ Hm". iIntros (i Hbound1 Hbound2). iDestruct (mapsto_block_extract i with "Hm") as (v) "[Hi %]"; eauto. iDestruct (heap_mapsto_na_acc with "Hi") as "[Hi Hi_rest]". iDestruct (@na_heap.na_heap_read with "Hσ Hi") as %(lk&?&Hlookup&Hlock). destruct lk; inversion Hlock; subst. rewrite Hlookup //. Qed. Theorem Block_to_vals_ext_eq b1 b2 : (forall (i:Z), (0 <= i)%Z -> (i < 4096)%Z -> Block_to_vals b1 !! Z.to_nat i = Block_to_vals b2 !! Z.to_nat i) -> b1 = b2. 
_, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). } iNext; iIntros (v2 σ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (ghost_async_map_update_flush_big with "Hd H") as "[$ Ha]". iModIntro; iSplit; first done. iFrame. iApply ("Hϕ" with "[$]"). Qed. Lemma wp_WriteOp s E (a: u64) aset b0 b q l : {{{ ▷ (int.Z a d↦{#1}[aset] b0 ∗ mapsto_block l q b) }}} ExternalOp WriteOp (Val $ PairV (LitV $ LitInt a) (LitV $ LitLoc l)) @ s; E {{{ RET LitV LitUnit; int.Z a d↦{#1}[{[b0]} ∪ aset] b ∗ mapsto_block l q b}}}. Proof. iIntros (Φ) ">H Hϕ". iDestruct "H" as "(Ha&Hl)". iApply wp_lift_atomic_head_step_no_fork; first by auto. iIntros (σ1 g1 ns mj D κ κs nt) "(Hσ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iDestruct (@ghost_async_map_lookup with "Hd Ha") as %Hlookup. destruct Hlookup as (vm&Hw&Hlatest&Hpend). iDestruct (heap_valid_block with "Hσ Hl") as %?. iSplit. { iPureIntro. eexists _, _, _, _, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). econstructor; eauto; [ econstructor; eauto| monad_simpl ]. } iNext; iIntros (v2 σ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (ghost_async_map_async_put with "Hd Ha") as "[$ Ha]". { eauto. } assert (b = b0); [ | subst b0 ]. { apply Block_to_vals_ext_eq; intros. specialize (H i); specialize (H1 i); intuition. simpl in H3. destruct_with_eqn (σ1.(heap) !! (l +ₗ i)); try contradiction. destruct p as (n0&?); destruct n0; try contradiction; congruence. } iModIntro; iSplit; first done. iFrame. iApply ("Hϕ" with "[$]"). Qed. Definition disk_array (l: Z) (q: dfrac) (vs: list Block): iProp Σ := ([∗ list] i ↦ b ∈ vs, (l + i) d↦{q}[ ] b)%I. Theorem disk_array_cons l q b vs : disk_array l q (b::vs) ⊣⊢ l d↦{q}[ ] b ∗ disk_array (l + 1) q vs. Proof. rewrite /disk_array big_sepL_cons. rewrite Z.add_0_r. assert (forall l k, l + S k = l + 1 + k) by lia. setoid_rewrite H. reflexivity. Qed. Theorem disk_array_app l q vs1 vs2 : disk_array l q (vs1 ++ vs2) ⊣⊢ disk_array l q vs1 ∗ disk_array (l + length vs1) q vs2. Proof. rewrite /disk_array big_sepL_app. setoid_rewrite Nat2Z.inj_add. by setoid_rewrite Z.add_assoc. Qed. Theorem disk_array_emp l q : disk_array l q [] ⊣⊢ emp. Proof. by rewrite /disk_array. Qed. Theorem disk_array_split l q z vs : 0 <= z < Z.of_nat (length vs) -> disk_array l q vs ⊣⊢ disk_array l q (take (Z.to_nat z) vs) ∗ disk_array (l + z) q (drop (Z.to_nat z) vs). 
c Q. Proof. intros; apply HtConsequence with (P := P) (Q := Q); crush. Qed.Lemma HtConsequencePost : forall P Q Q' c, htriple P c Q -> assertion_implies Q Q' -> htriple P c Q'. Proof. intros; apply HtConsequence with (P := P) (Q := Q); crush. Qed. Ltac ht1 := apply HtSkip || apply HtAssign || apply HtWrite || eapply HtSeq || eapply HtIf || eapply HtWhile || eapply HtAssert || eapply HtConsequencePre.Ltac a := unfold assertion_implies; intros; unfold valuation_sub, heap_sub; crush.Ltac ht := repeat ht1; match goal with | [ |- assertion_implies _ _ ] => a end.Lemma hoare_while_sound : forall I cond body, (forall v h v' h', execute v h body v' h' -> I v h /\ beval cond v h = true -> I v' h') -> forall v h v' h', execute v h (While I cond body) v' h' -> I v h -> I v' h' /\ beval cond v' h' = false. Proof. intros I cond body Hwhile. intros v h v' h' H. remember (While I cond body) as e; induction H; inversion Heqe; subst; try pose proof (Hwhile v1 h1 v2 h2); crush. Qed.Theorem hoare_sound : forall c P Q, htriple P c Q -> forall v h v' h', execute v h c v' h' -> P v h -> Q v' h'. Proof. induction 1; intros v h v' h' Hex; inversion Hex; crush; firstorder. try eassumption; eauto. pose proof (hoare_while_sound IHhtriple Hex H11); pose proof (H0 v' h'); crush. Qed. Module Hoare2. Definition htriple (P : assertion) (c : cmd) (Q : assertion) : Prop := forall v h v' h', execute v h c v' h' -> P v h -> Q v' h'. Ltac h := unfold htriple; intros; match goal with | [ H : execute _ _ _ _ _ |- _ ] => inversion H; subst end; subst; auto. Theorem HtSkip : forall P, htriple P Skip P. Proof. h. Qed. Theorem HtAssign : forall P x e, htriple (valuation_sub P x e) (Assign x e) P. Proof. h. Qed. Theorem HtWrite : forall P e1 e2, htriple (heap_sub P e1 e2) (Write e1 e2) P. Proof. h. Qed. Theorem HtSeq : forall P Q R c1 c2, htriple Q c2 R -> htriple P c1 Q -> htriple P (Seq c1 c2) R. Proof. h. eapply H; eauto. Qed. Theorem HtIf : forall P Q cond br1 br2, htriple (fun v h => P v h /\ beval cond v h = true) br1 Q -> htriple (fun v h => P v h /\ beval cond v h = false) br2 Q -> htriple P (If cond br1 br2) Q. 
Fi Fs m0 sm m IFs ilist ino freelist, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (BALLOCC.MSLog ms) sm hm * [[[ m ::: (Fm * rep bxp IFs xp ilist cache * BALLOCC.rep bxp freelist ms) ]]] * [[[ ilist ::: (Fi * inum |-> ino) ]]] * [[ (Fs * IFs * BALLOCC.smrep freelist)%pred sm ]] POST:hm' RET:^(cache', ms) exists m' ilist' ino' freelist' IFs', LOG.rep lxp F (LOG.ActiveTxn m0 m') (BALLOCC.MSLog ms) sm hm' * [[[ m' ::: (Fm * rep bxp IFs' xp ilist' cache' * BALLOCC.rep bxp freelist' ms) ]]] * [[[ ilist' ::: (Fi * inum |-> ino') ]]] * [[ (Fs * IFs' * BALLOCC.smrep freelist')%pred sm ]] * [[ ilist' = updN ilist inum ino' ]] * [[ ino' = mk_inode (cuttail nr (IBlocks ino)) attr ]] * [[ incl freelist freelist' ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} reset lxp bxp xp inum nr attr cache ms. Proof. unfold reset, rep. safestep. simplen. extract; seprewrite. safestep. rewrite listmatch_isolate with (a := combine ilist _) (i := inum) by simplen. unfold inode_match. rewrite selN_combine by simplen. cancel. Ind.psubst. rewrite Ind.pred_fold_left_selN_removeN. cancel. step. subst; unfold BPtrSig.upd_irec, BPtrSig.IRLen. simpl. smash_rec_well_formed. repeat match goal with |- let (_, _) := ?y in _ => destruct y; intuition idtac end. unfold Ind.rep in *. rewrite BPtrSig.upd_irec_get_blk in *. match goal with H: context [lift_empty] |- _ => destruct_lift H end. auto. sepauto. safestep. 4, 5, 6: sepauto. rewrite combine_updN, listmatch_updN_removeN. unfold inode_match, BPtrSig.upd_len, BPtrSig.IRLen; simpl. rewrite rep_upd_attrs. cbn. unfold cuttail. match goal with [H : context [Ind.rep _ _ ?x ?l] |- context [length ?l] ] => unfold Ind.rep in H; destruct_lift H; substl (length l) end. cancel. auto using forall_firstn. simplen. simplen. rewrite Ind.pred_fold_left_updN_removeN. split; cancel. simplen. simplen. cancel; auto. cancel; auto. Unshelve. all: solve [eauto | exact IRec.Defs.item0 | exact (inode0, emp)]. Qed. Lemma grow_wellformed : forall (a : BPtrSig.irec) inum reclist cache F1 F2 F3 F4 m xp, ((((F1 * IRec.rep xp reclist cache) * F2) * F3) * F4)%pred m -> length (BPtrSig.IRBlocks a) = length (BPtrSig.IRBlocks (selN reclist inum irec0)) -> inum < length reclist -> Rec.well_formed a. Proof. unfold IRec.rep, IRec.LRA.rep, IRec.LRA.items_valid; intros. destruct_lift H. denote Forall as Hx. apply Forall_selN with (i := inum) (def := irec0) in Hx; auto. apply direct_blocks_length in Hx. setoid_rewrite <- H0 in Hx. cbv in Hx; cbv in a. smash_rec_well_formed. Qed. Theorem grow_ok : forall lxp bxp xp inum bn cache ms, {< F Fm Fi Fs m0 sm m IFs ilist ino freelist, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (BALLOCC.MSLog ms) sm hm * [[ length (IBlocks ino) < NBlocks ]] * [[ BALLOCC.bn_valid bxp bn ]] * [[[ m ::: (Fm * rep bxp IFs xp ilist cache * BALLOCC.rep bxp freelist ms) ]]] * [[[ ilist ::: (Fi * inum |-> ino) ]]] * [[ (Fs * IFs * BALLOCC.smrep freelist)%pred sm ]] POST:hm' RET:^(cache', ms, r) exists m', [[ isError r ]] * LOG.rep lxp F (LOG.ActiveTxn m0 m') (BALLOCC.MSLog ms) sm hm' \/ [[ r = OK tt ]] * exists ilist' ino' freelist' IFs', LOG.rep lxp F (LOG.ActiveTxn m0 m') (BALLOCC.MSLog ms) sm hm' * [[[ m' ::: (Fm * rep bxp IFs' xp ilist' cache' * BALLOCC.rep bxp freelist' ms) ]]] * [[[ ilist' ::: (Fi * inum |-> ino') ]]] * [[ (Fs * IFs' * BALLOCC.smrep freelist')%pred sm ]] * [[ ino' = mk_inode ((IBlocks ino) ++ [$ bn]) (IAttr ino) ]] * [[ incl freelist' freelist ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} grow lxp bxp xp inum bn cache ms. 
H1; auto. intros p H b; case b; try (intros; right; red in |- *; intros; discriminate). intros p1; case (H p1). intros e; rewrite e; auto. intros H1; right; Contradict H1; inversion H1; auto. intros p H b; case b; try (intros; right; red in |- *; intros; discriminate). intros p1; case (H p1). intros e; rewrite e; auto. intros H1; right; Contradict H1; inversion H1; auto. intros p H p0 H0 b; case b; try (intros; right; red in |- *; intros; discriminate). intros p1 p2; case (H p1); intros H1. case (H0 p2); intros H2. left; rewrite H1; rewrite H2; auto. right; Contradict H2; injection H2; auto. right; Contradict H1; injection H1; auto. Defined. Definition inpb_dec : forall a b, {inpb a b} + {~ inpb a b}. intros a b; elim b. intros a0; case a; try (intros; right; red in |- *; intros HH; inversion HH; auto; fail). intros a1; case (eqA_dec a1 a0); intros HH. left; rewrite HH; auto. right; Contradict HH; inversion HH; auto. intros p Hp; case Hp; auto; intros HH. case (pbtree_dec a (pbleft p)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize HH HH1; inversion HH2; auto. intros p Hp; case Hp; auto; intros HH. case (pbtree_dec a (pbright p)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize HH HH1; inversion HH2; auto. intros p H p0 H0. case H; auto; intros H1. case H0; auto; intros H2. case (pbtree_dec a (pbnode p p0)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize H1 H2 HH1; inversion HH2; auto. Defined. Theorem inpb_trans : forall t1 t2 t3, inpb t1 t2 -> inpb t2 t3 -> inpb t1 t3. Proof using. intros t1 t2 t3 H H1; generalize t1 H; elim H1; clear H H1 t1 t2 t3; auto. Qed. Theorem inpb_ex : forall t : pbtree, exists x : _, inpb (pbleaf x) t. Proof using. intros t; elim t; simpl in |- *; auto. intros a; exists a; auto. intros b (a, H); exists a; auto. intros b (a, H); exists a; auto. intros b (a, H) b0 H0; exists a; auto. Qed. Definition distinct_pbleaves (t : pbtree) : Prop := forall t0 t1 t2 : pbtree, inpb (pbnode t1 t2) t -> inpb t0 t1 -> inpb t0 t2 -> False. Theorem distinct_pbleaves_Leaf : forall a : A, distinct_pbleaves (pbleaf a). 
%| 'Res[H] chi 1%g)%C by rewrite cfResE ?group1. rewrite ['Res _]cfun_sum_cfdot sum_cfunE rpred_sum // => i _. rewrite cfunE dvdC_mulr ?Cint_Cnat ?Cnat_irr1 //. have [j ->]: exists j, 'chi_i = 'Res 'chi[G]_j. case/predU1P: ZHG => [-> | cGG] in i *. suffices ->: i = 0 by exists 0; rewrite !irr0 cfRes_cfun1 ?sub1G. apply/val_inj; case: i => [[|i] //=]; rewrite ltnNge NirrE. by rewrite (@leq_trans 1) // leqNgt classes_gt1 eqxx. have linG := char_abelianP G cGG; have linG1 j := eqP (proj2 (andP (linG j))). have /fin_all_exists[rH DrH] j: exists k, 'Res[H, G] 'chi_j = 'chi_k. apply/irrP/lin_char_irr/andP. by rewrite cfRes_char ?irr_char // cfRes1 ?linG1. suffices{i} all_rH: codom rH =i Iirr H. by exists (iinv (all_rH i)); rewrite DrH f_iinv. apply/subset_cardP; last exact/subsetP; apply/esym/eqP. rewrite card_Iirr_abelian ?(abelianS sHG) //. rewrite -(eqn_pmul2r (indexg_gt0 G H)) Lagrange //; apply/eqP. rewrite -sum_nat_const -card_Iirr_abelian // -sum1_card. rewrite (partition_big rH (mem (codom rH))) /=; last exact: image_f. have nsHG: H <| G by rewrite -sub_abelian_normal. apply: eq_bigr => _ /codomP[i ->]; rewrite -card_quotient ?normal_norm //. rewrite -card_Iirr_abelian ?quotient_abelian //. have Mlin j1 j2: exists k, 'chi_j1 * 'chi_j2 = 'chi[G]_k. exact/irrP/lin_char_irr/rpredM. have /fin_all_exists[rQ DrQ] (j : Iirr (G / H)) := Mlin i (mod_Iirr j). have mulJi: ('chi[G]_i)^*%CF * 'chi_i = 1. apply/cfun_inP=> x Gx; rewrite !cfunE -lin_charV_conj ?linG // cfun1E Gx. by rewrite lin_charV ?mulVf ?lin_char_neq0 ?linG. have inj_rQ: injective rQ. move=> j1 j2 /(congr1 (fun k => (('chi_i)^*%CF * 'chi_k) / H)%CF). by rewrite -!DrQ !mulrA mulJi !mul1r !mod_IirrE ?cfModK // => /irr_inj. rewrite -(card_imset _ inj_rQ) -sum1_card; apply: eq_bigl => j. rewrite -(inj_eq irr_inj) -!DrH; apply/eqP/imsetP=> [eq_ij | [k _ ->]]. have [k Dk] := Mlin (conjC_Iirr i) j; exists (quo_Iirr H k) => //. apply/irr_inj; rewrite -DrQ quo_IirrK //. by rewrite -Dk conjC_IirrE mulrCA mulrA mulJi mul1r. apply/subsetP=> x Hx; have Gx := subsetP sHG x Hx. rewrite cfkerEirr inE linG1 -Dk conjC_IirrE; apply/eqP. transitivity ((1 : 'CF(G)) x); last by rewrite cfun1E Gx. by rewrite -mulJi !cfunE -!(cfResE _ sHG Hx) eq_ij. rewrite -DrQ; apply/cfun_inP=> x Hx; rewrite !cfResE // cfunE mulrC. by rewrite cfker1 ?linG1 ?mul1r ?(subsetP _ x Hx) // mod_IirrE ?cfker_mod. have: (#|G : H| %| #|G : H|%:R * '[chi, 'chi_j])%C. by rewrite dvdC_mulr ?Cint_Cnat ?Cnat_cfdot_char_irr. congr (_ %| _)%C; rewrite (cfdotEl _ Hchi) -(Lagrange sHG) mulnC natrM. rewrite invfM -mulrA mulVKf ?neq0CiG //; congr (_ * _). by apply: eq_bigr => x Hx; rewrite !cfResE. Qed. Theorem faithful_degree_p_part gT (p : nat) (G P : {group gT}) i : cfaithful 'chi[G]_i -> p.-nat (truncC ('chi_i 1%g)) -> p.-Sylow(G) P -> abelian P -> 'chi_i 1%g = (#|G : 'Z(G)|`_p)%:R. 
replace 1%R with (IZR 1); auto with real. Qed. Hint Resolve Rle_IZR1: real. Theorem lt_Rlt : forall n m : nat, (INR n < INR m)%R -> n < m. intros n m H'; case (le_or_lt m n); auto; intros H0; Contradict H'; auto with real. case (le_lt_or_eq _ _ H0); intros H1; auto with real. rewrite H1; apply Rlt_irrefl. Qed. Theorem INR_inv : forall n m : nat, INR n = INR m -> n = m. intros n; elim n; auto; try rewrite S_INR. intros m; case m; auto. intros m' H1; Contradict H1; auto. rewrite S_INR. apply Rlt_dichotomy_converse; left. apply Rle_lt_0_plus_1. apply pos_INR. intros n' H' m; case m. intros H'0; Contradict H'0; auto. rewrite S_INR. apply Rlt_dichotomy_converse; right. red in |- *; apply Rle_lt_0_plus_1. apply pos_INR. intros m' H'0. rewrite (H' m'); auto. repeat rewrite S_INR in H'0. apply Rplus_eq_reg_l with (r := 1%R); repeat rewrite (Rplus_comm 1); auto with real. Qed. Theorem Rle_INR : forall x y : nat, x <= y -> (INR x <= INR y)%R. intros x y H; repeat rewrite INR_IZR_INZ. apply Rle_IZR; auto with zarith. Qed. Hint Resolve Rle_INR: real. Theorem le_Rle : forall n m : nat, (INR n <= INR m)%R -> n <= m. intros n m H'; case H'; auto. intros H'0; apply lt_le_weak; apply lt_Rlt; auto. intros H'0; rewrite <- (INR_inv _ _ H'0); auto with arith. Qed. Theorem Rmult_IZR : forall z t : Z, IZR (z * t) = (IZR z * IZR t)%R. intros z t; case z; case t; simpl in |- *; auto with real; unfold IZR; intros t1 z1; repeat rewrite <- INR_IPR. - rewrite nat_of_P_mult_morphism; auto with real. - rewrite nat_of_P_mult_morphism; auto with real. rewrite Rmult_comm. rewrite Ropp_mult_distr_l_reverse; auto with real. apply Ropp_eq_compat; rewrite mult_comm; auto with real. - rewrite nat_of_P_mult_morphism; auto with real. rewrite Ropp_mult_distr_l_reverse; auto with real. - rewrite nat_of_P_mult_morphism; auto with real. rewrite Rmult_opp_opp; auto with real. Qed. Theorem absolu_Zs : forall z : Z, (0 <= z)%Z -> Zabs_nat (Zsucc z) = S (Zabs_nat z). intros z; case z. 3: intros p H'; Contradict H'; auto with zarith. replace (Zsucc 0) with (Z_of_nat 1). intros H'; rewrite absolu_INR; simpl in |- *; auto. simpl in |- *; auto. intros p H'; rewrite <- Zpos_succ_morphism; simpl in |- *; auto with zarith. unfold nat_of_P in |- *; rewrite Pmult_nat_succ_morphism; auto. Qed. Hint Resolve Zlt_le_succ: zarith. Theorem Zlt_next : forall n m : Z, (n < m)%Z -> m = Zsucc n \/ (Zsucc n < m)%Z. 
a p) (pX b q) = pX (multTerm (A:=A) multA (n:=n) a b) c. intros p; elim p; clear p; auto. simpl in |- *; intros q a b H' H'0. cut (canonical A0 eqA ltM q); [ intros Op0 | apply canonical_imp_canonical with (a := b) ]; auto. exists (mults (A:=A) multA (n:=n) a q); simpl in |- *; auto. rewrite <- pO_pluspf_inv2; auto. intros a1 p H' q a0 b H'0 H'1; auto. elim (H' q a1 b); simpl in |- *; [ intros c E | idtac | idtac ]; auto. 2: apply canonical_imp_canonical with (a := a0); auto. rewrite E. exists (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) (pX (multTerm (A:=A) multA (n:=n) a1 b) c)); auto. rewrite <- pluspf_inv1_eq; auto. apply multTerm_ltT_r; auto. apply (canonical_pX_order _ A0 eqA) with (l := p); auto. Qed. Theorem in_multpf_head : forall (p q : list (Term A n)) (a b : Term A n), canonical A0 eqA ltM (pX a p) -> canonical A0 eqA ltM (pX b q) -> In (multTerm (A:=A) multA (n:=n) a b) (multpf (pX a p) (pX b q)). intros p q a b H' H'0. elim (multpf_head p q a b); [ intros c E; rewrite E | idtac | idtac ]; simpl in |- *; auto. Qed. Theorem multpf_comp : forall p r : list (Term A n), eqP A eqA n p r -> forall q s : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> canonical A0 eqA ltM s -> eqP A eqA n q s -> eqP A eqA n (multpf p q) (multpf r s). intros p r H'; elim H'; simpl in |- *; auto. intros ma mb p0 q H'0 H'1 H'2 q0 s H'3 H'4 H'5 H'6 H'7. cut (canonical A0 eqA ltM p0); [ intros Op0 | apply canonical_imp_canonical with (a := ma); auto ]. cut (canonical A0 eqA ltM q); [ intros Op1 | apply canonical_imp_canonical with (a := mb); auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) ma); [ intros Z0 | apply canonical_nzeroP with (ltM := ltM) (p := p0); auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) mb); [ intros Z1 | apply canonical_nzeroP with (ltM := ltM) (p := q) ]; auto. Qed. Theorem multpf_com : forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqP A eqA n (multpf p q) (multpf q p). 
(impred (S O) (fun y:Y => iscontr (hfiber f y)) (fun y:Y => isapropiscontr (hfiber f y))). Defined. Theorem isapropisisolated ( X : UU ) ( x : X ) : isaprop ( isisolated X x ) . Proof. intros . apply isofhlevelsn . intro is . apply impred . intro x' . apply ( isapropdec _ ( isaproppathsfromisolated X x is x' ) ) . Defined . Theorem isapropisdeceq (X:UU): isaprop (isdeceq X). Proof. intro. apply ( isofhlevelsn 0 ) . intro is . unfold isdeceq. apply impred . intro x . apply ( isapropisisolated X x ) . Defined . Definition isapropisdecprop ( X : UU ) : isaprop ( isdecprop X ) := isapropiscontr ( coprod X ( neg X ) ) .Theorem isapropisofhlevel (n:nat)(X:UU): isaprop (isofhlevel n X). Proof. intro. unfold isofhlevel. induction n as [ | n IHn ] . apply isapropiscontr. intro X . assert (X0: forall (x x':X), isaprop ((fix isofhlevel (n0 : nat) (X0 : UU) {struct n0} : UU := match n0 with | O => iscontr X0 | S m => forall x0 x'0 : X0, isofhlevel m (paths x0 x'0) end) n (paths x x'))). intros. apply (IHn (paths x x')). assert (is1: (forall x:X, isaprop (forall x' : X, (fix isofhlevel (n0 : nat) (X1 : UU) {struct n0} : UU := match n0 with | O => iscontr X1 | S m => forall x0 x'0 : X1, isofhlevel m (paths x0 x'0) end) n (paths x x')))). intro. apply (impred ( S O ) _ (X0 x)). apply (impred (S O) _ is1). Defined. Corollary isapropisaprop (X:UU) : isaprop (isaprop X). Proof. intro. apply (isapropisofhlevel (S O)). Defined. Corollary isapropisaset (X:UU): isaprop (isaset X). Proof. intro. apply (isapropisofhlevel (S (S O))). Defined. Theorem isapropisofhlevelf ( n : nat ) { X Y : UU } ( f : X -> Y ) : isaprop ( isofhlevelf n f ) . Proof . intros . unfold isofhlevelf . apply impred . intro y . apply isapropisofhlevel . Defined .Definition isapropisincl { X Y : UU } ( f : X -> Y ) := isapropisofhlevelf 1 f . Theorem isinclpr1weq ( X Y : UU ) : isincl ( @pr1 _ ( fun f : X -> Y => isweq f ) ) . Proof. intros . apply isinclpr1 . intro f. apply isapropisweq . Defined . Theorem isinclpr1isolated ( T : UU ) : isincl ( pr1isolated T ) . 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Poly.Theorem silly1 : forall (n m o p : nat), n = m -> [n;o] = [n;p] -> [n;o] = [m;p]. Admitted. Theorem silly2 : forall (n m o p : nat), n = m -> (forall (q r : nat), q = r -> [q;o] = [r;p]) -> [n;o] = [m;p]. Admitted. Theorem silly3_firsttry : forall (n : nat), n = 5 -> beq_nat (S (S n)) 7 = true. Admitted. QuickChick silly3_firsttry. *) Theorem rev_exercise1 : forall (l l' : list nat), l = rev l' -> l' = rev l. Admitted. QuickChick rev_exercise1. *)Theorem trans_eq : forall (X:Type) (n m o : X), n = m -> m = o -> n = o. Admitted. QuickChick trans_eq. *)Example trans_eq_example' : forall (a b c d e f : nat), [a;b] = [c;d] -> [c;d] = [e;f] -> [a;b] = [e;f]. Admitted. Example trans_eq_exercise : forall (n m o p : nat), m = (minustwo o) -> (n + p) = m -> (n + p) = (minustwo o). Admitted. Theorem S_injective : forall (n m : nat), S n = S m -> n = m. Admitted. Theorem beq_nat_0_l : forall n, 0 = n -> n = 0. Admitted. QuickChick beq_nat_0_l. *)Theorem inversion_ex4 : forall (n : nat), S n = O -> 2 + 2 = 5. Admitted. Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A), x = y -> f x = f y. Admitted. Theorem plus_n_n_injective : forall n m, n + n = m + m -> n = m. Admitted. Theorem double_injective : forall n m, double n = double m -> n = m. 
p; simpl in |- *; auto. intros H'; case H'. apply Zdivides1. intros n H'; case (ZdividesP v (radix * Zpower_nat radix n)); auto. intros H'0; case H'; auto. intros H'0; generalize (maxDivLess v n); auto with arith. Qed. Theorem maxDivCorrect : forall (v : Z) (p : nat), Zdivides v (Zpower_nat radix (maxDiv v p)). intros v p; elim p. unfold maxDiv in |- *; rewrite Zpower_nat_O; auto. apply Zdivides1. simpl in |- *. intros n H'; case (ZdividesP v (radix * Zpower_nat radix n)); simpl in |- *; auto with zarith. Qed. Theorem maxDivSimplAux : forall (v : Z) (p q : nat), p = maxDiv v (S (q + p)) -> p = maxDiv v (S p). intros v p q; elim q. simpl in |- *; case (ZdividesP v (radix * Zpower_nat radix p)); auto. intros n H' H'0. apply H'; auto; clear H'. simpl in H'0; generalize H'0; clear H'0. case (ZdividesP v (radix * (radix * Zpower_nat radix (n + p)))). 2: simpl in |- *; auto. intros H' H'0; Contradict H'0; auto with zarith. Qed. Theorem maxDivSimpl : forall (v : Z) (p q : nat), p < q -> p = maxDiv v q -> p = maxDiv v (S p). intros v p q H' H'0. apply maxDivSimplAux with (q := q - S p); auto. replace (S (q - S p + p)) with q; auto with zarith. Qed. Theorem maxDivSimplInvAux : forall (v : Z) (p q : nat), p = maxDiv v (S p) -> p = maxDiv v (S (q + p)). intros v p q H'; elim q. simpl in |- *; auto. intros n; simpl in |- *. case (ZdividesP v (radix * Zpower_nat radix (n + p))); auto. case (ZdividesP v (radix * (radix * Zpower_nat radix (n + p)))); auto. intros H'0 H'1 H'2; Contradict H'2; auto with zarith. case (ZdividesP v (radix * (radix * Zpower_nat radix (n + p)))); auto. intros H'0 H'1 H'2; case H'1. case H'0; intros z1 Hz1; exists (radix * z1)%Z;rewrite Hz1. unfold Zpower_nat; simpl; ring. Qed. Theorem maxDivSimplInv : forall (v : Z) (p q : nat), p < q -> p = maxDiv v (S p) -> p = maxDiv v q. intros v p q H' H'0. replace q with (S (q - S p + p)); auto with zarith. apply maxDivSimplInvAux; auto. Qed. Theorem maxDivUnique : forall (v : Z) (p : nat), p = maxDiv v (S p) -> Zdivides v (Zpower_nat radix p) /\ ~ Zdivides v (Zpower_nat radix (S p)). 
Prop) (h1 : forall u : A, P u u) (h2 : forall u v w : A, R u v -> P v w -> P u w) => h1 x. Theorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z. Proof fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop) (h1 : forall u : A, P u u) (h2 : forall u v w : A, R u v -> P v w -> P u w) => h2 x y z t1 (t2 P h1 h2). Theorem Rstar_transitive : forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z. Proof fun (x y z : A) (h : Rstar x y) => h (fun u v : A => Rstar v z -> Rstar u z) (fun (u : A) (t : Rstar u z) => t) (fun (u v w : A) (t1 : R u v) (t2 : Rstar w z -> Rstar v z) (t3 : Rstar w z) => Rstar_R u v z t1 (t2 t3)). Definition Rstar' (x y : A) := forall P : A -> A -> Prop, P x x -> (forall u : A, R x u -> Rstar u y -> P x y) -> P x y. Theorem Rstar'_reflexive : forall x : A, Rstar' x x. Proof fun (x : A) (P : A -> A -> Prop) (h : P x x) (h' : forall u : A, R x u -> Rstar u x -> P x x) => h. Theorem Rstar'_R : forall x y z : A, R x z -> Rstar z y -> Rstar' x y. Proof fun (x y z : A) (t1 : R x z) (t2 : Rstar z y) (P : A -> A -> Prop) (h1 : P x x) (h2 : forall u : A, R x u -> Rstar u y -> P x y) => h2 z t1 t2. Theorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y. Proof fun (x y : A) (h : Rstar' x y) => h Rstar (Rstar_reflexive x) (fun u : A => Rstar_R x u y). Theorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y. 
Require Import VerdiRaft.Raft.Local Arguments update {_} {_} {_} _ _ _ _ : simpl never.Require Import VerdiRaft.AppendEntriesReplySublogInterface.Require Import VerdiRaft.AppendEntriesRequestReplyCorrespondenceInterface. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.AppendEntriesLeaderInterface.Section AppendEntriesReplySublog. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {aerrci : append_entries_request_reply_correspondence_interface}. Context {rri : raft_refinement_interface}. Context {aeli : append_entries_leader_interface}. Definition lowered_appendEntries_leader (net : @network _ multi_params) := forall p t leaderId prevLogIndex prevLogTerm entries leaderCommit h e, In p (nwPackets net) -> pBody p = AppendEntries t leaderId prevLogIndex prevLogTerm entries leaderCommit -> In e entries -> currentTerm (nwState net h) = t -> type (nwState net h) = Leader -> In e (log (nwState net h)). Theorem lower_appendEntries_leader : forall net, raft_intermediate_reachable net -> lowered_appendEntries_leader net. Proof using aeli rri. intros. apply (lower_prop lowered_appendEntries_leader); auto. intros. find_apply_lem_hyp append_entries_leader_invariant. unfold lowered_appendEntries_leader, appendEntries_leader in *. intros. simpl in *. repeat break_match. simpl in *. do_in_map. subst. simpl in *. match goal with | H : ?nwState ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState h)) in * by (rewrite H; reflexivity); clear H end. eapply_prop_hyp AppendEntries AppendEntries; eauto. Qed. Theorem append_entries_reply_sublog_invariant : forall net, raft_intermediate_reachable net -> append_entries_reply_sublog net. 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.SemEquiv. Require Import FCF.DetSem.Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) := match n with | 0 => fun (v : Vector.t A (O + m)) => (@Vector.nil A, v) | S n' => fun (v : Vector.t A (S n' + m)) => let (v1, v2) := splitVector _ _ (Vector.tl v) in (Vector.cons _ (Vector.hd v) _ v1, v2) end.Theorem splitVector_append : forall (A : Set) n1 (v1 : Vector.t A n1) n2 (v2 : Vector.t A n2), splitVector n1 n2 (Vector.append v1 v2) = (v1, v2). induction v1; intuition; simpl in *. remember ( splitVector n n2 (Vector.append v1 v2)) as z. destruct z. rewrite IHv1 in Heqz. inversion Heqz; subst. trivial. Qed.Theorem append_splitVector_h : forall (A : Set) n1 n2 (x : Vector.t A (n1 + n2)), (Vector.append (fst (splitVector n1 n2 x)) (snd (splitVector n1 n2 x))) = x. induction n1; intuition; simpl in *. destruct (vector_S x). destruct H. subst. simpl. remember (splitVector n1 n2 x1) as z. destruct z. simpl. f_equal. specialize (IHn1 n2 x1). rewrite <- Heqz in IHn1. simpl in *. trivial.Qed.Theorem append_splitVector: forall (A : Set) n1 n2 (x : Vector.t A (n1 + n2)) x1 x2, (x1, x2) = (splitVector n1 n2 x) -> (Vector.append x1 x2) = x. intuition. specialize (append_splitVector_h _ _ x); intuition. rewrite <- H in H0. simpl in *. trivial.Qed. Theorem shiftOut_plus : forall (n1 n2 : nat) s b s', shiftOut s (n1 + n2) = Some (b, s') -> exists b1 b2 s'', shiftOut s n1 = Some (b1, s'') /\ shiftOut s'' n2 = Some (b2, s') /\ splitVector n1 n2 b = (b1, b2). 
is_jrnl_to_old_pred' with "Hjrnl_mem Hdurable_frag Hold_vals" ). Qed. Definition jrnl_maps_to γtxn (a: addr) obj : iProp Σ := ptsto_mut γtxn a 1 obj. Global Instance jrnl_maps_to_conflicting γtxn : Conflicting (jrnl_maps_to γtxn). Proof. rewrite /jrnl_maps_to. iIntros (????) "Ha1 Ha2". destruct (decide (a0 = a1)); subst; auto. iDestruct (ptsto_conflict with "Ha1 Ha2") as %[]. Qed. Definition object_to_versioned (obj: object): versioned_object := existT (objKind obj) (objData obj, objData obj). Lemma committed_to_versioned obj : mspec.committed (object_to_versioned obj) = obj. Proof. destruct obj; reflexivity. Qed. Lemma modified_to_versioned obj : mspec.modified (object_to_versioned obj) = obj. Proof. destruct obj; reflexivity. Qed. Lemma durable_mapsto_mapsto_txn_agree' E γ a obj1 obj2 k q : ↑N ⊆ E → ↑invN ⊆ E → N ## invN → is_txn_system γ -∗ durable_mapsto γ a obj1 -∗ mapsto_txn γ.(jrnl_txn_names) a obj2 -∗ NC q -∗ |k={E}=> (⌜obj1 = obj2⌝ ∗ durable_mapsto γ a obj1 ∗ mapsto_txn γ.(jrnl_txn_names) a obj2) ∗ NC q. Proof. iIntros (???) "#Hinv Ha_i Ha HNC". iNamed "Hinv". iMod (ncinv_acc_k with "His_txn [$]") as "(>Hinner1&HNC&Hclose1)"; first by auto. iMod (ncinv_acc_k with "Htxn_inv [$]") as "(>Hinner2&HNC&Hclose2)"; first by set_solver. iAssert (⌜obj1 = obj2⌝)%I as %?; last first. { iMod ("Hclose2" with "[$] [$]") as "HNC". iMod ("Hclose1" with "[$] [$]") as "HNC". iFrame. auto. } iNamed "Hinner1". iClear "Hheapmatch Hcrashheapsmatch Hmetactx". iNamed "Hinner2". iDestruct (ghost_var_agree with "Hcrashstates [$]") as %->. iDestruct (mapsto_txn_cur with "Ha") as "[Ha _]". iDestruct "Ha_i" as (i) "[Ha_i _]". iDestruct (ephemeral_val_from_agree_latest with "H●latest Ha_i") as %Hlookup_obj. iDestruct (ghost_map_lookup with "Hlogheapctx [$]") as %Hlookup_obj0. iPureIntro. congruence. Qed. Lemma durable_mapsto_mapsto_txn_agree E γ a obj1 obj2 : ↑N ⊆ E → ↑invN ⊆ E → N ## invN → is_txn_system γ -∗ durable_mapsto γ a obj1 -∗ mapsto_txn γ.(jrnl_txn_names) a obj2 -∗ |NC={E}=> ⌜obj1 = obj2⌝ ∗ durable_mapsto γ a obj1 ∗ mapsto_txn γ.(jrnl_txn_names) a obj2. Proof. iIntros (???) "#Hinv Ha_i Ha". rewrite ncfupd_eq /ncfupd_def. iIntros. iApply (fupd_level_fupd _ _ _ O). iMod (durable_mapsto_mapsto_txn_agree' with "[$] [$] [$] [$]"); auto. Qed. Theorem is_jrnl_durable_not_in_map γ a obj γdurable P0 committed_mT : durable_mapsto γ a obj -∗ is_jrnl_durable γ γdurable P0 -∗ map_ctx γdurable (1 / 2) committed_mT -∗ ⌜committed_mT !! a = None⌝. Proof. iIntros "Ha Hdur Hctx". destruct (committed_mT !! a) eqn:He; try eauto. iNamed "Hdur". iDestruct (map_ctx_agree with "Hctx Hdurable_frag") as %->. iDestruct (big_sepM_lookup with "Hold_vals") as "Ha2"; eauto. iDestruct "Ha" as (i) "[Ha _]". iDestruct "Ha2" as (i2) "[Ha2 _]". iDestruct (ephemeral_val_from_conflict with "Ha Ha2") as "H". done. Qed. Theorem lift_into_txn' E l γ dinit γtxn γdurable committed_mT a obj : ↑N ⊆ E → ↑invN ⊆ E → N ## invN → "Hjrnl_mem" ∷ is_jrnl_mem l γ dinit γtxn γdurable -∗ "Hdurable_frag" ∷ map_ctx γdurable (1/2) committed_mT -∗ "Hdurable_maps_to" ∷ durable_mapsto_own γ a obj -∗ |NC={E}=> "Hjrnl_maps_to" ∷ jrnl_maps_to γtxn a obj ∗ "Hjrnl_mem" ∷ is_jrnl_mem l γ dinit γtxn γdurable ∗ "Hdurable_frag" ∷ map_ctx γdurable (1/2) (<[a:=obj]>committed_mT) ∗ "Hdurable_maps_to" ∷ durable_mapsto γ a obj ∗ "%Hnew" ∷ ⌜committed_mT !! a = None⌝. 
unfold log_matching in *. find_copy_apply_lem_hyp state_machine_safety_invariant. unfold state_machine_safety in *. find_copy_apply_lem_hyp max_index_sanity_invariant. unfold maxIndex_sanity in *. unfold lastApplied_commitIndex_match. intuition; simpl in *. - unfold log_matching_hosts in *. intuition. simpl in *. match goal with | H : forall (_ : name) (_ : nat), _ |- In ?e (_ (_ ?h)) => specialize (H h (eIndex e)); forward H; intuition end. + find_apply_hyp_hyp; omega. + eapply le_trans; [|eapply_prop maxIndex_commitIndex]. simpl. omega. + break_exists. intuition. match goal with | _ : eIndex ?e = eIndex ?e' |- _ => cut (e = e'); [intros; subst; auto|] end. eapply_prop state_machine_safety_host; unfold commit_recorded; intuition eauto; simpl in *; intuition. - unfold log_matching_hosts in *. intuition. simpl in *. match goal with | H : forall (_ : name) (_ : nat), _ |- In ?e (_ (_ ?h)) => specialize (H h (eIndex e)); forward H; intuition end. + find_apply_hyp_hyp; omega. + eapply le_trans; [|eapply_prop maxIndex_lastApplied]. simpl. omega. + break_exists. intuition. match goal with | _ : eIndex ?e = eIndex ?e' |- _ => cut (e = e'); [intros; subst; auto|] end. eapply_prop state_machine_safety_host; unfold commit_recorded; intuition eauto; simpl in *; intuition. Qed. Theorem commitIndex_lastApplied_match_invariant : forall net, raft_intermediate_reachable net -> commitIndex_lastApplied_match net. Proof using misi smsi lmi. intros. find_copy_apply_lem_hyp log_matching_invariant. unfold log_matching in *. find_copy_apply_lem_hyp state_machine_safety_invariant. unfold state_machine_safety in *. find_copy_apply_lem_hyp max_index_sanity_invariant. unfold maxIndex_sanity in *. unfold commitIndex_lastApplied_match. intuition; simpl in *. - unfold log_matching_hosts in *. intuition. simpl in *. match goal with | H : forall (_ : name) (_ : nat), _ |- In ?e (_ (_ ?h)) => specialize (H h (eIndex e)); forward H; intuition end. + find_apply_hyp_hyp; omega. + eapply le_trans; [|eapply_prop maxIndex_lastApplied]. simpl. omega. + break_exists. intuition. match goal with | _ : eIndex ?e = eIndex ?e' |- _ => cut (e = e'); [intros; subst; auto|] end. eapply_prop state_machine_safety_host; unfold commit_recorded; intuition eauto; simpl in *; intuition. - unfold log_matching_hosts in *. intuition. simpl in *. match goal with | H : forall (_ : name) (_ : nat), _ |- In ?e (_ (_ ?h)) => specialize (H h (eIndex e)); forward H; intuition end. + find_apply_hyp_hyp; omega. + eapply le_trans; [|eapply_prop maxIndex_commitIndex]. simpl. omega. + break_exists. intuition. match goal with | _ : eIndex ?e = eIndex ?e' |- _ => cut (e = e'); [intros; subst; auto|] end. eapply_prop state_machine_safety_host; unfold commit_recorded; intuition eauto; simpl in *; intuition. Qed. Theorem lastApplied_lastApplied_match_invariant : forall net, raft_intermediate_reachable net -> lastApplied_lastApplied_match net. 
b)} : Checkable (forall a b, pre a -> prop a b ) := {| checker f := @checker (forall a, pre a -> forall b, prop a b) _ _ |}. Proof. intros; eauto. Defined.Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m). Admitted. Inductive ev' : nat -> Prop := | ev'_0 : ev' 0 | ev'_2 : ev' 2 | ev'_sum : forall n m, ev' n -> ev' m -> ev' (n + m).Theorem ev'_ev : forall n, ev' n <-> ev n. Admitted. Theorem ev_ev__ev : forall n m, ev (n+m) -> ev n -> ev m. Admitted. Theorem ev_plus_plus : forall n m p, ev (n+m) -> ev (n+p) -> ev (m+p). Admitted. Inductive next_nat : nat -> nat -> Prop := | nn : forall n:nat, next_nat n (S n).Derive ArbitrarySizedSuchThat for (fun n => next_nat n m). Derive SizeMonotonicSuchThatOpt for (fun n => next_nat n m). Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_nat n m). Derive SizedProofEqs for (fun n => next_nat n m). Derive GenSizedSuchThatCorrect for (fun n => next_nat n m).Derive ArbitrarySizedSuchThat for (fun n => next_nat m n). Derive SizeMonotonicSuchThatOpt for (fun n => next_nat m n). Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_nat n m). Derive SizedProofEqs for (fun n => next_nat n m). Derive GenSizedSuchThatCorrect for (fun n => next_nat n m).Inductive next_even : nat -> nat -> Prop := | ne_1 : forall n, ev (S n) -> next_even n (S n) | ne_2 : forall n, ev (S (S n)) -> next_even n (S (S n)).Derive ArbitrarySizedSuchThat for (fun n => next_even n m). Derive SizeMonotonicSuchThatOpt for (fun n => next_even n m). Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_even n m). Derive SizedProofEqs for (fun n => next_even n m). Derive GenSizedSuchThatCorrect for (fun n => next_even n m).Derive ArbitrarySizedSuchThat for (fun n => next_even m n). Derive SizeMonotonicSuchThatOpt for (fun n => next_even m n). Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_even n m). Derive SizedProofEqs for (fun n => next_even n m). Derive GenSizedSuchThatCorrect for (fun n => next_even n m). Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o. Admitted. Theorem O_le_n : forall n, 0 <= n. Admitted. Theorem n_le_m__Sn_le_Sm : forall n m, n <= m -> S n <= S m. Admitted. Theorem Sn_le_Sm__n_le_m : forall n m, S n <= S m -> n <= m. 
Events.external_functions_sem name sg (Genv.globalenv p) [make_vint n] m [] Vfalse m) /\ (forall m b i, Events.external_functions_sem name sg (Genv.globalenv p) [Vptr b i] m [] Vtrue m). deref_loc valPtr m' tinf_b tinf_ofs (Vptr alloc_b alloc_ofs) /\ deref_loc valPtr m' tinf_b (Int.add tinf_ofs (Int.repr int_size)) (Vptr alloc_b limit_ofs) /\ deref_loc valPtr m' tinf_b (Int.add tinf_ofs (Int.repr (3*int_size))) (Vptr args_b args_ofs) /\ mem_same_block args_b m m' /\ (forall lenv' : temp_env, forall vsm4 vs7 vars, lenv_param_asgn (M.set argsIdent (Vptr args_b args_ofs) (M.set limitIdent (Vptr alloc_b limit_ofs) (M.set allocIdent (Vptr alloc_b alloc_ofs) (Maps.PTree.set tinfIdent (Vptr tinf_b tinf_ofs) (create_undef_temps vars))))) lenv' vsm4 vs7 -> rel_mem_L6_L7_id fenv finfo_env p rep_env e rho m' lenv' /\ correct_tinfo p (Int.unsigned finfo_maxalloc) lenv' m'). *) Inductive rel_mem_asgn {fenv finfo_env p rep_env} args_b args_ofs m L: list L6.cps.val -> list N -> list Values.val -> Prop := | rma_cons: forall i v6 v7 vs6 inf vs7, rel_mem_asgn args_b args_ofs m L vs6 inf vs7 -> Mem.loadv int_chunk m (Vptr args_b (Ptrofs.add args_ofs (Ptrofs.repr (int_size * (Z.of_N i))))) = Some v7 -> repr_val_L_L6_L7_id fenv finfo_env p rep_env v6 m L v7 -> rel_mem_asgn args_b args_ofs m L (v6::vs6) (i::inf) (v7::vs7) | rma_nil: rel_mem_asgn args_b args_ofs m L [] [] []. Theorem rel_mem_asgn_length: forall {fenv finfo_env p rep_env m L args_b args_ofs ys inf vs}, @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L ys inf vs -> length ys = length vs. Proof. induction ys; intros. inv H; auto. inv H. simpl. erewrite IHys. reflexivity. eauto. Qed. Theorem rel_mem_asgn_nthN: forall {L rep_env finfo_env fenv args_b args_ofs p m vs6 inf vs7 v6 v7 n}, @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L vs6 inf vs7 -> nthN vs6 n = Some v6 -> nthN vs7 n = Some v7 -> repr_val_L_L6_L7_id fenv finfo_env p rep_env v6 m L v7. Proof. induction vs6; intros. inv H0. destruct vs7. inv H1. inv H. destruct n. inv H0; inv H1; auto. apply nthN_pos_pred in H0. apply nthN_pos_pred in H1. eapply IHvs6; eauto. Qed. Theorem cons_get_list: forall {A y ys rho vs}, @get_list A (y::ys) rho = Some vs -> exists v vs', v::vs' = vs /\ M.get y rho = Some v /\ @get_list A ys rho = Some vs'. Proof. intros. simpl in H. destruct (M.get y rho) eqn:Hgy; destruct (get_list ys rho) eqn:Hgys. exists a, l. split. inv H; auto. split; reflexivity. inv H. inv H. inv H. Qed. Theorem rel_mem_after_asgn: forall fenv finfo_env p rep_env args_b args_ofs m L vs6 locs vs7, @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L vs6 locs vs7 -> mem_after_asgn args_b args_ofs m locs vs7. 
as [(n,Hn)|Hn]. right; simpl; exists n; now split. left; split; trivial. intros n; specialize (Hn n); omega. Qed.Context { valid_exp : Valid_exp fexp }.Lemma fexp_negligible_exp_eq: forall n m, (n <= fexp n)%Z -> (m <= fexp m)%Z -> fexp n = fexp m. Proof. intros n m Hn Hm. case (Zle_or_lt n m); intros H. apply valid_exp; omega. apply sym_eq, valid_exp; omega. Qed.Definition ulp x := match Req_bool x 0 with | true => match negligible_exp with | Some n => bpow (fexp n) | None => 0%R end | false => bpow (canonic_exp beta fexp x) end.Lemma ulp_neq_0 : forall x:R, (x <> 0)%R -> ulp x = bpow (canonic_exp beta fexp x). Proof. intros x Hx. unfold ulp; case (Req_bool_spec x); trivial. intros H; now contradict H. Qed.Notation F := (generic_format beta fexp).Theorem ulp_opp : forall x, ulp (- x) = ulp x. Proof. intros x. unfold ulp. case Req_bool_spec; intros H1. rewrite Req_bool_true; trivial. rewrite <- (Ropp_involutive x), H1; ring. rewrite Req_bool_false. now rewrite canonic_exp_opp. intros H2; apply H1; rewrite H2; ring. Qed.Theorem ulp_abs : forall x, ulp (Rabs x) = ulp x. Proof. intros x. unfold ulp; case (Req_bool_spec x 0); intros H1. rewrite Req_bool_true; trivial. now rewrite H1, Rabs_R0. rewrite Req_bool_false. now rewrite canonic_exp_abs. now apply Rabs_no_R0. Qed.Theorem ulp_ge_0: forall x, (0 <= ulp x)%R. Proof. intros x; unfold ulp; case Req_bool_spec; intros. case negligible_exp; intros. apply bpow_ge_0. apply Rle_refl. apply bpow_ge_0. Qed. Theorem ulp_le_id: forall x, (0 < x)%R -> F x -> (ulp x <= x)%R. Proof. intros x Zx Fx. rewrite <- (Rmult_1_l (ulp x)). pattern x at 2; rewrite Fx. rewrite ulp_neq_0. 2: now apply Rgt_not_eq. unfold F2R; simpl. apply Rmult_le_compat_r. apply bpow_ge_0. apply (Z2R_le (Zsucc 0)). apply Zlt_le_succ. apply F2R_gt_0_reg with beta (canonic_exp beta fexp x). now rewrite <- Fx. Qed.Theorem ulp_le_abs: forall x, (x <> 0)%R -> F x -> (ulp x <= Rabs x)%R. Proof. intros x Zx Fx. rewrite <- ulp_abs. apply ulp_le_id. now apply Rabs_pos_lt. now apply generic_format_abs. Qed.Theorem round_UP_DN_ulp : forall x, ~ F x -> round beta fexp Zceil x = (round beta fexp Zfloor x + ulp x)%R. Proof. intros x Fx. rewrite ulp_neq_0. unfold round. simpl. unfold F2R. simpl. rewrite Zceil_floor_neq. rewrite Z2R_plus. simpl. ring. intros H. apply Fx. unfold generic_format, F2R. simpl. rewrite <- H. rewrite Ztrunc_Z2R. rewrite H. now rewrite scaled_mantissa_mult_bpow. intros V; apply Fx. rewrite V. apply generic_format_0. Qed. Theorem ulp_bpow : forall e, ulp (bpow e) = bpow (fexp (e + 1)). 
Require Import Coq.Logic.ProofIrrelevance. Require Import Main.Tactics.#[local] Set Universe Polymorphism.Record category := newCategory { object : Type; arrow : object -> object -> Type; compose {x y z} : arrow y z -> arrow x y -> arrow x z; id {x}: arrow x x; cAssoc {w x y z} (f : arrow w x) (g : arrow x y) (h : arrow y z) : compose h (compose g f) = compose (compose h g) f; cIdentLeft {x y} (f : arrow x y) : compose id f = f; cIdentRight {x y} (f : arrow x y) : compose f id = f; }.Arguments arrow {_}. Arguments compose {_} {_} {_} {_}. Arguments id {_} {_}. Arguments cAssoc {_} {_} {_} {_} {_}. Arguments cIdentLeft {_} {_} {_}. Arguments cIdentRight {_} {_} {_}.#[export] Hint Resolve cAssoc : main. #[export] Hint Resolve cIdentLeft : main. #[export] Hint Rewrite @cIdentLeft : main. #[export] Hint Resolve cIdentRight : main. #[export] Hint Rewrite @cIdentRight : main.#[local] Theorem opCAssoc {C} (w x y z : object C) (f : arrow x w) (g : arrow y x) (h : arrow z y) : compose (compose f g) h = compose f (compose g h). Proof. magic. Qed.#[local] Theorem opCIdentLeft {C} (x y : object C) (f : arrow y x) : compose f id = f. 
Rle_pos_neg; replace (- (x * y))%R with (x * (- y))%R; auto with real; try ring. apply Rmult_le_pos; auto with real. Qed.Theorem Rle_sign_neg_pos: forall x y, (x <= 0 -> 0 <= y -> x * y <= 0)%R. intros x y H1 H2; apply Rle_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring. apply Rmult_le_pos; auto with real. Qed.Theorem Rlt_sign_pos_pos: forall x y, (0 < x -> 0 < y -> 0 < x * y)%R. intros; apply Rmult_lt_0_compat; auto with real. Qed.Theorem Rlt_sign_neg_neg: forall x y, (x < 0 -> y < 0 -> 0 < x * y)%R. intros x y H1 H2; replace (x * y)%R with (-x * -y)%R; auto with real; try ring. apply Rmult_lt_0_compat; auto with real. Qed.Theorem Rlt_pos_neg: forall x, (0 < -x -> x < 0)%R. intros x H; rewrite <- (Ropp_involutive 0); rewrite <- (Ropp_involutive x); auto with real. apply Ropp_lt_contravar; auto with real. rewrite Ropp_0; auto with real. Qed.Theorem Rlt_sign_pos_neg: forall x y, (0 < x -> y < 0 -> x * y < 0)%R. intros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (x * (- y))%R; auto with real; try ring. apply Rmult_lt_0_compat; auto. replace 0%R with (-0)%R; auto with real. Qed.Theorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y -> x * y < 0)%R. intros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring. apply Rmult_lt_0_compat; auto with real. Qed.Theorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y -> x * y >= 0)%R. intros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real. Qed.Theorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0 -> x * y >= 0)%R. intros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real. Qed.Theorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R. intros x H; rewrite <- (Ropp_involutive 0); rewrite <- (Ropp_involutive x); auto with real. apply Rle_ge;apply Ropp_le_contravar; auto with real. rewrite Ropp_0; auto with real. Qed.Theorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0 -> 0>= x * y)%R. intros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real. Qed.Theorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y -> 0 >= x * y)%R. intros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real. Qed. Theorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y -> x * y > 0)%R. 
n ltM (pX a0 l) c)) Q) in |- *; apply in_inPolySet; auto. red in |- *; intros H'4; inversion H'4. Qed. Theorem inPolySet_addEnd : forall (a : list (Term A n)) (p : poly A0 eqA ltM) (l : list (poly A0 eqA ltM)), inPolySet A A0 eqA n ltM a (addEnd p l) -> a = s2p A A0 eqA n ltM p \/ inPolySet A A0 eqA n ltM a l. intros a p l; elim l; simpl in |- *; auto. intros H'; inversion H'; auto. intros a0 l0 H' H'0; inversion H'0; auto. right. exact (incons A A0 eqA n ltM a1 p0 H l0). case H'; auto. intros H3; right; try assumption. apply inskip; auto. Qed. Remark CombLinear_trans1 : forall (a : list (Term A n)) (R : list (poly A0 eqA ltM)), CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec R a -> forall (b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), R = addEnd b Q -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q (s2p A A0 eqA n ltM b) -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a. intros a R H'; elim H'; auto. intros b Q H'0 H'1. apply CombLinear_0; auto. intros a0 p q s H'0 H'1 H'2 H'3 H'4 b Q H'5 H'6. apply CombLinear_comp with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply eqp_imp_canonical with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. 2: apply canonical_pluspf with (1 := os); auto. 2: apply canonical_mults with (1 := cs); auto. 2: apply inPolySet_imp_canonical with (L := R); auto. 2: apply CombLinear_canonical with (eqA_dec := eqA_dec) (ltM_dec := ltM_dec) (1 := cs) (Q := R); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply CombLinear_pluspf with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. 2: apply H'3 with (b := b); auto. case (inPolySet_addEnd q b Q); auto. rewrite <- H'5; auto. intros H'7; rewrite H'7; auto. intros; (apply CombLinear_id with (1 := cs); auto). Qed. Theorem Cb_trans : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a (addEnd b Q) -> Cb b Q -> Cb a Q. 
E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Ring.sum_inv_r_uniq ring. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Ring.sum_0_inv_l ring. Theorem sum_0_inv_r : sum_is_inv_r 0 0. Proof Ring.sum_0_inv_r ring. Theorem sum_0_inv : sum_is_inv 0 0. Proof Ring.sum_0_inv ring. Theorem sum_has_inv_l_0 : sum_has_inv_l 0. Proof Ring.sum_has_inv_l_0 ring. Theorem sum_has_inv_r_0 : sum_has_inv_r 0. Proof Ring.sum_has_inv_r_0 ring. Theorem sum_has_inv_0 : sum_has_inv 0. Proof Ring.sum_has_inv_0 ring. Theorem sum_inv_0_eq_0 : forall x : E, sum_is_inv x 0 -> x = 0. Proof Ring.sum_inv_0_eq_0 ring. Theorem sum_inv_0_uniq : unique (fun x => sum_is_inv x 0) 0. Proof Ring.sum_inv_0_uniq ring. Definition sum_neg_strong : forall x : E, { y | sum_is_inv x y } := Ring.sum_neg_strong ring. Definition sum_neg : E -> E := Ring.sum_neg ring.Notation "{-}" := (sum_neg) : commutative_ring_scope.Notation "- x" := (sum_neg x) : commutative_ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Ring.sum_neg_def ring. Theorem sum_neg_inj : is_injective E E sum_neg. Proof Ring.sum_neg_inj ring. Theorem sum_cancel_neg : forall x : E, sum_neg (- x) = x. Proof Ring.sum_cancel_neg ring. Theorem sum_neg_onto : is_onto E E sum_neg. Proof Ring.sum_neg_onto ring. Theorem sum_neg_bijective : is_bijective E E sum_neg. Proof Ring.sum_neg_bijective ring. Theorem sum_neg_rev : forall x y : E, - x = y -> - y = x. Proof Ring.sum_neg_rev ring. Theorem sum_neg_distrib_inv_l : forall x y : E, sum_is_inv_l (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_l ring. Theorem sum_neg_distrib_inv_r : forall x y : E, sum_is_inv_r (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_r ring. Theorem sum_neg_distrib_inv : forall x y : E, sum_is_inv (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv ring. Theorem sum_neg_distrib : forall x y : E, - (x + y) = - y + - x. Proof Ring.sum_neg_distrib ring. Theorem sum_0_neg : - 0 = 0. Proof Ring.sum_0_neg ring. Theorem sum_neg_0 : forall x : E, - x = 0 -> x = 0. Proof Ring.sum_neg_0 ring. Theorem sum_neg_0_uniq : unique (fun x => - x = 0) 0. Proof Ring.sum_neg_0_uniq ring. Theorem prod_id : prod_is_id 1. Proof Ring.prod_id ring. Theorem prod_id_l_uniq : forall x : E, (Monoid.is_id_l E {#} x) -> x = 1. Proof Ring.prod_id_l_uniq ring. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E {#} x) -> x = 1. Proof Ring.prod_id_r_uniq ring. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E {#} x) -> x = 1. Proof Ring.prod_id_uniq ring. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. 
finite  ∧ finite 𝜆. Proof with eauto. intros  Hcdk 𝜆 Hcdl Hfin. apply cardLt_aleph0_iff_finite in Hfin... split. - apply cardLt_aleph0_iff_finite... eapply cardLe_lt_trans... rewrite <- cardAdd_0_r at 1... apply cardAdd_preserve_le'. apply cardLe_0... - apply cardLt_aleph0_iff_finite... eapply cardLe_lt_trans... rewrite <- cardAdd_0_r at 1... rewrite cardAdd_comm. apply cardAdd_preserve_le. apply cardLe_0... Qed. Theorem cardAdd_finite_iff : ∀  𝜆 ⋵ 𝐂𝐃, finite  ∧ finite 𝜆 ↔ finite ( + 𝜆). Proof with auto. intros  Hcdk 𝜆 Hcdl. split. - intros [Hfink Hfinl]. apply cardAdd_finite; split... - apply finite_cardAdd... Qed. Corollary infinite_cardAdd : ∀  𝜆 ⋵ 𝐂𝐃, infinite ( + 𝜆) → infinite  ∨ infinite 𝜆. Proof. intros  Hcdk 𝜆 Hcdl Hinf. apply not_and_or. intros [Hfink Hfinl]. apply Hinf. apply cardAdd_finite; split; auto. Qed. Corollary cardAdd_infinite : ∀ ⋵ 𝐂𝐃ⁱⁿ , ∀𝜆 ⋵ 𝐂𝐃, infinite ( + 𝜆). Proof. intros  [Hcdk Hinf] 𝜆 Hcdl Hfin. apply Hinf. apply (finite_cardAdd  Hcdk 𝜆); auto. Qed.Corollary cardAdd_infinite' : ∀ ⋵ 𝐂𝐃ⁱⁿ , ∀𝜆 ⋵ 𝐂𝐃, infinite (𝜆 +  ). Proof with auto. intros  [Hcdk Hinf] 𝜆 Hcdl Hfin. apply Hinf. apply (finite_cardAdd 𝜆 Hcdl  ); auto. Qed. Corollary cardAdd_infinite_iff : ∀  𝜆 ⋵ 𝐂𝐃, infinite  ∨ infinite 𝜆 ↔ infinite ( + 𝜆). Proof. intros  Hcdk 𝜆 Hcdl. unfold infinite. rewrite <- (cardAdd_finite_iff  Hcdk 𝜆 Hcdl); tauto. Qed. Lemma cardMul_finite : ∀  𝜆 ⋵ 𝐂𝐃 ⁱⁿ,   𝜆 ⋵ 𝐂𝐃 ⁱⁿ. Proof with auto. intros  Hk 𝜆 Hl. apply nat_iff_fincard in Hk. apply nat_iff_fincard in Hl. apply nat_iff_fincard. rewrite fin_cardMul_eq_mul... apply mul_ran... Qed. Lemma finite_cardMul_l : ∀  𝜆 ⋵ 𝐂𝐃, 𝜆  0 → finite (  𝜆) → finite  . Proof with eauto. intros  Hcdk 𝜆 Hcdl Hnel Hfin. apply cardLt_aleph0_iff_finite in Hfin... apply cardLt_aleph0_iff_finite... eapply cardLe_lt_trans... rewrite <- cardMul_1_r at 1... apply cardMul_preserve_le'. apply cardLe_1... Qed. Lemma finite_cardMul_r : ∀  𝜆 ⋵ 𝐂𝐃,   0 → finite (  𝜆) → finite 𝜆. Proof with eauto. intros  Hcdk 𝜆 Hcdl Hnek Hfin. rewrite cardMul_comm in Hfin. apply (finite_cardMul_l 𝜆 Hcdl  )... Qed. Lemma finite_cardMul : ∀  𝜆 ⋵ 𝐂𝐃,   0 → 𝜆  0 → finite (  𝜆) → finite  ∧ finite 𝜆. Proof with auto. intros  Hcdk 𝜆 Hcdl Hnek Hnel Hfin. split. apply (finite_cardMul_l  Hcdk 𝜆)... apply (finite_cardMul_r  Hcdk 𝜆)... Qed. Theorem cardMul_finite_iff : ∀  𝜆 ⋵ 𝐂𝐃,   0 → 𝜆  0 → finite  ∧ finite 𝜆 ↔ finite (  𝜆). 
False -∗ WP Panic msg @ s; E {{ Φ }}. Proof. iIntros ">[] HΦ". Qed.Lemma wp_ArbitraryInt stk E : {{{ True }}} ArbitraryInt @ stk; E {{{ (x:u64), RET #x; True }}}. Proof. iIntros (Φ) "Htr HΦ". iApply wp_lift_atomic_head_step; [done|]. iIntros (σ1 g1 ns mj D κ κs n) "(Hσ&?&?&?) Hg !>"; iSplit; first by eauto. iNext; iIntros (v2 σ2 g2 efs Hstep); inv_head_step; iFrame. iMod (global_state_interp_le _ _ _ _ _ κs with "[$]") as "$". { rewrite /step_count_next/=. lia. } iModIntro. by iApply "HΦ". Qed.Lemma wp_output s E tr lit : {{{ trace_frag tr }}} Output (LitV lit) @ s; E {{{ RET (LitV LitUnit); trace_frag (add_event (Out_ev lit) tr)}}}. Proof. iIntros (Φ) "Htr HΦ". iApply wp_lift_atomic_head_step; [done|]. iIntros (σ1 g1 ns mj D κ κs n) "(Hσ&?&Htr_auth&?) Hg !>"; iSplit; first by eauto. iNext; iIntros (v2 σ2 g2 efs Hstep); inv_head_step. iFrame. iDestruct (trace_agree with "[$] [$]") as %?; subst. iMod (trace_update with "[$] [$]") as "(?&?)". iMod (global_state_interp_le _ _ _ _ _ κs with "[$]") as "$". { rewrite /step_count_next/=. lia. } iModIntro. iFrame; iSplitL; last done. by iApply "HΦ". Qed.Lemma wp_input s E tr (sel: u64) Or : {{{ trace_frag tr ∗ oracle_frag Or }}} Input (LitV (LitInt sel)) @ s; E {{{ RET (LitV (LitInt (Or tr sel))); trace_frag (add_event (In_ev sel (LitInt (Or tr sel))) tr) ∗ oracle_frag Or}}}. Proof. iIntros (Φ) "(Htr&Hor) HΦ". iApply wp_lift_atomic_head_step; [done|]. iIntros (σ1 g1 ns mj D κ κs n) "(Hσ&?&Htr_auth&Hor_auth) Hg !>"; iSplit. { iPureIntro. unshelve (by eauto); apply (U64 0). } iNext; iIntros (v2 σ2 g2 efs Hstep); inv_head_step. iDestruct (trace_agree with "[$] [$]") as %?; subst. iDestruct (oracle_agree with "[$] [$]") as %?; subst. iFrame. iMod (trace_update with "[$] [$]") as "(?&?)". iMod (global_state_interp_le _ _ _ _ _ κs with "[$]") as "$". { rewrite /step_count_next/=. lia. } iModIntro. iFrame; iSplitL; last done. iApply ("HΦ" with "[$]"). Qed. Lemma wp_fork s E e Φ : ▷ WP e @ s; ⊤ {{ _, True }} -∗ ▷ Φ (LitV LitUnit) -∗ WP Fork e @ s; E {{ Φ }}. Proof. iIntros "He HΦ". iApply wp_lift_atomic_head_step; [done|]. iIntros (σ1 g1 mj D ns κ κs n) "Hσ Hg !>"; iSplit; first by eauto. iNext; iIntros (v2 σ2 g2 efs Hstep); inv_head_step. iFrame. iMod (global_state_interp_le _ _ _ _ _ κs with "[$]") as "$". { rewrite /step_count_next/=. lia. } done. Qed. Theorem concat_replicate_S A n (vs: list A) : concat_replicate (S n) vs = vs ++ concat_replicate n vs. 
+ off * n) w') (combine v (split2 (idx * n + n) (off * n) w''))) _ H. Proof. intros. assert ((idx + 1 + off) * n = idx * n + n + off * n) as Hc by lia. erewrite eq_rect_combine_dist3 with (w := w). erewrite word_updN_shift_l_gt_0. erewrite wand_wnot_word_mask_w. unfold wlshift, zext. eq_rect_simpl. rewrite split1_combine. rewrite eq_rect_combine_assoc'. rewrite split2_combine. unfold wor. rewrite eq_rect_bitwp_1. f_equal. replace (eq_rect ((idx + 1 + off) *n) word (split1 _ (idx * n) _) _ _) with (combine (wzero (idx * n)) (combine v (wzero (off * n)))). - repeat rewrite <- combine_bitwp. repeat rewrite wor_wzero. repeat try (rewrite wor_comm, wor_wzero). reflexivity. - erewrite split1_eq_rect_eq1. repeat (eq_rect_simpl; erewrite split1_eq_rect_combine_partial; f_equal). erewrite wzero_dist, wzero_rev, <- combine_wzero. eq_rect_simpl. symmetry; apply split1_combine. Grab Existential Variables. all : lia. Qed. Fact word_updN_abs_helper : forall idx off, idx < idx + 1 + off. Proof. intros. omega. Qed. Theorem word_updN_abs : forall idx off ft w v, let H := word_shift_helper3 idx off (len ft) in let H1 := word_shift_helper4 idx off (len ft) in let w' := eq_rec _ word w _ (eq_sym H) in let w'' := eq_rec _ word w _ H1 in @word_updN ft (idx + 1 + off) idx w v = eq_rec _ word ( combine (split1 (idx * len ft) (len ft + off * len ft) w') (combine v (split2 (idx * len ft + len ft) (off * len ft) w''))) _ H. Proof. unfold word_updN; simpl. intros. destruct lt_dec; try omega. repeat eexists. eq_rect_simpl; apply eq_rect_both. rewrite eq_rect_word_offset; eq_rect_simpl. rewrite eq_rect_combine; f_equal. + erewrite eq_rect_split1_eq2. eq_rect_simpl; f_equal. apply eq_rect_both. eq_rect_simpl; reflexivity. + apply eq_rect_both. rewrite eq_rect_combine. rewrite eq_rect_split2. eq_rect_simpl. repeat (try reflexivity; f_equal; eq_rect_simpl; try apply eq_rect_both). Grab Existential Variables. all : simpl; lia. Qed. Theorem word_updN_shift_equiv : forall l idx ft w v, idx < l -> @word_updN_shift l (len ft) idx w v = @word_updN ft l idx w v. Proof. intros l idx ft w v H. remember (l - idx - 1) as off. assert (l = idx + 1 + off) by omega. subst l. erewrite word_updN_shift_abs by auto. erewrite word_updN_abs. repeat f_equal. Qed. Definition word_updN' {ft : type} {l : nat} (idx : nat) (w : word (len (ArrayF ft l))) (v : word (len ft)) : word (len (ArrayF ft l)) := @word_updN_shift l (len ft) idx w v. Theorem word_updN'_equiv : forall ft l idx w v, idx < l -> @word_updN' ft l idx w (to_word v) = @to_word (ArrayF ft l) (updN (of_word w) idx v). 
subst; auto. destruct (list_assoc x l); auto. intros [ ? | ]; subst; tauto. Qed. Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }. Proof. intros H. generalize (list_assoc_In x l). destruct (list_assoc x l) as [ y | ]. exists y; auto. tauto. Qed. Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None. Proof. intros H. generalize (list_assoc_In x l). destruct (list_assoc x l) as [ y | ]; auto. intros H1; contradict H. apply in_map_iff. exists (x,y); simpl; auto. Qed. Fact list_assoc_app x ll mm : list_assoc x (ll++mm) = match list_assoc x ll with | None => list_assoc x mm | Some y => Some y end. Proof. induction ll as [ | (x',?) ]; simpl; auto. destruct (eq_X_dec x x'); auto. Qed.End list_assoc.Section list_first_dec. Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }). Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } } + { forall x, In x ll -> ~ P x }. Proof using Pdec. induction ll as [ | a ll IH ]; [ | destruct (Pdec a) as [ Ha | Ha ]; [ | destruct IH as [ (l & x & r & H1 & H2 & H3) | H ]] ]. * right; intros _ []. * left; exists nil, a, ll; repeat split; auto. * left; exists (a::l), x, r; repeat split; subst; auto. intros ? [ | ]; subst; auto. * right; intros ? [ | ]; subst; auto. Qed. Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }. Proof using Pdec. intros H1 H2. destruct (list_choose_dec ll) as [ H | H ]; trivial. destruct (H _ H2 H1). Qed. End list_first_dec.Section list_dec. Variable (X : Type) (P Q : X -> Prop) (H : forall x, { P x } + { Q x }). Theorem list_dec l : { x | In x l /\ P x } + { forall x, In x l -> Q x }. 
x). Proof. intros x Zx Fx. destruct (ln_beta beta x) as (ex, Ex). specialize (Ex (Rgt_not_eq _ _ Zx)). assert (Ex' := Ex). rewrite Rabs_pos_eq in Ex'. destruct (id_p_ulp_le_bpow x ex) ; try easy. unfold generic_format, scaled_mantissa, canonic_exp. rewrite ln_beta_unique with beta (x + ulp x)%R ex. pattern x at 1 3 ; rewrite Fx. rewrite ulp_neq_0. unfold scaled_mantissa. rewrite canonic_exp_fexp with (1 := Ex). unfold F2R. simpl. rewrite Rmult_plus_distr_r. rewrite Rmult_assoc. rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r. change (bpow 0) with (Z2R 1). rewrite <- Z2R_plus. rewrite Ztrunc_Z2R. rewrite Z2R_plus. rewrite Rmult_plus_distr_r. now rewrite Rmult_1_l. now apply Rgt_not_eq. rewrite Rabs_pos_eq. split. apply Rle_trans with (1 := proj1 Ex'). pattern x at 1 ; rewrite <- Rplus_0_r. apply Rplus_le_compat_l. apply ulp_ge_0. exact H. apply Rplus_le_le_0_compat. now apply Rlt_le. apply ulp_ge_0. rewrite H. apply generic_format_bpow. apply valid_exp. destruct (Zle_or_lt ex (fexp ex)) ; trivial. elim Rlt_not_le with (1 := Zx). rewrite Fx. replace (Ztrunc (scaled_mantissa beta fexp x)) with Z0. rewrite F2R_0. apply Rle_refl. unfold scaled_mantissa. rewrite canonic_exp_fexp with (1 := Ex). destruct (mantissa_small_pos beta fexp x ex) ; trivial. rewrite Ztrunc_floor. apply sym_eq. apply Zfloor_imp. split. now apply Rlt_le. exact H2. now apply Rlt_le. now apply Rlt_le. Qed.Theorem generic_format_pred_pos : forall x, F x -> (0 < x)%R -> F (pred_pos x). Proof. intros x Fx Zx. unfold pred_pos; case Req_bool_spec; intros H. now apply generic_format_pred_aux2. now apply generic_format_pred_aux1. Qed. Theorem generic_format_succ : forall x, F x -> F (succ x). Proof. intros x Fx. unfold succ; case Rle_bool_spec; intros Zx. destruct Zx as [Zx|Zx]. now apply generic_format_succ_aux1. rewrite <- Zx, Rplus_0_l. apply generic_format_ulp_0. apply generic_format_opp. apply generic_format_pred_pos. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem generic_format_pred : forall x, F x -> F (pred x). Proof. intros x Fx. unfold pred. apply generic_format_opp. apply generic_format_succ. now apply generic_format_opp. Qed.Theorem pred_pos_lt_id : forall x, (x <> 0)%R -> (pred_pos x < x)%R. Proof. intros x Zx. unfold pred_pos. case Req_bool_spec; intros H.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. rewrite ulp_neq_0; trivial. apply bpow_gt_0. Qed.Theorem succ_gt_id : forall x, (x <> 0)%R -> (x < succ x)%R. Proof. intros x Zx; unfold succ. case Rle_bool_spec; intros Hx. pattern x at 1; rewrite <- (Rplus_0_r x). apply Rplus_lt_compat_l. rewrite ulp_neq_0; trivial. apply bpow_gt_0. pattern x at 1; rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar. apply pred_pos_lt_id. now auto with real. Qed. Theorem pred_lt_id : forall x, (x <> 0)%R -> (pred x < x)%R. 
p, Mem.range_perm m b ofs ofs' Cur p -> Mem.range_perm m' b ofs ofs' Cur p) <-> (forall b ofs chunk p, Mem.valid_access m chunk b ofs p -> Mem.valid_access m' chunk b ofs p). Proof. split. - intros. inv H0. apply H in H1. constructor; auto. - intros. intro. intros. specialize (H b ofs0 Mint8unsigned p). apply H0 in H1. assert ( Mem.valid_access m Mint8unsigned b ofs0 p). constructor. simpl. intro. intro. assert (ofs0 = ofs1)%Z by omega. subst; auto. simpl. apply Z.divide_1_l. apply H in H2. inv H2. simpl in H3. eapply H3. omega. Qed. Theorem correct_tinfo_valid_access: forall p z lenv m, correct_tinfo p z lenv m -> forall m', (forall b ofs ofs' p, Mem.range_perm m b ofs ofs' Cur p -> Mem.range_perm m' b ofs ofs' Cur p) -> correct_tinfo p z lenv m'. Proof. intros. unfold correct_tinfo in H. destruct H as [alloc_b [alloc_ofs [limit_ofs [args_b [args_ofs [tinf_b [tinf_ofs [Hget_alloc [Hdiv_alloc [Hrange_alloc [Hget_limit [Hbound_limit [Hget_args [Hdj_args [Hbound_args [Hrange_args [Hget_tinf [Htinfne1 [Htinfne2 [Hinf_limit [Hloc_args Hglobal ]]]]]]]]]]]]]]]]]]]]]. do 7 eexists. repeat (split; eauto). eapply H0. eapply Hrange_args. auto. apply Hrange_args in H. inv H. auto. eapply H0. apply Hinf_limit. auto. apply Hinf_limit. auto. inv Hloc_args. inv H. constructor; auto. inv H1. apply Hglobal in H. destructAll; auto. apply Hglobal in H; destructAll; auto. apply Hglobal in H; destructAll; auto. erewrite mem_range_valid in H0. apply Hglobal in H. destructAll. exists x0. apply H0. auto. Qed.Corollary correct_tinfo_after_store: forall p z lenv m, correct_tinfo p z lenv m -> forall m' chunk b ofs v, Mem.store chunk m b ofs v = Some m' -> correct_tinfo p z lenv m'. Proof. intros. eapply correct_tinfo_valid_access. apply H. eapply mem_range_valid. intros. eapply Mem.store_valid_access_1 in H0; eauto. Qed. Corollary valid_access_after_nstore: forall vs m m' i b' ofs', forall chunk b ofs p, Mem.valid_access m chunk b ofs p -> mem_after_n_proj_store b' ofs' vs i m m' -> Mem.valid_access m' chunk b ofs p. Proof. induction vs; intros. - inv H0. - inv H0. + eapply Mem.store_valid_access_1; eauto. + eapply IHvs. 2: apply H9. eapply Mem.store_valid_access_1; eauto. Qed. Corollary correct_tinfo_after_nstore: forall p vs z lenv m m' b ofs i, correct_tinfo p z lenv m -> mem_after_n_proj_store b ofs vs i m m' -> correct_tinfo p z lenv m'. Proof. induction vs; intros. - inv H0. - inv H0. + eapply correct_tinfo_after_store; eauto. + eapply IHvs. 2:{ apply H9. } eapply correct_tinfo_after_store; eauto. Qed. Theorem var_names_app: forall l1 l2, (var_names (l1 ++ l2)) = (var_names l1 ++ var_names l2). 
Proof Group.op_id_l_uniq op_group. Theorem op_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Group.op_id_r_uniq op_group. Theorem op_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Group.op_id_uniq op_group. Theorem op_inv_l_r_eq : forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z. Proof Group.op_inv_l_r_eq op_group. Theorem op_inv_sym : forall x y : E, op_is_inv x y <-> op_is_inv y x. Proof Group.op_inv_sym op_group. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. Proof Group.op_inv_ex op_group. Theorem op_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). 
Require Export Relations.Require Export List.Module Type DEC_ORDER. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom ordered : order A le. Axiom lt_le_weak : forall a b:A, lt a b -> le a b. Axiom lt_diff : forall a b:A, lt a b -> a <> b. Axiom le_lt_or_eq : forall a b:A, le a b -> lt a b \/ a = b. Parameter lt_eq_lt_dec : forall a b:A, {lt a b} + {a = b} + {lt b a}. End DEC_ORDER.Module Type MORE_DEC_ORDERS. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom le_trans : transitive A le. Axiom le_refl : reflexive A le. Axiom le_antisym : antisymmetric A le. Axiom lt_irreflexive : forall a:A, ~ lt a a. Axiom lt_trans : transitive A lt. Axiom lt_not_le : forall a b:A, lt a b -> ~ le b a. Axiom le_not_lt : forall a b:A, le a b -> ~ lt b a. Axiom lt_intro : forall a b:A, le a b -> a <> b -> lt a b. Parameter le_lt_dec : forall a b:A, {le a b} + {lt b a}. Parameter le_lt_eq_dec : forall a b:A, le a b -> {lt a b} + {a = b}. End MORE_DEC_ORDERS. Module More_Dec_Orders (D: DEC_ORDER) : MORE_DEC_ORDERS with Definition A := D.A with Definition le := D.le with Definition lt := D.lt. Definition A := D.A. Definition le := D.le. Definition lt := D.lt. Theorem le_trans : transitive A le. Proof. case D.ordered; auto. Qed. Theorem le_refl : reflexive A le. Proof. case D.ordered; auto. Qed. Theorem le_antisym : antisymmetric A le. 
H0... * subst. apply (ord_irrefl (μ α))... rewrite H at 2... - apply ord_le_iff_sub... intros x Hx. assert (Hox: x ⋵ 𝐎𝐍). apply (ord_is_ords (μ α)⁺)... apply ord_le_iff_lt_suc in Hx as []... + eapply ord_trans... apply μ_normal... + subst. apply μ_normal... Qed.Theorem μ_suc : ξ  1 → ∀α ⋵ 𝐎𝐍, α  0 → μ α⁺ = μ α + μ 1. Proof with neauto. intros Hξ1 α Hα Hα0. ord_ext... - apply μ_spec... + split... rewrite ordMul_distr, mu, mu... + intros H. apply ReplAx in H as [x [Hx H]]. assert (Hox: x ⋵ 𝐎𝐍). apply (ord_is_ords α⁺)... apply ord_le_iff_lt_suc in Hx as []... * apply μ_normal in H0... rewrite H in H0. apply ord_le_iff_not_gt in H0... left. apply ordAdd_enlarge_r... * subst. apply (ord_irrefl (μ α))... rewrite H at 2... apply ordAdd_enlarge_r... - apply ord_le_iff_sub... intros x Hx. rewrite ordAdd_limit, μ_1 in Hx... apply FUnionE in Hx as [β [Hβ Hx]]. apply FUnionE in Hβ as [n [Hn Hβ]]. eapply ord_trans... eapply ord_trans. auto. apply ordAdd_preserve_lt; revgoals... eapply (ord_is_ords (ξ ^ n))... clear Hβ Hx x. ω_induction n. + rewrite ordExp_0_r, ordAdd_1_r... apply sucord_in_limord... apply μ_normal... + rewrite ordExp_suc, <- mu, <- (mu α⁺)... rewrite <- ordMul_arbitrary_assoc, <- ordMul_distr... apply ordMul_preserve_lt... Qed.Theorem μ_normal_form_trivial : ξ = 1 → ∀α ⋵ 𝐎𝐍, μ α = α. Proof with eauto. intros Hξ1. ord_induction. intros α Hα IH. ord_destruct α. - subst. rewrite μ_0... - destruct Hsuc as [β [Hβ H]]. subst. rewrite μ_suc_trivial... f_equal... - rewrite μ_limit... ext. + apply FUnionE in H as [β [Hβ H]]. eapply ord_trans... rewrite IH... + eapply FUnionI. apply sucord_in_limord... rewrite IH... apply sucord_in_limord... Qed.Theorem μ_normal_form : ξ  1 → ∀α ⋵ 𝐎𝐍, α  0 → μ α = ξ ^ ω  α. Proof with eauto. intros Hξ1. ord_induction. intros α Hα IH Hα0. ord_destruct α. - subst. rewrite μ_0, ordMul_0_r... - destruct Hsuc as [β [Hβ H]]. subst. destruct (classic (β = 0)). + subst. replace 0⁺ with (Embed 1)... rewrite μ_1, ordMul_1_r, μ₁_normal_form... + rewrite μ_suc, ordMul_suc, μ_1, μ₁_normal_form, IH... - rewrite μ_limit, ordMul_limit... ext. + apply FUnionE in H as [β [Hβ H]]. destruct (classic (β = 0)). * subst. rewrite μ_0 in H. exfalso0. * eapply FUnionI... rewrite <- IH... + apply FUnionE in H as [β [Hβ H]]. destruct (classic (β = 0)). * subst. rewrite ordMul_0_r in H... exfalso0. * eapply FUnionI... rewrite IH... Qed. Theorem μ_for_all_smaller_mul : ξ  1 → ∀α ⋵ 𝐎𝐍, ∀β ∈ μ 1, β  0 → β  μ α = μ α. 
-> A -> B) (m: t A) (v: B) : B := match m with Empty => v | Nodes m' => fold1' f m' v end. Lemma fold1'_xelements': forall A B (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1' f m v) = List.fold_left (fun a p => f a (snd p)) (xelements' m i l) v. Proof. induction m; simpl; intros; auto. rewrite <- IHm1. rewrite <- IHm2. auto. rewrite <- IHm. auto. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall A B (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. destruct m as [|m]. reflexivity. apply fold1'_xelements' with (l := @nil (positive * A)). Qed. Arguments empty A : simpl never. Arguments get {A} p m : simpl never. Arguments set {A} p x m : simpl never. Arguments remove {A} p m : simpl never.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. reflexivity. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gso; auto. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then x else get i m. Proof. intros. destruct (peq i j). rewrite e. apply gss. auto. apply gso. auto. Qed. Theorem gsident: forall (A: Type) (i j: positive) (m: t A), get j (set i (get i m) m) = get j m. 
using. intros. unfold handleClientRequest in *. break_match; find_inversion; subst; simpl in *; auto. unfold assoc_default. break_match; rewrite get_set_same in *; try congruence; find_inversion; auto. Qed. Theorem handleClientRequest_matchIndex : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> (maxIndex (log st') = maxIndex (log st) /\ matchIndex st' = matchIndex st) \/ matchIndex st' = assoc_set name_eq_dec (matchIndex st) h (maxIndex (log st')) /\ maxIndex (log st') = S (maxIndex (log st)). Proof using. unfold handleClientRequest. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma tryToBecomeLeader_matchIndex_preserved : forall n st out st' ms, tryToBecomeLeader n st = (out, st', ms) -> matchIndex_preserved st st'. Proof using. unfold tryToBecomeLeader. intros. find_inversion. simpl; intros; auto; congruence. Qed. Lemma handleRequestVote_matchIndex_preserved : forall n st t c li lt st' ms, handleRequestVote n st t c li lt = (st', ms) -> matchIndex_preserved st st'. Proof using. unfold handleRequestVote, advanceCurrentTerm. intros. repeat (break_match; try discriminate; repeat (find_inversion; simpl in *)); auto. Qed. Lemma doGenericServer_matchIndex_preserved : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> matchIndex_preserved st st'. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleRequestVoteReply_matchIndex : forall n st src t v, type (handleRequestVoteReply n st src t v) = Leader -> (type st = Leader /\ matchIndex (handleRequestVoteReply n st src t v) = matchIndex st) \/ (assoc_default name_eq_dec (matchIndex (handleRequestVoteReply n st src t v)) n 0 = maxIndex (log (handleRequestVoteReply n st src t v))). Proof using. unfold handleRequestVoteReply. intros. repeat break_match; simpl; auto using advanceCurrentTerm_matchIndex_preserved; simpl in *; try congruence. unfold assoc_default. simpl. repeat break_match; simpl in *; try congruence; find_inversion; auto. Qed. Lemma doLeader_matchIndex_preserved : forall st h os st' ms, doLeader st h = (os, st', ms) -> matchIndex_preserved st st'. Proof using. intros. unfold doLeader in *. simpl; intros. repeat break_match; find_inversion; auto; congruence. Qed. Lemma doLeader_lastApplied : forall st h os st' ms, doLeader st h = (os, st', ms) -> lastApplied st' = lastApplied st. Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; auto. Qed. Lemma handleRequestVote_no_append_entries : forall st h h' t lli llt st' m, handleRequestVote h st t h' lli llt = (st', m) -> ~ is_append_entries m. Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; find_inversion; subst; auto; intuition; break_exists; congruence. Qed. Theorem handleClientRequest_no_append_entries : forall h st client id c out st' ps m, handleClientRequest h st client id c = (out, st', ps) -> In m ps -> ~ is_append_entries (snd m). 
Require Import Iron.Language.SimpleData.TyJudge. Require Import Iron.Language.SimpleData.ExpSubst. Require Export Iron.Language.SimpleData.Exp.Theorem subst_exp_exp_ix : forall ix ds te x1 x2 t1 t2 , get ix te = Some t2 -> TYPE ds te x1 t1 -> TYPE ds (delete ix te) x2 t2 -> TYPE ds (delete ix te) (substX ix x2 x1) t1. Proof. intros. gen ix ds te x2 t1 t2. induction x1 using exp_mutind with (PA := fun a1 => forall ix ds te x2 t11 t12 t2 , get ix te = Some t2 -> TYPEA ds te a1 t11 t12 -> TYPE ds (delete ix te) x2 t2 -> TYPEA ds (delete ix te) (substA ix x2 a1) t11 t12) ; intros; simpl; inverts_type; eauto. Case "XVar". fbreak_nat_compare; burn. SCase "n > ix". apply TYVar. destruct n; burn. norm. down. apply get_delete_below. omega. Case "XLam". apply TYLam. rewrite delete_rewind. eauto using type_tyenv_weaken1. Case "XCon". eapply TYCon; burn. norm. apply (Forall2_map_left (TYPE ds (delete ix te))). apply (Forall2_impl_in (TYPE ds te)); eauto. Case "XCase". eapply TYCase; eauto. clear IHx1. eapply Forall_map. burn. rewrite map_length; burn. norm. rename x into d. rewrite map_map. unfold Basics.compose. apply in_map_iff. have (exists a, dcOfAlt a = d /\ In a aa). shift a. rip. rewrite dcOfAlt_substA; auto. Case "AAlt". eapply TYAlt; auto. rewrite delete_app. eapply IHx1; eauto. rewrite <- delete_app. eauto using type_tyenv_weaken_append. Qed. Theorem subst_exp_exp : forall ds te x1 x2 t1 t2 , TYPE ds (te :> t2) x1 t1 -> TYPE ds te x2 t2 -> TYPE ds te (substX 0 x2 x1) t1. 
transition. Context {Σ:Type}. Inductive transition : Type -> Type := | runF {T} (f: Σ -> Σ * T) : transition T | suchThat {T} (pred: Σ -> T -> Prop) {gen:GenPred T Σ pred} : transition T | suchThatBool {T} (b: Σ -> T -> bool) {gen:GenBool T Σ b}: transition T | bind {T T'} (x: transition T') (rx: T' -> transition T) : transition T . Arguments suchThat {T} pred {gen}. Arguments suchThatBool {T} b {gen}. Definition ret {T} (v:T): transition T := runF (fun s => (s, v)). Definition fmap {T1 T2} (f: T1 -> T2) (r: transition T1): transition T2 := bind r (fun x => ret (f x)). Definition r_mbind : MBind transition := fun {A B} rx r => bind r rx. Definition r_mret : MRet transition := @ret. Definition r_fmap : FMap transition := @fmap. Definition reads {T} (f: Σ -> T): transition T := runF (fun s => (s, f s)). Definition modify (f: Σ -> Σ): transition unit := runF (fun s => (f s, tt)). Definition any T {gen:GenType T Σ}: transition T := suchThat (fun _ _ => True). Arguments any T {gen}. Definition undefined {T}: transition T := suchThat (gen:=fun _ _ => None) (fun _ _ => False). Definition plus {T} (r1 r2: transition T): transition T := bind (any bool) (fun b => if b then r1 else r2). Definition assert (pred: Σ -> Prop): transition unit := suchThat (gen:=fun _ _ => None) (fun s _ => pred s). Definition ifThenElse P `{!Decision P} {T} (tr1 tr2: transition T): transition T := match decide P with | left _ => tr1 | right _ => tr2 end. Arguments ifThenElse P {_} {T}. Definition check P `{!Decision P}: transition unit := ifThenElse P (ret tt) (undefined). Definition checkNot P `{!Decision P}: transition unit := ifThenElse P (undefined) (ret tt). Definition when P `{!Decision P} (r: transition unit): transition unit := ifThenElse P r (ret tt). Definition unless P `{!Decision P} (r: transition unit): transition unit := ifThenElse P (ret tt) (r). Definition unwrap {T} (mx: option T): transition T := match mx with | Some x => ret x | None => undefined end. Theorem ifThenElse_if P `{!Decision P} {T} (r1 r2: transition T) : P -> ifThenElse P r1 r2 = r1. Proof. intros H. unfold ifThenElse. destruct (decide P); auto || contradiction. Qed. Theorem ifThenElse_else P `{!Decision P} {T} (r1 r2: transition T) : ~P -> ifThenElse P r1 r2 = r2. 
Theorem test (A:Prop) : A \/ A -> A. 
Require Import List Arith Bool Lia Eqdep_dec.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_sat.Import fol_notations.Set Implicit Arguments.Local Notation ø := vec_nil. Local Notation Σ2 := (Σrel 2).Definition Σn1 (n : nat) : fo_signature. Proof. exists unit unit. + exact (fun _ => n). + exact (fun _ => 1). Defined.Local Definition PSSn1 n (x y : nat) := @fol_atom (Σn1 (S (S n))) tt ((@in_fot _ (ar_syms (Σn1 (S (S n)))) tt (£x##vec_set_pos (fun _ => £y)))##ø).Section Sig2_SigSSn1_encoding. Variable n : nat. Fixpoint Σ2_ΣSSn1 (d : nat) (A : fol_form Σ2) : fol_form (Σn1 (S (S n))) := match A with | ⊥ => ⊥ | fol_atom r v => PSSn1 n (Σrel_var (vec_head v)) (Σrel_var (vec_head (vec_tail v))) | fol_bin b A B => fol_bin b (Σ2_ΣSSn1 d A) (Σ2_ΣSSn1 d B) | fol_quant fol_fa A => ∀ PSSn1 n (S d) 0 ⤑ Σ2_ΣSSn1 (S d) A | fol_quant fol_ex A => ∃ PSSn1 n (S d) 0 ⟑ Σ2_ΣSSn1 (S d) A end. Variable (X : Type) (M2 : fo_model Σ2 X). Variable (Y : Type) (MSSn1 : fo_model (Σn1 (S (S n))) Y). Let Q x1 x2 := fom_rels M2 tt (x1##x2##ø). Let f y1 y2 := fom_syms MSSn1 tt (y1##vec_set_pos (fun _ => y2)). Let P y := fom_rels MSSn1 tt (y##ø). Variable R : X -> Y -> Prop. Variable (d : nat) (φ : nat -> X) (ψ : nat -> Y) (H1 : forall x1 x2 y1 y2, R x1 y1 -> R x2 y2 -> Q x1 x2 <-> P (f y1 y2)) (H2 : forall x, exists y, R x y /\ P (f (ψ d) y)) (H3 : forall y, P (f (ψ d) y) -> exists x, R x y). Theorem Σ2_ΣSSn1_correct A : (forall x, In x (fol_vars A) -> R (φ x) (ψ x)) -> fol_sem M2 φ A <-> fol_sem MSSn1 ψ (Σ2_ΣSSn1 d A). 
y -> forall z : E, op_is_inv_r x z -> y = z. Proof Group.op_inv_l_r_eq op_group. Theorem op_inv_sym : forall x y : E, op_is_inv x y <-> op_is_inv y x. Proof Group.op_inv_sym op_group. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. Proof Group.op_inv_ex op_group. Theorem op_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof Group.op_neg_def op_group. Theorem op_neg_inj : is_injective E E op_neg. Proof Group.op_neg_inj op_group. Theorem op_cancel_neg : forall x : E, op_neg (- x) = x. Proof Group.op_cancel_neg op_group. Theorem op_neg_onto : is_onto E E op_neg. Proof Group.op_neg_onto op_group. Theorem op_neg_bijective : is_bijective E E op_neg. 
nat) : l1 !! i = None -> ⊢ ( [∗ list] k↦y1;y2 ∈ l1;l2, Φ k y1 y2 ) -∗ ⌜l2 !! i = None⌝. Proof. intros. iIntros "H". apply lookup_ge_None in H as Hlen. iDestruct (big_sepL2_length with "H") as %Hslen. rewrite Hslen in Hlen. apply lookup_ge_None in Hlen. eauto. Qed. Lemma big_sepL2_lookup_2_none Φ (l1 : list A) (l2 : list B) (i : nat) : l2 !! i = None -> ([∗ list] k↦y1;y2 ∈ l1;l2, Φ k y1 y2) -∗ ⌜l1 !! i = None⌝. Proof. iIntros (?) "H". apply lookup_ge_None in H as Hlen. iDestruct (big_sepL2_length with "H") as %Hslen. rewrite -Hslen in Hlen. apply lookup_ge_None in Hlen. eauto. Qed. Local Lemma big_sepL_exists_list_aux n Φ l : ([∗ list] i↦a ∈ l, ∃ x, Φ (n+i) a x) -∗ ∃ xs, ⌜length xs = length l⌝ ∧ ([∗ list] i ↦ a ∈ l, ∃ x, ⌜xs !! i = Some x⌝ ∧ Φ (n+i) a x). Proof. iInduction l as [|a l] "IH" forall (n). - simpl. iIntros "H". iExists []. eauto. - simpl. iIntros "[HΦ Hl]". iDestruct "HΦ" as (x) "HΦ". assert (∀ k, n + S k = S n + k) as Harith by lia. setoid_rewrite Harith. iDestruct ("IH" with "Hl") as (xs) "Hl". iDestruct "Hl" as "[%Hlen Hl]". iExists (x::xs); simpl; eauto 10 with iFrame. Qed. Lemma big_sepL_exists_list Φ l : ([∗ list] i↦a ∈ l, ∃ x, Φ i a x) -∗ ∃ xs, ⌜length xs = length l⌝ ∧ ([∗ list] i ↦ a ∈ l, ∃ x, ⌜xs !! i = Some x⌝ ∧ Φ i a x). Proof. apply (big_sepL_exists_list_aux 0 Φ). Qed. Lemma big_sepL_exists_to_sepL2 Φ l : ([∗ list] i↦a ∈ l, ∃ x, Φ i a x) -∗ ∃ xs, [∗ list] i ↦ a;x ∈ l;xs, Φ i a x. Proof. iIntros "H". iDestruct (big_sepL_exists_list with "H") as (xs Hlen) "H". iExists xs. iApply big_sepL2_to_sepL_1'; done. Qed. Lemma big_sepL2_app_equiv Φ l1 l2 l1' l2' : length l1 = length l1' → ([∗ list] k↦y1;y2 ∈ l1; l1', Φ k y1 y2) ∗ ([∗ list] k↦y1;y2 ∈ l2; l2', Φ (length l1 + k) y1 y2) ⊣⊢ ([∗ list] k↦y1;y2 ∈ l1 ++ l2; l1' ++ l2', Φ k y1 y2). Proof. intros. iSplit. - iIntros "[H1 H2]". iApply (big_sepL2_app with "H1 H2"). - iIntros "H". iDestruct (big_sepL2_app_inv with "H") as "[$ $]"; auto. Qed. Theorem big_sepL2_lookup_acc_and Φ Φc l1 l2 i x1 x2 : (∀ k y1 y2, l1 !! k = Some y1 → l2 !! k = Some y2 → Φ k y1 y2 -∗ Φc k y1 y2) → l1 !! i = Some x1 → l2 !! i = Some x2 → big_sepL2 Φ l1 l2 -∗ Φ i x1 x2 ∗ ((Φ i x1 x2 -∗ big_sepL2 Φ l1 l2) ∧ (Φc i x1 x2 -∗ big_sepL2 Φc l1 l2)). 
E_1; prod_sum_distrib_l : Ring.is_distrib_l E prod sum }. Arguments E_0 {c}.Arguments E_1 {c}.Arguments sum {c} x y.Arguments prod {c} x y.Arguments distinct_0_1 {c} _.Arguments sum_is_assoc {c} x y z.Arguments sum_is_comm {c} x y.Arguments sum_id_l {c} x.Arguments sum_inv_l_ex {c} x.Arguments prod_is_assoc {c} x y z.Arguments prod_id_l {c} x.Arguments prod_sum_distrib_l {c} x y z.Arguments prod_is_comm {c} x y.Notation "0" := E_0 : commutative_ring_scope.Notation "1" := E_1 : commutative_ring_scope.Notation "x + y" := (sum x y) (at level 50, left associativity) : commutative_ring_scope.Notation "{+}" := sum : commutative_ring_scope.Notation "x # y" := (prod x y) (at level 50, left associativity) : commutative_ring_scope.Notation "{#}" := prod : commutative_ring_scope.Open Scope commutative_ring_scope.Section Theorems. Variable r : Commutative_Ring. Let E := E r. Definition sum_is_id_l := Monoid.is_id_l E {+}. Definition sum_is_id_r := Monoid.is_id_r E {+}. Definition sum_is_id := Monoid.is_id E {+}. Definition prod_is_id_l := Monoid.is_id_l E {#}. Definition prod_is_id_r := Monoid.is_id_r E {#}. Definition prod_is_id := Monoid.is_id E {#}. Theorem prod_id_r : prod_is_id_r 1. Proof fun x : E => eq_ind_r (fun a => a = x) (prod_id_l x) (prod_is_comm x 1). Theorem prod_sum_distrib_r : Ring.is_distrib_r E {#} {+}. Proof fun x y z : E => prod_sum_distrib_l x y z || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z || a = (y # x) + (z # x) @a by <- prod_is_comm x (y + z). Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r. Definition sum_abelian_group := Ring.sum_abelian_group ring. Definition sum_group := Ring.sum_group ring. Definition sum_monoid := Ring.sum_monoid ring. Definition prod_monoid := Ring.prod_monoid ring. Theorem distinct_1_0 : E_1 (c := r) <> E_0 (c := r). Proof fun H : E_1 = E_0 => distinct_0_1 (eq_sym H). Definition nonzero : E -> Prop := Ring.nonzero ring. Theorem sum_id_r : sum_is_id_r 0. Proof Ring.sum_id_r ring. Theorem sum_id : sum_is_id 0. Proof Ring.sum_id ring. Definition sum_is_inv_l := Ring.sum_is_inv_l ring. Definition sum_is_inv_r := Ring.sum_is_inv_r ring. Definition sum_is_inv := Ring.sum_is_inv ring. Definition sum_has_inv_l := Ring.sum_has_inv_l ring. Definition sum_has_inv_r := Ring.sum_has_inv_r ring. Definition sum_has_inv := Ring.sum_has_inv ring. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Ring.sum_inv_r_ex ring. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Ring.sum_id_l_uniq ring. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. 
Unset Kernel Term Sharing.Require Export UniMath.Foundations.NaturalNumbers. Require Import UniMath.MoreFoundations.PartA. Require Export UniMath.MoreFoundations.NegativePropositions. Require Import UniMath.Algebra.Monoids. Require Import UniMath.Algebra.Groups. Require Export UniMath.Algebra.RigsAndRings. Require Export UniMath.NumberSystems.NaturalNumbersAlgebra. Definition hz : commring := commrigtocommring natcommrig . Definition hzaddabgr : abgr := hz . Definition hzmultabmonoid : abmonoid := ringmultabmonoid hz .Definition natnattohz : nat -> nat -> hz := λ n m, setquotpr _ ( make_dirprod n m ) .Definition hzplus : hz -> hz -> hz := @op1 hz. Definition hzsign : hz -> hz := grinv hzaddabgr . Definition hzminus : hz -> hz -> hz := λ x y, hzplus x ( hzsign y ) . Definition hzzero : hz := unel hzaddabgr .Definition hzmult : hz -> hz -> hz := @op2 hz . Definition hzone : hz := unel hzmultabmonoid .Declare Scope hz_scope. Bind Scope hz_scope with hz . Notation " x + y " := ( hzplus x y ) : hz_scope . Notation " 0 " := hzzero : hz_scope . Notation " 1 " := hzone : hz_scope . Notation " - x " := ( hzsign x ) : hz_scope . Notation " x - y " := ( hzminus x y ) : hz_scope . Notation " x * y " := ( hzmult x y ) : hz_scope .Delimit Scope hz_scope with hz . Theorem isdeceqhz : isdeceq hz . 
From Undecidability.Synthetic Require Import Definitions DecidabilityFacts EnumerabilityFacts ReducibilityFacts MoreReducibilityFacts. From Undecidability.FOL Require Import FOL Util.Kripke Util.Deduction Util.Syntax Util.Tarski PCPb_to_FOL.From Undecidability.PCP Require Import PCP Reductions.PCPb_iff_dPCPb.Local Hint Constructors BPCP : core.Section kvalidity. Local Definition BSRS := list (card bool). Variable R : BSRS. Context {ff : falsity_flag}. Theorem BPCP_kprv : PCPb R <-> nil ⊢I (F R). 
Require Export ZFC.Lib.Relation. Definition is_nat := λ n, ∀ A, inductive A → n ∈ A.Theorem ω_exists : ∃ ω, ∀ n, n ∈ ω ↔ is_nat n. Proof with auto. exists {n ∊ 𝐈 | is_nat n}. split. - intros Hn A HA. apply SepE in Hn as [_ H]. apply H in HA... - intros Hn. apply SepI. apply Hn. apply InfAx. intros A HA. apply Hn in HA... Qed.Definition ω := {n ∊ 𝐈 | is_nat n}.Lemma ω_has_0 :  ∈ ω. Proof with auto. apply SepI... apply InfAx. intros x []... Qed.Lemma ω_neq_0 : ω   . Proof. intros H. assert ( ∈ ω). apply ω_has_0. rewrite H in H0. exfalso0. Qed. Theorem ω_inductive : inductive ω. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.SpecLemmas. Require Import VerdiRaft.RefinementSpecLemmas.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.VotesLeCurrentTermInterface.Set Bullet Behavior "Strict Subproofs".Section VotesLeCurrentTerm. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Ltac start_proof := cbn [nwState]; intros; subst; repeat find_higher_order_rewrite; update_destruct; rewrite_update; cbn [fst snd] in *; eauto. Lemma votes_le_current_term_client_request : refined_raft_net_invariant_client_request votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_client_request, votes_le_currentTerm. start_proof. erewrite handleClientRequest_currentTerm by eauto. rewrite @votes_update_elections_data_client_request in *. eauto. Qed. Lemma votes_le_current_term_timeout : refined_raft_net_invariant_timeout votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_timeout, votes_le_currentTerm. start_proof. find_copy_eapply_lem_hyp votes_update_elections_data_timeout; eauto. break_or_hyp; auto with *. find_apply_lem_hyp handleTimeout_currentTerm. find_apply_hyp_hyp. eauto using le_trans. Qed. Lemma votes_le_current_term_append_entries : refined_raft_net_invariant_append_entries votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_append_entries, votes_le_currentTerm. start_proof. rewrite @votes_same_append_entries in *. find_apply_lem_hyp handleAppendEntries_currentTerm. find_apply_hyp_hyp. eauto using le_trans. Qed. Lemma votes_le_current_term_append_entries_reply : refined_raft_net_invariant_append_entries_reply votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_append_entries_reply, votes_le_currentTerm. start_proof. find_apply_lem_hyp handleAppendEntriesReply_currentTerm. find_apply_hyp_hyp. eauto using le_trans. Qed. Lemma votes_le_current_term_request_vote : refined_raft_net_invariant_request_vote votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_request_vote, votes_le_currentTerm. start_proof. find_eapply_lem_hyp votes_update_elections_data_request_vote; eauto. intuition. find_apply_hyp_hyp. eauto using le_trans, handleRequestVote_currentTerm. Qed. Lemma votes_le_current_term_request_vote_reply : refined_raft_net_invariant_request_vote_reply votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_request_vote_reply, votes_le_currentTerm. start_proof. find_eapply_lem_hyp votes_update_elections_data_request_vote_reply; eauto. eapply le_trans; [|eapply handleRequestVoteReply_currentTerm'; eauto]; eauto. Qed. Lemma votes_le_current_term_do_leader : refined_raft_net_invariant_do_leader votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_do_leader, votes_le_currentTerm. start_proof. assert (gd = (fst (nwState net h)) /\ d = snd (nwState net h)) by (repeat find_rewrite; auto). break_and. subst. erewrite doLeader_currentTerm by eauto. eauto. Qed. Lemma votes_le_current_term_do_generic_server : refined_raft_net_invariant_do_generic_server votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_do_generic_server, votes_le_currentTerm. start_proof. assert (gd = (fst (nwState net h)) /\ d = snd (nwState net h)) by (repeat find_rewrite; auto). break_and. subst. erewrite doGenericServer_currentTerm by eauto. eauto. Qed. Lemma votes_le_current_term_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_state_same_packet_subset, votes_le_currentTerm. intros. repeat find_reverse_higher_order_rewrite. eauto. Qed. Lemma votes_le_current_term_reboot : refined_raft_net_invariant_reboot votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_reboot, votes_le_currentTerm. start_proof. unfold reboot. simpl. assert (gd = (fst (nwState net h)) /\ d = snd (nwState net h)) by (repeat find_rewrite; auto). break_and. subst. eauto. Qed. Theorem votes_le_current_term_init : refined_raft_net_invariant_init votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_init, votes_le_currentTerm. simpl. intuition. Qed. Theorem votes_le_current_term_invariant : forall net, refined_raft_intermediate_reachable net -> votes_le_currentTerm net. 
eapply in_flatten. econstructor. split. eapply in_map_iff. econstructor. split. eauto. eapply filter_In. split. eapply in_getUnique. eapply in_flatten. econstructor. split. eapply in_map_iff. econstructor. split. eapply eq_refl. eapply in_getAllBvectors. simpl. left. eapply eq_refl. 2:{ rewrite bvToNat_natToBv_inverse. simpl. left. eapply eq_refl. eapply lognat_monotonic. eapply modNat_lt. } rewrite bvToNat_natToBv_inverse. unfold ltNatBool. destruct (lt_dec (modNat k order) order); trivial. exfalso. eapply n. eapply modNat_lt. eapply lognat_monotonic. eapply modNat_lt. apply g_generator. Qed. Theorem RndGrpElem_uniform : forall x y, evalDist RndGrpElem x == evalDist RndGrpElem y. intuition. unfold RndGrpElem. eapply (evalDist_iso (fun z => (modNat (z + (modNatAddInverse (groupLog g y) order) + (groupLog g x))) order) (fun z => (modNat (z + (groupLog g y) + (modNatAddInverse (groupLog g x) order)) order))); intuition. rewrite <- plus_assoc. rewrite <- modNat_plus. assert ((x0 + groupLog g y + modNatAddInverse (groupLog g x) order + (modNatAddInverse (groupLog g y) order + groupLog g x)) = ((groupLog g y + modNatAddInverse (groupLog g y) order) + (groupLog g x + modNatAddInverse (groupLog g x) order + x0)))%nat. omega. rewrite H0. rewrite modNat_plus. rewrite modNatAddInverse_correct. rewrite plus_0_l. rewrite modNat_plus. rewrite modNatAddInverse_correct. rewrite plus_0_l. eapply modNat_eq. eapply RndNat_support_lt. trivial. rewrite <- plus_assoc. rewrite <- modNat_plus. assert ((x0 + modNatAddInverse (groupLog g y) order + groupLog g x + (groupLog g y + modNatAddInverse (groupLog g x) order)) = (groupLog g x + modNatAddInverse (groupLog g x) order + (groupLog g y + modNatAddInverse (groupLog g y) order + x0)))%nat. omega. rewrite H0. rewrite modNat_plus. rewrite modNatAddInverse_correct. rewrite plus_0_l. rewrite modNat_plus. rewrite modNatAddInverse_correct. rewrite plus_0_l. eapply modNat_eq. eapply RndNat_support_lt. trivial. eapply in_getSupport_RndNat. eapply modNat_lt. eapply RndNat_uniform. eapply modNat_lt. eapply RndNat_support_lt. trivial. subst. rewrite <- groupExp_mod. simpl. destruct (EqDec_dec GroupElement_EqDec (groupExp g x0) y); subst. rewrite groupExp_mod. rewrite modNat_plus. rewrite modNatAddInverse_correct_gen. rewrite plus_0_l. rewrite <- groupExp_mod. rewrite group_cyclic. destruct (EqDec_dec GroupElement_EqDec x x). intuition. congruence. apply g_generator. apply g_generator. symmetry. eapply groupLog_correct. apply g_generator. apply g_generator. destruct (EqDec_dec GroupElement_EqDec (groupExp g (x0 + modNatAddInverse (groupLog g y) order + groupLog g x)) x); intuition. exfalso. eapply n. rewrite groupExp_plus in e. rewrite group_cyclic in e. eapply ident_l_unique in e. rewrite <- (@groupIdent _ _ _ _ _ _ _ _ FCG g) in e. eapply groupExp_eq in e. rewrite (@modNat_eq order 0) in e. eapply modNatAddInverse_sum_0 in e. rewrite groupExp_mod. rewrite e. rewrite <- groupExp_mod. rewrite group_cyclic. trivial. apply g_generator. apply g_generator. apply g_generator. eapply posnat_pos. apply g_generator. apply g_generator. apply g_generator. apply g_generator. Qed. Theorem RndGrpElem_spec : forall x y, comp_spec (fun a b => a = x <-> b = y) RndGrpElem RndGrpElem. 
y}. Fixpoint remove (x : A) (l : list A) : list A := match l with | [] => [] | y::tl => if (eq_dec x y) then remove x tl else y::(remove x tl) end. Theorem remove_In : forall (l : list A) (x : A), ~ In x (remove x l). Proof. induction l as [|x l]; auto. intro y; simpl; destruct (eq_dec y x) as [yeqx | yneqx]. apply IHl. unfold not; intro HF; simpl in HF; destruct HF; auto. apply (IHl y); assumption. Qed. Fixpoint last (l:list A) (d:A) : A := match l with | [] => d | [a] => a | a :: l => last l d end. Fixpoint removelast (l:list A) : list A := match l with | [] => [] | [a] => [] | a :: l => a :: removelast l end. Lemma app_removelast_last : forall l d, l <> [] -> l = removelast l ++ [last l d]. Proof. induction l. destruct 1; auto. intros d _. destruct l; auto. pattern (a0::l) at 1; rewrite IHl with d; auto; discriminate. Qed. Lemma exists_last : forall l, l <> [] -> { l' : (list A) & { a : A | l = l' ++ [a]}}. Proof. induction l. destruct 1; auto. intros _. destruct l. exists [], a; auto. destruct IHl as [l' (a',H)]; try discriminate. rewrite H. exists (a::l'), a'; auto. Qed. Lemma removelast_app : forall l l', l' <> [] -> removelast (l++l') = l ++ removelast l'. Proof. induction l. simpl; auto. simpl; intros. assert (l++l' <> []). destruct l. simpl; auto. simpl; discriminate. specialize (IHl l' H). destruct (l++l'); [elim H0; auto|f_equal; auto]. Qed. Fixpoint count_occ (l : list A) (x : A) : nat := match l with | [] => 0 | y :: tl => let n := count_occ tl x in if eq_dec y x then S n else n end. Theorem count_occ_In l x : In x l <-> count_occ l x > 0. Proof. induction l as [|y l]; simpl. - split; [destruct 1 | apply gt_irrefl]. - destruct eq_dec as [->|Hneq]; rewrite IHl; intuition. Qed. Theorem count_occ_not_In l x : ~ In x l <-> count_occ l x = 0. Proof. rewrite count_occ_In. unfold gt. now rewrite Nat.nlt_ge, Nat.le_0_r. Qed. Lemma count_occ_nil x : count_occ [] x = 0. Proof. reflexivity. Qed. Theorem count_occ_inv_nil l : (forall x:A, count_occ l x = 0) <-> l = []. 
Require Export ArithRing. Require Export Compare_dec. Require Export Wf_nat. Require Export Arith. Require Export Omega. Theorem minus_minus : forall a b c : nat, a - b - c = a - (b + c). intros a; elim a; auto. intros n' Hrec b; case b; auto. Qed. Remark expand_mult2 : forall x : nat, 2 * x = x + x. intros x; ring. Qed. Theorem lt_neq : forall x y : nat, x < y -> x <> y. unfold not in |- *; intros x y H H1; elim (lt_irrefl x); pattern x at 2 in |- *; rewrite H1; auto. Qed. Hint Resolve lt_neq. Theorem monotonic_inverse : forall f : nat -> nat, (forall x y : nat, x < y -> f x < f y) -> forall x y : nat, f x < f y -> x < y. intros f Hmon x y Hlt; case (le_gt_dec y x); auto. intros Hle; elim (le_lt_or_eq _ _ Hle). intros Hlt'; elim (lt_asym _ _ Hlt); apply Hmon; auto. intros Heq; elim (lt_neq _ _ Hlt); rewrite Heq; auto. Qed. Theorem mult_lt : forall a b c : nat, c <> 0 -> a < b -> a * c < b * c. intros a b c; elim c. intros H; elim H; auto. intros c'; case c'. intros; omega. intros c'' Hrec Hneq Hlt; repeat rewrite <- (fun x : nat => mult_n_Sm x (S c'')). auto with *. Qed. Remark add_sub_square_identity : forall a b : nat, (b + a - b) * (b + a - b) = (b + a) * (b + a) + b * b - 2 * ((b + a) * b). intros a b; rewrite minus_plus. repeat rewrite mult_plus_distr_r || rewrite <- (mult_comm (b + a)). replace (b * b + a * b + (b * a + a * a) + b * b) with (b * b + a * b + (b * b + a * b + a * a)); try (ring; fail). rewrite expand_mult2; repeat rewrite minus_plus; auto with *. Qed. Theorem sub_square_identity : forall a b : nat, b <= a -> (a - b) * (a - b) = a * a + b * b - 2 * (a * b). intros a b H; rewrite (le_plus_minus b a H); apply add_sub_square_identity. Qed. Theorem square_monotonic : forall x y : nat, x < y -> x * x < y * y. 
rewrite Heq //. + list_simpl. auto with list lia. Qed.End list.Ltac find_list_hyps := repeat match goal with | H: @eq (list _) ?l1 ?l2 |- _ => learn_hyp (list_eq_length l1 l2 H); pose proof (list_eq_forall l1 l2 H); clear H | H: ?l1 `prefix_of` ?l2 |- _ => let Hnew := fresh H "len" in learn_hyp (prefix_length l1 l2 H) as Hnew; pose proof (list_prefix_forall l1 l2 H); clear H end.Ltac learn_feed_as H i := feed_core H using (fun p => let P := type of p in lazymatch goal with | H: P |- _ => fail 1 | _ => pose proof p as i end).Ltac use_list_hyps := repeat match goal with | H: (forall (i:nat), _), i: nat |- _ => let Hi := fresh H i in learn_feed_as (H i) Hi; [ lia .. | ] end.Ltac start_list_eq := let i := fresh "i" in first [ apply list_eq_bounded; [ lia | intros i ? ] | apply list_eq; intros i ].Definition lt_le_dec n1 n2 : {n1 < n2} + {n2 ≤ n1}. Proof. destruct (decide (n1 < n2)); [ left | right ]; lia. Qed. Ltac split_i l i := first [ assert_succeeds ((assert (i < length l) by lia) || (assert (length l ≤ i) by lia)); fail 1 "i < length l or not already" | destruct (lt_le_dec i (length l)) ].Ltac split_app_lookups := repeat match goal with | |- context[(?l1 ++ _) !! ?i] => split_i l1 i | H: context[(?l1 ++ _) !! ?i] |- _ => split_i l1 i end.Ltac solve_list_eq := find_list_hyps; start_list_eq; repeat first [ progress list_simpl | progress use_list_hyps | progress split_app_lookups ]; auto with lia list.Ltac start_list_prefix := apply list_prefix_bounded; [ list_simpl; solve [ auto with list lia ] | let i := fresh "i" in let Hle := fresh "Hle" in intros i Hle ].Ltac solve_list_prefix := find_list_hyps; start_list_prefix; list_simpl; use_list_hyps; list_simpl; auto with lia list.Ltac solve_list_general := find_list_hyps; list_simpl; auto with lia list.Ltac list_solver := autounfold with list in *; intros; lazymatch goal with | |- @eq (list _) _ _ => solve [ solve_list_eq ] | |- _ `prefix_of` _ => solve [ solve_list_prefix ] | _ => solve [ solve_list_general ] end.Section test. Context {A: Type}. Implicit Types (l: list A). Theorem test_1 l1 l2 : length l2 ≤ length l1 → l1 `prefix_of` l2 → l1 = l2. Proof. list_solver. Qed. Theorem test_2 l1 l2 n : n ≤ length l2 → take n l2 `prefix_of` l1 → take n l1 `prefix_of` take n l2. 
: E) (H : op_is_inv_l x y) => ex_intro (op_is_inv_r x) y (H || a = 0 @a by op_is_comm x y)) (op_inv_l_ex x). Definition op_group := Group.group E 0 {+} op_is_assoc op_id_l op_id_r op_inv_l_ex op_inv_r_ex. Definition op_monoid := Group.op_monoid op_group. Definition has_inv_l := Group.has_inv_l op_group. Definition has_inv_r := Group.has_inv_r op_group. Definition has_inv := Group.has_inv op_group. Theorem op_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Group.op_id_l_uniq op_group. Theorem op_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Group.op_id_r_uniq op_group. Theorem op_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Group.op_id_uniq op_group. Theorem op_inv_l_r_eq : forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z. Proof Group.op_inv_l_r_eq op_group. Theorem op_inv_sym : forall x y : E, op_is_inv x y <-> op_is_inv y x. Proof Group.op_inv_sym op_group. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. Proof Group.op_inv_ex op_group. Theorem op_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. 
auto. intros x0 y0 p q H'0 H'1 H'2 z H'3; simple inversion H'3. discriminate H. rewrite <- H1; auto. intros H'4; apply ltP_hd; auto. apply ltT_eqTr with (a := y0). apply (eqT_sym A n); auto. injection H0. intros H'5 H'6; rewrite <- H'6; auto. rewrite <- H2. intros H'4 H'5; apply ltP_tl; auto. apply (eqT_trans A n) with (y := x1); auto. injection H1. intros H'6 H'7; rewrite H'7; auto. apply H'2; auto. injection H1. intros H'6; rewrite <- H'6; auto. Qed. Theorem olist_pX_ltP : forall a p, olist (pX a p) -> ltP p (pX a pO). intros a p; case p; auto. intros b l H'. apply ltP_hd; auto. apply olist_pX_order with (l := l); auto. Qed. Theorem ltP_pX_olist : forall a p, olist p -> ltP p (pX a pO) -> olist (pX a p). intros a p; case p; auto. intros H' H'1; unfold olist, DescA, consA in |- *; simpl in |- *; unfold consA, nilA in |- *. apply d_one; auto. intros b l H' H'0. apply olist_cons; auto. simple inversion H'0. discriminate H. injection H1; injection H0; intros H'1 H'2 H'3 H'4; (rewrite H'2; rewrite H'4); auto. injection H2; intros H'1 H'2; rewrite H'1; auto. unfold pO in |- *; intros H'3 H'4; inversion H'4. Qed.Theorem ltP_order_comp : forall (a b c : Term A n) (p q : list (Term A n)), ltP (pX b p) (pX a q) -> ltT a c -> ltT b c. intros a b c p q H1; inversion_clear H1. intros; apply ltT_trans with (y := a); auto. apply eqT_compat_ltTl. apply eqT_sym; trivial. Qed. Hint Resolve ltP_order_comp. Set Implicit Arguments. Unset Strict Implicit. Definition nZterm : list (Term A n) -> Prop. intros H'; elim H'. exact True. intros a P1 Rec. exact (Rec /\ ~ zeroP (A:=A) A0 eqA (n:=n) a). Defined. Definition canonical (a : list (Term A n)) : Prop := olist a /\ nZterm a. Set Strict Implicit. Unset Implicit Arguments. Theorem canonical_imp_olist : forall a, canonical a -> olist a. intros a H'; elim H'; auto. Qed. Hint Resolve canonical_imp_olist. Theorem canonical0 : forall a b, ltT b a -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX a (pX b pO)). intros a b H' H'0 H'1; simpl in |- *; auto. split; simpl in |- *; auto. Qed. Theorem canonical_ltT : forall l a b, canonical (l ++ pX a (pX b pO)) -> ltT b a. 
intros H; discriminate. intros b H b0 H0 b1; case b1. intros a0; right; red in |- *; intros H1; discriminate. intros b2 b3; case (H b2); intros H1. case (H0 b3); intros H2. left; rewrite H1; rewrite H2; auto. right; rewrite H1; Contradict H2; inversion H2; auto. right; Contradict H1; inversion H1; auto. Defined. Definition inb_dec : forall a p, {inb a p} + {~ inb a p}. intros a; elim a; simpl in |- *; auto; clear a. intros a p; elim p; simpl in |- *; auto; clear p. intros a1; case (eqA_dec a a1); intros Ha. left; rewrite Ha; simpl in |- *; auto. right; red in |- *; Contradict Ha; inversion Ha; auto. intros b [H| H]; auto. intros b0 [H1| H1]; auto. right; red in |- *; intros H2; inversion H2. case H; auto. case H1; auto. intros b H b0 H0 p; elim p; auto. intros a; right; red in |- *; intros H1; inversion H1. intros b1 H1 b2 H2. case H1; intros H3; auto. case H2; intros H4; auto. case (btree_dec (node b b0) (node b1 b2)); intros H5. left; rewrite H5; auto. right; red in |- *; intros H6; inversion H6; auto. case H5; rewrite H9; rewrite H10; auto. Defined. Fixpoint all_leaves (t : btree) : list A := match t with | leaf a => a :: nil | node t1 t2 => all_leaves t1 ++ all_leaves t2 end. Theorem all_leaves_in : forall t a, inb (leaf a) t -> In a (all_leaves t). Proof using. intros t; elim t; simpl in |- *; auto. intros a a0 H; inversion H; auto. intros b H b0 H0 a H1; apply in_or_app; inversion H1; auto. Qed. Theorem all_leaves_inb : forall t a, In a (all_leaves t) -> inb (leaf a) t. Proof using. intros t; elim t; simpl in |- *; auto. intros a a0 [H| H]; [ rewrite H | case H ]; auto. intros b H b0 H0 a H1; case in_app_or with (1 := H1); auto. Qed. Definition distinct_leaves (t : btree) : Prop := forall t0 t1 t2 : btree, inb (node t1 t2) t -> inb t0 t1 -> inb t0 t2 -> False. Theorem distinct_leaves_leaf : forall a : A, distinct_leaves (leaf a). Proof using. intros a; red in |- *. intros a0 t1 t2 H; inversion H. Qed. Hint Resolve distinct_leaves_leaf : core. Theorem distinct_leaves_l : forall t1 t2 : btree, distinct_leaves (node t1 t2) -> distinct_leaves t1. 
x => prod_is_inv x 1) 1. Proof Monoid.op_inv_0_uniq prod_monoid. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_r prod_monoid. Theorem recipr_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_sum_distrib : is_distrib E prod sum. Proof conj prod_sum_distrib_l prod_sum_distrib_r. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof fun x => let H : (0 # x) + (0 # x) = (0 # x) + 0 := eq_refl (0 # x) || a # x = 0 # x @a by (sum_id_l 0) || a = 0 # x @a by <- prod_sum_distrib_r x 0 0 || (0 # x) + (0 # x) = a @a by sum_id_r (0 # x) in sum_cancel_l (0 # x) 0 (0 # x) H. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof fun x => let H : (x # 0) + (x # 0) = 0 + (x # 0) := eq_refl (x # 0) || x # a = x # 0 @a by sum_id_r 0 || a = x # 0 @a by <- prod_sum_distrib_l x 0 0 || (x # 0) + (x # 0) = a @a by sum_id_l (x # 0) in sum_cancel_r (x # 0) 0 (x # 0) H. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof ex_ind (fun x (H : x # 0 = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_r x)). Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof ex_ind (fun x (H : 0 # x = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_l x)). Theorem prod_0_inv : ~ prod_has_inv 0. Proof ex_ind (fun x H => prod_0_inv_l (ex_intro (fun x => prod_is_inv_l 0 x) x (proj1 H))). Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof fun x y H (H0 : y = 0) => distinct_0_1 (proj1 H || a # x = 1 @a by <- H0 || a = 1 @a by <- prod_0_l x). Definition E_n1_strong : { x : E | sum_is_inv 1 x } := constructive_definite_description (sum_is_inv 1) (sum_inv_uniq_ex 1). Definition E_n1 : E := proj1_sig E_n1_strong. Notation "{-1}" := E_n1 : ring_scope. Theorem E_n1_def : sum_is_inv 1 {-1}. Proof proj2_sig E_n1_strong. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof proj1 E_n1_def. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. 
Require Import Classical.Require Import Ensembles. Require Import Relations_1. Require Import Relations_1_facts. Require Import podefs. Require Import podefs_1.Section The_power_set_partial_order. Variable U : Type. Inductive Power_set (A : Ensemble U) : Ensemble (Ensemble U) := Definition_of_Power_set : forall X : Ensemble U, Included U X A -> In (Ensemble U) (Power_set A) X. Hint Resolve Definition_of_Power_set. Variable A : Ensemble U. Theorem Empty_set_minimal : forall X : Ensemble U, Included U (Empty_set U) X. Proof. red in |- *; intros X x H'; elim H'. Qed. Hint Resolve Empty_set_minimal. Theorem Power_set_non_empty : forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A). Proof. intro A'; apply Non_empty_intro with (Empty_set U); auto. Qed. Hint Resolve Power_set_non_empty. Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U). Proof. auto 8. Qed. Hint Resolve Inclusion_is_an_order. Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U). elim Inclusion_is_an_order; auto. Qed. Hint Resolve Inclusion_is_transitive. Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U). Proof. generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H'; auto. Qed. Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U). Proof. elim Same_set_equivalence; auto. Qed. Hint Resolve Same_set_reflexive. Theorem Power_set_PO : PO (Ensemble U). Proof. apply Definition_of_PO with (Power_set A) (Included U); auto. Defined. Theorem Union_minimal : forall a b X : Ensemble U, Included U a X -> Included U b X -> Included U (Union U a b) X. Proof. intros a b X H' H'0; red in |- *; (intros x H'1; elim H'1); auto. Qed. Hint Resolve Union_minimal. Theorem Intersection_maximal : forall a b X : Ensemble U, Included U X a -> Included U X b -> Included U X (Intersection U a b). Proof. auto. Qed. Theorem Union_increases_l : forall a b : Ensemble U, Included U a (Union U a b). Proof. auto. Qed. Theorem Union_increases_r : forall a b : Ensemble U, Included U b (Union U a b). 
intros; hnf; auto. Qed. Theorem state_register_inversion: forall register value state, ($register == value) state -> state = (machine_state empty {[ register := value ]}). Proof. intros ??? A; hnf in A; auto. Qed. Theorem state_star_register_same register v1 v2: ($register == v1) \* ($register == v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_register_inversion & ?%state_register_inversion & [] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_counter_intro: forall counter, (pc_at counter) (machine_state {[ 0%fin := counter ]} empty). Proof. intros; hnf; auto. Qed. Theorem state_counter_inversion: forall counter state, (pc_at counter) state -> state = (machine_state {[ 0%fin := counter ]} empty). Proof. intros ?? A; hnf in A; auto. Qed. Theorem state_star_counter v1 v2: (pc_at v1) \* (pc_at v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_counter_inversion & ?%state_counter_inversion & [? _] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_exists_intro: forall A (a: A) (P: A -> Assertion) state, P a state -> (\exists a, P a) state. Proof. intros; hnf; eauto. Qed. Theorem state_exists_inversion: forall X (P: X -> Assertion) state, (\exists x, P x) state -> exists x, P x state. Proof. intros ??? A; hnf in A; eauto. Qed. Theorem state_forall_intro: forall A (P: A -> Assertion) state, (forall a, P a state) -> (state_forall P) state. Proof. intros; hnf; assumption. Qed. Theorem state_forall_inversion: forall A (P: A -> Assertion) state, (state_forall P) state -> forall a, P a state. Proof. intros; hnf; trivial. Qed. Theorem state_implies_forall_r: forall A (P: A -> Assertion) H, (forall a, H **> P a) -> H **> (state_forall P). Proof. intros ??? M ???; apply M; assumption. Qed. Theorem state_implies_forall_l: forall A a (P: A -> Assertion) H, (P a **> H) -> (state_forall P) **> H. Proof. intros ???? M ??; apply M; trivial. Qed. Theorem state_forall_specialize: forall A a (P: A -> Assertion), (state_forall P) **> (P a). Proof. intros; apply (state_implies_forall_l a); auto. Qed. Theorem state_wand_equiv: forall H0 H1 H2, (H0 **> H1 \-* H2) <-> (H1 \* H0 **> H2). Proof. unfold state_wand. iff M. { rewrite state_star_comm. applys state_implies_state_star_trans_l (rm M). rewrite state_star_state_exists. applys state_implies_state_exists_l. intros H. rewrite (state_star_comm H). rewrite state_star_assoc. rewrite (state_star_comm H H1). applys~ state_implies_state_star_state_pure_l. } { applys state_implies_state_exists_r H0. rewrite <- (state_star_hempty_r H0) at 1. applys state_implies_frame_r. applys state_implies_hempty_state_pure M. } Qed. Theorem state_implies_state_wand_r: forall H1 H2 H3, H2 \* H1 **> H3 -> H1 **> (H2 \-* H3). 
unfold ptsto_subset; cancel; eauto. apply addr_valid_upd; auto. + cancel. rewrite sep_star_and_distr, pimpl_l_and. unfold rep; cancel; eauto. eapply pimpl_trans; [ | apply mem_pred_absorb_nop; eauto ]. unfold cachepred at 3; rewrite Heqo. unfold ptsto_subset; cancel; eauto. eapply incl_tran; eauto. - unfold ptsto_subset. repeat (rewrite pimpl_exists_l_star_r || rewrite pimpl_exists_r_star_r || rewrite pimpl_and_l_exists || rewrite pimpl_and_r_exists || apply pimpl_exists_l; intros ). setoid_rewrite sep_star_assoc at 2. rewrite sep_star_lift_empty. setoid_rewrite <- sep_star_assoc at 1 2. rewrite lift_empty_and_distr_r. norml; unfold stars; simpl; subst. rewrite sep_star_ptsto_and_eq. cancel; subst; eauto. prestep; norml; unfold stars; simpl; intuition; repeat deex; try congruence; inv_option_eq. cancel. 2: eapply ptsto_subset_upd with (vs' := nil); eauto; apply incl_refl. rewrite sep_star_and_distr; unfold synrep. apply pimpl_and_split. + rewrite pimpl_l_and; unfold rep; cancel. erewrite <- upd_nop with (m := d0) at 2 by eauto. rewrite <- mem_pred_absorb with (hm := d0) (a := a). unfold cachepred at 3. rewrite Heqo. unfold ptsto_subset; cancel. eapply incl_tran; eauto. + rewrite pimpl_r_and; unfold synrep'; cancel. rewrite <- mem_pred_absorb with (hm := d) (a := a). unfold synpred at 3. rewrite Heqo. unfold ptsto_subset; cancel; eauto. apply addr_valid_upd; auto. + cancel. rewrite sep_star_and_distr, pimpl_l_and. unfold rep; cancel; eauto. eapply pimpl_trans; [ | apply mem_pred_absorb_nop; eauto ]. unfold cachepred at 3; rewrite Heqo. unfold ptsto_subset; cancel; eauto. eapply incl_tran; eauto. Unshelve. all: eauto. Qed. Theorem sync_synrep_helper_1 : forall m cs d0 d a (F : @pred _ addr_eq_dec _) v, synrep cs d0 d m -> (F * a |+> v)%pred d -> exists (F0 : @pred _ addr_eq_dec _) v0, (F0 * a |+> v0)%pred d0. Proof. unfold synrep, rep, synrep', ptsto_subset; intros. case_eq (d0 a); intros. - destruct p. eapply any_sep_star_ptsto in H1. pred_apply. safecancel. eassign (w, l). eassign l. cancel. firstorder. - destruct H. destruct_lift H. destruct_lift H2. destruct_lift H0. apply ptsto_valid' in H0. eapply mem_pred_absent_lm in H; eauto. eapply mem_pred_absent_hm in H2; eauto. congruence. unfold synpred, ptsto_subset; intros. destruct (Map.find a0 (CSMap cs)); try destruct p; try destruct b; cancel. unfold cachepred, ptsto_subset; intros. destruct (Map.find a0 (CSMap cs)); try destruct p; try destruct b; cancel. Qed. Theorem sync_synrep_helper_2 : forall cs d0 d a (F : @pred _ addr_eq_dec _) v, (F * a |+> v)%pred d -> synrep cs d0 d =p=> synrep cs d0 d * exists (F0 : @pred _ addr_eq_dec _) v0, [[ (F0 * a |+> v0)%pred d0 ]]. Proof. unfold pimpl; intros. eapply sync_synrep_helper_1 in H; eauto; repeat deex. pred_apply; cancel. Qed. Theorem sync_ok : forall cs a, {< d0 d (F : rawpred) v0, PRE:hm synrep cs d0 d * [[ (F * a |+> v0)%pred d ]] * [[ sync_invariant F ]] POST:hm' RET:cs exists d, synrep cs d0 d * [[ (F * a |+> (fst v0, nil))%pred d ]] CRASH:hm' exists cs', rep cs' d0 >} sync a cs. 
v1 v2 w1 w2 : RunsTo cenv stmt cst cst' -> env_good_to_use modules imports stn fs -> fst cenv = from_bedrock_label_map (Labels stn) -> snd cenv = fs stn -> stmt = Compile.compile (CompileDFacade.compile prog) -> pre_cond v1 v2 -> disjoint_ptrs {(w1, v1); (w2, v2)} -> good_scalars {(w1, v1); (w2, v2)} -> w1 = Locals.sel (fst cst) argvar1 -> w2 = Locals.sel (fst cst) argvar2 -> snd cst == make_heap {(w1, v1); (w2, v2)} -> exists vr, let wr := Locals.sel (fst cst') retvar in let pairs := {(wr, vr)} in post_cond v1 v2 vr /\ snd cst' == make_heap pairs /\ disjoint_ptrs pairs /\ good_scalars pairs. Proof. destruct cenv as [l2w w2spec]; simpl in *. destruct cst as [vs h]; simpl in *. destruct cst' as [vs' h']; simpl in *. intros Hrt Hegtu ? ? ? Hpre Hdisj Hgs ? ? Hheq. subst. eapply CompileDFacadeToCito.compile_runsto in Hrt; try reflexivity; simpl in *; trivial. destruct Hrt as [st' [Hrt [Hsm [Hseleq Hr] ] ] ]. 6 : eapply env_good_to_use_cenv_impls_env; eauto. 2 : eapply unit_syntax_ok. Focus 3. { eapply make_map_make_heap_related with (ks := argvars); eauto; simpl in *. reflexivity. eauto. eauto. } Unfocus. simpl in *. { eapply dfacade_runsto in Hrt; eauto. 2 : reflexivity. destruct Hrt as [ret [Hst' [Hnoleak Hpost] ] ]. eapply make_map_related_make_heap_singleton in Hr. { destruct Hr as [Hh' [Hgs' Hdisj'] ]. exists ret. repeat try_split. - eauto. - eapply Hh'. - eauto. - eauto. } { instantiate (1 := ret). instantiate (1 := retvar). eauto. } { intros k Hnin. eauto. } { reflexivity. } { reflexivity. } { simpl. rewrite diff_same. rewrite diff_empty. reflexivity. } { eauto. } } { eapply submap_refl. } { eauto. } { eapply dfacade_safe; eauto. reflexivity. } Qed. Import Made. Definition output_module := bimport [[ (module_name!fun_name, spec_op_b) ]] bmodule export_module_name {{ bfunction fun_name(argvar1, argvar2, "R") [compileS pre_cond post_cond] "R" <-- Call module_name!fun_name(extra_stack, argvar1, argvar2) [PRE[_, R] Emp POST[R'] [| R' = R |] ];; Return "R" end }}. Require Import Bedrock.Platform.AutoSep. Require Import Bedrock.Platform.Cito.GeneralTactics3. Opaque mult. Import LinkMake.StubsMake.StubMake.LinkSpecMake2.CompileFuncSpecMake.InvMake. Require Import Bedrock.sep.Locals. Theorem is_state_in2 : forall vs sp args e_stack h F, locals ("rp" :: "extra_stack" :: args) vs e_stack sp * is_heap h * mallocHeap 0 * F ===> is_state sp (Locals.sel vs "rp") (wordToNat (Locals.sel vs "extra_stack")) e_stack args (vs, h) nil * mallocHeap 0 * F. intros; sepLemma. etransitivity; [ | apply is_state_in'' ]; auto. sepLemma. Qed. Theorem is_state_out'' sp rp args pairs vs e_stack e_stack' h : NoDup args -> ~List.In "rp" args -> ~List.In "extra_stack" args -> length args = length pairs -> is_state sp rp e_stack e_stack' nil (vs, h) (List.map fst pairs) ===> Ex vs', locals ("rp" :: "extra_stack" :: args) vs' e_stack' sp * is_heap h * [| sel vs' "extra_stack" = e_stack |] * [| saved_vars vs' args pairs |]. 
→ 𝜆 ≤ 𝜇 →  <𝐜 𝜇. Proof with eauto. intros * [H1 Hnq] H2. split. eapply cardLe_trans... intros Heq. apply Hnq. rewrite <- Heq in H2. eapply cardLe_antisym... Qed. Lemma cardAdd_preserve_eqnum : ∀  𝜆 𝜇,  ≈ 𝜆 →  + 𝜇 ≈ 𝜆 + 𝜇. Proof with auto. intros. unfold CardAdd. rewrite <- CardAx0, <- CardAx0. apply cardAdd_well_defined. apply cardMul_well_defined... now apply cardMul_well_defined... apply disjointify_0_1. apply disjointify_0_1. Qed. Theorem cardAdd_preserve_le : ∀  𝜆 𝜇,  ≤ 𝜆 →  + 𝜇 ≤ 𝜆 + 𝜇. Proof with auto. intros * Hle. apply cardLe_sub_exists in Hle as [K [L [Hk [Hl H]]]]. repeat split... eapply cardLe_well_defined. symmetry. apply cardAdd_preserve_eqnum. apply Hk. symmetry. apply cardAdd_preserve_eqnum. apply Hl. apply cardLe_sub. apply sub_mono_bunion. apply sub_mono_cprd... Qed. Theorem cardMul_preserve_le : ∀  𝜆 𝜇,  ≤ 𝜆 →   𝜇 ≤ 𝜆  𝜇. Proof with auto. intros * Hle. apply cardLe_sub_exists in Hle as [K [L [H1 [H2 H]]]]. apply cardLe_iff. eapply cardLe_well_defined. apply cardMul_well_defined. symmetry. apply H1. reflexivity. apply cardMul_well_defined. symmetry. apply H2. reflexivity. apply dominate_sub. apply sub_mono_cprd... Qed.Corollary cardAdd_preserve_le' : ∀  𝜆 𝜇,  ≤ 𝜆 → 𝜇 +  ≤ 𝜇 + 𝜆. Proof. intros * Hle. rewrite cardAdd_comm, (cardAdd_comm 𝜇). apply cardAdd_preserve_le. apply Hle. Qed.Corollary cardMul_preserve_le' : ∀  𝜆 𝜇,  ≤ 𝜆 → 𝜇   ≤ 𝜇  𝜆. Proof. intros * Hle. rewrite cardMul_comm, (cardMul_comm 𝜇). apply cardMul_preserve_le. apply Hle. Qed.Corollary cardAdd_enlarge : ∀  𝜆 ⋵ 𝐂𝐃,  ≤  + 𝜆. Proof with auto. intros  Hk 𝜆 Hl. rewrite <- cardAdd_0_r at 1... apply cardAdd_preserve_le'. apply cardLe_0... Qed.Corollary cardMul_enlarge : ∀  𝜆 ⋵ 𝐂𝐃, 𝜆  0 →  ≤   𝜆. Proof with auto. intros  Hk 𝜆 Hl H0. rewrite <- cardMul_1_r at 1... apply cardMul_preserve_le'. apply cardLe_1... Qed.Lemma sub_mono_arrow : ∀ A B C, A ⊆ B → C ⟶ A ⊆ C ⟶ B. Proof with auto. intros * Hsub f Hf. apply arrow_iff in Hf as [Hf [Hd Hr]]. apply arrow_iff. split; [|split]... Qed. Theorem cardExp_preserve_base_le : ∀  𝜆 𝜇,  ≤ 𝜆 →  ^ 𝜇 ≤ 𝜆 ^ 𝜇. Proof with auto. intros * Hle. apply cardLe_sub_exists in Hle as [K [L [H1 [H2 H]]]]. apply cardLe_iff. eapply cardLe_well_defined. apply cardExp_well_defined. symmetry. apply H1. reflexivity. apply cardExp_well_defined. symmetry. apply H2. reflexivity. apply dominate_sub. apply sub_mono_arrow... Qed. Theorem cardExp_preserve_exponent_le : ∀  𝜆 𝜇, (   ∨ 𝜇   ) →  ≤ 𝜆 → 𝜇 ^  ≤ 𝜇 ^ 𝜆. 
Require Import Ensembles. Require Import Relations_1.Section Partial_orders. Variable U : Type. Definition Carrier := Ensemble U. Definition Rel := Relation U. Inductive PO : Type := Definition_of_PO : forall (C : Carrier) (R : Rel), Non_empty U C -> Order U R -> PO. Theorem Carrier_of : PO -> Carrier. 
Require Export FPred. Section finduct. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition Fweight (p : float) := (Fnum p + Fexp p * Zpower_nat radix precision)%Z. Theorem FweightLt : forall p q : float, Fcanonic radix b p -> Fcanonic radix b q -> (0 <= p)%R -> (p < q)%R -> (Fweight p < Fweight q)%Z. intros p q H' H'0 H'1 H'2. cut (Fbounded b p); [ intros Fb1 | apply FcanonicBound with (1 := H') ]; auto. cut (Fbounded b q); [ intros Fb2 | apply FcanonicBound with (1 := H'0) ]; auto. case (FcanonicLtPos _ radixMoreThanOne b precision) with (p := p) (q := q); auto with arith; intros Zl1. unfold Fweight in |- *; simpl in |- *. replace (Fexp q) with (Fexp q - Fexp p + Fexp p)%Z; [ idtac | ring ]. rewrite Zmult_plus_distr_l. rewrite Zplus_assoc. repeat rewrite (fun x y z : Z => Zplus_comm x (y * z)). apply Zplus_lt_compat_l. apply Zlt_le_trans with (Zpower_nat radix precision); auto with zarith. apply Zle_lt_trans with (Zpred (Zpower_nat radix precision)); auto with zarith. apply Zle_Zabs_inv2; auto with float zarith. apply Zle_Zpred; auto with float zarith. rewrite <- pGivesBound; auto with float. apply Zle_trans with ((Fexp q - Fexp p) * Zpower_nat radix precision)%Z; auto with zarith. pattern (Zpower_nat radix precision) at 1 in |- *; replace (Zpower_nat radix precision) with (Zsucc 0 * Zpower_nat radix precision)%Z; auto. apply Zle_Zmult_comp_r; auto with zarith. unfold Zsucc in |- *; ring. cut (0 <= Fnum q)%Z; auto with zarith. apply (LeR0Fnum radix); auto. apply Rle_trans with (FtoRradix p); auto; apply Rlt_le; auto. elim Zl1; intros H'3 H'4; clear Zl1. unfold Fweight in |- *; simpl in |- *. rewrite <- H'3. repeat rewrite (fun x y z : Z => Zplus_comm x (y * z)). apply Zplus_lt_compat_l; auto. Qed. Theorem FweightEq : forall p q : float, Fcanonic radix b p -> Fcanonic radix b q -> p = q :>R -> Fweight p = Fweight q. 
:: A => ascend ψ0 ψ1 (substitute (if a then ψ1 else ψ0) t) A end.Lemma ascend_arr {ψ0 ψ1: valuation} {s t: term} {A: stack} : ascend ψ0 ψ1 (arr s t) A = arr (ascend ψ0 ψ1 s A) (ascend ψ0 ψ1 t A). Proof. elim: A s t; first done. move=> a A IH s t /=. by rewrite IH. Qed. Definition interpret (φ ψ0 ψ1: valuation) (X: config) : option term := match X with | (A, B, x) => descend (ascend ψ0 ψ1 (φ (embed ([], [], x))) A) B end. Lemma interpretP {M: ssm} {X Y: config} {φ ψ0 ψ1: valuation} : Forall (models φ ψ0 ψ1) (SM_to_SUcs M) -> reachable M X Y -> interpret φ ψ0 ψ1 X = interpret φ ψ0 ψ1 Y. Proof. move=> HM. elim; [| done | by move=> > ? ->]. move=> {}X {}Y [|] x y a b A B. - move: HM. rewrite /SM_to_SUcs Forall_map Forall_forall => HM. move /HM. rewrite /models /interpret. case: (φ (embed ([], [], y))); first done. move: a b => [|] [|] ? ? -> /=; by rewrite ascend_arr. - move: HM. rewrite /SM_to_SUcs Forall_map Forall_forall => HM. move /HM. rewrite /models /interpret. case: (φ (embed ([], [], x))); first done. move: a b => [|] [|] ? ? -> /=; by rewrite ascend_arr. Qed.Lemma descendP {s t: term} {B: list symbol} : descend s B = Some t -> length B <= term_depth_bound s. Proof. elim: B s t; first by (move=> /= *; lia). move=> b B IH [ /= | > /IH]; [done | case: b => /=; by lia]. Qed. Lemma completeness {M: cssm}: SSemiU (SM_to_SUcs (proj1_sig M)) -> CSSM_UB M. Proof. case: M=> M confluent_M /=. move=> [φ [ψ0 [ψ1]]]. rewrite -Forall_forall => Hφ. pose f x := embed (([], [], x) : config). apply: (bounded_of_bounded' confluent_M (n := depth_bound φ (map f (enum_states M)))). move=> /= Z x y A B Hx Hy. case: (In_dec _ y (enum_states M)); first by decide equality. { move=> /(in_map f) /depth_boundP => /(_ φ) Hfy. move: Hy => /(interpretP Hφ). move: Hx => /(interpretP Hφ) <- /= /descendP. rewrite -/(f y). move: (length B) => ?. by lia. } move: (Hy) Hx => /enum_states_reachable [<- /enum_states_reachable | ]; last by by move=> [+]. case; last by move=> [+]. case=> *. subst=> /=. by lia. Qed.End Argument.Require Import Undecidability.Synthetic.Definitions. Theorem reduction : CSSM_UB ⪯ SSemiU. 
n = o. Admitted. QuickChick trans_eq. *)Example trans_eq_example' : forall (a b c d e f : nat), [a;b] = [c;d] -> [c;d] = [e;f] -> [a;b] = [e;f]. Admitted. Example trans_eq_exercise : forall (n m o p : nat), m = (minustwo o) -> (n + p) = m -> (n + p) = (minustwo o). Admitted. Theorem S_injective : forall (n m : nat), S n = S m -> n = m. Admitted. Theorem beq_nat_0_l : forall n, 0 = n -> n = 0. Admitted. QuickChick beq_nat_0_l. *)Theorem inversion_ex4 : forall (n : nat), S n = O -> 2 + 2 = 5. Admitted. Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A), x = y -> f x = f y. Admitted. Theorem plus_n_n_injective : forall n m, n + n = m + m -> n = m. Admitted. Theorem double_injective : forall n m, double n = double m -> n = m. Admitted. Theorem beq_id_true : forall (x y : id), x = y -> x = y. Admitted. QuickChick beq_id_true. *) Theorem nth_error_after_last: forall (X : Type) (l : list X) (n : nat), length l = n -> nth_error l n = None. Admitted. QuickChick nth_error_after_last. *)Definition square n := n * n.Lemma square_mult : forall n m, square (n * m) = square n * square m. Admitted. Definition foo (x: nat) := 5.Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1. Admitted. Definition bar x := match x with | O => 5 | S _ => 5 end.Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1. Admitted. Definition sillyfun (n : nat) : bool := if beq_nat n 3 then false else if beq_nat n 5 then false else false.Theorem sillyfun_false : forall (n : nat), sillyfun n = false. Admitted. Definition sillyfun1 (n : nat) : bool := if beq_nat n 3 then true else if beq_nat n 5 then true else false.Theorem sillyfun1_odd : forall (n : nat), sillyfun1 n = true -> oddb n = true. Admitted. Theorem bool_fn_applied_thrice : forall (f : bool -> bool) (b : bool), f (f (f b)) = f b. Admitted. Theorem beq_nat_sym : forall (n m : nat), beq_nat n m = beq_nat m n. Admitted. Theorem beq_nat_trans : forall n m p, beq_nat n m = true -> beq_nat m p = true -> beq_nat n p = true. 
if b' then True else False. Module Bool_Order : DEC_ORDER with Definition A := bool with Definition le := bool_le with Definition lt := bool_lt. Definition A := bool. Definition le := bool_le. Definition lt := bool_lt. Theorem ordered : order A le. Proof. split. unfold A, le, reflexive in |- *. intro x; case x; simpl in |- *; auto. unfold A, le, transitive in |- *; simple destruct x; simple destruct y; auto; simple destruct z; auto. unfold A, le, antisymmetric in |- *; simple destruct x; simple destruct y; simpl in |- *; auto; contradiction. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. Proof. unfold A, lt, le in |- *; simple destruct a; simple destruct b; simpl in |- *; tauto. Qed. Theorem lt_diff : forall a b : A, lt a b -> a <> b. Proof. unfold A, lt, bool_lt in |- *; simple destruct a; simple destruct b; auto. Qed. Theorem le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Proof. unfold A, le, lt, bool_lt in |- *; simple destruct a; simple destruct b; auto. Qed. Definition lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a}. unfold A, le, lt, bool_lt in |- *; simple destruct a; simple destruct b; auto. Defined. End Bool_Order. Module Type DATA. Parameter data : Set. End DATA. Module TrivialDict (Key: KEY) (Val: DATA) : DICT with Definition key := Key.A with Definition data := Val.data. Definition key := Key.A. Definition data := Val.data. Definition dict := key -> option data. Definition empty (k : key) := None (A:=data). Definition find (k : key) (d : dict) := d k. Definition add (k : key) (v : data) (d : dict) : dict := fun k' : key => match Key.eqdec k' k with | left _ => Some v | right _ => d k' end. Theorem empty_def : forall k : key, find k empty = None. Proof. unfold find, empty in |- *; auto. Qed. Theorem success : forall (d : dict) (k : key) (v : data), find k (add k v d) = Some v. Proof. unfold find, add in |- *; intros d k v. case (Key.eqdec k k); simpl in |- *; tauto. Qed. Theorem diff_key : forall (d : dict) (k k' : key) (v : data), k <> k' -> find k (add k' v d) = find k d. 
with zarith. apply Zlt_not_le; apply Zmult_lt_compat_l; auto. Qed.Theorem Zmult_le_neg_compat_l_rev: forall n m p : Z, (p < 0)%Z -> (p * n <= p * m)%Z -> (m <= n)%Z. intros n m p H H1; case (Zle_or_lt m n); auto; intros H2. absurd (p * n <= p * m)%Z; auto with zarith. apply Zlt_not_le; apply Zmult_lt_neg_compat_l; auto. Qed.Theorem Zmult_lt_compat_l_rev: forall n m p : Z, (0 < p)%Z -> (p * n < p * m)%Z -> (n < m)%Z. intros n m p H H1; case (Zle_or_lt m n); auto; intros H2. absurd (p * n < p * m)%Z; auto with zarith. apply Zle_not_lt; apply Zmult_le_compat_l; auto with zarith. Qed.Theorem Zmult_lt_neg_compat_l_rev: forall n m p : Z, (p < 0)%Z -> (p * n < p * m)%Z -> (m < n)%Z. intros n m p H H1; case (Zle_or_lt n m); auto; intros H2. absurd (p * n < p * m)%Z; auto with zarith. apply Zle_not_lt; apply Zmult_le_neg_compat_l; auto with zarith. Qed.Theorem Zmult_ge_compat_l_rev: forall n m p : Z, (p > 0)%Z -> (p * n >= p * m)%Z -> (n >= m)%Z. intros n m p H H1; apply Z.le_ge; apply Zmult_le_compat_l_rev with p; auto with zarith. Qed.Theorem Zmult_ge_neg_compat_l_rev: forall n m p : Z, (0 > p)%Z -> (p * n >= p * m)%Z -> (m >= n)%Z. intros n m p H H1; apply Z.le_ge; apply Zmult_le_neg_compat_l_rev with p; auto with zarith. Qed.Theorem Zmult_gt_compat_l_rev: forall n m p : Z, (p > 0)%Z -> (p * n > p * m)%Z -> (n > m)%Z. intros n m p H H1; apply Z.lt_gt; apply Zmult_lt_compat_l_rev with p; auto with zarith. Qed.Theorem Zmult_gt_neg_compat_l_rev: forall n m p : Z, (0 > p)%Z -> (p * n > p * m)%Z -> (m > n)%Z. intros n m p H H1; apply Z.lt_gt; apply Zmult_lt_neg_compat_l_rev with p; auto with zarith. Qed.Theorem eq_Zlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Zlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Zgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Zgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). 
R'] Y] /inverse_simulation. case. { move=> <-. by left. } move=> [x'] [y'] [b_x'] [b_y'] [l] [r] [l'] [r']. move=> [[]] ? ? ? [[]] ? ? ?. subst. have [? ?] : (x, b_x) = (x', b_x') by rewrite -Hx /x_b_x enumP. subst. move Hb_x: (b_x') => b_x. move Hb_y: (b_y') => b_y. rewrite ?decode_encode_Stack in H1T1. rewrite ?decode_encode_Stack in H1T2. move: b_x b_y Hb_x Hb_y => [|] [|] ? ?; subst; rewrite ?in_app_iff ?in_flat_map. - move /H1T2 => ?. right. right. eexists. constructor; first by eassumption. move=> /=. by firstorder done. - move /H1T2 => ?. right. right. eexists. constructor; first by eassumption. move=> /=. by firstorder done. - move /H1T1 => ?. right. left. eexists. constructor; first by eassumption. move=> /=. by firstorder done. - move /H1T1 => ?. right. left. eexists. constructor; first by eassumption. move=> /=. by firstorder done. } rewrite ?app_length. set f1 := (f in (flat_map f T1)). set f2 := (f in (flat_map f T2)). have := legnth_flat_map (f := f1) (l := T1) (n := 2). apply: unnest. { move=> [[? ?] ?]. rewrite /f1 /length. by lia. } have := legnth_flat_map (f := f2) (l := T2) (n := 2). apply: unnest. { move=> [[? ?] ?]. rewrite /f2 /length. by lia. } rewrite /length -?/(length _). move: H2T1 H2T2. move: (length _) (length _). by lia. Qed. End Transport. Section Reflection. Variable NMN : nat. Variable bounded_MN : bounded MN NMN. Definition encode_State : State * bool -> nat := to_nat. Definition decode_State : nat -> State * bool := of_nat. Lemma bounded_MX : SMX.bounded MX (2*NMN). Proof using bounded_MN. rewrite /SMX.bounded. move=> [[l r] x]. have [T [H1T H2T]]:= bounded_MN (encode_Stack l, encode_Stack r, encode_State (x, false)). exists ((map (fun '(L, R, X) => (decode_Stack L, decode_Stack R, fst (decode_State X))) T) ++ (map (fun '(L, R, X) => (decode_Stack R, decode_Stack L, fst (decode_State X))) T)). constructor; first last. { rewrite ?app_length ?map_length. move: (length T) H2T. by lia. } move=> [[l' r'] y] /simulation /=. rewrite ?in_app_iff ?in_map_iff. move=> [] _ [Hxy|Hxy]. - left. exists (encode_Stack l', encode_Stack r', to_nat (y, false)). rewrite ?decode_encode_Stack /decode_State ?enumP /=. constructor; first done. by apply: H1T. - right. exists (encode_Stack r', encode_Stack l', to_nat (y, true)). rewrite ?decode_encode_Stack /decode_State ?enumP /=. constructor; first done. by apply: H1T. Qed. End Reflection. End Reduction. End Argument.Require Import Undecidability.Synthetic.Definitions. Require Import Undecidability.CounterMachines.CM1. Theorem reduction : CM1_HALT ⪯ SMNdl_UB. 
in Hbks_len. fold (slidingM.numMutable σ). change (uint64T * (blockT * unitT))%ht with (struct.t Update). set (s':=slice_take logSlice (slidingM.numMutable σ)). iDestruct (is_slice_small_sz with "Hs") as %Hsz. autorewrite with len in Hsz. iDestruct (is_slice_small_take_drop _ _ _ (word.sub start σ.(slidingM.start)) with "Hs") as "[Hs2 Hs1]". { revert Hbks_len; word. } iApply "HΦ". iSplitR "Hs2 Hblocks". { iFrame "% ∗". iExists _, _; iFrame "# ∗". } iExists _. rewrite -fmap_drop. iFrame "Hs2". set (numMutable := int.nat (slidingM.numMutable σ)) in *. assert (numMutable ≤ length σ.(slidingM.log))%nat by (rewrite /numMutable; word). replace (numMutable `min` length σ.(slidingM.log))%nat with numMutable in * by word. assert (int.nat (word.sub start σ.(slidingM.start)) = int.nat start - int.nat σ.(slidingM.start))%nat as Hstart_off by word. rewrite Hstart_off. rewrite -{1}(take_drop (int.nat start - int.nat σ.(slidingM.start)) bks). iDestruct (big_sepL2_app_inv_l with "Hblocks") as (bks1 bks2 Hbks12) "[Hblocks1 Hblocks2]". iDestruct (big_sepL2_length with "Hblocks1") as %Hlen1. iDestruct (big_sepL2_length with "Hblocks2") as %Hlen2. autorewrite with len in Hlen1, Hlen2. iExactEq "Hblocks2". f_equal. rewrite subslice_take_drop. replace (slidingM.logIndex σ σ.(slidingM.mutable)) with (int.nat (slidingM.numMutable σ)) by word. rewrite -/numMutable. rewrite Hbks12. assert (length bks1 = slidingM.logIndex σ start). { rewrite -Hlen1. rewrite Hbks_len /numMutable. word. } rewrite -> drop_app_ge by lia. replace (slidingM.logIndex σ start - length bks1)%nat with 0%nat by lia; auto. Qed.Theorem wp_SliceTake_updates s (n: u64) q q_b (upds: list update.t) : int.Z n ≤ length upds → {{{ updates_slice_frag' s q q_b upds }}} SliceTake (slice_val s) #n {{{ RET (slice_val (slice_take s n)); updates_slice_frag' (slice_take s n) q q_b (take (int.nat n) upds) }}}. Proof. iIntros (Hbound Φ) "Hupds HΦ". iDestruct (updates_slice_frag_len with "Hupds") as %Hlen. iDestruct (updates_slice_frag_wf with "Hupds") as %Hwf. wp_apply wp_SliceTake; first by word. iApply "HΦ". iDestruct (updates_slice_frag_split with "Hupds") as "[_ $]". word. Qed.Theorem wp_sliding__takeTill l q_b σ (endPos: u64) : int.Z σ.(slidingM.start) ≤ int.Z endPos ≤ int.Z σ.(slidingM.mutable) -> {{{ is_sliding l q_b σ }}} sliding__takeTill #l #endPos {{{ q s, RET (slice_val s); is_sliding l q_b σ ∗ let to := slidingM.logIndex σ endPos in updates_slice_frag s q (take to σ.(slidingM.log)) }}}. Proof. iIntros (Hbound Φ) "Hs HΦ". iNamed "Hs"; iNamed "Hinv". wp_call. repeat wp_loadField. iDestruct (memLog_sz with "log_mutable") as %Hsz. iDestruct (memLog_wf with "log_mutable") as %?. iMod (readonly_load with "log_readonly") as (q) "Hlog". wp_apply wp_SliceTake. { word. } wp_apply (wp_SliceTake_updates with "Hlog"); first by len. iIntros "Hupds". iApply "HΦ". iSplitR "Hupds". { iSplit; auto. iExists _, _; iFrame "# ∗". } rewrite take_take. iExactEq "Hupds". repeat (f_equal; try word). Qed. Theorem memLogMap_drop1_not_highest (σ: slidingM.t) (upd: update.t) i : slidingM.wf σ → σ.(slidingM.log) !! O = Some upd → find_highest_index (update.addr <$> σ.(slidingM.log)) upd.(update.addr) = Some i → (i > 0)%nat → slidingM.addrPosMap (set slidingM.start (word.add 1) (set slidingM.log (drop 1) σ)) = slidingM.addrPosMap σ. 
* q')%R. intros P H' r q q' H'0 H'1. replace (radix * q')%R with (FtoRradix (Float (Fnum q') (Fexp q' + 1%nat))). intros H'2; case H'2. intros H'3; case H'; intros H'4 H'5; elim H'5; intros H'6 H'7; elim H'7; intros H'8 H'9; apply H'9 with (1 := H'3); clear H'7 H'5; auto. apply RoundedModeProjectorIdem; auto. apply FBoundedScale; auto. intros H'3. replace (FtoRradix q) with (FtoRradix (Float (Fnum q') (Fexp q' + 1%nat))); auto with real. apply (RoundedProjector _ _ P H'); auto. apply FBoundedScale; auto. case H'. intros H'4 H'5; elim H'5; intros H'6 H'7; clear H'5. apply (H'6 r (Float (Fnum q') (Fexp q' + 1%nat)) q); auto. apply RoundedModeBounded with (P := P) (r := r); auto. rewrite (FvalScale _ radixMoreThanOne b). rewrite powerRZ_1; auto. Qed. Theorem RoundedModeMultLess : forall P, RoundedModeP b radix P -> forall (r : R) (q q' : float), P r q -> Fbounded b q' -> (radix * q' <= r)%R -> (radix * q' <= q)%R. intros P H' r q q' H'0 H'1. replace (radix * q')%R with (FtoRradix (Float (Fnum q') (Fexp q' + 1%nat))). intros H'2; case H'2. intros H'3; case H'; intros H'4 H'5; elim H'5; intros H'6 H'7; elim H'7; intros H'8 H'9; apply H'9 with (1 := H'3); clear H'7 H'5; auto. apply RoundedModeProjectorIdem; auto. apply FBoundedScale; auto. intros H'3. replace (FtoRradix q) with (FtoRradix (Float (Fnum q') (Fexp q' + 1%nat))); auto with real. apply (RoundedProjector _ _ P H'); auto. apply FBoundedScale; auto. unfold FtoRradix in H'3; rewrite H'3; auto. case H'. intros H'4 H'5; elim H'5; intros H'6 H'7; clear H'5. unfold FtoRradix in |- *; rewrite FvalScale; auto. rewrite powerRZ_1; auto. Qed. Theorem RleMinR0 : forall (r : R) (min : float), (0 <= r)%R -> isMin b radix r min -> (0 <= min)%R. intros r min H' H'0. rewrite <- (FzeroisZero radix b). case H'; intros H'1. apply (MonotoneMin b radix) with (p := FtoRradix (Fzero (- dExp b))) (q := r); auto. unfold FtoRradix in |- *; rewrite (FzeroisZero radix b); auto. apply (RoundedModeProjectorIdem (isMin b radix)); auto. apply MinRoundedModeP with (precision := precision); auto with float. apply FboundedFzero; auto. replace (FtoR radix (Fzero (- dExp b))) with (FtoRradix min); auto with real. apply sym_eq; apply (ProjectMin b radix). apply FboundedFzero; auto. rewrite <- H'1 in H'0; rewrite <- (FzeroisZero radix b) in H'0; auto. Qed. Theorem RleRoundedR0 : forall (P : R -> float -> Prop) (p : float) (r : R), RoundedModeP b radix P -> P r p -> (0 <= r)%R -> (0 <= p)%R. 
a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). induction arr; intuition; simpl in *. discriminate. remember (split arr) as z. destruct z. simpl. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H0. intuition. rewrite H0 in H. right. eapply IHarr; intuition. eauto. Qed. Theorem arrayLookup_noCollision_eq_f : forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. induction x1; intuition; simpl in *. remember (split x1) as z. destruct z. simpl in *. unfold collidesWith in *. simpl in *. case_eq (eqb b2 b1); intuition. rewrite H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem randomFunc_mem_preserves_coll : forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (randomFunc_mem _ _ RndR c0 d)) -> funcCollision _ _ (fst (split b0)) = true. 
Col Y P Q /\ Col Y U V}. Proof with Geometry. intros. assert (P <> Q). eapply par_aux_1. apply H... assert (T := A2a P Q (S P U V / S4 P U Q V))... elim T; intro O; intros... decompose [and] p... clear T p...cut (O ** Q / P ** Q = - (S Q U V / S4 P U Q V))... intro...assert (S O U V = P ** O / P ** Q * S Q U V + O ** Q / P ** Q * S P U V)... apply l2_9...assert (P ** O / P ** Q = S P U V / S4 P U Q V)... rewrite H2... field... clear H2; rename H5 into H2...rewrite H2 in H4... rewrite H3 in H4... assert (S O U V = 0)... rewrite H4; field...exists O... assert (P ** O / P ** Q = S P U V / S4 P U Q V)... rewrite H2; field... clear H2; rename H3 into H2...assert (P ** Q + Q ** O = P ** O)... rewrite <- H3 in H2... assert (O ** Q / P ** Q = 1 - S P U V / S4 P U Q V)... rewrite <- H2... assert (O ** Q = - Q ** O)... rewrite H4... field...assert (1 - S P U V / S4 P U Q V = (S4 P U Q V - S P U V) / S4 P U Q V)... field... rewrite H5 in H4... clear H5... unfold S4 in H4... assert (S P U Q + S P Q V - S P U V = - S Q U V)... assert (S P Q V = S P Q U + S P U V + S U Q V)... rewrite H5... assert (S P Q U = - S P U Q)... rewrite H6... assert (S U Q V = - S Q U V)... rewrite H7... ring... rewrite H5 in H4... rewrite H4... unfold S4 in |- *... field... Qed.Lemma inter_ll_ex : forall P Q U V : Point, ~ parallel P Q U V -> exists Y, inter_ll Y P Q U V. Proof with intuition. intros. assert {Y : Point | Col Y P Q /\ Col Y U V}. apply inter_llex... DecompExAnd H0 Y. exists Y. unfold inter_ll... Qed. Theorem on_parallelex : forall P Q R : Point, Q<>R -> ~ Col P Q R -> exists Y, parallel Q R P Y. 
n⁺ = m  m ^ n. Proof with eauto; try congruence. intros m Hm n Hn. eapply func_ap. apply binExp_is_func. apply SepI. apply CPrdI. apply CPrdI... apply ω_inductive... apply mul_ran... split; zfc_simple. split. apply ω_inductive... cut (m ^ n = (Exp m)[n]). intros. rewrite H. rewrite exp_m_suc; auto. eapply func_ap. apply binExp_is_func. apply SepI. apply CPrdI. apply CPrdI... apply exp_m_ran... split; zfc_simple. split... Qed.Lemma exp_m_ap : ∀ m n ∈ ω, (Exp m)[n] = m ^ n. Proof with auto. intros m Hm n Hn. generalize dependent m. ω_induction n; intros k Hk. - rewrite exp_m_0, exp_0_r... - cut ((Exp k)[m] = k ^ m). intros. rewrite exp_suc, exp_m_suc, H... apply IH... Qed.Example add_1_1 : 1 + 1 = 2. Proof with auto. rewrite pred, add_suc, add_0_r; auto; repeat apply ω_inductive. Qed.Example add_1_2 : 1 + 2 = 3. Proof. rewrite (pred 2), add_suc, (pred 1), add_suc, add_0_r; auto; repeat apply ω_inductive... Qed.Example mul_2_2 : 2  2 = 4. Proof with auto. rewrite (pred 2), mul_suc, (pred 1), mul_suc, mul_0_r, add_0_r, add_suc, add_suc, add_0_r; auto; repeat apply ω_inductive... Qed. Theorem add_assoc : ∀ m n p ∈ ω, (m + n) + p = m + (n + p). Proof with auto. intros n Hn m Hm p Hp. generalize dependent n. generalize dependent m. ω_induction p; intros n Hn k Hk. - repeat rewrite add_0_r... - repeat rewrite add_suc... rewrite IH... Qed.Lemma add_0_l : ∀n ∈ ω, 0 + n = n. Proof with nauto. intros n Hn. ω_induction n. rewrite add_0_r... rewrite add_suc... rewrite IH... Qed.Lemma add_suc' : ∀ m n ∈ ω, m⁺ + n = (m + n)⁺. Proof with auto. intros m Hm n Hn. generalize dependent m. ω_induction n; intros k Hk. - repeat rewrite add_0_r... apply ω_inductive... - repeat rewrite add_suc... rewrite IH... apply ω_inductive... Qed. Theorem add_comm : ∀ m n ∈ ω, m + n = n + m. Proof with auto. intros n Hn m Hm. ω_destruct m. rewrite add_0_l, add_0_r... rewrite add_suc... clear Hm. generalize dependent m. ω_induction n; intros k Hk. - rewrite add_0_l, add_0_r... apply ω_inductive... - rewrite add_suc, add_suc'... rewrite IH... apply ω_inductive... Qed.Corollary add_comm_123_213 : ∀ m n p ∈ ω, m + n + p = n + m + p. Proof with auto. intros m Hm n Hn p Hp. rewrite add_comm... rewrite (add_comm (n + m))... rewrite (add_comm m)... Qed. Theorem mul_distr : ∀ m n p ∈ ω, m  (n + p) = m  n + m  p. 
goal with | H : doLeader ?d ?h = _, H' : type ?d = _ |- _ => replace d with (snd (nwState net h)) in H by (repeat find_rewrite; reflexivity); replace d with (snd (nwState net h)) in H' by (repeat find_rewrite; reflexivity) end. find_eapply_lem_hyp leaders_have_leaderLogs_strong_invariant; eauto. exists h. break_exists_exists. repeat find_rewrite. eexists; intuition eauto using Prefix_refl; auto. * simpl in *. repeat find_rewrite. eapply sorted_findGtIndex_0; eauto. * simpl in *. repeat find_higher_order_rewrite. rewrite_update. eauto. + subst. break_exists. intuition. find_apply_lem_hyp findAtIndex_elim. intuition. subst. match goal with | H : doLeader ?d ?h = _, H' : type ?d = _, H'' : context [log ?d] |- _ => replace d with (snd (nwState net h)) in H by (repeat find_rewrite; reflexivity); replace d with (snd (nwState net h)) in H' by (repeat find_rewrite; reflexivity); replace d with (snd (nwState net h)) in H'' by (repeat find_rewrite; reflexivity); replace d with (snd (nwState net h)) by (repeat find_rewrite; reflexivity) end. find_copy_apply_lem_hyp lift_log_matching. unfold log_matching, log_matching_hosts in *. intuition. match goal with | H : forall _ _, In _ _ -> _ |- _ => specialize (H h x0); conclude H ltac:(unfold deghost in *; repeat (break_match; simpl in *); repeat (simpl in *; find_rewrite); auto) end. find_eapply_lem_hyp leaders_have_leaderLogs_strong_invariant; eauto. exists h. break_exists. intuition. exists x1. repeat (find_rewrite; simpl in *). do_in_app. intuition. * find_copy_eapply_lem_hyp findGtIndex_app_in_1; eauto. break_exists_exists. exists nil. intuition; simpl in *; auto; eauto using sorted_app_in_1; [rewrite app_nil_r; auto|]. clear H18. find_higher_order_rewrite. rewrite_update. simpl in *. auto. * { find_copy_eapply_lem_hyp findGtIndex_app_in_2; eauto. exists x2. break_exists_exists. intuition; simpl in *; auto; intuition eauto. - clear H18. find_higher_order_rewrite. rewrite_update. auto. - right. left. eexists; intuition; eauto. match goal with | |- Prefix_sane ?l _ _ => unfold Prefix_sane; destruct l; intuition end; try rewrite app_nil_r in *; eauto using findGtIndex_app_eq. left. intuition. congruence. } + exfalso. break_exists. intuition. replace d with (snd (nwState net h)) in * by (repeat find_rewrite; reflexivity). find_eapply_lem_hyp nextIndex_sanity; eauto. break_exists. congruence. Qed. Lemma append_entries_leaderLogs_init : refined_raft_net_invariant_init append_entries_leaderLogs. Proof using. red. unfold append_entries_leaderLogs, step_async_init. intros. simpl in *. intuition. Qed. Lemma append_entries_leaderLogs_state_same_packets_subset : refined_raft_net_invariant_state_same_packet_subset append_entries_leaderLogs. Proof using. red. unfold append_entries_leaderLogs. intros. find_apply_hyp_hyp. eapply_prop_hyp In In; eauto. break_exists_exists; intuition; eauto; repeat find_reverse_higher_order_rewrite; eauto. Qed. Lemma append_entries_leaderLogs_reboot : refined_raft_net_invariant_reboot append_entries_leaderLogs. Proof using. red. unfold append_entries_leaderLogs. intros. repeat find_rewrite. eapply_prop_hyp In In; eauto. break_exists_exists; intuition; eauto; repeat find_higher_order_rewrite; update_destruct; subst; rewrite_update; simpl in *; repeat find_rewrite; auto. Qed. Theorem append_entries_leaderLogs_invariant : forall net, refined_raft_intermediate_reachable net -> append_entries_leaderLogs net. 
term end | _ => term end.Ltac clean_zabs_N term := match term with context id [(Z.abs_N ?X)] => match is_ZCst X with true => let x := eval vm_compute in (Z.abs_N X) in let y := context id [x] in clean_zabs_N y | false => term end | _ => term end.Ltac eqterm t1 t2 := match constr:((t1,t2)) with (?X, ?X) => true | _ => false end.Theorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z. intros; apply trans_equal with y; auto. Qed.Open Scope nat_scope.Theorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c. intros; apply f_equal2 with (f := plus); auto. Qed.Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c. intros a b c H H1; case H. apply plus_reg_l with a; auto. Qed.Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m. intros n m p H; unfold ge; apply plus_le_compat_l; auto. Qed.Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c. intros a b c H H1; case H; subst; auto. Qed.Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m. intros n m p H; unfold ge; apply plus_le_reg_l with p; auto. Qed. Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem eq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). intros x y z H; rewrite H; auto. Qed. Theorem eq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y). intros x y z H; rewrite H; auto. Qed. Theorem eq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z). intros x y z H; rewrite H; auto. Qed. Theorem eq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y). 
*; intros nz1; absurd (zeroP (A:=A) A0 eqA (n:=n) b0); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := d0); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem divP_multTerm_l : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c a. intros a b c H' H'0 H'1. apply divP_comp with (a := multTerm (A:=A) multA (n:=n) a b) (c := a); auto. Qed. Theorem divP_multTerm_r : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c b. intros a b c H' H'0 H'1. apply divP_comp with (a := multTerm (A:=A) multA (n:=n) a b) (c := b); auto. Qed. Hint Resolve divP_multTerm_r divP_multTerm_l. Theorem divP_ppcl : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (ppc a b) a. intros a b H' H'0; try assumption. lapply (ppc_is_ppcm a b); [ intros H'3; lapply H'3; clear H'3; [ intros H'4 | idtac ] | idtac ]; auto; auto. inversion H'4; auto. Qed. Theorem divP_ppcr : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (ppc a b) b. intros a b H' H'0; try assumption. lapply (ppc_is_ppcm a b); [ intros H'3; lapply H'3; clear H'3; [ intros H'4 | idtac ] | idtac ]; auto; auto. inversion H'4; auto. Qed. Hint Resolve divP_ppcl divP_ppcr. Theorem divTerm_compo : forall (a b c : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c), divP a b -> divP b c -> eqTerm (A:=A) eqA (n:=n) (divTerm a nZc) (multTerm (A:=A) multA (n:=n) (divTerm a nZb) (divTerm b nZc)). intros a b c nZb nZc H'; inversion H'. intros H'0; inversion H'0. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := divTerm (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b) nZc); auto. Qed. Hint Resolve divTerm_compo. Theorem divP_comp_ppc0 : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (nZppab : ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b)) (p : list (Term A n)), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) a b) nZppab) (divTerm (ppc a b) nZa)). 
UU } ( R : hrel X ) ( f : X -> Y ) := forall x x' : X , R x x' -> paths ( f x ) ( f x' ) .Lemma iscomprelfunlogeqf { X Y : UU } { R L : hrel X } ( lg : hrellogeq L R ) ( f : X -> Y ) ( is : iscomprelfun L f ) : iscomprelfun R f . Proof . intros . intros x x' r . apply ( is _ _ ( pr2 ( lg _ _ ) r ) ) . Defined . Lemma isapropimeqclass { X : UU } ( R : hrel X ) ( Y : hSet ) ( f : X -> Y ) ( is : iscomprelfun R f ) ( c : setquot R ) : isaprop ( image ( fun x : c => f ( pr1 x ) ) ) . Proof. intros. apply isapropsubtype . intros y1 y2 . simpl . apply ( @hinhuniv2 _ _ ( hProppair ( paths y1 y2 ) ( pr2 Y y1 y2 ) ) ) . intros x1 x2 . simpl . destruct c as [ A iseq ] . destruct x1 as [ x1 is1 ] . destruct x2 as [ x2 is2 ] . destruct x1 as [ x1 is1' ] . destruct x2 as [ x2 is2' ] . simpl in is1 . simpl in is2 . simpl in is1' . simpl in is2' . assert ( r : R x1 x2 ) . apply ( eqax2 iseq _ _ is1' is2' ) . apply ( pathscomp0 ( pathsinv0 is1 ) ( pathscomp0 ( is _ _ r ) is2 ) ) . Defined . Theorem setquotuniv { X : UU } ( R : hrel X ) ( Y : hSet ) ( f : X -> Y ) ( is : iscomprelfun R f ) ( c : setquot R ) : Y . Proof. intros. apply ( pr1image ( fun x : c => f ( pr1 x ) ) ) . apply ( @hinhuniv ( pr1 c ) ( hProppair _ ( isapropimeqclass R Y f is c ) ) ( prtoimage ( fun x : c => f ( pr1 x ) ) ) ) . apply ( eqax0 ( pr2 c ) ) . Defined . Theorem setquotunivcomm { X : UU } ( R : eqrel X ) ( Y : hSet ) ( f : X -> Y ) ( is : iscomprelfun R f ) : forall x : X , paths ( setquotuniv R Y f is ( setquotpr R x ) ) ( f x ) . 
pbfree l1 (pbadd a l3 l2). Proof using. intros a l1 l2; generalize a l1; elim l2; simpl in |- *; auto. intros a0 l0 l3 H H0; case H0; auto. intros a0; case a0. intros l H a1 l0; case l0. intros l3 H0; inversion H0. intros b; case b; simpl in |- *; auto. intros l3 l4; case l4; simpl in |- *; auto. intros a2 H0 H1 H2; apply pbfree_right2. apply pbfree_pbadd_prop1; auto. intros p H0 H1 H2; apply pbfree_node2. apply pbfree_pbadd_prop1; auto. intros a2 H0 H1 H2; apply pbfree_right2. apply H; auto. inversion H0; auto. intros p p0 H0 H1 H2; apply pbfree_node2. apply H; auto. inversion H0; auto. intros l3 l4; case l4; simpl in |- *; auto. intros p H0 H1 H2; apply pbfree_node1. inversion H0; auto. intros p p0 H0 H1 H2; apply pbfree_node1. inversion H0; auto. intros l H a1 l0; case l0. intros l3 H0; inversion H0. intros b; case b; simpl in |- *; auto. intros l3 l4; case l4; simpl in |- *; auto. intros p H0 H1 H2; apply pbfree_node2. inversion H0; auto. intros p p0 H0 H1 H2; apply pbfree_node2. inversion H0; auto. intros l3 l4; case l4; simpl in |- *; auto. intros a2 H0 H1 H2; apply pbfree_left2. apply pbfree_pbadd_prop1; auto. intros a2 H0 H1 H2; apply pbfree_left2. apply H; auto. inversion H0; auto. intros p H0 H1 H2; apply pbfree_node1. apply pbfree_pbadd_prop1; auto. intros p p0 H0 H1 H2; apply pbfree_node1. apply H; auto. inversion H0; auto. Qed. Theorem distinct_pbleaves_pbadd_prop1 : forall a a1 l1, distinct_pbleaves (pbadd a1 (pbleaf a) l1). Proof using. intros a a1 l1; generalize a a1; elim l1; simpl in |- *; auto; clear a a1 l1. intros a2; case a2; auto. Qed. Theorem in_pbleaf_node : forall a1 a2 a3 a4 l, ~ inpb (pbnode a1 a2) (pbadd a3 (pbleaf a4) l). Proof using. intros a1 a2 a3 a4 l; generalize a1 a2 a3 a4; elim l; simpl in |- *; auto; clear a1 a2 a3 a4 l. intros a1 a2 a3 a4; red in |- *; intros H; inversion H. intros a; case a. intros l H a1 a2 a3 a4; red in |- *; intros H0; case (H a1 a2 a3 empty). inversion H0; auto. intros l H a1 a2 a3 a4; red in |- *; intros H0; case (H a1 a2 a3 empty). inversion H0; auto. Qed. Theorem inpbleaf_eq : forall a1 a2 a3 l, inpb (pbleaf a1) (pbadd a2 (pbleaf a3) l) -> a1 = a2. 
(A B: Type) (f: B -> positive -> A -> B) m i v l, List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. apply fold1_xelements with (l := @nil (positive * A)). Qed.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. 
exploit in_xkeys. eexact H0. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H0. destruct H0. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall (A: Type) (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil. Proof. induction m; intros. auto. rewrite xelements_node. rewrite IHm1, IHm2. destruct o; auto. generalize (H xH); simpl; congruence. intros. apply (H (xI i0)). intros. apply (H (xO i0)). Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros until n. unfold elements. generalize 1%positive. revert m n. induction m; intros. - simpl. rewrite xelements_empty. constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. - destruct n as [ | n1 o' n2 ]. + rewrite (xelements_empty (Node m1 o m2)). simpl; constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. + rewrite ! xelements_node. repeat apply list_forall2_app. apply IHm1. intros. apply (H (xO i)). generalize (H xH); simpl; intros OR; inv OR. constructor. constructor. auto. constructor. apply IHm2. intros. apply (H (xI i)). Qed. Theorem elements_canonical_order: forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) -> (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros. apply elements_canonical_order'. intros. destruct (get i m) as [x|] eqn:GM. exploit H; eauto. intros (y & P & Q). rewrite P; constructor; auto. destruct (get i n) as [y|] eqn:GN. exploit H0; eauto. intros (x & P & Q). congruence. constructor. Qed. Theorem elements_extensional: forall (A: Type) (m n: t A), (forall i, get i m = get i n) -> elements m = elements n. 
powerRZ radix (Fexp p))%R. apply Rle_monotone_exp; auto with zarith; repeat rewrite Rmult_IZR; apply Rle_IZR; unfold pPred in |- *; apply Zle_Zpred; auto with float real zarith. apply Rmult_le_compat_l; auto with real zarith. replace 0%R with (IZR 0); auto with real; apply Rle_IZR; unfold pPred in |- *; apply Zle_Zpred; auto with float zarith. apply Rle_powerRZ; auto with float real zarith. Qed. Theorem FnormalBoundAbs : forall p : float, Fnormal p -> (Float (pPred (vNum b)) (Zpred (Fexp p)) < Fabs p)%R. intros p H'; unfold FtoRradix, FtoR in |- *; simpl in |- *. pattern (Fexp p) at 2 in |- *; replace (Fexp p) with (Zsucc (Zpred (Fexp p))); [ rewrite powerRZ_Zs; auto with real zarith | unfold Zsucc, Zpred in |- *; ring ]. repeat rewrite <- Rmult_assoc. apply Rmult_lt_compat_r; auto with real arith. rewrite <- Rmult_IZR; apply Rlt_IZR. unfold pPred in |- *; cut (Zpos (vNum b) <= Zabs (Fnum p) * radix)%Z; auto with zarith. rewrite <- (Zabs_eq radix); auto with float zarith; rewrite <- Zabs_Zmult; rewrite Zmult_comm; auto with float real zarith. Qed. Definition Fsubnormal (p : float) := Fbounded b p /\ Fexp p = (- dExp b)%Z /\ (Zabs (radix * Fnum p) < Zpos (vNum b))%Z. Theorem FsubnormalFbounded : forall p : float, Fsubnormal p -> Fbounded b p. intros p H; case H; auto. Qed. Theorem FsubnormalFexp : forall p : float, Fsubnormal p -> Fexp p = (- dExp b)%Z. intros p H; case H; auto. intros H1 H2; case H2; auto. Qed. Theorem FsubnormalBound : forall p : float, Fsubnormal p -> (Zabs (radix * Fnum p) < Zpos (vNum b))%Z. intros p H; case H; auto. intros H1 H2; case H2; auto. Qed. Hint Resolve FsubnormalFbounded FsubnormalBound FsubnormalFexp: float. Theorem FsubnormFopp : forall p : float, Fsubnormal p -> Fsubnormal (Fopp p). intros p H'; repeat split; simpl in |- *; auto with zarith float. rewrite Zabs_Zopp; auto with float. rewrite <- Zopp_mult_distr_r; rewrite Zabs_Zopp; auto with float. Qed. Theorem FsubnormFabs : forall p : float, Fsubnormal p -> Fsubnormal (Fabs p). intros p; case p; intros a e H; split; auto with float. simpl in |- *; split; auto with float. case H; intros H1 (H2, H3); auto. rewrite <- (Zabs_eq radix); auto with zarith. rewrite <- Zabs_Zmult. rewrite (fun x => Zabs_eq (Zabs x)); auto with float zarith. case H; intros H1 (H2, H3); auto. Qed. Theorem FsubnormalUnique : forall p q : float, Fsubnormal p -> Fsubnormal q -> p = q :>R -> p = q. 
(remove i m) = l1 ++ l2. Proof. intros. exploit xelements_remove. eauto. instantiate (1 := xH). rewrite prev_append_prev. auto. Qed. Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B) (i: positive) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := xfold f (xO i) l v in xfold f (xI i) r v1 | Node l (Some x) r => let v1 := xfold f (xO i) l v in let v2 := f v1 (prev i) x in xfold f (xI i) r v2 end. Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) := xfold f xH m v. Lemma xfold_xelements: forall (A B: Type) (f: B -> positive -> A -> B) m i v l, List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. 
: A) (n : nat), fast_power_cps x ret n = power x n * ret. Proof. Opaque Nat.div2. intros. revert x ret. induction n using lt_wf_ind; intros. rewrite fast_power_cps_equation. destruct n. - monoid_simpl. auto. - pose proof (even_odd_double (S n)). unfold Nat.double in H1; intuition. destruct (even_odd_dec (S n)); pose proof (lt_div2 (S n) (Nat.lt_0_succ n)); pose proof (H0 (Nat.div2 (S n)) H3); rewrite H6; monoid_simpl; f_equal; rewrite <- power_sqr; rewrite power_of_power. + replace (x * x ** n) with (x ** (1 + n)). * f_equal. simpl; rewrite <- plus_n_O; intuition. * rewrite power_add_dist. monoid_simpl. auto. + rewrite power_commute_with_x. f_equal. f_equal. simpl; rewrite <- plus_n_O. intuition. Qed. Theorem fast_power_ok : forall (x : A) (n : nat), fast_power x n = power x n. Proof. intros; pose proof (fast_power_cps_ok x one n) as F. unfold fast_power. rewrite F. monoid_simpl; auto. Qed. End Power. Module Fibonacci. Import ZMatrix2. Open Scope Z_scope. Definition base : ZMatrix2 := {| c00 := 1; c01 := 1; c10 := 1; c11 := 0; |} % Z. Compute @power ZMatrix2 ZMatrix2_mul (Unit2 0 1) base 5. Function fibnoacci (n : nat) {measure (fun i => i) n} : Z := match n with | O => 0 | S O => 1 | S (S n) => fibnoacci n + fibnoacci (S n) end. Proof. + intros; omega. + intros; omega. Qed. Notation power := (@power ZMatrix2 ZMatrix2_mul (Unit2 0 1)). Notation fast_power := (@fast_power ZMatrix2 ZMatrix2_mul (Unit2 0 1)). Definition fast_fibnoacci (n : nat) : Z := match n with | O => 0 | _ => c11 (fast_power base (S n)) end. Theorem fast_fibnoacci_matrix : forall (n : nat) (m : ZMatrix2), m = fast_power base (S n) -> c00 m = fibnoacci (2+n) /\ c01 m = fibnoacci (1+n) /\ c10 m = fibnoacci (1+n) /\ c11 m = fibnoacci n. Proof. induction n; intros; rewrite fast_power_ok in H. + simpl in H. repeat (rewrite fibnoacci_equation; simpl). unfold Unit2 in H; destruct m. inversion H; subst. simpl. tauto. + Opaque Z.add Z.mul. rewrite fast_power_ok in IHn. pose proof (IHn (power base (S n)) eq_refl); clear IHn. replace (power base (S (S n))) with (ZMatrix2_mul base (power base (S n))) in H; auto. remember (power base (S n)) as m'; clear Heqm'; subst. destruct m'; simpl in H0. unfold ZMatrix2_mul, base in *; repeat (rewrite fibnoacci_equation in *; simpl in *); intuition. Qed. Theorem fast_fibnoacci_ok : forall (n : nat), fast_fibnoacci n = fibnoacci n. 
Import EqNotations. From Perennial.Helpers Require Import Map. From Perennial.algebra Require Import auth_map liftable log_heap async.From Goose.github_com.mit_pdos.go_journal Require Import jrnl. From Perennial.program_logic Require Export ncinv. From Perennial.program_proof Require Import buf.buf_proof addr.addr_proof obj.obj_proof. From Perennial.program_proof Require jrnl.jrnl_proof. From Perennial.program_proof Require Import disk_prelude. From Perennial.goose_lang.lib Require Import slice.typed_slice. From Perennial.goose_lang.ffi Require Import disk_prelude. From Perennial.program_proof Require Import jrnl.sep_jrnl_invariant. Module mspec := jrnl.jrnl_proof.Section goose_lang. Context `{!jrnlG Σ}. Context `{!heapGS Σ}. Context (N:namespace). Implicit Types (l: loc) (γ: jrnl_names) (γtxn: gname). Implicit Types (obj: object). Theorem wp_Op__Begin' (l_txn: loc) γ dinit : {{{ is_txn l_txn γ.(jrnl_txn_names) dinit ∗ is_txn_system N γ }}} Begin #l_txn {{{ γtxn γdurable l, RET #l; "Hjrnl_mem" ∷ is_jrnl_mem N l γ dinit γtxn γdurable ∗ "Hdurable_frag" ∷ map_ctx γdurable (1/2)  }}}. Proof. iIntros (Φ) "Hpre HΦ". iDestruct "Hpre" as "[#His_txn #Htxn_inv]". iApply wp_fupd. wp_apply (mspec.wp_jrnl_Begin with "His_txn"). iIntros (l) "Hjrnl". iMod (map_init  ) as (γtxn) "Hctx". iMod (map_init  ) as (γdurable) "[Hdurable Hdurable_frag]". iModIntro. iApply "HΦ". iFrame "Hdurable_frag". iExists  , false. rewrite !fmap_empty. iFrame "Hctx". iFrame "∗#". auto with iFrame. Qed. Theorem wp_Op__Begin (l_txn: loc) γ dinit : {{{ is_txn l_txn γ.(jrnl_txn_names) dinit ∗ is_txn_system N γ }}} Begin #l_txn {{{ γtxn l, RET #l; is_jrnl N l γ dinit γtxn (λ _, emp) }}}. 
R TF TR (out out': recover_outcome TF TR), routcome_disk_R R out out' <-> routcome_disk_R_conv R out' out. Proof. split; destruct out, out'; simpl; intros; repeat deex; match goal with | [ H: @eq (recover_outcome _ _) _ _ |- _ ] => inversion H; subst end; eauto. Qed.Hint Constructors ExecRecover.R exec_recover.Theorem exec_recover_is_R : forall TF TR d vm hm (p: prog TF) (r: prog TR) out, exec_recover d vm hm p r out <-> ExecRecover.R exec possible_crash d vm hm p r out. Proof. split; induction 1; eauto. Qed.Theorem exec_recover_without_sync : forall TF TR d vm hm (p: prog TF) (r: prog TR) out, ExecRecover.R (@Exec.R possible_sync) possible_crash d vm hm p r out -> exists out', ExecRecover.R (@Exec.R eq) possible_crash d vm hm p r out' /\ routcome_disk_R possible_sync out' out. Proof. induction 1; simpl; repeat match goal with | [ H: Exec.R possible_sync _ _ _ _ _ |- _ ] => apply exec_sync_obs_irrelevant in H; simpl in H | [ H: outcome_obs_le _ _ |- _ ] => apply outcome_obs_ge_ok in H; progress simpl in H | [ H: routcome_disk_R _ _ _ |- _ ] => apply routcome_disk_R_conv_ok in H; progress simpl in H | [ H: possible_sync ?m ?m', H': possible_crash ?m' ?m'' |- _ ] => lazymatch goal with | [ H: possible_crash m m'' |- _ ] => fail | _ => pose proof possible_crash_possible_sync_trans H H' end | _ => progress subst | _ => deex end; try solve [ eexists; intuition eauto; simpl; eauto ]. Qed.Module PhysicalSemantics. Definition flush_disk (d d': rawdisk) := forall a, match d a with | None => d' a = None | Some (v, vs) => exists n, d' a = Some (v, firstn n vs) end. Theorem flush_disk_refl : forall d, flush_disk d d. Proof. unfold flush_disk; intros. destruct (d a) as [ [? ?] | ]; auto. exists (length l). rewrite firstn_all. eauto. Qed. Theorem flush_disk_trans : forall d d' d'', flush_disk d d' -> flush_disk d' d'' -> flush_disk d d''. Proof. unfold flush_disk; intros. specialize (H a). specialize (H0 a). destruct (d a) as [ [? ?] | ]; destruct (d' a) as [ [? ?] | ]; repeat deex; inv_opt; try congruence. rewrite firstn_firstn in H0. eauto. Qed. Lemma firstn_incl : forall A (l: list A) n, incl (firstn n l) l. Proof. unfold incl. apply ListUtils.in_firstn_in. Qed. Hint Resolve firstn_incl. Theorem flush_disk_is_sync : forall d d', flush_disk d d' -> possible_sync (AEQ:=addr_eq_dec) d d'. 
Set Warnings "-notation-overridden,-parsing". Require Export IndProp.Definition relation (X: Type) := X -> X -> Prop.Print le.Check le : nat -> nat -> Prop. Check le : relation nat. Definition partial_function {X: Type} (R: relation X) := forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.Print next_nat.Check next_nat : relation nat.Theorem next_nat_partial_function : partial_function next_nat. Proof. unfold partial_function. intros x y1 y2 H1 H2. inversion H1. inversion H2. reflexivity. Qed.Theorem le_not_a_partial_function : ~ (partial_function le). Proof. unfold not. unfold partial_function. intros Hc. assert (0 = 1) as Nonsense. { apply Hc with (x := 0). - apply le_n. - apply le_S. apply le_n. } inversion Nonsense. Qed. Definition reflexive {X: Type} (R: relation X) := forall a : X, R a a.Theorem le_reflexive : reflexive le. Proof. unfold reflexive. intros n. apply le_n. Qed. Definition transitive {X: Type} (R: relation X) := forall a b c : X, (R a b) -> (R b c) -> (R a c).Theorem le_trans : transitive le. Proof. intros n m o Hnm Hmo. induction Hmo. - apply Hnm. - apply le_S. apply IHHmo. Qed.Theorem lt_trans: transitive lt. Proof. unfold lt. unfold transitive. intros n m o Hnm Hmo. apply le_S in Hnm. apply le_trans with (a := (S n)) (b := (S m)) (c := o). apply Hnm. apply Hmo. Qed. Theorem lt_trans' : transitive lt. Proof. unfold lt. unfold transitive. intros n m o Hnm Hmo. induction Hmo as [| m' Hm'o]. Admitted.Theorem lt_trans'' : transitive lt. Proof. unfold lt. unfold transitive. intros n m o Hnm Hmo. induction o as [| o']. Admitted. Theorem le_Sn_le : forall n m, S n <= m -> n <= m. Proof. intros n m H. apply le_trans with (S n). - apply le_S. apply le_n. - apply H. Qed. Theorem le_S_n : forall n m, (S n <= S m) -> (n <= m). Proof. Admitted. [] *) Theorem le_Sn_n : forall n, ~ (S n <= n). Proof. Admitted.Definition symmetric {X: Type} (R: relation X) := forall a b : X, (R a b) -> (R b a). Theorem le_not_symmetric : ~ (symmetric le). 
then true else false. #[deprecated(since="2021-09-21", note="Use [byte_to_N_inj]")] Notation to_N_inj := byte_to_N_inj. End BS. Export Bytestring_notations.Fixpoint bs_cmp (xs ys : bs) : comparison := match xs , ys with | BS.EmptyString , BS.EmptyString => Eq | BS.EmptyString , _ => Lt | _ , BS.EmptyString => Gt | BS.String x xs , BS.String y ys => match byte_cmp x y with | Eq => bs_cmp xs ys | x => x end end%bs.Module OT_bs <: OrderedType.OrderedType with Definition t := bs. Definition t := bs. Definition eq := @eq bs. Definition lt := fun l r => bs_cmp l r = Lt. Theorem lm x y : CompareSpec (x = y) (lt x y) (lt y x) (bs_cmp x y). Proof. revert y; induction x; destruct y; simpl. - constructor; reflexivity. - constructor. reflexivity. - constructor. reflexivity. - unfold lt; simpl. destruct (byte_cmp_spec b b0); simpl. + subst. destruct (IHx y); constructor; eauto. congruence. destruct (byte_cmp_spec b0 b0); try congruence. red in H0. rewrite OT_byte.eq_refl in H0. congruence. + constructor; auto. + red in H. rewrite H. constructor; auto. Qed. Definition compare (x y : t) : OrderedType.Compare lt eq x y. Proof. refine ( match bs_cmp x y as X return bs_cmp x y = X -> OrderedType.Compare lt eq x y with | Eq => fun pf => OrderedType.EQ _ | Lt => fun pf => OrderedType.LT pf | Gt => fun pf => OrderedType.GT _ end (Logic.eq_refl)); abstract (generalize (lm x y); rewrite pf; inversion 1; auto). Defined. Theorem eq_refl (x : t) : eq x x. Proof. reflexivity. Qed. Theorem eq_sym (x y : t) : eq x y -> eq y x. Proof. eapply eq_sym. Qed. Theorem eq_trans (x y z : t) : eq x y -> eq y z -> eq x z. Proof. eapply eq_trans. Qed. Theorem lt_trans (x y z : t) : lt x y -> lt y z -> lt x z. Proof. unfold lt. revert y z. induction x; destruct y; simpl; try congruence. - destruct z; congruence. - destruct (byte_cmp_spec b b0); subst. + destruct z; auto. destruct (byte_cmp b0 b); auto. eauto. + destruct z; auto. red in H. destruct (byte_cmp b0 b1) eqn:?. * generalize (byte_cmp_spec b0 b1). rewrite Heqc. inversion 1. subst. rewrite H. auto. * generalize (OT_byte.lt_trans _ _ _ H Heqc). unfold OT_byte.lt. intro X; rewrite X. auto. * congruence. + congruence. Qed. Theorem lt_not_eq (x y : t) : lt x y -> ~ eq x y. 
n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. Admitted. Theorem leb_refl : forall n:nat, true = leb n n. Admitted. Theorem zero_nbeq_S : forall n:nat, beq_nat 0 (S n) = false. Admitted. Theorem andb_false_r : forall b : bool, andb b false = false. Admitted. Derive ArbitrarySizedSuchThat for (fun m => le n m). Derive SizeMonotonicSuchThatOpt for (fun m => le n m). Derive GenSizedSuchThatSizeMonotonicOpt for (fun m => le n m). Derive SizedProofEqs for (fun m => le n m). Derive GenSizedSuchThatCorrect for (fun m => le n m).Theorem plus_ble_compat_l : forall n m p : nat, leb n m = true -> leb (p + n) (p + m) = true. Admitted.Theorem S_nbeq_0 : forall n:nat, beq_nat (S n) 0 = false. Admitted. Theorem mult_1_l : forall n:nat, 1 * n = n. Admitted. Theorem all3_spec : forall b c : bool, orb (andb b c) (orb (negb b) (negb c)) = true. Admitted. Theorem mult_plus_distr_r : forall n m p : nat, (n + m) * p = (n * p) + (m * p). Admitted. Theorem mult_assoc : forall n m p : nat, n * (m * p) = (n * m) * p. 
subtree * dirlist_pred (tree_pred xp) ents =p=> dirlist_pred (tree_pred xp) (add_to_list name subtree ents). Proof. intros. apply dirlist_pred_absorb_notin'; auto. eapply notindomain_not_in_dirents; eauto. eapply tree_dir_names_pred_nodup; eauto. Qed. Lemma dir_names_pred_add : forall l m name subtree, tree_dir_names_pred' l m -> tree_dir_names_pred' (add_to_list name subtree l) (Mem.upd m name (dirtree_inum subtree, dirtree_isdir subtree)). Proof. induction l; simpl; intros; auto. apply sep_star_comm. apply ptsto_upd_disjoint; auto. destruct a. destruct (string_dec s name); subst; simpl. eapply ptsto_upd; eauto. generalize H. unfold_sep_star; intuition. repeat deex. exists m1. eexists. intuition. 3: eapply IHl; eauto. apply functional_extensionality; intro. unfold Mem.upd, mem_union. destruct (string_dec x name); subst; auto. destruct (m1 name) eqn: Hx; auto. unfold ptsto in H2; intuition. pose proof (H3 _ n); congruence. unfold mem_disjoint, Mem.upd. intuition; repeat deex. destruct (string_dec a name); subst; auto. unfold ptsto in H2; intuition. pose proof (H6 _ n); congruence. unfold mem_disjoint in H0; repeat deex. firstorder. Qed. Lemma dir_names_pred_add_delete : forall l m name subtree, tree_dir_names_pred' (delete_from_list name l) m -> notindomain name m -> tree_dir_names_pred' (add_to_list name subtree l) (Mem.upd m name (dirtree_inum subtree, dirtree_isdir subtree)). Proof. induction l; simpl; intros; auto. apply sep_star_comm. apply ptsto_upd_disjoint; auto. destruct a. destruct (string_dec s name); subst; simpl in *. apply sep_star_comm. apply ptsto_upd_disjoint; auto. generalize H. unfold_sep_star; intros; repeat deex. exists m1; eexists; intuition. 3: eapply IHl; eauto. apply functional_extensionality; intro. unfold Mem.upd, mem_union. destruct (string_dec x name); subst; auto. destruct (m1 name) eqn: Hx; auto. unfold ptsto in H3; intuition. pose proof (H4 _ n); congruence. unfold mem_disjoint, Mem.upd. intuition; repeat deex. destruct (string_dec a name); subst; auto. unfold ptsto in H3; intuition. pose proof (H7 _ n); congruence. unfold mem_disjoint in H1; repeat deex. firstorder. eapply notindomain_mem_union; eauto. Qed. Lemma dirlist_pred_add_notin: forall xp ents name subtree, ~ In name (map fst ents) -> NoDup (map fst ents) -> dirlist_pred (tree_pred xp) (add_to_list name subtree ents) =p=> tree_pred xp subtree * dirlist_pred (tree_pred xp) ents. Proof. induction ents; intros; simpl; auto. destruct a. destruct (string_dec s name); subst; simpl. cancel. cancel. inversion H0. apply IHents; auto. Qed. Lemma dirlist_pred_add_delete : forall xp ents name subtree, NoDup (map fst ents) -> dirlist_pred (tree_pred xp) (add_to_list name subtree (delete_from_list name ents)) =p=> dirlist_pred (tree_pred xp) (add_to_list name subtree ents). Proof. induction ents; simpl; intros; auto. destruct a. destruct (string_dec s name); subst; simpl. inversion H; subst. apply dirlist_pred_add_notin; auto. destruct (string_dec s name); subst; simpl. congruence. cancel; apply IHents. inversion H; auto. Qed. Theorem tree_dir_names_pred_update' : forall fnlist subtree subtree' d, find_subtree fnlist d = Some subtree -> dirtree_inum subtree = dirtree_inum subtree' -> dirtree_isdir subtree = dirtree_isdir subtree' -> (dirtree_inum d, dirtree_isdir d) = (dirtree_inum (update_subtree fnlist subtree' d), dirtree_isdir (update_subtree fnlist subtree' d)). 
-> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q (s2p A A0 eqA n ltM b) -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a. intros a R H'; elim H'; auto. intros b Q H'0 H'1. apply CombLinear_0; auto. intros a0 p q s H'0 H'1 H'2 H'3 H'4 b Q H'5 H'6. apply CombLinear_comp with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply eqp_imp_canonical with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. 2: apply canonical_pluspf with (1 := os); auto. 2: apply canonical_mults with (1 := cs); auto. 2: apply inPolySet_imp_canonical with (L := R); auto. 2: apply CombLinear_canonical with (eqA_dec := eqA_dec) (ltM_dec := ltM_dec) (1 := cs) (Q := R); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply CombLinear_pluspf with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. 2: apply H'3 with (b := b); auto. case (inPolySet_addEnd q b Q); auto. rewrite <- H'5; auto. intros H'7; rewrite H'7; auto. intros; (apply CombLinear_id with (1 := cs); auto). Qed. Theorem Cb_trans : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a (addEnd b Q) -> Cb b Q -> Cb a Q. intros a b; case a; case b; simpl in |- *; auto. intros x c x0 H' Q H'0 H'1. apply CombLinear_trans1 with (R := addEnd (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c) Q) (b := exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c); auto. Qed. Theorem Cb_incl : forall (a : poly A0 eqA ltM) (P Q : list (poly A0 eqA ltM)), (forall a : poly A0 eqA ltM, In a P -> In a Q) -> Cb a P -> Cb a Q. intros a; case a; simpl in |- *; auto. intros x H' P Q H'0 H'1. apply CombLinear_incl with (1 := cs) (P := P); auto. intros a0 H'2. apply Incl_inp_inPolySet with (P := P); auto. Qed. Theorem Cb_in1 : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a Q -> Cb a (b :: Q). 
Context (LEM : forall P:Prop, P \/ ~P). Lemma classicalProvabilityTransport : H10UPC_SAT h10 -> nil ⊢C F (h10:=h10). Proof using LEM. intros [φ Hφ]. apply intuitionistic_is_classical. eapply transport_prove. exact Hφ. Qed. Lemma classicalProvabilityInverseTransport : nil ⊢C F (h10:=h10) -> H10UPC_SAT h10. Proof using LEM. intros H%(classical_soundness LEM). apply inverseTransport. intros D I rho. apply H. easy. Qed. End classical_provability. Section satisfiability. Context {h10 : list h10upc}. Lemma satisTransport : (~ H10UPC_SAT h10) -> satis ((F (ff:=falsity_on) (h10:=h10)) --> falsity). Proof. intros H. exists dom. exists (IB (h10:=h10)). exists (fun _ => Num 0). intros HF. apply H. eapply IB_fulfills. easy. Qed. Lemma satisInverseTransport : satis ((F (ff:=falsity_on) (h10:=h10)) --> falsity) -> (~ H10UPC_SAT h10). Proof. intros [D [I [rho HF]]] H. apply HF, (transport (ff:=falsity_on) H). Qed. End satisfiability. Section ksatisfiability. Context {h10 : list h10upc}. Lemma ksatisTransport : (~ H10UPC_SAT h10) -> ksatis ((F (ff:=falsity_on) (h10:=h10)) --> falsity). Proof. intros H. exists dom. pose (kripke_tarski (ff:=falsity_on) (IB (h10:=h10))) as Hk. exists (interp_kripke (IB (h10:=h10))). exists tt. exists (fun _ => Num 0). rewrite <- Hk. intros HF. apply H. eapply IB_fulfills. easy. Qed. Lemma ksatisInverseTransport : ksatis ((F (ff:=falsity_on) (h10:=h10)) --> falsity) -> (~ H10UPC_SAT h10). Proof. intros [D [M [u [rho HF]]]] H. specialize (HF u). apply HF. - apply reach_refl. - apply (kripkeTransport (ff:=falsity_on) H). Qed. End ksatisfiability.Require Import Undecidability.Synthetic.Definitions. Section undecResults. Definition minimalSignature (f:funcs_signature) (p:preds_signature) : Prop := match f,p with {|syms := F; ar_syms := aF|},{|preds := P; ar_preds := aP|} => (F -> False) /\ exists pp : P, aP pp = 2 end. Lemma sig_is_minimal : minimalSignature sig_empty sig_binary. Proof. split. * intros []. * now exists tt. Qed. Theorem validReduction : H10UPC_SAT ⪯ @valid sig_empty sig_binary falsity_off. Proof. exists (fun l => @F falsity_off l). split. * apply transport. * apply inverseTransport. Qed. Theorem satisReduction : complement H10UPC_SAT ⪯ @satis sig_empty sig_binary falsity_on. Proof. exists (fun l => @F falsity_on l --> falsity). split. * apply satisTransport. * apply satisInverseTransport. Qed. Theorem proveReduction : H10UPC_SAT ⪯ (fun (k:@form sig_empty sig_binary frag_operators falsity_off) => nil ⊢M k). Proof. exists (fun l => @F falsity_off l). split. * apply proofTransport. * apply inverseProofTransport. Qed. Theorem classicalProveReduction (LEM : forall P:Prop, P \/ ~P) : H10UPC_SAT ⪯ (fun (k:@form sig_empty sig_binary frag_operators falsity_off) => nil ⊢C k). Proof. exists (fun l => @F falsity_off l). split. * apply classicalProvabilityTransport, LEM. * apply classicalProvabilityInverseTransport, LEM. Qed. Theorem kripkeValidReduction : H10UPC_SAT ⪯ @kvalid sig_empty sig_binary falsity_off. 
arrayN a vs. Proof. induction vs; simpl; intuition. inversion H. destruct i; simpl. replace (a0 + 0) with (a0) by omega. replace (a0 + 1) with (S a0) by omega. cancel. eapply pimpl_trans; [ | apply pimpl_sep_star; [ apply pimpl_refl | apply IHvs ] ]; clear IHvs. 2: instantiate (1 := i); omega. simpl. replace (a0 + S i) with (S (a0 + i)) by omega. cancel. Qed. Theorem isolateN_bwd : forall (default : V) a i vs, i < length vs -> arrayN a (firstn i vs) * (a + i) |-?-> selN vs i default * arrayN (a + i + 1) (skipn (S i) vs) =p=> arrayN a vs. Proof. intros. eapply pimpl_trans; [ | apply isolateN_bwd' ]. 2: eassumption. apply pimpl_refl. Qed. Theorem arrayN_isolate : forall (default : V) a i vs, i < length vs -> arrayN a vs <=p=> arrayN a (firstn i vs) * (a + i) |-?-> selN vs i default * arrayN (a + i + 1) (skipn (S i) vs). Proof. unfold piff; split. apply isolateN_fwd; auto. apply isolateN_bwd; auto. Qed. Theorem isolate_fwd_upd : forall (v : V) a i vs, i < length vs -> arrayN a (updN vs i v) <=p=> arrayN a (firstn i vs) * (a + i) |-?-> v * arrayN (a + i + 1) (skipn (S i) vs). Proof. intros. erewrite arrayN_isolate with (vs:=updN vs i v) (i:=i) (default:=v); autorewrite with lists; auto. unfold piff; split. cancel; autorewrite with lists; cancel. cancel; autorewrite with lists; cancel. Qed. Theorem isolateN_bwd_upd : forall (v : V) a i vs, i < length vs -> arrayN a (firstn i vs) * (a + i) |-?-> v * arrayN (a + i + 1) (skipn (S i) vs) =p=> arrayN a (updN vs i v). Proof. intros. erewrite <- isolateN_bwd with (vs:=updN vs i v) (i:=i) (default:=v). rewrite selN_updN_eq by auto. rewrite firstn_updN_oob by auto. rewrite skipN_updN' by auto. cancel. rewrite length_updN. auto. Qed. Theorem arrayN_app : forall (a b : list V) st, arrayN st (a ++ b) <=p=> arrayN st a * arrayN (st + length a) b. Proof. induction a; split; simpl; auto. rewrite Nat.add_0_r; cancel. rewrite Nat.add_0_r; cancel. rewrite IHa. replace (S st + length a0) with (st + S (length a0)) by omega. cancel. rewrite IHa. replace (S st + length a0) with (st + S (length a0)) by omega. cancel. Qed. Theorem arrayN_split : forall i (a : list V) st, arrayN st a <=p=> arrayN st (firstn i a) * arrayN (st + i) (skipn i a). 
t T1 T2, empty |- t \typ (TArrow T1 T2) -> value t -> exists x u, t = tabs x T1 u. Admitted. Definition step_fun (t : trm) : option trm := Some t.Axiom step_fun_correct : forall t t', step_fun t = Some t' <-> step t t'.Instance dec_step (t : trm) : Dec (exists t', step t t') := {| dec := _ |}. Proof. destruct (step_fun t) eqn:Step. - left; exists t0; eapply step_fun_correct; eauto. - right => [[t' contra]]. eapply step_fun_correct in contra; congruence. Defined.Theorem progress : forall t T, empty |- t \typ T -> value t \/ exists t', t ===> t'. Admitted. Inductive appears_free_in : id -> trm -> Prop := | afi_var : forall i, appears_free_in i (tvar i) | afi_app1 : forall i t1 t2, appears_free_in i t1 -> appears_free_in i (tapp t1 t2) | afi_app2 : forall i t1 t2, appears_free_in i t2 -> appears_free_in i (tapp t1 t2) | afi_abs : forall i y T11 t12, y <> i -> appears_free_in i t12 -> appears_free_in i (tabs y T11 t12) | afi_if1 : forall i t1 t2 t3, appears_free_in i t1 -> appears_free_in i (tif t1 t2 t3) | afi_if2 : forall i t1 t2 t3, appears_free_in i t2 -> appears_free_in i (tif t1 t2 t3) | afi_if3 : forall i t1 t2 t3, appears_free_in i t3 -> appears_free_in i (tif t1 t2 t3).Hint Constructors appears_free_in.Derive ArbitrarySizedSuchThat for (fun i => appears_free_in i t). Derive SizeMonotonicSuchThatOpt for (fun i => appears_free_in i t). Derive SizedProofEqs for (fun i => appears_free_in i t). Derive GenSizedSuchThatCorrect for (fun i => appears_free_in i t). Derive GenSizedSuchThatSizeMonotonicOpt for (fun i => appears_free_in i t).Instance appears_free_in_gen_correct t : SuchThatCorrect (fun i => appears_free_in i t) (@arbitraryST _ (fun i => appears_free_in i t) _). Admitted.Definition closed (t:trm) := forall x, ~ appears_free_in x t.Instance dec_closed t : Dec (closed t). Admitted. Instance dec_bind x Gamma : Dec (exists T, bind Gamma x T). Admitted.Lemma free_in_context : forall x t, appears_free_in x t -> forall T Gamma, Gamma |- t \typ T -> exists T', bind Gamma x T'. Admitted. Corollary typable_empty__closed : forall t T, empty |- t \typ T -> closed t. Admitted. Lemma substitution_preserves_typing : forall Gamma x U t v T, cons (x,U) Gamma |- t \typ T -> empty |- v \typ U -> Gamma |- [x:=v]t \typ T. Admitted. Theorem preservation : forall t T, empty |- t \typ T -> forall t', t ===> t' -> empty |- t' \typ T. 
l : nat. Hypothesis l_pos : l > 0. Variable r_init : Bvector eta. Definition v_init := injD r_init. Definition RndOut := compMap _ (fun _ => {0, 1}^eta) (forNats l). Fixpoint PRF_DRBG_f (v : D)(n : nat)(k : Key) := match n with | O => nil | S n' => r <- (f k v); r :: (PRF_DRBG_f (injD r) n' k) end. Definition PRF_DRBG (k : Key) := PRF_DRBG_f v_init l k. Variable A : list (Bvector eta) -> Comp bool. Hypothesis A_wf : forall c, well_formed_comp (A c). Definition PRF_DRBG_G1 := s <-$ RndKey ; A (PRF_DRBG_f v_init l s). Theorem PRF_DRBG_G1_equiv : Pr[DRBG_G0 RndKey PRF_DRBG A] == Pr[PRF_DRBG_G1]. reflexivity. Qed. Fixpoint PRF_DRBG_f_G2 (v : D)(n : nat) : OracleComp D (Bvector eta) (list (Bvector eta)) := match n with | O => $ ret nil | S n' => r <--$ (OC_Query _ v); ls' <--$ (PRF_DRBG_f_G2 (injD r) n'); $ ret (r :: ls') end. Definition PRF_A : OracleComp D (Bvector eta) bool := ls <--$ PRF_DRBG_f_G2 v_init l; $ A ls. Check A. Theorem PRF_DRBG_f_G2_wf : forall n v, well_formed_oc (PRF_DRBG_f_G2 v n). induction n; intuition; simpl in *; fcf_well_formed. Qed. Theorem PRF_A_wf : well_formed_oc PRF_A. unfold PRF_A; fcf_well_formed. apply PRF_DRBG_f_G2_wf. Qed. Definition PRF_DRBG_G2 := s <-$ RndKey ; [b, _] <-$2 PRF_A unit _ (f_oracle f _ s) tt; ret b. Fixpoint PRF_DRBG_f_G1_1 (v : D)(n : nat)(k : Key) := match n with | O => ret nil | S n' => r <-$ ret (f k v); ls <-$ (PRF_DRBG_f_G1_1 (injD r) n' k); ret (r :: ls) end. Definition PRF_DRBG_G1_1 := s <-$ RndKey ; ls <-$ PRF_DRBG_f_G1_1 v_init l s; A ls. Theorem PRF_DRBG_f_G1_1_eq_ret : forall k n v, comp_spec eq (PRF_DRBG_f_G1_1 v n k) (ret (PRF_DRBG_f v n k)). induction n; intuition; simpl in *. fcf_reflexivity. fcf_simp. fcf_transitivity. fcf_skip_eq. fcf_reflexivity. fcf_simp. fcf_reflexivity. Qed. Theorem PRF_DRBG_G1_1_equiv : Pr[PRF_DRBG_G1] == Pr[PRF_DRBG_G1_1]. unfold PRF_DRBG_G1, PRF_DRBG_G1_1. fcf_skip. fcf_to_prhl_eq. fcf_symmetry. fcf_transitivity. fcf_with PRF_DRBG_f_G1_1_eq_ret fcf_skip_eq. fcf_reflexivity. fcf_simp. fcf_reflexivity. Qed. Theorem PRF_DRBG_f_G1_1_G2_equiv : forall k n v, comp_spec (fun x1 x2 => x1 = fst x2) (PRF_DRBG_f_G1_1 v n k) ((PRF_DRBG_f_G2 v n) unit unit_EqDec (f_oracle f (Bvector_EqDec eta) k) tt). induction n; intuition; simpl in *. fcf_simp. fcf_spec_ret. fcf_skip. unfold f_oracle. eapply (comp_spec_ret _ _ (fun x1 x2 => x1 = fst x2)). trivial. simpl in *. intuition. subst. fcf_skip. fcf_simp. fcf_spec_ret. Qed. Theorem PRF_DRBG_G1_G2_equiv : Pr[ PRF_DRBG_G1 ] == Pr[ PRF_DRBG_G2 ]. 
a0 H'0. apply Cb_genPcPf with (b := a) (P := l) (Q := genOCPf l); auto with datatypes. apply Cb_id with (1 := cs); auto with datatypes. intros; apply Cb_in1 with (1 := cs); auto. apply Cb_id with (1 := cs); auto with datatypes. intros; apply Cb_in1 with (1 := cs); auto. Qed. Inductive OBuch : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop := | OBuch0 : forall aL : list (poly A0 eqA ltM), OBuch aL nil aL | OBuch1 : forall (a : poly A0 eqA ltM) (aP Q R : list (poly A0 eqA ltM)), OBuch (addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP) (genPcPf (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP Q) R -> ~ BuchAux.zerop A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) -> OBuch aP (a :: Q) R | OBuch2 : forall (a : poly A0 eqA ltM) (aP Q R : list (poly A0 eqA ltM)), OBuch aP Q R -> BuchAux.zerop A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) -> OBuch aP (a :: Q) R. Hint Resolve OBuch0 OBuch2. Hint Resolve incl_refl incl_tl. Theorem incl_addEnd1 : forall (a : poly A0 eqA ltM) (L1 L2 : list (poly A0 eqA ltM)), incl (addEnd A A0 eqA n ltM a L1) L2 -> incl (a :: L1) L2. unfold incl in |- *; simpl in |- *; auto. intros a L1 L2 H' a0 H'0; case H'0; [ intros H'1; rewrite <- H'1; clear H'0 | intros H'1; clear H'0 ]; auto. Qed. Theorem ObuchPincl : forall aP R Q : list (poly A0 eqA ltM), OBuch aP Q R -> incl aP R. intros aP R Q H'; elim H'; simpl in |- *; auto. intros a aP0 Q0 R0 H'0 H'1 H'2; try assumption. apply incl_tran with (m := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP0 :: aP0); simpl in |- *; auto. apply incl_addEnd1; auto. Qed. Theorem ObuchPred : forall aP R Q : list (poly A0 eqA ltM), OBuch aP Q R -> forall a : poly A0 eqA ltM, In a aP -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a R. 
Theorem redInclR : forall (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn a b P Q R -> forall R1 : list (poly A0 eqA ltM), incl R R1 -> redIn a b P Q R1. intros P Q R a b H'; elim H'; simpl in |- *; auto. intros P0 Q0 R0 a0 b0 H'0 H'1 R1 H'2; try assumption. apply redIn0b; auto. intros P0 Q0 R0 a0 b0 H'0 R1 H'1; try assumption. apply redIn1; auto. apply red_incl with (1 := cs) (p := R0); auto. intros P0 Q0 R0 a0 b0 c H'0 H'1 H'2 H'3 H'4 H'5 R1 H'6. apply redIn2 with (c := c); auto. Qed. Remark lem_redln_cons_gen : forall (aP R Q : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), In a aP -> In b aP -> redIn a b aP Q R -> forall (c : poly A0 eqA ltM) (Q1 : list (poly A0 eqA ltM)), incl (addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os c aP) aP) R -> Q = c :: Q1 -> redIn a b (addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os c aP) aP) Q1 R. intros aP R Q a b H' H'0 H'1; elim H'1; auto. intros P Q0 R0 a0 b0 H'2 H'3 c Q1 H'4 H'5. apply redIn0b; auto. intros P Q0 R0 a0 b0 H'2 c Q1 H'3 H'4. rewrite H'4 in H'2; elim H'2; auto. intros H'5; rewrite H'5. apply redIn1; auto. apply nf_red with (aP := P) (cs := cs) (os := os); auto. apply incl_tran with (m := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os c P :: P); simpl in |- *; auto. apply incl_addEnd1; auto. apply red_cons with (1 := cs); auto. apply in_incl with (p := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os c P :: P); auto. apply incl_addEnd1; auto. rewrite H'5; simpl in |- *; auto. intros P Q0 R0 a0 b0 c H'2 H'3 H'4 H'5 H'6 H'7 c0 Q1 H'8 H'9. apply redIn2 with (c := c); auto. Qed. Theorem redln_cons_gen : forall (aP R Q : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In a aP -> In b aP -> redIn a b aP (c :: Q) R -> incl (addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os c aP) aP) R -> redIn a b (addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os c aP) aP) Q R. 
simpl. iDestruct "Hpost" as "[%HQ Hdbpt]". destruct HQ as [u Hlookup]. iApply "HΦ". unfold dbmap_ptstos. iDestruct (big_sepM_lookup with "Hdbpt") as "Hdbpt"; first apply Hlookup. by eauto with iFrame. } { iIntros "!> Htxn". wp_pures. iApply "HΦ". unfold dbmap_ptstos. rewrite big_sepM_singleton. by eauto with iFrame. } } { subst P. simpl. unfold dbmap_ptstos. iDestruct (big_sepM_lookup _ _ (U64 0) with "Hdbpts") as "Hdbpt". { rewrite lookup_gset_to_gmap_Some. split; [set_solver | reflexivity]. } iFrame. } iIntros "HP". wp_pures. subst P. simpl. iDestruct "HP" as "[Htxn [%v Hdbpt]]". iMod (mono_nat_own_alloc (int.nat v)) as (α) "[Hmn _]". iApply "HΦ". iMod (inv_alloc mvccNApp _ (mvcc_inv_app_def γ α) with "[-]") as "#Hinv". { iExists _. iFrame. } done. Qed.Theorem wp_InitCounter : {{{ True }}} InitCounter #() {{{ γ α (mgr : loc), RET #mgr; is_txnmgr mgr γ ∗ mvcc_inv_app γ α }}}. Proof. iIntros (Φ) "_ HΦ". wp_call. wp_apply wp_MkTxnMgr. iIntros (γ mgr) "[#Hmgr Hdbpts]". wp_pures. wp_apply (wp_InitializeCounterData with "Hmgr [$Hdbpts]"). iIntros (α) "#Hinv". wp_pures. iModIntro. iApply "HΦ". iFrame "∗ #". Qed. Theorem wp_CallIncrement (mgr : loc) γ α : mvcc_inv_app γ α -∗ is_txnmgr mgr γ -∗ {{{ True }}} CallIncrement #mgr {{{ RET #(); True }}}. Proof. iIntros "#Hinv #Hmgr" (Φ) "!> _ HΦ". wp_call. wp_apply (wp_txnMgr__New with "Hmgr"). iNamed "Hmgr". iIntros (txn) "Htxn". wp_pures. wp_apply (wp_Increment with "Htxn"). iInv "Hinv" as "> HinvO" "HinvC". iApply ncfupd_mask_intro; first set_solver. iIntros "Hclose". iNamed "HinvO". iExists _. iFrame "Hdbpt". iIntros (ok) "H". iMod "Hclose" as "_". destruct ok eqn:E. { iDestruct "H" as (u) "[Hdbpt %Huv]". iMod (mono_nat_own_update (int.nat u) with "Hmn") as "[Hmn #Hmnlb]". { word. } iMod ("HinvC" with "[- HΦ]") as "_". { iExists _. iFrame. } iIntros "!> Htxn". wp_pures. by iApply "HΦ". } { iMod ("HinvC" with "[- HΦ]") as "_". { iExists _. iFrame. } iIntros "!> Htxn". wp_pures. by iApply "HΦ". } Qed. Theorem wp_CallDecrement (mgr : loc) γ α : mvcc_inv_app γ α -∗ is_txnmgr mgr γ -∗ {{{ True }}} CallDecrement #mgr {{{ RET #(); True }}}. Proof. iIntros "#Hinv #Hmgr" (Φ) "!> _ HΦ". wp_call. wp_apply (wp_txnMgr__New with "Hmgr"). iNamed "Hmgr". iIntros (txn) "Htxn". wp_pures. wp_apply (wp_Decrement with "Htxn"). iInv "Hinv" as "> HinvO" "HinvC". iApply ncfupd_mask_intro; first set_solver. iIntros "Hclose". iNamed "HinvO". iExists _. iFrame "Hdbpt". iIntros (ok) "H". iMod "Hclose" as "_". destruct ok eqn:E. { iDestruct "H" as (u) "[Hdbpt %Huv]". iMod (mono_nat_own_update (int.nat u) with "Hmn") as "[Hmn #Hmnlb]". { Fail word. Abort. Theorem wp_CallIncrementFetch (mgr : loc) γ α : mvcc_inv_app γ α -∗ is_txnmgr mgr γ -∗ {{{ True }}} CallIncrementFetch #mgr {{{ RET #(); True }}}. 
apply (notPosible (P:=fun s : Stream S => ~ P s) H H0); assumption. inversion_clear H2; simpl in |- *. unfold isTraceFrom in |- *; split; trivial. Qed. Lemma not_EX : forall (P : Stream S -> Prop) (x : Stream S) (s : S), ~ ExistsS P (s ^ x) -> ~ ExistsS P x. Proof. unfold not in |- *; intros. apply (H (Further s H0)). Qed. Theorem Equiv4 : forall (Sini : S) (P : Stream S -> Prop), SafePath Sini P <-> ~ Inevitable Sini (fun s : Stream S => ~ P s). Proof. unfold iff, Inevitable, not in |- *; intros; split. intro sp; inversion sp; intros. generalize H0; elim (H1 x H); intros. inversion_clear H3 in H2. apply (H2 H4). apply H3; inversion_clear H4; assumption. intro H; elim (not_all_ex_not (Stream S) (fun x : Stream S => isTraceFrom Sini x -> ExistsS (fun s : Stream S => P s -> False) x) H). intros. generalize (not_imply_elim2 (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0). generalize (not_imply_elim (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0); intros. apply safePath with (1 := H1). generalize H1; clear H1; generalize H2; clear H2. generalize x; generalize Sini; cofix u. simple destruct x0; intros; constructor. elim (classic (P (s ^ s0))); [ trivial | intro ]. elim (H2 (Here (P:=fun s : Stream S => ~ P s) H3)). apply u with (Sini := hd s0). generalize H2; clear H2; case s0; unfold not in |- *; intros. apply (not_EX H2 H3). elim H1; intros ig trace; inversion_clear trace. unfold isTraceFrom in |- *; split; trivial. Qed. Theorem Mon_I_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ForAllS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ForAllS Pp x. Proof. cofix u; intro x; case x; intros. case H; constructor. apply (H0 (s1 ^ x0) H1). apply (u x0 Pg Pp H2 H0). Qed. Theorem Conj_S : forall (x : Stream S) (P1 P2 : Stream S -> Prop), ForAllS P1 x -> ForAllS P2 x -> ForAllS (fun s : Stream S => P1 s /\ P2 s) x. Proof. cofix u; intro x; case x; intros. inversion_clear H; inversion_clear H0. constructor; [ split | apply (u s0) ]; assumption. Qed. Theorem Mon_I_EX_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ExistsS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ExistsS Pp x. 
sm hm' >} read_array xp a i ms. Proof. unfold read_array. hoare. subst; pred_apply. rewrite isolateN_fwd with (i:=i) by auto. rewrite <- surjective_pairing. cancel. Qed. Theorem write_array_ok : forall xp a i v ms, {< F Fm ds sm m vs, PRE:hm rep xp F (ActiveTxn ds m) ms sm hm * [[[ m ::: Fm * arrayP a vs ]]] * [[ i < length vs /\ a <> 0 ]] POST:hm' RET:ms' exists m', rep xp F (ActiveTxn ds m') ms' sm hm' * [[[ m' ::: Fm * arrayP a (updN vs i (v, nil)) ]]] CRASH:hm' exists m' ms', rep xp F (ActiveTxn ds m') ms' sm hm' >} write_array xp a i v ms. Proof. unfold write_array. prestep. norm. cancel. unfold rep_inner; intuition. pred_apply; cancel. eauto. subst; pred_apply. rewrite isolateN_fwd with (i:=i) by auto. rewrite surjective_pairing with (p := selN vs i ($0, nil)). cancel. step. rewrite <- isolateN_bwd_upd by auto. cancel. step. Qed. Hint Extern 1 ({{_}} Bind (read_array _ _ _ _) _) => apply read_array_ok : prog. Hint Extern 1 ({{_}} Bind (write_array _ _ _ _ _) _) => apply write_array_ok : prog. Hint Extern 0 (okToUnify (rep _ _ _ ?a _ _) (rep _ _ _ ?a _ _)) => constructor : okToUnify. Definition read_range A xp a nr (vfold : A -> valu -> A) v0 ms := let^ (ms, r) <- ForN i < nr Hashmap hm Ghost [ F Fm crash ds sm m vs ms0 ] Loopvar [ ms pf ] Invariant rep xp F (ActiveTxn ds m) ms sm hm * [[[ m ::: (Fm * arrayP a vs) ]]] * [[ pf = fold_left vfold (firstn i (map fst vs)) v0 ]] * [[ (exists ms00, readOnly ms00 ms0) -> readOnly ms0 ms ]] OnCrash crash Begin let^ (ms, v) <- read_array xp a i ms; Ret ^(ms, vfold pf v) Rof ^(ms, v0); Ret ^(ms, r). Definition write_range xp a l ms := let^ (ms) <- ForN i < length l Hashmap hm Ghost [ F Fm crash ds sm vs ] Loopvar [ ms ] Invariant exists m, rep xp F (ActiveTxn ds m) ms sm hm * [[[ m ::: (Fm * arrayP a (vsupsyn_range vs (firstn i l))) ]]] OnCrash crash Begin ms <- write_array xp a i (selN l i $0) ms; Ret ^(ms) Rof ^(ms); Ret ms. Theorem read_range_ok : forall A xp a nr vfold (v0 : A) ms, {< F Fm ds sm m vs, PRE:hm rep xp F (ActiveTxn ds m) ms sm hm * [[ nr <= length vs ]] * [[[ m ::: (Fm * arrayP a vs) ]]] POST:hm' RET:^(ms', r) rep xp F (ActiveTxn ds m) ms' sm hm' * [[ r = fold_left vfold (firstn nr (map fst vs)) v0 ]] * [[ (exists ms0, readOnly ms0 ms) -> readOnly ms ms' ]] CRASH:hm' exists ms', rep xp F (ActiveTxn ds m) ms' sm hm' >} read_range xp a nr vfold v0 ms. 
Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. intros. apply PTree.gro. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply grs. apply gro; auto. Qed. Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq. Theorem beq_sound: forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A), beq eqA t1 t2 = true -> forall (x: elt), match get x t1, get x t2 with | None, None => True | Some y1, Some y2 => eqA y1 y2 = true | _, _ => False end. Proof. unfold beq, get. intros. rewrite PTree.beq_correct in H. apply H. Qed. Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine. Theorem gcombine: forall (A B C: Type) (f: option A -> option B -> option C), f None None = None -> forall (m1: t A) (m2: t B) (i: elt), get i (combine f m1 m2) = f (get i m1) (get i m2). 
repeat find_rewrite. eauto. Qed. Lemma append_entries_came_from_leaders_clientRequest : refined_raft_net_invariant_client_request append_entries_came_from_leaders. Proof using. red. unfold append_entries_came_from_leaders. intros. subst. simpl in *. find_apply_hyp_hyp. intuition eauto. - find_apply_hyp_hyp. break_exists. repeat find_higher_order_rewrite. update_destruct; subst_max; rewrite_update; simpl in *; eauto; subst; auto. rewrite update_elections_data_client_request_leaderLogs. repeat find_rewrite. eauto. - do_in_map. subst. simpl in *. find_eapply_lem_hyp handleClientRequest_no_append_entries; eauto. contra. Qed. Lemma append_entries_came_from_leaders_timeout : refined_raft_net_invariant_timeout append_entries_came_from_leaders. Proof using. red. unfold append_entries_came_from_leaders. intros. subst. simpl in *. find_apply_hyp_hyp. intuition eauto. - find_apply_hyp_hyp. break_exists. repeat find_higher_order_rewrite. update_destruct; subst_max; rewrite_update; simpl in *; eauto; subst; auto. rewrite update_elections_data_timeout_leaderLogs. repeat find_rewrite. eauto. - do_in_map. subst. simpl in *. find_eapply_lem_hyp handleTimeout_packets; eauto. contra. Qed. Lemma append_entries_came_from_leaders_doLeader : refined_raft_net_invariant_do_leader append_entries_came_from_leaders. Proof using lhlli. red. unfold append_entries_came_from_leaders. intros. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. subst. simpl in *. find_apply_hyp_hyp. intuition eauto. - find_apply_hyp_hyp. break_exists. repeat find_higher_order_rewrite. update_destruct; subst_max; rewrite_update; simpl in *; eauto; subst; auto. - do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; eauto. repeat break_and. subst. find_eapply_lem_hyp leaders_have_leaderLogs_invariant; eauto. repeat find_higher_order_rewrite. update_destruct; subst_max; rewrite_update; simpl in *; eauto; subst; auto. Qed. Lemma append_entries_came_from_leaders_doGenericServer : refined_raft_net_invariant_do_generic_server append_entries_came_from_leaders. Proof using. red. unfold append_entries_came_from_leaders. intros. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. subst. simpl in *. find_apply_hyp_hyp. intuition eauto. - find_apply_hyp_hyp. break_exists. repeat find_higher_order_rewrite. update_destruct; subst_max; rewrite_update; simpl in *; eauto; subst; auto. - do_in_map. subst. simpl in *. find_eapply_lem_hyp doGenericServer_packets. subst. simpl in *. intuition. Qed. Lemma append_entries_came_from_leaders_reboot : refined_raft_net_invariant_reboot append_entries_came_from_leaders. Proof using. red. unfold append_entries_came_from_leaders. intros. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. subst. simpl in *. find_reverse_rewrite. find_apply_hyp_hyp. repeat find_higher_order_rewrite. update_destruct; subst_max; rewrite_update; simpl in *; eauto; subst; auto. Qed. Lemma append_entries_came_from_leaders_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset append_entries_came_from_leaders. Proof using. red. unfold append_entries_came_from_leaders. intros. find_apply_hyp_hyp. find_apply_hyp_hyp. repeat find_higher_order_rewrite. eauto. Qed. Lemma append_entries_came_from_leaders_init : refined_raft_net_invariant_init append_entries_came_from_leaders. Proof using. red. unfold append_entries_came_from_leaders. intros. simpl in *. intuition. Qed. Theorem append_entries_came_from_leaders_invariant : forall net, refined_raft_intermediate_reachable net -> append_entries_came_from_leaders net. 
IFs, BALLOCC.rep (fst bxps) (fst frees) (BALLOCC.mk_memstate lms (fst cms)) * BALLOCC.rep (snd bxps) (snd frees) (BALLOCC.mk_memstate lms (snd cms)) * INODE.rep (fst bxps) IFs ixp ilist icache * listmatch file_match flist ilist * [[ locked (cache_rep mscache flist ilist) ]] * [[ BmapNBlocks (fst bxps) = BmapNBlocks (snd bxps) ]] * exists Fs, [[ (Fs * IFs * smrep frees dblocks ilist)%pred sm ]] )%pred. Definition rep_length_pimpl : forall bxps sm ixp flist ilist frees allocc icache mscache dblocks, rep bxps sm ixp flist ilist frees allocc icache mscache dblocks =p=> (rep bxps sm ixp flist ilist frees allocc icache mscache dblocks * [[ length flist = ((INODE.IRecSig.RALen ixp) * INODE.IRecSig.items_per_val)%nat ]] * [[ length ilist = ((INODE.IRecSig.RALen ixp) * INODE.IRecSig.items_per_val)%nat ]])%pred. Proof. unfold rep; intros. norm'l; unfold stars; simpl. rewrite INODE.rep_length_pimpl at 1. rewrite listmatch_length_pimpl at 1. cancel. Qed. Definition rep_alt (bxps : BALLOCC.Alloc.Alloc.BmpSig.xparams * BALLOCC.Alloc.Alloc.BmpSig.xparams) sm ixp (flist : list bfile) ilist frees cms icache mscache msalloc dblocks := (exists lms IFs, BALLOCC.rep (pick_balloc bxps msalloc) (pick_balloc frees msalloc) (BALLOCC.mk_memstate lms (pick_balloc cms msalloc)) * BALLOCC.rep (pick_balloc bxps (negb msalloc)) (pick_balloc frees (negb msalloc)) (BALLOCC.mk_memstate lms (pick_balloc cms (negb msalloc))) * INODE.rep (pick_balloc bxps msalloc) IFs ixp ilist icache * listmatch file_match flist ilist * [[ locked (cache_rep mscache flist ilist) ]] * [[ BmapNBlocks (pick_balloc bxps msalloc) = BmapNBlocks (pick_balloc bxps (negb msalloc)) ]] * exists Fs, [[ (Fs * IFs * smrep (pick_balloc frees (msalloc), pick_balloc frees (negb msalloc)) dblocks ilist)%pred sm ]] )%pred. Theorem rep_alt_equiv : forall bxps sm ixp flist ilist frees mscache allocc icache msalloc dblocks, rep bxps sm ixp flist ilist frees allocc mscache icache dblocks <=p=> rep_alt bxps sm ixp flist ilist frees allocc icache mscache msalloc dblocks. Proof. unfold rep, rep_alt; split; destruct msalloc; simpl. - cancel. - norml; unfold stars; simpl. rewrite INODE.rep_bxp_switch at 1 by eauto. cancel. unfold smrep. cancel. - cancel. - norml; unfold stars; simpl. rewrite INODE.rep_bxp_switch at 1 by eauto. cancel. unfold smrep. cancel. Qed. Definition clear_cache bf := mk_bfile (BFData bf) (BFAttr bf) None. Definition clear_caches bflist := map clear_cache bflist. Theorem rep_clear_freelist : forall bxps sm ixp flist ilist frees allocc mscache icache dblocks, rep bxps sm ixp flist ilist frees allocc mscache icache dblocks =p=> rep bxps sm ixp flist ilist frees (BALLOCC.Alloc.freelist0, BALLOCC.Alloc.freelist0) mscache icache dblocks. Proof. unfold rep; intros; cancel. rewrite <- BALLOCC.rep_clear_mscache_ok. cancel. rewrite <- BALLOCC.rep_clear_mscache_ok. cancel. Qed. Theorem rep_clear_bfcache : forall bxps sm ixp flist ilist frees allocc mscache icache dblocks, rep bxps sm ixp flist ilist frees allocc mscache icache dblocks =p=> rep bxps sm ixp (clear_caches flist) ilist frees allocc (BFcache.empty _) icache dblocks. 
p n m : nat => plus_le_reg_l n m p) with (S p * S p'). replace (S p * S p' + S p * S q') with (S p * (S p' + S q')). replace (S p * S p' + S p' * S q) with (S p' * (S p + S q)). auto. ring. ring.unfold Qpositive_le' in |- *; simpl in |- *. elim (interp_non_zero w'1); intros p' Hex; elim Hex; intros q' Heq1; clear Hex; rewrite Heq1. rewrite <- plus_n_O; rewrite <- (mult_comm 1); simpl in |- *; intros H; generalize (plus_le_reg_l _ _ _ (le_S_n _ _ H)). intros H1; inversion H1. intros w; case w; clear w; unfold Qpositive_le', Qpositive_le in |- *; simpl in |- *.intros w; elim (interp_non_zero w). intros p Hex; elim Hex; intros q Heq; rewrite Heq. rewrite mult_1_r. rewrite (plus_comm (S p)). intros H; generalize (plus_le_reg_l _ _ _ H); intros H1; inversion H1.auto.auto.Qed. Theorem Qpositive_le_trans : forall w w' w'' : Qpositive, Qpositive_le w w' -> Qpositive_le w' w'' -> Qpositive_le w w''. intros w w'; generalize w; elim w'; unfold Qpositive_le in |- *; simpl in |- *; clear w w'. intros w' Hrec w; case w.3: intros w''; case w''; simpl in |- *; auto.intros w0 w''; case w''; simpl in |- *; auto.intros w0 w''; case w''; simpl in |- *; auto. intros w''0 H H1; discriminate H1. intros w' Hrec w; case w.3: intros w'' H; discriminate H.intros w0 w'' H; discriminate H.intros w0 w''; case w''; simpl in |- *; auto. intros w; case w; clear w; simpl in |- *.3: auto.intros w w'' H; discriminate H. intros w w''; case w''; simpl in |- *; auto. intros w''0 H H1; discriminate H1.Qed. Theorem Qpositive_le_antisym : forall w w' : Qpositive, Qpositive_le w w' -> Qpositive_le w' w -> w = w'. intros w; elim w; unfold Qpositive_le in |- *; simpl in |- *. intros w0 Hrec w'; case w'; simpl in |- *. 3: intros H; discriminate H. intros; apply f_equal with (f := nR); auto. intros w'0 H; discriminate H. intros w0 Hrec w'; case w'; simpl in |- *. 3: intros H H1; discriminate H1. intros w'1 H H1; discriminate H1. intros; apply f_equal with (f := dL); auto.intros w'; case w'; auto with *. intros w'0 H H1; discriminate H1. intros w'0 H; discriminate H.Qed. Theorem Qpositive_le_refl : forall w : Qpositive, Qpositive_le w w. 
destruct Hx; destruct_lift H; denote (Map.Equal _ _) as Heq. safecancel. eassign F_. cancel. or_l; cancel. unfold synced_rep; auto. auto. denote or as Hx. apply sep_star_or_distr in Hx. destruct Hx; destruct_lift H. prestep. norm. cancel. intuition simpl; auto. pred_apply; cancel. prestep. norm. cancel. intuition simpl; auto. pred_apply. cancel. or_l; cancel. rewrite <- Heq; auto. rewrite <- Heq; auto. cancel. xcrash; eauto. rewrite DLog.rep_synced_pimpl; cancel. or_l; cancel. prestep. norm. cancel. intuition simpl; auto. pred_apply; cancel. prestep. norm. cancel. intuition simpl; auto. pred_apply; cancel. or_r; cancel. rewrite <- Heq; auto. rewrite <- Heq; auto. norm'l. xcrash; eauto. rewrite DLog.rep_synced_pimpl; cancel. or_r; cancel. denote or as Hx. apply sep_star_or_distr in Hx. destruct Hx; destruct_lift H. xcrash; eauto. or_l; cancel. xcrash; eauto. or_r; cancel. safecancel. eassign F_; cancel. or_r; cancel. unfold synced_rep; auto. auto. prestep. norm. cancel. intuition simpl; auto. pred_apply; cancel. prestep. norm. cancel. intuition simpl; auto. pred_apply. cancel. or_l; cancel. rewrite <- Heq; auto. rewrite <- Heq; auto. norm'l. xcrash; eauto. rewrite DLog.rep_synced_pimpl; cancel. or_l; cancel. xcrash; eauto. or_l; cancel. Unshelve. exact valu. all: eauto. all: econstructor; eauto. Qed. Theorem dwrite_vecs_ok : forall xp avl ms, {< F d na, PRE:hm << F, rep: xp (Synced na d) ms hm >> * [[ Forall (fun e => fst e < length d) avl /\ sync_invariant F ]] POST:hm' RET:ms' exists na', << F, rep: xp (Synced na' (vsupd_vecs d avl)) ms' hm' >> XCRASH:hm' << F, would_recover_before: xp d hm' -- >> \/ exists na' ms', << F, rep: xp (Synced na' (vsupd_vecs d avl)) ms' hm' >> >} dwrite_vecs xp avl ms. Proof. unfold dwrite_vecs, would_recover_before. step. step. prestep. unfold rep at 1. unfold synced_rep, map_replay in *. cancel; auto. erewrite <- replay_disk_length. eauto. step. unfold rep, synced_rep, map_replay; cancel. rewrite DLog.rep_hashmap_subset; eauto. eauto. rewrite vsupd_vecs_length; auto. apply map_valid_vsupd_vecs; auto. repeat rewrite replay_disk_empty; auto. norm'l. unfold stars; cbn. xcrash. or_r. rewrite dwrite_vecs_xcrash_ok_empty; eauto. xform_norm; cancel. xform_normr; cancel. eassign x2; eassign (x1_1, x1_2); eauto. pred_apply; eauto. pred_apply; rewrite firstn_oob; eauto. erewrite DLog.rep_hashmap_subset; eauto. xcrash. or_l; cancel. xform_normr; cancel. denote rep as Hx; unfold rep, synced_rep, map_replay in Hx. destruct_lift Hx. step. erewrite <- replay_disk_length; eauto. step. unfold rep, synced_rep, map_replay; cancel. erewrite DLog.rep_hashmap_subset; eauto. eauto. rewrite vsupd_vecs_length; auto. apply map_valid_vsupd_vecs; auto. apply replay_disk_vsupd_vecs_nonoverlap; auto. apply not_true_is_false; auto. xcrash. or_r. rewrite dwrite_vecs_xcrash_ok; eauto. xform_norm; cancel. xform_normr; cancel. eassign x2; eassign (x1_1, x1_2); eauto. pred_apply; eauto. pred_apply; rewrite firstn_oob; eauto. erewrite DLog.rep_hashmap_subset; eauto. Qed. Theorem dsync_vecs_ok: forall xp al ms, {< F d na, PRE:hm << F, rep: xp (Synced na d) ms hm >> * [[ Forall (fun e => e < length d) al /\ sync_invariant F ]] POST:hm' RET:ms' exists na', << F, rep: xp (Synced na' (vssync_vecs d al)) ms' hm' >> CRASH:hm' exists na' ms', << F, rep: xp (Synced na' d) ms' hm' >> >} dsync_vecs xp al ms. 
uint32T | byte_hasTy x : base_lit_hasTy (LitByte x) byteT | bool_hasTy x : base_lit_hasTy (LitBool x) boolT | unit_hasTy : base_lit_hasTy (LitUnit) unitT | string_hasTy s : base_lit_hasTy (LitString s) stringT | loc_null_hasTy t : base_lit_hasTy (LitLoc null) (arrayT t) | structRef_null_hasTy ts : base_lit_hasTy (LitLoc null) (structRefT ts) | ptr_null_hasTy : base_lit_hasTy (LitLoc null) ptrT . Definition bin_op_ty (op:bin_op) (t:ty) : option (ty * ty * ty) := match op with | PlusOp | MinusOp | MultOp | QuotOp | RemOp | ShiftLOp | ShiftROp | OrOp | AndOp => Some (t, t, t) | LtOp | LeOp => Some (t, t, boolT) | _ => None end. Definition un_op_ty (op:un_op) : option (ty * ty) := match op with | NegOp => Some (boolT, boolT) | _ => None end. Definition is_intTy (t: ty) : bool := match t with | baseT uint64BT => true | baseT uint32BT => true | baseT byteBT => true | _ => false end. Definition is_byteTy (t: ty) : bool := match t with | baseT byteBT => true | _ => false end. Definition is_unboxed_baseTy (t: ty) : bool := match t with | baseT _ => true | arrayT _ => true | structRefT _ => true | ptrT => false | _ => false end. Definition is_unboxedTy (t: ty) : bool := match t with | baseT _ => true | arrayT _ => true | structRefT _ => true | ptrT => false | sumT t1 t2 => is_unboxed_baseTy t1 && is_unboxed_baseTy t2 | _ => false end. Fixpoint is_comparableTy (t: ty) : bool := match t with | baseT _ => true | prodT t1 t2 => is_comparableTy t1 && is_comparableTy t2 | sumT t1 t2 => is_comparableTy t1 && is_comparableTy t2 | arrayT _ => true | structRefT _ => true | ptrT => false | _ => false end. Lemma unboxed_baseTy_unboxed (t1: ty): is_unboxed_baseTy t1 = true → is_unboxedTy t1 = true. Proof. destruct t1 => //=. Qed. Lemma unboxedTy_comparable (t: ty): is_unboxedTy t = true → is_comparableTy t = true. Proof. induction t => //=. intros (?&?)%andb_prop. rewrite IHt1 //=; eauto using unboxed_baseTy_unboxed. Qed. Fixpoint flatten_ty (t: ty) : list ty := match t with | prodT t1 t2 => flatten_ty t1 ++ flatten_ty t2 | baseT unitBT => [] | _ => [t] end. Definition refT (t:ty) : ty := structRefT (flatten_ty t). Theorem array_null_hasTy t : base_lit_hasTy (LitLoc null) (refT t). 
|- *; rewrite <- (Zpower_nat_1 radix). rewrite <- Zpower_nat_is_exp; auto with zarith. replace (pred precision + 1) with precision. rewrite <- pGivesBound; auto with float. rewrite <- (Zabs_eq radix); auto with zarith. rewrite <- Zabs_Zmult; rewrite Zmult_comm; auto with float. generalize precisionNotZero; case precision; simpl in |- *; try (intros tmp; Contradict tmp; auto; fail); intros; rewrite plus_comm; simpl in |- *; auto. Qed. Theorem maxMaxBis : forall (p : float) (z : Z), Fbounded b p -> (Fexp p < z)%Z -> (Fabs p < Float nNormMin z)%R. intros p z H' H'0; apply Rlt_le_trans with (FtoR radix (Float (Zpos (vNum b)) (Zpred z))). unfold FtoRradix in |- *; apply maxMax; auto with zarith; unfold Zpred in |- *; auto with zarith. unfold FtoRradix, FtoR, nNormMin in |- *; simpl in |- *. pattern z at 2 in |- *; replace z with (Zsucc (Zpred z)); [ rewrite powerRZ_Zs; auto with real zarith | unfold Zsucc, Zpred in |- *; ring ]. rewrite <- Rmult_assoc. apply Rmult_le_compat_r; auto with real arith. pattern radix at 2 in |- *; rewrite <- (Zpower_nat_1 radix). rewrite <- Rmult_IZR. rewrite <- Zpower_nat_is_exp. replace (pred precision + 1) with precision. replace (INR (nat_of_P (vNum b))) with (IZR (Zpos (vNum b))). rewrite pGivesBound; auto with real. simpl; unfold IZR; rewrite <- INR_IPR; auto. generalize precisionNotZero; case precision; simpl in |- *; auto with arith. intros H'1; Contradict H'1; auto. intros; rewrite plus_comm; simpl in |- *; auto. Qed. Theorem FnormalLtFirstNormalPos : forall p : float, Fnormal p -> (0 <= p)%R -> (firstNormalPos <= p)%R. intros p H' H'0. case (Rle_or_lt firstNormalPos p); intros Lt0; auto with real. case (FnormalLtPos p firstNormalPos); auto. apply firstNormalPosNormal. intros H'1; Contradict H'1; unfold firstNormalPos in |- *; simpl in |- *. apply Zle_not_lt; auto with float. intros H'1; elim H'1; intros H'2 H'3; Contradict H'3. unfold firstNormalPos in |- *; simpl in |- *. apply Zle_not_lt. rewrite <- (Zabs_eq (Fnum p)); auto with float zarith. apply pNormal_absolu_min; auto. apply LeR0Fnum with (radix := radix); auto with arith. Qed. Theorem FnormalLtFirstNormalNeg : forall p : float, Fnormal p -> (p <= 0)%R -> (p <= Fopp firstNormalPos)%R. intros p H' H'0. rewrite <- (Ropp_involutive p); unfold FtoRradix in |- *; repeat rewrite Fopp_correct. apply Ropp_le_contravar; rewrite <- Fopp_correct. apply FnormalLtFirstNormalPos. apply FnormalFop; auto. replace 0%R with (-0)%R; unfold FtoRradix in |- *; try rewrite Fopp_correct; auto with real. Qed. Theorem FsubnormalDigit : forall p : float, Fsubnormal p -> Fdigit radix p < precision. 
_) => econstructor; simpl : core. Lemma alloc_block_loc_not_null: ∀ (b: Block) σ1 l, isFresh σ1 l → ∀ l0 (x : val), heap_array l (Block_to_vals b) !! l0 = Some x → l0  null. Proof. intros v σ1 l H l0 x Heq. apply heap_array_lookup in Heq. destruct Heq as [l' (?&->&Heq)]. apply H; eauto. Qed. Definition mapsto_block (l: loc) (q: Qp) (b: Block) := ([∗ map] l ↦ v ∈ heap_array l (Block_to_vals b), l ↦{q} v)%I. Lemma wp_ReadOp s E (a: u64) q b : {{{ ▷ int.Z a d↦{q} b }}} ExternalOp ReadOp (Val $ LitV $ LitInt a) @ s; E {{{ l, RET LitV (LitLoc l); int.Z a d↦{q} b ∗ mapsto_block l 1 b }}}. Proof. iIntros (Φ) ">Ha HΦ". iApply wp_lift_atomic_head_step_no_fork; first by auto. iIntros (σ1 g1 ns mj D κ κs nt) "(Hσ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iDestruct (@gen_heap_valid with "Hd Ha") as %?. iSplit. { iPureIntro. eexists _, _, _, _, _; simpl. constructor 1. rewrite /head_step /=. monad_simpl. simpl. monad_simpl. econstructor; [ eapply relation.suchThat_gen0; reflexivity | ]. monad_simpl. } iNext; iIntros (v2 σ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (na_heap_alloc_list tls _ l (Block_to_vals b) (Reading O) with "Hσ") as "(Hσ & Hblock & Hl)". { rewrite length_Block_to_vals. rewrite /block_bytes. lia. } { destruct H1 as (?&?); eauto. } { destruct H1 as (H'&?); eauto. eapply H'. } { destruct H1 as (H'&?); eauto. destruct (H' 0) as (?&Hfresh). by rewrite (loc_add_0) in Hfresh. } { eauto. } iModIntro; iSplit; first done. iFrame. iApply "HΦ". iFrame. { rewrite /mapsto_block. iApply seq_mapsto_to_heap_array. iApply (big_sepL_mono with "Hl"). iIntros (k x Heq) "(Hli&Hmt)". iApply (na_mapsto_to_heap with "Hli"). destruct H1 as (H'&?). eapply H'. } Qed. Definition bindex_of_Z (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : fin block_bytes. cut (Z.to_nat i < 4096)%nat. { apply nat_to_fin. } change 4096%nat with (Z.to_nat 4096%Z). abstract (apply Z2Nat.inj_lt; auto; vm_compute; inversion 1). Defined. Theorem block_byte_index {ext: ffi_syntax} (b: Block) (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : Block_to_vals b !! Z.to_nat i = Some (LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi). Proof. unfold Block_to_vals. rewrite ?list_lookup_fmap. unfold bindex_of_Z. destruct (vlookup_lookup' b (Z.to_nat i) (b !!! bindex_of_Z i Hlow Hhi)) as [H _]. rewrite H; eauto. Qed. Theorem mapsto_block_extract i l q b : (0 <= i)%Z -> (i < 4096)%Z -> ⊢ mapsto_block l q b -∗ ∃ v, (l +ₗ i) ↦{q} v ∗ ⌜Block_to_vals b !! Z.to_nat i = Some v⌝. 
(x x' : bool) (t t' f f' : T) eqT, x = x' -> eqT t t' -> eqT f f' -> eqT (if x then t else f) (if x' then t' else f') . intros; subst; auto; destruct x'; auto. Qed.Ltac derive_morph := repeat first [ lazymatch goal with | |- Proper _ _ => red; intros | |- (_ ==> _)%signature _ _ => red; intros end | apply respectful_red; intros | apply respectful_if_bool; intros | match goal with | [ H : (_ ==> ?EQ)%signature ?F ?F' |- ?EQ (?F _) (?F' _) ] => apply H | [ |- ?EQ (?F _) (?F _) ] => let inst := constr:(_ : Proper (_ ==> EQ) F) in apply inst | [ H : (_ ==> _ ==> ?EQ)%signature ?F ?F' |- ?EQ (?F _ _) (?F' _ _) ] => apply H | [ |- ?EQ (?F _ _) (?F' _ _) ] => let inst := constr:(_ : Proper (_ ==> _ ==> EQ) F) in apply inst | [ |- ?EQ (?F _ _ _) (?F _ _ _) ] => let inst := constr:(_ : Proper (_ ==> _ ==> _ ==> EQ) F) in apply inst | [ |- ?EQ (?F _) (?F _) ] => unfold F | [ |- ?EQ (?F _ _) (?F _ _) ] => unfold F | [ |- ?EQ (?F _ _ _) (?F _ _ _) ] => unfold F end ]. Global Instance Proper_andb : Proper (@eq bool ==> @eq bool ==> @eq bool) andb. derive_morph; auto. Qed.Section K. Variable F : bool -> bool -> bool. Hypothesis Fproper : Proper (@eq bool ==> @eq bool ==> @eq bool) F. Existing Instance Fproper. Definition food (x y z : bool) : bool := F x (F y z). Global Instance Proper_food : Proper (@eq bool ==> @eq bool ==> @eq bool ==> @eq bool) food. Proof. derive_morph; auto. Qed. Global Instance Proper_S : Proper (@eq nat ==> @eq nat) S. Proof. derive_morph; auto. Qed. End K.Require Import List.Section Map. Variable T : Type. Variable eqT : relation T. Inductive listEq {T} (eqT : relation T) : relation (list T) := | listEq_nil : listEq eqT nil nil | listEq_cons : forall x x' y y', eqT x x' -> listEq eqT y y' ->listEq eqT (x :: y) (x' :: y'). Theorem listEq_match V U (eqV : relation V) (eqU : relation U) : forall x x' : list V, forall X X' Y Y', eqU X X' -> (eqV ==> listEq eqV ==> eqU)%signature Y Y' -> listEq eqV x x' -> eqU (match x with | nil => X | x :: xs => Y x xs end) (match x' with | nil => X' | x :: xs => Y' x xs end). 
Qed. Lemma listmatch_length_l : forall F a b m, (listmatch a b * F)%pred m -> length a = length b. Proof. unfold listmatch; intros. destruct_lift H; auto. Qed. Lemma listmatch_length_pimpl : forall a b, listmatch a b =p=> (listmatch a b) * [[ length a = length b ]]. Proof. unfold listmatch; cancel. Qed. Lemma listmatch_cons: forall (a : list A) (b : list B) x y, listmatch (x :: a) (y :: b) <=p=> prd x y * listmatch a b. Proof. unfold listmatch. split; cancel. Qed. Theorem listmatch_isolate : forall a b i ad bd, i < length a -> i < length b -> listmatch a b <=p=> listmatch (removeN a i) (removeN b i) * prd (selN a i ad) (selN b i bd). Proof. intros; unfold listmatch. unfold piff; split. cancel. rewrite listpred_isolate with (i := i) (def := (ad, bd)) at 1. rewrite removeN_combine. rewrite selN_combine; auto. rewrite combine_length; rewrite <- H2; rewrite Nat.min_id; auto. repeat rewrite removeN_length by omega. omega. cancel. eapply removeN_length_eq with (a:=a) (b:=b) in H0; eauto. eapply pimpl_trans2. rewrite listpred_isolate with (i := i) (def := (ad, bd)). rewrite removeN_combine. rewrite selN_combine; auto. apply pimpl_refl. rewrite combine_length; rewrite <- H0; rewrite Nat.min_id; auto. repeat rewrite removeN_length by omega. cancel. eapply removeN_length_eq with (a:=a) (b:=b) in H1; eauto. Qed. Theorem listmatch_extract : forall a b i ad bd, i < length a -> listmatch a b =p=> [[ length a = length b ]] * listmatch (removeN a i) (removeN b i) * prd (selN a i ad) (selN b i bd). Proof. intros; unfold listmatch. cancel. rewrite listpred_isolate with (i := i) (def := (ad, bd)) at 1. rewrite removeN_combine. rewrite selN_combine; auto. rewrite combine_length; rewrite <- H1; rewrite Nat.min_id; auto. repeat rewrite removeN_length by omega. omega. Qed. Theorem listmatch_updN_removeN : forall a b i av bv, i < length a -> i < length b -> listmatch (updN a i av) (updN b i bv) <=p=> listmatch (removeN a i) (removeN b i) * (prd av bv). Proof. intros; unfold piff; split. rewrite listmatch_isolate with (ad := av) (bd := bv); [ | rewrite length_updN; eauto ..]. repeat rewrite selN_updN_eq by auto. repeat rewrite removeN_updN; auto. eapply pimpl_trans2. rewrite listmatch_isolate with (i := i) (ad := av) (bd := bv); [ | rewrite length_updN; eauto ..]. apply pimpl_refl. repeat rewrite selN_updN_eq by auto. repeat rewrite removeN_updN; auto. Qed. Theorem listmatch_updN_selN: forall a b i av bv ad bd, i < length a -> i < length b -> prd (selN a i ad) (selN b i bd) =p=> prd av bv -> listmatch a b =p=> listmatch (updN a i av) (updN b i bv). 
-> (y < x)%R. intros x y H' H'0 H'1 H'2 H'3. case (Rle_or_lt x y); auto. intros H'4; case H'4; clear H'4; intros H'4. case FcanonicLtNeg with (p := x) (q := y); auto. intros H'5; Contradict H'3; auto with zarith. intros H'5; elim H'5; intros H'6 H'7; clear H'5; Contradict H'3; rewrite H'6; auto with zarith. Contradict H'3. rewrite FcanonicUnique with (p := x) (q := y); auto with zarith. Qed. Theorem FnormalBoundAbs2 : forall p : float, Fnormal p -> (Zpos (vNum b) * Float 1%nat (Zpred (Fexp p)) <= Fabs p)%R. intros p H'; unfold FtoRradix, FtoR in |- *; simpl in |- *. replace (1 * powerRZ radix (Zpred (Fexp p)))%R with (powerRZ radix (Zpred (Fexp p))); [ idtac | ring ]. pattern (Fexp p) at 2 in |- *; replace (Fexp p) with (Zsucc (Zpred (Fexp p))); [ rewrite powerRZ_Zs; auto with real zarith | unfold Zsucc, Zpred in |- *; ring ]. repeat rewrite <- Rmult_assoc. apply Rmult_le_compat_r; auto with real arith. rewrite <- Rmult_IZR; apply Rle_IZR. rewrite <- (Zabs_eq radix); auto with zarith. rewrite <- Zabs_Zmult; rewrite Zmult_comm; auto with float. Qed. Theorem vNumbMoreThanOne : (1 < Zpos (vNum b))%Z. replace 1%Z with (Z_of_nat 1); [ idtac | simpl in |- *; auto ]. rewrite <- (Zpower_nat_O radix); rewrite pGivesBound; auto with zarith. Qed. Theorem PosNormMin : Zpos (vNum b) = (radix * nNormMin)%Z. pattern radix at 1 in |- *; rewrite <- (Zpower_nat_1 radix); unfold nNormMin in |- *. rewrite pGivesBound; rewrite <- Zpower_nat_is_exp. generalize precisionNotZero; case precision; auto with zarith. Qed. Theorem FnormalPpred : forall x : Z, (- dExp b <= x)%Z -> Fnormal (Float (pPred (vNum b)) x). intros x H; (cut (0 <= pPred (vNum b))%Z; [ intros Z1 | unfold pPred in |- *; auto with zarith ]). repeat split; simpl in |- *; auto with zarith. rewrite (Zabs_eq (pPred (vNum b))). unfold pPred in |- *; auto with zarith. unfold pPred in |- *; rewrite pGivesBound; auto with zarith. rewrite Zabs_Zmult; repeat rewrite Zabs_eq; auto with zarith. apply Zle_trans with ((1 + 1) * pPred (vNum b))%Z; auto with zarith. replace ((1 + 1) * pPred (vNum b))%Z with (pPred (vNum b) + pPred (vNum b))%Z; auto with zarith. replace (Zpos (vNum b)) with (1 + Zpred (Zpos (vNum b)))%Z; unfold pPred in |- *; auto with zarith. apply Zplus_le_compat_r; apply Zle_Zpred. apply vNumbMoreThanOne. Qed. Theorem FcanonicPpred : forall x : Z, (- dExp b <= x)%Z -> Fcanonic (Float (pPred (vNum b)) x). 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. 
auto. Qed. Theorem pbfree_pbadd_prop1 : forall a1 l l1, ~ is_prefix l l1 -> ~ is_prefix l1 l -> pbfree l (pbadd a1 (pbleaf empty) l1). Proof using. intros a1 l l1; generalize a1 l; elim l1; simpl in |- *; auto; clear a1 l l1. intros a1 l H H0; elim H0; auto. intros a; case a. intros l H a1 l0; case l0. intros H0; elim H0; auto. intros b; case b; simpl in |- *; auto. intros l1 H0 H1; apply pbfree_right2. apply H; auto. intros l H a1 l0; case l0; simpl in |- *; auto. intros H0; elim H0; auto. intros b; case b; simpl in |- *; auto. intros l1 H0 H1; apply pbfree_left2. apply H; auto. Qed. Theorem pbfree_pbadd_prop2 : forall a l1 l2 l3, pbfree l1 l3 -> ~ is_prefix l2 l1 -> ~ is_prefix l1 l2 -> pbfree l1 (pbadd a l3 l2). Proof using. intros a l1 l2; generalize a l1; elim l2; simpl in |- *; auto. intros a0 l0 l3 H H0; case H0; auto. intros a0; case a0. intros l H a1 l0; case l0. intros l3 H0; inversion H0. intros b; case b; simpl in |- *; auto. intros l3 l4; case l4; simpl in |- *; auto. intros a2 H0 H1 H2; apply pbfree_right2. apply pbfree_pbadd_prop1; auto. intros p H0 H1 H2; apply pbfree_node2. apply pbfree_pbadd_prop1; auto. intros a2 H0 H1 H2; apply pbfree_right2. apply H; auto. inversion H0; auto. intros p p0 H0 H1 H2; apply pbfree_node2. apply H; auto. inversion H0; auto. intros l3 l4; case l4; simpl in |- *; auto. intros p H0 H1 H2; apply pbfree_node1. inversion H0; auto. intros p p0 H0 H1 H2; apply pbfree_node1. inversion H0; auto. intros l H a1 l0; case l0. intros l3 H0; inversion H0. intros b; case b; simpl in |- *; auto. intros l3 l4; case l4; simpl in |- *; auto. intros p H0 H1 H2; apply pbfree_node2. inversion H0; auto. intros p p0 H0 H1 H2; apply pbfree_node2. inversion H0; auto. intros l3 l4; case l4; simpl in |- *; auto. intros a2 H0 H1 H2; apply pbfree_left2. apply pbfree_pbadd_prop1; auto. intros a2 H0 H1 H2; apply pbfree_left2. apply H; auto. inversion H0; auto. intros p H0 H1 H2; apply pbfree_node1. apply pbfree_pbadd_prop1; auto. intros p p0 H0 H1 H2; apply pbfree_node1. apply H; auto. inversion H0; auto. Qed. Theorem distinct_pbleaves_pbadd_prop1 : forall a a1 l1, distinct_pbleaves (pbadd a1 (pbleaf a) l1). 
"Hlock"); first by auto. iIntros "His_locked". iNamed 1. wpc_pures. wpc_bind_seq. iApply (use_crash_locked with "His_locked"); first done. iSplit; first iFromCache. iDestruct 1 as (σ) "(Hlkinv&HP)". iNamed "Hlkinv". iNamed "Hlkinv". iCache with "HP Hprimary Hbackup Hfupd". { iLeft in "Hfupd". eauto 10 with iFrame. } wpc_call. wpc_loadField. wpc_apply (wpc_Write_ncfupd ⊤ with "Hb"). iModIntro. iExists _; iFrame. iIntros "!> Hprimary". iRight in "Hfupd". rewrite difference_empty_L. iMod ("Hfupd" with "HP") as "[HP HΦ]". iEval (rewrite ->(left_id True bi_wand)%I) in "HΦ". iModIntro. iSplit. { iLeft in "HΦ". eauto 10 with iFrame. } iIntros "Hb". iCache (Φc)%I with "HΦ". { by iLeft in "HΦ". } wpc_pures. { iLeft in "HΦ". eauto 10 with iFrame. } iCache with "HΦ Hprimary Hbackup HP". { iLeft in "HΦ". eauto 10 with iFrame. } wpc_loadField. wpc_pures. iApply wpc_fupd. wpc_apply (wpc_Write' with "[$Hb Hbackup]"). { iFrame. } iSplit; [ | iNext ]. { iLeft in "HΦ". iIntros "[Hbackup|Hbackup]"; eauto 10 with iFrame. } iIntros "(Hbackup&Hb)". wpc_pures. { iLeft in "HΦ". eauto 10 with iFrame. } iSplitR "Hprimary Hbackup HP"; last first. { eauto with iFrame. } iIntros "!> His_locked". iSplit; first iFromCache. wpc_pures. wpc_frame. wp_loadField. wp_apply (crash_lock.release_spec with "[$His_locked]"); auto. wp_pures. iModIntro. iNamed 1. iApply "HΦ"; iFrame. Qed. Theorem wpc_RepBlock__Write_triple (Q: iProp Σ) (Qc: iProp Σ) `{Timeless _ Qc} l addr (s: Slice.t) q (b: Block) : {{{ "Hrb" ∷ is_rblock l addr ∗ "Hb" ∷ is_block s q b ∗ "HQc" ∷ (Q -∗ Qc) ∗ "Hfupd" ∷ (Qc ∧ (∀ σ, P σ ={⊤}=∗ P b ∗ Q)) }}} RepBlock__Write #l (slice_val s) @ ⊤ {{{ RET #(); Q ∗ is_block s q b }}} {{{ Qc }}}. Proof. iIntros (Φ Φc) "Hpre HΦ"; iNamed "Hpre". iApply (wpc_step_strong_mono _ _ _ _ _ (λ v, ⌜ v = #()⌝ ∗ Q ∗ is_block s q b)%I _ _ with "[-HΦ] [HΦ]"); auto. 2: { iSplit. * iNext. iIntros (?) "H". iDestruct "H" as "(%&?)". subst. iModIntro. iRight in "HΦ". by iApply "HΦ". * iLeft in "HΦ". iIntros. iModIntro. by iApply "HΦ". } iApply (wpc_RepBlock__Write with "[$Hrb $Hb //]"). iFrame. iSplit. { iLeft in "Hfupd". eauto. } rewrite difference_empty_L. iNext. iIntros (σ) "HP". iRight in "Hfupd". iMod ("Hfupd" with "HP") as "[HP HQ]". iModIntro. iFrame "HP". iSplit. { iSpecialize ("HQc" with "[$]"). eauto. } iIntros "Hblock". iSplit; first eauto. iFrame. Qed. Definition OpenRead d (addr: u64) : expr := (let: "l" := Open (disk_val d) #addr in RepBlock__Read "l" #true). Theorem wpc_OpenRead d addr σ: {{{ rblock_cinv addr σ ∗ P σ }}} OpenRead d addr @ ⊤ {{{ (x: val), RET x; True }}} {{{ ∃ σ, rblock_cinv addr σ ∗ P σ }}}. 
(xelements' r (xI i) k)) end. Definition elements {A} (m : t A) : list (positive * A) := match m with Empty => nil | Nodes m' => xelements' m' xH nil end. Definition xelements {A} (m : t A) (i: positive) : list (positive * A) := match m with Empty => nil | Nodes m' => xelements' m' i nil end. Lemma xelements'_append: forall A (m: tree' A) i k1 k2, xelements' m i (k1 ++ k2) = xelements' m i k1 ++ k2. Proof. induction m; intros; simpl; auto. - f_equal; auto. - rewrite IHm2, IHm1. auto. - rewrite <- IHm. auto. - rewrite IHm2, <- IHm1. auto. Qed. Lemma xelements_Node: forall A (l: tree A) (o: option A) (r: tree A) i, xelements (Node l o r) i = xelements l (xO i) ++ match o with None => nil | Some v => (prev i, v) :: nil end ++ xelements r (xI i). Proof. Local Transparent Node. intros; destruct l, o, r; simpl; rewrite <- ? xelements'_append; auto. Qed. Lemma xelements_correct: forall A (m: tree A) i j v, get i m = Some v -> In (prev (prev_append i j), v) (xelements m j). Proof. intros A. induction m using tree_ind; intros. - discriminate. - rewrite xelements_Node, ! in_app. rewrite gNode in H0. destruct i. + right; right. apply (IHm2 i (xI j)); auto. + left. apply (IHm1 i (xO j)); auto. + right; left. subst o. rewrite prev_append_prev. auto with coqlib. Qed. Theorem elements_correct: forall A (m: t A) (i: positive) (v: A), get i m = Some v -> In (i, v) (elements m). Proof. intros A m i v H. generalize (xelements_correct m i xH H). rewrite prev_append_prev. auto. Qed. Lemma in_xelements: forall A (m: tree A) (i k: positive) (v: A) , In (k, v) (xelements m i) -> exists j, k = prev (prev_append j i) /\ get j m = Some v. Proof. intros A. induction m using tree_ind; intros. - elim H. - rewrite xelements_Node, ! in_app in H0. destruct H0 as [P | [P | P]]. + exploit IHm1; eauto. intros (j & Q & R). exists (xO j); rewrite gNode; auto. + destruct o; simpl in P; intuition auto. inv H0. exists xH; rewrite gNode; auto. + exploit IHm2; eauto. intros (j & Q & R). exists (xI j); rewrite gNode; auto. Qed. Theorem elements_complete: forall A (m: t A) (i: positive) (v: A), In (i, v) (elements m) -> get i m = Some v. 
Nplus_lt_compat_l: forall n m p, n < m -> p + n < p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_gt_compat_l: forall n m p, n > m -> p + n > p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_le_compat_l: forall n m p, n <= m -> p + n <= p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_ge_compat_l: forall n m p, n >= m -> p + n >= p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c. intros a b c H H1; case H; apply f_equal2 with (f:= Nplus); auto. Qed.Theorem Nplus_lt_reg_l: forall n m p, p + n < p + m -> n < m. intros; to_nat; apply plus_lt_reg_l with nn1; auto with arith. Qed.Theorem Nplus_gt_reg_l: forall n m p, p + n > p + m -> n > m. intros; to_nat; apply plus_gt_reg_l with nn1; auto with arith. Qed.Theorem Nplus_le_reg_l: forall n m p, p + n <= p + m -> n <= m. intros; to_nat; apply plus_le_reg_l with nn1; auto with arith. Qed.Theorem Nplus_ge_reg_l: forall n m p, p + n >= p + m -> n >= m. intros; to_nat; apply plus_ge_reg_l with nn1; auto with arith. Qed. Theorem Neq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros; subst; auto. Qed.Theorem Neq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros; subst; auto. Qed.Theorem Neq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem Neq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). intros x y z H; rewrite H; auto. Qed. Theorem Neq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y). intros x y z H; rewrite H; auto. Qed. Theorem Neq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z). intros x y z H; rewrite H; auto. Qed. Theorem Neq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y). intros x y z H; rewrite H; auto. Qed. Theorem Neq_ge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z). 
radix n)); auto. intros H'3; case H'3; auto. Qed. Theorem maxDivUniqueInverseDigit : forall (v : Z) (p : nat), v <> 0 -> Zdivides v (Zpower_nat radix p) -> ~ Zdivides v (Zpower_nat radix (S p)) -> p = maxDiv v (digit radix v). intros v p H' H'0 H'1. apply maxDivSimplInv; auto. 2: apply maxDivUniqueInverse; auto. apply Zpower_nat_anti_monotone_lt with (n := radix); auto. apply Zle_lt_trans with (m := Zabs v); auto. rewrite <- (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith; apply ZDividesLe; auto. apply digitMore; auto. Qed. Theorem maxDivPlus : forall (v : Z) (n : nat), v <> 0 -> maxDiv (v * Zpower_nat radix n) (digit radix v + n) = maxDiv v (digit radix v) + n. intros v n H. replace (digit radix v + n) with (digit radix (v * Zpower_nat radix n)); auto. apply sym_equal. apply maxDivUniqueInverseDigit; auto. red in |- *; intros Z1; case (Zmult_integral _ _ Z1); intros Z2. case H; auto. absurd (0 < Zpower_nat radix n)%Z; auto with zarith. rewrite Zpower_nat_is_exp. repeat rewrite (fun x : Z => Zmult_comm x (Zpower_nat radix n)). apply ZdividesMult; auto. case (maxDivUniqueDigit v); auto. replace (S (maxDiv v (digit radix v) + n)) with (S (maxDiv v (digit radix v)) + n); auto. rewrite Zpower_nat_is_exp. repeat rewrite (fun x : Z => Zmult_comm x (Zpower_nat radix n)). red in |- *; intros H'. absurd (Zdivides v (Zpower_nat radix (S (maxDiv v (digit radix v))))). case (maxDivUniqueDigit v); auto. apply ZdividesDiv with (p := Zpower_nat radix n); auto with zarith. apply digitAdd; auto with zarith. Qed. Definition LSB (x : float) := (Z_of_nat (maxDiv (Fnum x) (Fdigit radix x)) + Fexp x)%Z. Theorem LSB_shift : forall (x : float) (n : nat), ~ is_Fzero x -> LSB x = LSB (Fshift radix n x). intros x n H'; unfold LSB, Fdigit in |- *; simpl in |- *. rewrite digitAdd; auto with arith. rewrite maxDivPlus; auto. rewrite inj_plus; ring. Qed. Theorem LSB_comp : forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> LSB x = LSB y. intros x y H' H'0 H'1. case (FshiftCorrectSym radix) with (2 := H'1); auto. intros m1 H'2; elim H'2; intros m2 E; clear H'2. rewrite (LSB_shift x m1); auto. rewrite E; auto. apply sym_equal; apply LSB_shift; auto. apply (NisFzeroComp radix) with (x := x); auto. Qed. Theorem maxDiv_opp : forall (v : Z) (p : nat), maxDiv v p = maxDiv (- v) p. 
Require Import Compare_dec. Require qs_definitions. Require qs_parts. Require U. Require Import expec. Require Import arith_lems. Require Import list_utils. Require Import indices. Require Import sort_order. Require Import nat_below. Require Import skip_list. Require Import Bvector.Section contents. Variables (ee: E) (ol: list ee). Import qs_definitions.mon_nondet. Lemma NeTree_In_Node_inv (A: Set) (r: A) (l: ne_list.L (ne_tree.T A)): ne_tree.In r (ne_tree.Node l) -> ne_tree.InL r l. Proof. intros. inversion H. assumption. Qed. Lemma pair_eq_inv (X Y: Set) (x x': X) (y y': Y): (x, y) = (x', y') -> x' = x /\ y' = y. Proof. intros. inversion H. split; reflexivity. Qed. Let qs := @U.qs ee ol. Theorem qs_sound_cmps_2: forall l, forall r, ne_tree.In r (qs l) -> forall i j, In (i, j) (fst r) -> IndexIn i l /\ IndexIn j l. Proof with auto with arith. subst qs. unfold U.qs. intro. pattern l, (qs_definitions.mon_nondet.qs (U.cmp (e:=ee) (ol:=ol)) U.pick l). apply U.qs_ind. Focus 1. simpl. intros r H. inversion_clear H. simpl. intros. elimtype False... intros. cset (NeTree_In_Node_inv H0). clear H0. destruct (ne_tree.InL_map_inv _ _ H2). clear H2. destruct H0. destruct (ne_tree.In_map_inv _ _ H0). clear H0. destruct H3. subst r. unfold monoid_expec.map_fst in H1. unfold fst in H1. destruct (in_app_or _ _ _ H1); clear H1. destruct (In_map_inv H0). clear H0. destruct H1. unfold U.unordered_nat_pair in H0. unfold IndexIn. destruct (le_lt_dec x1 (vec.nth v x)); destruct (pair_eq_inv H0); split; subst; apply in_map. apply vec.remove_In with x... apply vec.In_nth. apply vec.In_nth. apply vec.remove_In with x... destruct (ne_tree_monad.In_bind_inv _ _ H3). clear H3. destruct H1. unfold U.M in H3. rewrite MonoidMonadTrans.bind_toLower in H3. rewrite (@mon_assoc ne_tree_monad.M ) in H3. destruct (ne_tree_monad.In_bind_inv _ _ H3). clear H3. destruct H4. revert H0. rewrite (@mon_assoc ne_tree_monad.M) in H4. rewrite MonoidMonadTrans.ret_toLower in H4. rewrite (@mon_lunit ne_tree_monad.M) in H4. simpl @fst in H4. rewrite (@mon_lunit ne_tree_monad.M) in H4. simpl @fst in H4. unfold snd in H4. inversion_clear H4. simpl. rewrite app_nil_r. intros. assert (forall k cr, IndexIn k (filter (fun f: Index ee ol => unsum_bool (cmp_cmp (Ecmp ee (subscript f) (subscript (vec.nth v x))) cr)) (vec.remove v x)) -> IndexIn k v). intros. unfold IndexIn in *. apply (incl_In _ H4). apply incl_map. apply incl_trans with (vec.remove v x)... apply SkipList_incl. apply vec.SkipList_remove. destruct (in_app_or _ _ _ H0). destruct (H x Lt x1 H1 _ _ H5). split; apply H4 with Lt... destruct (H x Gt x2 H3 _ _ H5). split; apply H4 with Gt... Qed. Theorem qs_sound_cmps: forall l, forall r, ne_tree.In r (qs l) -> NoDup l -> forall i j, In (i, j) (fst r) -> i < j. 
2. destruct (Map.find a cs) eqn:?; try destruct p, b; unfold ptsto_subset in H; destruct_lift H; denote incl as Hx; apply incl_in_nil in Hx; subst. intuition. eapply ptsto_valid'; eauto. eapply ptsto_valid'; eauto. Qed. Lemma mem_pred_cachepred_eq : forall (m1 m2 : mem) cs, mem_pred (cachepred cs) m1 m2 -> synced_mem m1 -> m1 = m2. Proof. intros. apply functional_extensionality; intros. destruct (m1 x) eqn: Heq. erewrite mem_pred_cachepred_some; eauto. eapply mem_pred_cachepred_none in H; eauto. Qed. Lemma mem_pred_possible_crash_trans : forall m m1 m2 cs, possible_crash m m1 -> mem_pred (cachepred cs) m1 m2 -> possible_crash m1 m2. Proof. intros. replace m2 with m1. apply possible_crash_refl. eapply possible_crash_synced; eauto. eapply mem_pred_cachepred_eq; eauto. eapply possible_crash_synced; eauto. Qed. Lemma crash_xform_rep_r: forall m m' cs', possible_crash m m' -> rep cs' m' =p=> crash_xform (rep (cache0 (CSMaxCount cs')) m). Proof. unfold rep; intros. cancel. xform_normr. cancel. unfold pimpl, crash_xform; intros. eexists; split. eapply mem_pred_cachepred_refl; eauto. apply possible_crash_mem_match; auto. eapply possible_crash_trans. eauto. eapply mem_pred_possible_crash_trans; eauto. unfold size_valid in *; intuition. unfold addr_valid in *; intuition. eapply MapFacts.empty_in_iff; eauto. Qed. Lemma crash_xform_rep_r_pred : forall cs m (F : pred), (crash_xform F)%pred m -> rep cs m =p=> exists m', crash_xform (rep (cache0 (CSMaxCount cs)) m') * [[ F m' ]]. Proof. intros. unfold crash_xform in H; deex. rewrite crash_xform_rep_r by eauto. cancel. Qed. Definition init_load := init. Definition init_recover := init. Lemma sync_xform_cachepred : forall m a vs, sync_xform (cachepred m a vs) =p=> exists v, [[ In v (vsmerge vs) ]] * a |=> v. Proof. unfold cachepred; intros. case_eq (Map.find a m); intros; try destruct p, b. - rewrite sync_xform_exists_comm. apply pimpl_exists_l; intro. rewrite sync_xform_sep_star_dist, sync_xform_lift_empty. rewrite sync_xform_ptsto_subset_precise; simpl. cancel. apply in_cons; auto. - rewrite sync_xform_sep_star_dist, sync_xform_lift_empty. rewrite sync_xform_ptsto_subset_precise; simpl. cancel. - rewrite sync_xform_ptsto_subset_precise; cancel. Qed. Lemma sync_xform_mem_pred_cachepred : forall cm m, sync_xform (mem_pred (cachepred cm) m) =p=> exists m', mem_pred (cachepred (Map.empty (valu * bool))) m' * [[ possible_crash m m' ]]. Proof. intros. rewrite sync_xform_mem_pred. unfold mem_pred at 1. xform_norm; subst. rename hm_avs into l. revert H; revert l. induction l; simpl; intros. cancel. apply mem_pred_empty_mem. unfold possible_crash; intuition. inversion H; destruct a; subst; simpl in *. unfold mem_pred_one; simpl. rewrite IHl by auto. xform_norm. rewrite sync_xform_cachepred. norml; unfold stars; simpl. apply pimpl_exists_r. exists (upd m' n (v, nil)). rewrite <- mem_pred_absorb. unfold cachepred at 3; unfold ptsto_subset. rewrite MapFacts.empty_o; cancel. erewrite <- notindomain_mem_eq; auto. eapply possible_crash_notindomain; eauto. apply avs2mem_notindomain; auto. apply possible_crash_upd; eauto. Qed. Theorem init_recover_ok : forall cachesize, {< d F, PRE:hm exists cs, rep cs d * [[ F d ]] * [[ cachesize <> 0 ]] POST:hm' RET:cs exists d', rep cs d' * [[ (crash_xform F) d' ]] CRASH:hm' exists cs, rep cs d >} init_recover cachesize. 
B_EqDec (fun _ : nat => (c1 a)) (forNats n); A2 s_A b ] == Pr [x <-$ computeHybrid n n a; A2 s_A x ]. intuition. unfold computeHybrid. inline_first. comp_skip. inline_first. rewrite minus_diag. unfold forNats. unfold compMap. comp_simp. rewrite app_nil_r. intuition. Qed. Theorem DistSingle_impl_Mult : DistMult_Adv _ c1 c2 A1 A2 n <= (n / 1) * (DistSingle_Adv c1 c2 B1 B2). eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. rewrite DistSingle_G1_equiv. rewrite DistSingle_G2_equiv. rewrite DistSingle_G2_equiv. rewrite DistSingle_G3_c1_equiv. rewrite DistSingle_G3_c2_equiv. eapply eqRat_refl. } eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. unfold DistSingle_G3_c1, DistSingle_G3_c2. rewrite rndNat_sumList. rewrite rndNat_sumList. rewrite sumList_factor_constant_l. rewrite sumList_factor_constant_l. rewrite ratMult_ratDistance_factor_l. eapply eqRat_refl. } eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. rewrite <-ratMult_assoc. rewrite ratMult_eq_rat1. rewrite ratMult_1_l. rewrite ratDistance_comm. rewrite sumList_forNats_distance. eapply eqRat_refl. } unfold DistMult_Adv. unfold DistMult_G. rewrite ratDistance_comm. eapply eqRat_impl_leRat. eapply ratDistance_eqRat_compat. eapply evalDist_seq; intuition. comp_simp. eapply compMap_computeHybrid_0_equiv. eapply evalDist_seq; intuition. comp_simp. eapply compMap_computeHybrid_n_equiv. Grab Existential Variables. econstructor; intuition. Qed.End DistSingle_impl_Mult.Section RepeatCore. Variable A B : Set. Hypothesis B_EqDec : EqDec B. Variable P : B -> bool. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A1 : Comp (A * A_State ). Variable A2 : A_State -> B -> Comp bool. Definition RepeatCore_G(c : A -> Comp B) := [a, s_A] <-$2 A1; b <-$ Repeat (c a) P; A2 s_A b. Definition RepeatCore_Adv := | Pr[RepeatCore_G c1] - Pr[RepeatCore_G c2] |.End RepeatCore. Section DistMult_impl_RepeatCore. Variable A B : Set. Hypothesis B_EqDec : EqDec B. Variable P : B -> bool. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A1 : Comp (A * A_State). Variable A2 : A_State -> B -> Comp bool. Hypothesis A1_wf : well_formed_comp A1. Hypothesis A2_wf : forall s_A b, well_formed_comp (A2 s_A b). Hypothesis c1_wf : forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c1 a). Hypothesis c1_repeat_wf : forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c1 a))). Hypothesis c2_wf : forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c2 a). Hypothesis c2_repeat_wf : forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c2 a))). Variable n : nat. Definition DM_RC_G1(c : A -> Comp B) := [a, s_A] <-$2 A1; p <-$ Repeat (b <-$ (c a); g <-$ (A2 s_A b); ret (b, g)) (fun p => P (fst p)); ret (snd p). Theorem DM_RC_G1_equiv : forall c x, (forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c a)) -> (forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c a)))) -> evalDist (RepeatCore_G P A1 A2 c) x == evalDist (DM_RC_G1 c) x. 
Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface.Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.SpecLemmas. Require Import VerdiRaft.RefinementSpecLemmas.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.LeaderSublogInterface. Require Import VerdiRaft.LeaderLogsTermSanityInterface. Require Import VerdiRaft.EveryEntryWasCreatedInterface. Require Import VerdiRaft.LeaderLogsCandidateEntriesInterface.Require Import VerdiRaft.CroniesCorrectInterface. Require Import VerdiRaft.VotesCorrectInterface.Require Import VerdiRaft.RefinementCommonTheorems.Require Import VerdiRaft.LeaderLogsSublogInterface.Section LeaderLogsSublog. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lsi : leader_sublog_interface}. Context {lltsi : leaderLogs_term_sanity_interface}. Context {eewci : every_entry_was_created_interface}. Context {llcei : leaderLogs_candidate_entries_interface}. Context {cci : cronies_correct_interface}. Context {vci : votes_correct_interface}. Theorem leaderLogs_sublog_init : refined_raft_net_invariant_init leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_init, leaderLogs_sublog. simpl. intuition. Qed. Ltac start := repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end; rewrite update_fun_comm with (f := snd); simpl in *; match goal with | [ H : context [ type ] |- _ ] => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by auto end; match goal with | [ H : context [ currentTerm ] |- _ ] => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by auto end. Theorem leaderLogs_sublog_client_request : refined_raft_net_invariant_client_request leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_client_request, leaderLogs_sublog. intuition. simpl in *. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleClientRequest_type. intuition. start. find_rewrite_lem update_elections_data_client_request_leaderLogs. find_erewrite_lem update_nop_ext' . update_destruct_max_simplify. - destruct (log d) using (handleClientRequest_log_ind ltac:(eauto)). + eauto. + simpl. right. eauto. - eauto. Qed. Theorem leaderLogs_sublog_timeout : refined_raft_net_invariant_timeout leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_timeout, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleTimeout_type. intuition. - start. find_rewrite_lem update_elections_data_timeout_leaderLogs. find_erewrite_lem update_nop_ext' . update_destruct_max_simplify; eauto. erewrite handleTimeout_log_same by eauto; eauto. - repeat update_destruct_max_simplify; try congruence. + find_rewrite_lem update_elections_data_timeout_leaderLogs. eauto. + eauto. Qed. Lemma handleAppendEntries_leader : forall h st t n pli plt es ci st' m, handleAppendEntries h st t n pli plt es ci = (st', m) -> type st' = Leader -> log st' = log st. Proof using. unfold handleAppendEntries. intros. repeat break_match; repeat find_inversion; simpl in *; auto; discriminate. Qed. Theorem leaderLogs_sublog_append_entries : refined_raft_net_invariant_append_entries leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_append_entries, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleAppendEntries_type. intuition. - start. find_rewrite_lem update_elections_data_appendEntries_leaderLogs. find_erewrite_lem update_nop_ext'. update_destruct_max_simplify; eauto. erewrite handleAppendEntries_leader by (eauto; congruence). eauto. - repeat update_destruct_max_simplify; try congruence. + find_rewrite_lem update_elections_data_appendEntries_leaderLogs. eauto. + eauto. Qed. Theorem leaderLogs_sublog_append_entries_reply : refined_raft_net_invariant_append_entries_reply leaderLogs_sublog. 
in *. eauto 10. destruct (agree H1); intuition. rewrite H3 in H5; injection H5; clear H5; intros; subst. unfold step in H; simpl in H. rewrite H6 in H. specialize (BlocksOk ok H1); intro ok'. red in ok'. specialize (@ok' stn _ specsOk _ H2). destruct ok'; clear ok; intuition. rewrite H in H5; injection H5; clear H5; intros; subst. destruct H7; intuition. destruct (specsOk' _ H5) as [? [? [ ] ] ]. inversion H0; clear H0; subst. eauto 10. unfold step in H9. destruct (agreeImp H8) as [ ? [ ] ]. rewrite H4 in H0; injection H0; clear H0; intros; subst. rewrite H11 in H9; discriminate. destruct H8. eapply IHreachable. apply H8. eauto. eauto. destruct x0; simpl in *. congruence. Qed. Theorem safety'' : forall st st', reachable stn prog st st' -> forall l pre bl, LabelMap.MapsTo l (pre, bl) (Blocks m) -> Labels stn l = Some (fst st) -> interp specs0 (pre (stn, snd st)) -> (exists l', Labels stn l' = Some (fst st') /\ exists pre', LabelMap.MapsTo l' pre' (Imports m) /\ interp specs0 (pre' (stn, snd st'))) \/ step stn prog st' <> None. intros. eapply safety' in H; eauto. 2: destruct st; auto. destruct H as [ ? [ ? [ ? [ ] ] ] ]; intuition eauto. destruct H5. apply (BlocksOk ok H3) in H4; [ | apply specsOk ]. destruct H4 as [ ? [ ? [ ? [ ] ] ] ]. right; intro. unfold step in H7. apply agree in H3; destruct H3; intuition. rewrite H in H8; injection H8; clear H8; intros; subst. rewrite H9 in H7. congruence. Qed. End safetyWithImports. Hypothesis closed : LabelMap.cardinal (Imports m) = 0. Variable stn : settings. Variable prog : program. Hypothesis inj : forall l1 l2 w, Labels stn l1 = Some w -> Labels stn l2 = Some w -> l1 = l2. Hypothesis agree : forall l pre bl, LabelMap.MapsTo l (pre, bl) (Blocks m) -> exists w, Labels stn l = Some w /\ prog w = Some bl. Hypothesis ok : moduleOk. Hint Constructors SetoidList.InA. Definition specs : codeSpec W (settings * state) := specs0 stn. Lemma it's_really_empty : forall k v, LabelMap.MapsTo k v (Imports m) -> False. intros; apply LabelMap.elements_1 in H. rewrite LabelMap.cardinal_1 in closed. inversion H. rewrite <- H0 in closed. discriminate. rewrite <- H0 in closed. discriminate. Qed. Theorem safety : forall mn g pre, LabelMap.MapsTo (mn, Global g) pre (Exports m) -> forall w, Labels stn (mn, Global g) = Some w -> forall st, interp specs (pre (stn, st)) -> safe stn prog (w, st). 
Hx. denote (Data.avail_rep) as Hx; clear Hx. xcrash. or_l. cancel. solve_checksums. denote (Data.avail_rep) as Hx; clear Hx. denote (Data.avail_rep) as Hx; clear Hx. xcrash. or_l. cancel. solve_checksums. denote (Data.avail_rep) as Hx; clear Hx. denote (Data.avail_rep) as Hx; clear Hx. xcrash. or_l. cancel. solve_checksums. denote (Data.avail_rep) as Hx; clear Hx. xcrash. or_l. cancel. solve_checksums. xcrash. or_l. cancel. solve_checksums. xcrash. or_l. cancel. solve_checksums. Grab Existential Variables. all: eauto; try econstructor. Qed. Definition recover_ok : forall xp cs, {< F st l, PRE:hm exists d, BUFCACHE.rep cs d * [[ (F * rep xp st hm)%pred d ]] * [[ st = Synced l \/ st = Rollback l ]] * [[ sync_invariant F ]] POST:hm' RET:cs' exists d', BUFCACHE.rep cs' d' * [[ (F * rep xp (Synced l) hm')%pred d' ]] XCRASH:hm' would_recover xp F l hm' >} recover xp cs. Proof. unfold would_recover, would_recover'; intros. eapply pimpl_ok2; monad_simpl; try eapply nop_ok. intros. norm'l. unfold stars; cbn. intuition; subst. - cancel. eapply pimpl_ok2; monad_simpl; try apply recover_ok_Synced. cancel. eassign l. cancel. hoare. norm'l. xcrash. xcrash. xcrash. or_l; cancel. - cancel. eapply pimpl_ok2; monad_simpl; try apply recover_ok_Rollback. intros; norm. cancel. intuition simpl. eauto. auto. step. cancel. xcrash. or_r; or_l; cancel. or_r; or_r; cancel. xcrash. or_r; or_l; cancel. Qed. Hint Extern 1 ({{_}} Bind (recover _ _) _) => apply recover_ok : prog. End PaddedLog. Module DLog. Definition entry := (addr * valu)%type. Definition contents := list entry. Inductive state := | Synced (navail : nat) (l: contents) | Truncated (old: contents) | ExtendedUnsync (old: contents) | Extended (old: contents) (new: contents) | Rollback (l: contents) | Recovering (l: contents). Definition rep_common l padded : rawpred := ([[ l = PaddedLog.log_nonzero padded /\ length padded = roundup (length padded) PaddedLog.DescSig.items_per_val ]])%pred. Definition rep xp st hm := (match st with | Synced navail l => exists padded, rep_common l padded * [[ navail = (LogLen xp) - (length padded) ]] * PaddedLog.rep xp (PaddedLog.Synced padded) hm | Truncated l => exists padded, rep_common l padded * PaddedLog.rep xp (PaddedLog.Truncated padded) hm | ExtendedUnsync l => exists padded, rep_common l padded * PaddedLog.rep xp (PaddedLog.Synced padded) hm | Extended l new => exists padded, rep_common l padded * PaddedLog.rep xp (PaddedLog.Extended padded new) hm | Rollback l => exists padded, rep_common l padded * PaddedLog.rep xp (PaddedLog.Rollback padded) hm | Recovering l => exists padded, rep_common l padded * PaddedLog.would_recover' xp padded hm end)%pred. Theorem sync_invariant_rep : forall xp st hm, sync_invariant (rep xp st hm). 
(Hgx = Hhx); trivial. apply sig_proof_irrelevance. destruct Hgx as [y Hy]; destruct Hhx as [z Hz]. cbn in *. refine (equal_f (fm (unit : Type) (fun _ => y) (fun _ => z) _) tt). FunExt; cbn; auto. Qed. Definition Monic_To_Image : A → Monic_Image_of := fun a => existT _ (f a) (exist _ a eq_refl). Definition Monic_From_Image_back : Monic_Image_of → A := fun x => proj1_sig (projT2 x). Theorem Monic_From_Image_back_is_Monic : @is_Monic Type_Cat _ _ Monic_To_Image. Proof. intros T g h H. extensionality x. assert (H' := f_equal (fun w : Monic_Image_of => (fun u : unit => projT1 w)) (equal_f H x) ); clear H. apply (equal_f (fm (unit : Type) (fun _ => (g x)) (fun _ => (h x)) H') tt). Qed. Theorem Monic_To_Image_form_split_epic : ( fun (x : Monic_Image_of) => Monic_To_Image (Monic_From_Image_back x) ) = (fun x => x). Proof. extensionality x. destruct x as [x [y Hxy]]. unfold Monic_To_Image. cbn in *. destruct Hxy; trivial. Qed. Program Definition Monic_Iso_Monic_Factor_Iso : (A ≃≃ Monic_Image_of ::> Type_Cat)%isomorphism := Monic_is_split_Epic_Iso _ _ (is_Monic_Monic Monic_From_Image_back_is_Monic) ( @Build_is_split_Monic (Type_Cat ^op) _ _ Monic_To_Image _ Monic_To_Image_form_split_epic ) . Theorem Monic_Iso_Monic_Factorization : f = fun x => Monic_From_Image_forward (Monic_To_Image x). Proof. auto. Qed.End Monic_Iso_Monic_Factorization. Require Import Coq.Logic.ChoiceFacts.Local Axiom ConstructiveIndefiniteDescription_Type : forall T : Type, ConstructiveIndefiniteDescription_on T. Section split_Epic_Monic_Factorization. Context {A B : Type} (f : A → B). Definition Image_of : Type := {x : B | ∃ a, f a = x}. Definition From_Image_forward : Image_of → B := fun x => proj1_sig x. Program Definition Epic_Monic_Factor_Monic : @Monic Type_Cat Image_of B := {| mono_morphism := From_Image_forward; mono_morphism_monomorphic := fun T g h => _ |} . Next Obligation. Proof. extensionality x. assert (H' := equal_f H x); cbn in H'. apply sig_proof_irrelevance. destruct (g x); destruct (h x). trivial. Qed. Definition To_Image : A → Image_of := fun a => exist _ (f a) (ex_intro _ a eq_refl). Definition From_Image_back : Image_of → A := fun x => proj1_sig (ConstructiveIndefiniteDescription_Type _ _ (proj2_sig x)). Theorem From_Image_back_form_split_epic : ∀ (x : Image_of), To_Image (From_Image_back x) = x. Proof. intros x. apply sig_proof_irrelevance. unfold From_Image_back; cbn. destruct (ConstructiveIndefiniteDescription_Type A (fun a : A => f a = proj1_sig x) (proj2_sig x) ) as [z Hz]. trivial. Qed. Program Definition Epic_Monic_Factor_split_Epic : @is_split_Epic Type_Cat _ _ To_Image := {| is_split_monic_left_inverse := From_Image_back |}. Next Obligation. Proof. extensionality x. apply From_Image_back_form_split_epic. Qed. Theorem split_Epic_Monic_Factorization : f = fun x => From_Image_forward (To_Image x). 
in H; nauto. Qed. Local Hint Resolve ε₀_neq_0 : core. Lemma ε₀_closed_under_ω_exp : ∀α ∈ ε₀, ξ ^ α ∈ ε₀. Proof with nauto. intros α Hα. assert (Hoα: α ⋵ 𝐎𝐍). apply (ord_is_ords ε₀)... apply ε₀E in Hα as [n [Hn Hα]]. apply (ε₀I n⁺). apply ω_inductive... rewrite ordTetL_suc... apply ordExp_preserve_lt... Qed. Definition ε_number := λ ε, ε ⋵ 𝐎𝐍 ∧ ξ ^ ε = ε. Lemma ε₀_is_ε_number : ε₀ ⋵ ε_number. Proof with neauto. split... ext. - rewrite ordExp_limit in H... apply FUnionE in H as [α [Hα Hx]]. eapply ord_trans... apply ε₀_closed_under_ω_exp... - rewrite ordExp_limit... eapply FUnionI... apply ε₀E in H as [n [Hn Hx]]. eapply ordExp_enlarge_l_strictly... Qed. Lemma ε_number_neq_0 : ∀ε ⋵ ε_number, ε  0. Proof with eauto. intros ε [Hε Heq]. intros H. subst. rewrite ordExp_0_r in Heq... Qed. Lemma ε_number_neq_1 : ∀ε ⋵ ε_number, ε  1. Proof with neauto. intros ε [Hε Heq]. intros H. subst. rewrite ordExp_1_r in Heq... Qed. Lemma ε_number_has_tower_n : ∀n ∈ ω, ∀ε ⋵ ε_number, ξ ^^ᴸ n ∈ ε. Proof with neauto. intros n Hn. ω_induction n; intros ε [Hε Heq]. - rewrite <- zero, ordTetL_0, <- Heq... apply ordExp_enlarge_r... apply ord_neq_0_1_gt_1... apply ε_number_neq_0. split... apply ε_number_neq_1. split... - rewrite ordTetL_suc, <- Heq... apply ordExp_preserve_lt... apply IH. split... Qed. Lemma ε₀_is_the_least_ε_number : ∀α ⋵ ε_number, ε₀ ⋸ α. Proof with eauto. intros ε [Hε Heq]. apply ord_le_iff_sub... intros x Hx. apply ε₀E in Hx as [n [Hn Hx]]. eapply ord_trans... apply ε_number_has_tower_n... split... Qed. Definition ε := Enumerate ε_number. Lemma ε_number_sub_𝐎𝐍 : ε_number ⫃ 𝐎𝐍. Proof. intros α []; auto. Qed. Local Hint Resolve ε_number_sub_𝐎𝐍 : core. Lemma ε_number_unbounded : unbounded ε_number. Proof. apply fixed_point_class_unbounded, ordExp_normal; nauto. Qed. Local Hint Resolve ε_number_unbounded : core. Lemma ε_spec : ∀α ⋵ 𝐎𝐍, ∀β ⋵ ε_number, β ∉ {ε x | x ∊ α} → ε α ⋸ β. Proof. intros α Hα β Hβ. apply enum_spec; auto. Qed. Lemma ε_is_ε_number : ε :ᶜ 𝐎𝐍 ⇒ ε_number. Proof. apply enum_into_class; auto. Qed. Local Hint Resolve ε_is_ε_number : core. Lemma ε_operative : ε :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍. Proof. intros. apply enum_operative; auto. Qed. Local Hint Resolve ε_operative : core. Theorem ε_0 : ε 0 = ε₀. Proof with auto. ord_ext... - apply ε_spec... apply ε₀_is_ε_number. intros H. apply ReplAx in H as [x [Hx _]]. exfalso0. - apply ε₀_is_the_least_ε_number... Qed. Theorem ε_monotone : monotone ε. Proof. apply enum_monotone; auto. Qed. Theorem ε_injective : class_injective ε 𝐎𝐍. 
-> B) -> t A -> t B. Axiom gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). End MAP.Module PTree <: TREE. Definition elt := positive. Definition elt_eq := peq. Inductive tree (A : Type) : Type := | Leaf : tree A | Node : tree A -> option A -> tree A -> tree A. Arguments Leaf [A]. Arguments Node [A]. Scheme tree_ind := Induction for tree Sort Prop. Definition t := tree. Definition empty (A : Type) := (Leaf : t A). Fixpoint get (A : Type) (i : positive) (m : t A) {struct i} : option A := match m with | Leaf => None | Node l o r => match i with | xH => o | xO ii => get ii l | xI ii => get ii r end end. Fixpoint set (A : Type) (i : positive) (v : A) (m : t A) {struct i} : t A := match m with | Leaf => match i with | xH => Node Leaf (Some v) Leaf | xO ii => Node (set ii v Leaf) None Leaf | xI ii => Node Leaf None (set ii v Leaf) end | Node l o r => match i with | xH => Node l (Some v) r | xO ii => Node (set ii v l) o r | xI ii => Node l o (set ii v r) end end. Fixpoint remove (A : Type) (i : positive) (m : t A) {struct i} : t A := match i with | xH => match m with | Leaf => Leaf | Node Leaf o Leaf => Leaf | Node l o r => Node l None r end | xO ii => match m with | Leaf => Leaf | Node l None Leaf => match remove ii l with | Leaf => Leaf | mm => Node mm None Leaf end | Node l o r => Node (remove ii l) o r end | xI ii => match m with | Leaf => Leaf | Node Leaf None r => match remove ii r with | Leaf => Leaf | mm => Node Leaf None mm end | Node l o r => Node l o (remove ii r) end end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. 
Theorem n3_47a : ∀ P Q R S : Prop, ((P → R) ∧ (Q → S)) → (P ∧ Q) → R ∧ S. 
in |- *; intros x y H'; auto with real. Qed. Lemma Fge_Zge : forall n1 n2 d : Z, (n1 >= n2)%Z -> Fge (Float n1 d) (Float n2 d). intros n1 n2 d H'; apply Fle_Fge; auto. apply Fle_Zle; auto. apply Zge_le; auto. Qed. Lemma Flt_Fgt : forall x y : float, Flt x y -> Fgt y x. unfold Flt, Fgt in |- *; intros x y H'; auto. Qed. Lemma Fgt_Zgt : forall n1 n2 d : Z, (n1 > n2)%Z -> Fgt (Float n1 d) (Float n2 d). intros n1 n2 d H'; apply Flt_Fgt; auto. apply Flt_Zlt; auto. apply Zgt_lt; auto. Qed. Lemma Fle_refl : forall x y : float, Feq x y -> Fle x y. unfold Feq in |- *; unfold Fle in |- *; intros. rewrite H; auto with real. Qed. Lemma Fle_trans : forall x y z : float, Fle x y -> Fle y z -> Fle x z. unfold Fle in |- *; intros. apply Rle_trans with (r2 := FtoR radix y); auto. Qed. Theorem Rlt_Fexp_eq_Zlt : forall x y : float, (x < y)%R -> Fexp x = Fexp y -> (Fnum x < Fnum y)%Z. intros x y H' H'0. apply lt_IZR. apply (Rlt_monotony_contra_exp radix) with (z := Fexp x); auto with real arith. pattern (Fexp x) at 2 in |- *; rewrite H'0; auto. Qed. Theorem Rle_Fexp_eq_Zle : forall x y : float, (x <= y)%R -> Fexp x = Fexp y -> (Fnum x <= Fnum y)%Z. intros x y H' H'0. apply le_IZR. apply (Rle_monotony_contra_exp radix) with (z := Fexp x); auto with real arith. pattern (Fexp x) at 2 in |- *; rewrite H'0; auto. Qed. Theorem LtR0Fnum : forall p : float, (0 < p)%R -> (0 < Fnum p)%Z. intros p H'. apply lt_IZR. apply (Rlt_monotony_contra_exp radix) with (z := Fexp p); auto with real arith. simpl in |- *; rewrite Rmult_0_l; auto. Qed. Theorem LeR0Fnum : forall p : float, (0 <= p)%R -> (0 <= Fnum p)%Z. intros p H'. apply le_IZR. apply (Rle_monotony_contra_exp radix) with (z := Fexp p); auto with real arith. simpl in |- *; rewrite Rmult_0_l; auto. Qed. Theorem LeFnumZERO : forall x : float, (0 <= Fnum x)%Z -> (0 <= x)%R. intros x H'; unfold FtoRradix, FtoR in |- *. replace 0%R with (0%Z * 0%Z)%R; auto 6 with real zarith. Qed. Theorem R0LtFnum : forall p : float, (p < 0)%R -> (Fnum p < 0)%Z. 
p q n Heq; injection Heq; intros Heq2 Heq1; case n. rewrite <- Heq1; simpl in |- *; intros Hle; inversion Hle. rewrite <- Heq1; rewrite <- Heq2; simpl in |- *; auto with *.Qed. Theorem construct_correct2 : forall n p q : nat, S p + S q <= n -> exists d : nat, S p = fst (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d /\ S q = snd (Qpositive_i (Qpositive_c (S p) (S q) n)) * S d. intros n; elim n. intros p q Hle; inversion Hle. clear n; intros n. intros Hrec p q Hle; case (le_gt_dec (S p) (S q)). simpl in |- *. intros Hle'; rewrite (le_minus_O p q). CaseEq (q - p). intros Heq_minus; exists p. simpl in |- *; split; auto with arith. rewrite <- plus_n_O. apply le_antisym; auto with arith. apply minus_O_le. auto. intros q' Heq_minus; elim (Hrec p q'). intros d; simpl in |- *; case (Qpositive_i (Qpositive_c (S p) (S q') n)); repeat rewrite <- (mult_comm (S d)); intros p'' q'' (Heq1, Heq2). exists d; split. exact Heq1. rewrite (le_plus_minus (S p) (S q)). simpl in |- *. rewrite Heq_minus; rewrite Heq2. simpl in |- *. replace (S (p + q'' * S d)) with (S p + q'' * S d). rewrite Heq1. simpl in |- *. ring. simpl in |- *; auto. auto with arith. apply le_S_n. rewrite plus_n_Sm. apply le_trans with (S p + S q). apply plus_le_compat_l. apply le_n_S. rewrite <- Heq_minus; apply minus_le. exact Hle. auto with arith. intros Hgt; simpl in |- *; CaseEq (p - q). intros H; elim (gt_not_le _ _ Hgt). apply le_n_S. apply minus_O_le. exact H. intros p'. intros Heq_minus; simpl in |- *; elim (Hrec p' q). intros d; case (Qpositive_i (Qpositive_c (S p') (S q) n)). simpl in |- *; intros p'' q'' (Heq1, Heq2). exists d; split; auto. rewrite (le_plus_minus (S q) (S p)); simpl in |- *. rewrite Heq_minus. replace (S (q + S p')) with (S q + S p'). rewrite Heq2; rewrite Heq1; ring. simpl in |- *; auto. auto with arith. rewrite <- Heq_minus. replace (p - q) with (S p - S q). rewrite <- (plus_comm (S q)). rewrite <- (le_plus_minus (S q) (S p)). apply le_trans with (S p + q). auto with arith. apply le_S_n; rewrite plus_n_Sm. exact Hle. auto with arith. auto. Qed. Theorem construct_correct2' : forall n p q : nat, 1 <= p -> 1 <= q -> p + q <= n -> exists d : nat, p = fst (Qpositive_i (Qpositive_c p q n)) * S d /\ q = snd (Qpositive_i (Qpositive_c p q n)) * S d. 
H l0 l1 l def idx. generalize (len ft); clear ft. intros. assert (n + n0 = n + (n1 + n2)) as e0' by omega. replace ((eq_rec (n + n0) (fun n => word n) w (n + n1 + n2) e0)) with (match plus_assoc _ _ _ in _ = N return word N with | refl_equal => (eq_rec (n+n0) (fun n => word n) w (n+(n1+n2)) e0') end). rewrite <- split2_iter. f_equal. generalize dependent e0'; clear e0. rewrite <- e; intros. repeat rewrite <- eq_rec_eq. reflexivity. destruct (Nat.add_assoc n n1 n2). destruct e0. repeat rewrite <- eq_rec_eq. reflexivity. Qed. Lemma word_updN_helper1 : forall idx l lenft, idx < l -> lenft + (l * lenft - idx * lenft - lenft) = l * lenft - idx * lenft. Proof. intros. rewrite Nat.add_sub_assoc. rewrite plus_comm. rewrite <- Nat.add_sub_assoc by omega. rewrite Nat.sub_diag. omega. rewrite <- Nat.mul_sub_distr_r. replace (lenft) with (1 * lenft) at 1 by omega. apply Nat.mul_le_mono_r; omega. Qed. Lemma word_updN_helper2 : forall idx l lenft, idx < l -> idx * lenft + (l * lenft - idx * lenft) = l * lenft. Proof. intros. rewrite Nat.add_sub_assoc. rewrite plus_comm. rewrite <- Nat.add_sub_assoc by omega. rewrite Nat.sub_diag. omega. apply Nat.mul_le_mono_r; omega. Qed. Definition word_updN {ft : type} {l : nat} (idx : nat) (w : word (len (ArrayF ft l))) (v : word (len ft)) : word (len (ArrayF ft l)). refine (if lt_dec idx l then _ else w); simpl in *. replace (l * len ft) with (idx * len ft + (l * len ft - idx * len ft)) in * by (apply word_updN_helper2; assumption). remember (split1 (idx * len ft) (l * len ft - idx * len ft) w) as low; clear Heqlow. refine (combine low _). replace (l * len ft - idx * len ft) with (len ft + (l * len ft - idx * len ft - len ft)) in * by (apply word_updN_helper1; assumption). rewrite plus_assoc in *. remember (split2 (idx * len ft + len ft) (l * len ft - idx * len ft - len ft) w) as hi; clear Heqhi. refine (combine v hi). Defined. Theorem word_updN_oob : forall ft l idx w v, idx >= l -> @word_updN ft l idx w (to_word v) = w. Proof. unfold word_updN; simpl; intros. destruct (lt_dec idx l); auto. exfalso; omega. Qed. Theorem word_updN_equiv : forall ft l idx w v, idx < l -> @word_updN ft l idx w (to_word v) = @to_word (ArrayF ft l) (updN (of_word w) idx v). 
Require Export Fprop. Require Export Fodd. Section FRound. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition TotalP (P : R -> float -> Prop) := forall r : R, exists p : float, P r p. Definition UniqueP (P : R -> float -> Prop) := forall (r : R) (p q : float), P r p -> P r q -> p = q :>R. Definition CompatibleP (P : R -> float -> Prop) := forall (r1 r2 : R) (p q : float), P r1 p -> r1 = r2 -> p = q :>R -> Fbounded b q -> P r2 q. Definition MinOrMaxP (P : R -> float -> Prop) := forall (r : R) (p : float), P r p -> isMin b radix r p \/ isMax b radix r p. Definition RoundedModeP (P : R -> float -> Prop) := TotalP P /\ CompatibleP P /\ MinOrMaxP P /\ MonotoneP radix P. Theorem RoundedModeP_inv1 : forall P, RoundedModeP P -> TotalP P. intros P H; case H; auto. Qed. Theorem RoundedModeP_inv2 : forall P, RoundedModeP P -> CompatibleP P. intros P H; Casec H; intros H H1; Casec H1; auto. Qed. Theorem RoundedModeP_inv3 : forall P, RoundedModeP P -> MinOrMaxP P. intros P H; Casec H; intros H H1; Casec H1; intros H1 H2; Casec H2; auto. Qed. Theorem RoundedModeP_inv4 : forall P, RoundedModeP P -> MonotoneP radix P. intros P H; Casec H; intros H H1; Casec H1; intros H1 H2; Casec H2; auto. Qed. Hint Resolve RoundedModeP_inv1 RoundedModeP_inv2 RoundedModeP_inv3 RoundedModeP_inv4: inv. Theorem RoundedProjector : forall P, RoundedModeP P -> ProjectorP b radix P. intros P H'; red in |- *; simpl in |- *. intros p q H'0 H'1. red in H'. elim H'; intros H'2 H'3; elim H'3; intros H'4 H'5; elim H'5; intros H'6 H'7; case (H'6 p q); clear H'5 H'3 H'; auto. intros H'; apply (ProjectMin b radix p); auto. intros H'; apply (ProjectMax b radix p); auto. Qed. Theorem MinCompatible : CompatibleP (isMin b radix). 
X'. Hypothesis HR: diagram RX R RX (plus S). Theorem diagram_plus: diagram RX (plus R) RX (plus S). Proof. intros x x' z Hxx' xRz; destruct xRz as [ y xRy yRz ]. elim (HR Hxx' xRy); intros y' Hyy' x'Sy'. elim diagram_star with X X' RX R S y y' z; auto. intros z' Hzz' y'Sz'. exists z'; auto; apply plus_star_plus with y'; assumption. apply diagram_incl with R (plus S); auto. Qed. End Plus. Section PlusWf. Variable X: Set. Variable S: relation X. Variable TX: relation X. Hypothesis HS: diagram TX S (star TX) (plus S). Hypothesis Hwf: well_founded (trans S). Let Hpwf: well_founded (trans (plus S)) := plus_wf Hwf. Lemma diagram_plus_wf: diagram (star TX) (plus S) (star TX) (plus S). Proof. intros x x'; cgen x. induction x' as [x' IH ] using (well_founded_ind Hpwf). intros x y xTx'; cgen y. induction xTx' as [ x | x1 x x' xTx1 x1Ts' IHv ]; intros y xSy. exists y; auto. destruct xSy as [ w xSw wSy ]. destruct (HS xTx1 xSw) as [ w1 wTw1 x1Sw1 ]. elim IHv with w1; auto; intros w' w1Tw' x'Sw'. destar wSy z. exists w'; auto; apply star_trans with w1; assumption. elim IH with w' w y; auto. intros y' yTy' w'Ty'. exists y'; auto; apply plus_trans with w'; assumption. apply star_trans with w1; assumption. Qed. Variable TX': relation X. Hypothesis HS': diagram TX' S (comp (star TX) TX') (plus S). Lemma diagram_plus_wf_1: strong_commute (comp (star TX) TX') (plus S). Proof. intros x x'; cgen x. induction x' as [x' IH ] using (well_founded_ind Hpwf). intros x y xTx' xSy; destruct xTx' as [ x1 xTx1 x1Tx' ]. destruct (diagram_plus_wf xTx1 xSy) as [ y1 yTy1 x1Sy1 ]. destruct x1Sy1 as [ w1 x1Sw1 w1Sy1 ]. destruct (HS' x1Tx' x1Sw1) as [ w' w1Tw' x'Sw' ]. destar w1Sy1 z1. destruct w1Tw' as [ w2 w1Tw2 w2Tw' ]; exists w'; auto; exists w2; auto; apply star_trans with w1; auto. elim IH with w' w1 y1; auto. intros y' y1Ty' w'Sy'; exists y'. destruct y1Ty' as [ y2 y1Ty2 y2Ty' ]; exists y2; auto; apply star_trans with y1; auto. apply plus_trans with w'; auto. Qed. Variable Y: Type. Variables R R': relation2 X Y. Variable TY TY': relation Y. Hypothesis HR: diagram TX R (star TY) (comp (star S) R). Hypothesis HR': diagram TX' R (comp (star TY) TY') (comp (star S) R'). Theorem diagram_plus_wf_2: diagram (comp (star TX) TX') (comp (star S) R) (comp (star TY) TY') (comp (star S) R'). 
rewrite H_makeTag. rewrite H_make_ctor_rep. auto. simpl. rewrite IHl0. auto. - simpl. induction (rev l). simpl. rewrite H_makeTag. auto. simpl. rewrite IHl0. auto. Admitted. *)Theorem find_symbol_map: forall p fenv m finfo_env id v, find_symbol_domain p finfo_env -> var_or_funvar id m fenv finfo_env p v (makeVar id m v fenv finfo_env). Proof. intros. specialize (H v). inv H. destruct (cps.M.get v finfo_env) eqn:Hgvm. - destruct (H0 (ex_intro _ p0 (eq_refl _))). econstructor. apply H. - unfold makeVar. rewrite Hgvm. econstructor. destruct (Genv.find_symbol (Genv.globalenv p) v) eqn:Hgpv; auto. exfalso. destruct (H1 (ex_intro _ b (eq_refl _))). inv H. Qed. Theorem find_symbol_map_f: forall p fenv m finfo_env id v, find_symbol_domain p finfo_env -> var_or_funvar_f id m fenv finfo_env p v = makeVar id m v fenv finfo_env. Proof. intros. apply var_or_funvar_of_f. apply find_symbol_map; auto. Qed.Theorem asgnAppVars_correct: forall p fenv finfo_env, forall vs avs ind aind s, find_symbol_domain p finfo_env -> avs = skipn nParam vs -> aind = skipn nParam ind -> asgnAppVars' argsIdent threadInfIdent nParam vs ind fenv finfo_env = Some s -> repr_asgn_fun' argsIdent threadInfIdent nParam fenv finfo_env p avs aind s. Proof. intros p fenv finfo_env vs avs. generalize vs. clear vs. induction avs; intros vs ind aind s Hfinfo_env Hvs Hind Hasgn; unfold asgnAppVars' in Hasgn. - destruct aind; rewrite <- Hvs in Hasgn; rewrite <- Hind in Hasgn; destruct nParam; inv Hasgn; constructor. - destruct aind; rewrite <- Hvs in Hasgn; rewrite <- Hind in Hasgn; [ destruct nParam; inv Hasgn | ]. destruct vs; [destruct nParam; inv Hvs | ]. destruct ind; [destruct nParam; inv Hind | ]. symmetry in Hvs. set (Hvs' := skipn_cons nParam p0 a vs avs Hvs). symmetry in Hvs'. symmetry in Hind. set (Hind' := skipn_cons nParam n0 n ind aind Hind). symmetry in Hind'. simpl in Hasgn. destruct (asgnAppVars'' argsIdent threadInfIdent nParam avs aind fenv) eqn:Happ. 2: inv Hasgn. specialize (IHavs _ _ _ s0 Hfinfo_env Hvs' Hind'). unfold asgnAppVars' in IHavs. rewrite <- Hvs' in IHavs. rewrite <- Hind' in IHavs. apply IHavs in Happ. inv Hasgn. erewrite <- find_symbol_map_f; eauto. exact (repr_asgn_cons _ _ _ _ _ _ _ _ _ _ s0 Happ). Qed. Theorem repr_call_vars_length1 : forall p fenv map n l1 l2, repr_call_vars threadInfIdent nParam fenv map p n l1 l2 -> length l1 = n. Proof. induction n; intros l1 l2 Hr; destruct l1; inv Hr. + reflexivity. + simpl. apply f_equal. eapply IHn. eauto. Qed. Theorem mkCallVars_correct: forall p fenv map n vs bvs es, find_symbol_domain p map -> bvs = firstn nParam vs -> mkCallVars threadInfIdent nParam fenv map n bvs = Some es -> repr_call_vars threadInfIdent nParam fenv map p n bvs es. 
Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. intros. apply PTree.gro. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply grs. apply gro; auto. Qed. Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq. Theorem beq_sound: forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A), beq eqA t1 t2 = true -> forall (x: elt), match get x t1, get x t2 with | None, None => True | Some y1, Some y2 => eqA y1 y2 = true | _, _ => False end. Proof. unfold beq, get. intros. rewrite PTree.beq_correct in H. apply H. Qed. Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine. Theorem gcombine: forall (A B C: Type) (f: option A -> option B -> option C), f None None = None -> forall (m1: t A) (m2: t B) (i: elt), get i (combine f m1 m2) = f (get i m1) (get i m2). 
assert (Z.neg p < 0)%Z by apply Pos2Z.neg_is_neg. omega. Qed. Theorem unzip_vars: forall vs0 vars x, Forall2 (fun (x0 : var) (xt : var * type) => xt = (x0, uval)) vs0 vars -> List.In x (var_names vars) <-> List.In x vs0. Proof. induction vs0; intros. inv H. split; intro H; inv H. inv H. simpl. apply IHvs0 with (x := x) in H4. rewrite <- H4. reflexivity. Qed. Theorem case_of_labeled_stm_unboxed: forall rep_env arr t n0 e p fenv finfo_env ienv cenv , correct_ienv_of_cenv cenv ienv -> M.get t rep_env = Some (enum arr) -> correct_crep_of_env cenv rep_env -> repr_unboxed_L7 arr n0 -> forall cl ls ls', caseConsistent cenv cl t -> findtag cl t = Some e -> repr_branches_L6_L7 argsIdent allocIdent limitIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam fenv finfo_env p rep_env cl ls ls' -> exists s s', seq_of_labeled_statement (select_switch (Z.shiftr n0 1) ls') = (Ssequence (Ssequence s Sbreak) s') /\ repr_expr_L6_L7_id fenv finfo_env p rep_env e s. Proof. intros rep_env arr t n0 e p fenv finfo_env ienv cenv Hienv H H0 H1. induction cl; intros ls ls' Hcc; intros. inv H2. simpl in H2. destruct a. destruct (M.elt_eq c t). - inv H2. inv H3. 3:{ rewrite H10 in H. inv H. } 3:{ rewrite H10 in H. inv H. } + simpl. exists s, Sskip. split. reflexivity. auto. + rewrite H10 in H. inv H. exists s, (seq_of_labeled_statement ( (LScons lsa' lsb' lsc'))). split; auto. simpl. unfold select_switch. simpl. assert (tag = n0). inv H11; inv H1. auto. subst. rewrite Coqlib.zeq_true. simpl. reflexivity. - inv H3. + exfalso. assert (Hn_repr := repr_branches_LSnil_no_unboxed _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2 H11). apply Hn_repr. eauto. + simpl. unfold select_switch. simpl select_switch_case. rewrite Coqlib.zeq_false. inv Hcc. specialize (IHcl _ _ H14 H2 H7). apply IHcl. inv H0. apply H4 in H11. apply H4 in H. inv H. inv H11. assert (it = it0). { inv Hcc. rewrite H5 in H13; rewrite H0 in H14; inv H13; inv H14. auto. } subst. assert (n1 <> arr). { assert (Hdj := disjoint_ord Hienv H0 H5). apply Hdj. auto. } inv Hcc. rewrite H5 in H14; inv H14. rewrite H0 in H15; inv H15. intro. do 2 (erewrite repr_unboxed_shiftr in H6 by eauto). apply H. apply N2Z.inj. apply H6. + inv Hcc; eapply IHcl; eauto. + inv Hcc; eapply IHcl; eauto. Qed. Theorem case_of_labeled_stm_boxed: forall rep_env n arr t h e p fenv finfo_env ienv cenv , correct_ienv_of_cenv cenv ienv -> M.get t rep_env = Some (boxed n arr) -> correct_crep_of_env cenv rep_env -> boxed_header n arr h -> forall cl ls ls', caseConsistent cenv cl t -> findtag cl t = Some e -> repr_branches_L6_L7 argsIdent allocIdent limitIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam fenv finfo_env p rep_env cl ls ls' -> exists s s', (seq_of_labeled_statement (select_switch (Z.land h 255) ls)) = (Ssequence (Ssequence s Sbreak) s') /\ repr_expr_L6_L7_id fenv finfo_env p rep_env e s. 
/\ error = q :>R /\ (Fexp error <= Zmax (Fexp p - precision) (- dExp b))%Z. intros p q x H H0 H1 H2; exists (Fnormalize radix b precision q). cut (Fcanonic radix b (Fnormalize radix b precision q)); [ intros C1 | apply FnormalizeCanonic; auto with arith ]. split. apply FcanonicBound with (radix := radix); auto. split. apply (FnormalizeCorrect radix); auto. case C1; intros C2. apply Zle_trans with (Fexp p - precision)%Z; auto with zarith. apply Zplus_le_reg_l with (Z_of_nat precision). replace (precision + (Fexp p - precision))%Z with (Fexp p); [ idtac | ring ]. replace (precision + Fexp (Fnormalize radix b precision q))%Z with (Zsucc (Zpred precision + Fexp (Fnormalize radix b precision q))); [ idtac | unfold Zpred, Zsucc in |- *; ring ]. apply Zlt_le_succ. apply Zlt_powerRZ with (IZR radix); auto with real zarith. rewrite powerRZ_add; auto with real zarith. apply Rle_lt_trans with (Zabs (Fnum (Fnormalize radix b precision q)) * powerRZ radix (Fexp (Fnormalize radix b precision q)))%R. apply Rmult_le_compat_r; auto with real zarith. replace (Zpred precision) with (Z_of_nat (pred (digit radix (Fnum (Fnormalize radix b precision q))))). rewrite <- Zpower_nat_Z_powerRZ. apply Rle_IZR; apply digitLess; auto with real zarith. change (~ is_Fzero (Fnormalize radix b precision q)) in |- *; apply (FnormalNotZero radix b); auto with float. change (Z_of_nat (pred (Fdigit radix (Fnormalize radix b precision q))) = Zpred precision) in |- *. rewrite FnormalPrecision with (precision := precision) (4 := C2); auto with zarith arith. apply inj_pred; auto with arith. change (Fabs (Fnormalize radix b precision q) < powerRZ radix (Fexp p))%R in |- *. rewrite (Fabs_correct radix); auto; rewrite (FnormalizeCorrect radix); auto. apply Rle_lt_trans with (Float 1%nat (Fexp p) * / 2%nat)%R. apply ClosestErrorBound with (x := x); auto. unfold FtoRradix in |- *; unfold FtoR in |- *; simpl in |- *. pattern (powerRZ radix (Fexp p)) at 2 in |- *; replace (powerRZ radix (Fexp p)) with (powerRZ radix (Fexp p) * 1)%R; [ idtac | ring ]. replace (1 * powerRZ radix (Fexp p))%R with (powerRZ radix (Fexp p)); [ apply Rmult_lt_compat_l | ring ]. apply powerRZ_lt; auto with arith real. pattern 1%R at 3 in |- *; replace 1%R with (/ 1)%R. apply Rinv_1_lt_contravar; auto with real. replace 2%R with (INR 2); auto with real arith. apply Zle_trans with (- dExp b)%Z; auto with float zarith. case C2. intros H3 (H4, H5); rewrite H4; auto with zarith. Qed. Theorem ClosestErrorBoundNormal_aux : forall (x : R) (p : float), Closest b radix x p -> Fnormal radix b (Fnormalize radix b precision p) -> (Rabs (x - p) <= Rabs p * (/ 2%nat * (radix * / Zpos (vNum b))))%R. 
Require Export List. From Huffman Require Export Aux. Section permutation. Variable A : Type. Inductive permutation : list A -> list A -> Prop := | permutation_nil : permutation nil nil | permutation_skip : forall (a : A) (l1 l2 : list A), permutation l2 l1 -> permutation (a :: l2) (a :: l1) | permutation_swap : forall (a b : A) (l : list A), permutation (a :: b :: l) (b :: a :: l) | permutation_trans : forall l1 l2 l3 : list A, permutation l1 l2 -> permutation l2 l3 -> permutation l1 l3. Hint Constructors permutation : core. Theorem permutation_refl : forall l : list A, permutation l l. Proof using. simple induction l. apply permutation_nil. intros a l1 H. apply permutation_skip with (1 := H). Qed. Hint Resolve permutation_refl : core. Theorem permutation_sym : forall l m : list A, permutation l m -> permutation m l. Proof using. intros l1 l2 H'; elim H'. apply permutation_nil. intros a l1' l2' H1 H2. apply permutation_skip with (1 := H2). intros a b l1'. apply permutation_swap. intros l1' l2' l3' H1 H2 H3 H4. apply permutation_trans with (1 := H4) (2 := H2). Qed. Theorem permutation_length : forall l m : list A, permutation l m -> length l = length m. Proof using. intros l m H'; elim H'; simpl in |- *; auto. intros l1 l2 l3 H'0 H'1 H'2 H'3. rewrite <- H'3; auto. Qed. Theorem permutation_nil_inv : forall l : list A, permutation l nil -> l = nil. Proof using. intros l H; generalize (permutation_length _ _ H); case l; simpl in |- *; auto. intros; discriminate. Qed. Lemma permutation_one_inv_aux : forall l1 l2 : list A, permutation l1 l2 -> forall a : A, l1 = a :: nil -> l2 = a :: nil. Proof using. intros l1 l2 H; elim H; clear H l1 l2; auto. intros a l3 l4 H0 H1 b H2. apply f_equal2 with (f := cons (A:=A)). injection H2; auto. apply permutation_nil_inv; auto. injection H2; intros H3 H4; rewrite <- H3; auto. apply permutation_sym; auto. intros; discriminate. Qed. Theorem permutation_one_inv : forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil. Proof using. intros a l H; apply permutation_one_inv_aux with (l1 := a :: nil); auto. Qed. Theorem permutation_in : forall (a : A) (l m : list A), permutation l m -> In a l -> In a m. 
&?); subst state'; exists h1, (union h2 h3); rewrite state_union_associative; assert (D' := D); apply state_disjoint_union_distributive in D' as [?%symmetry ?%symmetry]; repeat split; repeat apply state_star_intro; trivial; apply state_disjoint_union_distributive; split; trivial. - intros state (h1 & state' &?&(h2 & h3 &?&?&?&?)&D&?); subst state'; exists (union h1 h2), h3; rewrite <-state_union_associative; assert (D' := D); apply state_disjoint_union_distributive in D' as []; repeat split; repeat apply state_star_intro; trivial; symmetry; apply state_disjoint_union_distributive; split; symmetry; trivial. Qed. Theorem state_star_empty_l H: \[] \* H <*> H. Proof. apply state_implies_antisymmetric; hnf. - intros ? [? (? & ?%state_unknown_inversion & ? & ? & ?)]; subst; rewrite state_union_empty_l; assumption. - intros ?; exists empty, state; repeat split; simpl; try apply state_unknown_intro; try apply map_disjoint_empty_l; try rewrite state_union_empty_l; trivial. Qed. Theorem state_star_empty_r H: H \* \[] <*> H. Proof. rewrite state_star_commutative; apply state_star_empty_l. Qed. Theorem state_star_exists A (P: A -> Assertion) H: (\exists a, P a) \* H <*> \exists a, (P a \* H). Proof. apply state_implies_antisymmetric; intros state. - intros (s1 & s2 & (a &?)&?&?&?); exists a, s1, s2; auto. - intros (a & (s1 & s2 &?&?&?&?)); exists s1, s2; split; auto; exists a; trivial. Qed. Theorem state_implies_frame_l H2 H1 H1': H1 **> H1' -> (H1 \* H2) **> (H1' \* H2). Proof. intros ?? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_frame_r H1 H2 H2': H2 **> H2' -> (H1 \* H2) **> (H1 \* H2'). Proof. intros ?? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_frame H1 H1' H2 H2': H1 **> H1' -> H2 **> H2' -> (H1 \* H2) **> (H1' \* H2'). Proof. intros ??? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_star_trans_l H1 H2 H3 H4: H1 **> H2 -> H2 \* H3 **> H4 -> H1 \* H3 **> H4. Proof. intros M1 M2 ? (s1 & s2 & (?&?&?&?)); apply M2; exists s1, s2; auto. Qed. Theorem state_implies_star_trans_r H1 H2 H3 H4: H1 **> H2 -> H3 \* H2 **> H4 -> H3 \* H1 **> H4. Proof. intros M1 M2 ? (s1 & s2 & (?&?&?&?)); apply M2; exists s1, s2; auto. Qed. Theorem state_pure_intro: forall P: Prop, P -> \[P] empty. Proof. intros ? P; exists P; hnf; auto. Qed. Theorem state_pure_inversion: forall P state, \[P] state -> P /\ state = empty. Proof. intros ?? A; hnf in A; naive_solver. Qed. Theorem state_star_pure_l P H state: (\[P] \* H) state <-> P /\ (H state). 
v v0 count : get_c v0 (M.set v (get_c v count + 1) count) = get_c v0 count + get_c v0 (M.set v 1 (M.empty nat)). Proof. intros. destruct (var_dec v v0). - subst. rewrite gdss. rewrite gdss. reflexivity. - rewrite gdso by auto. rewrite gdso by auto. rewrite gdempty. rewrite <- plus_n_O. auto. Qed. Theorem combine_plus_census_correct : (forall m count sig, map_getd_r _ 0 (M.combine (f_opt_d 0 plus) count (init_census (rename_all_ns sig m))) (update_census sig m c_plus count)) /\ (forall f count sig, map_getd_r _ 0 (M.combine (f_opt_d 0 plus) count (update_census_f (M.empty var) (rename_all_fun_ns sig f) c_plus (M.empty nat))) (update_census_f sig f c_plus count)). Proof. eapply exp_def_mutual_ind; intros; simpl. - intro. rewrite gccombine'. rewrite <- H. rewrite gccombine'. unfold init_census. simpl. rewrite <- combine_plus_census_list. rewrite gccombine'. assert (Hfr := init_census_f_ar). destruct (Hfr c_plus). intros. simpl. rewrite H0. auto. rewrite H0. rewrite <- H. rewrite gccombine'. simpl. unfold init_census. lia. - intro. rewrite gccombine'. unfold init_census. simpl. rewrite plus_n_O. rewrite apply_r_empty. simpl. rewrite get_c_up. lia. - intro. rewrite gccombine'. unfold init_census. simpl. unfold init_census in H0. simpl in H0. rewrite init_census_plus_ar. symmetry. erewrite proper_plus_census_d. 2:{ apply smgd_sym. apply H0. } rewrite <- H. rewrite <- H. do 3 (rewrite gccombine'). lia. - unfold init_census. simpl. intro. rewrite gccombine'. rewrite <- H. rewrite gccombine'. rewrite init_census_plus_ar. rewrite <- H. rewrite gccombine'. rewrite apply_r_empty. rewrite get_c_up. simpl. lia. - intro. rewrite gccombine'. rewrite <- H. rewrite gccombine'. unfold init_census. simpl. rewrite <- !combine_plus_census_list. rewrite gccombine'. assert (Hfr := init_census_f_ar). destruct (Hfr c_plus). intros. simpl. rewrite H0. now auto. rewrite H0. rewrite <- H. rewrite gccombine'. unfold init_census. rewrite <- combine_plus_census_list. rewrite !gccombine'. rewrite !apply_r_empty. rewrite !get_c_up, apply_r_list_empty. lia. - intro. rewrite gccombine'. unfold init_census. simpl. rewrite init_census_plus_ar. rewrite <- H0. rewrite gccombine'. symmetry. rewrite <- H0. rewrite gccombine'. rewrite <- H. rewrite gccombine'. lia. - intro. rewrite gccombine'. rewrite <- combine_plus_census_list. rewrite gccombine'. unfold init_census. simpl. rewrite <- combine_plus_census_list. rewrite gccombine'. rewrite apply_r_empty. rewrite apply_r_list_empty. rewrite get_c_up. lia. - intro. rewrite gccombine'. unfold init_census. simpl. rewrite <- H. rewrite gccombine'. rewrite init_census_plus_ar. rewrite <- H. rewrite gccombine'. symmetry. rewrite <- combine_plus_census_list. rewrite gccombine'. lia. - intro. rewrite gccombine'. rewrite get_c_up. unfold init_census. simpl. rewrite apply_r_empty. lia. - intro; rewrite gccombine'. rewrite <- H0. rewrite gccombine'. rewrite init_census_plus_ar_f. rewrite <- H0. rewrite gccombine'. symmetry. rewrite <- H. rewrite gccombine'. unfold init_census. lia. - intro. rewrite gccombine'. rewrite gdempty. rewrite plus_n_O. reflexivity. Qed. Theorem num_occur_constr: forall {e} {v} {n n'}, num_occur e v n -> n = n' -> num_occur e v n'. 
auto. Qed. Theorem minuspf_inv1_eq : forall (a b : Term A n) (p q : list (Term A n)), ltT ltM b a -> pX a (minuspf p (pX b q)) = minuspf (pX a p) (pX b q). intros a b p q H'; try assumption. rewrite (minusP_inv1 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv2_eq : forall (a b : Term A n) (p q : list (Term A n)), ltT ltM a b -> pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q) = minuspf (pX a p) (pX b q). intros a b p q H'; try assumption. rewrite (minusP_inv2 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3a_eq : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> minuspf p q = minuspf (pX a p) (pX b q). intros a b p q H' Z; try assumption. rewrite (minusP_inv3a a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3b_eq : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> pX (minusTerm (A:=A) minusA (n:=n) a b) (minuspf p q) = minuspf (pX a p) (pX b q). intros a b p q H' Z; try assumption. rewrite (minusP_inv3b a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv1 : forall (a b : Term A n) (p q : list (Term A n)), ltT ltM b a -> eqP A eqA n (pX a (minuspf p (pX b q))) (minuspf (pX a p) (pX b q)). intros a b p q H'; try assumption. rewrite (minusP_inv1 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv2 : forall (a b : Term A n) (p q : list (Term A n)), ltT ltM a b -> eqP A eqA n (pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q)) (minuspf (pX a p) (pX b q)). intros a b p q H'; try assumption. rewrite (minusP_inv2 a b p q (minuspf (pX a p) (pX b q))); auto. Qed. Theorem minuspf_inv3a : forall (a b : Term A n) (p q : list (Term A n)), eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> eqP A eqA n (minuspf p q) (minuspf (pX a p) (pX b q)). 
Hstep as [ds' [dinv' [MATCH' [dtr' stp']]]]. econstructor 4; eauto. { apply stp'. } intro U''; specialize (Hsafe U''). destruct Hsafe as [[? [Hphi Hext]] Hsafe]. specialize (Hsafe _ Hphi [:: Some (ghost_PCM.ext_ref tt, NoneP)]) as (? & ? & ? & ? & Hr & ? & Hsafe); auto. { apply join_sub_refl. } eapply MTCH_tp_update in MATCH'; eauto. } Qed. Theorem erasure_safety: forall ge cd j js ds m n, Erasure.match_state ge cd j js m ds m -> jm_csafe js m n -> HybridMachineSig.HybridCoarseMachine.csafe ds m n. Proof. intros ? ? ? ? ? ? ? MATCH jsafe. inversion MATCH. subst. eapply erasure_safety'; eauto. Qed. End ErasureSafety.End ErasureSafety.Require Import VST.concurrency.juicy.semax_to_juicy_machine.Lemma no_locks_no_locks_perm : forall r, Parching.no_locks_perm r <-> initial_world.no_locks r. Proof. unfold Parching.no_locks_perm, initial_world.no_locks, perm_of_res_lock; split; intros. - destruct addr as (b, ofs); specialize (H b ofs). destruct (r @ (b, ofs)); try discriminate. destruct (perm_of_sh (Share.glb Share.Rsh sh0)) eqn: Hsh. destruct k; discriminate. { contradiction r0. apply perm_of_empty_inv in Hsh as ->; auto. } - specialize (H (b, ofs)). destruct (r @ (b, ofs)); auto. specialize (H sh r0). destruct k; auto. specialize (H n i p). contradiction; auto. Qed. Lemma juice2Perm_match : forall m r, access_cohere' m r -> Parching.match_rmap_perm r (juice2Perm r m, empty_map). Proof. split; auto; simpl. intros; apply juic2Perm_correct; auto. Qed.Section DrySafety. Variable (CPROOF : CSL_proof). Instance Sem : Semantics := ClightSemanticsForMachines.Clight_newSem (Clight.globalenv CPROOF.(CSL_prog)). Definition ge := Clight.globalenv CPROOF.(CSL_prog). Instance DTP : threadPool.ThreadPool.ThreadPool := Parching.DTP ge. Instance DMS : HybridMachineSig.MachineSig := Parching.DMS ge. Definition init_mem := proj1_sig (init_mem CPROOF). Definition init_rmap n := m_phi (initial_jm CPROOF n). Lemma init_match n : Parching.match_rmap_perm (init_rmap n) (getCurPerm init_mem, empty_map). Proof. split; auto; simpl. unfold init_rmap, initial_jm, spr. destruct (semax_prog.semax_prog_rule' _ _ _ _ _ _ _ _) as (? & ? & ? & s); simpl. destruct (s n tt) as (jm & ? & ? & ? & ? & ? & ?); simpl. destruct jm; simpl in *; subst; intros. rewrite <- (JMaccess (b, ofs)). unfold access_at, PMap.get; simpl. rewrite PTree.gmap1. fold init_mem; destruct ((snd (Mem.mem_access init_mem)) ! b); auto. Qed. Lemma init_no_locks n : Parching.no_locks_perm (init_rmap n). Proof. apply no_locks_no_locks_perm. unfold init_rmap, initial_jm, spr. destruct (semax_prog.semax_prog_rule' _ _ _ _ _ _ _ _) as (? & ? & ? & s); simpl. destruct (s n tt) as (jm & ? & ? & ? & ? & ? & ?); auto. Qed. Theorem dry_safety_initial_state (sch : HybridMachineSig.schedule) (n : nat) : HybridMachineSig.HybridCoarseMachine.csafe (sch, [::], DryHybridMachine.initial_machine(Sem := Sem) (getCurPerm init_mem) (initial_corestate CPROOF)) init_mem n. 
mem_range_valid in H0. apply Hglobal in H. destructAll. exists x0. apply H0. auto. Qed.Corollary correct_tinfo_after_store: forall p z lenv m, correct_tinfo p z lenv m -> forall m' chunk b ofs v, Mem.store chunk m b ofs v = Some m' -> correct_tinfo p z lenv m'. Proof. intros. eapply correct_tinfo_valid_access. apply H. eapply mem_range_valid. intros. eapply Mem.store_valid_access_1 in H0; eauto. Qed. Corollary valid_access_after_nstore: forall vs m m' i b' ofs', forall chunk b ofs p, Mem.valid_access m chunk b ofs p -> mem_after_n_proj_store b' ofs' vs i m m' -> Mem.valid_access m' chunk b ofs p. Proof. induction vs; intros. - inv H0. - inv H0. + eapply Mem.store_valid_access_1; eauto. + eapply IHvs. 2: apply H9. eapply Mem.store_valid_access_1; eauto. Qed. Corollary correct_tinfo_after_nstore: forall p vs z lenv m m' b ofs i, correct_tinfo p z lenv m -> mem_after_n_proj_store b ofs vs i m m' -> correct_tinfo p z lenv m'. Proof. induction vs; intros. - inv H0. - inv H0. + eapply correct_tinfo_after_store; eauto. + eapply IHvs. 2:{ apply H9. } eapply correct_tinfo_after_store; eauto. Qed. Theorem var_names_app: forall l1 l2, (var_names (l1 ++ l2)) = (var_names l1 ++ var_names l2). Proof. induction l1. reflexivity. intros. destruct a; simpl. rewrite IHl1. reflexivity. Qed. Definition repr_expr_L6_L7_id := repr_expr_L6_L7 argsIdent allocIdent limitIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam. Definition rel_mem_L6_L7_id := rel_mem_L6_L7 argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam. Definition repr_val_L_L6_L7_id := repr_val_L_L6_L7 argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam. Definition repr_val_id_L_L6_L7_id := repr_val_id_L_L6_L7 argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam. Definition protected_id_not_bound_id := protected_id_not_bound argsIdent allocIdent limitIdent gcIdent mainIdent bodyIdent threadInfIdent tinfIdent heapInfIdent numArgsIdent isptrIdent caseIdent.Definition protected_not_in_L_id := protected_not_in_L argsIdent allocIdent limitIdent tinfIdent.Theorem Z_non_neg_add: forall n m p, (n <= m -> 0 <= p -> n <= p + m)%Z. Proof. intros. etransitivity. eauto. omega. Qed. Inductive nth_arg_rel_L6_L7 (fenv:fun_env) (finfo_env:fun_info_env) (p:program) (rep_env: M.t ctor_rep) : L6.eval.env -> positive -> temp_env -> mem -> Z -> Prop := | is_in_and_rel: forall lenv args_b args_ofs rho m n x L6v L7v L, protected_not_in_L argsIdent allocIdent limitIdent tinfIdent p lenv L -> M.get x rho = Some L6v -> M.get argsIdent lenv = Some (Vptr args_b args_ofs) -> Mem.load int_chunk m args_b (Ptrofs.unsigned (Ptrofs.add args_ofs (Ptrofs.mul (Ptrofs.repr (sizeof (M.empty composite) val)) (Ptrofs.repr n)))) = Some L7v -> repr_val_L_L6_L7_id fenv finfo_env p rep_env L6v m L L7v -> nth_arg_rel_L6_L7 fenv finfo_env p rep_env rho x lenv m n. Theorem caseConsistent_findtag_In_cenv: forall cenv t e l, caseConsistent cenv l t -> findtag l t = Some e -> exists (a aty:BasicAst.name) (ty:ind_tag) (n:N) (i:N), M.get t cenv = Some (Build_ctor_ty_info a aty ty n i). 
"Hpre". wpc_call. { crash_case; auto. } { crash_case; auto. } iCache with "HΦ Hfupd". { crash_case; auto. } wpc_pures. iNamed "Hdir". iNamed "Hro_state". edestruct (lookup_lt_is_Some_2 inode_refs) as [inode_ref Hinode_ref]. { rewrite Hlen. done. } iDestruct (big_sepL_lookup _ _ _ _ Hinode_ref with "Hinodes") as "Hinode {Hinodes}". wpc_frame_seq. wp_loadField. iMod (readonly_load with "inodes_s") as (qinodes) "{inodes_s} inodes_s". wp_apply (wp_SliceGet _ _ _ _ _ inode_refs with "[$inodes_s //]"). iIntros "inodes_s Hrest". iNamed "Hrest". wpc_pures. iApply (wpc_step_strong_mono _ _ _ _ _ (λ v, ∃ (sz : u64), ⌜ v = #sz ⌝ ∗ Q sz)%I _ _ with "[-HΦ] [HΦ]"); auto. 2: { iSplit. * iNext. iIntros (?) "H". iDestruct "H" as (?) "(%&?)". subst. iModIntro. iRight in "HΦ". by iApply "HΦ". * iLeft in "HΦ". iIntros. iModIntro. by iApply "HΦ". } iApply (wpc_Inode__Size with "[$Hinode]"). iSplit; first eauto. iIntros "!>" (σI mb) "[%Hmb HPI]". iNamed "HPI". iInv dirN as (σD) "[>Hdir HPD]". rewrite /dir_inv. iNamed "Hdir". destruct (Hdom _ Hidx) as [σI' HσI']. iDestruct (inode_blocks_lookup with "Hownblocks Hγblocks") as %Hblock. simplify_eq. iMod fupd_mask_subseteq as "HcloseM"; last iMod ("Hfupd" with "[] HPD") as "[HPD HQ]". { solve_ndisj. } { iPureIntro. eauto. } iMod "HcloseM" as "_". iModIntro. iSplitL "Hγblocks HPD". { eauto 10 with iFrame. } iModIntro. iSplitL "Hownblocks Hused1". { rewrite /Pinode. eauto 10 with iFrame. } iSplit. - eauto. - iIntros "_". eauto. Qed. Lemma reserve_fupd_Palloc E γused : ⊢ reserve_fupd E (Palloc γused). Proof. iIntros (s s' ma Hma) "HPalloc". destruct ma; intuition subst; auto. iModIntro. rewrite /Palloc /named. rewrite alloc_used_reserve //. Qed. Lemma free_fupd_Palloc E γused : ⊢ ∀ a, free_fupd E (Palloc γused) a. Proof. iIntros (a s s') "HPalloc". iModIntro. rewrite /Palloc /named. rewrite alloc_free_reserved //. Qed. Lemma alloc_insert_dom idx (new_addrs old_addrs inode_addrs: gset u64) (allocs: gmap nat (gset u64)) : old_addrs = ⋃ (snd <$> map_to_list allocs) → allocs !! idx = Some inode_addrs → new_addrs ∪ old_addrs = ⋃ (snd <$> map_to_list (<[idx:=new_addrs ∪ inode_addrs]> allocs)). Proof. intros -> Hidx. revert idx Hidx; induction allocs using map_ind; intros idx Hidx. { exfalso. rewrite lookup_empty in Hidx. done. } destruct (decide (idx = i)) as [->|Hne]. - rewrite insert_insert. rewrite !map_to_list_insert //. rewrite !fmap_cons !union_list_cons /=. rewrite lookup_insert in Hidx. simplify_eq/=. set_solver+. - rewrite insert_commute //. rewrite map_to_list_insert //. rewrite map_to_list_insert; last first. { rewrite lookup_insert_ne //. } rewrite !fmap_cons !union_list_cons /=. rewrite -IHallocs; last first. { rewrite -Hidx lookup_insert_ne //. } set_solver+. Qed. Theorem wpc_Dir__Append (Q: iProp Σ) l sz b_s b0 (idx: u64) : int.nat idx < num_inodes → {{{ "#Hdir" ∷ is_dir l sz ∗ "Hb" ∷ is_block b_s 1 b0 ∗ "Hfupd" ∷ (∀ σ blocks, ⌜σ.(dir.inodes) !! int.nat idx = Some blocks⌝ -∗ ▷ P σ ={⊤ ∖ ↑N}=∗ ▷ P (dir.mk $ <[ int.nat idx := blocks ++ [b0] ]> σ.(dir.inodes)) ∗ Q) }}} Dir__Append #l #idx (slice_val b_s) @ ⊤ {{{ (ok: bool), RET #ok; if ok then Q else emp }}} {{{ True }}}. 
intuition. simpl. remember (split x2) as z. destruct z. simpl. trivial. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq_f in H; eauto. discriminate. unfold funcCollision, collidesWith in *. simpl in *. assert (l = (fst (split x2))). rewrite <- Heqz. trivial. subst. destruct (findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. trivial. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq_f in H; eauto. discriminate. unfold funcCollision, collidesWith in *. simpl in *. assert (l = (fst (split x2))). rewrite <- Heqz. trivial. subst. destruct (findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. trivial. comp_skip. apply (oneVector c). apply (oneVector c). eapply comp_spec_ret; intuition. intros. eapply F_randomFunc_preserves_coll; eauto. intuition. eapply randomFunc_mem_preserves_coll; eauto. trivial. trivial. intuition. simpl in *; subst. destruct b1; trivial. Grab Existential Variables. trivial. Qed. Theorem G2_3_4_bad_eq : Pr[x <-$ G2_3; ret (snd x)] == Pr[x <-$ G2_4; ret (snd x)]. unfold G2_3, G2_4. inline_first. comp_skip. inline_first. eapply comp_spec_eq_impl_eq. comp_skip. eapply A_randomFunc_F_spec. simpl in *. comp_simp. simpl. eapply comp_spec_ret; intuition. Qed. Theorem G2_3_4_eq_until_bad : forall x, evalDist G2_3 (x, false) == evalDist G2_4 (x, false). intuition. unfold G2_3, G2_4. inline_first. comp_skip. inline_first. eapply comp_spec_impl_eq. comp_skip. eapply A_randomFunc_F_spec. simpl in *. comp_simp. eapply comp_spec_ret; intuition. pairInv. intuition. pairInv. trivial. pairInv. simpl in *. rewrite H3 in H4. intuition. pairInv. trivial. Qed. Definition F_randomFunc_O f d : OracleComp (list (Bvector b)) (Bvector b) (Bvector c * list ((list (Bvector b) * Bvector b) * Bvector c)) := fd <--$ OC_Query _ d; match arrayLookup_f _ f fd with | Some r => $ ret (r, ((d, fd), r) :: f) | None => r <--$$ {0, 1}^c; $ ret (r, ((d, fd), r) :: f) end. Definition au_F_A : OracleComp (list (Bvector b)) (Bvector b) _ := [_, p ] <--$2 OC_Run _ _ _ A F_randomFunc_O nil; let coll := match (findCollision _ _ (fst (split p)) ) with | None => (nil, nil) | Some p => fst p end in $ ret (coll). Definition G2_3_bad := k_in <-$ {0, 1}^k; [p, _] <-$2 au_F_A _ _ (WCR_Oracle _ F k_in) tt; [d1, d2] <-2 p; ret (negb (eqb d1 d2) && eqb (F k_in d1) (F k_in d2)). Theorem G2_3_bad_small : Pr[G2_3_bad] == Adv_WCR _ _ F (Rnd k) au_F_A. reflexivity. Qed. Theorem findCollision_1_correct : forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y, findCollision_1 eqd1 eqd2 ls x1 y = Some x2 -> x1 <> x2 /\ In (x2, y) ls. 
sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)). intros. apply sqrt_prime;trivial. apply is_prime_2. Qed. Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)). intros. intro. assert (divides a p). apply prime_power with n;trivial. generalize (power_divides_lemma1 r p H1);intro. elim H5;intro q;intros. rewrite H6 in H4. rewrite <- H4;exists (q*k*(power b n));ring. assert (divides b p). elim H5;intro q;intros. rewrite H6 in H4. rewrite power_mult_lemma1 in H4. assert ((power p n)=(power p (r+(n-r)))). rewrite <- le_plus_minus;try (auto with arith). rewrite H7 in H4;rewrite power_plus_lemma1 in H4. assert ((power p r)<>O). intro. apply not_prime_zero. assert (p=O). apply power_zero with r;trivial. rewrite H9 in H;trivial. rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro. assert (divides (power p (n-r)) p). apply power_divides_lemma1;apply minus_lt_lemma1;trivial. apply prime_power with n;trivial. apply gauss with k;try (apply rel_prime_sym;trivial). rewrite H9;apply divides_mult;trivial. elim H3;intros. elim H;intros. apply H9;apply divides_antisym;try (apply one_min_div). apply H8;red;tauto. Qed. Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)). intros. intro. generalize (gcd_is_gcd a b);intro. generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro. generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro. assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial). assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial). rewrite power_mult_lemma1 in H8;rewrite H8 in H4. rewrite power_mult_lemma1 in H9;rewrite H9 in H4. rewrite mult_lemma7 in H4. assert ((power (gcd a b) n)<>O). intro. generalize (power_zero n (gcd a b) H10);intro. apply (gcd_non_zero (gcd a b) a b);trivial. generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4). fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)). apply nth_root_irrat_aux;trivial. apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial. Qed. Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Category Category.Morph Category.Opposite. From Categories Require Import Ext_Cons.Arrow. From Categories Require Import Functor.Functor Functor.Functor_Ops Const_Func. From Categories Require Import Archetypal.Discr.Discr. From Categories Require Import Cat.Cat Cat.Cat_Iso. From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.Local Open Scope morphism_scope. Section Comma. Context {B C D : Category} (F : (B –≻ C)%functor) (G : (D –≻ C)%functor). Record Comma_Obj : Type := { CMO_src : B; CMO_trg : D; CMO_hom : ((F _o CMO_src) –≻ (G _o CMO_trg))%object }. Record Comma_Hom (a b : Comma_Obj) : Type := { CMH_left : (CMO_src a) –≻ (CMO_src b); CMH_right : (CMO_trg a) –≻ (CMO_trg b); CMH_com : ((G _a CMH_right) ∘ (@CMO_hom a) = (@CMO_hom b) ∘ (F _a CMH_left))%morphism }. Arguments CMH_left {_ _} _. Arguments CMH_right {_ _} _. Arguments CMH_com {_ _} _. Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) : (@CMH_left _ _ h) = (@CMH_left _ _ h') → (@CMH_right _ _ h) = (@CMH_right _ _ h') → h = h'. Proof. intros H1 H2. destruct h; destruct h'. cbn in *. ElimEq. PIR. trivial. Qed. Program Definition Comma_Hom_compose {a b c : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) : Comma_Hom a c := {| CMH_left := (CMH_left h') ∘ (CMH_left h); CMH_right := (CMH_right h') ∘ (CMH_right h) |}. Next Obligation. Proof. repeat rewrite F_compose. rewrite assoc. rewrite CMH_com. rewrite assoc_sym. rewrite CMH_com. auto. Qed. Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) (h'' : Comma_Hom c d) : Comma_Hom_compose h (Comma_Hom_compose h' h'') = Comma_Hom_compose (Comma_Hom_compose h h') h''. 
From hydras Require Import Hydra_Lemmas Epsilon0_Needed_Free Epsilon0_Needed_Std Hydra_Termination L_alpha Battle_length Ack. Import E0 Large_Sets Hprime Paths MoreLists O2H Hydra_Definitions Iterates. Export Hydra_Definitions. Corollary Alive_free : Alive free. Proof. red;intros. destruct (next_round i h). - destruct s as [h' H']; exists h'; now exists i. - tauto. Qed. Corollary Alive_standard : Alive standard. Proof. red;intros. destruct (next_round i h). - destruct s as [h' H']; exists h'. assumption. - now destruct H. Qed. Theorem Variant_LT_free_0 : @Hvariant _ _ T1_wf free Hydra_Termination.m. Proof. split; intros; now apply round_decr. Qed.Theorem Variant_lt_free: @Hvariant _ _ E0lt_wf free Hydra_Termination.var. Proof. split; intros; now apply round_decr. Qed. Theorem Variant_LT_standard : @Hvariant _ _ T1_wf standard Hydra_Termination.m. Proof. split; intros i h h' H H0; apply round_decr; now exists i. Qed. Theorem Variant_lt_standard : @Hvariant _ _ E0lt_wf standard Hydra_Termination.var. 
exists (a :: prefix); auto. intros. apply pimpl_refl. + cancel. exists nil; auto. Qed.Hint Extern 1 ({{_}} Bind (ForEach_ _ _ _ _ _) _) => apply foreach_ok : prog.Notation "'ForEach' elem rest lst 'Ghost' [ g1 .. g2 ] 'Loopvar' [ l1 .. l2 ] 'Invariant' nocrash 'OnCrash' crashed 'Begin' body 'Rof'" := (ForEach_ (fun elem => (pair_args_helper (fun l1 => .. (pair_args_helper (fun l2 (_:unit) => body)) ..))) lst (pair_args_helper (fun vm0 => (pair_args_helper (fun g1 => .. (pair_args_helper (fun g2 (_:unit) => fun rest => (pair_args_helper (fun l1 => .. (pair_args_helper (fun l2 (_:unit) => fun vm hm => ([[ vm = vm0 ]] * nocrash)%pred)) ..)) )) .. )))) (pair_args_helper (fun vm0 => (pair_args_helper (fun g1 => .. (pair_args_helper (fun g2 (_:unit) => fun hm => crashed%pred)) .. ))))) (at level 9, elem at level 0, rest at level 0, g1 closed binder, g2 closed binder, l1 closed binder, l2 closed binder, body at level 9).Notation "'ForEach' elem rest lst 'Hashmap' hm 'Ghost' [ g1 .. g2 ] 'Loopvar' [ l1 .. l2 ] 'Invariant' nocrash 'OnCrash' crashed 'Begin' body 'Rof'" := (ForEach_ (fun elem => (pair_args_helper (fun l1 => .. (pair_args_helper (fun l2 (_:unit) => body)) ..))) lst (pair_args_helper (fun vm0 => (pair_args_helper (fun g1 => .. (pair_args_helper (fun g2 (_:unit) => fun rest => (pair_args_helper (fun l1 => .. (pair_args_helper (fun l2 (_:unit) => fun vm hm => ([[ vm = vm0 ]] * nocrash)%pred)) ..)) )) .. )))) (pair_args_helper (fun vm0 => (pair_args_helper (fun g1 => .. (pair_args_helper (fun g2 (_:unit) => fun hm => crashed%pred)) .. ))))) (at level 9, elem at level 0, rest at level 0, g1 closed binder, g2 closed binder, l1 closed binder, l2 closed binder, body at level 9). Fixpoint ForNBreak_ (L : Type) (G : Type) (f : nat -> L -> prog (L+L)) (i n : nat) (nocrash : G -> nat -> L -> varmem -> hashmap -> rawpred) (crashed : G -> hashmap -> rawpred) (l : L) : prog L := match n with | 0 => Ret l | S m => l' <- f i l; match l' with | inl l' => ForNBreak_ f (S i) m nocrash crashed l' | inr l' => Ret l' end end.Definition Continue L (l:L) : L + L := inl l. Definition Break L (l:L) : L + L := inr l. Theorem var_get_ok: forall (Tv : Type) (i : vartype), {< (x : Tv) Fv, PRE::vm,hm emp * [[ (Fv * i |-> Any x)%pred vm ]] POST::vm',hm' RET:r emp * [[ r = x ]] * [[ vm' = vm ]] CRASH:hm' [[ False ]] >} VarGet i. 
:= pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply eqp_imp_canonical with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. 2: apply canonical_pluspf; auto. 2: apply canonical_mults with (1 := cs); auto. 2: apply inPolySet_imp_canonical with (L := R); auto. 2: apply CombLinear_canonical with (1 := H'2); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply CombLinear_pluspf; auto. apply CombLinear_mults1; auto. 2: apply H'3 with (b := b); auto. rewrite H'5 in H'1; inversion H'1; auto. rewrite <- H2 in H'6; simpl in H'6; auto. Qed. Theorem reduce_cb : forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b. intros a b Q H' H'0 H'1. cut (canonical A0 eqA ltM b); [ intros Op1 | apply canonical_reduce with (1 := cs) (3 := H'); auto ]. case reduce_inv2 with (1 := cs) (3 := H'); auto; (intros c E; elim E; intros d E0; elim E0; intros H'7 H'8; elim H'8; intros H'9 H'10; elim H'10; intros H'11 H'12; clear H'10 H'8 E0 E); auto. apply CombLinear_comp with (p := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec a (mults (A:=A) multA (n:=n) d c)); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem reduceplus_cb : forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b. intros a b Q H'; elim H'; auto. intros x y H'0 H'1 H'2. apply CombLinear_comp with (p := x); auto. apply eqp_imp_canonical with (p := x) (1 := cs); auto. intros x y z H'0 H'1 H'2 H'3 H'4. apply H'2; auto. apply canonical_reduce with (1 := cs) (3 := H'0) (p := x); auto. apply reduce_cb with (a := x); auto. Qed. Theorem reducestar_cb : forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b. 
m1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. rewrite Rinv_mult_distr; auto with real. rewrite Rinv_involutive; auto with real. apply lt_le_weak. apply Pnat.nat_of_P_lt_Lt_compare_morphism; auto. apply BinPos.ZC2; auto. intros H' H'0; rewrite (Pnat.nat_of_P_minus_morphism m1 n1); auto with real. rewrite (pow_RN_plus e (BinPos.nat_of_P m1 - BinPos.nat_of_P n1) (BinPos.nat_of_P n1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. apply lt_le_weak. change (BinPos.nat_of_P m1 > BinPos.nat_of_P n1) in |- *. apply Pnat.nat_of_P_gt_Gt_compare_morphism; auto. intros n1 m1. rewrite Z.pos_sub_spec; unfold Pos.compare. CaseEq (Pcompare n1 m1 Datatypes.Eq); simpl in |- *; auto with real. intros H' H'0; rewrite BinPos.Pcompare_Eq_eq with (1 := H'); auto with real. intros H' H'0; rewrite (Pnat.nat_of_P_minus_morphism m1 n1); auto with real. rewrite (pow_RN_plus e (BinPos.nat_of_P m1 - BinPos.nat_of_P n1) (BinPos.nat_of_P n1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. rewrite Rinv_mult_distr; auto with real. apply lt_le_weak. apply Pnat.nat_of_P_lt_Lt_compare_morphism; auto. apply BinPos.ZC2; auto. intros H' H'0; rewrite (Pnat.nat_of_P_minus_morphism n1 m1); auto with real. rewrite (pow_RN_plus e (BinPos.nat_of_P n1 - BinPos.nat_of_P m1) (BinPos.nat_of_P m1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. apply lt_le_weak. change (BinPos.nat_of_P n1 > BinPos.nat_of_P m1) in |- *. apply Pnat.nat_of_P_gt_Gt_compare_morphism; auto. intros n1 m1; rewrite Pnat.nat_of_P_plus_morphism; auto with real. intros H'; rewrite pow_add; auto with real. apply Rinv_mult_distr; auto. apply pow_NR0; auto. apply pow_NR0; auto. Qed. Hint Resolve powerRZ_O powerRZ_1 powerRZ_NOR powerRZ_add: real. Theorem powerRZ_Zopp : forall (e : R) (z : BinInt.Z), e <> 0%R -> powerRZ e (- z) = (/ powerRZ e z)%R. intros e z H; case z; simpl in |- *; auto with real. intros p; apply sym_eq; apply Rinv_involutive. apply pow_nonzero; auto. Qed.Theorem powerRZ_Zs : forall (e : R) (n : BinInt.Z), e <> 0%R -> powerRZ e (Zsucc n) = (e * powerRZ e n)%R. intros e n H'0. replace (Zsucc n) with (n + Zsucc 0)%Z. rewrite powerRZ_add; auto. rewrite powerRZ_1. rewrite Rmult_comm; auto. auto with zarith. Qed. Theorem Zpower_nat_powerRZ : forall (n : BinInt.Z) (m : nat), IZR (Zpower_nat n m) = powerRZ (IZR n) (Z_of_nat m). intros n m; elim m; simpl in |- *; auto with real. intros m1 H'; rewrite Pnat.nat_of_P_o_P_of_succ_nat_eq_succ; simpl in |- *. replace (Zpower_nat n (S m1)) with (n * Zpower_nat n m1)%Z. rewrite Rmult_IZR; auto with real. rewrite H'; simpl in |- *. case m1; simpl in |- *; auto with real. intros m2; rewrite Pnat.nat_of_P_o_P_of_succ_nat_eq_succ; auto. unfold Zpower_nat in |- *; auto. Qed. Theorem powerRZ_lt : forall (e : R) (z : BinInt.Z), (0 < e)%R -> (0 < powerRZ e z)%R. 
a) as [ [? ?] | ]; congruence. Qed. Definition outcome_disk_R (R: rawdisk -> rawdisk -> Prop) T (out out':outcome T) := match out with | Finished d vm hm v => exists d', out' = Finished d' vm hm v /\ R d d' | Crashed _ d hm => exists d', out' = Crashed _ d' hm /\ R d d' | Failed _ => out' = Failed _ end. Definition pexec T d vm hm (p: prog T) out := exists out', Exec.R flush_disk d vm hm p out' /\ outcome_disk_R flush_disk out' out. Definition pexec_recover := @ExecRecover.R pexec discard_buffers. Hint Resolve flush_disk_refl flush_disk_trans. Hint Resolve flush_disk_is_sync. Lemma flush_disk_in_domain : forall d d' a v vs, d a = Some (v, vs) -> flush_disk d d' -> exists n, d' a = Some (v, firstn n vs). Proof. unfold flush_disk; intros. specialize (H0 a). rewrite H in H0; eauto. Qed. Theorem outcome_obs_le_to_R : forall T (out out': outcome T), outcome_obs_le out out' <-> outcome_disk_R possible_sync out out'. Proof. unfold outcome_obs_le, outcome_disk_R; split; intros; destruct out; eauto. Qed. Lemma exec_flush_to_exec : forall T (p: prog T) d vm hm out, Exec.R flush_disk d vm hm p out -> exec d vm hm p out. Proof. induction 1; simpl; intros; intuition (repeat deex; eauto 10). Qed. Corollary pexec_to_exec : forall T (p: prog T) d vm hm out, pexec d vm hm p out -> exists out', exec d vm hm p out' /\ outcome_disk_R flush_disk out' out. Proof. unfold pexec; intros; deex. eauto using exec_flush_to_exec. Qed. Definition outcome_disk_R_conv (R: rawdisk -> rawdisk -> Prop) T (out' out: outcome T) := match out' with | Finished m vm hm v => exists m', out = Finished m' vm hm v /\ R m' m | Crashed _ m hm => exists m', out = Crashed _ m' hm /\ R m' m | Failed _ => out = Failed _ end. Theorem outcome_disk_R_conv_ok : forall R T (out out': outcome T), outcome_disk_R R out out' <-> outcome_disk_R_conv R out' out. Proof. unfold outcome_disk_R, outcome_disk_R_conv; split; intros; destruct out, out'; repeat deex; try congruence. inversion H0; eauto. inversion H0; eauto. inversion H0; eauto. inversion H0; eauto. Qed. Lemma diskval_firstn_in_list : forall l n v, In (diskval v (firstn n l)) (v::l). Proof. induction l; simpl; intros. rewrite firstn_nil; eauto. destruct n; simpl; eauto. destruct (IHl n a); simpl; eauto. Qed. Theorem discard_flush_is_crash : forall d d' d'', flush_disk d d' -> discard_buffers d' d'' -> possible_crash d d''. 
Require Export ChargeCore.Logics.ILogic.Section logic. Context {L : Type}. Context {ILO : ILogicOps L}. Context {IL : ILogic L}. Theorem lcut : forall P Q R : L, P |-- R -> P |-- R -->> Q -> P |-- Q. Proof. intros. eapply landAdj in H0. etransitivity; [ | eassumption ]. eapply landR. reflexivity. assumption. Qed. Theorem limplAdj_true : forall P Q, P |-- Q -> ltrue |-- P -->> Q. Proof. intros. apply limplAdj. apply landL2. assumption. Qed. Theorem landAdj_true : forall P Q, ltrue |-- P -->> Q -> P |-- Q. 
Require Import Coq.Strings.Ascii Coq.NArith.NArith Coq.Strings.String Coq.Structures.OrderedType Coq.FSets.FMapAVL.Require Import Bedrock.Nomega Bedrock.Labels.Local Open Scope string_scope. Local Open Scope N_scope.Definition ascii_lt (a1 a2 : ascii) := N_of_ascii a1 < N_of_ascii a2.Fixpoint string_lt (s1 s2 : string) : bool := match s1, s2 with | "", String _ _ => true | String _ _, "" => false | String a1 s1', String a2 s2' => match (N_of_ascii a1) ?= (N_of_ascii a2) with | Datatypes.Lt => true | Gt => false | Datatypes.Eq => string_lt s1' s2' end | _, _ => false end.Section CompSpec. Variables (A : Type) (eq lt : A -> A -> Prop) (x y : A) (c : comparison). Hypothesis H : CompSpec eq lt x y c. Theorem Comp_eq : (forall z, lt z z -> False) -> x = y -> c = Datatypes.Eq. inversion H; intros; subst; auto; elimtype False; eauto. Qed. Theorem Comp_lt : (forall z z', lt z z' -> eq z z' -> False) -> (forall z z', lt z z' -> lt z' z -> False) -> lt x y -> c = Datatypes.Lt. 
n; elim n; clear n; auto. intros p q; try rewrite <- Zplus_0_r_reverse. intros H' H'0; simpl in |- *; left. apply Zle_antisym; auto. intros n H' p q H'0 H'1; case (Zle_lt_or_eq _ _ H'0); intros H'2. simpl in |- *; right. apply H'; auto with zarith. rewrite Zplus_succ_comm. rewrite <- inj_S; auto. simpl in |- *; auto. Qed. Theorem mZlist_aux_correct_rev1 : forall (n : nat) (p q : Z), In q (mZlist_aux p n) -> (p <= q)%Z. intros n; elim n; clear n; simpl in |- *; auto. intros p q H'; elim H'; auto with zarith. intros n H' p q H'0; elim H'0; auto with zarith. intros H'1; apply Zle_succ_le; auto with zarith. Qed. Theorem mZlist_aux_correct_rev2 : forall (n : nat) (p q : Z), In q (mZlist_aux p n) -> (q <= p + Z_of_nat n)%Z. intros n; elim n; clear n; auto. intros p q H'; elim H'; auto with zarith. intros H'0; elim H'0. intros n H' p q H'0; elim H'0; auto with zarith. intros H'1; rewrite inj_S; rewrite <- Zplus_succ_comm; auto. Qed. Definition mZlist (p q : Z) : list Z := match (q - p)%Z with | Z0 => p :: nil | Zpos d => mZlist_aux p (nat_of_P d) | Zneg _ => nil (A:=Z) end. Theorem mZlist_correct : forall p q r : Z, (p <= r)%Z -> (r <= q)%Z -> In r (mZlist p q). intros p q r H' H'0; unfold mZlist in |- *; CaseEq (q - p)%Z; auto with zarith. intros H'1; rewrite (Zle_antisym r p); auto with datatypes. auto with zarith. intros p0 H'1; apply mZlist_aux_correct; auto. rewrite inject_nat_convert with (1 := H'1); auto with zarith. intros p0 H'1; absurd (p <= q)%Z; auto. apply Zlt_not_le; auto. apply Zlt_O_minus_lt; auto. replace (p - q)%Z with (- (q - p))%Z; auto with zarith. rewrite H'1; simpl in |- *; auto with zarith. unfold Zlt in |- *; simpl in |- *; auto. apply Zle_trans with (m := r); auto. Qed. Theorem mZlist_correct_rev1 : forall p q r : Z, In r (mZlist p q) -> (p <= r)%Z. intros p q r; unfold mZlist in |- *; CaseEq (q - p)%Z. intros H' H'0; elim H'0; auto with zarith. intros H'1; elim H'1. intros p0 H' H'0. apply mZlist_aux_correct_rev1 with (n := nat_of_P p0); auto. intros p0 H' H'0; elim H'0. Qed. Theorem mZlist_correct_rev2 : forall p q r : Z, In r (mZlist p q) -> (r <= q)%Z. 
Require Import List Lia Relation_Operators. Import ListNotations. Require Import Undecidability.SystemF.SysF. From Undecidability.SystemF.Util Require Import Facts poly_type_facts pure_term_facts term_facts typing_facts pure_typing_facts.Require Import ssreflect ssrbool ssrfun.Set Default Goal Selector "!".Module Argument. Section SysF_TYP_to_SysF_TC.Variables M0 : pure_term.Definition Gamma_M0 := [poly_abs (poly_var 0)].Definition M_M0 := pure_app (pure_var 0) (many_pure_term_abs (pure_var_bound M0) M0).Definition t_M0 := poly_var 0. Lemma transport : SysF_TYP M0 -> SysF_TC (Gamma_M0, M_M0, t_M0). Proof. move=> [Gamma] [t] /pure_typing_iff_type_assignment. move=> /pure_typableI /pure_typable_many_pure_term_abs_allI [{}t]. move=> /(pure_typing_ren_pure_term id (Delta := Gamma_M0)). rewrite ren_pure_term_id. apply: unnest; first by case. move=> /(pure_typing_pure_app_simpleI (M := pure_var 0) (t := t_M0)). apply: unnest. { apply: (pure_typing_pure_var 0); first by reflexivity. apply: rt_step. by apply: contains_step_subst. } move=> /pure_typing_to_typing /= [P] [HP] /typing_to_type_assignment. by rewrite -HP. Qed. Lemma inverse_transport : SysF_TC (Gamma_M0, M_M0, t_M0) -> SysF_TYP M0. Proof. move=> /pure_typing_iff_type_assignment. rewrite /Gamma_M0 /M_M0 /t_M0. move=> /pure_typingE' [?] [?] [_] [/pure_typableI HM0 _]. have : exists Gamma, pure_typable Gamma M0. { elim: (pure_var_bound M0) ([poly_abs (poly_var 0)]) HM0. - move=> /= ? ?. eexists. by eassumption. - by move=> {}n IH Gamma /= /pure_typableE [?] /IH. } move=> [Gamma] [t] /pure_typing_to_typing [P] [->]. move=> /typing_to_type_assignment ?. by exists Gamma, t. Qed.End SysF_TYP_to_SysF_TC. End Argument.Require Import Undecidability.Synthetic.Definitions. Theorem reduction : SysF_TYP ⪯ SysF_TC. 
A_wf : well_formed_oc A. Definition G0 := k_in <-$ {0, 1}^k; k_out <-$ {0, 1}^c; [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Definition G1 := k_in <-$ {0, 1}^k; [b, _] <-$2 A _ _ (fun (s : list (Bvector b * Bvector c)) m => randomFunc ({0, 1}^c) _ s (F k_in m)) nil; ret b. Definition G2 := [b, _] <-$2 A _ _ (fun (s : list (list (Bvector b) * Bvector c)) m => randomFunc ({0, 1}^c) _ s m) nil; ret b. Definition G0_1 := [k_out, k_in] <-$2 ( key <-$ {0, 1}^(c + k); ret splitVector c k key); [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Theorem G0_1_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1]. unfold PRF_G_A, G0_1. inline_first. comp_skip. unfold f_oracle, hF. remember (splitVector c k x) as z. comp_simp. reflexivity. Qed. Theorem G0_1_G0_equiv : Pr[G0_1] == Pr[G0]. unfold G0_1, G0. eapply eqRat_trans. eapply evalDist_seq_eq. eapply Rnd_split_equiv. intros. eapply eqRat_refl. inline_first. comp_swap_r. comp_skip. inline_first. comp_skip. Qed. Theorem G0_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0]. rewrite G0_1_equiv. apply G0_1_G0_equiv. Qed. Definition hF_oracle k_in (s : unit) m : OracleComp (Bvector b) (Bvector c) (Bvector c * unit) := r <--$ OC_Query _ (F k_in m); $ ret (r, tt). Definition PRF_h_A : OracleComp (Bvector b) (Bvector c) bool := k_in <--$$ {0, 1}^k; [r, _] <--$2 OC_Run _ _ _ A (hF_oracle k_in) tt; $ ret r. Definition G1_1 := k_out <-$ { 0 , 1 }^c; [b, _] <-$2 PRF_h_A _ _ (f_oracle h _ k_out) tt; ret b. Definition G1_2 := [b, _] <-$2 PRF_h_A _ _ (randomFunc ({0, 1}^c) _) nil; ret b. Local Opaque evalDist. Theorem G0_G1_1_equiv : Pr[G0] == Pr[G1_1]. unfold G0, G1_1. comp_swap_l. comp_skip. unfold PRF_h_A. simpl. inline_first. comp_skip. comp_simp. inline_first. unfold f_oracle. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => True)). trivial. intuition. inline_first. comp_simp. inline_first. comp_simp. simpl. eapply comp_spec_ret; intuition. simpl in *. intuition; subst. comp_simp. simpl. inline_first. comp_simp. eapply comp_spec_eq_refl. Qed. Theorem G1_1_2_close : | Pr[G1_1] - Pr[G1_2] | <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A. reflexivity. Qed. Theorem G1_2_G1_equiv : Pr[G1_2] == Pr[G1]. 
suffix) -> find_subtree pn (update_subtree base subtree tree) = Some (TreeFile inum f) -> find_subtree pn tree = Some (TreeFile inum f). Proof. induction base; intros. simpl in *. contradict H. eauto. destruct pn. simpl in *. inversion H0; subst. eauto. destruct tree; simpl in *; try congruence. destruct tree; simpl in *; try congruence. induction l; simpl in *; try congruence. destruct a0; simpl in *. destruct (string_dec s0 s); destruct (string_dec s0 a); subst; subst; simpl in *. - destruct (string_dec s s); try congruence. eapply IHbase; eauto. intro H'; apply H. deex. exists suffix. eauto. - destruct (string_dec s s); try congruence. - destruct (string_dec a s); try congruence; eauto. - destruct (string_dec s0 s); try congruence; eauto. Qed. Lemma find_subtree_update_subtree_oob_general : forall base pn tree subtree subtree', (~ exists suffix, pn = base ++ suffix) -> find_subtree pn (update_subtree base subtree tree) = Some subtree' -> exists subtree'', find_subtree pn tree = Some subtree'' /\ dirtree_inum subtree'' = dirtree_inum subtree' /\ dirtree_isdir subtree'' = dirtree_isdir subtree'. Proof. induction base; simpl; intros. contradict H; eauto. destruct pn; simpl in *. - eexists; intuition eauto. destruct tree; destruct subtree'; simpl in *; try congruence. destruct tree; destruct subtree'; simpl in *; try congruence. - destruct tree; simpl in *; try congruence. induction l; simpl in *; try congruence. destruct a0; simpl in *. destruct (string_dec s0 a); destruct (string_dec s0 s); subst; simpl in *. + destruct (string_dec s s); try congruence. eapply IHbase; eauto. intro H'. apply H. deex. eauto. + destruct (string_dec a s); try congruence. eauto. + destruct (string_dec s s); try congruence. eauto. + destruct (string_dec s0 s); try congruence. eauto. Qed. Theorem find_subtree_helper1 : forall pathname suffix tree subtree subtree' r, find_subtree pathname tree = Some subtree -> find_subtree (pathname ++ suffix) (update_subtree pathname subtree' tree) = Some r -> find_subtree suffix subtree' = Some r. Proof. induction pathname; simpl in *; intros; eauto. destruct tree; try congruence. induction l; simpl in *; try congruence. destruct a0; simpl in *. destruct (string_dec s a); subst; simpl in *. - destruct (string_dec a a); try congruence. eauto. - destruct (string_dec s a); try congruence. apply IHl; eauto. Qed. Lemma tree_names_distinct_head_name' : forall rest name f, map fst (map (update_subtree_helper f name) rest) = map fst rest. Proof. induction rest; simpl; intros. auto. erewrite IHrest. unfold update_subtree_helper. destruct a. destruct (string_dec s name); eauto. Qed. Theorem find_update_subtree : forall fnlist tree subtree subtree0, find_subtree fnlist tree = Some subtree0 -> find_subtree fnlist (update_subtree fnlist subtree tree) = Some subtree. 
==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. End QUEUE.Module Queue : QUEUE. Open Scope Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). destruct n; reflexivity. Qed. Theorem queue_extensional : forall b p, HProp_extensional (queue b p). reflexivity. Qed. Theorem lseg_extensional' : forall ba n b b' fr, b %= b' -> lseg b n fr ba ===> lseg b' n fr ba. induction n; sepLemma. Qed. Theorem llist_extensional' : forall ba n b b' fr, b %= b' -> llist b n fr ba ===> llist b' n fr ba. induction n; sepLemma. Qed. Theorem queue_fwd : forall b p, queue b p ===> Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. unfold queue; sepLemma. Qed. Theorem queue_bwd : forall b p, (Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba) ===> queue b p. unfold queue; sepLemma. Qed. Theorem llist_empty_fwd : forall b n (fr : W) ba, fr = 0 -> llist b n fr ba ===> [| b %= empty |] * [| n = O |]. 
From Perennial.goose_lang Require Import notation typing. From Perennial.goose_lang.lib Require Import typed_mem.impl. From Perennial.goose_lang.lib Require Import control.impl.Open Scope heap_types.Module slice. Section types. Context `{ext_ty: ext_types}. Definition T t : ty := (arrayT t * uint64T * uint64T)%ht. Definition ptr: val := λ: "s", Fst (Fst (Var "s")). Definition len: val := λ: "s", Snd (Fst (Var "s")). Definition cap: val := λ: "s", Snd (Var "s"). Theorem ptr_t t :  ⊢ ptr : (T t -> arrayT t). Proof. typecheck. Qed. Theorem len_t t :  ⊢ len : (T t -> uint64T). Proof. typecheck. Qed. Definition nil : val := (#null, #0, #0). Theorem nil_t t :  ⊢ nil : T t. 
_) (u, id c)))%morphism → f = (eval ∘ ((× ⁿᶜ C) @_a (_, _) (_, _) (u', id c)))%morphism → u = u' }.Coercion exponential : Exponential >-> Obj.Arguments Exponential _ {_} _ _, {_ _} _ _.Arguments exponential {_ _ _ _} _, {_ _} _ _ {_}. Arguments eval {_ _ _ _} _, {_ _} _ _ {_}. Arguments Exp_morph_ex {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _. Arguments Exp_morph_com {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _. Arguments Exp_morph_unique {_ _ _ _} _ _ _ _ _ _ _, {_ _} _ _ {_} _ _ _ _ _ _.Notation "a ⇑ b" := (Exponential a b) : object_scope. Theorem Exponential_iso {C : Category} {HP : Has_Products C} (c d : C) (E E' : (c ⇑ d)%object) : (E ≃ E')%isomorphism. Proof. eapply ( Build_Isomorphism _ _ _ (Exp_morph_ex E' _ (eval E)) (Exp_morph_ex E _ (eval E')) ); eapply Exp_morph_unique; eauto; simpl_ids; match goal with [|- (_ ∘ ?M)%morphism = _] => match M with (?U _a (?A ∘ ?B, ?C))%morphism => assert (M = (U @_a (_, _) (_, _) (A, C)) ∘ (U @_a (_, _) (_, _) (B, C)))%morphism as HM; [simpl_ids; rewrite <- F_compose; simpl; simpl_ids; trivial|rewrite HM] end end; rewrite <- assoc; repeat rewrite <- Exp_morph_com; auto. Qed.Definition Has_Exponentials (C : Category) {HP : Has_Products C} := ∀ a b, (a ⇑ b)%object.Existing Class Has_Exponentials.Section Curry_UnCurry. Context (C : Category) {HP : Has_Products C} {HE : Has_Exponentials C}. Definition curry : forall {a b c : C}, (((× ⁿᶜ C) _o (a, b))%object –≻ c) → (a –≻ (HE b c)) := fun {a b c : C} (f : ((× ⁿᶜ C) _o (a, b))%object –≻ c) => Exp_morph_ex (HE b c) _ f. Definition uncurry : forall {a b c : C}, (a –≻ (HE b c)) → (((× ⁿᶜ C) _o (a, b))%object –≻ c) := fun {a b c : C} (f : a –≻ (HE b c)) => ((eval (HE b c)) ∘ ((× ⁿᶜ C) @_a (_, _) (_, _) (f, id C b)))%morphism. Section inversion. Context {a b c : C}. Theorem curry_uncurry (f : a –≻ (HE b c)) : curry (uncurry f) = f. Proof. unfold curry, uncurry. eapply Exp_morph_unique; trivial. rewrite <- Exp_morph_com; trivial. Qed. Theorem uncurry_curry (f : ((× ⁿᶜ C) _o (a, b))%object –≻ c) : uncurry (curry f) = f. 
prog. Hint Extern 1 ({{_}} Bind (getattr _ _ _) _) => apply getattr_ok : prog. Hint Extern 1 ({{_}} Bind (setattr _ _ _ _) _) => apply setattr_ok : prog. Theorem delete_ok : forall fsxp dnum name mscs, {< F mbase sm m pathname Fm Ftop tree tree_elem ilist frees, PRE:hm LOG.rep fsxp.(FSXPLog) F (LOG.ActiveTxn mbase m) (MSLL mscs) sm hm * [[ (Fm * rep fsxp Ftop tree ilist frees mscs sm)%pred (list2nmem m) ]] * [[ find_subtree pathname tree = Some (TreeDir dnum tree_elem) ]] POST:hm' RET:^(mscs',r) exists m', LOG.rep fsxp.(FSXPLog) F (LOG.ActiveTxn mbase m') (MSLL mscs') sm hm' * [[ MSAlloc mscs' = MSAlloc mscs ]] * ([[ isError r ]] \/ [[ r = OK tt ]] * exists tree' ilist' frees', [[ tree' = update_subtree pathname (delete_from_dir name (TreeDir dnum tree_elem)) tree ]] * [[ (Fm * rep fsxp Ftop tree' ilist' frees' mscs' sm)%pred (list2nmem m') ]] * [[ dirtree_safe ilist (BFILE.pick_balloc frees (MSAlloc mscs')) tree ilist' (BFILE.pick_balloc frees' (MSAlloc mscs')) tree' ]] * [[ forall inum def', inum <> dnum -> (In inum (tree_inodes tree') \/ (~ In inum (tree_inodes tree))) -> selN ilist inum def' = selN ilist' inum def' ]]) CRASH:hm' LOG.intact fsxp.(FSXPLog) F mbase sm hm' >} delete fsxp dnum name mscs. Proof. intros; eapply pimpl_ok2. apply delete_ok'. intros; norml; unfold stars; simpl. rewrite rep_tree_distinct_impl in *. unfold rep in *; cancel. rewrite subtree_extract; eauto. simpl. instantiate (tree_elem0:=tree_elem). cancel. step. apply pimpl_or_r; right. cancel. rewrite <- subtree_absorb; eauto. cancel. eapply dirlist_safe_subtree; eauto. denote (dirlist_combine tree_inodes _) as Hx. specialize (Hx inum def' H4). intuition; try congruence. destruct_lift H0. edestruct tree_inodes_pathname_exists. 3: eauto. eapply tree_names_distinct_update_subtree; eauto. eapply tree_names_distinct_delete_from_list. eapply tree_names_distinct_subtree; eauto. eapply tree_inodes_distinct_update_subtree; eauto. eapply tree_inodes_distinct_delete_from_list. eapply tree_inodes_distinct_subtree; eauto. simpl. eapply incl_cons2. eapply tree_inodes_incl_delete_from_list. repeat deex. destruct (pathname_decide_prefix pathname x); repeat deex. erewrite find_subtree_app in *; eauto. eapply H11. eapply find_subtree_inum_present in H16; simpl in *. intuition. exfalso; eauto. eapply H9. intro. edestruct tree_inodes_pathname_exists with (tree := TreeDir dnum tree_elem) (inum := dirtree_inum subtree). 3: eassumption. eapply tree_names_distinct_subtree; eauto. eapply tree_inodes_distinct_subtree; eauto. destruct H20. destruct H20. eapply H6. exists x0. edestruct find_subtree_before_prune_general; eauto. eapply find_subtree_inode_pathname_unique. eauto. eauto. intuition eauto. erewrite find_subtree_app; eauto. intuition congruence. eapply H11; eauto. right. contradict H7; intuition eauto. exfalso; eauto. eapply tree_inodes_find_subtree_incl; eauto. simpl; intuition. Unshelve. all: eauto. Qed. Hint Extern 1 ({{_}} Bind (delete _ _ _ _) _) => apply delete_ok : prog. Theorem rename_cwd_ok : forall fsxp dnum srcpath srcname dstpath dstname mscs, {< F mbase m sm Fm Ftop tree tree_elem ilist frees, PRE:hm LOG.rep fsxp.(FSXPLog) F (LOG.ActiveTxn mbase m) (MSLL mscs) sm hm * [[ (Fm * rep fsxp Ftop tree ilist frees mscs sm)%pred (list2nmem m) ]] * [[ tree = TreeDir dnum tree_elem ]] POST:hm' RET:^(mscs',r) exists m', LOG.rep fsxp.(FSXPLog) F (LOG.ActiveTxn mbase m') (MSLL mscs') sm hm' * [[ MSAlloc mscs' = MSAlloc mscs ]] * ([[ isError r ]] \/ [[ r = OK tt ]] * exists snum sents dnum dents subtree pruned tree' ilist' frees', [[ find_subtree srcpath tree = Some (TreeDir snum sents) ]] * [[ find_dirlist srcname sents = Some subtree ]] * [[ pruned = tree_prune snum sents srcpath srcname tree ]] * [[ find_subtree dstpath pruned = Some (TreeDir dnum dents) ]] * [[ tree' = tree_graft dnum dents dstpath dstname subtree pruned ]] * [[ (Fm * rep fsxp Ftop tree' ilist' frees' mscs' sm)%pred (list2nmem m') ]] * [[ dirtree_safe ilist (BFILE.pick_balloc frees (MSAlloc mscs')) tree ilist' (BFILE.pick_balloc frees' (MSAlloc mscs')) tree' ]] * [[ forall inum' def', inum' <> snum -> inum' <> dnum -> (In inum' (tree_inodes tree') \/ (~ In inum' (tree_inodes tree))) -> selN ilist inum' def' = selN ilist' inum' def' ]] ) CRASH:hm' LOG.intact fsxp.(FSXPLog) F mbase sm hm' >} rename fsxp dnum srcpath srcname dstpath dstname mscs. 
eps <= ulp x)%R -> round beta fexp Zceil (x + eps) = (x + ulp x)%R. Proof with auto with typeclass_instances. intros x Zx Fx eps. case Zx; intros Zx1.intros (Heps1,[Heps2|Heps2]). assert (Heps: (0 <= eps < ulp x)%R). split. now apply Rlt_le. exact Heps2. assert (Hd := round_DN_plus_eps_pos x Zx Fx eps Heps). rewrite round_UP_DN_ulp. rewrite Hd. rewrite 2!ulp_neq_0. unfold canonic_exp. now rewrite ln_beta_plus_eps. now apply Rgt_not_eq. now apply Rgt_not_eq, Rplus_lt_0_compat. intros Fs. rewrite round_generic in Hd... apply Rgt_not_eq with (2 := Hd). pattern x at 2 ; rewrite <- Rplus_0_r. now apply Rplus_lt_compat_l. rewrite Heps2. apply round_generic... now apply generic_format_succ_aux1.rewrite <- Zx1, 2!Rplus_0_l. intros Heps. case (proj2 Heps). unfold round, scaled_mantissa, canonic_exp. unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros H2. intros J; absurd (0 < 0)%R; auto with real. apply Rlt_trans with eps; try assumption; apply Heps. intros n Hn H. assert (fexp (ln_beta beta eps) = fexp n). apply valid_exp; try assumption. assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega]. apply lt_bpow with beta. apply Rle_lt_trans with (2:=H). destruct (ln_beta beta eps) as (e,He). simpl; rewrite Rabs_pos_eq in He. now apply He, Rgt_not_eq. now left. replace (Zceil (eps * bpow (- fexp (ln_beta beta eps)))) with 1%Z. unfold F2R; simpl; rewrite H0; ring. apply sym_eq, Zceil_imp. split. simpl; apply Rmult_lt_0_compat. apply Heps. apply bpow_gt_0. apply Rmult_le_reg_r with (bpow (fexp n)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus. rewrite H0; ring_simplify (-fexp n + fexp n)%Z. simpl; rewrite Rmult_1_l, Rmult_1_r. now left. intros P; rewrite P. apply round_generic... apply generic_format_ulp_0. Qed. Theorem round_UP_pred_plus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x) )%R -> round beta fexp Zceil (pred x + eps) = x. Proof. intros x Hx Fx eps Heps. rewrite round_UP_plus_eps_pos; trivial. rewrite pred_eq_pos. apply pred_pos_plus_ulp; trivial. now left. now apply pred_ge_0. apply generic_format_pred; trivial. Qed.Theorem round_DN_minus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x))%R -> round beta fexp Zfloor (x - eps) = pred x. Proof. intros x Hpx Fx eps. rewrite pred_eq_pos;[intros Heps|now left]. replace (x-eps)%R with (pred_pos x + (ulp (pred_pos x)-eps))%R. 2: pattern x at 3; rewrite <- (pred_pos_plus_ulp x); trivial. 2: ring. rewrite round_DN_plus_eps_pos; trivial. now apply pred_pos_ge_0. now apply generic_format_pred_pos. split. apply Rle_0_minus. now apply Heps. rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. now apply Heps. Qed. Theorem round_DN_plus_eps: forall x, F x -> forall eps, (0 <= eps < if (Rle_bool 0 x) then (ulp x) else (ulp (pred (-x))))%R -> round beta fexp Zfloor (x + eps) = x. 
From Huffman Require Export WeightTree. From Huffman Require Export Ordered. From Huffman Require Export SameSumLeaves. Section OneStep. Variable A : Type. Variable f : A -> nat. Definition one_step (l1 l2 : list (btree A)) : Prop := exists l3 : list (btree A), (exists t1 : btree A, (exists t2 : btree A, ordered (sum_order f) (t1 :: t2 :: l3) /\ permutation l1 (t1 :: t2 :: l3) /\ permutation l2 (node t1 t2 :: l3))). Theorem one_step_weight_tree_list : forall l1 l2 l3 : list (btree A), one_step l1 l2 -> one_step l1 l3 -> weight_tree_list f l2 = weight_tree_list f l3. 
\* H2) **> (H1 \* H2'). Proof. intros ?? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_frame H1 H1' H2 H2': H1 **> H1' -> H2 **> H2' -> (H1 \* H2) **> (H1' \* H2'). Proof. intros ??? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_star_trans_l H1 H2 H3 H4: H1 **> H2 -> H2 \* H3 **> H4 -> H1 \* H3 **> H4. Proof. intros M1 M2 ? (s1 & s2 & (?&?&?&?)); apply M2; exists s1, s2; auto. Qed. Theorem state_implies_star_trans_r H1 H2 H3 H4: H1 **> H2 -> H3 \* H2 **> H4 -> H3 \* H1 **> H4. Proof. intros M1 M2 ? (s1 & s2 & (?&?&?&?)); apply M2; exists s1, s2; auto. Qed. Theorem state_pure_intro: forall P: Prop, P -> \[P] empty. Proof. intros ? P; exists P; hnf; auto. Qed. Theorem state_pure_inversion: forall P state, \[P] state -> P /\ state = empty. Proof. intros ?? A; hnf in A; naive_solver. Qed. Theorem state_star_pure_l P H state: (\[P] \* H) state <-> P /\ (H state). Proof. unfold state_pure, state_exists; split. - hnf. rewrite state_star_exists. - rewrite state_star_exists. rewrite* state_star_empty_l. iff (p&M) (p&M). { split~. } { exists~ p. } Qed. Theorem state_star_pure_r: forall P H h, (H \* \[P]) h = (H h /\ P). Proof. intros. rewrite hstar_comm. rewrite state_star_pure_l. apply* prop_ext. Qed. Theorem himpl_state_star_pure_r: forall P H H', P -> (H ==> H') -> H ==> (\[P] \* H'). Proof. introv HP W. intros h K. rewrite* state_star_pure_l. Qed. Theorem state_pure_inv_hempty: forall P h, \[P] h -> P /\ \[] h. Proof. introv M. rewrite <- state_star_pure_l. rewrite~ hstar_hempty_r. Qed. Theorem state_pure_intro_hempty: forall P h, \[] h -> P -> \[P] h. Proof. introv M N. rewrite <- (hstar_hempty_l \[P]). rewrite~ state_star_pure_r. Qed. Theorem himpl_hempty_state_pure: forall P, P -> \[] ==> \[P]. Proof. introv HP. intros h Hh. applys* state_pure_intro_hempty. Qed. Theorem himpl_state_star_pure_l: forall P H H', (P -> H ==> H') -> (\[P] \* H) ==> H'. Proof. introv W Hh. rewrite state_star_pure_l in Hh. applys* W. Qed. Theorem hempty_eq_state_pure_true : \[] = \[True]. Proof. applys himpl_antisym; intros h M. { applys* state_pure_intro_hempty. } { forwards*: state_pure_inv_hempty M. } Qed. Theorem hfalse_hstar_any: forall H, \[False] \* H = \[False]. Proof. intros. applys himpl_antisym; intros h; rewrite state_star_pure_l; intros M. { false*. } { lets: state_pure_inv_hempty M. false*. } Qed. Theorem state_register_intro: forall register value, ($register == value) (machine_state empty {[ register := value ]}). 
(LOG.arrayP 0 l =p=> fp) -> listpred (fun a => a |->?) (seq 0 (length l)) =p=> smrep freelist. Proof. unfold smrep, Alloc.rep, Alloc.Alloc.rep in *. intros. destruct_lifts. denote piff as Hp; rewrite Hp in *. eapply arrayN_ptsto_linked. eapply pimpl_trans; eauto. eapply listpred_pimpl_replace. cancel. Unshelve. all: try exact addr_eq_dec. exact unit. Qed. Lemma rep_ignore_mslog_ok: forall bxps frees lms lms' cm, rep bxps frees (mk_memstate lms cm) =p=> rep bxps frees (mk_memstate lms' cm). Proof. intros. unfold mk_memstate, rep. cancel. Qed. Lemma rep_clear_mscache_ok : forall bxps frees lms cm, rep bxps frees (mk_memstate lms cm) =p=> rep bxps frees (mk_memstate lms Alloc.freelist0). Proof. intros. unfold mk_memstate, rep. cancel. rewrite Alloc.rep_clear_mscache_ok. cancel. Qed. Theorem init_ok : forall lxp xp ms, {< F Fm Fs m0 sm m bl dl, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * arrayN (@ptsto _ _ _) 0 dl * arrayN (@ptsto _ _ _) (BmapStart xp) bl) ]]] * [[ (Fs * listpred (fun a => a |->?) (seq 0 (length dl)))%pred sm ]] * [[ (BmapNBlocks xp) <= valulen * valulen /\ BmapStart xp <> 0 ]] * [[ length bl = BmapNBlocks xp /\ length dl = ((BmapNBlocks xp) * valulen)%nat ]] POST:hm' RET:ms exists m' freeblocks, LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * rep xp freeblocks ms) ]]] * [[ (Fs * smrep freeblocks)%pred sm ]] * [[ forall bn, bn < (BmapNBlocks xp) * valulen -> In bn freeblocks ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init lxp xp ms. Proof. unfold init, rep, MSLog; intros. step. step. eapply listpred_seq_smrep; eauto. Qed. Theorem init_nofree_ok : forall lxp xp ms, {< F Fm Fs m0 sm m bl, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * arrayN (@ptsto _ _ _) (BmapStart xp) bl) ]]] * [[ Fs sm ]] * [[ (BmapNBlocks xp) <= valulen * valulen /\ BmapStart xp <> 0 ]] * [[ length bl = BmapNBlocks xp ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[ (Fs * smrep nil)%pred sm ]] * [[[ m' ::: (Fm * rep xp nil ms) ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init_nofree lxp xp ms. Proof. unfold init_nofree, rep, MSLog; intros. step. step. Qed. Theorem steal_ok : forall lxp xp bn ms, {< F Fm Fs m0 sm m freeblocks, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLog ms) sm hm * [[[ m ::: (Fm * rep xp freeblocks ms) ]]] * [[ (Fs * smrep freeblocks)%pred sm ]] * [[ bn_valid xp bn /\ In bn freeblocks ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * bn |->? * rep xp (remove addr_eq_dec bn freeblocks) ms) ]]] * [[ (Fs * bn |->? * smrep (remove addr_eq_dec bn freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} steal lxp xp bn ms. 
BFalse | BEq a1 a2 => match (fold_constants_aexp a1, fold_constants_aexp a2) with | (ANum n1, ANum n2) => if beq_nat n1 n2 then BTrue else BFalse | (a1', a2') => BEq a1' a2' end | BLe a1 a2 => match (fold_constants_aexp a1, fold_constants_aexp a2) with | (ANum n1, ANum n2) => if leb n1 n2 then BTrue else BFalse | (a1', a2') => BLe a1' a2' end | BNot b1 => match (fold_constants_bexp b1) with | BTrue => BFalse | BFalse => BTrue | b1' => BNot b1' end | BAnd b1 b2 => match (fold_constants_bexp b1, fold_constants_bexp b2) with | (BTrue, BTrue) => BTrue | (BTrue, BFalse) => BFalse | (BFalse, BTrue) => BFalse | (BFalse, BFalse) => BFalse | (b1', b2') => BAnd b1' b2' end end.Example fold_bexp_ex1 : fold_constants_bexp (BAnd BTrue (BNot (BAnd BFalse BTrue))) = BTrue. Proof. reflexivity. Qed.Example fold_bexp_ex2 : fold_constants_bexp (BAnd (BEq (AId X) (AId Y)) (BEq (ANum 0) (AMinus (ANum 2) (APlus (ANum 1) (ANum 1))))) = BAnd (BEq (AId X) (AId Y)) BTrue. Proof. reflexivity. Qed.Fixpoint fold_constants_com (c : com) : com := match c with | SKIP => SKIP | i ::= a => CAss i (fold_constants_aexp a) | c1 ;; c2 => (fold_constants_com c1) ;; (fold_constants_com c2) | IFB b THEN c1 ELSE c2 FI => match fold_constants_bexp b with | BTrue => fold_constants_com c1 | BFalse => fold_constants_com c2 | b' => IFB b' THEN fold_constants_com c1 ELSE fold_constants_com c2 FI end | WHILE b DO c END => match fold_constants_bexp b with | BTrue => WHILE BTrue DO SKIP END | BFalse => SKIP | b' => WHILE b' DO (fold_constants_com c) END end end.Example fold_com_ex1 : fold_constants_com (X ::= APlus (ANum 4) (ANum 5);; Y ::= AMinus (AId X) (ANum 3);; IFB BEq (AMinus (AId X) (AId Y)) (APlus (ANum 2) (ANum 4)) THEN SKIP ELSE Y ::= ANum 0 FI;; IFB BLe (ANum 0) (AMinus (ANum 4) (APlus (ANum 2) (ANum 1))) THEN Y ::= ANum 0 ELSE SKIP FI;; WHILE BEq (AId Y) (ANum 0) DO X ::= APlus (AId X) (ANum 1) END) = (X ::= ANum 9;; Y ::= AMinus (AId X) (ANum 3);; IFB BEq (AMinus (AId X) (AId Y)) (ANum 6) THEN SKIP ELSE (Y ::= ANum 0) FI;; Y ::= ANum 0;; WHILE BEq (AId Y) (ANum 0) DO X ::= APlus (AId X) (ANum 1) END). Proof. reflexivity. Qed. Theorem fold_constants_aexp_sound : atrans_sound fold_constants_aexp. 
minusA multA eqA_dec n ltM ltM_dec Rec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) b (b:=a) nZa) q)). Defined. Theorem minuspf_in : forall (p q : list (Term A n)) (a b : Term A n), In a p -> ltT ltM b a -> canonical A0 eqA ltM p -> canonical A0 eqA ltM (pX b q) -> In a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (pX b q)). intros p; elim p; simpl in |- *; auto. intros q a b H'; elim H'; auto. intros a l H' q a0 b H'0 H'1 H'2 H'3. elim H'0; [ intros H'4; rewrite H'4; clear H'0 | intros H'4; clear H'0 ]. change (In a0 (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (pX a0 l) (pX b q))) in |- *. rewrite <- minuspf_inv1_eq; simpl in |- *; auto. case (ltT_dec A n ltM ltM_dec a b); intros test; [ case test; clear test; intros test | idtac ]. absurd (ltT ltM b a0); auto. apply ltT_not_ltT; auto. generalize H'4 H'2; elim l; simpl in |- *; auto. intros H'0; elim H'0; auto. intros a1 l0 H'0 H'5; elim H'5; [ intros H'6; rewrite <- H'6; clear H'5 | intros H'6; clear H'5 ]; auto. intros H'5; apply (ltT_trans A n ltM os) with (y := a); auto. apply (canonical_pX_order A A0 eqA) with (l := l0); auto. intros H'5; apply H'0; auto. change (canonical A0 eqA ltM (pX a l0)) in |- *. apply canonical_skip_fst with (b := a1); auto. change (In a0 (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (pX a l) (pX b q))) in |- *. rewrite <- minuspf_inv1_eq; simpl in |- *; auto. right; auto. apply H'; auto. apply canonical_imp_canonical with (a := a); auto. absurd (ltT ltM b a0); auto. apply ltT_not_ltT; auto. apply eqT_compat_ltTr with (b := a); auto. generalize H'4 H'2; elim l; simpl in |- *; auto. intros H'0; elim H'0; auto. intros a1 l0 H'0 H'5; elim H'5; [ intros H'6; rewrite <- H'6; clear H'5 | intros H'6; clear H'5 ]; auto. intros H'5; apply (canonical_pX_order A A0 eqA) with (l := l0); auto. intros H'5; apply H'0; auto. change (canonical A0 eqA ltM (pX a l0)) in |- *. apply canonical_skip_fst with (b := a1); auto. Qed. Theorem minus_is_reduce : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (q : list (Term A n)), inPolySet A A0 eqA n ltM (pX a q) Q -> forall u : Term A n, divP A A0 eqA multA divA n u a -> forall p : list (Term A n), canonical A0 eqA ltM p -> In u p -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) nZa) (pX a q))). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations. From Categories Require Import Functor.Main. From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop. From Categories Require Import NatTrans.Main.Local Open Scope functor_scope. Local Notation NID := NatTrans_id (only parsing). Local Notation FCAT := Func_Cat (only parsing). Notation Hom_Adj_Left C D F G := ((Hom_Func D) ∘ (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing). Notation Hom_Adj_Right C D F G := ((Hom_Func C) ∘ (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).Local Obligation Tactic := idtac.Section Adjunction. Context {C D : Category} (F : C –≻ D) (G : D –≻ C). Record Adjunct : Type := { adj_unit : ((Functor_id C) –≻ (G ∘ F))%nattrans; adj_morph_ex {c : C} {d : D} (f : (c –≻ (G _o d)%object)%morphism) : ((F _o c)%object –≻ d)%morphism; adj_morph_com {c : C} {d : D} (f : (c –≻ (G _o d))%morphism%object) : f = ((G _a (adj_morph_ex f)) ∘ (Trans adj_unit c))%morphism; adj_morph_unique {c : C} {d : D} (f : (c –≻ (G _o d))%object%morphism) (g h : ((F _o c) –≻ d)%morphism%object) : f = ((G _a g) ∘ (Trans adj_unit c))%morphism → f = ((G _a h) ∘ (Trans adj_unit c))%morphism → g = h }. Arguments adj_unit : clear implicits. Arguments adj_morph_ex _ {_ _} _. Arguments adj_morph_com _ {_ _} _. Arguments adj_morph_unique _ {_ _} _ _ _ _ _. Theorem Adjunct_eq_simplify (adj adj' : Adjunct) : adj_unit adj = @adj_unit adj' → @adj_morph_ex adj = @adj_morph_ex adj' → adj = adj'. 
(e x); auto with zfc. Qed.Hint Resolve EQC_sym EQC_refl EQC_INC: zfc.Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'. simple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros. apply X1. exists x; auto with zfc. cut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc). apply X2; exists y; auto with zfc. Qed.Hint Resolve CINC_EQC: zfc.Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''. simple induction E''; simpl in |- *; intros. elim X1; intros y p; exists y. apply EQC_tran with E; auto with zfc. Qed.Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''. simple induction E'; simple induction E''; simpl in |- *; intros. elim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc. Qed.Theorem CINC_refl : forall E : Ens, CINC E E. unfold CINC in |- *; auto with zfc. Qed.Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''. unfold CINC in |- *; auto with zfc. Qed. Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''. simple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1. apply CIN_sound_right with E'; auto with zfc. Qed.Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''. simple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros. elim (X2 E0); try assumption; intros. elim X1; intros XA XB; elim (XA x); intros. exists x0; apply EQC_tran with (e x); auto with zfc. Qed.Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide. unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split. intros; elim (H (e x)); auto with zfc. exists x; auto with zfc. simple induction y. Qed. Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B). 
case a; case b; simpl in |- *; auto. intros a0 m a1 m0 nZa H; split; auto. apply divA_is_multA with (1 := cs); auto. apply ppcm_prop_l. Qed. Theorem divTerm_ppcr : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqTerm (A:=A) eqA (n:=n) (ppc a b) (multTerm (A:=A) multA (n:=n) (divTerm (ppc a b) nZb) b). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 H nZb; split; auto. apply divA_is_multA with (1 := cs); auto. apply ppcm_prop_r. Qed. Theorem ppc_nZ : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b). intros a b; case a; case b; simpl in |- *; auto. Qed. Theorem divTerm_rew : forall (a b : Term A n) (nZ1 nZ2 : ~ zeroP (A:=A) A0 eqA (n:=n) b), divTerm a nZ1 = divTerm a nZ2. intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 nZ1 nZ2. rewrite divA_rew with (1 := cs) (nZ2 := nZ2); auto. Qed. Inductive divP : Term A n -> Term A n -> Prop := divTerm_def : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b) -> divP a b. Theorem divP_inv1 : forall a b : Term A n, divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) a. intros a b H; inversion H; auto. Qed. Theorem divP_inv2 : forall a b : Term A n, divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b. intros a b H; inversion H; auto. Qed. Theorem divP_inv3 : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b), divP a b -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). intros a b nZb H; inversion H; auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a nZb0) b); auto. Qed. Hint Resolve divP_inv1 divP_inv2 divP_inv3. Theorem divP_plusTerm : forall a b c : Term A n, divP a c -> divP b c -> eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> divP (plusTerm (A:=A) plusA (n:=n) a b) c. 
st' ms m t n pli plt es ci e, doLeader st h = (os, st', ms) -> In m ms -> snd m = AppendEntries t n pli plt es ci -> In e es -> In e (log st). Proof using. intros. unfold doLeader, advanceCommitIndex in *. break_match; try solve [find_inversion; simpl in *; intuition]. break_if; try solve [find_inversion; simpl in *; intuition]. find_inversion. simpl. do_in_map. subst. simpl in *. find_inversion. eauto using findGtIndex_in. Qed. Theorem handleAppendEntries_log_term_type : forall h st t n pli plt es ci st' ps, handleAppendEntries h st t n pli plt es ci = (st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' = Follower. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleAppendEntries_votesReceived : forall h st t n pli plt es ci st' ps, handleAppendEntries h st t n pli plt es ci = (st', ps) -> votesReceived st' = votesReceived st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleAppendEntriesReply_log_term_type : forall h st n t es r st' ps, handleAppendEntriesReply h st n t es r = (st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' = Follower. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleAppendEntriesReply_votesReceived : forall h st n t es r st' ps, handleAppendEntriesReply h st n t es r = (st', ps) -> votesReceived st' = votesReceived st. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleRequestVote_log_term_type : forall h st t c li lt st' m, handleRequestVote h st t c li lt = (st', m) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' = Follower. Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleRequestVote_votesReceived : forall h st t c li lt st' m, handleRequestVote h st t c li lt = (st', m) -> votesReceived st' = votesReceived st. Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleRequestVoteReply_log_term_type : forall h st t h' r st', type st' = Candidate -> handleRequestVoteReply h st h' t r = st' -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st). 
fds, get_b f im = false -> (name_in_fundefs fds f <-> name_in_fundefs (inlined_fundefs_f fds im) f). Proof. induction fds; simpl; intros. 2: split; intro; auto. destruct (var_dec v f). - subst. rewrite H. simpl. split; intro. left; auto. left; auto. - split. intro. inv H0. exfalso. apply n. inv H1. auto. apply IHfds in H1; auto. destruct (get_b v im); auto. constructor 2. auto. intro. right. apply IHfds; auto. destruct (get_b v im). auto. inv H0. exfalso; apply n; inv H1; auto. auto. Qed. Theorem Included_name_in_fundefs_inlined: forall im fds, Included _ (name_in_fundefs (inlined_fundefs_f fds im)) (name_in_fundefs fds). Proof. induction fds; eauto with Ensembles_DB. simpl. destruct (get_b v im); simpl; auto with Ensembles_DB. Qed. Theorem name_in_fundefs_not_inlined': forall f fds im, name_in_fundefs fds f -> get_b f im = false -> bound_var_fundefs (inlined_fundefs_f fds im) f. Proof. induction fds; simpl; intros. - inv H. inv H1. rewrite H0. apply bound_var_fundefs_Fcons. auto. specialize (IHfds _ H1 H0). destruct (get_b v im); eauto with Ensembles_DB. - inv H. Qed. Theorem fundefs_ctx_append_num_occur: forall B1 B2, forall (x : var) (n m : nat), num_occur_fds B1 x n -> num_occur_fdc B2 x m -> num_occur_fdc (fundefs_ctx_append B1 B2) x (n + m). Proof. induction B1; intros. - simpl in H. inv H. simpl. eapply num_occur_fdc_n. constructor. eauto. apply IHB1; eauto. lia. - inv H. auto. Qed. Theorem fundefs_ctx_append_num_occur': forall (B1: fundefs) B2 (nm : nat) (x : var), num_occur_fdc (fundefs_ctx_append B1 B2) x nm -> exists n m : nat, num_occur_fds B1 x n /\ num_occur_fdc B2 x m /\ n + m = nm. Proof. induction B1; intros. - simpl in H. inv H. apply IHB1 in H8. destructAll. exists (n + x0), x1. split. constructor; auto. split; auto. lia. - simpl in H. exists 0, nm. split; auto. constructor. Qed. Theorem rename_all_fun_ns_inlined_fundefs: forall sig im fds, (rename_all_fun_ns sig (inlined_fundefs_f fds im)) = (inlined_fundefs_f (rename_all_fun_ns sig fds) im). Proof. induction fds; simpl. - destruct (get_b v im). + auto. + simpl. rewrite IHfds. auto. - auto. Qed. Theorem update_count_inlined_unaffected: forall v0 lx ly count, ~FromList lx v0 -> ~FromList ly v0 -> get_c v0 (update_count_inlined ly lx count) = get_c v0 count. Proof. induction lx; intros. destruct ly; simpl; auto. destruct ly. simpl. auto. simpl. erewrite IHlx. rewrite gdso. rewrite gdso. auto. intro; apply H. constructor; auto. intro; apply H0. constructor; auto. intro; apply H. constructor 2; auto. intro; apply H0. constructor 2; auto. Qed. Theorem update_count_inlined_dom: forall v0 lx ly count, List.length lx = List.length ly -> FromList lx v0 -> Disjoint _ (FromList ly) (FromList lx) -> get_c v0 (update_count_inlined ly lx count) = 0. 
Require Export CoefStructure. Section mCoef. Load "hCoefStructure". Load "mCoefStructure". Let eqA_trans := eqA_trans _ _ _ _ _ _ _ _ _ cs. Let eqA_sym := eqA_sym _ _ _ _ _ _ _ _ _ cs. Theorem eqA_A0 : forall a b : A, eqA a A0 -> eqA a b -> eqA b A0. intros a b H H1; apply eqA_trans with (y := a); auto. Qed. Theorem plusA_eqA_comp_l : forall a b c : A, eqA a b -> eqA (plusA a c) (plusA b c). intros a b c H'; auto. Qed. Theorem plusA_eqA_comp_r : forall a b c : A, eqA a b -> eqA (plusA c a) (plusA c b). intros a b c H'; auto. Qed. Theorem eqA0_left : forall a b : A, eqA a A0 -> eqA b (plusA a b). intros a b H'; apply eqA_trans with (y := plusA A0 b); auto. apply eqA_trans with (y := plusA b A0); auto. Qed. Theorem eqA0_right : forall a b : A, eqA b A0 -> eqA a (plusA a b). 
-> exists x, nth_error_get_hlist_nth (tvs ++ tvs') n = Some x /\ exists y, nth_error_get_hlist_nth tvs n = Some (@existT _ _ (projT1 x) y) /\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs. Proof. clear. induction tvs; simpl; intros. { exfalso; inversion H. } { destruct n. { clear H IHtvs. eexists; split; eauto. eexists; split; eauto. simpl. intros. rewrite (hlist_eta vs). reflexivity. } { apply Lt.lt_S_n in H. { specialize (IHtvs _ H). forward_reason. rewrite H0. rewrite H1. forward. subst. simpl in *. eexists; split; eauto. eexists; split; eauto. simpl. intros. rewrite (hlist_eta vs). simpl. auto. } } } Qed. Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'. Proof. clear. induction tvs; simpl; intros. { rewrite <- Minus.minus_n_O. rewrite H0. destruct x. simpl. eexists; split; eauto. intros. rewrite (hlist_eta vs). reflexivity. } { destruct n. { inversion H. } { assert (n >= length tvs) by (eapply le_S_n; eassumption). clear H. { forward. inv_all; subst. simpl in *. specialize (IHtvs _ _ H1 H0). simpl in *. forward_reason. rewrite H. eexists; split; eauto. intros. rewrite (hlist_eta vs). simpl. auto. } } } Qed.End hlist.Arguments Hnil {_ _}. Arguments Hcons {_ _ _ _} _ _. Arguments equiv_hlist {_ F} R {_} _ _ : rename. Section hlist_map. Variable A : Type. Variables F G : A -> Type. Variable ff : forall x, F x -> G x. Fixpoint hlist_map (ls : list A) (hl : hlist F ls) {struct hl} : hlist G ls := match hl in @hlist _ _ ls return hlist G ls with | Hnil => Hnil | Hcons _ _ hd tl => Hcons (ff hd) (hlist_map tl) end. Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b). Proof. induction a. simpl; auto. simpl. intros. f_equal. auto. Qed.End hlist_map.Arguments hlist_map {_ _ _} _ {_} _. Section hlist_map_rules. Variable A : Type. Variables F G G' : A -> Type. Variable ff : forall x, F x -> G x. Variable gg : forall x, G x -> G' x. Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl. 
-> _ <= _ -> _ < _). apply lt_le_trans with j. apply H. apply le_trans with (k-3). Search (_ < _ -> _ <= _). apply lt_le_weak. auto. apply le_minus. Qed. Theorem omega_example2: forall i j k, i < j -> ~ (k - 3 <= j) -> k > i. Proof. intros. omega. Qed.Definition maybe_swap (al: list nat) : list nat := match al with | a :: b :: ar => if a >? b then b::a::ar else a::b::ar | _ => al end.Example maybe_swap_123: maybe_swap [1; 2; 3] = [1; 2; 3]. Proof. reflexivity. Qed.Example maybe_swap_321: maybe_swap [3; 2; 1] = [2; 3; 1]. Proof. reflexivity. Qed.Check (1>2). Check (1>?2). Locate ">?". Print Nat.ltb.Locate ">=?".Locate leb. Print leb. Print Nat.leb. Theorem maybe_swap_idempotent: forall al, maybe_swap (maybe_swap al) = maybe_swap al. Proof. intros. destruct al as [ | a al]. simpl. reflexivity. destruct al as [ | b al]. simpl. reflexivity. simpl. destruct (b <? a) eqn:H. simpl. destruct (a <? b) eqn:H0. try omega. Abort.Theorem maybe_swap_idempotent: forall al, maybe_swap (maybe_swap al) = maybe_swap al. Proof. intros. destruct al as [ | a al]. simpl. reflexivity. destruct al as [ | b al]. simpl. reflexivity. simpl. destruct (blt_reflect b a). *) * simpl. bdestruct (a <? b). omega. reflexivity. * simpl. bdestruct (b <? a). omega. reflexivity. Qed.Theorem maybe_swap_idempotent': forall al, maybe_swap (maybe_swap al) = maybe_swap al. Proof. intros. destruct al as [ | a al]. simpl. reflexivity. destruct al as [ | b al]. simpl. reflexivity. simpl. bdestruct (b <? a). * simpl. bdestruct (a <? b). omega. reflexivity. * simpl. bdestruct (b <? a). omega. reflexivity. Qed. Locate Permutation. Check Permutation. Print Permutation. Search Permutation. Example butterfly: forall b u t e r f l y : nat, Permutation ([b;u;t;t;e;r]++[f;l;y]) ([f;l;u;t;t;e;r]++[b;y]). Proof. intros. change [b;u;t;t;e;r] with ([b]++[u;t;t;e;r]). change [f;l;u;t;t;e;r] with ([f;l]++[u;t;t;e;r]). remember [u;t;t;e;r] as utter. clear Hequtter. Check app_assoc. rewrite <- app_assoc. rewrite <- app_assoc. Check perm_trans. apply perm_trans with (utter ++ [f;l;y] ++ [b]). rewrite (app_assoc utter [f;l;y]). Check Permutation_app_comm. apply Permutation_app_comm. eapply perm_trans. 2: apply Permutation_app_comm. rewrite <- app_assoc. Search (Permutation (_++_) (_++_)). apply Permutation_app_head. eapply perm_trans. 2: apply Permutation_app_comm. simpl. Check perm_skip. apply perm_skip. apply perm_skip. Search (Permutation (_::_) (_::_)). apply perm_swap. Qed. Check perm_skip. Check Permutation_refl. Check Permutation_app_comm. Check app_assoc.Example permut_example: forall (a b: list nat), Permutation (5::6::a++b) ((5::b)++(6::a++[])). Proof. Admitted.Check Permutation_cons_inv. Check Permutation_length_1_inv.Example not_a_permutation: ~ Permutation [1;1] [1;2]. Proof. Admitted. Theorem maybe_swap_perm: forall al, Permutation al (maybe_swap al). 
*; auto. intros P0 H' H'0 H'1 c H'2; elim H'2; [ intros H'3; rewrite <- H'3; clear H'2 | intros H'3; clear H'2 ]; auto. elim (H'1 c); [ intros H'5; try exact H'5 | intros H'5 | idtac ]; auto. intros P0 H' H'0 H'1 c H'2; elim H'2; [ intros H'3; rewrite <- H'3; clear H'2 | intros H'3; clear H'2 ]; auto. elim (H'1 c); [ intros H'5; try exact H'5 | intros H'5 | idtac ]; auto. Qed. Theorem slice_cons : forall (i a : poly A0 eqA ltM) (aP Q : list (poly A0 eqA ltM)), slice i a aP = DontKeep Q -> (exists c : poly A0 eqA ltM, In c Q /\ divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM i a) c) \/ foreigner A A0 A1 eqA multA n ltM i a. intros i a aP; elim aP. simpl in |- *; case (foreigner_dec A A0 A1 eqA multA n ltM i a); auto. intros H' Q H'0; inversion H'0. intros a0 l H' Q; simpl in |- *. case (divp_dec _ _ _ _ _ _ _ _ _ cs n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM i a) a0); auto. intros H'0 H'1; inversion H'1; auto. left; exists a0; split; simpl in |- *; auto. case (divp_dec _ _ _ _ _ _ _ _ _ cs n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM i a0) a); auto. generalize H'; clear H'; case (slice i a l); simpl in |- *; auto. intros P H' H'0 H'1 H'2; inversion H'2. intros P H' H'0 H'1 H'2; inversion H'2. elim (H' P); [ intros H'5; elim H'5; intros c E; elim E; intros H'6 H'7; clear E H'5 | intros H'5 | idtac ]; auto. left; exists c; split; simpl in |- *; auto. Qed. Definition Tl : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop. exact (fun x y : list (poly A0 eqA ltM) => length x < length y). Defined. Theorem wf_Tl : well_founded Tl. apply (wf_inverse_image _ _ lt (length (A:=poly A0 eqA ltM))); auto. generalize lt_wf; auto. Qed. Scheme Sdep := Induction for prod Sort Prop. Require Import Arith. Theorem slice_Tl : forall (a ia : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), Tl (slicef a ia L) (a :: L). 
From Perennial.iris_lib Require Export conflicting. From Perennial.algebra.big_op Require Import big_sepM. From iris.proofmode Require Import tactics.Set Default Proof Using "Type*". Set Default Goal Selector "!".Section bi. Context {PROP:bi} `{!BiAffine PROP, !BiPersistentlyForall PROP}. Implicit Types (P Q: PROP).Section maplist. Context `{Countable K} {V LV : Type}. Implicit Types Φ Ψ : K → V → LV → PROP. Implicit Types m : gmap K V. Implicit Types l : list LV. Definition big_sepML_def Φ m l : PROP := (∃ lm, ⌜ l ≡ₚ snd <$> (map_to_list lm) ⌝ ∗ [∗ map] k ↦ v;lvm ∈ m;lm, Φ k v lvm)%I. Definition big_sepML_aux : seal (@big_sepML_def). Proof. by eexists. Qed. Definition big_sepML := unseal big_sepML_aux. Definition big_sepML_eq : @big_sepML = @big_sepML_def := big_sepML_aux.(seal_eq). Global Instance big_sepML_proper : Proper (pointwise_relation _ (pointwise_relation _ (pointwise_relation _ (⊢))) ==> (=) ==> (Permutation) ==> (⊢)) (big_sepML). Proof. intros P0 P1 HP. intros m0 m Hm; subst. intros l0 l1 Hl. rewrite big_sepML_eq. iIntros "Hml". iDestruct "Hml" as (lm) "[Hlm Hml]". rewrite Hl. iExists lm; iFrame. iApply big_sepM2_mono; iFrame. iIntros (k v lv ? ?) "H". iApply HP; iFrame. Qed. Theorem big_sepML_empty Φ : ⊢ big_sepML Φ  nil. Proof. iIntros. rewrite big_sepML_eq. iExists  . eauto. Qed. Theorem big_sepML_insert Φ m l k v lv : m !! k = None -> Φ k v lv ∗ big_sepML Φ m l -∗ big_sepML Φ (<[k := v]> m) (lv :: l). Proof. iIntros "% [Hp Hml]". rewrite big_sepML_eq. iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_lookup_l_none with "Hml") as %Hlmnone; eauto. iExists (<[k := lv]> lm). iSplitR. - iPureIntro. rewrite map_to_list_insert; eauto. rewrite /=. rewrite H1. reflexivity. - iApply big_sepM2_insert; eauto. iFrame. Qed. Theorem big_sepML_insert_app Φ m l k v lv : m !! k = None -> Φ k v lv ∗ big_sepML Φ m l -∗ big_sepML Φ (<[k := v]> m) (l ++ [lv]). 
build_the_discrete_model. Let l := proj1_sig fin. Let Hl : forall x, x ∊ l := proj2_sig fin. Hint Resolve fom_eq_dec : core. Let Q : fin_quotient fom_eq. Proof. apply decidable_EQUIV_fin_quotient with (l := l); eauto. Qed. Let n := fq_size Q. Let cls := fq_class Q. Let repr := fq_repr Q. Let E1 p : cls (repr p) = p. Proof. apply fq_surj. Qed. Let E2 x y : x ≡ y <-> cls x = cls y. Proof. apply fq_equiv. Qed. Let Md : fo_model Σ (pos n). Proof. exists. + intros s v; apply cls, (fom_syms M s), (vec_map repr v). + intros s v; apply (fom_rels M s), (vec_map repr v). Defined. Let H1 s v : s ∊ ls -> cls (fom_syms M s v) = fom_syms Md s (vec_map cls v). Proof. intros Hs; simpl. apply E2. apply fom_eq_syms_full; auto. intros p; rewrite vec_map_map, vec_pos_map. apply E2; rewrite E1; auto. Qed. Let H2 r v : r ∊ lr -> fom_rels M r v <-> fom_rels Md r (vec_map cls v). Proof. intros Hs; simpl. apply fom_eq_rels_full; auto. intros p; rewrite vec_map_map, vec_pos_map. apply E2; rewrite E1; auto. Qed. Let f : fo_projection ls lr M Md. Proof. exists cls repr; abstract auto. Defined. Let H3 φ ρ : fol_syms φ ⊑ ls -> fol_rels φ ⊑ lr -> M,ρ ⊨ φ <-> Md,cls∘ρ ⊨ φ. Proof. intros; apply fo_model_projection with (p := f); auto. Qed. Let H4 p q : fo_bisimilar Md p q <-> p = q. Proof. split. + intros H. rewrite <- (E1 q), <- (E1 p). apply E2, fom_eq_fol_characterization. intros A Hs Hr phi. specialize (H A Hs Hr (fun p => cls (phi p))). revert H; apply fol_equiv_impl. all: rewrite H3; auto; apply fol_sem_ext; intros []; now simpl. + intros []; red; tauto. Qed. Theorem fo_fin_model_discretize : { n : nat & { Md : fo_model Σ (pos n) & { _ : fo_model_dec Md & { _ : fo_projection ls lr M Md & (forall p q, fo_bisimilar Md p q <-> p = q) } } } }. Proof using E1. exists n, Md. exists; eauto. red; simpl; auto. Qed. End build_the_discrete_model. Section FO_definability. Local Fact fom_eq_finite : { n | forall x y, x ≡ y <-> iter fom_op (fun _ _ => True) n x y }. Proof using fin dec. apply gfp_finite_t; eauto. Qed. Theorem fo_bisimilar_fol_def : fol_definable ls lr M (fun φ => φ 0 ≐ φ 1). 
Type) : A <~> A := BuildEquiv A A idmap _.Arguments equiv_idmap {A} , A.Notation "1" := equiv_idmap : equiv_scope.Global Instance reflexive_equiv : Reflexive Equiv | 0 := @equiv_idmap. Global Instance isequiv_compose `{IsEquiv A B f} `{IsEquiv B C g} : IsEquiv (compose g f) | 1000 := BuildIsEquiv A C (compose g f) (compose f^-1 g^-1) (fun c => ap g (eisretr f (g^-1 c)) @ eisretr g c) (fun a => ap (f^-1) (eissect g (f a)) @ eissect f a) (fun a => (whiskerL _ (eisadj g (f a))) @ (ap_pp g _ _)^ @ ap02 g ( (concat_A1p (eisretr f) (eissect g (f a)))^ @ (ap_compose f^-1 f _ @@ eisadj f a) @ (ap_pp f _ _)^ ) @ (ap_compose f g _)^ ). Definition isequiv_compose' {A B : Type} (f : A -> B) (_ : IsEquiv f) {C : Type} (g : B -> C) (_ : IsEquiv g) : IsEquiv (g o f) := isequiv_compose.Definition equiv_compose {A B C : Type} (g : B -> C) (f : A -> B) `{IsEquiv B C g} `{IsEquiv A B f} : A <~> C := BuildEquiv A C (compose g f) _.Definition equiv_compose' {A B C : Type} (g : B <~> C) (f : A <~> B) : A <~> C := equiv_compose g f. Notation "g 'oE' f" := (equiv_compose' g%equiv f%equiv) (at level 40, left associativity) : equiv_scope. Global Instance transitive_equiv : Transitive Equiv | 0 := fun _ _ _ f g => equiv_compose g f.Section IsEquivHomotopic. Context {A B : Type} (f : A -> B) {g : A -> B}. Context `{IsEquiv A B f}. Hypothesis h : f == g. Let sect := (fun b:B => (h (f^-1 b))^ @ eisretr f b). Let retr := (fun a:A => (ap f^-1 (h a))^ @ eissect f a). Let adj (a : A) : sect (g a) = ap g (retr a). Proof. unfold sect, retr. rewrite ap_pp. apply moveR_Vp. rewrite concat_p_pp, <- concat_Ap, concat_pp_p, <- concat_Ap. rewrite ap_V; apply moveL_Vp. rewrite <- ap_compose; rewrite (concat_A1p (eisretr f) (h a)). apply whiskerR, eisadj. Qed. Definition isequiv_homotopic : IsEquiv g := BuildIsEquiv _ _ g (f ^-1) sect retr adj. Definition equiv_homotopic : A <~> B := BuildEquiv _ _ g isequiv_homotopic.End IsEquivHomotopic.Section EquivInverse. Context {A B : Type} (f : A -> B) {feq : IsEquiv f}. Theorem other_adj (b : B) : eissect f (f^-1 b) = ap f^-1 (eisretr f b). 
=> false | String y ys => if Byte.byte_eq_dec x y then prefix xs ys else false end end. Fixpoint substring (n m : nat) (s : bs) : bs := match n, m, s with | O, O, _ => BS.EmptyString | O, S m', BS.EmptyString => s | O, S m', BS.String c s' => BS.String c (substring 0 m' s') | S n', _, BS.EmptyString => s | S n', _, BS.String c s' => substring n' m s' end. Fixpoint index (n : nat) (s1 s2 : bs) {struct s2} : option nat := match s2 with | EmptyString => match n with | 0 => match s1 with | "" => Some 0 | String _ _ => None end | S _ => None end | String _ s2' => match n with | 0 => if prefix s1 s2 then Some 0 else match index 0 s1 s2' with | Some n0 => Some (S n0) | None => None end | S n' => match index n' s1 s2' with | Some n0 => Some (S n0) | None => None end end end%bs. Fixpoint length (l : bs) : nat := match l with | EmptyString => 0 | String _ l => S (length l) end. Lemma print_length (s : bs) : List.length (print s) = length s. Proof. induction s; simpl. - easy. - now rewrite IHs. Qed. Fixpoint contains (start : nat) (keys : list bs) (fullname : bs) :bool := match keys with | kh::ktl => match index start kh fullname with | Some n => contains (n + length kh) ktl fullname | None => false end | [] => true end. Definition eqb (a b : bs) : bool := if eq_dec a b then true else false. #[deprecated(since="2021-09-21", note="Use [byte_to_N_inj]")] Notation to_N_inj := byte_to_N_inj. End BS. Export Bytestring_notations.Fixpoint bs_cmp (xs ys : bs) : comparison := match xs , ys with | BS.EmptyString , BS.EmptyString => Eq | BS.EmptyString , _ => Lt | _ , BS.EmptyString => Gt | BS.String x xs , BS.String y ys => match byte_cmp x y with | Eq => bs_cmp xs ys | x => x end end%bs.Module OT_bs <: OrderedType.OrderedType with Definition t := bs. Definition t := bs. Definition eq := @eq bs. Definition lt := fun l r => bs_cmp l r = Lt. Theorem lm x y : CompareSpec (x = y) (lt x y) (lt y x) (bs_cmp x y). 
auto with arith. auto. Qed. Section bugFix. Variable PdivAux : positive -> positive -> Option positive * Option positive. Fixpoint PdivlessAux (bound p base length : positive) {struct length} : Option positive * Option positive * nat := match Pcompare bound p Datatypes.Eq with | Datatypes.Gt => (Some _ p, None _, 0) | _ => match PdivAux p base with | (None, None) => (None _, None _, 1) | (None, Some r1) => (None _, Some _ r1, 1) | (Some q1, None) => match length with | xH => (Some _ q1, None _, 0) | xO length' => match PdivlessAux bound q1 base length' with | (s2, None, n) => (s2, None _, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => (x * y)%positive) r2 (fun x => x) base), S n) end | xI length' => match PdivlessAux bound q1 base length' with | (s2, None, n) => (s2, None _, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => (x * y)%positive) r2 (fun x => x) base), S n) end end | (Some q1, Some r1) => match length with | xH => (Some _ q1, None _, 0) | xO length' => match PdivlessAux bound q1 base length' with | (s2, None, n) => (s2, Some _ r1, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => x * y) r2 ( fun x => x) base + r1)%positive, S n) end | xI length' => match PdivlessAux bound q1 base length' with | (s2, None, n) => (s2, Some _ r1, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => x * y) r2 ( fun x => x) base + r1)%positive, S n) end end end end. End bugFix. Definition Pdivless := PdivlessAux Pdiv. Theorem Pdivless1 : forall bound p q base, Pcompare bound p Datatypes.Eq = Datatypes.Gt -> Pdivless bound p base q = (Some _ p, None _, 0). intros bound p q base H; case q; simpl in |- *; auto; intros; rewrite H; auto. Qed. Theorem Pdivless2 : forall bound p length base, Pcompare bound p Datatypes.Eq <> Datatypes.Gt -> Pdivless bound p base length = match Pdiv p base with | (None, None) => (None _, None _, 1) | (None, Some r1) => (None _, Some _ r1, 1) | (Some q1, None) => match length with | xH => (Some _ q1, None _, 0) | xO length' => match Pdivless bound q1 base length' with | (s2, None, n) => (s2, None _, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => (x * y)%positive) r2 ( fun x => x) base), S n) end | xI length' => match Pdivless bound q1 base length' with | (s2, None, n) => (s2, None _, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => (x * y)%positive) r2 ( fun x => x) base), S n) end end | (Some q1, Some r1) => match length with | xH => (Some _ q1, None _, 0) | xO length' => match Pdivless bound q1 base length' with | (s2, None, n) => (s2, Some _ r1, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => x * y) r2 ( fun x => x) base + r1)%positive, S n) end | xI length' => match Pdivless bound q1 base length' with | (s2, None, n) => (s2, Some _ r1, S n) | (s2, Some r2, n) => (s2, Some _ ((fun (x : positive) (_ : positive -> positive) (y : positive) => x * y) r2 ( fun x => x) base + r1)%positive, S n) end end end. 
intros H; rewrite H | idtac ]; auto with real. apply Zcompare_EGAL. generalize H'; unfold Feq_bool, Fcompare in |- *. case (Fdiff x y ?= 0)%Z;auto; intros; discriminate. Qed. Theorem Feq_bool_correct_r : forall x y : float, Feq x y -> Feq_bool x y = true. intros x y H'; cut ((x - y)%R = 0%R). rewrite <- Fdiff_correct; intros H'1; case Rmult_integral with (1 := H'1). intros H'0; unfold Feq_bool, Fcompare in |- *. rewrite eq_IZR_R0 with (1 := H'0); auto. intros H'0; Contradict H'0. case (Zmin (Fexp x) (Fexp y)); simpl in |- *; auto with real zarith. apply Rplus_eq_reg_l with (r := FtoR radix y); auto with real. Qed. Theorem Feq_bool_correct_f : forall x y : float, Feq_bool x y = false -> ~ Feq x y. intros x y H'; Contradict H'. rewrite Feq_bool_correct_r; auto with arith. red in |- *; intros H'0; discriminate. Qed. Definition Flt_bool (x y : float) := match Fcompare x y with | Lt => true | _ => false end. Theorem Flt_bool_correct_t : forall x y : float, Flt_bool x y = true -> Flt x y. intros x y H'; red in |- *. apply Rplus_lt_reg_r with (r := (- y)%R). repeat rewrite (Rplus_comm (- y)). rewrite Rplus_opp_r. change (x - y < 0)%R in |- *. rewrite <- Fdiff_correct. replace 0%R with (powerRZ radix (Zmin (Fexp x) (Fexp y)) * 0)%R; auto with real arith. rewrite (Rmult_comm (Fdiff x y)). apply Rmult_lt_compat_l; auto with real zarith. replace 0%R with (IZR 0); auto with real arith. apply Rlt_IZR; red in |- *. generalize H'; unfold Flt_bool, Fcompare in |- *. case (Fdiff x y ?= 0)%Z; auto; intros; try discriminate. Qed. Theorem Flt_bool_correct_r : forall x y : float, Flt x y -> Flt_bool x y = true. intros x y H'. cut (0 < y - x)%R; auto with arith. 2: apply Rplus_lt_reg_l with (r := FtoRradix x); rewrite Rplus_0_r; rewrite Rplus_minus; auto with real. intros H'0. cut (Fdiff x y < 0)%R; auto with arith. intros H'1. cut (Fdiff x y < 0)%Z; auto with zarith. intros H'2; generalize (Zlt_compare _ _ H'2); unfold Flt_bool, Fcompare, Zcompare in |- *; case (Fdiff x y); auto with arith; intros; contradiction. apply lt_IZR; auto with arith. apply (Rlt_monotony_contra_exp radix) with (z := Zmin (Fexp x) (Fexp y)); auto with arith real; rewrite Rmult_0_l. rewrite Fdiff_correct; auto with real. Qed. Theorem Flt_bool_correct_f : forall x y : float, Flt_bool x y = false -> Fle y x. 
- intros t'; case t'. + inversion 1. + intros z0 i0 H0; intro t'';case t''. * inversion 1. * intros z1 i1 H1; inversion_clear H1. constructor 2. inversion_clear H0;eauto with zarith. inversion_clear H0. intro i2; case (H4 i2). intros x H5; generalize (H i2 _ H5); intro H6. case (H3 x);intros x0 Hx0. exists x0;auto. Qed.Inductive itree_le' : itree-> itree -> Prop := | le_leaf' : forall t, itree_le' ileaf t | le_node' : forall l l' s s' g, Z.le l l' -> (forall i, itree_le' (s i) (s' (g i))) -> itree_le' (inode l s) (inode l' s'). Lemma t1_le_t2 : itree_le t1 t2. Proof. unfold t1, t2; constructor; auto with zarith. intro i; exists (2 * i); unfold isingle; constructor. - auto with zarith. - exists i;constructor. Qed. Lemma t1_le'_t2 : itree_le' t1 t2. Proof. unfold t1, t2; constructor 2 with (fun i : nat => 2 * i); auto with zarith. unfold isingle; intro i ; constructor 2 with (fun i :nat => i); auto with zarith. constructor . Qed. Require Import List.Inductive ltree (A:Set) : Set := lnode : A -> list (ltree A) -> ltree A.Inductive prop : Prop := prop_intro : Prop -> prop.Lemma prop_inject: prop. Proof prop_intro prop. Inductive ex_Prop (P : Prop -> Prop) : Prop := exP_intro : forall X : Prop, P X -> ex_Prop P.Lemma ex_Prop_inhabitant : ex_Prop (fun P => P -> P). Proof. now exists (ex_Prop (fun P => P -> P)). Qed. Inductive ex_Set (P : Set -> Prop) : Type := exS_intro : forall X : Set, P X -> ex_Set P. Module Bad. Inductive comes_from_the_left {P Q:Prop} : P \/ Q -> Prop := c1 : forall p, comes_from_the_left (or_introl (A:=P) Q p).Goal comes_from_the_left (or_introl True I). split. Qed.Goal ~ comes_from_the_left (or_intror True I). intro H. Abort.End Bad. Definition comes_from_the_left_sumbool (P Q:Prop)(x:{P}+{Q}): Prop := match x with | left p => True | right q => False end. Close Scope Z_scope. Definition Is_zero (x:nat):= match x with | 0 => True | _ => False end. Lemma O_is_zero : forall m, m = 0 -> Is_zero m. Proof. intros m H; subst m. simpl;trivial. Qed. Theorem S_is_not_O : forall n, S n <> 0. red; intros n Hn. apply O_is_zero with (m := S n). assumption. Qed.Theorem disc2 : forall n, S (S n) <> 1. Proof. intros n Hn; discriminate. Qed. Theorem disc3 : forall n, S (S n) = 0 -> forall Q:Prop, Q. 
: forall (k:nat) (l1 l2 l3 l4: list(nat*nat))(b:bool), update_primes k l1 = (l2, true) -> update_primes k (l3++l1) = (l4, b) -> b=true. Proof. intros k l1 l2 l3; elim l3. - simpl; intros l4 b Heq1; rewrite Heq1; intros Heq2; injection Heq2; auto. - simpl; intros (p,n) l; case (update_primes k (l++l1)). intros l4 b Hrec l4' b'; case (Nat.compare k n). + intros Heq1 Heq2; injection Heq2; auto. + intros Heq1 Heq2; injection Heq2. intros Heq3 Heq4; rewrite <- Heq3; apply Hrec with l4; auto. + intros Heq1 Heq2; injection Heq2. intros Heq3 Heq4; rewrite <- Heq3; apply Hrec with l4; auto. Qed.Theorem update_primes_true_imp_div : forall (k:nat)(l: list (nat*nat)), all_first_less_than k l -> all_multiples l -> all_greater_than_one l -> forall l1, update_primes k l = (l1, true) -> (exists p:nat, 1< p < k /\ (exists q:nat, k = p*q)). Proof. intros k l; elim l. - simpl; intros; discriminate. - intros (p,n) l0 Hrec Haf Ham Hal l1; simpl. case_eq (update_primes k l0). intros l2 b Hup; case_eq (Nat.compare k n). + intros Htwc Heq; generalize (nat_compare_eq _ _ Htwc). intros Hk; exists p; split. * split. unfold all_greater_than_one in Hal; apply Hal with (nil (A:=nat*nat)) l0 n; auto. unfold all_first_less_than in Haf; apply Haf with (nil (A:=nat*nat)) l0 n; auto. * unfold all_multiples in Ham. rewrite Hk; apply Ham with (nil (A:=nat*nat)) l0; auto. + intros Htwc Heq; injection Heq; intros Hb Hl1. * rewrite Hb in Hup; apply Hrec with l2. -- apply all_first_less_than_transmit with (p,n); auto. -- apply all_multiples_transmit with (p,n); auto. -- apply all_greater_than_one_transmit with (p,n); auto. -- auto. + intros Htwc Heq; injection Heq; intros Hb Hl1. rewrite Hb in Hup; apply Hrec with l2. * apply all_first_less_than_transmit with (p,n); auto. * apply all_multiples_transmit with (p,n); auto. * apply all_greater_than_one_transmit with (p,n); auto. * auto. Qed.Theorem interval_eq : forall p q q', p*q'-p < p*q <= p*q' -> q=q'. Proof. intros p; case p. - simpl; intros q q' (Hlt, Hle); elim (lt_irrefl 0);assumption. - intros p' q q' (Hlt, Hle). apply le_antisym. + apply mult_S_le_reg_l with p'; auto. + assert (Hlt' : (q' - 1)*S p' < S p' * q). { rewrite mult_minus_distr_r. rewrite mult_1_l. rewrite (mult_comm q'). assumption. } rewrite (mult_comm (q' - 1)) in Hlt'. generalize (mult_lt_reg_l _ _ _ Hlt'). case q'; simpl. * auto with arith. * intros n; rewrite <- minus_n_O; auto with arith. Qed. Theorem update_primes_false_imp_prime : forall k l l1, 1 < k -> all_multiples l -> all_intervals k l -> all_prime_in_first k l -> update_primes k l = (l1,false) -> prime k. 
Hij w. apply G. intro Hw. elim (Hij _ Hw). induction w; intros i j; simpl lang; rewrite pair.pi1mk, pair.pi2mk. case (v A i); case (v B j); firstorder discriminate. split. intros Hij [HaB Hw]. apply IHw in Hw as []. intro Aw. apply Hij. now split. intros Hw [Ha Aw]. split. apply H, Ha. eapply IHw. 2: eassumption. tauto. Qed.End diff. Section empty_dec.Variables A: t. Definition step: bmx (n A) (n A) := fun i j => \sup_(a\in vars A) eqb_ord (M A i a) j. Definition steps := (@str bmx _ step). Variable i: ord (n A). Lemma steps_refl: steps i i. Proof. apply bmx_str_clot. constructor. Qed.Lemma steps_snoc: forall j a, steps i j -> In a (vars A) -> steps i (M A j a). Proof. setoid_rewrite bmx_str_clot. intros. eapply clot_snoc. eassumption. setoid_rewrite is_true_sup. eexists. split. eassumption. apply eqb_refl. Qed. Fixpoint Ms i w := match w with nil => i | cons a w => Ms (M A i a) w end. Lemma steps_least: forall j, steps i j -> exists w, w ≦ vars A /\ j = Ms i w. Proof. intros j H. apply bmx_str_clot in H. induction H as [i|i j k Hij _ [w [Hw ->]]]. exists nil. split. lattice. reflexivity. setoid_rewrite is_true_sup in Hij. destruct Hij as [a [Ha Hij]]. exists (a::w). split. intros b [<-|Hb]. assumption. now apply Hw. revert Hij. case eqb_ord_spec. 2: discriminate. now intros <-. Qed. Definition empty := \inf_(j<_) (steps i j <<< !v A j). Lemma empty_lang1 j: steps i j -> empty -> lang A j ≦ bot. Proof. intros Hj He. setoid_rewrite is_true_inf in He. setoid_rewrite le_bool_spec in He. pose proof (fun i => He i (ordinal.in_seq _)) as H. clear He. intro w. revert j Hj. induction w as [|a w IH]; simpl lang; intros j Hj. apply (H j), negb_spec in Hj. rewrite Hj. discriminate. intros [Ha Hj']. apply IH in Hj' as []. now apply steps_snoc. Qed. Lemma empty_lang2: lang A i ≦ bot -> empty. Proof. intro H. setoid_rewrite is_true_inf. intros j _. rewrite le_bool_spec. intro Hj. apply steps_least in Hj as [w [Hw ->]]. generalize i (H w) Hw. clear. induction w; intros i Hi Hw. simpl in *. destruct (v A i). now elim Hi. reflexivity. apply IHw. intro H. elim Hi. split. apply Hw. now left. assumption. intros ? ?. apply Hw. now right. Qed. Theorem empty_dec: {lang A i ≦ bot} + {~ (lang A i ≦ bot)}. 
ν l : dp_eval φ ν (dee2dp_1 l) = dp_eval φ ν (dee2dp_2 l) <-> Forall (dc_eval φ ν) l. Proof. rewrite dee2dp_1_eval, dee2dp_2_eval. destruct (list_fun_inv l (0,dee_nat 0)) as (f & Hf). rewrite Hf at 1 2. do 2 rewrite map_map. do 2 rewrite <- sum_fold_map. unfold dc_value_1, dc_value_2. rewrite convex_n_eq. unfold dc_eval. apply Forall_forall_map with (P := fun i => φ (fst i) = dee_eval φ ν (snd i)); auto. Qed. Theorem dio_elem_single l : { E : dio_single nat nat | dio_single_size E <= 2+20*length l /\ forall ν φ, dp_eval φ ν (fst E) = dp_eval φ ν (snd E) <-> Forall (dc_eval φ ν) l }. Proof. exists (dee2dp_1 l,dee2dp_2 l); split. + unfold dio_single_size, fst, snd. generalize (dee2dp_1_size l) (dee2dp_2_size l); intros; lia. + unfold dio_single_pred, fst, snd; split; apply dee2dp_spec. Defined. Theorem dio_elem_equation l : { E : dio_single nat nat | dio_single_size E <= 2+20*length l /\ forall ν, dio_single_pred E ν <-> exists φ, Forall (dc_eval φ ν) l }. Proof. destruct (dio_elem_single l) as (p & H1 & H2); exists p; split; auto. split; intros (phi & H); exists phi; revert H; apply H2. Defined.End dio_elem_dio_poly.Corollary dio_rel_single R : 𝔻R R -> { E : dio_single nat nat | forall ν, R ν <-> dio_single_pred E ν}. Proof. intros (A & HA). destruct dio_formula_elem with (f := A) as (l & _ & _ & Hl). destruct dio_elem_equation with (l := l) as (E & _ & HE). exists E; intro; rewrite HE, <- Hl, HA; tauto. Qed.Section dio_poly_pos. Variable P : Set. Implicit Type (p : dio_polynomial nat P). Definition dio_poly_pos m p : (forall x, In x (dp_var_list p) -> x < m) -> { q | forall φ ν, dp_eval φ ν p = dp_eval (vec_pos (fun2vec 0 m φ)) ν q }. Proof. induction p as [ n | v | i | o p Hp q Hq ]; intros H. + exists (dp_nat n); auto. + specialize (H v); spec in H; simpl; auto. exists (dp_var (nat2pos H)); intros phi psi; simpl. rewrite vec_pos_fun2vec, pos2nat_nat2pos; auto. + exists (dp_par i); auto. + simpl in H. destruct Hp as (p1 & H1). { intros; apply H, in_or_app; auto. } destruct Hq as (q1 & H2). { intros; apply H, in_or_app; auto. } exists (dp_comp o p1 q1); intros phi psi; simpl. destruct o; f_equal; auto. Qed. Theorem dio_poly_eq_pos (e : dio_single nat P) : { m : nat & { p' : dio_polynomial (pos m) P & { q' | forall ν, dio_single_pred e ν <-> dio_single_pred (p',q') ν } } }. 
arith pts. Qed. Hint Resolve bd_app_list_ctxt: pts. Lemma bd_whnf_rec : forall (e : env) (t : term) (args : list term), sn (ctxt beta_delta) e (app_list args t) -> {u : term | red beta_delta e (app_list args t) u & head_normal beta_delta e u}. intros. pattern e, t, args in |- *. apply (Acc3_rec (R:=whnf_bd_ord)). clear H e t args. intros e t args. case t; intros. exists (app_list args (Srt s)); auto with arith pts. apply whnf_bd_app_list; simpl in |- *; intros; auto with arith pts. discriminate.elim delta_reduce with n e; intros. inversion_clear a. elim H with e x args; intros; auto with arith pts. exists x0; auto with arith pts. apply red_trans with (app_list args x); auto with arith pts. red in |- *; red in |- *. apply rt_step. apply bd_app_list_ctxt. apply ctx_rule. right; auto with arith pts.red in |- *; simpl in |- *. left. apply Rex_intro. apply bd_app_list_ctxt. apply ctx_rule. right; auto with arith pts.exists (app_list args (Ref n)); auto with arith pts. apply whnf_bd_app_list; simpl in |- *; intros; auto with arith pts. elim delta_reduce with n e; intros. inversion_clear a. elim b with x; auto with arith pts.auto with arith pts.discriminate.generalize H. case args; simpl in |- *; intros. exists (Abs t0 t1); simpl in |- *; auto with arith pts. apply whnf_bd_head_normal; auto with arith pts.simpl in |- *; auto with arith pts. elim H0 with e (subst t2 t1) l; simpl in |- *; intros; auto with arith pts. exists x; auto with arith pts. apply red_trans with (app_list l (subst t2 t1)); auto with arith pts. red in |- *; red in |- *. apply rt_step. apply bd_app_list_ctxt. apply ctx_rule; left; auto with arith pts.red in |- *; simpl in |- *. left. apply Rex_intro. apply bd_app_list_ctxt. apply ctx_rule; left; auto with arith pts.elim H with e t0 (t1 :: args); intros; auto with arith pts. exists x; auto with arith pts.red in |- *; simpl in |- *; right; auto with arith pts.exists (app_list args (Prod t0 t1)); simpl in |- *; auto with arith pts. apply whnf_bd_app_list; simpl in |- *; intros; auto with arith pts. discriminate.apply Acc_Acc3. unfold whnf_bd_ord in |- *. apply (Acc_inverse_image approx {x_ : value & value}). simpl in |- *. apply acc_A_B_lexprod; intros. elim H; intros. apply Acc_intro; intros; auto with arith pts. inversion_clear H2; auto with arith pts.exact wf_subterm.apply wf_subterm. Qed. Theorem beta_delta_whnf : forall (e : env) (t : term), sn (ctxt beta_delta) e t -> {u : term | red beta_delta e t u & head_normal beta_delta e u}. 
a i * f i) + ∑ n (fun i => b i * f i). Proof. rewrite <- msum_sum; auto. + apply msum_ext; intros; ring. + intros; ring. Qed.Section power_decomp. Variable (p : nat) (Hp : 2 <= p). Let power_nzero x : power x p <> 0. Proof. generalize (@power_ge_1 x p); omega. Qed. Fact power_decomp_lt n f a q : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> f i < q) -> (forall i, i < n -> a i < p) -> ∑ n (fun i => a i * power (f i) p) < power q p. Proof. revert q; induction n as [ | n IHn ]; intros q Hf1 Hf2 Ha. + rewrite msum_0; apply power_ge_1; omega. + rewrite msum_plus1; auto. apply lt_le_trans with (1*power (f n) p + a n * power (f n) p). * apply plus_lt_le_compat; auto. rewrite Nat.mul_1_l. apply IHn. - intros; apply Hf1; omega. - intros; apply Hf1; omega. - intros; apply Ha; omega. * rewrite <- Nat.mul_add_distr_r. replace q with (S (q-1)). - rewrite power_S; apply mult_le_compat; auto. ++ apply Ha; auto. ++ apply power_mono_l; try omega. generalize (Hf2 n); intros; omega. - generalize (Hf2 0); intros; omega. Qed. Lemma power_decomp_is_digit n a f : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> forall i, i < n -> is_digit (∑ n (fun i => a i * power (f i) p)) p (f i) (a i). Proof. intros Hf Ha. induction n as [ | n IHn ]; intros i Hi. + omega. + split; auto. exists (∑ (n-i) (fun j => a (S i + j) * power (f (S i+j) - f i - 1) p)), (∑ i (fun j => a j * power (f j) p)); split. - replace (S n) with (S i + (n-i)) by omega. rewrite msum_plus, msum_plus1; auto. rewrite <- plus_assoc, plus_comm; f_equal. rewrite Nat.mul_add_distr_r, plus_comm; f_equal. rewrite <- mult_assoc, mult_comm, <- sum_0n_scal_l. apply msum_ext. intros j Hj. rewrite (mult_comm (_ * _)); repeat rewrite <- mult_assoc; f_equal. rewrite <- power_S, <- power_plus; f_equal. generalize (Hf i (S i+j)); intros; omega. - apply power_decomp_lt; auto. * intros; apply Hf; omega. * intros; apply Ha; omega. Qed. Theorem power_decomp_unique n f a b : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> (forall i, i < n -> b i < p) -> ∑ n (fun i => a i * power (f i) p) = ∑ n (fun i => b i * power (f i) p) -> forall i, i < n -> a i = b i. 
Require Import Coq.omega.Omega. Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Util. Require Import Coq.Arith.Arith Coq.Lists.List.Set Implicit Arguments.Local Hint Extern 1 (himp _ (allocated _ _ _) (allocated _ _ _)) => apply allocated_shift_base. Definition noWrapAround (p : W) (sz : nat) := forall n, (n < 4 * sz)%nat -> p ^+ $ (n) <> $0.Definition freeable (p : W) (sz : nat) := (sz >= 2)%nat /\ noWrapAround p sz.Lemma BigEnough : forall p sz, freeable p sz -> (sz >= 2)%nat. unfold freeable; tauto. Qed.Lemma SmallEnough : forall p sz, freeable p sz -> noWrapAround p sz. unfold freeable; tauto. Qed.Local Hint Immediate BigEnough SmallEnough. Local Hint Unfold freeable.Module Type FREE_LIST. Parameter freeList : nat -> W -> HProp. Parameter mallocHeap : W -> HProp. Axiom freeList_extensional : forall n p, HProp_extensional (freeList n p). Axiom mallocHeap_extensional : forall p, HProp_extensional (mallocHeap p). Axiom mallocHeap_fwd : forall p, mallocHeap p ===> Ex n, Ex p', p =*> p' * freeList n p'. Axiom mallocHeap_bwd : forall p, (Ex n, Ex p', p =*> p' * freeList n p') ===> mallocHeap p. Axiom nil_bwd : forall n p, p = 0 -> [| n = 0 |] ===> freeList n p. Axiom cons_bwd : forall n (p : W), p <> 0 -> (Ex n', Ex sz, Ex p', [| n = S n' |] * [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p') ===> freeList n p. Axiom cons_fwd : forall n (p : W), p <> 0 -> freeList n p ===> Ex n', Ex sz, Ex p', [| n = S n' |] * [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p'. End FREE_LIST.Module FreeList : FREE_LIST. Open Scope Sep_scope. Fixpoint freeList (n : nat) (p : W) : HProp := match n with | O => [| p = 0 |] | S n' => [| p <> 0 |] * Ex sz, Ex p', [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p' end. Definition mallocHeap (p : W) := Ex n, Ex p', p =*> p' * freeList n p'. Theorem freeList_extensional : forall n p, HProp_extensional (freeList n p). 
L6.stemctx L6.shrink_cps_correct L6.shrink_cps_corresp L6.inline_letapp L6.algebra L6.Ensembles_util L6.rel_comp L6.functions. Section Srink_top_correct. Variable pr : prims. Variable cenv : ctor_env. Context {fuel : Type} {Hfuel : @fuel_resource fuel} {trace : Type} {Htrace : @trace_resource trace}. Variable (P1 : nat -> @PostT fuel trace) (PG : @PostGT fuel trace) (HPost : forall n, n <= 1 -> Post_properties cenv (P1 n) (P1 n) PG) (HPost' : Post_properties cenv PG PG PG) (Hless_steps_app : forall f ft ys rho1 e2 rho2, post_Eapp_l (P1 0) (P1 1) f ft ys rho1 e2 rho2) (Hless_steps_letapp : remove_steps_letapp cenv (P1 0) (P1 0) (P1 1)) (Hless_steps_letapp_OOT : remove_steps_letapp_OOT cenv (P1 0) (P1 1)). Context (Hless_steps_ctx : forall C e1 rho1 (rho1' : env) (e2 : exp) (rho2 : env) (cin1 cin2 : fuel) (cout1 cout2 : trace), ctx_to_rho C rho1 rho1' -> len_exp_ctx C = 1 -> P1 0 (e1, rho1', cin1, cout1) (e2, rho2, cin2, cout2) -> P1 1 (C |[ e1 ]|, rho1, cin1 <+> one (C |[ e1 ]|), cout1 <+> one (C |[ e1 ]|)) (e2, rho2, cin2, cout2)). Context (Hless_steps_case : forall x cl t e n rho1 rho2 cin1 cout1 cin2 cout2, find_tag_nth cl t e n -> P1 0 (e, rho1, cin1, cout1) (e, rho2, cin2, cout2) -> P1 1 (Ecase x cl, rho1, cin1 <+> one (Ecase x cl), cout1 <+> one (Ecase x cl)) (e, rho2, cin2, cout2)). Context (Hubound1 : post_upper_bound (P1 1)) (Hubound2 : post_upper_bound PG). Definition well_scoped e := unique_bindings e /\ Disjoint _ (bound_var e) (occurs_free e). Definition wf_pres e1 e2 := occurs_free e2 \subset occurs_free e1. Definition post_prop P1 PG := Post_properties cenv P1 P1 PG /\ post_upper_bound P1. Theorem gsr_clos_unwrap : forall s f t xs e e', gsr_clos s (Efun (Fcons f t xs e Fnil) (Ehalt f)) e' -> exists e'', e' = (Efun (Fcons f t xs e'' Fnil) (Ehalt f)) /\ gsr_clos s e e''. Proof. intros s f t xs e e' H. assert (Heq : Efun (Fcons f t xs e Fnil) (Ehalt f) = Efun (Fcons f t xs e Fnil) (Ehalt f)). reflexivity. revert H Heq. generalize (Efun (Fcons f t xs e Fnil) (Ehalt f)) at 1 3. intros e0 H. revert f t xs e. induction H. + intros. subst. eapply sr_unwrap_halt in H. destructAll. edestruct IHgsr_clos. reflexivity. destructAll. eexists. split; eauto. econstructor; eassumption. + intros. subst. eexists. split; eauto. constructor. Qed. Theorem shrink_corresp_top e: unique_bindings e -> Disjoint var (bound_var e) (occurs_free e) -> let (e', n) := shrink_top e in (exists m, m >= n /\ preord_exp_n cenv wf_pres post_prop m e e') /\ unique_bindings e' /\ Disjoint _ (occurs_free e') (bound_var e') /\ occurs_free e' \subset occurs_free e /\ bound_var e' \subset bound_var e. 
subst. - edestruct IHRunsTo1 as [IHRunsTo1' ?]; eauto. edestruct IHRunsTo1' as [s_st' [Hsst' Heq']]; eauto. edestruct IHRunsTo2 as [IHRunsTo2' ?]; eauto. edestruct (IHRunsTo2' (While e s)) as [s_st'' [Hsst'' Heq'']]; try eapply Heq'; eauto. exists s_st''; split. + eapply RunsToWhileTrue; eauto. + eauto. - rename H5 into He. eapply is_false_equiv in He; eauto. exfalso; eapply is_true_is_false; eauto. } { inject Hcomp. eapply is_syntax_ok_while_elim in Hsyn. destruct Hsyn as [Hsyne Hsynb]. inversion Hsf; unfold_all; subst. - rename H2 into He. eapply is_true_equiv in He; eauto. exfalso; eapply is_true_is_false; eauto. - exists s_st; split. + eapply RunsToWhileFalse; eauto. + eauto. } { inject Hcomp. rename s into x. rename H into He. rename H0 into Hnadt. rename H1 into Hst'. eapply is_syntax_ok_assign_elim in Hsyn. destruct Hsyn as [Hsynx Hsyne]. erewrite <- eval_equiv in He by eauto. erewrite <- not_mapsto_adt_equiv in Hnadt by eauto. exists (add x (SCA w) s_st); split. - eapply RunsToAssign; eauto. - rewrite Hst'. eapply add_equiv; eauto. } { unfold_all. intros x' f' args' f_w' spec' input' t_callee_st' ret' Heq Hfw Hspec Hmm Hsfb Hrtb Hret Hnadt Hst''2. inject Heq. unif (@SCA ADTValue f_w'). rename H1 into Hspec'. rewrite Hspec' in Hspec. discriminate. } { unfold_all. intros x' f' args' f_w' spec' input' t_callee_st' ret' Heq Hfw Hspec Hmm Hsfb Hrtb Hret' Hnadt Hst''2. inject Heq. unif (@SCA ADTValue f_w'). rename H1 into Hspec'. rewrite Hspec in Hspec'. rename H6 into Hret. inject Hspec'. unif input'. destruct spec'; simpl in *. edestruct IHRunsTo as [IHRunsTo' trash]; eauto. edestruct IHRunsTo' as [s_callee_st' [Hstb Hscst']]; eauto. { eapply equiv_refl. eapply args_name_ok_make_map; eauto. } rename H8 into Hst''. rewrite Hst'' in Hst''2. eapply add_add_remove_many_eq_elim in Hst''2; eauto; try (rewrite map_length; eauto). destruct Hst''2 as [Hreteq Houteq]. exists s_callee_st'. repeat try_split; eauto. { rewrite (map_find_equiv s_callee_st' callee_st') by eauto. eauto. } { unfold sel in *. rewrite (find_equiv s_callee_st' callee_st') by eauto. rewrite Hret. rewrite Hret'. rewrite Hreteq. eauto. } { Arguments no_adt_leak_equiv st1 st2 [_] _ _ _ _ _ _ _. eapply (no_adt_leak_equiv _ callee_st'); eauto. } } Qed. Theorem compile_runsto t t_env t_st t_st' : FRunsTo t_env t t_st t_st' -> forall s_env, fenv_impls_env t_env s_env -> (forall s, t = compile s -> is_syntax_ok s = true -> forall s_st, Safe s_env s s_st -> s_st === t_st -> exists s_st', RunsTo s_env s s_st s_st' /\ s_st' === t_st'). Proof. intros; eapply compile_runsto'; eauto. Qed. Require Import Bedrock.Platform.Facade.SafeCoind. Theorem compile_safe s_env s s_st : Safe s_env s s_st -> is_syntax_ok s = true -> forall t_env t_st, fenv_impls_env t_env s_env -> s_st === t_st -> let t := compile s in FSafe t_env t t_st. 
. apply idpath . apply ( gradth _ _ egf efg ) . Defined . Theorem isofhlevelsnweqtohlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq X Y ) . Proof . intros . apply ( isofhlevelsninclb n _ ( isinclpr1weq _ _ ) ) . apply impred . intro . apply is . Defined . Theorem isofhlevelsnweqfromhlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq Y X ) . Proof. intros . apply ( isofhlevelweqf ( S n ) ( weqinvweq X Y ) ( isofhlevelsnweqtohlevelsn n X Y is ) ) . Defined . Theorem isapropweqtocontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqfromcontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqtoprop ( X Y : UU ) ( is : isaprop Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ is ) . Defined . Theorem isapropweqfromprop ( X Y : UU )( is : isaprop Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ is ) . Defined . Theorem isasetweqtoset ( X Y : UU ) ( is : isaset Y ) : isaset ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 1 _ _ is ) . Defined . Theorem isasetweqfromset ( X Y : UU )( is : isaset Y ) : isaset ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 1 X _ is ) . Defined . Theorem isapropweqtoempty ( X : UU ) : isaprop ( weq X empty ) . Proof . intro . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropempty ) ) . Defined . Theorem isapropweqtoempty2 ( X : UU ) { Y : UU } ( is : neg Y ) : isaprop ( weq X Y ) . 
=> apply reset_ok : prog. Hint Extern 0 (okToUnify (rep _ _ _ _ _) (rep _ _ _ _ _)) => constructor : okToUnify. Lemma inode_match_sm_sync_invariant: forall bxp x y, inode_match bxp x y <=p=> (inode_match bxp x y * [[ SyncedMem.sm_sync_invariant (snd x) ]])%pred. Proof. intros. unfold inode_match. destruct x. split. intros m H'. destruct_lifts. pred_apply. cancel. eapply Ind.rep_IFs_sync_invariant with (m := m). pred_apply. cancel. cancel. Qed. Lemma rep_IFs_sync_invariant: forall bxp IFs ixp ilist icache m F, (F * INODE.rep bxp IFs ixp ilist icache)%pred m -> SyncedMem.sm_sync_invariant IFs. Proof. unfold INODE.rep. intros. destruct_lifts. rewrite SyncedMem.sm_sync_invariant_piff by eauto. eapply Ind.sm_sync_invariant_pred_fold_left. rewrite listmatch_lift_l in H. destruct_lifts. erewrite <- Forall_combine_r; try eassumption. split; intro H'; exact H'. eassign (fun x y => inode_match bxp x y). intros. rewrite inode_match_sm_sync_invariant. destruct x; cbn. split; cancel. Qed. Lemma inode_rep_bn_valid_piff : forall bxp IFs xp l c, rep bxp IFs xp l c <=p=> rep bxp IFs xp l c * [[ forall inum, inum < length l -> Forall (fun a => BALLOCC.bn_valid bxp (# a) ) (IBlocks (selN l inum inode0)) ]]. Proof. intros; split; unfold pimpl; intros; pred_apply; unfold rep in H; destruct_lift H; cancel. extract at inum. unfold inode_match in H. erewrite selN_combine in * by auto. destruct_lifts; eauto. Unshelve. all: eauto. Qed. Lemma inode_rep_bn_nonzero_pimpl : forall bxp IFs xp l c, rep bxp IFs xp l c =p=> rep bxp IFs xp l c * [[ forall inum off, inum < length l -> off < length (IBlocks (selN l inum inode0)) -> # (selN (IBlocks (selN l inum inode0)) off $0) <> 0 ]]. Proof. intros. setoid_rewrite inode_rep_bn_valid_piff at 1; cancel. specialize (H1 _ H). rewrite Forall_forall in H1. eapply H1; eauto. apply in_selN; eauto. Qed. Lemma crash_xform_inode_match : forall xp a b, crash_xform (inode_match xp a b) <=p=> inode_match xp a b. Proof. unfold inode_match; split. xform_norm. rewrite Ind.xform_rep; cancel. cancel. xform_normr. rewrite Ind.xform_rep; cancel. Qed. Lemma listmatch_inode_match_sm_sync_invariant: forall bxp inodes lfs l, length inodes = length lfs -> listmatch (inode_match bxp) (combine inodes lfs) l =p=> listmatch (inode_match bxp) (combine inodes lfs) l * [[ sm_sync_invariant (pred_fold_left lfs) ]]. Proof. intros. intros m H'. pred_apply; cancel. eapply Ind.sm_sync_invariant_pred_fold_left. eapply listmatch_lift_l with (P := fun x => sm_sync_invariant (snd x)) in H'. destruct_lifts. eapply Forall_combine_r; eauto. intuition. eassign (fun x y => inode_match bxp x y). intro x. destruct x. intros. rewrite inode_match_sm_sync_invariant. split; cancel. Qed. Theorem xform_rep : forall bxp Fs xp l c, crash_xform (rep bxp Fs xp l c) <=p=> rep bxp Fs xp l c * [[ sm_sync_invariant Fs ]]. 
<= if ?P then _ else _)%Z => destruct P; subst; simpl in * end. ++ assert (th2: forall x, (x = 0)%Z -> (x <= 1)%Z) by (intros; Omega.omega). apply th2; clear th2. eapply NoSelfCallMeth_Impl; eauto. ++ apply th1; clear th1. eapply NoSelfCallMeth_Impl; eauto. * split; auto. split; auto. unfold WeakInclusion; simpl; intros. split; intros; auto. Qed. End SimulationGen. Section SimulationGen_new. Variable imp spec: BaseModuleWf_new type. Variable NoSelfCalls: NoSelfCallBaseModule spec. Variable simRel: RegsT -> RegsT -> Prop. Variable simRelGood: forall oImp oSpec, simRel oImp oSpec -> getKindAttr oSpec = getKindAttr (getRegisters spec). Variable initRel: forall rimp, Forall2 regInit rimp (getRegisters imp) -> exists rspec, Forall2 regInit rspec (getRegisters spec) /\ simRel rimp rspec. Variable simulationRule: forall oImp rImp uImp rleImp csImp oImp' aImp, In (rleImp, aImp) (getRules imp) -> SemAction oImp (aImp type) rImp uImp csImp WO -> UpdRegs [uImp] oImp oImp' -> forall oSpec, simRel oImp oSpec -> ((simRel oImp' oSpec /\ csImp = []) \/ (exists rleSpec aSpec, In (rleSpec, aSpec) (getRules spec) /\ exists rSpec uSpec, SemAction oSpec (aSpec type) rSpec uSpec csImp WO /\ exists oSpec', UpdRegs [uSpec] oSpec oSpec' /\ simRel oImp' oSpec')). Variable simulationMeth: forall oImp rImp uImp meth csImp oImp' sign aImp arg ret, In (meth, existT _ sign aImp) (getMethods imp) -> SemAction oImp (aImp type arg) rImp uImp csImp ret -> UpdRegs [uImp] oImp oImp' -> forall oSpec, simRel oImp oSpec -> exists aSpec rSpec uSpec, In (meth, existT _ sign aSpec) (getMethods spec) /\ SemAction oSpec (aSpec type arg) rSpec uSpec csImp ret /\ exists oSpec', UpdRegs [uSpec] oSpec oSpec' /\ simRel oImp' oSpec'. Variable notMethMeth: forall oImp rImpl1 uImpl1 meth1 sign1 aImp1 arg1 ret1 csImp1 rImpl2 uImpl2 meth2 sign2 aImp2 arg2 ret2 csImp2, In (meth1, existT _ sign1 aImp1) (getMethods imp) -> SemAction oImp (aImp1 type arg1) rImpl1 uImpl1 csImp1 ret1 -> In (meth2, existT _ sign2 aImp2) (getMethods imp) -> SemAction oImp (aImp2 type arg2) rImpl2 uImpl2 csImp2 ret2 -> exists k, In k (map fst uImpl1) /\ In k (map fst uImpl2). Variable notRuleMeth: forall oImp rImpl1 uImpl1 rleImpl1 aImp1 csImp1 rImpl2 uImpl2 meth2 sign2 aImp2 arg2 ret2 csImp2, In (rleImpl1, aImp1) (getRules imp) -> SemAction oImp (aImp1 type) rImpl1 uImpl1 csImp1 WO -> In (meth2, existT _ sign2 aImp2) (getMethods imp) -> SemAction oImp (aImp2 type arg2) rImpl2 uImpl2 csImp2 ret2 -> exists k, In k (map fst uImpl1) /\ In k (map fst uImpl2). Theorem simulationGen_new : TraceInclusion (Base imp) (Base spec). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import hmacfcf.HMAC_spec. Require Import FCF.PRF. Require Import hmacfcf.NMAC_to_HMAC. Require Import hmacfcf.hF. Require Import hmacfcf.GHMAC_PRF.Section HMAC_PRF. Variable c p : nat. Definition b := @b c p. Variable h : Bvector c -> Bvector b -> Bvector c. Variable iv : Bvector c. Variable Message : Set. Hypothesis Message_EqDec : EqDec Message. Variable splitAndPad : Message -> list (Bvector b). Hypothesis splitAndPad_1_1 : forall b1 b2, splitAndPad b1 = splitAndPad b2 -> b1 = b2. Variable fpad : Bvector c -> Bvector p. Definition h_star_pad := h_star_pad h fpad. Variable opad ipad : Bvector b. Hypothesis opad_ne_ipad : opad <> ipad. Section h_star_WCR. Definition h_star := h_star _ h. Variable Z : OracleComp (list (Bvector (HMAC_spec.b c p))) (Bvector (HMAC_spec.b c p)) (list (Bvector (HMAC_spec.b c p)) * list (Bvector (HMAC_spec.b c p))). Definition Y : OracleComp (list (Bvector (HMAC_spec.b c p))) (Bvector c) (list (Bvector (HMAC_spec.b c p)) * list (Bvector (HMAC_spec.b c p))) := [x, _] <--$2 OC_Run _ _ _ Z (fun _ d => r <--$ OC_Query _ d; $ ret ((app_fpad fpad r), tt)) tt; $ ret x. Theorem Vector_append_inj_first : forall (A : Set)(a : nat)(a1 a2 : Vector.t A a)(b : nat)(b1 b2 : Vector.t A b), Vector.append a1 b1 = Vector.append a2 b2 -> a1 = a2. 
auto with zarith. rewrite <- (inject_nat_convert (Zpos m') m'); auto with zarith. rewrite <- (inject_nat_convert (Zpos n') n'); auto with zarith. rewrite Zabs_Zopp. rewrite inj_oZ1; rewrite Zabs_eq; auto with zarith. rewrite <- (inject_nat_convert (Zpos n') n'); auto with zarith. Qed. Theorem ZquotientPos : forall z1 z2 : Z, (0 <= z1)%Z -> (0 <= z2)%Z -> (0 <= Zquotient z1 z2)%Z. intros z1 z2 H H0; case (Z_eq_dec z2 0); intros Z1. rewrite Z1; red in |- *; case z1; simpl in |- *; auto; intros; red in |- *; intros; discriminate. case (ZquotientProp z1 z2); auto; intros r (H1, (H2, H3)). case (Zle_or_lt 0 (Zquotient z1 z2)); auto; intros Z2. Contradict H3; apply Zle_not_lt. replace r with (z1 - Zquotient z1 z2 * z2)%Z; [ idtac | pattern z1 at 1 in |- *; rewrite H1; ring ]. repeat rewrite Zabs_eq; auto. pattern z2 at 1 in |- *; replace z2 with (0 + 1 * z2)%Z; [ idtac | ring ]. unfold Zminus in |- *; apply Zle_trans with (z1 + 1 * z2)%Z; auto with zarith. apply Zplus_le_compat_l. rewrite Zopp_mult_distr_l. apply Zle_Zmult_comp_r; auto with zarith. unfold Zminus in |- *; rewrite Zopp_mult_distr_l; auto with zarith. Qed. Definition Zdivides (n m : Z) := exists q : Z, n = (m * q)%Z. Theorem ZdividesZquotient : forall n m : Z, m <> 0%Z -> Zdivides n m -> n = (Zquotient n m * m)%Z. intros n m H' H'0. case H'0; intros z1 Hz1. case (ZquotientProp n m); auto; intros z2 (Hz2, (Hz3, Hz4)). cut (z2 = 0%Z); [ intros H1; pattern n at 1 in |- *; rewrite Hz2; rewrite H1; ring | idtac ]. cut (z2 = ((z1 - Zquotient n m) * m)%Z); [ intros H2 | idtac ]. case (Z_eq_dec (z1 - Zquotient n m) 0); intros H3. rewrite H2; rewrite H3; ring. Contradict Hz4. replace (Zabs m) with (1 * Zabs m)%Z; [ idtac | ring ]. apply Zle_not_lt; rewrite H2. rewrite Zabs_Zmult; apply Zle_Zmult_comp_r; auto with zarith. generalize H3; case (z1 - Zquotient n m)%Z; try (intros H1; case H1; auto; fail); simpl in |- *; intros p; case p; simpl in |- *; auto; intros; red in |- *; simpl in |- *; auto; red in |- *; intros; discriminate. rewrite Zmult_minus_distr_r; rewrite (Zmult_comm z1); rewrite <- Hz1; (pattern n at 1 in |- *; rewrite Hz2); ring. Qed. Theorem ZdividesZquotientInv : forall n m : Z, n = (Zquotient n m * m)%Z -> Zdivides n m. 
Require Export NBase.Module NAddProp (Import N : NAxiomsMiniSig'). Include NBaseProp N. Theorem eq_add_0 : forall n m, n + m == 0 <-> n == 0 /\ m == 0. 
(TreeFile n b) = None. Proof. intros. rewrite cons_app. rewrite find_subtree_app_none; eauto. Qed. Lemma find_subtree_file_dir_exfalso: forall pn n f d e, find_subtree pn (TreeFile n f) = Some (TreeDir d e) -> False. Proof. intros. destruct pn. simpl in *; try congruence. rewrite find_subtree_file_none in H. try congruence. Qed. Theorem find_subtree_graft_subtree_oob: forall pn num ents base name tree subtree inum f, find_subtree base tree = Some (TreeDir num ents) -> (~ pathname_prefix (base ++ [name]) pn) -> find_subtree pn tree = Some (TreeFile inum f) -> find_subtree pn (tree_graft num ents base name subtree tree) = Some (TreeFile inum f). Proof. unfold tree_graft; intros. destruct (pathname_decide_prefix base pn). - deex. erewrite find_subtree_app in H1 by eassumption. erewrite find_subtree_app. 2: erewrite find_update_subtree; eauto. clear H. induction ents; simpl in *. + destruct suffix; simpl in *; congruence. + destruct suffix; simpl in *; try congruence. destruct a; simpl in *. destruct (string_dec s0 s); subst. * destruct (string_dec s name); subst. -- exfalso. apply H0. eexists; rewrite <- app_assoc; simpl; eauto. -- simpl in *. destruct (string_dec s s); subst; congruence. * specialize (IHents H1). destruct (string_dec s0 name); subst. -- simpl. destruct (string_dec name s); congruence. -- simpl. destruct (string_dec s0 s); congruence. - eapply find_subtree_update_subtree_oob; eauto. Qed. Theorem find_subtree_graft_subtree_oob': forall pn num ents base name tree subtree inum f, find_subtree base tree = Some (TreeDir num ents) -> (~ pathname_prefix (base ++ [name]) pn) -> find_subtree pn (tree_graft num ents base name subtree tree) = Some (TreeFile inum f) -> find_subtree pn tree = Some (TreeFile inum f). Proof. unfold tree_graft; intros. destruct (pathname_decide_prefix base pn). - deex. erewrite find_subtree_app in H1. erewrite find_subtree_app by eassumption. 2: erewrite find_update_subtree; eauto. clear H. induction ents; simpl in *. + destruct suffix; simpl in *; try congruence. destruct (string_dec name s); subst; simpl in *; try congruence. contradict H0; eauto. exists suffix. rewrite <- app_assoc. simpl. eauto. + destruct suffix; simpl in *; try congruence. destruct a; simpl in *. destruct (string_dec s0 s); subst. * destruct (string_dec s name); subst. -- exfalso. apply H0. eexists; rewrite <- app_assoc; simpl; eauto. -- simpl in *. destruct (string_dec s s); subst; congruence. * destruct (string_dec s0 name); subst; simpl in *; try congruence. destruct (string_dec name s); subst; simpl in *; try congruence. destruct (string_dec s0 s); subst; simpl in *; try congruence. specialize (IHents H1). eauto. - eapply find_subtree_update_subtree_oob'; eauto. Qed. Theorem find_subtree_prune_subtree_oob: forall pn num ents base name tree inum f, find_subtree base tree = Some (TreeDir num ents) -> (~ pathname_prefix (base ++ [name]) pn) -> find_subtree pn tree = Some (TreeFile inum f) -> find_subtree pn (tree_prune num ents base name tree) = Some (TreeFile inum f). 
= 0. Proof with auto. intros. unfold CardExp. rewrite arrow_to_empty. apply card_eq_0... apply EmptyNE. apply H. Qed.Fact cardExp_0_0 : 0 ^ 0 = 1. Proof. apply cardExp_0_r. Qed. Lemma card_of_power : ∀ A, |𝒫 A| = 2 ^ |A|. Proof with auto. intros. pose proof (power_eqnum_func_to_2 A). apply CardAx1 in H. rewrite H. clear H. apply CardAx1. apply cardExp_well_defined. easy. apply CardAx0. Qed. Lemma card_neq_exp : ∀ ⋵ 𝐂𝐃,   2 ^  . Proof. intros  Hcd Heq. apply card_of_card in Hcd. rewrite Hcd, <- card_of_power in Heq. apply CardAx1 in Heq. eapply Cantor's. apply Heq. Qed. Theorem cardAdd_comm : ∀  𝜆,  + 𝜆 = 𝜆 +  . Proof. intros. apply CardAx1. rewrite bunion_comm. apply cardAdd_well_defined. - rewrite <- eqnum_cprd_single. rewrite <- eqnum_cprd_single. reflexivity. - rewrite <- eqnum_cprd_single. rewrite <- eqnum_cprd_single. reflexivity. - unfold disjoint. rewrite binter_comm. apply disjointify_0_1. - apply disjointify_0_1. Qed. Theorem cardMul_comm : ∀  𝜆,   𝜆 = 𝜆   . Proof with auto. intros. apply CardAx1. set (Func ( × 𝜆) (𝜆 ×  ) (λ x, <π2 x, π1 x>)) as F. exists F. apply meta_bijection. - intros x Hx. apply CPrdE0 in Hx as []. apply CPrdI... - intros x1 Hx1 x2 Hx2 Heq. apply cprd_is_pairs in Hx1 as [a [b Hx1]]. apply cprd_is_pairs in Hx2 as [c [d Hx2]]. apply op_iff in Heq as []. subst. zfc_simple. - intros y Hy. apply CPrdE1 in Hy as [a [Ha [b [Hb Hy]]]]. subst. exists <b, a>. split. apply CPrdI... zfc_simple. Qed.Fact cardAdd_k_k : ∀  ,  +  = 2   . Proof with auto. intros. rewrite cardMul_comm. apply CardAx1. cut ( × {0,} ∪  × {1,} =  × 2). { intros H. now rewrite H. } assert (H1_2: 1 ∈ 2). apply suc_has_n. assert (H0_2: 0 ∈ 2) by (apply suc_has_0; apply ω_inductive; nauto). ext Hx. - apply BUnionE in Hx as []. + apply CPrdE1 in H as [a [Ha [b [Hb H]]]]. apply SingE in Hb. subst. apply CPrdI... + apply CPrdE1 in H as [a [Ha [b [Hb H]]]]. apply SingE in Hb. subst. apply CPrdI... - apply CPrdE1 in Hx as [a [Ha [b [Hb Hx]]]]. subst. apply BUnionE in Hb as []. + apply BUnionE in H as []. exfalso0. apply BUnionI1. apply CPrdI... + apply SingE in H. subst b. apply BUnionI2. apply CPrdI... Qed. Theorem cardAdd_assoc : ∀  𝜆 𝜇, ( + 𝜆) + 𝜇 =  + (𝜆 + 𝜇). 
Require Export List. Require Export Arith. From Huffman Require Export sTactic. Require Import Inverse_Image. Require Import Wf_nat. Section Minus. Theorem lt_minus_O : forall n m, m < n -> 0 < n - m. Proof using. intros n; elim n; simpl in |- *; auto. intros m H1; Contradict H1; auto with arith. intros n1 Rec m; case m; simpl in |- *; auto. intros m1 H1; apply Rec; apply lt_S_n; auto. Qed. Theorem le_minus : forall a b : nat, a - b <= a. 
Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.Echo3 Bedrock.Platform.Bootstrap. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Module M'. Definition globalSched : W := (heapSize + 50) * 4. Definition globalSock : W := globalSched ^+ $4. End M'.Import M'.Module E := Echo3.Make(M'). Import E.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 2. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 2. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "test"!"main" @ [E.mainS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREmain[_] globalSched =?> 2 * 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREmain[_] globalSock =?> 1 * globalSched =?> 1 * mallocHeap 0];; Goto "test"!"main" end }}. Ltac t := unfold globalSched, localsInvariantMain, M'.globalSock, M'.globalSched; genesis. Theorem ok0 : moduleOk boot. vcgen; abstract t. Qed. Definition m1 := link boot E.T.m. Definition m := link E.m m1. Lemma ok1 : moduleOk m1. link ok0 E.T.ok. Qed. Theorem ok : moduleOk m. link E.ok ok1. Qed. Variable stn : settings. Variable prog : program. Hypothesis inj : forall l1 l2 w, Labels stn l1 = Some w -> Labels stn l2 = Some w -> l1 = l2. Hypothesis agree : forall l pre bl, LabelMap.MapsTo l (pre, bl) (XCAP.Blocks m) -> exists w, Labels stn l = Some w /\ prog w = Some bl. Hypothesis agreeImp : forall l pre, LabelMap.MapsTo l pre (XCAP.Imports m) -> exists w, Labels stn l = Some w /\ prog w = None. Hypothesis omitImp : forall l w, Labels stn ("sys", l) = Some w -> prog w = None. Variable w : W. Hypothesis at_start : Labels stn ("main", Global "main") = Some w. Variable st : state. Hypothesis mem_low : forall n, (n < size * 4)%nat -> st.(Mem) n <> None. Hypothesis mem_high : forall w, $ (size * 4) <= w -> st.(Mem) w = None. Theorem safe : sys_safe stn prog (w, st). 
Zabs_eq; apply LeR0Fnum with radix; auto with zarith real. replace (Fabs f) with (Fopp f); [ rewrite Fnormalize_Fopp | apply floatEq; simpl in |- * ]; auto with arith. apply sym_eq; apply Zabs_eq_opp; apply R0LeFnum with radix; auto with zarith real. Qed. Theorem RoundedModeUlp : forall P, RoundedModeP b radix P -> forall (p : R) (q : float), P p q -> (Rabs (p - q) < Fulp q)%R. intros P H' p q H'0. case (Req_dec p q); intros Eq1. rewrite <- Eq1. replace (p - p)%R with 0%R; [ idtac | ring ]. rewrite Rabs_R0; auto. unfold Fulp, FtoRradix, FtoR in |- *; simpl in |- *; auto with real arith. case H'. intros H'1 H'2; elim H'2; intros H'3 H'4; elim H'4; intros H'5 H'6; case H'5 with (1 := H'0); clear H'5 H'4 H'2; intros H'5. rewrite Rabs_right; auto. cut (Fbounded b q); [ intros B0 | case H'5; auto ]. apply Rlt_le_trans with (2 := FulpSuc q B0). apply Rplus_lt_reg_l with (r := FtoR radix q). repeat rewrite Rplus_minus; auto. case (Rle_or_lt (FNSucc b radix precision q) p); auto. intros H'2; absurd (FNSucc b radix precision q <= q)%R; auto. apply Rgt_not_le; red in |- *; unfold FtoRradix in |- *; auto with real float arith. case H'5; auto. intros H'4 H'7; elim H'7; intros H'8 H'9; apply H'9; clear H'7; auto. apply (FcanonicBound radix b); auto with float arith. apply Rle_ge; apply Rplus_le_reg_l with (r := FtoR radix q). repeat rewrite Rplus_minus; auto. rewrite Rplus_0_r; apply isMin_inv1 with (1 := H'5); auto. rewrite Faux.Rabsolu_left1; auto. rewrite Ropp_minus_distr; auto. cut (Fbounded b q); [ intros B0 | case H'5; auto ]. apply Rlt_le_trans with (2 := FulpPred q B0). apply Ropp_lt_cancel; repeat rewrite Rminus_0_l. apply Rplus_lt_reg_l with (r := FtoR radix q). repeat rewrite Rplus_minus; auto. case (Rle_or_lt p (FNPred b radix precision q)); auto. intros H'2; absurd (q <= FNPred b radix precision q)%R; auto. apply Rgt_not_le; red in |- *; unfold FtoRradix in |- *; auto with real float arith. case H'5; auto. intros H'4 H'7; elim H'7; intros H'8 H'9; apply H'9; clear H'7; auto. apply (FcanonicBound radix b); auto with float arith. intros H1; apply Rplus_lt_compat_l; auto with real; apply Ropp_lt_contravar; unfold Rminus in |- *; auto with real. apply Rplus_le_reg_l with (r := FtoR radix q). repeat rewrite Rplus_minus; auto. rewrite Rplus_0_r; apply isMax_inv1 with (1 := H'5). Qed. Theorem RoundedModeErrorExpStrict : forall P, RoundedModeP b radix P -> forall (p q : float) (x : R), Fbounded b p -> Fbounded b q -> P x p -> q = (x - p)%R :>R -> q <> 0%R :>R -> (Fexp q < Fexp p)%Z. 
zarith arith. case (dExp b); auto with zarith. case (boundR r); simpl in |- *; auto with zarith. case (boundR r); simpl in |- *; auto with zarith. Qed. Theorem mBFadic_correct3 : forall r : R, In (Fopp (boundR r)) (mBFloat r). intros r; unfold mBFloat in |- *. replace (Fopp (boundR r)) with ((fun p : Z * Z => Float (fst p) (snd p)) (Fnum (Fopp (boundR r)), Fexp (Fopp (boundR r)))). apply in_map with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. apply mProd_correct; auto. apply mZlist_correct; auto. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. replace (-1)%Z with (- Z_of_nat 1)%Z; auto with zarith. apply Zle_Zopp. unfold pPred in |- *; apply Zle_Zpred; simpl in |- *. apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. unfold pPred in |- *; apply Zle_Zpred; simpl in |- *. red in |- *; simpl in |- *; auto. apply mZlist_correct; auto. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. apply Zle_trans with 0%Z; auto with zarith. case (dExp b); auto with zarith. case (boundR r); simpl in |- *; auto with zarith. case (boundR r); simpl in |- *; auto with zarith. Qed. Theorem mBFadic_correct4 : forall r : R, In (Float 0%nat (- dExp b)) (mBFloat r). intros p; unfold mBFloat in |- *. replace (Float 0%nat (- dExp b)) with ((fun p : Z * Z => Float (fst p) (snd p)) (Fnum (Float 0%nat (- dExp b)), Fexp (Float 0%nat (- dExp b)))). apply in_map with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. apply mProd_correct; auto. apply mZlist_correct; auto. simpl in |- *; auto with zarith. replace 0%Z with (- (0))%Z; [ idtac | simpl in |- *; auto ]. apply Zle_Zopp; unfold pPred in |- *; apply Zle_Zpred. red in |- *; simpl in |- *; auto with zarith. simpl in |- *; auto with zarith. unfold pPred in |- *; apply Zle_Zpred. red in |- *; simpl in |- *; auto with zarith. apply mZlist_correct; auto. simpl in |- *; auto with zarith. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. apply Zle_trans with 0%Z; auto with zarith. case (dExp b); auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem mBPadic_Fbounded : forall (p : float) (r : R), In p (mBFloat r) -> Fbounded b p. 
in S_P. have sYS: {subset Y <= S} by apply: mem_Cint_span. have S_1: 1 \in S. by apply/sYS/imageP; exists 0 => //; rewrite big1 // => i; rewrite ffunE. have SmulX (i : 'I_m): {in S, forall x, x * X`_i \in S}. move=> _ /S_P[x ->]; rewrite mulr_suml rpred_sum // => j _. rewrite mulrzAl rpredMz {x}// nth_image mulrC (bigD1 i) //= mulrA -exprS. move: {j}(enum_val j) (familyP (enum_valP j)) => f fP. have:= fP i; rewrite inE /= leq_eqVlt => /predU1P[-> | fi_ltn]; last first. apply/sYS/imageP; have fiK: (inord (f i).+1 : 'I_N) = (f i).+1 :> nat. by rewrite inordK // ltnS (bigmax_sup i). exists (finfun [eta f with i |-> inord (f i).+1]). apply/familyP=> i1; rewrite inE ffunE /= fun_if fiK. by case: eqP => [-> // | _]; apply: fP. rewrite (bigD1 i isT) ffunE /= eqxx fiK; congr (_ * _). by apply: eq_bigr => i1; rewrite ffunE /= => /negPf->. have [/monicP ] := (minCpoly_monic X`_i, root_minCpoly X`_i). rewrite /root horner_coef lead_coefE -(subnKC (size_minCpoly _)) subn2. rewrite big_ord_recr /= addrC addr_eq0 => ->; rewrite mul1r => /eqP->. have /floorCpP[p Dp]: X`_i \in Aint. by have [/(nth_default 0)-> | /(mem_nth 0)/AZ_X] := leqP (size X) i. rewrite -/(n i) Dp mulNr rpredN // mulr_suml rpred_sum // => [[e le_e]] /= _. rewrite coef_map -mulrA mulrzl rpredMz ?sYS //; apply/imageP. have eK: (inord e : 'I_N) = e :> nat by rewrite inordK // ltnS (bigmax_sup i). exists (finfun [eta f with i |-> inord e]). apply/familyP=> i1; rewrite inE ffunE /= fun_if eK. by case: eqP => [-> // | _]; apply: fP. rewrite (bigD1 i isT) ffunE /= eqxx eK; congr (_ * _). by apply: eq_bigr => i1; rewrite ffunE /= => /negPf->. exists S; last by exists (Tagged (fun n => n.-tuple _) [tuple of Y]). split=> [|x Xx]; last first. by rewrite -[x]mul1r -(nth_index 0 Xx) (SmulX (Ordinal _)) // ltnS index_size. split=> // x y Sx Sy; first by rewrite rpredB. case/S_P: Sy => {y}[y ->]; rewrite mulr_sumr rpred_sum //= => j. rewrite mulrzAr rpredMz {y}// nth_image; move: {j}(enum_val j) => f. elim/big_rec: _ => [|i y _ IHy] in x Sx *; first by rewrite mulr1. rewrite mulrA {y}IHy //. elim: {f}(f i : nat) => [|e IHe] in x Sx *; first by rewrite mulr1. by rewrite exprS mulrA IHe // SmulX. Qed.Section AlgIntSubring.Import DefaultKeying GRing.DefaultPred perm. Theorem fin_Csubring_Aint S n (Y : n.-tuple algC) : mulr_closed S -> (forall x, reflect (inIntSpan Y x) (x \in S)) -> {subset S <= Aint}. 
eapply filter_In. intuition. eapply in_intersect. intuition. apply ratMult_0_r. eapply sumList_body_eq. intuition. apply filter_In in H3. intuition. destruct a0; simpl in *. destruct b; simpl in *; try discriminate. rewrite H0. intuition. Qed.Theorem evalDist_right_ident : forall (A : Set)(eqd : EqDec A)(c : Comp A) a, evalDist (x <-$ c; ret x) a == evalDist c a. intuition. destruct (in_dec (EqDec_dec eqd) a (getSupport c)). simpl. eapply eqRat_trans. eapply sumList_exactly_one. eapply getSupport_NoDup. eauto. intuition. destruct (EqDec_dec eqd b a). subst. intuition. eapply ratMult_0_r. destruct (EqDec_dec eqd a a). eapply ratMult_1_r. congruence. simpl. eapply eqRat_trans. eapply sumList_0. intuition. destruct (EqDec_dec eqd a0 a). subst. intuition. eapply ratMult_0_r. symmetry. eapply getSupport_not_In_evalDist. trivial. Qed. Theorem fundamental_lemma : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(c1 c2 : Comp A)(badness : A -> bool)(proj : A -> B), Pr [a <-$ c1; ret (badness a)] == Pr[a <-$ c2; ret (badness a)] -> (forall x, evalDist (a <-$ c1; ret (proj a, badness a)) (x, false) == evalDist (a <-$ c2; ret (proj a, badness a)) (x, false)) -> forall x, | (evalDist (a <-$ c1; ret (proj a)) x) - (evalDist (a <-$ c2; ret (proj a)) x) | <= Pr [a <-$ c1; ret (badness a)]. intuition. specialize (@fundamental_lemma_h B eqdb (a <-$ c1; ret (proj a, badness a)) (a <-$ c2; ret (proj a, badness a)) ); intuition. assert ( | evalDist (x <-$ (a0 <-$ c1; ret (proj a0, badness a0)); ret fst x) x - evalDist (x <-$ (a0 <-$ c2; ret (proj a0, badness a0)); ret fst x) x | == | evalDist (a <-$ c1; ret proj a) x - evalDist (a <-$ c2; ret proj a) x |). eapply ratDistance_eqRat_compat. eapply eqRat_trans. eapply evalDist_assoc_eq. cbv beta. eapply eqRat_trans. eapply evalDist_seq_eq. intuition. eapply eqRat_refl. intuition. eapply eqRat_trans. eapply evalDist_left_ident_eq. eapply eqRat_refl. cbv beta. unfold fst. intuition. eapply eqRat_trans. eapply evalDist_assoc_eq. cbv beta. eapply evalDist_seq_eq; intuition. eapply evalDist_left_ident_eq. rewrite <- H2. rewrite H1. eapply leRat_trans. eapply eqRat_impl_leRat. eapply eqRat_trans. eapply evalDist_assoc_eq. cbv beta. eapply evalDist_seq_eq; intuition. eapply eqRat_refl. eapply eqRat_trans. eapply evalDist_left_ident_eq. cbv beta. eapply eqRat_refl. cbv beta. unfold snd. intuition. eapply eqRat_trans. eapply evalDist_assoc_eq. eapply eqRat_trans. eapply evalDist_seq_eq; intuition. eapply eqRat_refl. eapply eqRat_trans. eapply evalDist_left_ident_eq. cbv beta. eapply eqRat_refl. rewrite H. symmetry. eapply eqRat_trans. eapply evalDist_assoc_eq. eapply eqRat_trans. eapply evalDist_seq_eq; intuition. eapply eqRat_refl. eapply eqRat_trans. eapply evalDist_left_ident_eq. eapply eqRat_refl. cbv beta. simpl. intuition. intuition. Qed. Theorem repeat_unroll_eq: forall (A : Set)(eqd : EqDec A)(c : Comp A)(P : A -> bool) v, well_formed_comp c -> (exists a, In a (filter P (getSupport c))) -> evalDist (Repeat c P) v == evalDist (x <-$ c; if (P x) then ret x else (Repeat c P)) v. 
l) o' (filter1 pred r) end. Theorem gfilter1: forall (A: Type) (pred: A -> bool) (i: elt) (m: t A), get i (filter1 pred m) = match get i m with None => None | Some x => if pred x then Some x else None end. Proof. intros until m. revert m i. induction m; simpl; intros. rewrite gleaf; auto. rewrite gnode'. destruct i; simpl; auto. destruct o; auto. Qed. Section COMBINE. Variables A B C: Type. Variable f: option A -> option B -> option C. Hypothesis f_none_none: f None None = None. Fixpoint xcombine_l (m : t A) {struct m} : t C := match m with | Leaf => Leaf | Node l o r => Node' (xcombine_l l) (f o None) (xcombine_l r) end. Lemma xgcombine_l : forall (m: t A) (i : positive), get i (xcombine_l m) = f (get i m) None. Proof. induction m; intros; simpl. repeat rewrite gleaf. auto. rewrite gnode'. destruct i; simpl; auto. Qed. Fixpoint xcombine_r (m : t B) {struct m} : t C := match m with | Leaf => Leaf | Node l o r => Node' (xcombine_r l) (f None o) (xcombine_r r) end. Lemma xgcombine_r : forall (m: t B) (i : positive), get i (xcombine_r m) = f None (get i m). Proof. induction m; intros; simpl. repeat rewrite gleaf. auto. rewrite gnode'. destruct i; simpl; auto. Qed. Fixpoint combine (m1: t A) (m2: t B) {struct m1} : t C := match m1 with | Leaf => xcombine_r m2 | Node l1 o1 r1 => match m2 with | Leaf => xcombine_l m1 | Node l2 o2 r2 => Node' (combine l1 l2) (f o1 o2) (combine r1 r2) end end. Theorem gcombine: forall (m1: t A) (m2: t B) (i: positive), get i (combine m1 m2) = f (get i m1) (get i m2). Proof. induction m1; intros; simpl. rewrite gleaf. apply xgcombine_r. destruct m2; simpl. rewrite gleaf. rewrite <- xgcombine_l. auto. repeat rewrite gnode'. destruct i; simpl; auto. Qed. End COMBINE. Lemma xcombine_lr : forall (A B: Type) (f g : option A -> option A -> option B) (m : t A), (forall (i j : option A), f i j = g j i) -> xcombine_l f m = xcombine_r g m. Proof. induction m; intros; simpl; auto. rewrite IHm1; auto. rewrite IHm2; auto. rewrite H; auto. Qed. Theorem combine_commut: forall (A B: Type) (f g: option A -> option A -> option B), (forall (i j: option A), f i j = g j i) -> forall (m1 m2: t A), combine f m1 m2 = combine g m2 m1. 
apply ( isofhlevelcontr 2 is ) . Defined .Lemma isasetaprop { X : UU } ( is : isaprop X ) : isaset X . Proof . intros . apply ( isofhlevelsnprop 1 is ) . Defined . Lemma uip { X : UU } ( is : isaset X ) { x x' : X } ( e e' : paths x x' ) : paths e e' . Proof. intros . apply ( proofirrelevance _ ( is x x' ) e e' ) . Defined . Lemma isofhlevelssnset (n:nat) ( X : UU ) ( is : isaset X ) : isofhlevel ( S (S n) ) X. Proof. intros n X X0. simpl. unfold isaset in X0. intros x x' . apply isofhlevelsnprop. set ( int := X0 x x'). assumption . Defined. Lemma isasetifiscontrloops (X:UU): (forall x:X, iscontr (paths x x)) -> isaset X. Proof. intros X X0. unfold isaset. unfold isofhlevel. intros x x' x0 x0' . destruct x0. set (is:= X0 x). apply isapropifcontr. assumption. Defined. Lemma iscontrloopsifisaset (X:UU): (isaset X) -> (forall x:X, iscontr (paths x x)). Proof. intros X X0 x. unfold isaset in X0. unfold isofhlevel in X0. change (forall (x x' : X) (x0 x'0 : paths x x'), iscontr (paths x0 x'0)) with (forall (x x':X), isaprop (paths x x')) in X0. apply (iscontraprop1 (X0 x x) (idpath x)). Defined.Theorem isasetsubset { X Y : UU } (f: X -> Y) (is1: isaset Y) (is2: isincl f): isaset X. Proof. intros. apply (isofhlevelsninclb (S O) f is2). apply is1. Defined. Theorem isinclfromhfiber { X Y : UU } (f: X -> Y) (is : isaset Y) ( y: Y ) : @isincl (hfiber f y) X ( @pr1 _ _ ). Proof. intros. apply isofhlevelfhfiberpr1. assumption. Defined. Theorem isinclbetweensets { X Y : UU } ( f : X -> Y ) ( isx : isaset X ) ( isy : isaset Y ) ( inj : forall x x' : X , ( paths ( f x ) ( f x' ) -> paths x x' ) ) : isincl f . Proof. intros . apply isinclweqonpaths . intros x x' . apply ( isweqimplimpl ( @maponpaths _ _ f x x' ) ( inj x x' ) ( isx x x' ) ( isy ( f x ) ( f x' ) ) ) . Defined . Theorem isinclfromunit { X : UU } ( f : unit -> X ) ( is : isaset X ) : isincl f . 
=> tr1 | right _ => tr2 end. Arguments ifThenElse P {_} {T}. Definition check P `{!Decision P}: transition unit := ifThenElse P (ret tt) (undefined). Definition checkNot P `{!Decision P}: transition unit := ifThenElse P (undefined) (ret tt). Definition when P `{!Decision P} (r: transition unit): transition unit := ifThenElse P r (ret tt). Definition unless P `{!Decision P} (r: transition unit): transition unit := ifThenElse P (ret tt) (r). Definition unwrap {T} (mx: option T): transition T := match mx with | Some x => ret x | None => undefined end. Theorem ifThenElse_if P `{!Decision P} {T} (r1 r2: transition T) : P -> ifThenElse P r1 r2 = r1. Proof. intros H. unfold ifThenElse. destruct (decide P); auto || contradiction. Qed. Theorem ifThenElse_else P `{!Decision P} {T} (r1 r2: transition T) : ~P -> ifThenElse P r1 r2 = r2. Proof. intros H. unfold ifThenElse. destruct (decide P); auto || contradiction. Qed. Definition next_hint (hints: list Z): Z * list Z := match hints with | z::hints' => (z, hints') | nil => (0%Z, nil) end. Fixpoint interpret (hints: list Z) {T} (tr: transition T): Σ -> option (list Z * Σ * T) := match tr with | runF f => fun s => let (s', v) := f s in Some (hints, s', v) | bind r1 rx => fun s => match interpret hints r1 s with | Some (hints', s', v) => interpret hints' (rx v) s' | None => None end | suchThat pred => let (hint, hints') := next_hint hints in fun s => match genNext hint s with | Some (exist _ x _) => Some (hints', s, x) | None => None end | suchThatBool b => let (hint, hints') := next_hint hints in fun s => match genNextBool hint s with | Some (exist _ x _) => Some (hints', s, x) | None => None end end.End transition.Arguments transition Σ T : clear implicits. Arguments suchThat {Σ T} pred {gen}. Arguments suchThatBool {Σ T} b {gen}. Arguments any {Σ} T {gen}. Arguments check {Σ} P {_}. Arguments when {Σ} P {_}.Module relation. Section state. Context (Σ:Type). Definition t T := Σ -> Σ -> T -> Prop. Inductive runF {T} (f:Σ -> Σ * T): t T := | runF_runs : forall s s' v, f s = (s', v) -> runF f s s' v. Theorem runF_runs_to {T} (f: Σ -> Σ * T) s : runF f s (fst (f s)) (snd (f s)). 
Prop := forall v h, p v h <-> q v h. Definition hlift (p : Prop) : assertion := fun v h => p.Infix "|->" := hpto (at level 30) : sep_scope. Infix "/~\" := hand (at level 40) : sep_scope. Infix "**" := hstar (at level 40) : sep_scope. Delimit Scope sep_scope with sep. Notation "p ==> q" := (himp p%sep q%sep) (no associativity, at level 70). Notation "p <==> q" := (heq p%sep q%sep) (no associativity, at level 70).Open Scope sep_scope.Ltac hsimpl := unfold hemp, empty_heap, hpto, hstar, hsplit, hdsj, hcov, huni, hand, himp, heq, hlift, add, lookup in *. Ltac hsolver := match goal with | [ |- context[ if ?c then _ else _ ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ if ?c then _ else _ ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ |- context[ match ?c with Some _ => _ | None => _ end ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ match ?c with Some _ => _ | None => _ end ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ H : (?x <? ?y) = true |- _ ] => rewrite Nat.ltb_lt in H | [ H : (?x <? ?y) = false |- _ ] => rewrite Nat.ltb_nlt in H end; subst; auto.Lemma heap_extensionality : forall (h1 h2 : heap), h1 = h2 -> forall (x : nat), h1 x = h2 x. Proof. crush. Qed.Module SeparationProperty. Theorem pt2same_sep : forall (p x y : exp), p |-> x ** p |-> y ==> hlift False. Proof. hsimpl; intros; firstorder; subst. specialize (H (eval p v)). hsolver; crush. Qed. Theorem pt2same_sep' : forall (p q x y : exp), p |-> x ** q |-> y ==> (fun v h => eval p v <> eval q v). Proof. hsimpl; intros; firstorder; subst. intros contra; subst. specialize (H (eval q v)); repeat hsolver; crush. Qed. Theorem pt2same_and : forall (p x y : exp), p |-> x /~\ p |-> y ==> (fun v h => eval x v = eval y v). Proof. hsimpl; intros; intuition; subst. pose proof (@heap_extensionality _ _ H1 (eval p v)); crush. hsolver; crush. Qed. Theorem pt_and_empty : forall (p x : exp), p |-> x /~\ hemp ==> hlift False. 
| n m l k H1 H2 (H7 & ll & H3 & H4 & H5 & H6) ]. + split. * intros ?; auto. * exists nil; simpl; repeat split; auto. - inversion 1. - intros _ []. + split. * intros ? ?; apply H7, H1; auto. * destruct H1 as (G1 & x & G2 & G3). exists (x::ll); simpl; repeat split; auto. - contradict H3. apply list_has_dup_cons_inv in H3. destruct H3 as [ H3 | ]; auto. destruct (H6 x); auto. - apply incl_cons; auto. - intros y F1 [ F2 | F2 ]; subst. ** tauto. ** apply (H6 y); auto. Qed. Corollary sincl_chain_bounded l m n : chain sincl n m l -> n <= length l. Proof. intros H. apply sincl_chain in H. destruct H as (_ & ll & H1 & H2 & H3 & _). destruct (le_lt_dec n (length l)) as [ | C ]; auto. subst; destruct H1. apply finite_php_dup with l; auto. Qed. Theorem wf_sincl : well_founded sincl. Proof. apply wf_chains. intros l; exists (length l). intros ? ?; apply sincl_chain_bounded. Qed.End sincl.Arguments wf_sincl {X}.Section rincl_fin. Variable (X : Type) (M : list X). Definition rincl_fin l m := (forall x, In x m -> In x M -> In x l) /\ exists x, ~ In x m /\ In x l /\ In x M. Lemma rincl_fin_chains n m l : chain rincl_fin n m l -> exists ll, ~ list_has_dup ll /\ incl ll M /\ length ll = n /\ incl ll m. Proof. induction 1 as [ x | n m k l H1 H2 (ll & H3 & H4 & H5 & H6) ]. + exists nil. repeat split; simpl; auto; inversion 1. + destruct H1 as (H1 & a & G1 & G2 & G3). exists (a::ll). repeat split. * contradict H3. apply list_has_dup_cons_inv in H3. destruct H3 as [ H3 | ]; auto. destruct G1; apply H6; auto. * apply incl_cons; auto. * simpl; f_equal; auto. * apply incl_cons; auto. intros ? ?; auto. Qed. Corollary rincl_fin_chain_bounded l m n : chain rincl_fin n m l -> n <= length M. Proof. intros H. apply rincl_fin_chains in H. destruct H as (ll & H1 & H2 & H3 & _). destruct (le_lt_dec n (length M)) as [ | C ]; auto. subst n; destruct H1. apply finite_php_dup with M; auto. Qed. Theorem wf_rincl_fin : well_founded rincl_fin. 
Nat2Z.inj_succ. rewrite Z.mul_succ_l. chunk_red; omega. Qed. Theorem bind_n_after_ptr_exists: forall n b ofs L, exists L', bind_n_after_ptr_rev n b ofs L L' /\ (forall b' z', (bind_n_after_ptr ((Z.of_nat n) * int_size) b ofs L) b' z' <-> L' b' z'). Proof. intros. assert (H_L := bind_n_after_ptr_exists' n b ofs L). destruct H_L. exists x. split. auto. eapply bind_n_after_ptr_from_rev. auto. Qed. Theorem load_ptr_or_int: forall y, Vint_or_Vptr y = true -> Val.load_result int_chunk y = y. Proof. intros. simpl. destruct y; inv H; auto. Qed. Theorem mem_after_n_proj_rev_unchanged: forall b vs ofs m m', mem_after_n_proj_store_rev b ofs vs m m' -> forall L, (forall j, ofs <= j < ofs+int_size*(Z.of_nat (length vs)) -> ~ L b j)%Z -> Mem.unchanged_on L m m'. Proof. induction vs; intros; inv H. - eapply Mem.store_unchanged_on. eauto. simpl in H0. simpl size_chunk. auto. - eapply IHvs with (L := L) in H5. + apply Mem.unchanged_on_trans with (m2 := m'0). auto. eapply Mem.store_unchanged_on; eauto. intros. apply H0. simpl length. rewrite Nat2Z.inj_succ. chunk_red; omega. + intros. apply H0. simpl length. rewrite Nat2Z.inj_succ. chunk_red; omega. Qed. Definition arg_val_L6_L7 (fenv:fun_env) (finfo_env:fun_info_env) (p:program) (rep_env: M.t ctor_rep): L6.cps.val -> mem -> temp_env -> Prop := fun v m lenv => exists args_b args_ofs L7v L, M.get argsIdent lenv = Some (Vptr args_b args_ofs) /\ Mem.load int_chunk m args_b (Ptrofs.unsigned (Ptrofs.add args_ofs (Ptrofs.repr int_size))) = Some L7v /\ repr_val_L_L6_L7_id fenv finfo_env p rep_env v m L L7v. Definition same_args_ptr lenv lenv' := @M.get Values.val argsIdent lenv = M.get argsIdent lenv'.Definition same_tinf_ptr lenv lenv' := @M.get Values.val tinfIdent lenv = M.get tinfIdent lenv'.Definition mem_same_block (b:block) (m m':mem) : Prop := forall chunk ofs, Mem.load chunk m b ofs = Mem.load chunk m' b ofs. Theorem max_allocs_case: forall c e y cl, List.In (c, e) cl -> max_allocs e <= max_allocs (Ecase y cl). Proof. induction cl; intros. inv H. simpl. destruct a. inv H. - inv H0. apply Nat.le_max_l. - apply IHcl in H0. simpl in H0. etransitivity. apply H0. apply Nat.le_max_r. Qed. Theorem get_list_cons : forall A rho v ys vs, @get_list A ys rho = Some (v :: vs) -> exists y ys', ys = y::ys' /\ cps.M.get y rho = Some v /\ get_list ys' rho = Some vs. Proof. intros. destruct ys as [ | y ys']. inv H. exists y, ys'. split; auto. simpl in H. destruct (cps.M.get y rho). destruct (get_list ys' rho). inv H. auto. inv H. inv H. Qed. Theorem exists_getvar_or_funvar_list: forall lenv p rho L rep_env finfo_env argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam fenv m xs vs, ( forall x, List.In x xs -> exists v6 : cps.val, M.get x rho = Some v6 /\ repr_val_id_L_L6_L7 argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam fenv finfo_env p rep_env v6 m L lenv x) -> get_list xs rho = Some vs -> exists vs7 : list Values.val, get_var_or_funvar_list p lenv xs = Some vs7. 
Theorem trivial : forall A : Prop, A -> A. auto. Qed.Theorem and_commutative : forall A B : Prop, A /\ B -> B /\ A. intros A B H'; elim H'; auto. Qed.Theorem or_commutative : forall A B : Prop, A \/ B -> B \/ A. intros A B H'; elim H'; auto. Qed.Theorem mp : forall A B : Prop, A -> (A -> B) -> B. auto. Qed.Theorem S : forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C. auto. Qed.Theorem Praeclarum : forall x y z t : Prop, (x -> z) /\ (y -> t) -> x /\ y -> z /\ t. intros x y z t H'; elim H'. intros H'0 H'1 H'2; elim H'2. auto. Qed.Theorem resolution : forall (p q : Type -> Prop) (a : Type), p a -> (forall x : Type, p x -> q x) -> q a. auto. Qed.Theorem Witnesses : forall (a b : Type) (p : Type -> Prop), p a \/ p b -> exists x : Type, p x. intros a b p h; elim h; [ intro H'; clear h; try exact H' | clear h; intro H' ]. exists a; try assumption. exists b; try assumption. Qed.Theorem Simple : forall (A : Set) (R : A -> A -> Prop), (forall x y z : A, R x y /\ R y z -> R x z) -> (forall x y : A, R x y -> R y x) -> forall x : A, (exists y : A, R x y) -> R x x. intros A R H' H'0 x H'1; try assumption. elim H'1; intros y E; clear H'1; try exact E. apply H' with y; auto. Qed.Theorem not_not : forall a : Prop, a -> ~ ~ a. unfold not in |- *; auto. Qed.Theorem mini_cases : forall x y : Prop, (x \/ ~ y) /\ y -> x. intros x y h; elim h; intros h0 H'; elim h0; [ clear h h0; intro H'0 | intro H'0; elim H'0; clear h h0; try assumption ]; auto. Qed.Require Import Classical. Theorem not_not_converse : forall a : Prop, ~ ~ a -> a. 
eqA_trans with (y := plusA (invA (multA a b)) A0); auto. apply eqA_trans with (y := plusA A0 (invA (multA a b))); auto. apply eqA_trans with (y := plusA (multA A0 b) (invA (multA a b))); auto. apply eqA_trans with (y := plusA (multA (plusA a (invA a)) b) (invA (multA a b))); auto. apply eqA_trans with (y := plusA (plusA (multA a b) (multA (invA a) b)) (invA (multA a b))); auto. apply eqA_trans with (y := plusA (plusA (multA (invA a) b) (multA a b)) (invA (multA a b))); auto. apply eqA_trans with (y := plusA (multA (invA a) b) (plusA (multA a b) (invA (multA a b)))); auto. apply eqA_trans with (y := plusA (multA (invA a) b) A0); auto. apply plusA_eqA_comp with (1 := cs); auto. apply multA_dist_r. Qed. Hint Resolve multA_invA_com_l. Theorem multA_invA_com_r : forall a b : A, eqA (multA a (invA b)) (invA (multA a b)). intros a b; apply eqA_trans with (y := multA (invA b) a); auto. apply eqA_trans with (y := invA (multA b a)); auto. Qed. Hint Resolve multA_invA_com_r. Theorem divA_multA_comp_l : forall (a b c : A) (nZc : ~ eqA c A0), eqA (divA (multA a b) c nZc) (multA a (divA b c nZc)). intros a b c nZc; apply eqA_trans with (y := divA (multA b a) c nZc); auto. apply eqA_trans with (y := multA (divA b c nZc) a); auto. apply divA_multA_comp_r with (1 := cs); auto. Qed. Hint Resolve divA_multA_comp_l. Theorem invA_is_invA1 : forall a : A, eqA (invA a) (multA (invA A1) a). intros a; apply eqA_trans with (y := plusA (invA a) A0); auto. apply eqA_trans with (y := plusA (invA a) (multA A0 a)); auto. apply eqA_trans with (y := plusA (invA a) (multA (plusA A1 (invA A1)) a)); auto. apply eqA_trans with (y := plusA (invA a) (plusA (multA A1 a) (multA (invA A1) a))); auto. apply plusA_eqA_comp with (1 := cs); auto. apply eqA_sym; auto. apply multA_dist_r. apply eqA_trans with (y := plusA (invA a) (plusA a (multA (invA A1) a))); auto. apply eqA_trans with (y := plusA (plusA (invA a) a) (multA (invA A1) a)); auto. apply eqA_trans with (y := plusA (plusA a (invA a)) (multA (invA A1) a)); auto. apply eqA_trans with (y := plusA A0 (multA (invA A1) a)); auto. apply eqA_trans with (y := plusA (multA (invA A1) a) A0); auto. Qed. Theorem divA_A0_l : forall (a : A) (nZa : ~ eqA a A0), eqA (divA A0 a nZa) A0. 
  . Proof with auto. intros. rewrite cardMul_comm. apply CardAx1. cut ( × {0,} ∪  × {1,} =  × 2). { intros H. now rewrite H. } assert (H1_2: 1 ∈ 2). apply suc_has_n. assert (H0_2: 0 ∈ 2) by (apply suc_has_0; apply ω_inductive; nauto). ext Hx. - apply BUnionE in Hx as []. + apply CPrdE1 in H as [a [Ha [b [Hb H]]]]. apply SingE in Hb. subst. apply CPrdI... + apply CPrdE1 in H as [a [Ha [b [Hb H]]]]. apply SingE in Hb. subst. apply CPrdI... - apply CPrdE1 in Hx as [a [Ha [b [Hb Hx]]]]. subst. apply BUnionE in Hb as []. + apply BUnionE in H as []. exfalso0. apply BUnionI1. apply CPrdI... + apply SingE in H. subst b. apply BUnionI2. apply CPrdI... Qed. Theorem cardAdd_assoc : ∀  𝜆 𝜇, ( + 𝜆) + 𝜇 =  + (𝜆 + 𝜇). Proof with neauto; try congruence; try easy. intros. apply CardAx1. assert (Hnq: Embed 1 = Embed 2 → False). { intros. apply (nat_irrefl 2)... rewrite <- H at 1. apply suc_has_n. } eapply Equivalence_Transitive. { apply cardAdd_well_defined. - unfold CardAdd. rewrite <- eqnum_cprd_single, <- CardAx0... - rewrite <- eqnum_cprd_single, (eqnum_cprd_single _ 2)... - apply disjointify_0_1. - unfold disjoint. rewrite binter_comm, binter_bunion_distr. apply EmptyI. intros x Hx. apply BUnionE in Hx as []; apply BInterE in H as []. + eapply disjointE. apply (cprd_disjointify 𝜇  2 0). apply suc_neq_0. apply H. apply H0. + eapply disjointE. apply (cprd_disjointify 𝜇 𝜆 2 1). intro. apply Hnq... apply H. apply H0. } symmetry. eapply Equivalence_Transitive. { apply cardAdd_well_defined. - reflexivity. - unfold CardAdd. rewrite <- eqnum_cprd_single, <- CardAx0. apply cardAdd_well_defined. + rewrite <- eqnum_cprd_single, (eqnum_cprd_single _ 1)... + rewrite <- eqnum_cprd_single, (eqnum_cprd_single _ 2)... + apply disjointify_0_1. + apply cprd_disjointify. intro. apply Hnq... - apply disjointify_0_1. - unfold disjoint. rewrite binter_bunion_distr. apply EmptyI. intros x Hx. apply BUnionE in Hx as []. + pose proof (disjointify_0_1  𝜆). rewrite H0 in H. exfalso0. + apply BInterE in H as []. eapply disjointE. apply (cprd_disjointify  𝜇 0 2). intro. eapply suc_neq_0... apply H. apply H0. } rewrite bunion_assoc... Qed. Theorem cardMul_assoc : ∀  𝜆 𝜇, (  𝜆)  𝜇 =   (𝜆  𝜇). Proof. intros. apply CardAx1. eapply Equivalence_Transitive. - apply cardMul_well_defined. symmetry. apply CardAx0. reflexivity. - rewrite eqnum_cprd_assoc. apply cardMul_well_defined. easy. apply CardAx0. Qed. Theorem cardMul_distr : ∀  𝜆 𝜇,   (𝜆 + 𝜇) =   𝜆 +   𝜇. 
(forall p, In p (nwPackets {| nwPackets := ps ; nwState := st |}) -> In p (nwPackets net)) by (intros; simpl in *; find_rewrite; in_crush) end. eapply_prop msg_refined_raft_net_invariant_state_same_packet_subset; [|eauto|idtac|]; eauto. + match goal with | [ H : nwPackets ?net = _ |- _ {| nwPackets := ?ps ; nwState := ?st |} ] => assert (forall p, In p (nwPackets {| nwPackets := ps ; nwState := st |}) -> In p (nwPackets net)) by (intros; simpl in *; find_rewrite; in_crush) end. eapply_prop msg_refined_raft_net_invariant_state_same_packet_subset; [|eauto|idtac|]; eauto. + auto. + eapply_prop msg_refined_raft_net_invariant_reboot; eauto; intros; simpl in *; repeat break_if; intuition; subst; intuition eauto. destruct (nwState net h); auto. - eapply msg_refined_raft_invariant_handle_input; eauto. - eapply msg_refined_raft_invariant_handle_message; eauto. - eapply_prop msg_refined_raft_net_invariant_do_leader; eauto. - eapply_prop msg_refined_raft_net_invariant_do_generic_server; eauto. Qed. Lemma msg_refined_raft_invariant_handle_message' P : forall xs p ys net st' ps' gd d l, msg_refined_raft_net_invariant_append_entries' P -> msg_refined_raft_net_invariant_append_entries_reply' P -> msg_refined_raft_net_invariant_request_vote' P -> msg_refined_raft_net_invariant_request_vote_reply' P -> handleMessage (pSrc p) (pDst p) (snd (pBody p)) (snd (nwState net (pDst p))) = (d, l) -> update_elections_data_net (pDst p) (pSrc p) (snd (pBody p)) (nwState net (pDst p)) = gd -> P net -> msg_refined_raft_intermediate_reachable net -> msg_refined_raft_intermediate_reachable (mkNetwork ps' st') -> nwPackets net = xs ++ p :: ys -> (forall h, st' h = update name_eq_dec (nwState net) (pDst p) (gd, d) h) -> (forall p', In p' ps' -> In p' (xs ++ ys) \/ In p' (send_packets (pDst p) (@add_ghost_msg _ _ ghost_log_params (pDst p) (gd, d) l))) -> P (mkNetwork ps' st'). Proof using. intros. unfold handleMessage, update_elections_data_net in *. break_match; repeat break_let; repeat find_inversion; [eapply_prop msg_refined_raft_net_invariant_request_vote'| eapply_prop msg_refined_raft_net_invariant_request_vote_reply'| eapply_prop msg_refined_raft_net_invariant_append_entries'| eapply_prop msg_refined_raft_net_invariant_append_entries_reply']; eauto; unfold send_packets in *; simpl in *; intros; subst; auto; find_apply_hyp_hyp; intuition. Qed. Lemma msg_refined_raft_invariant_handle_input' P : forall h inp net st' ps' gd out d l, msg_refined_raft_net_invariant_timeout' P -> msg_refined_raft_net_invariant_client_request' P -> handleInput h inp (snd (nwState net h)) = (out, d, l) -> update_elections_data_input h inp (nwState net h) = gd -> P net -> msg_refined_raft_intermediate_reachable net -> msg_refined_raft_intermediate_reachable (mkNetwork ps' st') -> (forall h', st' h' = update name_eq_dec (nwState net) h (gd, d) h') -> (forall p', In p' ps' -> In p' (nwPackets net) \/ In p' (send_packets h (@add_ghost_msg _ _ ghost_log_params h (gd, d) l))) -> P (mkNetwork ps' st'). Proof using. intros. unfold handleInput, update_elections_data_input in *. break_match; repeat break_let; repeat find_inversion; [eapply_prop msg_refined_raft_net_invariant_timeout'| eapply_prop msg_refined_raft_net_invariant_client_request']; eauto; subst; auto. Qed. Theorem msg_refined_raft_net_invariant' : forall P net, msg_refined_raft_net_invariant_init P -> msg_refined_raft_net_invariant_client_request' P -> msg_refined_raft_net_invariant_timeout' P -> msg_refined_raft_net_invariant_append_entries' P -> msg_refined_raft_net_invariant_append_entries_reply' P -> msg_refined_raft_net_invariant_request_vote' P -> msg_refined_raft_net_invariant_request_vote_reply' P -> msg_refined_raft_net_invariant_do_leader' P -> msg_refined_raft_net_invariant_do_generic_server' P -> msg_refined_raft_net_invariant_state_same_packet_subset' P -> msg_refined_raft_net_invariant_reboot' P -> msg_refined_raft_intermediate_reachable net -> P net. 
[H2| H2] [H3| H3]. injection H2; injection H3; intros; apply trans_equal with b; auto. case (H l2); injection H2; intros H4 H5; rewrite H5; auto. case (H l1); injection H3; intros H4 H5; rewrite H5; auto. apply H1 with (1 := H2) (2 := H3); auto. Qed. Theorem unique_key_perm : forall l1 l2, permutation l1 l2 -> unique_key l1 -> unique_key l2. Proof using. intros l1 l2 H; elim H; auto. intros (a1, b1) L1 L2 H0 H1 H2; apply unique_key_cons. intros b; red in |- *; intros H3; case (unique_key_in _ _ b _ H2). apply permutation_in with (2 := H3); auto. apply permutation_sym; auto. apply H1; apply unique_key_inv with (1 := H2); auto. intros (a1, b1) (a2, b2) L H0; apply unique_key_cons. intros b; red in |- *; simpl in |- *; intros [H1| H1]. case (unique_key_in _ _ b2 _ H0); auto. injection H1; intros H2 H3; rewrite H3; simpl in |- *; auto. case (unique_key_in _ _ b _ (unique_key_inv _ _ H0)); auto. apply unique_key_cons. intros b; red in |- *; simpl in |- *; intros H1; case (unique_key_in _ _ b _ H0); simpl in |- *; auto. apply unique_key_inv with (a := (a2, b2)); apply unique_key_inv with (1 := H0). Qed. Theorem unique_key_app : forall l1 l2, unique_key l1 -> unique_key l2 -> (forall a b c, In (a, b) l1 -> In (a, c) l2 -> False) -> unique_key (l1 ++ l2). Proof using. intros l1; elim l1; simpl in |- *; auto. intros (a1, ll1) l H l2 H0 H1 H2; apply unique_key_cons; auto. intros b; red in |- *; intros H3. case in_app_or with (1 := H3). change (~ In (a1, b) l) in |- *; apply unique_key_in with (1 := H0). intros H4; apply (H2 a1 ll1 b); auto. apply H; auto. apply unique_key_inv with (1 := H0); auto. intros a b c H3 H4; apply (H2 a b c); auto. Qed. Theorem unique_key_ulist : forall l : list (A * B), unique_key l -> ulist (map (fst (B:=_)) l). Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H H0; apply ulist_cons. inversion H0. red in |- *; intros H5; case in_map_inv with (1 := H5). intros (b2, l2); simpl in |- *; intros (Hb1, Hb2); case (H3 l2); auto. rewrite Hb2; auto. apply H; apply unique_key_inv with (1 := H0); auto. Qed. Theorem ulist_unique_key : forall l : list (A * B), ulist (map (fst (B:=_)) l) -> unique_key l. 
x = round Zceil x. Proof. intros x Hx. unfold round, Ztrunc. case Rlt_bool_spec. easy. intros [H|H]. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- cexp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. rewrite <- H. now rewrite Zfloor_IZR, Zceil_IZR. Qed.Theorem round_AW_UP : forall x, (0 <= x)%R -> round Zaway x = round Zceil x. Proof. intros x Hx. unfold round, Zaway. case Rlt_bool_spec. intros H. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- cexp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. easy. Qed.Theorem round_AW_DN : forall x, (x <= 0)%R -> round Zaway x = round Zfloor x. Proof. intros x Hx. unfold round, Zaway. case Rlt_bool_spec. easy. intros [H|H]. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- cexp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. rewrite <- H. now rewrite Zfloor_IZR, Zceil_IZR. Qed.Theorem generic_format_round : forall rnd { Hr : Valid_rnd rnd } x, generic_format (round rnd x). Proof with auto with typeclass_instances. intros rnd Zrnd x. destruct (total_order_T x 0) as [[Hx|Hx]|Hx]. rewrite <- (Ropp_involutive x). destruct (round_DN_or_UP rnd (- - x)) as [Hr|Hr] ; rewrite Hr. rewrite round_DN_opp. apply generic_format_opp. apply generic_format_round_pos... now apply Ropp_0_gt_lt_contravar. rewrite round_UP_opp. apply generic_format_opp. apply generic_format_round_pos... now apply Ropp_0_gt_lt_contravar. rewrite Hx. rewrite round_0... apply generic_format_0. now apply generic_format_round_pos. Qed.Theorem round_DN_pt : forall x, Rnd_DN_pt generic_format x (round Zfloor x). Proof with auto with typeclass_instances. intros x. split. apply generic_format_round... split. pattern x at 2 ; rewrite <- scaled_mantissa_mult_bpow. unfold round, F2R. simpl. apply Rmult_le_compat_r. apply bpow_ge_0. apply Zfloor_lb. intros g Hg Hgx. apply round_ge_generic... Qed.Theorem generic_format_satisfies_any : satisfies_any generic_format. Proof. split.exact generic_format_0. exact generic_format_opp.intros x. eexists. apply round_DN_pt. Qed.Theorem round_UP_pt : forall x, Rnd_UP_pt generic_format x (round Zceil x). Proof. intros x. rewrite <- (Ropp_involutive x). rewrite round_UP_opp. apply Rnd_UP_pt_opp. apply generic_format_opp. apply round_DN_pt. Qed.Theorem round_ZR_pt : forall x, Rnd_ZR_pt generic_format x (round Ztrunc x). Proof. intros x. split ; intros Hx. rewrite round_ZR_DN with (1 := Hx). apply round_DN_pt. rewrite round_ZR_UP with (1 := Hx). apply round_UP_pt. Qed.Lemma round_DN_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> round Zfloor x = 0%R. Proof. intros x ex Hx He. rewrite <- (F2R_0 beta (cexp x)). rewrite <- mantissa_DN_small_pos with (1 := Hx) (2 := He). now rewrite <- cexp_fexp_pos with (1 := Hx). Qed. Theorem round_DN_UP_lt : forall x, ~ generic_format x -> (round Zfloor x < x < round Zceil x)%R. 
fpad. Definition h_star := h_star p h. Definition GNMAC := GNMAC h fpad. Definition A_NMAC := x <-$ {0, 1}^(c + c); [b, _] <-$2 A _ _ (f_oracle GNMAC _ x) tt; ret b. Definition A_HMAC := x <-$ {0, 1}^b; [b, _] <-$2 A _ _ (f_oracle GHMAC _ x) tt; ret b. Theorem GHMAC_2K_GNMAC_equiv : forall k ls, let (k_Out, k_In) := splitVector b b k in let k' := Vector.append (h iv k_Out) (h iv k_In) in GHMAC_2K k ls = GNMAC k' ls. intuition. unfold GHMAC_2K, HMAC_spec.GHMAC_2K, GNMAC, HMAC_spec.GNMAC, b, HMAC_spec.b. remember (splitVector (c + p) (c + p) k) as z. destruct z. rewrite splitVector_append. unfold app_fpad, hash_words. simpl. trivial. Qed. Definition HMAC_RKA_A : OracleComp (Bvector b * Bvector c) (Bvector c) bool := k_Out <--$ OC_Query _ (opad, iv); k_In <--$ OC_Query _ (ipad, iv); [b, _] <--$2 $ A _ _ (f_oracle GNMAC _ (Vector.append k_Out k_In)) tt; $ ret b. Local Opaque evalDist. Theorem A_HMAC_RKA_equiv : Pr[A_HMAC] == Pr[RKA_G0 _ (Rnd b) (dual_f h) (BVxor b) HMAC_RKA_A]. unfold A_HMAC, RKA_G0, GHMAC, HMAC_RKA_A, GNMAC, HMAC_spec.GHMAC. comp_skip. simpl. repeat ( inline_first; comp_simp). comp_skip. eapply comp_spec_eq_impl_eq. eapply comp_spec_consequence. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => a = b)). trivial. intuition. unfold f_oracle. eapply comp_spec_ret; intuition. simpl. specialize (GHMAC_2K_GNMAC_equiv (Vector.append (x xor opad) (x xor ipad)) a0); intuition. rewrite splitVector_append in H1. unfold dual_f. eapply eq_trans. eapply H1. unfold GNMAC. f_equal. f_equal. f_equal. eapply BVxor_comm. f_equal. eapply BVxor_comm. intuition. destruct b2; simpl in *; subst; intuition. comp_simp. simpl. inline_first. comp_simp. intuition. Qed. Definition A_NMAC_G1 := x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_0 := [x1, x2] <-$2 ( x <-$ {0, 1}^(c + c); ret (splitVector c c x)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_1 := [x1, x2] <-$2 ( x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; ret (x1, x2)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Theorem A_NMAC_G1_0_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1_0]. unfold A_NMAC, A_NMAC_G1_0. inline_first. comp_skip. remember (splitVector c c x) as z. comp_simp. erewrite append_splitVector. reflexivity. trivial. Qed. Theorem A_NMAC_G1_0_1_equiv : Pr[A_NMAC_G1_0] == Pr[A_NMAC_G1_1]. unfold A_NMAC_G1_0, A_NMAC_G1_1. comp_skip. eapply Rnd_split_equiv. reflexivity. Qed. Theorem A_NMAC_G1_1_equiv : Pr[A_NMAC_G1_1] == Pr[A_NMAC_G1]. 
f: seg t R ⇒ B}. Definition transfinite_recursion_preliminary_form := ∀ A R B G, woset A R → G: SegFuncs A R B ⇒ B → ∃! F, F: A ⇒ B ∧ ∀t ∈ A, F[t] = G[F ↾ seg t R]. Definition transfinite_recursion_schema := ∀ A R γ, woset A R → (∀ f, ∃! y, γ f y) → ∃! F, is_function F ∧ dom F = A ∧ ∀t ∈ A, γ (F ↾ seg t R) F[t]. Fact transfinite_recursion_schema_to_preliminary_form : transfinite_recursion_schema → transfinite_recursion_preliminary_form. Proof with eauto; try congruence. intros Schema A R B G Hwo HG. set (λ f y, y = G[f]) as γ. pose proof (Schema A R γ Hwo) as [F [[HF [Hd Hrec]] Hu]]. { intros f. rewrite <- unique_existence. split. exists (G[f])... intros... } set {x ∊ A | F[x] ∈ B} as A'. replace A with A' in *. { assert (Hr: ran F ⊆ B). { intros y Hy. apply ranE in Hy as [x Hp]. apply domI in Hp as Hx. rewrite Hd in Hx. apply func_ap in Hp... apply SepE2 in Hx... } rewrite <- unique_existence. split. exists F. split. split... intros t Ht. rewrite Hrec... intros f1 f2 [[Hf1 [Hd1 Hr1]] H1] [[Hf2 [Hd2 Hr2]] H2]. rewrite <- Hu... rewrite <- Hu at 1... } eapply transfinite_induction... split. - intros x Hx. apply SepE1 in Hx... - intros t Ht Hsub. apply SepI... rewrite Hrec... eapply ap_ran... apply SepI. + apply PowerAx. intros p Hp. apply restrE1 in Hp as [a [b [Ha [Hp Heq]]]]. subst p. apply Hsub in Ha. apply SepE in Ha as [Ha HFa]. apply func_ap in Hp... apply CPrdI... + exists t. split... split; [|split]. * apply restr_func... * apply restr_dom... eapply sub_trans. apply Hsub. rewrite Hd. intros x Hx. apply SepE1 in Hx... * intros y Hy. apply ranE in Hy as [x Hp]. apply restrE2 in Hp as [Hp Hx]. apply func_ap in Hp... apply Hsub in Hx. apply SepE2 in Hx... Qed. Local Fact sometimes_replacement_is_simpler_than_separation : ∀ A, {𝒫 a | a ∊ A} = {x ∊ 𝒫 𝒫 ⋃A | ∃a ∈ A, x = 𝒫 a}. Proof with auto. intro. ext Hx. - apply ReplAx in Hx as [a [Ha Heq]]. subst x. apply SepI. apply ex2_10... exists a. split... - apply SepE in Hx as [_ [a [Ha Heq]]]. subst x. apply ReplI... Qed. Theorem transfinite_recursion : transfinite_recursion_schema. 
Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Malloc. Require Import Coq.Lists.List Bedrock.Platform.SinglyLinkedList.Set Implicit Arguments. Module Type LIST_SEGMENT. Parameter lseg : list W -> W -> W -> HProp. Axiom lseg_extensional : forall ls p p', HProp_extensional (lseg ls p p'). Axiom nil_bwd : forall (p p' : W), [| p = p' |] ===> lseg nil p p'. Axiom nil_bwd' : forall ls (p p' : W), p = p' -> [| ls = nil |] ===> lseg ls p p'. Axiom append_bwd : forall p' ls p, (Ex ls', Ex x, Ex p'', [| ls = ls' ++ x :: nil |] * lseg ls' p p'' * [| freeable p'' 2 |] * [| p'' <> 0 |] * (p'' ==*> x, p')) ===> lseg ls p p'. Axiom sll_fwd : forall ls (p p' : W), p' = 0 -> lseg ls p p' ===> sll ls p. End LIST_SEGMENT.Module ListSegment : LIST_SEGMENT. Open Scope Sep_scope. Fixpoint lseg (ls : list W) (p p' : W) : HProp := match ls with | nil => [| p = p' |] | x :: ls' => [| freeable p 2 |] * [| p <> 0 |] * Ex p'', (p ==*> x, p'') * lseg ls' p'' p' end. Theorem lseg_extensional : forall ls (p p' : W), HProp_extensional (lseg ls p p'). destruct ls; reflexivity. Qed. Theorem nil_bwd : forall (p p' : W), [| p = p' |] ===> lseg nil p p'. sepLemma. Qed. Theorem nil_bwd' : forall ls (p p' : W), p = p' -> [| ls = nil |] ===> lseg ls p p'. destruct ls; sepLemma. Qed. Theorem append_bwd' : forall x p' ls p, (Ex p'', lseg ls p p'' * [| freeable p'' 2 |] * [| p'' <> 0 |] * (p'' ==*> x, p')) ===> lseg (ls ++ x :: nil) p p'. induction ls; sepLemma. etransitivity; [ | apply IHls ]; sepLemma. Qed. Theorem append_bwd : forall p' ls p, (Ex ls', Ex x, Ex p'', [| ls = ls' ++ x :: nil |] * lseg ls' p p'' * [| freeable p'' 2 |] * [| p'' <> 0 |] * (p'' ==*> x, p')) ===> lseg ls p p'. sepLemma; etransitivity; [ | apply append_bwd' ]; sepLemma. Qed. Theorem sll_fwd : forall ls (p p' : W), p' = 0 -> lseg ls p p' ===> sll ls p. 
l -> f x = true). Proof. induction l; simpl; intuition. destruct (andb_prop _ _ H1). congruence. destruct (andb_prop _ _ H1); auto. assert (forallb l = true). apply H0; intuition. rewrite H1; auto. Qed. Lemma forallb_app : forall l1 l2, forallb (l1++l2) = forallb l1 && forallb l2. Proof. induction l1; simpl. solve[auto]. case (f a); simpl; solve[auto]. Qed. Fixpoint filter (l:list A) : list A := match l with | nil => nil | x :: l => if f x then x::(filter l) else filter l end. Lemma filter_In : forall x l, In x (filter l) <-> In x l /\ f x = true. Proof. induction l; simpl. intuition. intros. case_eq (f a); intros; simpl; intuition congruence. Qed. Fixpoint find (l:list A) : option A := match l with | nil => None | x :: tl => if f x then Some x else find tl end. Lemma find_some l x : find l = Some x -> In x l /\ f x = true. Proof. induction l as [|a l IH]; simpl; [easy| ]. case_eq (f a); intros Ha Eq. * injection Eq as ->; auto. * destruct (IH Eq); auto. Qed. Lemma find_none l : find l = None -> forall x, In x l -> f x = false. Proof. induction l as [|a l IH]; simpl; [easy|]. case_eq (f a); intros Ha Eq x IN; [easy|]. destruct IN as [<-|IN]; auto. Qed. Fixpoint partition (l:list A) : list A * list A := match l with | nil => (nil, nil) | x :: tl => let (g,d) := partition tl in if f x then (x::g,d) else (g,x::d) end. Theorem partition_cons1 a l l1 l2: partition l = (l1, l2) -> f a = true -> partition (a::l) = (a::l1, l2). Proof. simpl. now intros -> ->. Qed. Theorem partition_cons2 a l l1 l2: partition l = (l1, l2) -> f a=false -> partition (a::l) = (l1, a::l2). Proof. simpl. now intros -> ->. Qed. Theorem partition_length l l1 l2: partition l = (l1, l2) -> length l = length l1 + length l2. Proof. revert l1 l2. induction l as [ | a l' Hrec]; intros l1 l2. - now intros [= <- <- ]. - simpl. destruct (f a), (partition l') as (left, right); intros [= <- <- ]; simpl; rewrite (Hrec left right); auto. Qed. Theorem partition_inv_nil (l : list A): partition l = ([], []) <-> l = []. 
(ind_params m) + #|ind_bodies m|) xpred0) (decl_type c0). { eapply nth_error_smash_onfvs in hnth. 2:{ apply on_free_vars_ctx_smash => //. eapply wf_local_closed_context in wfargs. now move: wfargs; rewrite -app_context_assoc => /onfvs_app. } len in hnth. move/andP: hnth => [] _ o. red; rewrite -o shiftnP_add. lia_f_equal. } erewrite <-(trans_lift _ _); tea. have fvslift : on_free_vars (shiftnP (n' + 1 + context_assumptions (ind_params m) + #|ind_bodies m|) xpred0) (lift 1 n' (decl_type c0)). { rewrite -2!shiftnP_add Nat.add_comm. eapply on_free_vars_lift_impl. rewrite !shiftnP_add //. } rewrite (trans_subst (shiftnP 1 (shiftnP (context_assumptions (ind_params m) + #|ind_bodies m|) xpred0)) xpred0). { eapply on_free_vars_subst; [eapply on_free_vars_projs|]. rewrite projs_length !shiftnP_add Nat.add_assoc //. } { eapply (inds_is_open_terms [] ind). } f_equal. erewrite (trans_subst _ (shiftnP 1 xpred0)); tea. 2:{ eapply on_free_vars_projs. } now rewrite trans_projs. } { cbn. move: ind_sorts. rewrite /check_ind_sorts. destruct Universe.is_prop => //. destruct Universe.is_sprop => //. intuition auto. rewrite /PCUICLookup.global_ext_constraints. destruct indices_matter => //. now eapply (trans_type_local_ctx (Σ := (Σ0, ind_universes m))). } { intros v indv. specialize (onIndices v indv). move: onIndices. rewrite /ind_respects_variance. rewrite indv in onVariance. eapply variance_universes_insts in onVariance as [univs' [u [u' [eqv hunivs cu cu' equlen eqvlen equ' cli equ]]]]. cbn [variance_universes ind_universes trans_minductive_body]. rewrite eqv. cbn [cstr_args trans_constructor_body]. cbn [ind_params trans_minductive_body]. have clpars : is_closed_context (ind_params m). { now eapply wf_local_closed_context in onParams. } rewrite -(trans_smash_context xpred0 []) //. have wfindices := !! wf_ind_indices onind. have fvsindices: on_free_vars_ctx (shiftnP (#|ind_params m|) xpred0) (ind_indices idecl). { move/wf_local_closed_context: wfindices; rewrite on_free_vars_ctx_app => /andP[] //. } rewrite -(trans_smash_context (shiftnP (#|ind_params m|) xpred0) []) //. rewrite -(trans_expand_lets_ctx xpred0 (shiftnP (#|ind_params m|) xpred0)) //. rewrite on_free_vars_ctx_smash //. rewrite -!trans_subst_instance_ctx. have wf_ext : wf_global_ext Σ0 (ind_universes m). { destruct (ind_universes m) eqn:equniv => //. cbn. split => //. cbn. now eapply on_udecl_on_udecl_prop. } eapply (trans_cumul_ctx_rel' (Σ := (Σ0, univs')) (Γ' := (smash_context [] (ind_params m))@[u'])) => //. { rewrite subst_instance_expand_lets_ctx. rewrite !subst_instance_smash. rewrite -[_ ,,, _]app_context_nil_l app_context_assoc. eapply wf_local_expand_lets. rewrite app_context_nil_l. eapply wf_local_smash_end. rewrite -subst_instance_app_ctx. eapply wf_local_subst_instance; tea. } { rewrite subst_instance_expand_lets_ctx. rewrite !subst_instance_smash. rewrite -[_ ,,, _]app_context_nil_l app_context_assoc. eapply wf_local_expand_lets. rewrite app_context_nil_l. eapply wf_local_smash_end. rewrite -subst_instance_app_ctx. eapply wf_local_subst_instance; tea. } { now len. } { repeat apply assumption_context_app_inv; pcuic. } { repeat apply assumption_context_app_inv; pcuic. } } + cbn. eapply (trans_on_context _ _ onParams). + cbn. rewrite context_assumptions_map //. Qed.Lemma trans_wf_ext {cf} {Σ : global_env_ext} : wf_ext Σ -> wf_ext_trans Σ. Proof. intros; split. now eapply trans_wf. destruct X. now eapply trans_on_udecl. Qed. Theorem expand_lets_sound {cf} {Σ : global_env_ext} {Γ t T} {wfΣ : wf Σ} : typing Σ Γ t T -> typing (H := cf' cf) (trans_global Σ) (trans_local Γ) (trans t) (trans T). 
Require Import Coq.Init.Byte. Require Import Coq.Lists.List. Require Coq.Vectors.Vector.Require Import Cava.Util.BitArithmetic. Require Import Cava.Util.List. Require Import Cava.Util.Vector. Require Import AesSpec.AddRoundKey. Require Import AesSpec.MixColumns. Require Import AesSpec.ShiftRows. Require Import AesSpec.SubBytes. Require Import AesSpec.Sbox. Require Import AesSpec.StateTypeConversions.Section SubBytesShiftRows. Lemma sub_byte_shift_row_once_comm : forall row, shift_row_once (map forward_sbox row) = map forward_sbox (shift_row_once row). Proof. intros. destruct row; [reflexivity|]. simpl. rewrite map_app. reflexivity. Qed. Lemma sub_byte_shift_row_comm : forall row shift, shift_row (map forward_sbox row) shift = map forward_sbox (shift_row row shift). Proof. intros. generalize dependent row. induction shift; [reflexivity|]. intros. simpl. rewrite <- IHshift. rewrite sub_byte_shift_row_once_comm. reflexivity. Qed. Lemma sub_bytes_shift_rows_start_comm : forall st n, shift_rows_start (sub_bytes st) n = sub_bytes (shift_rows_start st n). Proof. induction st; [reflexivity|]. intro n. unfold shift_rows_start. simpl. rewrite sub_byte_shift_row_comm. unfold shift_rows_start in IHst. rewrite IHst. reflexivity. Qed. Theorem sub_bytes_shift_rows_comm : forall st, shift_rows (sub_bytes st) = sub_bytes (shift_rows st). 
| xH => match m with | Leaf => Leaf | Node Leaf o Leaf => Leaf | Node l o r => Node l None r end | xO ii => match m with | Leaf => Leaf | Node l None Leaf => match remove ii l with | Leaf => Leaf | mm => Node mm None Leaf end | Node l o r => Node (remove ii l) o r end | xI ii => match m with | Leaf => Leaf | Node Leaf None r => match remove ii r with | Leaf => Leaf | mm => Node Leaf None mm end | Node l o r => Node l o (remove ii r) end end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. induction i; simpl; auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x. Proof. induction i; destruct m; simpl; auto. Qed. Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None. Proof. exact gempty. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. induction i; intros; destruct j; destruct m; simpl; try rewrite <- (gleaf A i); auto; try apply IHi; congruence. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then Some x else get i m. Proof. intros. destruct (peq i j); [ rewrite e; apply gss | apply gso; auto ]. Qed. Theorem gsident: forall (A: Type) (i: positive) (m: t A) (v: A), get i m = Some v -> set i v m = m. Proof. induction i; intros; destruct m; simpl; simpl in H; try congruence. rewrite (IHi m2 v H); congruence. rewrite (IHi m1 v H); congruence. Qed. Theorem set2: forall (A: Type) (i: elt) (m: t A) (v1 v2: A), set i v2 (set i v1 m) = set i v2 m. Proof. induction i; intros; destruct m; simpl; try (rewrite IHi); auto. Qed. Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf. Proof. destruct i; simpl; auto. Qed. Theorem grs: forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None. 
BVxor_comm end.Ltac xorTac := repeat xorTac_once; simpl; try reflexivity; try eapply in_getAllBvectors. Section OTP. Variable c : nat. Definition OTP (x : Bvector c) : Comp (Bvector c) := p <-$ {0, 1}^c; ret (BVxor c p x). Theorem OTP_eq_Rnd: forall (x y : Bvector c), D (OTP x) y == D ({0, 1}^c) y. intuition. unfold OTP. r_ident_r. eapply (dist_iso (BVxor c x) (BVxor c x)); intuition; xorTac. Qed.End OTP. *) Section OTP. Variable T : Set. Hypothesis T_EqDec : EqDec T. Variable RndT : Comp T. Variable T_op : T -> T -> T. Hypothesis op_assoc : forall x y z, T_op (T_op x y) z = T_op x (T_op y z). Variable T_inverse : T -> T. Variable T_ident : T. Hypothesis inverse_l_ident : forall x, T_op (T_inverse x) x = T_ident. Hypothesis inverse_r_ident : forall x, T_op x (T_inverse x) = T_ident. Hypothesis ident_l : forall x, T_op T_ident x = x. Hypothesis ident_r : forall x, T_op x T_ident = x. Hypothesis RndT_uniform : forall x y, comp_spec (fun a b => a = x <-> b = y) RndT RndT. Theorem all_in_support : forall y, In y (getSupport RndT) -> forall x, In x (getSupport RndT). intuition. eapply getSupport_In_evalDist. intuition. eapply getSupport_In_evalDist. eapply H. rewrite <- H0. eapply comp_spec_impl_eq. trivial. Qed. Theorem OTP_inf_th_sec_l : forall (x : T), comp_spec eq RndT (r <-$ RndT; ret (T_op x r)). intros. eapply (@comp_spec_eq_trans_l _ _ _ _ RndT (x <-$ RndT; ret x)). eapply comp_spec_eq_symm. eapply comp_spec_right_ident. eapply comp_spec_seq. trivial. trivial. eapply comp_spec_symm. eapply (comp_spec_iso (T_op x) (T_op (T_inverse x))); intuition. rewrite <- op_assoc. rewrite inverse_r_ident. eauto. rewrite <- op_assoc. rewrite inverse_l_ident. eauto. eapply all_in_support; eauto. intuition. subst. eapply comp_spec_eq_refl. Qed. Theorem OTP_inf_th_sec_r : forall (x : T), comp_spec eq RndT (r <-$ RndT; ret (T_op r x)). intros. eapply (@comp_spec_eq_trans_l _ _ _ _ RndT (x <-$ RndT; ret x)). eapply comp_spec_eq_symm. eapply comp_spec_right_ident. eapply comp_spec_seq. trivial. trivial. eapply comp_spec_symm. eapply (comp_spec_iso (fun b => T_op b x) (fun b => T_op b (T_inverse x))); intuition. rewrite op_assoc. rewrite inverse_l_ident. eauto. rewrite op_assoc. rewrite inverse_r_ident. eauto. eapply all_in_support; eauto. intuition. subst. eapply comp_spec_eq_refl. Qed.End OTP. Section xor_OTP. Variable n : nat. Theorem xor_OTP: forall (x : Bvector n), comp_spec eq (Rnd n) (r <-$ Rnd n; ret (BVxor n x r)). eapply OTP_inf_th_sec_l; intuition. eapply BVxor_assoc. eapply BVxor_same_id. eapply BVxor_same_id. eapply BVxor_id_l. eapply comp_spec_rnd. Qed. Theorem xor_OTP_eq: forall (x y : Bvector n), evalDist (r <-$ Rnd n; ret (BVxor n x r)) y == evalDist (Rnd n) y. 
Require Export Pspminus. Section Preduce. Load "hCoefStructure". Load "hOrderStructure". Load "hSpminus". Inductive inPolySet : list (Term A n) -> list (poly A0 eqA ltM) -> Prop := | incons : forall (a : Term A n) (p : list (Term A n)) (H : canonical A0 eqA ltM (pX a p)) (P : list (poly A0 eqA ltM)), inPolySet (pX a p) (exist (fun l0 : list (Term A n) => canonical A0 eqA ltM l0) (pX a p) H :: P) | inskip : forall (a : poly A0 eqA ltM) (p : list (Term A n)) (P : list (poly A0 eqA ltM)), inPolySet p P -> inPolySet p (a :: P). Hint Resolve incons inskip. Lemma inPolySet_imp_canonical : forall (p : list (Term A n)) (L : list (poly A0 eqA ltM)), inPolySet p L -> canonical A0 eqA ltM p. intros p L H'; elim H'; auto. Qed. Hint Resolve inPolySet_imp_canonical. Lemma not_nil_in_polySet_elm : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), inPolySet p Q -> p <> pO A n. intros Q p H'; elim H'; auto. intros a p0 H'0 H'1; red in |- *; intros H'2; inversion H'2. Qed. Theorem not_nil_in_polySet : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), ~ inPolySet (pO A n) Q. 
Require Import Coq.Logic.Classical_Prop. Require Import Coq.Relations.Operators_Properties. Require Import Coq.Relations.Relation_Operators. Require Import Main.Experiments.Overtree.Overtree. Require Import Main.Tactics.Module OvertreeTheorems (Graph : Overtree). Import Graph. #[local] Arguments clos_refl_trans {A} _ _ _. #[local] Arguments clos_refl_trans_1n {A} _ _ _. #[local] Arguments clos_refl_trans_n1 {A} _ _ _. #[local] Hint Constructors clos_refl_trans : main. #[local] Hint Constructors clos_refl_trans_1n : main. #[local] Hint Constructors clos_refl_trans_n1 : main. #[local] Hint Resolve clos_rt1n_rt : main. #[local] Hint Resolve clos_rt_rt1n : main. #[local] Hint Resolve clos_rtn1_rt : main. #[local] Hint Resolve clos_rt_rtn1 : main. Theorem rootUniquelyReachable : forall n, verticallyReachable n root -> n = root. Proof. clean. assert (clos_refl_trans_n1 proxies n root); magic. pose proof rootProxy. induction H0; magic. assert (y = z); magic. Qed. #[export] Hint Resolve rootUniquelyReachable : main. Theorem rootProxyUniqueness : forall n, proxy n = n -> n = root. Proof. clean. induction (rootReach n); magic. Qed. #[export] Hint Resolve rootProxyUniqueness : main. Theorem rootReachUniqueness : forall n1, (forall n2, verticallyReachable n1 n2) -> n1 = root. Proof. magic. Qed. #[export] Hint Resolve rootReachUniqueness : main. Definition reachable := clos_refl_trans edge. #[export] Hint Unfold reachable : main. Theorem horizontalSoundness : forall n1 n2, horizontallyReachable n1 n2 -> reachable n1 n2. Proof. clean. induction H; magic. apply rt_trans with (y := y); magic. Qed. #[export] Hint Resolve horizontalSoundness : main. Theorem horizontalCovalency : forall n1 n2, horizontallyReachable n1 n2 -> proxy n1 = proxy n2. 
using m_nodupvars. * erewrite find_class_name; eauto. eapply staterep_extract; eauto. exists objs, objs', d; intuition; eauto. rewrite sep_swap34, sep_swap23, sep_swap, sep_swap67, sep_swap56, sep_swap45, sep_swap34, sep_swap23. eapply sep_imp; eauto. repeat apply sep_imp'; auto. -- unfold instance_match; rewrite find_inst_gss. rewrite Ptrofs.unsigned_repr; auto. -- apply staterep_objs_not_in; auto. * apply Hself. rewrite PTree.gso; auto. eapply prefix_injective'. left. prove_str_to_pos_neq. - assert (M.MapsTo (o, fid) cid (instance_methods caller)) by (apply Hinstmth; simpl; omega). rewrite sep_swap45, sep_swap34, sep_swap23, sep_swap in Hmem. eapply subrep_extract in Hmem as (instb & instco & xs & xs' &?& Hinstco &?& Hmem); eauto. pose proof Hinstco; erewrite <-(find_class_name cid), <-(find_method_name fid) in Hinstco; eauto. assert (eval_expr tge e le m (Eaddrof (Evar (prefix_out fid o) (type_of_inst (prefix_fun fid cid))) (pointer_of (type_of_inst (prefix_fun fid cid)))) (Vptr instb Ptrofs.zero)) by (constructor; constructor; auto). assert (Cop.sem_cast (Vptr instb Ptrofs.zero) (Clight.typeof (Eaddrof (Evar (prefix_out o fid) (type_of_inst (prefix_fun fid cid))) (pointer_of (type_of_inst (prefix_fun fid cid))))) (pointer_of (type_of_inst (prefix_fun fid cid))) m = Some (Vptr instb Ptrofs.zero)) by auto. rewrite sep_swap23, sep_swap in Hmem. edestruct CallSpec as (ve_f & m' & ? & Spec_f' & EvalF & ? & Hmem'); eauto. erewrite find_class_name in Hmem'; eauto. clear Hmem. eapply method_spec_eq with (2 := Spec_f) in Spec_f'; eauto; subst. rewrite <- (Ptrofs.unsigned_repr d), <- Ptrofs.add_unsigned in EvalF; eauto. assert (1 < Datatypes.length (m_out callee))%nat by (rewrite Hout; simpl; omega). rewrite sep_swap, sep_swap56, sep_swap45, sep_swap34, sep_swap23, sep_swap78, sep_swap67, sep_swap56, sep_swap45, sep_swap34 in Hmem'. edestruct exec_funcall_assign as (m'' & le' & ? & Hmem'' & Hself); eauto; try rewrite Hout; eauto. clear Hmem'. exists m'', le'; split. + change E0 with (Eapp E0 (Eapp E0 E0)). unfold funcall. rewrite <-Hout. eapply exec_Sseq_1; eauto. change le with (set_opttemp None Vundef le). econstructor; simpl; eauto using eval_exprlist. + apply match_states_conj; intuition; eauto using m_nodupvars. erewrite find_class_name; eauto. eapply staterep_extract; eauto. exists objs, objs', d; intuition; eauto. rewrite sep_swap45, sep_swap34, sep_swap23, sep_swap. eapply subrep_extract; eauto. exists instb, instco, xs, xs'; intuition. rewrite Env.adds_opt_is_adds; auto. rewrite sep_swap56, sep_swap45, sep_swap34, sep_swap23, sep_swap78, sep_swap67, sep_swap56, sep_swap45, sep_swap34, sep_swap45. eapply sep_imp; eauto using fieldsrep_any_empty. repeat apply sep_imp'; eauto. * unfold instance_match; rewrite find_inst_gss. rewrite Ptrofs.unsigned_repr; auto. * apply staterep_objs_not_in; auto. Qed. End MatchStates. Hypothesis SpecIO : forall ome ome' clsid f vos rvos, Forall (fun vo => vo <> None) vos -> stmt_call_eval prog ome clsid f vos ome' rvos -> Forall (fun x => x <> None) rvos. Hypothesis NO_NAKED_VARS: Forall_methods (fun m => No_Naked_Vars m.(m_body)) prog. Theorem mutual_correctness: (forall p me ve s me' ve' ownerid owner prog' callerid caller m e le outb_co sb sofs P, suffix p prog -> stmt_eval p me ve s (me', ve') -> find_class ownerid prog = Some (owner, prog') -> find_method callerid owner.(c_methods) = Some caller -> occurs_in s caller.(m_body) -> m |= match_states gcenv prog owner caller (me, ve) (e, le) sb sofs outb_co ** P -> exists m' le', exec_stmt_fe function_entry2 tge e le m (translate_stmt (rev prog) owner caller s) E0 le' m' Out_normal /\ m' |= match_states gcenv prog owner caller (me', ve') (e, le') sb sofs outb_co ** P) /\ (forall p me cid fid c f vs rvs prog' me', suffix p prog -> stmt_call_eval p me cid fid (map Some vs) me' (map Some rvs) -> find_class cid prog = Some (c, prog') -> find_method fid c.(c_methods) = Some f -> wt_vals vs f.(m_in) -> wt_mem me prog c -> call_spec c f vs rvs me me'). 
Require Import Monads.Monad. Require Import Tactics.CpdtTactics.Set Implicit Arguments. Module Option <: Monad. Definition m := option. Definition ret {A : Type} := @Some A. Definition bind {A B : Type} (n : option A) (f : A -> option B) := match n with | Some x => f x | None => None end. Infix ">>=" := bind (at level 50, left associativity). Ltac nake := unfold m; unfold ret; unfold bind. Theorem left_id : forall (A B : Type) (x : A) (f : A -> m B), ret x >>= f = f x. Proof. nake. crush. Qed. Theorem right_id : forall (A : Type) (x : m A), x >>= ret = x. Proof. nake. intros; destruct x; crush. Qed. Theorem bind_assoc : forall (A B C : Type) (n : m A) (f : A -> m B) (g : B -> m C), (n >>= f) >>= g = n >>= (fun x => f x >>= g). 
right;apply lt_omega_limit. + apply seq_mono_intro ... Qed. Lemma ksi_plus_seq_n' : forall (m:nat), ksi + seq m <= beta. Proof. intro m ; destruct (Nat.le_gt_cases n m) as [H | H]. - apply ksi_plus_seq_n;auto. - apply le_trans with (ksi + seq n). + apply plus_mono_r_weak;auto. apply mono_seq_weak2; auto with arith. + apply ksi_plus_seq_n; auto with arith. Qed. Lemma ksi_plus_beta : ksi + beta <= beta. Proof. unfold beta at 1; unfold omega_limit. rewrite alpha_plus_sup. - apply sup_least_upper_bound; eauto with schutte. + apply R1 with ordinal (ge ksi). * apply plus_ordering; auto. * apply seq_range_countable;auto. * intro; split. + intros y [z [H1 H2]]; subst y. destruct H1 as [x [_ H2]]; subst z; apply ksi_plus_seq_n'. - now exists (seq 0), 0. - eauto with schutte. Qed. Lemma ksi_plus_beta_eq : ksi + beta = beta. Proof. apply le_antisym. - apply ksi_plus_beta. - apply le_plus_r;auto. Qed. End ksi_fixed. Lemma AP_unbounded_0 : alpha < beta /\ AP beta. Proof. split. - apply alpha_lt_beta. - split. + apply zero_lt_beta. + intros; apply ksi_plus_beta_eq; eauto with schutte. Qed.End AP_Unbounded.Theorem AP_unbounded : Unbounded AP. Proof. intro x. exists (omega_limit (fix seq (n : nat) : Ord := match n with | O => succ x | S p => seq p + seq p end)). destruct (AP_unbounded_0 x); now split. Qed.Section AP_closed. Variable M : Ensemble Ord. Hypothesis OM : Included M AP. Hypothesis inhM : Inhabited _ M. Hypothesis denM : countable M. Remark supM_gt0 : zero < |_| M. Proof. destruct inhM as [x H]; apply lt_le_trans with x. - now destruct (OM H). - apply sup_upper_bound; auto with schutte. Qed. Lemma AP_sup : In AP (|_| M). Proof. split. - apply supM_gt0. - intros ksi Hksi; destruct (@lt_sup_exists_lt M denM ksi Hksi) as [alpha [Malpha ksialpha]]. apply le_antisym. + rewrite alpha_plus_sup; auto. * apply sup_mono; auto. { apply R1 with ordinal (ge ksi); auto. - apply plus_ordering; eauto with schutte. - split. } { intros x H; destruct H as [beta [Mbeta ebeta]]. case (@lt_or_ge beta alpha);auto with schutte. - exists alpha; split;auto. subst x; case (OM Mbeta). intros H1 H2; right. apply lt_le_trans with (ksi + alpha). + apply plus_mono_r; eauto with schutte. + left. destruct (OM Malpha) as [H3 H4]; now apply H4. - exists beta; split; auto. left; subst x. case (OM Mbeta); intros H1 H2; apply H2. apply lt_le_trans with alpha;auto. } + apply le_plus_r;eauto with schutte. Qed. End AP_closed. Theorem AP_closed : Closed AP. 
destruct H. intuition. intuition. econstructor. intuition. eapply eb_symm. eauto. left. eapply ea_refl. eapply eb_symm. eauto. specialize (IHl y). intuition. destruct H2. intuition. econstructor. split. eauto. intuition. destruct H. intuition. left. eapply eb_trans. eapply eb_symm. eauto. eapply ea_func. trivial. right. specialize (IHl y). intuition. eapply H2. econstructor. intuition. eauto. trivial. Qed. Theorem map_NoDup_gen : forall (ls : list A), NoDup_gen ea ls -> NoDup_gen eb (map f ls). induction ls; intuition; simpl in *. econstructor. inversion H; clear H; subst. econstructor. intuition. eapply H2. eapply In_gen_map_iff in H. destruct H. intuition. eapply In_gen_equiv_compat; [ eauto | eauto | idtac | idtac]. eapply eb_func. eauto. trivial. eauto. Qed. End NoDup_gen_map.Require Import FCF.RepeatCore. Theorem In_gen_weaken : forall (A : Type)(e1 e2 : A -> A -> Prop) ls a, In_gen e1 a ls -> (forall a', e1 a a' -> e2 a a') -> In_gen e2 a ls. induction ls; intuition; simpl in *. intuition. Qed.Lemma flatten_NoDup_gen : forall (A : Set)(ls : list (list A)), NoDup_gen (fun a b => a <> nil /\ a = b) ls -> (forall x, In x ls -> NoDup x) -> (forall x1 x2, In x1 ls -> In x2 ls -> x1 <> x2 -> NoDup (x1 ++ x2)) -> NoDup (flatten ls). induction ls; intuition; simpl in *. econstructor. inversion H; clear H; subst. eapply app_NoDup; intuition. eapply in_flatten in H3. destruct H3. intuition. eapply app_NoDup_inv. eapply H1. right. eapply H6. left. reflexivity. intuition. subst. eapply H4. eapply In_gen_weaken. exact H6. intuition. subst. subst. simpl in *. intuition. eauto. eauto. eapply in_flatten in H2. destruct H2. intuition. eapply app_NoDup_inv. eapply H1. right. eapply H6. left. reflexivity. intuition. subst. eapply H4. eapply In_gen_weaken. exact H6. intuition. subst. subst. simpl in *. intuition. eauto. eauto. Qed.Theorem NoDup_gen_weaken : forall (A : Type)(e1 e2 : A -> A -> Prop) ls, NoDup_gen e1 ls -> (forall a1 a2, e2 a1 a2 -> e1 a1 a2) -> NoDup_gen e2 ls. induction ls; intuition; simpl in *. econstructor. inversion H; clear H; subst. econstructor. intuition. eapply H3. eapply In_gen_weaken; eauto. eauto. Qed.Theorem In_gen_zip_fst : forall (A B : Set)(ea : A -> A -> Prop)(lsa : list A)(lsb : list B) a b, In_gen (fun a b => ea (fst a) (fst b)) (a, b) (zip lsa lsb) -> In_gen ea a lsa. induction lsa; intuition; simpl in *. destruct lsb; simpl in *; intuition. right. eauto. Qed. Theorem NoDup_gen_zip_fst : forall (A B : Set)(ea : A -> A -> Prop)(lsa : list A)(lsb : list B), NoDup_gen ea lsa -> NoDup_gen (fun a b => ea (fst a) (fst b)) (zip lsa lsb). 
loc_null_hasTy t : base_lit_hasTy (LitLoc null) (arrayT t) | structRef_null_hasTy ts : base_lit_hasTy (LitLoc null) (structRefT ts) | ptr_null_hasTy : base_lit_hasTy (LitLoc null) ptrT . Definition bin_op_ty (op:bin_op) (t:ty) : option (ty * ty * ty) := match op with | PlusOp | MinusOp | MultOp | QuotOp | RemOp | ShiftLOp | ShiftROp | OrOp | AndOp => Some (t, t, t) | LtOp | LeOp => Some (t, t, boolT) | _ => None end. Definition un_op_ty (op:un_op) : option (ty * ty) := match op with | NegOp => Some (boolT, boolT) | _ => None end. Definition is_intTy (t: ty) : bool := match t with | baseT uint64BT => true | baseT uint32BT => true | baseT byteBT => true | _ => false end. Definition is_byteTy (t: ty) : bool := match t with | baseT byteBT => true | _ => false end. Definition is_unboxed_baseTy (t: ty) : bool := match t with | baseT _ => true | arrayT _ => true | structRefT _ => true | ptrT => false | _ => false end. Definition is_unboxedTy (t: ty) : bool := match t with | baseT _ => true | arrayT _ => true | structRefT _ => true | ptrT => false | sumT t1 t2 => is_unboxed_baseTy t1 && is_unboxed_baseTy t2 | _ => false end. Fixpoint is_comparableTy (t: ty) : bool := match t with | baseT _ => true | prodT t1 t2 => is_comparableTy t1 && is_comparableTy t2 | sumT t1 t2 => is_comparableTy t1 && is_comparableTy t2 | arrayT _ => true | structRefT _ => true | ptrT => false | _ => false end. Lemma unboxed_baseTy_unboxed (t1: ty): is_unboxed_baseTy t1 = true → is_unboxedTy t1 = true. Proof. destruct t1 => //=. Qed. Lemma unboxedTy_comparable (t: ty): is_unboxedTy t = true → is_comparableTy t = true. Proof. induction t => //=. intros (?&?)%andb_prop. rewrite IHt1 //=; eauto using unboxed_baseTy_unboxed. Qed. Fixpoint flatten_ty (t: ty) : list ty := match t with | prodT t1 t2 => flatten_ty t1 ++ flatten_ty t2 | baseT unitBT => [] | _ => [t] end. Definition refT (t:ty) : ty := structRefT (flatten_ty t). Theorem array_null_hasTy t : base_lit_hasTy (LitLoc null) (refT t). Proof. apply structRef_null_hasTy. Qed. Theorem ty_size_ge_0 : forall t, (0 <= ty_size t)%Z. Proof. induction t; simpl; try lia. destruct t; lia. Qed. Theorem ty_size_length t : Z.to_nat (ty_size t) = length (flatten_ty t). 
cs. Proof. unfold read_range; intros. safestep. auto. auto. safestep. step; subst. rewrite firstn_S_selN_expand with (def := $0). rewrite fold_left_app; simpl. erewrite selN_map by omega; auto. rewrite map_length; omega. all: step. Unshelve. exact tt. eauto. Qed. Lemma vsupd_range_xcrash_firstn' : forall l F a n vs cs' d', (F * arrayN ptsto_subset a (vsupd_range vs (firstn n l)))%pred d' -> length l <= length vs -> crash_xform (rep cs' d') =p=> crash_xform (exists cs d, rep cs d * [[ (F * arrayN ptsto_subset a (vsupd_range vs l))%pred d ]]). Proof. induction l using rev_ind; simpl; intros. rewrite firstn_nil in H; cbn in *. apply crash_xform_pimpl; cancel. destruct (le_dec n (S (length l))). destruct (le_dec n (length l)). - rewrite app_length in *; simpl in *. rewrite firstn_app_l in H by auto. rewrite IHl; eauto; try omega. rewrite vsupd_range_app_tl; eauto. xform_norm. rewrite write_array_xcrash_ok with (i := length l); eauto. 2: rewrite vsupd_range_length; try omega; rewrite firstn_length, app_length, Nat.min_l; simpl; omega. xform_norm; cancel. apply crash_xform_pimpl. cancel. - assert (n = length l + 1) by omega; subst. rewrite app_length in *; simpl in *. rewrite firstn_oob in H by (rewrite app_length; simpl; omega). apply crash_xform_pimpl. cancel. - rewrite firstn_oob in H. apply crash_xform_pimpl; cancel. rewrite app_length; simpl; omega. Qed. Lemma vsupd_range_xcrash_firstn : forall F a n l vs, length l <= length vs -> crash_xform (exists cs' d', rep cs' d' * [[ (F * arrayN ptsto_subset a (vsupd_range vs (firstn n l)))%pred d' ]]) =p=> crash_xform (exists cs d, rep cs d * [[ (F * arrayN ptsto_subset a (vsupd_range vs l))%pred d ]]). Proof. intros. xform_norm. erewrite vsupd_range_xcrash_firstn'; eauto. xform_norm. do 2 (xform_normr; cancel). Qed. Theorem write_range_ok : forall a l cs, {< d F vs, PRE:hm rep cs d * [[ (F * arrayS a vs)%pred d ]] * [[ length l <= length vs ]] POST:hm' RET:cs exists d', rep cs d' * [[ (F * arrayS a (vsupd_range vs l))%pred d' ]] XCRASH:hm' exists cs' d', rep cs' d' * [[ (F * arrayS a (vsupd_range vs l))%pred d' ]] >} write_range a l cs. Proof. unfold write_range; intros. safestep. auto. auto. prestep; unfold rep; cancel. rewrite vsupd_range_length; try omega. rewrite firstn_length_l; omega. prestep; unfold rep; cancel. erewrite firstn_S_selN_expand by omega. setoid_rewrite <- vsupd_range_progress; auto. cancel. repeat xcrash_rewrite. setoid_rewrite vsupd_range_progress; auto. rewrite <- firstn_plusone_selN by auto. apply vsupd_range_xcrash_firstn; auto. step. rewrite firstn_oob; auto. xcrash. Unshelve. exact tt. Qed. Theorem sync_range_ok : forall a n cs, {< d d0 F vs, PRE:hm synrep cs d0 d * [[ (F * arrayS a vs)%pred d ]] * [[ n <= length vs /\ sync_invariant F ]] POST:hm' RET:cs exists d', synrep cs d0 d' * [[ (F * arrayS a (vssync_range vs n))%pred d' ]] CRASH:hm' exists cs', rep cs' d0 >} sync_range a n cs. 
1 - 1)%Z with (fexp n) by ring. rewrite Req_bool_true; trivial. apply Rminus_diag_eq, f_equal. apply sym_eq, valid_exp; omega. Qed.Theorem pred_succ_aux : forall x, F x -> (0 < x)%R -> pred (succ x)=x. Proof. intros x Fx Hx. rewrite succ_eq_pos;[idtac|now left]. rewrite pred_eq_pos. 2: apply Rplus_le_le_0_compat;[now left| apply ulp_ge_0]. unfold pred_pos. case Req_bool_spec; intros H1.pose (l:=(ln_beta beta (x+ulp x))). rewrite H1 at 1; fold l. apply Rplus_eq_reg_r with (ulp x). rewrite H1; fold l. rewrite (ulp_neq_0 x) at 3. 2: now apply Rgt_not_eq. unfold canonic_exp. replace (fexp (ln_beta beta x)) with (fexp (l-1))%Z. ring. apply f_equal, sym_eq. apply Zle_antisym. assert (ln_beta beta x - 1 < l - 1)%Z;[idtac|omega]. apply lt_bpow with beta. unfold l; rewrite <- H1. apply Rle_lt_trans with x. destruct (ln_beta beta x) as (e,He); simpl. rewrite <- (Rabs_right x) at 1. 2: apply Rle_ge; now left. now apply He, Rgt_not_eq. apply Rplus_lt_reg_l with (-x)%R; ring_simplify. rewrite ulp_neq_0. apply bpow_gt_0. now apply Rgt_not_eq. apply le_bpow with beta. unfold l; rewrite <- H1. apply id_p_ulp_le_bpow; trivial. rewrite <- (Rabs_right x) at 1. 2: apply Rle_ge; now left. apply bpow_ln_beta_gt.replace (ulp (x+ ulp x)) with (ulp x). ring. rewrite ulp_neq_0 at 1. 2: now apply Rgt_not_eq. rewrite ulp_neq_0 at 1. 2: apply Rgt_not_eq, Rlt_gt. 2: apply Rlt_le_trans with (1:=Hx). 2: apply Rplus_le_reg_l with (-x)%R; ring_simplify. 2: apply ulp_ge_0. apply f_equal; unfold canonic_exp; apply f_equal. apply sym_eq, ln_beta_unique. rewrite Rabs_right. 2: apply Rle_ge; left. 2: apply Rlt_le_trans with (1:=Hx). 2: apply Rplus_le_reg_l with (-x)%R; ring_simplify. 2: apply ulp_ge_0. destruct (ln_beta beta x) as (e,He); simpl. rewrite Rabs_right in He. 2: apply Rle_ge; now left. split. apply Rle_trans with x. apply He, Rgt_not_eq; assumption. apply Rplus_le_reg_l with (-x)%R; ring_simplify. apply ulp_ge_0. case (Rle_lt_or_eq_dec (x+ulp x) (bpow e)); trivial. apply id_p_ulp_le_bpow; trivial. apply He, Rgt_not_eq; assumption. intros K; contradict H1. rewrite K, ln_beta_bpow. apply f_equal; ring. Qed.Theorem succ_pred : forall x, F x -> succ (pred x)=x. Proof. intros x Fx. case (Rle_or_lt 0 x); intros Hx. destruct Hx as [Hx|Hx]. now apply succ_pred_aux. rewrite <- Hx. rewrite pred_eq_opp_succ_opp, succ_opp, Ropp_0. rewrite pred_succ_aux_0; ring. rewrite pred_eq_opp_succ_opp, succ_opp. rewrite pred_succ_aux. ring. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem pred_succ : forall x, F x -> pred (succ x)=x. Proof. intros x Fx. case (Rle_or_lt 0 x); intros Hx. destruct Hx as [Hx|Hx]. now apply pred_succ_aux. rewrite <- Hx. apply pred_succ_aux_0. rewrite succ_eq_opp_pred_opp, pred_opp. rewrite succ_pred_aux. ring. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed. Theorem round_UP_pred_plus_eps : forall x, F x -> forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x) else (ulp (pred x)))%R -> round beta fexp Zceil (pred x + eps) = x. 
subst; apply H1; inList. intro; subst; apply H1; inList. rewrite Coqlib.peq_false. rewrite Coqlib.peq_false. rewrite Coqlib.peq_false. rewrite Coqlib.peq_true. archi_red. simpl. reflexivity. intro; subst; apply H1; inList. intro; subst; apply H1; inList. intro; subst; apply H1; inList. Qed. admit. - admit. - simpl. induction (rev l). simpl. rewrite H_makeTag. rewrite H_make_ctor_rep. auto. simpl. rewrite IHl0. auto. - simpl. induction (rev l). simpl. rewrite H_makeTag. auto. simpl. rewrite IHl0. auto. Admitted. *)Theorem find_symbol_map: forall p fenv m finfo_env id v, find_symbol_domain p finfo_env -> var_or_funvar id m fenv finfo_env p v (makeVar id m v fenv finfo_env). Proof. intros. specialize (H v). inv H. destruct (cps.M.get v finfo_env) eqn:Hgvm. - destruct (H0 (ex_intro _ p0 (eq_refl _))). econstructor. apply H. - unfold makeVar. rewrite Hgvm. econstructor. destruct (Genv.find_symbol (Genv.globalenv p) v) eqn:Hgpv; auto. exfalso. destruct (H1 (ex_intro _ b (eq_refl _))). inv H. Qed. Theorem find_symbol_map_f: forall p fenv m finfo_env id v, find_symbol_domain p finfo_env -> var_or_funvar_f id m fenv finfo_env p v = makeVar id m v fenv finfo_env. Proof. intros. apply var_or_funvar_of_f. apply find_symbol_map; auto. Qed.Theorem asgnAppVars_correct: forall p fenv finfo_env, forall vs avs ind aind s, find_symbol_domain p finfo_env -> avs = skipn nParam vs -> aind = skipn nParam ind -> asgnAppVars' argsIdent threadInfIdent nParam vs ind fenv finfo_env = Some s -> repr_asgn_fun' argsIdent threadInfIdent nParam fenv finfo_env p avs aind s. Proof. intros p fenv finfo_env vs avs. generalize vs. clear vs. induction avs; intros vs ind aind s Hfinfo_env Hvs Hind Hasgn; unfold asgnAppVars' in Hasgn. - destruct aind; rewrite <- Hvs in Hasgn; rewrite <- Hind in Hasgn; destruct nParam; inv Hasgn; constructor. - destruct aind; rewrite <- Hvs in Hasgn; rewrite <- Hind in Hasgn; [ destruct nParam; inv Hasgn | ]. destruct vs; [destruct nParam; inv Hvs | ]. destruct ind; [destruct nParam; inv Hind | ]. symmetry in Hvs. set (Hvs' := skipn_cons nParam p0 a vs avs Hvs). symmetry in Hvs'. symmetry in Hind. set (Hind' := skipn_cons nParam n0 n ind aind Hind). symmetry in Hind'. simpl in Hasgn. destruct (asgnAppVars'' argsIdent threadInfIdent nParam avs aind fenv) eqn:Happ. 2: inv Hasgn. specialize (IHavs _ _ _ s0 Hfinfo_env Hvs' Hind'). unfold asgnAppVars' in IHavs. rewrite <- Hvs' in IHavs. rewrite <- Hind' in IHavs. apply IHavs in Happ. inv Hasgn. erewrite <- find_symbol_map_f; eauto. exact (repr_asgn_cons _ _ _ _ _ _ _ _ _ _ s0 Happ). Qed. Theorem repr_call_vars_length1 : forall p fenv map n l1 l2, repr_call_vars threadInfIdent nParam fenv map p n l1 l2 -> length l1 = n. 
(x < y)%Z. intros x y H'; case (Zle_or_lt y x); auto; intros ZH; Contradict H'. apply Rle_not_lt; apply oneExp_le; auto. Qed. Theorem oneExp_Zle : forall x y : Z, (Float 1%nat x <= Float 1%nat y)%R -> (x <= y)%Z. intros x y H'; case (Zle_or_lt x y); auto; intros ZH; Contradict H'. apply Rgt_not_le; red in |- *; apply oneExp_lt; auto. Qed. Definition Fdigit (p : float) := digit radix (Fnum p). Definition Fshift (n : nat) (x : float) := Float (Fnum x * Zpower_nat radix n) (Fexp x - n). Theorem sameExpEq : forall p q : float, p = q :>R -> Fexp p = Fexp q -> p = q. intros p q; case p; case q; unfold FtoR in |- *; simpl in |- *. intros Fnum1 Fexp1 Fnum2 Fexp2 H' H'0; rewrite H'0; rewrite H'0 in H'. cut (Fnum1 = Fnum2). intros H'1; rewrite <- H'1; auto. apply eq_IZR; auto. apply Rmult_eq_reg_l with (r := powerRZ radix Fexp1); repeat rewrite (Rmult_comm (powerRZ radix Fexp1)); auto. apply Rlt_dichotomy_converse; right; auto with real. red in |- *; auto with real. Qed. Theorem FshiftFdigit : forall (n : nat) (x : float), ~ is_Fzero x -> Fdigit (Fshift n x) = Fdigit x + n. intros n x; case x; unfold Fshift, Fdigit, is_Fzero in |- *; simpl in |- *. intros p1 p2 H; apply digitAdd; auto. Qed. Theorem FshiftCorrect : forall (n : nat) (x : float), Fshift n x = x :>R. intros n x; unfold FtoR in |- *; simpl in |- *. rewrite Rmult_IZR. rewrite Zpower_nat_Z_powerRZ; auto. repeat rewrite Rmult_assoc. rewrite <- powerRZ_add; auto with real zarith. rewrite Zplus_minus; auto. Qed. Theorem FshiftCorrectInv : forall x y : float, x = y :>R -> (Fexp x <= Fexp y)%Z -> Fshift (Zabs_nat (Fexp y - Fexp x)) y = x. intros x y H' H'0; try apply sameExpEq; auto. apply trans_eq with (y := FtoR y); auto. apply FshiftCorrect. generalize H' H'0; case x; case y; simpl in |- *; clear H' H'0 x y. intros Fnum1 Fexp1 Fnum2 Fexp2 H' H'0; rewrite inj_abs; auto with zarith. Qed. Theorem FshiftO : forall x : float, Fshift 0 x = x. intros x; unfold Fshift in |- *; apply floatEq; simpl in |- *. replace (Zpower_nat radix 0) with 1%Z; auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem FshiftCorrectSym : forall x y : float, x = y :>R -> exists n : nat, (exists m : nat, Fshift n x = Fshift m y). 
Union_is_Lub : forall a b : Ensemble U, Included U a A -> Included U b A -> Lub (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Union U a b). Proof. intros a b H' H'0. apply Lub_definition; simpl in |- *. apply Upper_Bound_definition; simpl in |- *. auto. intros y H'1; elim H'1; auto. intros y H'1; elim H'1; simpl in |- *; auto. Qed. Theorem Intersection_is_Glb : forall a b : Ensemble U, Included U a A -> Included U b A -> Glb (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Intersection U a b). Proof. intros a b H' H'0. apply Glb_definition. apply Lower_Bound_definition; simpl in |- *. apply Definition_of_Power_set; auto. generalize Inclusion_is_transitive; intro IT; red in IT; apply IT with a; auto. intros y H'1; elim H'1; auto. intros y H'1; elim H'1; simpl in |- *; auto. Qed. Theorem Empty_set_zero : forall X : Ensemble U, Union U (Empty_set U) X = X. Proof. auto 10. Qed. Theorem Union_commutative : forall A B : Ensemble U, Union U A B = Union U B A. Proof. auto. Qed. Theorem Union_associative : forall A B C : Ensemble U, Union U (Union U A B) C = Union U A (Union U B C). Proof. auto 20. Qed. Theorem Non_disjoint_union : forall (X : Ensemble U) (x : U), In U X x -> Union U (Singleton U x) X = X. Proof. intros X x H'; try assumption; auto 10. apply Extensionality_Ensembles; unfold Same_set in |- *; split; auto. red in |- *; auto 10. intros x0 H'0; elim H'0; auto 10. intros x1 H'1; elim H'1; auto 10. Qed. Theorem Finite_plus_one_is_finite : forall (X : Ensemble U) (x : U), Finite U X -> Finite U (Union U (Singleton U x) X). Proof. intros X x H'. generalize (classic (In U X x)); intro h; elim h; [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ]; auto 10. generalize (Non_disjoint_union X x); intro h; lapply h; [ intro H'1; rewrite H'1; clear h | clear h ]; auto. Qed. Hint Resolve Finite_plus_one_is_finite. Theorem Singleton_is_finite : forall x : U, Finite U (Singleton U x). Proof. intro x; generalize (Empty_set_zero (Singleton U x)); intro h; rewrite <- h; clear h. generalize (Union_commutative (Empty_set U) (Singleton U x)); intro h; rewrite h; clear h; auto. Qed. Hint Resolve Singleton_is_finite. Theorem Union_of_finite_is_finite : forall X Y : Ensemble U, Finite U X -> Finite U Y -> Finite U (Union U X Y). 
Require Import Arith. Require Export Euclid. Require Import ZArith. Theorem lt_mult_right : forall x y z t : nat, x < z -> y < t -> x * y < z * t. 
∗ "%H0iseven" ∷ ⌜ Block_to_vals v !! O = Some #(U8 n) ∧ Z.even n ⌝)%I. Definition written_slice : list val := <[int.nat 0:=#(U8 4)]> (replicate (int.nat 4096) (zero_val byteT)). Definition written_block : Block := list_to_vec (U8 4 :: replicate (int.nat 4095) (U8 0)). Lemma written_slice_to_written_block: written_slice = Block_to_vals written_block. Proof. rewrite /written_slice. change (zero_val byteT) with #(U8 0). change (int.nat 4095) with (Z.to_nat 4095). rewrite /Block_to_vals /written_block //=. Qed. Theorem wpc_consumeEvenBlock_seq {E1} (d_ref: loc) (addr: u64) : {{{ EBlk addr }}} consumeEvenBlock #d_ref #addr @ E1 {{{ RET #(); EBlk addr }}} {{{ EBlk addr }}}. Proof. iIntros (Φ Φc) "HE HΦ"; iNamed "HE". wpc_call. { iExists _, _; eauto. } { iExists _, _; eauto. } rewrite /BlockSize. iCache Φc with "HΦ Ha". { crash_case. iExists _, _; eauto. } wpc_pures. wpc_frame_seq. wp_apply (wp_new_slice). { apply to_val_has_zero. } iIntros (s) "Hslice". iNamed 1. wpc_pures. wpc_frame_seq. iDestruct (is_slice_small_acc with "Hslice") as "(H1&H2)". wp_apply (wp_SliceSet with "[$H1]"). { eauto. } iIntros "Hslice"; iNamed 1. wpc_pures. wpc_bind (Write _ _). iApply (wpc_Write_fupd E1 with "[ Hslice]"). { rewrite /is_block. iExactEq "Hslice". f_equal. erewrite <-written_slice_to_written_block. eauto. } iSplit; first iFromCache. iModIntro. iExists _. iFrame. iNext. iIntros "Hwritten". iModIntro. iCache Φc with "Hwritten HΦ". { crash_case. iExists _, 4. iFrame. iPureIntro. rewrite //=. } iSplit; first iFromCache. iIntros "Hblock". wpc_pures. wpc_bind (Read _). iApply (wpc_Read with "Hwritten"). iSplit. { iLeft in "HΦ". iIntros "Hwritten". iApply "HΦ". iExists _, 4. iFrame. iPureIntro. rewrite //=. } iNext. iIntros (s') "(Hwritten&Hslice)". wpc_pures. wpc_frame. wp_bind (SliceGet _ _ _). iDestruct (is_slice_small_acc with "Hslice") as "(H1&H2')". iApply (wp_SliceGet with "[$H1]"). { iPureIntro. rewrite //=. } iNext. iIntros "(H1&%Hval)". wp_pures. iModIntro. iNamed 1. iApply "HΦ". iExists _, _. iFrame. eauto. Qed. Theorem wpc_consumeEvenBlock (d_ref: loc) (addr: u64): {{{ crash_borrow (EBlk addr) (EBlk addr) }}} consumeEvenBlock #d_ref #addr @ ⊤ {{{ RET #() ; True }}} {{{ True }}}. Proof. iIntros (Φ Φc) "Hncinv HΦ". iApply (wpc_step_strong_mono' _ _ _ _ _ (λ v, ⌜ v = #() ⌝ ∗ True)%I _ True with "[-HΦ] [HΦ]"); auto. 2: { iSplit. * iNext. iIntros (?) "H". iDestruct "H" as (?) "%". subst. iModIntro. iRight in "HΦ". by iApply "HΦ". * iLeft in "HΦ". iIntros. by iApply "HΦ". } iApply (wpc_crash_borrow_open with "Hncinv"). { eauto. } iSplit; first eauto. iIntros "Hblk". wpc_apply (wpc_consumeEvenBlock_seq with "[$]"). iSplit. { iIntros; iFrame. } iNext. iIntros "$ _". iSplit; eauto. Unshelve. exact ⊤. Qed. Opaque crash_borrow. Theorem wpc_TransferEvenBlock (d_ref: loc) (addr: u64) : {{{ EBlk addr }}} TransferEvenBlock #d_ref #addr @ ⊤ {{{ RET #() ; True }}} {{{ EBlk addr }}}. 
l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. apply fold1_xelements with (l := @nil (positive * A)). Qed.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. unfold init. unfold get. simpl. rewrite PTree.gempty. auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. 
(sz >= 2)%nat /\ noWrapAround p sz.Lemma BigEnough : forall p sz, freeable p sz -> (sz >= 2)%nat. unfold freeable; tauto. Qed.Lemma SmallEnough : forall p sz, freeable p sz -> noWrapAround p sz. unfold freeable; tauto. Qed.Local Hint Immediate BigEnough SmallEnough. Local Hint Unfold freeable.Module Type FREE_LIST. Parameter freeList : nat -> W -> HProp. Parameter mallocHeap : W -> HProp. Axiom freeList_extensional : forall n p, HProp_extensional (freeList n p). Axiom mallocHeap_extensional : forall p, HProp_extensional (mallocHeap p). Axiom mallocHeap_fwd : forall p, mallocHeap p ===> Ex n, Ex p', p =*> p' * freeList n p'. Axiom mallocHeap_bwd : forall p, (Ex n, Ex p', p =*> p' * freeList n p') ===> mallocHeap p. Axiom nil_bwd : forall n p, p = 0 -> [| n = 0 |] ===> freeList n p. Axiom cons_bwd : forall n (p : W), p <> 0 -> (Ex n', Ex sz, Ex p', [| n = S n' |] * [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p') ===> freeList n p. Axiom cons_fwd : forall n (p : W), p <> 0 -> freeList n p ===> Ex n', Ex sz, Ex p', [| n = S n' |] * [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p'. End FREE_LIST.Module FreeList : FREE_LIST. Open Scope Sep_scope. Fixpoint freeList (n : nat) (p : W) : HProp := match n with | O => [| p = 0 |] | S n' => [| p <> 0 |] * Ex sz, Ex p', [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p' end. Definition mallocHeap (p : W) := Ex n, Ex p', p =*> p' * freeList n p'. Theorem freeList_extensional : forall n p, HProp_extensional (freeList n p). destruct n; reflexivity. Qed. Theorem mallocHeap_extensional : forall p, HProp_extensional (mallocHeap p). reflexivity. Qed. Theorem mallocHeap_fwd : forall p, mallocHeap p ===> Ex n, Ex p', p =*> p' * freeList n p'. unfold mallocHeap; sepLemma. Qed. Theorem mallocHeap_bwd : forall p, (Ex n, Ex p', p =*> p' * freeList n p') ===> mallocHeap p. unfold mallocHeap; sepLemma. Qed. Theorem nil_bwd : forall n p, p = 0 -> [| n = 0 |] ===> freeList n p. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Representable.Hom_Func. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations Ext_Cons.Prod_Cat.Nat_Facts. From Categories Require Import Adjunction.Adjunction. From Categories Require Import KanExt.Local. From Categories Require Import Basic_Cons.Terminal.Local Open Scope functor_scope. Section Facts. Context {C C' : Category} (p : C --> C') {D : Category} (F : C --> D). Section LoKan_Cone_Morph_eq_simplify. Context {Cn Cn' : LoKan_Cone p F} (M M' : LoKan_Cone_Morph Cn Cn'). Theorem LoKan_Cone_Morph_eq_simplify : M = M' :> (_ --> _)%nattrans → M = M'. Proof. intros H. destruct M; destruct M'; cbn in *. ElimEq. PIR. trivial. Qed. End LoKan_Cone_Morph_eq_simplify. Section LoKan_id_Cone_Morph. Context (Cn : LoKan_Cone p F). Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn : core. Program Definition LoKan_id_Cone_Morph : LoKan_Cone_Morph Cn Cn := {| cone_morph := NatTrans_id _ |}. End LoKan_id_Cone_Morph. Section LoKan_Cone_Morph_compose. Context {Cn Cn' Cn'' : LoKan_Cone p F} (h : LoKan_Cone_Morph Cn Cn') (h' : LoKan_Cone_Morph Cn' Cn''). Program Definition LoKan_Cone_Morph_compose : LoKan_Cone_Morph Cn Cn'' := {| cone_morph := NatTrans_compose h h' |}. Next Obligation. Proof. rewrite (cone_morph_com h). rewrite (cone_morph_com h'). rewrite NatTrans_compose_assoc. rewrite NatTrans_comp_hor_comp. rewrite NatTrans_id_unit_right. trivial. Qed. End LoKan_Cone_Morph_compose. Section LoKan_Cone_Morph_compose_assoc. Context {Cn Cn' Cn'' Cn''' : LoKan_Cone p F} (h : LoKan_Cone_Morph Cn Cn') (h' : LoKan_Cone_Morph Cn' Cn'') (h'' : LoKan_Cone_Morph Cn'' Cn'''). Theorem LoKan_Cone_Morph_compose_assoc : LoKan_Cone_Morph_compose h (LoKan_Cone_Morph_compose h' h'') = LoKan_Cone_Morph_compose (LoKan_Cone_Morph_compose h h') h''. 
: Z), e <> 0%R -> powerRZ e z <> 0%R. intros e z; case z; simpl in |- *; auto with real. Qed. Hint Resolve powerRZ_O powerRZ_1 powerRZ_NOR: real. Theorem powerRZ_add : forall (e : R) (n m : Z), e <> 0%R -> powerRZ e (n + m) = (powerRZ e n * powerRZ e m)%R. intros e n m; case n; case m; simpl in |- *; auto with real. intros n1 m1; rewrite nat_of_P_plus_morphism; auto with real. intros n1 m1. rewrite Z.pos_sub_spec; unfold Pos.compare. CaseEq (Pcompare m1 n1 Datatypes.Eq); simpl in |- *; auto with real. intros H' H'0; rewrite Pcompare_Eq_eq with (1 := H'); auto with real. intros H' H'0; rewrite (nat_of_P_minus_morphism n1 m1); auto with real. rewrite (pow_RN_plus e (nat_of_P n1 - nat_of_P m1) (nat_of_P m1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. rewrite Rinv_mult_distr; auto with real. rewrite Rinv_involutive; auto with real. apply lt_le_weak. apply nat_of_P_lt_Lt_compare_morphism; auto. apply ZC2; auto. intros H' H'0; rewrite (nat_of_P_minus_morphism m1 n1); auto with real. rewrite (pow_RN_plus e (nat_of_P m1 - nat_of_P n1) (nat_of_P n1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. apply lt_le_weak. change (nat_of_P m1 > nat_of_P n1) in |- *. apply nat_of_P_gt_Gt_compare_morphism; auto. intros n1 m1. rewrite Z.pos_sub_spec; unfold Pos.compare. CaseEq (Pcompare n1 m1 Datatypes.Eq); simpl in |- *; auto with real. intros H' H'0; rewrite Pcompare_Eq_eq with (1 := H'); auto with real. intros H' H'0; rewrite (nat_of_P_minus_morphism m1 n1); auto with real. rewrite (pow_RN_plus e (nat_of_P m1 - nat_of_P n1) (nat_of_P n1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. rewrite Rinv_mult_distr; auto with real. apply lt_le_weak. apply nat_of_P_lt_Lt_compare_morphism; auto. apply ZC2; auto. intros H' H'0; rewrite (nat_of_P_minus_morphism n1 m1); auto with real. rewrite (pow_RN_plus e (nat_of_P n1 - nat_of_P m1) (nat_of_P m1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. apply lt_le_weak. change (nat_of_P n1 > nat_of_P m1) in |- *. apply nat_of_P_gt_Gt_compare_morphism; auto. intros n1 m1; rewrite nat_of_P_plus_morphism; auto with real. intros H'; rewrite pow_add; auto with real. apply Rinv_mult_distr; auto. apply pow_NR0; auto. apply pow_NR0; auto. Qed. Hint Resolve powerRZ_O powerRZ_1 powerRZ_NOR powerRZ_add: real. Theorem powerRZ_Zopp : forall (e : R) (z : Z), e <> 0%R -> powerRZ e (- z) = (/ powerRZ e z)%R. intros e z H; case z; simpl in |- *; auto with real. intros p; apply sym_eq; apply Rinv_involutive. apply pow_nonzero; auto. Qed. Theorem powerRZ_Zs : forall (e : R) (n : Z), e <> 0%R -> powerRZ e (Zsucc n) = (e * powerRZ e n)%R. 
(e,He); simpl. apply sym_eq, valid_exp... assert (e <= fexp e)%Z. apply exp_small_round_0_pos with beta Zfloor x... rewrite <- (Rabs_pos_eq x). apply He, Rgt_not_eq... apply Rlt_le... replace (fexp n) with (fexp e); try assumption. now apply fexp_negligible_exp_eq. Qed. Theorem ulp_round : forall { Not_FTZ_ : Exp_not_FTZ fexp}, forall rnd { Zrnd : Valid_rnd rnd } x, ulp (round beta fexp rnd x) = ulp x \/ Rabs (round beta fexp rnd x) = bpow (mag beta x). Proof with auto with typeclass_instances. intros Not_FTZ_ rnd Zrnd x. case (Rtotal_order x 0); intros Zx. case (ulp_round_pos (Zrnd_opp rnd) (-x)). now apply Ropp_0_gt_lt_contravar. rewrite ulp_opp, <- ulp_opp. rewrite <- round_opp, Ropp_involutive. intros Y;now left. rewrite mag_opp. intros Y; right. rewrite <- (Ropp_involutive x) at 1. rewrite round_opp, Y. rewrite Rabs_Ropp, Rabs_right... apply Rle_ge, bpow_ge_0. destruct Zx as [Zx|Zx]. left; rewrite Zx; rewrite round_0... rewrite Rabs_right. apply ulp_round_pos... apply Rle_ge, round_ge_generic... apply generic_format_0... now apply Rlt_le. Qed.Lemma succ_round_ge_id : forall rnd { Zrnd : Valid_rnd rnd } x, (x <= succ (round beta fexp rnd x))%R. Proof. intros rnd Vrnd x. apply (Rle_trans _ (round beta fexp Raux.Zceil x)). { now apply round_UP_pt. } destruct (round_DN_or_UP beta fexp rnd x) as [Hr|Hr]; rewrite Hr. { now apply UP_le_succ_DN. } apply succ_ge_id. Qed.Theorem round_N_le_midp: forall choice u v, F u -> (v < (u + succ u)/2)%R -> (round beta fexp (Znearest choice) v <= u)%R. Proof with auto with typeclass_instances. intros choice u v Fu H.assert (V: ((succ u = 0 /\ u = 0) \/ u < succ u)%R). specialize (succ_ge_id u); intros P; destruct P as [P|P]. now right. case (Req_dec u 0); intros Zu. left; split; trivial. now rewrite <- P. right; now apply succ_gt_id.destruct V as [(V1,V2)|V]. rewrite V2; apply round_le_generic... apply generic_format_0. left; apply Rlt_le_trans with (1:=H). rewrite V1,V2; right; field.assert (T: (u < (u + succ u) / 2 < succ u)%R) by lra. destruct T as (T1,T2). apply Rnd_N_pt_monotone with F v ((u + succ u) / 2)%R... apply round_N_pt... apply Rnd_N_pt_DN with (succ u)%R. pattern u at 3; replace u with (round beta fexp Zfloor ((u + succ u) / 2)). apply round_DN_pt... apply round_DN_eq; trivial. split; try left; assumption. pattern (succ u) at 2; replace (succ u) with (round beta fexp Zceil ((u + succ u) / 2)). apply round_UP_pt... apply round_UP_eq; trivial. apply generic_format_succ... rewrite pred_succ; trivial. split; try left; assumption. right; field. Qed. Theorem round_N_ge_midp: forall choice u v, F u -> ((u + pred u)/2 < v)%R -> (u <= round beta fexp (Znearest choice) v)%R. 
(a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b), divP a b -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). intros a b nZb H; inversion H; auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a nZb0) b); auto. Qed. Hint Resolve divP_inv1 divP_inv2 divP_inv3. Theorem divP_plusTerm : forall a b c : Term A n, divP a c -> divP b c -> eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> divP (plusTerm (A:=A) plusA (n:=n) a b) c. intros a b c H' H'0; inversion H'0; inversion H'. intros H'1 H'2; apply divTerm_def with (nZb := nZb0); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := plusTerm (A:=A) plusA (n:=n) (multTerm (A:=A) multA (n:=n) (divTerm a nZb0) c) (multTerm (A:=A) multA (n:=n) (divTerm b nZb0) c)); auto. apply eqTerm_plusTerm_comp with (1 := cs); auto. apply multTerm_eqT; auto. apply eqT_divTerm; auto. apply (eqT_refl A n). apply (eqT_refl A n). apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (plusTerm (A:=A) plusA (n:=n) (divTerm a nZb0) (divTerm b nZb0)) c); auto. apply multTerm_plusTerm_dist_l with (1 := cs); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply eqT_divTerm_plusTerm; auto. Qed. Hint Resolve divP_plusTerm. Theorem divP_invTerm_l : forall a b : Term A n, divP a b -> divP (invTerm (A:=A) invA (n:=n) a) b. intros a b H'; inversion H'; auto. apply divTerm_def with (nZb := nZb); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (divTerm a nZb)) b); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := invTerm (A:=A) invA (n:=n) (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply mult_invTerm_com with (1 := cs); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_invTerm_l; auto. Qed. Hint Resolve divP_invTerm_l. Theorem divP_invTerm_r : forall a b : Term A n, divP a b -> divP a (invTerm (A:=A) invA (n:=n) b). 
DivNumBitsPerPhase) + 4 + 2 * DivNumBits + 1) by lia; intros. eapply nrDivInv_nrDivStep in Hinv3; try reflexivity; try eassumption; try lia. clear Heq3 nprem3 npq3; destruct Hinv3 as [nprem4 [npq4 [Heq4 Hinv4]]]. generalize dependent nprem4. replace ((pred (wordToNat x) * DivNumBitsPerPhase) + 4 + 2 * DivNumBits) with ((pred (wordToNat x) * DivNumBitsPerPhase) + 3 + 2 * DivNumBits + 1) by lia; intros. eapply nrDivInv_nrDivStep in Hinv4; try reflexivity; try eassumption; try lia. clear Heq4 nprem4 npq4; destruct Hinv4 as [nprem5 [npq5 [Heq5 Hinv5]]]. generalize dependent nprem5. replace ((pred (wordToNat x) * DivNumBitsPerPhase) + 3 + 2 * DivNumBits) with ((pred (wordToNat x) * DivNumBitsPerPhase) + 2 + 2 * DivNumBits + 1) by lia; intros. eapply nrDivInv_nrDivStep in Hinv5; try reflexivity; try eassumption; try lia. clear Heq5 nprem5 npq5; destruct Hinv5 as [nprem6 [npq6 [Heq6 Hinv6]]]. generalize dependent nprem6. replace ((pred (wordToNat x) * DivNumBitsPerPhase) + 2 + 2 * DivNumBits) with ((pred (wordToNat x) * DivNumBitsPerPhase) + 1 + 2 * DivNumBits + 1) by lia; intros. eapply nrDivInv_nrDivStep in Hinv6; try reflexivity; try eassumption; try lia. clear Heq6 nprem6 npq6; destruct Hinv6 as [nprem7 [npq7 [Heq7 Hinv7]]]. generalize dependent nprem7. replace ((pred (wordToNat x) * DivNumBitsPerPhase) + 1 + 2 * DivNumBits) with ((pred (wordToNat x) * DivNumBitsPerPhase) + 2 * DivNumBits + 1) by lia; intros. eapply nrDivInv_nrDivStep in Hinv7; try reflexivity; try eassumption; try lia. clear Heq7 nprem7 npq7; destruct Hinv7 as [nprem8 [npq8 [Heq8 Hinv8]]]. generalize dependent nprem8. replace (pred (wordToNat x) * DivNumBitsPerPhase + 2 * DivNumBits) with (2 * DivNumBits + pred (wordToNat x) * DivNumBitsPerPhase) by lia; intros. replace (wordToNat (evalExpr (_ - _)%kami_expr)) with (pred (wordToNat x)) by (clear -Hxz; simpl; rewrite wordToNat_natToWord_pred; [reflexivity|]; intro Hx; elim Hxz; subst; reflexivity). do 5 eexists; split; [reflexivity|]. split; [|split]; try eassumption. apply Nat.add_comm. Qed. Lemma nrDividerInv_ok: forall o, reachable o nrDividerImpl -> NrDividerInv o. Proof. intros; inv H; inv H0. eapply nrDividerInv_ok'; eauto. Qed. Local Definition thetaR (ir sr: RegsT): Prop. Proof. kexistv "xq" xq ir (Bit DivBits). kexistv "x" x ir (Bit DivNumBits). kexistv "d" d ir (Bit DivNumBits). kexistv "cnt" m ir (Bit (S DivLogNumPhases)). exact (sr = ["d" <- existT _ _ d] +["x" <- existT _ _ x])%fmap. Defined. #[local] Hint Unfold thetaR: MapDefs. Local Definition ruleMap (o: RegsT): string -> option string := "nrDivRegister" |-> "divRegister"; "nrDivGetResult" |-> "divGetResult"; ||. #[local] Hint Unfold ruleMap: MethDefs. Theorem divider_ok: nrDividerImpl <<== dividerSpec. 
Require Export Ensembles. Require Export Constructive_sets. Require Export Relations_1. Require Export Relations_1_facts. Require Export Partial_Order. Require Export Cpo. Require Export Powerset.Section Sets_as_an_algebra. Variable U : Type. Theorem Empty_set_zero : forall X:Ensemble U, Union U (Empty_set U) X = X. Proof. auto 6 with sets. Qed. Theorem Empty_set_zero_right : forall X:Ensemble U, Union U X (Empty_set U) = X. 
:= pX a1 l4); auto. Qed. Theorem canonical_plusP : forall l1 l2 l3, plusP l1 l2 l3 -> canonical A0 eqA ltM l1 -> canonical A0 eqA ltM l2 -> canonical A0 eqA ltM l3. intros l1 l2 l3 H'; elim H'; auto. intros a1 a2 l4 l5 l6 H'0 H'1 H'2 H'3 H'4; try assumption. apply order_plusP with (l1 := l4) (l2 := pX a2 l5); auto. apply canonical_cons; auto. apply (canonical_nzeroP _ A0 eqA _ ltM) with (p := l4); auto. apply H'2; auto. apply (canonical_imp_canonical _ A0 eqA _ ltM) with (a := a1); auto. intros a1 a2 l4 l5 l6 H'0 H'1 H'2 H'3 H'4 H'5. apply H'1; auto. apply (canonical_imp_canonical _ A0 eqA _ ltM) with (a := a1); auto. apply (canonical_imp_canonical _ A0 eqA _ ltM) with (a := a2); auto. intros a1 a2 l4 l5 l6 H'0 H'1 H'2 H'3 H'4 H'5. apply order_plusP with (l1 := l4) (l2 := l5); auto. apply canonical_pX_eqT with (a := a1); auto. apply (eqT_sym A n (plusTerm (A:=A) plusA (n:=n) a1 a2)). apply plusTerm_eqT1; auto. apply canonical_pX_eqT with (a := a2); auto; auto. apply (eqT_sym A n (plusTerm (A:=A) plusA (n:=n) a1 a2)). apply plusTerm_eqT2; auto. apply H'1. apply (canonical_imp_canonical _ A0 eqA _ ltM) with (a := a1); auto. apply (canonical_imp_canonical _ A0 eqA _ ltM) with (a := a2); auto. intros a1 a2 l4 l5 l6 H'0 H'1 H'2 H'3 H'4. apply order_plusP with (l1 := pX a1 l4) (l2 := l5); auto. apply canonical_cons; auto. apply (canonical_nzeroP _ A0 eqA _ ltM) with (p := l5); auto. apply H'2; auto. apply canonical_imp_canonical with (a := a2); auto. Qed. Theorem canonical_pluspf : forall l1 l2, canonical A0 eqA ltM l1 -> canonical A0 eqA ltM l2 -> canonical A0 eqA ltM (pluspf l1 l2). intros l1 l2 H' H'0; generalize (pluspf_is_plusP l1 l2); intros u1. apply canonical_plusP with (l1 := l1) (l2 := l2); auto. Qed. Theorem pO_plusP_inv1 : forall p q, plusP (pO A n) p q -> p = q. intros p; elim p. intros q H'; inversion H'; auto. intros a l H' q H'0; inversion H'0; auto. Qed. Hint Resolve eqp_refl. Theorem pO_plusP_inv2 : forall p q, plusP p (pO A n) q -> p = q. intros p; elim p. intros q H'; inversion H'; auto. intros a l H' q H'0; inversion H'0; auto. Qed. Hint Resolve eqp_refl. Theorem plusP_decomp : forall a p, canonical A0 eqA ltM (pX a p) -> plusP (pX a (pO A n)) p (pX a p). 
b2 q -> rem (alpha_nat b1 n) q = rem (alpha_nat b2 n) q. Proof. intros H1 H2 H3. destruct (eq_nat_dec q 0) as [ H4 | H4 ]. + subst; do 2 rewrite rem_0 in H3; subst; auto. + rewrite <- nat2Zp_inj with (Hp := H4) in H3. apply alpha_Z_congr with (n := S n) in H3; auto. simpl in H3. do 2 rewrite Z2Zp_of_nat in H3. rewrite nat2Zp_inj in H3. trivial. Qed.Corollary alpha_nat_congruence_1 b n : b-2 <> 0 -> rem (alpha_nat b n) (b-2) = rem n (b-2). Proof. intros Hb. rewrite <- alpha_nat_2 with (b_nat := 2) (n := n) at 2; auto. apply alpha_nat_congruence_0; try lia. replace b with ((b-2)+2) at 1 by lia. apply rem_erase with 1; lia. Qed.Section congruence_2. Variable (b : nat) (Hb : b - 2 <> 0). Notation "〚 x 〛" := (Z2Zp Hb x). Hint Resolve Zle_0_nat : core. Open Scope Z_scope. Theorem alpha_Z_b_2 n : 〚 alpha_Z b n 〛 = Zp_plus Hb 〚 Z.of_nat n 〛〚 -1 〛. Proof. rewrite <- Z2Zp_plus. replace (Z.of_nat n + -1) with (Z.of_nat n -1) by lia. rewrite <- (@alpha_2 2); auto. apply alpha_Z_congr; try lia. replace b with (2+(b-2))%nat at 3 by lia. rewrite nat2Zp_plus. rewrite nat2Zp_p, Zp_plus_comm, Zp_plus_zero; auto. Qed.End congruence_2.Lemma rem_eq_eq a b v : 2*a < v -> 2*b < v -> rem a v = rem b v -> a = b. Proof. intros H1 H2 H3. do 2 (rewrite rem_lt in H3; try lia). Qed.Lemma rem_eq_diff_eq a b v : 2*a < v -> 2*b < v -> (rem a v = rem b v) \/ (rem (a+b) v = 0) -> a = b. Proof. intros H1 H2 [ H3 | H3 ]. + do 2 (rewrite rem_lt in H3; try lia). + rewrite rem_lt in H3; lia. Qed.Section diophantine_sufficiency. Variables (a b c : nat) (u t r s v w x y : nat). Definition alpha_conditions := 3 < b /\ u*u+t*t = 1+b*(u*t) /\ s*s+r*r = 1+b*(s*r) /\ r < s /\ u*u │ s /\ v+2*r = b*s /\ rem w v = rem b v /\ rem w u = rem 2 u /\ 2 < w /\ x*x+y*y = 1+w*(x*y) /\ 2*a < u /\ 2*a < v /\ rem a v = rem x v /\ 2*c < u /\ rem c u = rem x u. Theorem alpha_sufficiency : alpha_conditions -> 3 < b /\ a = alpha_nat b c. 
+ r2) (r3 + r2)); intuition. assert (r1 + r2 == r3 + r2). eapply leRat_antisymm; eauto. repeat rewrite ratSubtract_0. intuition. eapply eqRat_impl_leRat. eapply ratAdd_add_same_r. eauto. eapply eqRat_impl_leRat. eapply eqRat_symm. trivial. apply ratSubtract_add_same_r; eauto. Qed.Lemma ratDistance_add_same_l : forall r1 r2 r3, (ratDistance (r2 + r3) (r2 + r1)) == (ratDistance r3 r1). intuition. unfold ratDistance, maxRat, minRat. case_eq (bleRat r3 r1); intuition. assert (r2 + r3 <= r2 + r1). eapply ratAdd_leRat_compat; trivial. eapply leRat_refl. rewrite H0. apply ratSubtract_add_same_l; eauto. apply bleRat_total in H. assert (r2 + r1 <= r2 + r3). eapply ratAdd_leRat_compat; trivial. apply leRat_refl. case_eq (bleRat (r2 + r3) (r2 + r1)); intuition. assert (r2 + r3 == r2 + r1). eapply leRat_antisymm; eauto. repeat rewrite ratSubtract_0. intuition. eapply eqRat_impl_leRat. eapply ratAdd_add_same_l. eauto. eapply eqRat_impl_leRat. eapply eqRat_symm. trivial. apply ratSubtract_add_same_l; eauto.Qed.Theorem rat_distance_of_sum : forall r1 r2 r3 r4, ratDistance (r1 + r2) (r3 + r4) <= (ratDistance r1 r3) + (ratDistance r2 r4). intuition. eapply leRat_trans. eapply (ratTriangleInequality _ _ (r3 + r2)). eapply ratAdd_leRat_compat. eapply eqRat_impl_leRat. eapply ratDistance_add_same_r. eapply eqRat_impl_leRat. eapply ratDistance_add_same_l. Qed.Theorem ratMult_distrib : forall r1 r2 r3, r1 * (r2 + r3) == r1 * r2 + r1 * r3. rattac. inversion H1; clear H1; subst. inversion H0; clear H0; subst. inversion H; clear H; subst. arithNormalize. f_equal. do 5 arithSimplify. do 5 arithSimplify. Qed. Theorem num_dem_same_rat1 : forall n d, n = posnatToNat d -> RatIntro n d == rat1. rattac. inversion H0; clear H0; subst. omega. Qed.Lemma ratAdd_num : forall n1 n2 d, RatIntro (n1 + n2) d == (ratAdd (RatIntro n1 d) (RatIntro n2 d)). rattac. arithNormalize. trivial. Qed.Lemma ratMult_denom : forall n d1 d2, (RatIntro n (posnatMult d1 d2)) == (ratMult (RatIntro 1 d1) (RatIntro n d2)). rattac. Qed.Lemma ratMult_num_den : forall n1 n2 d1 d2, (RatIntro (n1 * n2)%nat (posnatMult d1 d2)) == (RatIntro n1 d1) * (RatIntro n2 d2). intuition. unfold ratMult, natToPosnat, posnatMult. eapply eqRat_refl. Qed.Theorem ratAdd_den_same : forall n1 n2 d, RatIntro (n1 + n2)%nat d == (RatIntro n1 d) + (RatIntro n2 d). rattac. arithNormalize. arithSimplify. Qed.Lemma rat_mult_den : forall n d1 d2, (RatIntro n (posnatMult d1 d2)) == (RatIntro 1 d1) * (RatIntro n d2). intuition. assert (n = 1 * n)%nat. omega. rewrite H at 1. apply ratMult_num_den; omega. Qed.Lemma ratOneHalf_add: 1 / 2 + 1 / 2 == 1. unfold ratAdd. simpl. unfold posnatMult. simpl. apply (@num_dem_same_rat1 4 _). simpl. trivial. Qed. Theorem ratS_num : forall n, (S n) / (S O) == 1 + (n / (S O)). 
hprop_cell (p : ptr) T (v : T) (pi:Qc): hprop := fun h => h#p = Some (Dyn v, pi) /\ forall p', p' <> p -> h#p' = None.Notation "p ---> v" := (hprop_cell p v (0%Qc)) (at level 38, no associativity) : hprop_scope.Definition empty : heap := fun _ => None.Definition hprop_empty : hprop := eq empty. Notation "'emp'" := hprop_empty : hprop_scope.Definition hprop_inj (P : Prop) : hprop := fun h => h = empty /\ P. Notation "[ P ]" := (hprop_inj P) (at level 0, P at level 200) : hprop_scope.Definition hprop_imp (p1 p2 : hprop) : Prop := forall h, p1 h -> p2 h. Infix "==>" := hprop_imp (right associativity, at level 55).Definition hprop_ex T (p : T -> hprop) : hprop := fun h => exists v, p v h. Notation "'Exists' v :@ T , p" := (hprop_ex (fun v : T => p%hprop)) (at level 90, T at next level) : hprop_scope.Local Open Scope hprop_scope. Definition disjoint (h1 h2 : heap) : Prop := forall p, match h1#p with | None => True | Some v1 => match h2#p with | None => True | Some v2 => val v1 = val v2 /\ compatible (frac v1) (frac v2) end end.Infix "<#>" := disjoint (at level 40, no associativity) : heap_scope.Definition split (h h1 h2 : heap) : Prop := h1 <#> h2 /\ h = h1 * h2.Notation "h ~> h1 * h2" := (split h h1 h2) (at level 40, h1 at next level, no associativity).Definition hprop_sep (p1 p2 : hprop) : hprop := fun h => exists h1, exists h2, h ~> h1 * h2 /\ p1 h1 /\ p2 h2. Infix "*" := hprop_sep (at level 40, left associativity) : hprop_scope.Section Stack. Variable T : Set. Record node : Set := Node { data : T; next : option ptr }. Fixpoint listRep (ls : list T) (hd : option ptr) {struct ls} : hprop := match ls with | nil => [hd = None] | h :: t => match hd with | None => [False] | Some hd' => Exists p :@ option ptr, hd' ---> Node h p * listRep t p end end%hprop. Definition stack := ptr. Definition rep q ls := (Exists po :@ option ptr, q ---> po * listRep ls po)%hprop. Definition isExistential T (x : T) := True. Theorem himp_ex_conc_trivial : forall T p p1 p2, p ==> p1 * p2 -> T -> p ==> hprop_ex (fun _ : T => p1) * p2. 
a a', ~ In a' (map fst avs) -> ~ In a' (map fst (avs_except avs a)). Proof. induction avs; simpl; intros; eauto. destruct a. destruct (HighAEQ h a0); subst; eauto. simpl in *; intuition; eauto. Qed. Hint Resolve avs_except_notin. Lemma avs2mem_notindomain : forall l a, ~ In a (map fst l) -> notindomain a (avs2mem l). Proof. unfold avs2mem, notindomain; induction l; simpl; intros. cbv; auto. destruct a; simpl in *; intuition. rewrite upd_ne; auto. Qed. Theorem avs_except_nodup : forall avs a, NoDup (map fst avs) -> NoDup (map fst (avs_except avs a)). Proof. induction avs; simpl; intros; eauto. destruct a. inversion H; subst. destruct (HighAEQ h a0); subst; eauto. simpl; constructor; eauto. Qed. Hint Resolve avs_except_nodup. Lemma avs2mem_except_eq : forall avs a, avs2mem (avs_except avs a) a = None. Proof. induction avs; simpl; intros; eauto. destruct a. destruct (HighAEQ h a0); subst; eauto. rewrite avs2mem_ne by auto; auto. Qed. Lemma avs2mem_except_ne : forall avs a a', a <> a' -> avs2mem (avs_except avs a) a' = avs2mem avs a'. Proof. induction avs; simpl; intros; eauto. destruct a. destruct (HighAEQ h a0); subst. - rewrite avs2mem_ne; auto. - unfold avs2mem in *; simpl. destruct (HighAEQ h a'); subst. + repeat rewrite upd_eq; auto. + repeat rewrite upd_ne; auto. Qed. Theorem mem_except_avs_except : forall avs a, mem_except (avs2mem avs) a = avs2mem (avs_except avs a). Proof. intros; apply functional_extensionality; intros. destruct (HighAEQ a x); subst. - rewrite mem_except_eq. rewrite avs2mem_except_eq. auto. - rewrite mem_except_ne by auto. rewrite avs2mem_except_ne by auto. auto. Qed. Hint Resolve mem_except_avs_except. Lemma avs2mem_none_notin : forall avs a, avs2mem avs a = None -> ~ In a (map fst avs). Proof. unfold avs2mem; induction avs; simpl; intros; auto. destruct a; intuition; simpl in *; subst. rewrite upd_eq in * by auto; congruence. destruct (HighAEQ h a0); subst. rewrite upd_eq in * by auto; congruence. rewrite upd_ne in * by auto; eauto. Qed. Variable Pred : HighAT -> HighV -> low_pred. Definition mem_pred_one (av : HighAT * HighV) : low_pred := Pred (fst av) (snd av). Definition mem_pred (hm : high_mem) : low_pred := (exists hm_avs, [[ NoDup (map fst hm_avs) ]] * [[ hm = avs2mem hm_avs ]] * listpred mem_pred_one hm_avs)%pred. Theorem mem_pred_extract' : forall hm a v, hm a = Some v -> mem_pred hm =p=> mem_pred (mem_except hm a) * mem_pred_one (a, v). Proof. unfold mem_pred; intros. cancel. eapply listpred_avs_except; subst; eauto. eauto. Qed. Theorem mem_pred_extract : forall hm a v, hm a = Some v -> mem_pred hm =p=> mem_pred (mem_except hm a) * Pred a v. 
prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof Ring.prod_0_inv_r ring. Theorem prod_0_inv : ~ prod_has_inv 0. Proof Ring.prod_0_inv ring. Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof Ring.prod_inv_0 ring. Definition E_n1_strong : { x : E | sum_is_inv 1 x } := Ring.E_n1_strong ring. Definition E_n1 : E := Ring.E_n1 ring. Notation "{-1}" := E_n1 : commutative_ring_scope. Definition E_n1_def : sum_is_inv 1 {-1} := Ring.E_n1_def ring. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof Ring.E_n1_inv_l ring. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof Ring.E_n1_inv_r ring. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof Ring.E_n1_uniq ring. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). Proof Ring.prod_n1_x_inv_l ring. Theorem prod_x_n1_inv_l : forall x : E, sum_is_inv_l x (x # {-1}). Proof Ring.prod_x_n1_inv_l ring. Theorem prod_n1_x_inv_r : forall x : E, sum_is_inv_r x ({-1} # x). Proof Ring.prod_n1_x_inv_r ring. Theorem prod_x_n1_inv_r : forall x : E, sum_is_inv_r x (x # {-1}). Proof Ring.prod_x_n1_inv_r ring. Theorem prod_n1_x_inv : forall x : E, sum_is_inv x ({-1} # x). Proof Ring.prod_n1_x_inv ring. Theorem prod_x_n1_inv : forall x : E, sum_is_inv x (x # {-1}). Proof Ring.prod_x_n1_inv ring. Theorem prod_n1_neg : {#} {-1} = sum_neg. Proof Ring.prod_n1_neg ring. Theorem prod_x_n1_neg : forall x : E, x # {-1} = - x. Proof Ring.prod_x_n1_neg ring. Theorem prod_n1_x_neg : forall x : E, {-1} # x = - x. Proof Ring.prod_n1_x_neg ring. Theorem prod_n1_eq : forall x : E, {-1} # x = x # {-1} . Proof Ring.prod_n1_eq ring. Theorem neg_1 : {-} 1 = {-1}. Proof Ring.neg_1 ring. Theorem neg_n1 : sum_neg {-1} = 1. Proof Ring.neg_n1 ring. Theorem prod_n1_n1 : {-1} # {-1} = 1. Proof Ring.prod_n1_n1 ring. Theorem E_n1_inv : prod_is_inv {-1} {-1}. 
c (firstn n ls); x <-$ c (nth n ls def); ret (y ++ x :: nil)). induction ls; intuition; simpl in *. omega. destruct n. destruct ls. simpl in *. comp_simp. comp_skip. simpl. eapply comp_spec_eq_refl. simpl in*. omega. simpl. inline_first. comp_skip. eapply comp_spec_eq_trans. eapply comp_spec_seq_eq; eauto with inhabited. intros. eapply comp_spec_eq_refl. inline_first. comp_skip. inline_first. comp_simp. comp_skip. rewrite <- app_comm_cons. eapply comp_spec_eq_refl. Qed. Theorem firstn_firstn : forall (A : Type)(ls : list A)(n1 n2 : nat), (n1 <= n2)%nat -> firstn n1 (firstn n2 ls) = firstn n1 ls. induction ls; destruct n1; destruct n2; intuition; simpl in *. omega. f_equal. eapply IHls. omega. Qed. Theorem nth_firstn : forall (A : Set)(def : A)(ls : list A)(n1 n2 : nat), (n1 < n2)%nat -> nth n1 (firstn n2 ls) def = nth n1 ls def. induction ls; destruct n1; destruct n2; intuition; simpl in *. omega. omega. eapply IHls. omega. Qed. Theorem G_hybrid_DistSingle_S_eq : forall i, Pr[G_hybrid (S i)] == Pr[DistSingle_G (B1 i) B2 c1]. intuition. unfold G_hybrid, DistSingle_G, B1, B2. inline_first. comp_skip. comp_simp. eapply comp_spec_eq_impl_eq. destruct (lt_dec i (length l)). eapply comp_spec_eq_trans. eapply comp_spec_seq_eq; eauto with inhabited. eapply compMap_unroll_tl. rewrite firstn_length. eapply min_l. omega. intuition. eapply comp_spec_eq_refl. inline_first. rewrite firstn_firstn. comp_swap_r. comp_skip. inline_first. rewrite nth_firstn. comp_skip. comp_skip. rewrite <- app_assoc. rewrite <- app_comm_cons. simpl. eapply comp_spec_eq_refl. omega. omega. comp_irr_r. repeat rewrite firstn_ge_all. comp_skip. comp_skip. rewrite skipn_gt_nil in H3. simpl in *. intuition. subst. rewrite app_nil_r. eapply comp_spec_eq_refl. omega. omega. omega. Qed. Theorem hybrid_incr_close : forall i, | Pr[G_hybrid i] - Pr[G_hybrid (S i)] | == DistSingle_Adv c1 c2 (B1 i) B2. intuition. unfold DistSingle_Adv. rewrite G_hybrid_DistSingle_eq. rewrite G_hybrid_DistSingle_S_eq. eapply ratDistance_comm. Qed. Theorem ratDistance_sequence_sum : forall (f : nat -> Rat)(n : nat), | f O - f n | <= sumList (forNats n) (fun i => | f i - f (S i) |). induction n; intuition; simpl in *. unfold sumList. simpl. eapply eqRat_impl_leRat. rewrite <- ratIdentityIndiscernables. intuition. eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. symmetry. eapply sumList_cons. } simpl. eapply leRat_trans. eapply ratDistance_le_trans. eapply IHn. eapply leRat_refl. rewrite ratAdd_comm. intuition. Qed. Theorem Single_impl_ListHybrid_sum : ListHybrid_Advantage <= sumList (forNats maxA) (fun i => DistSingle_Adv c1 c2 (B1 i) B2). unfold ListHybrid_Advantage. rewrite G_1_hybrid_eq. rewrite G_2_hybrid_eq. rewrite ratDistance_comm. rewrite (@ratDistance_sequence_sum (fun i => Pr[G_hybrid i])); intuition. eapply sumList_le. intuition. eapply eqRat_impl_leRat. eapply hybrid_incr_close. Qed. Variable maxDistance : Rat. Hypothesis maxDistance_correct : forall i, DistSingle_Adv c1 c2 (B1 i) B2 <= maxDistance. Theorem Single_impl_ListHybrid : ListHybrid_Advantage <= maxA / 1 * maxDistance. 
erewrite Loop_size_step by eauto. } } Qed.Fixpoint Loop_steps T V H k := match k with | 0 => Step_steps T V H | S k' => match step_fun (T, V, H) with | Some (T',V',H') => if is_halt_state (T',V',H') then 1 + Step_steps T V H + Step_steps T' V' H' else 1 + Step_steps T V H + Loop_steps T' V' H' k' | None => Step_steps T V H end end. Definition Loop_T : tRel sigStep^+ 11 := fun tin i => exists T V H k, halts_k (T,V,H) k /\ tin[@Fin0] ≃ T /\ tin[@Fin1] ≃ V /\ tin[@Fin2] ≃ H /\ (forall i : Fin.t 8, isVoid tin[@FinR 3 i]) /\ Loop_steps T V H k <= i. Lemma Loop_Terminates : projT1 Loop ↓ Loop_T. Proof. eapply TerminatesIn_monotone. { unfold Loop. TM_Correct. - apply Step_Realise. - apply Step_Terminates. } { eapply WhileCoInduction. intros tin i. intros (T&V&Heap&k&Halt&HEncT&HEncV&HEncH&HInt&Hi). exists (Step_steps T V Heap). repeat split. { hnf. do 3 eexists; repeat split; eauto. } intros ymid tmid HStep. cbn in HStep. modpon HStep. { instantiate (1 := [| _;_;_;_;_;_;_;_|]). intros i0. specialize HInt with (i := i0). isVoid_mono; cbn. destruct_fin i0; cbn; constructor. } destruct ymid as [ () | ]. - destruct HStep as (HStep&_). destruct Halt as (((T'&V')&H')&HSteps&HTerm). pose proof (halt_state_steps_k HStep HSteps) as (H&->); inv H. cbn in *. assumption. - destruct HStep as (T1&V1&Heap1&HStep); modpon HStep. destruct Halt as (((T2&V2)&H2)&HSteps&HTerm). unfold Loop_T; cbn. destruct k. +inv HSteps. exfalso. eapply HTerm; eauto. + eapply pow_add with (n:=1) in HSteps as (?&H%rcomp_1&?). pose proof (step_functional HStep H) as <-. cbn -[step_fun] in *. rewrite (step_step_fun HStep) in Hi. move HTerm at bottom. clear H. rename H0 into HSteps. destruct (is_halt_state (T1, V1, Heap1)) eqn:EHalt. * apply is_halt_state_correct in EHalt. pose proof (halt_state_steps_k EHalt HSteps) as (H&->); inv H. exists (Step_steps T1 V1 Heap1). split. -- do 3 eexists. eexists 0. cbn -[step_fun]. repeat split; eauto. ++ econstructor; eauto. ++ intros i0. specialize HStep3 with (i := i0). isVoid_mono. -- lia. * exists (Loop_steps T1 V1 Heap1 k). split. -- do 3 eexists. exists k. repeat split; eauto. ++ econstructor; eauto. ++ intros i0. specialize HStep3 with (i := i0). isVoid_mono. -- lia. } Qed.Definition initTapes : state -> tapes sigStep^+ 11 := fun '(T,V,H) => initValue _ _ T ::: initValue _ _ V ::: initValue _ _ H ::: Vector.const (initRight _) 8. Theorem HaltingProblem s : halts s <-> HaltsTM (projT1 Loop) (initTapes s). 
e'). Qed. Theorem le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Proof. unfold A, lt, le in |- *; intros a b; case a; case b. intros a0 a1 H; case (O1.le_lt_or_eq a1 a0 H). auto. simple destruct 1; auto. auto. contradiction. intros a0 a1 H; case (O2.le_lt_or_eq a1 a0 H); auto. simple destruct 1; auto. Qed. Definition lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a}. unfold A, lt in |- *; intros. case a; case b. intros a0 a1. case (O1.lt_eq_lt_dec a0 a1). simple destruct 1. right. auto. simple destruct 1. left. right. trivial. left. left. trivial. left; trivial. left; trivial. right. auto. intros a0 a1. case (O2.lt_eq_lt_dec a0 a1). simple destruct 1. right. auto. simple destruct 1. left. right. trivial. left. left. trivial. Defined.End Sum_Order. Require Import Arith.Module Nat_Order : DEC_ORDER with Definition A := nat with Definition le := le with Definition lt := lt. Definition A := nat. Definition le := le. Definition lt := lt. Theorem ordered : order A le. Proof. split. unfold A, le, reflexive in |- *; auto with arith. unfold A, le, transitive in |- *; eauto with arith. unfold A, le, antisymmetric in |- *; eauto with arith. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. Proof. unfold A in |- *; exact lt_le_weak. Qed. Theorem lt_diff : forall a b : A, lt a b -> a <> b. Proof. unfold A, lt, le in |- *; intros a b H e. rewrite e in H. case (lt_irrefl b H). Qed. Theorem le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Proof. unfold A, le, lt in |- *. exact le_lt_or_eq. Qed. Definition lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a} := lt_eq_lt_dec. End Nat_Order. Definition bool_le (b b' : bool) := if b then if b' then True else False else True. Definition bool_lt (b b' : bool) := if b then False else if b' then True else False. Module Bool_Order : DEC_ORDER with Definition A := bool with Definition le := bool_le with Definition lt := bool_lt. Definition A := bool. Definition le := bool_le. Definition lt := bool_lt. Theorem ordered : order A le. 
Require Export Zenum. Require Export FPred. Section FMinMax. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Coercion FtoRradix : float >-> R. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition boundNat (n : nat) := Float 1%nat (digit radix n). Theorem boundNatCorrect : forall n : nat, (n < boundNat n)%R. intros n; unfold FtoRradix, FtoR, boundNat in |- *; simpl in |- *. rewrite Rmult_1_l. rewrite <- Zpower_nat_Z_powerRZ; auto with real zarith. rewrite INR_IZR_INZ; auto with real zarith. apply Rle_lt_trans with (Zabs n); [rewrite (Zabs_eq (Z_of_nat n))|idtac];auto with real zarith. Qed. Theorem boundBoundNat : forall n : nat, Fbounded b (boundNat n). intros n; repeat split; unfold boundNat in |- *; simpl in |- *; auto with zarith. apply vNumbMoreThanOne with (radix := radix) (precision := precision); auto with zarith. apply Zle_trans with 0%Z;[case (dExp b)|idtac]; auto with zarith. Qed. Definition boundR (r : R) := boundNat (Zabs_nat (up (Rabs r))). Theorem boundRCorrect1 : forall r : R, (r < boundR r)%R. intros r; case (Rle_or_lt r 0); intros H'. apply Rle_lt_trans with (1 := H'). unfold boundR, boundNat, FtoRradix, FtoR in |- *; simpl in |- *; auto with real. rewrite Rmult_1_l; auto with real zarith. apply Rlt_trans with (2 := boundNatCorrect (Zabs_nat (up (Rabs r)))). replace (Rabs r) with r; auto with real. apply Rlt_le_trans with (r2 := IZR (up r)); auto with real zarith. case (archimed r); auto. rewrite INR_IZR_INZ; auto with real zarith. unfold Rabs in |- *; case (Rcase_abs r); auto with real. intros H'0; Contradict H'0; auto with real. Qed. Theorem boundRrOpp : forall r : R, boundR r = boundR (- r). intros R; unfold boundR in |- *. rewrite Rabs_Ropp; auto. Qed. Theorem boundRCorrect2 : forall r : R, (Fopp (boundR r) < r)%R. 
Qed. Lemma surjection_is_func : ∀ F A B, F: A ⟹ B ↔ F: A ⇒ B ∧ ran F = B. Proof with auto. split. intros [Hf [Hd Hr]]. split... split... split... rewrite Hr... intros [[Hf [Hd _]] Hr]. split... Qed. Lemma bijection_is_injection : ∀ F A B, F: A ⟺ B ↔ F: A ⇔ B ∧ ran F = B. Proof with auto. split. intros [Hi [Hd Hr]]. split;[split;[|split]|]... rewrite Hr... intros [[Hi [Hd Hr]] Heq]. split... Qed. Lemma bijection_is_surjection : ∀ F A B, F: A ⟺ B ↔ F: A ⟹ B ∧ injective F. Proof with auto. split. intros [Hi [Hd Hr]]. split... split... destruct Hi... intros [[_ [Hd Hr]] Hi]. split... Qed. Lemma bijection_is_func : ∀ F A B, F: A ⟺ B ↔ F: A ⇒ B ∧ injective F ∧ ran F = B. Proof with auto. split. intros [Hi [Hd Hr]]. split... split. destruct Hi... split... rewrite Hr... intros [[Hf [Hd _]] [Hi Hr]]. split... Qed. Lemma ap_ran : ∀ A B F, F: A ⇒ B → ∀x ∈ A, F[x] ∈ B. Proof with auto. intros * [Hf [Hd Hr]] x Hx. apply Hr. eapply ranI. apply func_correct... rewrite Hd... Qed.Lemma cprd_single_is_func : ∀ F a, is_function (F × {a,}). Proof with auto. split. - apply cprd_is_rel. - intros x Hx. apply domE in Hx as [y Hy]. exists y. split... intros y' Hy'. apply CPrdE2 in Hy as [_ Hy ]. apply CPrdE2 in Hy' as [_ Hy']. apply SingE in Hy. apply SingE in Hy'. subst... Qed.Lemma bunion_is_func : ∀ F G, is_function F → is_function G → dom F ∩ dom G =  → is_function (F ∪ G). Proof with eauto. intros F G Hf Hg Hi. split. - intros x Hx. apply BUnionE in Hx as [Hx|Hx]. + destruct Hf as [Hr _]. apply Hr in Hx... + destruct Hg as [Hr _]. apply Hr in Hx... - intros x Hx. apply domE in Hx as [y Hy]. exists y. split... intros y' Hy'. apply BUnionE in Hy as [Hy|Hy]; apply BUnionE in Hy' as [Hy'|Hy']. + eapply unique_existence. eapply func_dom_sv. apply Hf. eapply domI... easy. easy. + apply domI in Hy. apply domI in Hy'. exfalso. eapply disjointE... + apply domI in Hy. apply domI in Hy'. exfalso. eapply disjointE... + eapply unique_existence. eapply func_dom_sv. apply Hg. eapply domI... easy. easy. Qed. Theorem left_inv : ∀ F A B, F: A ⇒ B → ⦿ A → (∃ G, G: B ⇒ A ∧ G ∘ F = Ident A) ↔ injective F. 
i1 i2 i a1 a2 stk, r#v = Some (value_cons a1 a2) -> estep p r ((instr_if_nil v i1 i2 ;; i) :: stk) r ((i2 ;; i) :: stk) | estep_call : forall p r v l i i' stk, r#v = Some (value_label l) -> p#l = Some i' -> estep p r ((instr_call v ;; i) :: stk) r ((i' ;; instr_assert x) :: i :: stk) | estep_return : forall p r stk i, estep p r ((instr_return ;; i) :: stk) r stk. Inductive estepstar : program X -> store -> list (instr X) -> store -> list (instr X) -> Prop := | estepstar_O: forall p s i, estepstar p s i s i | estepstar_S: forall p s i s' i' s'' i'', estep p s i s' i' -> estepstar p s' i' s'' i'' -> estepstar p s i s'' i''. Definition eventually_ehalts (p:program X) (r:store) (s:list (instr X)) : Prop := exists r', estepstar p r s r' nil. Definition erase_instr : instruction -> instr X := fmap_instr (fun _ => x). Definition erase_prog := map_fmap _ _ erase_instr. Theorem erase_step : forall p p' n r r' s s', step (K.squash (n,p)) p' r s r' s' -> estep (erase_prog p) r (List.map erase_instr s) r' (List.map erase_instr s') /\ exists n', p' = K.squash (n',p). Proof. intros. inv H; unfold erase_instr; simpl in *; try (split; econstructor; eauto; fail). split. eapply estep_call; eauto. unfold prog_lookup in H1. rewrite K.unsquash_squash in H1. simpl in H1. unfold KnotInput.fmap in H1. eapply fmap_eqn2 in H1. destruct H1 as [i'' [? ?]]. unfold erase_prog. erewrite fmap_eqn. 2: eauto. f_equal. subst i'. clear. unfold erase_instr. induction i''; simpl; congruence. hnf in H2. rewrite K.knot_age1 in H2. rewrite K.unsquash_squash in H2. destruct n; try discriminate. inv H2. exists n. apply K.unsquash_inj. repeat rewrite K.unsquash_squash. f_equal. rewrite K.fmap_fmap. change (S n) with (1 +n). rewrite <- K.approx_approx1. auto. Qed. Lemma erase_halt' : forall n p p' r r' s, stepstar (K.squash (n,p)) p' r s r' nil -> estepstar (erase_prog p) r (List.map erase_instr s) r' nil. Proof. intros. remember (K.squash (n,p)) as phat. remember (@nil instruction) as s'. revert Heqphat Heqs'. revert n. induction H; intros. subst i. simpl. econstructor. subst. apply erase_step in H. destruct H. destruct H1. subst p'. spec IHstepstar x0. spec IHstepstar; auto. spec IHstepstar; auto. eapply estepstar_S; eauto. Qed. Theorem erase_halt : forall p n r s, eventually_halts (K.squash (n,p)) r s -> eventually_ehalts (erase_prog p) r (List.map erase_instr s). 
forall A B:Prop, decidable A -> decidable B -> decidable (A \/ B). Proof. unfold decidable; tauto. Qed.Theorem dec_and : forall A B:Prop, decidable A -> decidable B -> decidable (A /\ B). Proof. unfold decidable; tauto. Qed.Theorem dec_not : forall A:Prop, decidable A -> decidable (~ A). Proof. unfold decidable; tauto. Qed.Theorem dec_imp : forall A B:Prop, decidable A -> decidable B -> decidable (A -> B). Proof. unfold decidable; tauto. Qed.Theorem dec_iff : forall A B:Prop, decidable A -> decidable B -> decidable (A<->B). Proof. unfold decidable. tauto. Qed.Theorem not_not : forall P:Prop, decidable P -> ~ ~ P -> P. Proof. unfold decidable; tauto. Qed.Theorem not_or : forall A B:Prop, ~ (A \/ B) -> ~ A /\ ~ B. Proof. tauto. Qed.Theorem not_and : forall A B:Prop, decidable A -> ~ (A /\ B) -> ~ A \/ ~ B. Proof. unfold decidable; tauto. Qed.Theorem not_imp : forall A B:Prop, decidable A -> ~ (A -> B) -> A /\ ~ B. Proof. unfold decidable; tauto. Qed.Theorem imp_simp : forall A B:Prop, decidable A -> (A -> B) -> ~ A \/ B. Proof. unfold decidable; tauto. Qed.Theorem not_iff : forall A B:Prop, decidable A -> decidable B -> ~ (A <-> B) -> (A /\ ~ B) \/ (~ A /\ B). Proof. unfold decidable; tauto. Qed.Theorem not_true_iff : (True -> False) <-> False. Proof. tauto. Qed.Theorem not_false_iff : (False -> False) <-> True. Proof. tauto. Qed.Theorem not_not_iff : forall A:Prop, decidable A -> (((A -> False) -> False) <-> A). Proof. unfold decidable; tauto. Qed.Theorem contrapositive : forall A B:Prop, decidable A -> (((A -> False) -> (B -> False)) <-> (B -> A)). Proof. unfold decidable; tauto. Qed.Lemma or_not_l_iff_1 : forall A B: Prop, decidable A -> ((A -> False) \/ B <-> (A -> B)). Proof. unfold decidable. tauto. Qed.Lemma or_not_l_iff_2 : forall A B: Prop, decidable B -> ((A -> False) \/ B <-> (A -> B)). Proof. unfold decidable. tauto. Qed.Lemma or_not_r_iff_1 : forall A B: Prop, decidable A -> (A \/ (B -> False) <-> (B -> A)). Proof. unfold decidable. tauto. Qed.Lemma or_not_r_iff_2 : forall A B: Prop, decidable B -> (A \/ (B -> False) <-> (B -> A)). Proof. unfold decidable. tauto. Qed.Lemma imp_not_l : forall A B: Prop, decidable A -> (((A -> False) -> B) <-> (A \/ B)). Proof. unfold decidable. tauto. Qed. Theorem not_or_iff : forall A B:Prop, (A \/ B -> False) <-> (A -> False) /\ (B -> False). 
(Nat.eq_dec a to). * subst a. unfold a2v_upd_inc. rewrite tmap_get_upd_eq. rewrite (plus_safe_lt _ _ Hreq_blncs). omega. * apply neq_beq_false in n. apply beq_sym in n. unfold a2v_upd_inc. rewrite tmap_get_upd_ne; auto. + apply Sum_inc; auto. - unfold funcspec_finishMinting in H1. subst spec preP evP postP. simpl in *. destruct H5 as [[Hreq_owner Hreq_mint] [Hevts [Hsym [Hname [Hdec [Htotal [Hbalances [Hallowed [Howner Hmint]]]]]]]]]. unfold INV. rewrite Hbalances in *. rewrite Htotal in *. split; auto. Qed. Theorem create_INV : forall env0 env C E, create env0 C E -> env_step env0 env -> INV env (w_st C) E. Proof. intros. inversion_clear H. unfold funcspec_MintableToken in H2. subst spec. simpl in *. destruct H6 as [Hx1 [Hx2 Hx3]]. unfold INV. rewrite H3 in Hx1. rewrite H4 in Hx2. rewrite H5 in Hx3. destruct Hx3 as [Hto [Hb Hxx]]. split. - rewrite Hb. intros a. destruct (beq_dec a (m_sender msg)). + rewrite Nat.eqb_eq in H. subst a. rewrite (tmap_get_upd_eq _ _ _). auto. + rewrite Nat.eqb_neq in H. rewrite tmap_get_upd_ne. simpl. omega. apply neq_beq_false in H. apply beq_sym in H. auto. - rewrite Hb. apply Sum_sig with (m_sender msg); auto. Qed.Lemma step_contract_address_constant : forall env C I C' E', step env C I C' E' -> w_a C = w_a C'. Proof. intros. destruct C as [a S]. destruct C' as [a' S']. induction H; simpl; auto; intuition. Qed.Lemma steps_INV: forall ml env C E, INV env (w_st C) E -> forall env' C' E', steps env C ml env' C' E' -> INV env' (w_st C') (E ++ E'). Proof. induction ml. - intros. inversion_clear H0. destruct H2. subst. rewrite app_nil_r. trivial. - intros. inversion_clear H0. rename x into envx. rename a into msg. destruct H1 as [Cx [Ex [Ey [H1 [H2 [H3 H4]]]]]]. subst E'. assert (Hx : INV envx (w_st Cx) (E ++ Ex)). { assert (w_a C = w_a Cx). { apply step_contract_address_constant with env msg Ex. apply H1. } destruct C as [C_a C_st]. destruct Cx as [Cx_a Cx_st]. simpl. simpl in H. simpl in H0. generalize H. generalize H4. apply step_INV with C_a msg. subst Cx_a. apply H1. } substH IHml with (IHml envx Cx (E ++ Ex) Hx). rewrite app_assoc. apply IHml; trivial. Qed.Lemma INV_implies_totalSupply_fixed : forall env S E, INV env S E -> Sum (st_balances S) (st_totalSupply S). Proof. intros env S E HI. unfold INV in HI. destruct HI as [_ Hsum]. trivial. Qed. Theorem Property_totalSupply_fixed : forall env0 env ml C E C' E', create env0 C E -> env_step env0 env -> run env C ml C' E' -> Sum (st_balances (w_st C')) (st_totalSupply (w_st C')). 
-> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; subst; simpl in *; auto; congruence. Qed. Theorem handleRequestVoteReply_votesReceived : forall h st t h' r v, In v (votesReceived (handleRequestVoteReply h st h' t r)) -> In v (votesReceived st) \/ (r = true /\ v = h' /\ currentTerm (handleRequestVoteReply h st h' t r) = t). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; subst; simpl in *; do_bool; intuition. Qed. Theorem handleTimeout_log_term_type : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ currentTerm st' = S (currentTerm st). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma handleClientRequest_candidate : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = Candidate -> st' = st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_candidate : forall st h os st' ms, doLeader st h = (os, st', ms) -> type st' = Candidate -> st' = st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_term_votedFor : forall st h os st' ms, doLeader st h = (os, st', ms) -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma doGenericServer_log_type_term_votesReceived : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> log st' = log st /\ type st' = type st /\ currentTerm st' = currentTerm st /\ votesReceived st' = votesReceived st /\ votedFor st' = votedFor st. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleClientRequest_term_votedFor : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = type st /\ currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Theorem handleAppendEntries_term_votedFor : forall h st t n pli plt es ci st' ps h', handleAppendEntries h st t n pli plt es ci = (st', ps) -> votedFor st' = Some h' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. 
match a' with | None => (findCollision _ _ ls') | Some p' => Some (a, p', b) end end. Definition funcCollision (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B)) := if (findCollision _ _ ls) then true else false. Definition G2_3 := k_in <-$ {0, 1}^k; [b, f] <-$2 A _ _ (F_randomFunc k_in) nil; ret (b, funcCollision _ _ (fst (split f))). Theorem G2_2_3_equiv : Pr[G2_2] == Pr[x <-$ G2_3; ret fst x]. unfold G2_2, G2_3. inline_first. comp_skip. inline_first. comp_skip. comp_simp. simpl. intuition. Qed. Definition G2_4 := k_in <-$ {0, 1}^k; [b, f] <-$2 A _ _ (fun s a => b <- F k_in a; randomFunc_mem _ _ ({0, 1}^c) s (a, b)) nil; ret (b, funcCollision _ _ (fst (split f))). Theorem arrayLookup_noCollision_eq : forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) a b0 b, arrayLookup _ x1 (a, b) = Some b0 -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup_f _ x1 b = Some b0. induction x1; intuition; simpl in *. remember (split x1) as z. destruct z. simpl in *. unfold collidesWith in *. simpl in *. case_eq (eqb b3 b1); intuition. rewrite H1 in H0. simpl in *. case_eq (eqb a0 a); intuition. rewrite H2 in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H2. subst. unfold eqbPair in *. simpl in *. repeat rewrite eqb_refl in H. simpl in *. trivial. rewrite H2 in H0. simpl in *. discriminate. rewrite H1 in H0. simpl in *. unfold eqbPair in *. simpl in *. rewrite H1 in H. case_eq (eqb a0 a); intuition. rewrite H2 in H. simpl in *. eapply IHx1; eauto. rewrite H2 in H. simpl in *. eapply IHx1; eauto. Qed. Theorem in_impl_collidesWith : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B), In (a, b) ls -> a <> a' -> collidesWith _ _ ls a' b = true. unfold collidesWith in *. induction ls; intuition; simpl in *. intuition. pairInv. case_eq (eqb a' a); intuition. rewrite eqb_leibniz in H. subst. intuition. rewrite eqb_refl. simpl in *. trivial. case_eq (eqb b1 b0); intuition. case_eq (eqb a' a0); intuition. simpl. eapply IHls; intuition. eauto. subst; intuition. simpl. eapply IHls; eauto. Qed. Theorem funcCollision_false_impl_collidesWith_false : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B), funcCollision _ _ ls = false -> In (a, b) ls -> collidesWith _ _ ls a b = false. 
false) xs. Proof. intros. rewrite fold_left_orb_exists_false'. split; intros; dest; auto. Qed. Lemma utila_any_correct_false: forall xs : list (Expr type (SyntaxKind Bool)), evalExpr (utila_any xs) = false <-> Forall (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. Proof. apply fold_left_orb_exists_false. Qed. End ver. Structure utila_sem_type := utila_sem { utila_sem_m : utila_monad_type type; utila_sem_interp : forall k : Kind, utila_m utila_sem_m k -> type k; utila_sem_bind_correct : forall (j k : Kind) (x : utila_m utila_sem_m j) (f : type j -> utila_m utila_sem_m k), (utila_sem_interp k (utila_mbind utila_sem_m j k x f)) = (utila_sem_interp k (f (utila_sem_interp j x))); utila_sem_unit_correct : forall (k : Kind) (x : k @# type), utila_sem_interp k (utila_munit (utila_sem_m) x) = evalExpr x; utila_sem_foldr_nil_correct : forall (j k : Kind) (f : j @# type -> k @# type -> k @# type) (init : k @# type), (utila_sem_interp k (utila_mfoldr f init nil) = evalExpr init); utila_sem_foldr_cons_correct : forall (j k : Kind) (f : j @# type -> k @# type -> k @# type) (init : k @# type) (x0 : utila_m utila_sem_m j) (xs : list (utila_m utila_sem_m j)), (utila_sem_interp k (utila_mfoldr f init (x0 :: xs)) = (evalExpr (f (Var type (SyntaxKind j) (utila_sem_interp j x0)) (Var type (SyntaxKind k) (utila_sem_interp k (utila_mfoldr f init xs)))))) }. Arguments utila_sem_interp {u} {k} x. Arguments utila_sem_bind_correct {u} {j} {k} x f. Arguments utila_sem_unit_correct {u} {k} x. Arguments utila_sem_foldr_nil_correct {u} {j} {k}. Arguments utila_sem_foldr_cons_correct {u} {j} {k}. Section monad_ver. Import EqIndNotations. Variable sem : utila_sem_type. Let monad : utila_monad_type type := utila_sem_m sem. Let m := utila_m monad. Let mbind := utila_mbind monad. Let munit := utila_munit monad. Local Notation "{{ X }}" := (evalExpr X). Local Notation "[[ X ]]" := (@utila_sem_interp sem _ X). Local Notation "#{{ X }}" := (Var type (SyntaxKind _) {{X}}). Local Notation "#[[ X ]]" := (Var type (SyntaxKind _) [[X]]). Hint Rewrite (@utila_sem_bind_correct sem) (@utila_sem_unit_correct sem) (@utila_sem_foldr_cons_correct sem) (@utila_sem_unit_correct sem) : utila_sem_rewrite_db. Let utila_is_true (x : m Bool) : Prop := [[x]] = true. Lemma utila_mall_nil : [[utila_mall ([] : list (m Bool))]] = true. Proof utila_sem_foldr_nil_correct (fun x acc => x && acc) (Const type true). Lemma utila_mall_cons : forall (x0 : m Bool) (xs : list (m Bool)), [[utila_mall (x0 :: xs)]] = andb [[x0]] [[utila_mall xs]]. Proof utila_sem_foldr_cons_correct (fun x acc => x && acc) (Const type true). Theorem utila_mall_correct : forall xs : list (m Bool), [[utila_mall xs]] = true <-> Forall utila_is_true xs. 
subst. rewrite log2_0 in H. omega. omega. eapply le_trans. 2:{ eapply H3. } simpl. omega. assert ( S (y + (y + y * y)) <= div2 x). eapply IHy. trivial. omega. assert (2 * y + 3 <= div2 x). eapply double_log_plus_3_le_h; trivial. omega. eapply le_trans. eapply plus_le_compat. eapply H2. eapply H3. eapply div2_ge_double. Qed.Theorem S_log_square_lt : forall x, Nat.pow 2 6 <= x-> S (Nat.log2 x) * S (Nat.log2 x) <= x. intuition. eapply S_log_square_lt_h; trivial. eapply le_trans. 2:{ eapply Nat.log2_le_mono. eapply H. } rewrite Nat.log2_pow2; omega. Qed.Theorem log_square_lt : forall x, Nat.pow 2 6 <= x-> Nat.log2 x * Nat.log2 x < x. intuition. assert (Nat.log2 x < S (Nat.log2 x)). omega. eapply lt_le_trans. eapply mult_lt_compat. eapply H0. eapply H0. eapply S_log_square_lt. trivial. Qed.Theorem poly_lt_exp_ge_6 : forall c x, x >= (Nat.pow 2 c) -> x >= (Nat.pow 2 6) -> Nat.pow x c < Nat.pow 2 x. intuition. specialize (Nat.log2_spec_alt); intuition. destruct (H1 x). eapply lt_le_trans. 2:{ eapply H. } eapply (expnat_2_ge_1 c). intuition. destruct (eq_nat_dec x0 0). rewrite e in H3. rewrite plus_0_r in *. rewrite H3. rewrite <- Nat.pow_mul_r. eapply Nat.pow_lt_mono_r. omega. rewrite <- H3. assert (c <= Nat.log2 x). eapply (@Nat.pow_le_mono_r_iff 2). omega. rewrite <- H3. trivial. eapply le_lt_trans. eapply mult_le_compat. eapply le_refl. eapply H4. eapply log_square_lt. eapply le_trans. 2:{ eapply H0. } eapply Nat.pow_le_mono_r. omega. omega. destruct (eq_nat_dec c 0). rewrite e. simpl. eapply le_lt_trans. assert (1 <= expnat 2 0). trivial. eapply H4. eapply Nat.pow_lt_mono_r. omega. omega. assert (expnat x c < expnat (2 ^ S (Nat.log2 x)) c). eapply Nat.pow_lt_mono_l. omega. eapply Nat.log2_spec. omega. eapply lt_le_trans. eapply H4. rewrite <- Nat.pow_mul_r. eapply Nat.pow_le_mono_r. omega. assert (c <= S (Nat.log2 x)). eapply (@Nat.pow_le_mono_r_iff 2). omega. eapply le_trans. eapply H. eapply lt_le_weak. eapply Nat.log2_spec. omega. eapply le_trans. eapply mult_le_compat. eapply le_refl. eapply H6. eapply S_log_square_lt. eapply le_trans. 2:{ eapply H0. } eapply Nat.pow_le_mono_r. omega. omega. Qed.Theorem poly_lt_exp : forall c, exists x, forall y, y >= x -> expnat y c < expnat 2 y. intuition. exists (expnat 2 (max c 6)). intuition. eapply poly_lt_exp_ge_6. eapply le_trans. 2:{ eapply H. } eapply Nat.pow_le_mono_r. omega. eapply Max.le_max_l. eapply le_trans. 2:{ eapply H. } eapply Nat.pow_le_mono_r. omega. eapply Max.le_max_r. Qed. Theorem negligible_exp_den : negligible (fun n => 1 / expnat 2 n)%rat. unfold negligible in *. intuition. destruct (poly_lt_exp c). exists x. intuition. eapply (rat_num_not_le). eapply H1. unfold posnatToNat, natToPosnat. eapply H. omega. Qed. Theorem negligible_const_mult : forall (n : nat) d f, negligible f -> negligible (fun x => (RatIntro n d) * (f x))%rat. 
star, inj, interp; intros. propxIntuition; eauto using HT.semp_smem_emp, HT.split_a_semp_a. eapply Imply_E. eapply valid_weaken; eauto. firstorder. econstructor. firstorder. Qed. Theorem himp_subst_p : forall P Q R S, himp P S -> himp (star S Q) R -> himp (star P Q) R. Proof. unfold himp, star, interp; intros; propxIntuition. specialize (H s x). specialize (H0 s m). eapply Imply_E. eapply valid_weaken. eapply H0. firstorder. propxIntuition. eauto. eapply Imply_E. eapply valid_weaken. eauto. firstorder. econstructor; firstorder. Qed. Theorem himp_subst_c : forall P Q R S, himp S Q -> himp P (star S R) -> himp P (star Q R). Proof. unfold himp, star, interp; intros. eapply Imply_I. eapply valid_extend. eapply Imply_E. eapply valid_weaken. specialize (H0 s m). eassumption. firstorder. eauto. propxIntuition; eauto. eapply Imply_E. eapply valid_weaken. eapply H. firstorder. econstructor; firstorder. Qed. Theorem heq_subst : forall P Q R S, heq P S -> heq (star S Q) R -> heq (star P Q) R. Proof. unfold heq. intros. intuition; generalize himp_subst_p; generalize himp_subst_c; eauto. Qed. Theorem himp_star_emp_p : forall P Q, himp P Q -> himp (star emp P) Q. Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply Imply_E. eapply valid_weaken; [ eapply H | firstorder ]. eapply HT.split_semp in H0; eauto; subst. propxIntuition. Qed. Theorem himp_star_emp_p' : forall P Q, himp (star emp P) Q -> himp P Q. Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply Imply_E. eapply valid_weaken; [ eapply H | firstorder ]. propxIntuition. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. Qed. Theorem himp_star_emp_c : forall P Q, himp P Q -> himp P (star emp Q). Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. eapply Imply_E. eapply valid_weaken; [ eapply H | firstorder ]. propxIntuition. Qed. Theorem himp_star_emp_c' : forall P Q, himp P (star emp Q) -> himp P Q. Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply valid_extend. eapply Imply_E. eapply valid_weaken. eapply (H s m). firstorder. econstructor; firstorder. propxIntuition. eapply HT.split_semp in H0; eauto; subst. propxIntuition. Qed. Theorem heq_star_emp_l : forall P, heq (star emp P) P. intros. unfold heq in *; intuition. eapply himp_star_emp_p. reflexivity. eapply himp_star_emp_c. reflexivity. Qed. Theorem heq_star_emp_r : forall P, heq (star P emp) P. Proof. intros. unfold heq, himp, star, emp, inj, interp in *; intuition. propxIntuition. eapply HT.split_comm in H. eapply HT.split_semp in H; eauto; subst. propxIntuition. propxIntuition. eapply HT.split_comm. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. Qed. Theorem himp_star_cancel : forall P Q R, himp Q R -> himp (star P Q) (star P R). 
S) as T. exists T. symmetry. apply seg_α. apply Ht. Qed. Theorem ord_trans : ∀α ⋵ 𝐎𝐍, trans α. Proof. intros α [S H]. subst. apply α_trans. Qed. Theorem ord_irrefl : ∀α ⋵ 𝐎𝐍, α ∉ α. Proof. intros α [S H]. subst. intros H. pose proof (ordE _ _ H) as [s [Hs Heq]]. rewrite <- Heq in H. eapply e_irrefl; eauto. Qed.End OrdDef. Notation 𝐎𝐍 := is_ord. Global Hint Immediate ord_is_ord : core. Theorem ord_trich : ∀ α β ⋵ 𝐎𝐍, α ∈ β ∧ α  β ∧ β ∉ α ∨ α ∉ β ∧ α = β ∧ β ∉ α ∨ α ∉ β ∧ α  β ∧ β ∈ α. Proof with eauto. intros α Hα β Hβ. assert (α ∈ β ∨ α = β ∨ β ∈ α). { destruct Hα as [S Heqα]. destruct Hβ as [T Heqβ]. subst. destruct (wo_iso_at_least_trich S T) as [H|[[t [Ht H]]|[t [Ht H]]]]. - right; left. apply ord_well_defined... - left. eapply ord_lt_intro... - right; right. eapply ord_lt_intro... symmetry... } destruct H as [Hab|[Hnq|Hba]]. - left. split... split; intros H; subst; eapply ord_irrefl... eapply ord_trans... - right; left. repeat split; auto; intros H; subst; eapply ord_irrefl... - right; right. repeat split; auto; intros H; subst; eapply ord_irrefl... eapply ord_trans... Qed. Corollary ord_connected : ∀ α β ⋵ 𝐎𝐍, α  β → α ∈ β ∨ β ∈ α. Proof. intros α Hα β Hβ Hnq. destruct (ord_trich α Hα β) as [[H []]|[[H []]|[H []]]]; tauto. Qed. Corollary ord_comparability : ∀ α β ⋵ 𝐎𝐍, α ⋸ β ∨ β ⋸ α. Proof with auto. intros α Hα β Hβ. destruct (classic (α = β)). left. right... apply ord_connected in H as []... Qed. Corollary ord_le_iff_sub : ∀ α β ⋵ 𝐎𝐍, α ⋸ β ↔ α ⊆ β. Proof with eauto. intros α Hα β Hβ. split. - intros []. + intros x Hx. eapply ord_trans... + subst. apply sub_refl. - intros H. destruct (classic (α = β)). right... left. apply ord_connected in H0 as []... apply H in H0. exfalso. eapply ord_irrefl... Qed.Ltac ord_ext := apply sub_antisym; apply ord_le_iff_sub. Fact seg_of_ord : ∀α ⋵ 𝐎𝐍, ∀β ∈ α, seg β (MemberRel α) = β. Proof with eauto. intros α Hα β Hlt. ext Hx. - apply SepE2 in Hx. apply binRelE3 in Hx... - apply segI. apply binRelI... eapply ord_trans... Qed. Theorem ords_has_minimum : ∀ A, A ⪽ 𝐎𝐍 → ⦿ A → ∃μ ∈ A, ∀α ∈ A, μ ⋸ α. 
k v. Proof. unseal. iDestruct 1 as (m_ro ->) "Hm". iIntros "Hk". iDestruct (own_valid_2 with "Hm Hk") as %[Hlookup%map_ptsto_included _]%auth_both_valid_discrete. iMod (own_update_2 with "Hm Hk") as "[Hm $]". { eapply auth_update, singleton_local_update, (exclusive_local_update _ (Cinr (to_agree (v: leibnizO V))))=> //. rewrite lookup_fmap Hlookup //=. } iModIntro. rewrite -to_mapUR_insert_inr. iExists _; iFrame. iPureIntro. apply map_eq; intros k'; rewrite !lookup_fmap. destruct (decide (k = k')); subst. - rewrite lookup_insert Hlookup //. - rewrite lookup_insert_ne //. Qed. Theorem map_alloc_ro {γ m} k v : m !! k = None → map_ctx γ 1 m ==∗ map_ctx γ 1 (<[k:=v]> m) ∗ ptsto_ro γ k v. Proof. iIntros (?) "Hm". iMod (map_alloc k v with "Hm") as "[Hm Hk]"; auto. iMod (map_freeze with "Hm Hk") as "[$ $]". auto. Qed. Theorem map_alloc_many' {γ m} m0 Φ: (∀ m k v, m !! k = None → map_ctx γ 1 m ==∗ map_ctx γ 1 (<[k:=v]> m) ∗ Φ k v) → ( ∀ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx γ 1 m ==∗ map_ctx γ 1 (m0 ∪ m) ∗ [∗ map] a↦v ∈ m0, Φ a v. Proof. iIntros (Halloc Hnone) "Hm". iInduction m0 as [|l v m0'] "IH" using map_ind forall (m Hnone). { rewrite left_id. iFrame. iModIntro. iApply big_sepM_empty. done. } iMod ("IH" with "[] Hm") as "[Hm Hmany]". { iPureIntro. intros k Hk. eapply Hnone. destruct (decide (l = k)); subst. { rewrite lookup_insert. eauto. } rewrite lookup_insert_ne; eauto. } iMod (Halloc _ l v with "Hm") as "[Hm Hl]". { rewrite lookup_union_None; intuition. eapply Hnone. rewrite lookup_insert. eauto. } iModIntro. rewrite insert_union_l; iFrame "Hm". iApply big_sepM_insert; eauto. iFrame. Qed. Theorem map_alloc_many {γ m} m0 : ( ∀ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx γ 1 m ==∗ map_ctx γ 1 (m0 ∪ m) ∗ [∗ map] a↦v ∈ m0, ptsto_mut γ a 1 v. Proof. intros. iApply (map_alloc_many' _ (λ a v, ptsto_mut γ a 1 v)); eauto. intros. by apply map_alloc. Qed. Theorem map_alloc_many_ro {γ m} m0 : ( ∀ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx γ 1 m ==∗ map_ctx γ 1 (m0 ∪ m) ∗ [∗ map] a↦v ∈ m0, ptsto_ro γ a v. Proof. intros. iApply (map_alloc_many' _ (λ a v, ptsto_ro γ a v)); eauto. intros. by apply map_alloc_ro. Qed. Theorem map_init_many m : ⊢ |==> ∃ γ, map_ctx γ 1 m ∗ ([∗ map] a ↦ v ∈ m, ptsto_mut γ a 1 v). 
Module NonDependentPairsWithNonDependentElimination. Definition Pair (X Y : Prop) : Prop := forall (Z : Prop), (X -> Y -> Z) -> Z. Definition construct (X Y : Prop) : X -> Y -> Pair X Y := fun x y Z f => f x y. Definition eliminate (X Y Z : Prop) : (X -> Y -> Z) -> Pair X Y -> Z := fun f p => p Z f. Definition first (X Y : Prop) : Pair X Y -> X := fun p => eliminate X Y X (fun x _ => x) p. Definition second (X Y : Prop) : Pair X Y -> Y := fun p => eliminate X Y Y (fun _ y => y) p. Theorem betaFirst : forall (X Y : Prop) (x : X) (y : Y), first X Y (construct X Y x y) = x. Proof. reflexivity. Qed. Theorem betaSecond : forall (X Y : Prop) (x : X) (y : Y), second X Y (construct X Y x y) = y. Proof. reflexivity. Qed. Axiom eta : forall (X Y : Prop) (p : Pair X Y), construct X Y (first X Y p) (second X Y p) = p. End NonDependentPairsWithNonDependentElimination.Module DependentPairsWithNonDependentElimination. Definition Pair (X : Prop) (Y : X -> Prop) : Prop := forall (Z : Prop), (forall x, Y x -> Z) -> Z. Definition construct (X : Prop) (Y : X -> Prop) : forall (x : X), Y x -> Pair X Y := fun x y Z f => f x y. Definition eliminate (X : Prop) (Y : X -> Prop) (Z : Prop) : (forall (x : X), Y x -> Z) -> Pair X Y -> Z := fun f p => p Z f. Definition first (X : Prop) (Y : X -> Prop) : Pair X Y -> X := fun p => eliminate X Y X (fun x _ => x) p. Parameter second : forall (X : Prop) (Y : X -> Prop) (p : Pair X Y), Y (first X Y p). Theorem betaFirst : forall (X : Prop) (Y : X -> Prop) (x : X) (y : Y x), first X Y (construct X Y x y) = x. 
n1 Int.iwordsize) eqn:?; simpl; auto. rewrite Heqb; rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shru_shru; auto. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\ Val.lessdef (Val.mul x (Vint n)) v). TrivialExists. econstructor. EvalOp. simpl; eauto. econstructor. eauto. constructor. rewrite Val.mul_commut. auto. generalize (Int.one_bits_decomp n). generalize (Int.one_bits_range n). destruct (Int.one_bits n). intros. auto. destruct l. intros. rewrite H1. simpl. rewrite Int.add_zero. replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul. apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib. destruct l. intros. rewrite H1. simpl. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exploit (eval_add (x :: le)). eexact A1. eexact A2. intros [v [A B]]. exists v; split. econstructor; eauto. rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. eapply Val.lessdef_trans. 2: eauto. apply Val.add_lessdef; auto. simpl. repeat rewrite H0; auto with coqlib. intros. auto. Qed. Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros until x; unfold mulimm. predSpec Int.eq Int.eq_spec n Int.zero. intros. exists (Vint Int.zero); split. EvalOp. destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto. predSpec Int.eq Int.eq_spec n Int.one. intros. exists x; split; auto. destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto. case (mulimm_match a); intros; InvEval. TrivialExists. simpl. rewrite Int.mul_commut; auto. subst. rewrite Val.mul_add_distr_l. exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]]. exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]]. exists v''; split; auto. eapply Val.lessdef_trans. eapply Val.add_lessdef; eauto. rewrite Val.mul_commut; auto. apply eval_mulimm_base; auto. Qed.Theorem eval_mul: binary_constructor_sound mul Val.mul. Proof. red; intros until y. unfold mul; case (mul_match a b); intros; InvEval. rewrite Val.mul_commut. apply eval_mulimm. auto. apply eval_mulimm. auto. TrivialExists. Qed.Theorem eval_mulhs: binary_constructor_sound mulhs Val.mulhs. Proof. unfold mulhs; red; intros; TrivialExists. Qed. Theorem eval_mulhu: binary_constructor_sound mulhu Val.mulhu. Proof. unfold mulhu; red; intros; TrivialExists. Qed. Theorem eval_andimm: forall n, unary_constructor_sound (andimm n) (fun x => Val.and x (Vint n)). 
eps' is). Defined.Corollary isofhlevelweqf (n : nat) {X Y : UU} (f : X ≃ Y) : isofhlevel n X -> isofhlevel n Y. Proof. intros X0. apply (hlevelretract n f (invmap f) (homotweqinvweq f)). assumption. Defined.Corollary isofhlevelweqb (n : nat) {X Y : UU} (f : X ≃ Y) : isofhlevel n Y -> isofhlevel n X. Proof. intros X0. apply (hlevelretract n (invmap f) f (homotinvweqweq f)). assumption. Defined.Lemma isofhlevelsn (n : nat) {X : UU} (f : X -> isofhlevel (S n) X) : isofhlevel (S n) X. Proof. intros. simpl. intros x x'. apply (f x x x'). Defined.Lemma isofhlevelssn (n : nat) {X : UU} (is : ∏ x : X, isofhlevel (S n) (x = x)) : isofhlevel (S (S n)) X. Proof. intros. simpl. intros x x'. change (∏ (x0 x'0 : x = x'), isofhlevel n (x0 = x'0)) with (isofhlevel (S n) (x = x')). assert (X1 : x = x' -> isofhlevel (S n) (x = x')) by (intro X2; induction X2; apply (is x)). apply (isofhlevelsn n X1). Defined. Definition isofhlevelf (n : nat) {X Y : UU} (f : X -> Y) : UU := ∏ y : Y, isofhlevel n (hfiber f y). Theorem isofhlevelfhomot (n : nat) {X Y : UU} (f f' : X -> Y) (h : ∏ x : X, paths (f x) (f' x)) : isofhlevelf n f -> isofhlevelf n f'. Proof. intros X0. unfold isofhlevelf. intro y. apply (isofhlevelweqf n (weqhfibershomot f f' h y) (X0 y)). Defined. Theorem isofhlevelfpmap (n : nat) {X Y : UU} (f : X -> Y) (Q : Y -> UU) : isofhlevelf n f -> isofhlevelf n (fpmap f Q). Proof. intros X0. unfold isofhlevelf. unfold isofhlevelf in X0. intro y. set (yy := pr1 y). set (g := hfiberfpmap f Q y). set (is := isweqhfiberfp f Q y). set (isy := X0 yy). apply (isofhlevelweqb n (make_weq g is) isy). Defined.Theorem isofhlevelfffromZ (n : nat) {X Y Z : UU} (f : X -> Y) (g : Y -> Z) (z : Z) (fs : fibseqstr f g z) (isz : isofhlevel (S n) Z) : isofhlevelf n f. Proof. intros. intro y. assert (w : (hfiber f y) ≃ ((g y) = z)). apply (invweq (ezweq1 f g z fs y)). apply (isofhlevelweqb n w (isz (g y) z)). Defined. Theorem isofhlevelXfromg (n : nat) {X Y Z : UU} (f : X -> Y) (g : Y -> Z) (z : Z) (fs : fibseqstr f g z) : isofhlevelf n g -> isofhlevel n X. 
Theorem t : forall n, n = 0 \/ n > 0. 
Require Import abp_base. Require Import abp_defs. Require Import abp_lem1.Theorem Lem1 : D + (fun d : D => seq (ia D r1 d) (X1 d)) = X. unfold X at 1 in |- *. elim ProcS; elim ProcR. elim EXPH4. elim LmerSn. elim LmerK. elim LmerL. elim LmerRn. elim CommLRn. elim CommKL. elim CommKRn. elim CommSnK. elim CommSnL. elim CommSnRn. repeat elim A6. elim (A6 (D + (fun d : D => seq (ia D r1 d) (enc H (mer (seq (Sn_d d e0) (seq (Sn e1) (S i))) (mer (K i) (mer (L i) (seq (Rn e1) (seq (Rn e0) (R i)))))))))). unfold X1 in |- *. pattern (R i) at 1 in |- *. elim ProcR. apply refl_equal. Qed. Theorem Lem2 : D + (fun d : D => seq (ia D r1 d) (Y1 d)) = Y. 
Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.EchoServer Bedrock.Platform.Bootstrap. Module Type S. Parameter heapSize : nat. Parameters port numWorkers : W. End S.Module Make(M : S). Import M.Module M'. Definition globalSched : W := ((heapSize + 50) * 4)%nat. Definition globalSock : W := globalSched ^+ $4. Definition port := M.port. Definition numWorkers := M.numWorkers. Definition inbuf_size := 40. Theorem inbuf_size_lower : (inbuf_size >= 2)%nat. unfold inbuf_size; auto. Qed. Theorem inbuf_size_upper : (N_of_nat (inbuf_size * 4) < Npow2 32)%N. reflexivity. Qed. End M'.Import M'.Module E := EchoServer.Make(M'). Import E.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 2. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 2. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "echo"!"main" @ [E.mainS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREmain[_] globalSched =?> 2 * 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREmain[_] globalSock =?> 1 * globalSched =?> 1 * mallocHeap 0];; Goto "echo"!"main" end }}. Ltac t := unfold globalSched, localsInvariantMain, M'.globalSock, M'.globalSched; genesis. Theorem ok0 : moduleOk boot. 
{{{ is_lock lk R }}} lock.try_acquire lk @ stk; E {{{ b, RET #b; if b is true then locked lk ∗ R else True }}}. Proof. iIntros (? Φ) "#Hl HΦ". iDestruct "Hl" as (l ->) "#Hinv". wp_rec. wp_bind (CmpXchg _ _ _). iInv N as ([]) "[Hl HR]". - wp_cmpxchg_fail. iModIntro. iSplitL "Hl"; first (iNext; iExists true; eauto). wp_pures. iApply ("HΦ" $! false). done. - iDestruct "HR" as "[Hl2 HR]". iCombine "Hl Hl2" as "Hl". rewrite Qp.quarter_three_quarter. wp_cmpxchg_suc. iModIntro. iEval (rewrite -Qp.quarter_three_quarter) in "Hl". iDestruct (fractional.fractional_split_1 with "Hl") as "[Hl1 Hl2]". iSplitL "Hl1"; first (iNext; iExists true; eauto). rewrite /locked. wp_pures. iApply "HΦ". eauto with iFrame. Qed. Lemma acquire_spec' stk E lk R : ↑N ⊆ E → {{{ is_lock lk R }}} lock.acquire lk @ stk; E {{{ RET #(); locked lk ∗ R }}}. Proof. iIntros (? Φ) "#Hl HΦ". iLöb as "IH". wp_rec. wp_apply (try_acquire_spec with "Hl"); auto. iIntros ([]). - iIntros "[Hlked HR]". wp_if. iApply "HΦ"; by iFrame. - iIntros "_". wp_if. iApply ("IH" with "[HΦ]"). auto. Qed. Lemma acquire_spec lk R : {{{ is_lock lk R }}} lock.acquire lk {{{ RET #(); locked lk ∗ R }}}. Proof. eapply acquire_spec'; auto. Qed. Lemma release_spec' stk E lk R : ↑N ⊆ E → {{{ is_lock lk R ∗ locked lk ∗ ▷ R }}} lock.release lk @ stk; E {{{ RET #(); True }}}. Proof. iIntros (? Φ) "(Hlock & Hlocked & HR) HΦ". iDestruct "Hlock" as (l ->) "#Hinv". rewrite /lock.release /=. wp_lam. wp_bind (CmpXchg _ _ _). iInv N as (b) "[>Hl _]". iDestruct (locked_loc with "Hlocked") as "Hl2". iDestruct (heap_mapsto_agree with "[$Hl $Hl2]") as %->. iCombine "Hl Hl2" as "Hl". rewrite Qp.quarter_three_quarter. wp_cmpxchg_suc. iModIntro. iSplitR "HΦ"; last by wp_seq; iApply "HΦ". iEval (rewrite -Qp.quarter_three_quarter) in "Hl". iDestruct (fractional.fractional_split_1 with "Hl") as "[Hl1 Hl2]". iNext. iExists false. iFrame. Qed. Lemma release_spec lk R : {{{ is_lock lk R ∗ locked lk ∗ ▷ R }}} lock.release lk {{{ RET #(); True }}}. Proof. eapply release_spec'; auto. Qed. Lemma release_spec'' lk R : is_lock lk R -∗ {{{ locked lk ∗ ▷ R }}} lock.release lk {{{ RET #(); True }}}. Proof. iIntros "#Hlock !# %Φ [??] HΦ". iApply (release_spec with "[-HΦ]"); by iFrame. Qed. Definition is_cond (c: loc) (lk : val) : iProp Σ := readonly (c ↦ lk). Global Instance is_cond_persistent c lk : Persistent (is_cond c lk) := _. Theorem wp_newCond' lk : {{{ is_free_lock lk }}} lock.newCond #lk {{{ (c: loc), RET #c; is_free_lock lk ∗ is_cond c #lk }}}. 
beta FLX_exp)). intros x. split. apply FLX_format_generic. apply generic_format_FLX. Qed.Theorem FLX_format_FIX : forall x e, (bpow (e - 1) <= Rabs x <= bpow e)%R -> FIX_format beta (e - prec) x -> FLX_format x. Proof with auto with typeclass_instances. intros x e Hx Fx. apply FLX_format_generic. apply generic_format_FIX in Fx. revert Fx. apply generic_inclusion with (e := e)... apply Zle_refl. Qed. Definition FLXN_format (x : R) := exists f : float beta, x = F2R f /\ (x <> R0 -> Zpower beta (prec - 1) <= Zabs (Fnum f) < Zpower beta prec)%Z.Theorem generic_format_FLXN : forall x, FLXN_format x -> generic_format beta FLX_exp x. Proof. intros x ((xm,ex),(H1,H2)). destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx. apply generic_format_0. specialize (H2 Zx). apply generic_format_FLX. rewrite H1. eexists ; repeat split. apply H2. Qed.Theorem FLXN_format_generic : forall x, generic_format beta FLX_exp x -> FLXN_format x. Proof. intros x Hx. rewrite Hx. simpl. eexists ; split. split. simpl. rewrite <- Hx. intros Zx. split.apply le_Z2R. rewrite Z2R_Zpower. 2: now apply Zlt_0_le_0_pred. rewrite Z2R_abs, <- scaled_mantissa_generic with (1 := Hx). apply Rmult_le_reg_r with (bpow (canonic_exp beta FLX_exp x)). apply bpow_gt_0. rewrite <- bpow_plus. rewrite <- scaled_mantissa_abs. rewrite <- canonic_exp_abs. rewrite scaled_mantissa_mult_bpow. unfold canonic_exp, FLX_exp. rewrite ln_beta_abs. ring_simplify (prec - 1 + (ln_beta beta x - prec))%Z. destruct (ln_beta beta x) as (ex,Ex). now apply Ex.apply lt_Z2R. rewrite Z2R_Zpower. 2: now apply Zlt_le_weak. rewrite Z2R_abs, <- scaled_mantissa_generic with (1 := Hx). apply Rmult_lt_reg_r with (bpow (canonic_exp beta FLX_exp x)). apply bpow_gt_0. rewrite <- bpow_plus. rewrite <- scaled_mantissa_abs. rewrite <- canonic_exp_abs. rewrite scaled_mantissa_mult_bpow. unfold canonic_exp, FLX_exp. rewrite ln_beta_abs. ring_simplify (prec + (ln_beta beta x - prec))%Z. destruct (ln_beta beta x) as (ex,Ex). now apply Ex. Qed.Theorem FLXN_format_satisfies_any : satisfies_any FLXN_format. Proof. refine (satisfies_any_eq _ _ _ (generic_format_satisfies_any beta FLX_exp)). split ; intros H. now apply FLXN_format_generic. now apply generic_format_FLXN. Qed.Theorem ulp_FLX_0: (ulp beta FLX_exp 0 = 0)%R. Proof. unfold ulp; rewrite Req_bool_true; trivial. case (negligible_exp_spec FLX_exp). intros _; reflexivity. intros n H2; contradict H2. unfold FLX_exp; unfold Prec_gt_0 in prec_gt_0_; omega. Qed.Theorem ulp_FLX_le: forall x, (ulp beta FLX_exp x <= Rabs x * bpow (1-prec))%R. Proof. intros x; case (Req_dec x 0); intros Hx. rewrite Hx, ulp_FLX_0, Rabs_R0. right; ring. rewrite ulp_neq_0; try exact Hx. unfold canonic_exp, FLX_exp. replace (ln_beta beta x - prec)%Z with ((ln_beta beta x - 1) + (1-prec))%Z by ring. rewrite bpow_plus. apply Rmult_le_compat_r. apply bpow_ge_0. now apply bpow_ln_beta_le. Qed. Theorem ulp_FLX_ge: forall x, (Rabs x * bpow (-prec) <= ulp beta FLX_exp x)%R. 
: forall n m p : Z, Zdivides n m -> Zdivides (p * n) (p * m). intros n m p H'; red in H'. elim H'; intros q E. red in |- *. exists q. rewrite E. auto with zarith. Qed. Theorem Zeq_mult_simpl : forall a b c : Z, c <> 0%Z -> (a * c)%Z = (b * c)%Z -> a = b. intros a b c H H0. case (Zle_or_lt c 0); intros Zl1. apply Zle_antisym; apply Zmult_le_reg_r with (p := (- c)%Z); try apply Zlt_gt; auto with zarith; repeat rewrite <- Zopp_mult_distr_r; rewrite H0; auto with zarith. apply Zle_antisym; apply Zmult_le_reg_r with (p := c); try apply Zlt_gt; auto with zarith; rewrite H0; auto with zarith. Qed. Theorem ZdividesDiv : forall n m p : Z, p <> 0%Z -> Zdivides (p * n) (p * m) -> Zdivides n m. intros n m p H' H'0. case H'0; intros q E. exists q. apply Zeq_mult_simpl with (c := p); auto. rewrite (Zmult_comm n); rewrite E; ring. Qed. Definition ZdividesP : forall n m : Z, {Zdivides n m} + {~ Zdivides n m}. intros n m; case m. case n. left; red in |- *; exists 0%Z; auto with zarith. intros p; right; red in |- *; intros H; case H; simpl in |- *; intros f H1; discriminate. intros p; right; red in |- *; intros H; case H; simpl in |- *; intros f H1; discriminate. intros p; generalize (Z_eq_bool_correct (Zquotient n (Zpos p) * Zpos p) n); case (Z_eq_bool (Zquotient n (Zpos p) * Zpos p) n); intros H1. left; apply ZdividesZquotientInv; auto. right; Contradict H1; apply sym_equal; apply ZdividesZquotient; auto. red in |- *; intros; discriminate. intros p; generalize (Z_eq_bool_correct (Zquotient n (Zneg p) * Zneg p) n); case (Z_eq_bool (Zquotient n (Zneg p) * Zneg p) n); intros H1. left; apply ZdividesZquotientInv; auto. right; Contradict H1; apply sym_equal; apply ZdividesZquotient; auto. red in |- *; intros; discriminate. Defined. Theorem Zquotient1 : forall m : Z, Zquotient m 1 = m. intros m. case (ZquotientProp m 1); auto. red in |- *; intros; discriminate. intros z (H1, (H2, H3)). pattern m at 2 in |- *; rewrite H1; replace z with 0%Z; try ring. generalize H3; case z; simpl in |- *; auto; intros p; case p; unfold Zlt in |- *; simpl in |- *; intros; discriminate. Qed. Theorem Zdivides1 : forall m : Z, Zdivides m 1. 
Hnint. rewrite make_triples_make_triples' by eauto. eapply in_map_iff. exists (w, ADT a'', o); simpl; split; trivial. eapply nth_error_In with (n := n). eapply nth_error_combine; eauto. } assert (Hnin' : ~ In w h1). { intros Hin. subst h1. eapply in_find_Some in Hin. destruct Hin as [a'' Hin]. rewrite make_heap_make_heap' in Hin by eauto. eapply mapsto_make_heap'_iff in Hin; trivial. contradict Hnin. exists a''; eauto. } assert (Hhh1 : find w (h - h1) = find w h). { rewrite diff_o by eauto. eauto. } rewrite <- Hhh1 in Hw. eapply Hhle in Hw. eauto. } destruct Hx as [a' Hin]. rewrite make_triples_make_triples' in Hin by eauto. unfold make_triples' in Hin. eapply in_map_iff in Hin. destruct Hin as [ [ [w1 a1'] a1] [Hinj Hin] ]. inject Hinj. eapply in_nth_error in Hin. destruct Hin as [n Hin]. eapply nth_error_combine_elim in Hin. destruct Hin as [Hin Ho]. unfold outputs_gen in Ho. eapply nth_error_map_elim in Ho. destruct Ho as [ [w1 a1'] [Hinj Ho] ]. subst words_inputs. rewrite Hin in Hinj. symmetry in Hinj. inject Hinj. unfold output_gen in Ho. rewrite Hcond in Ho. eauto. } } } { eauto. } { eauto. } { subst h1. eapply good_inputs_make_heap_submap; eauto. } { subst h1. subst st. eapply DFacadeToBedrock2Util.make_map_make_heap_related with (ks := ArgVars) (pairs := words_inputs); simpl; eauto. { eapply forall_word_adt_match_good_scalars; eauto. } { subst words_inputs. rewrite map_fst_combine; try rewrite map_length in *; eauto. } { subst words_inputs. rewrite map_snd_combine; try rewrite map_length in *; eauto. } } { Require Import Bedrock.Platform.Cito.StringMap. Import StringMap. Require Import Bedrock.Platform.Cito.StringMapFacts. Import FMapNotations. eapply not_find_in_iff. eapply make_map_not_in. intros Hin. copy_as args_name_ok Hgn. eapply forallb_forall in Hgn; eauto. intuition. } { eapply env_ok; eauto. } { eapply Hrefines; eauto. } } Qed. Definition output_module : XCAP.module := CM2.make_module cito_module imports exports ax_mod_name op_mod_name op_mod_name_ok. Definition output_module_ok : moduleOk output_module. refine (CM2.make_module_ok cito_module imports exports _ ax_mod_name op_mod_name op_mod_name_ok op_mod_name_not_in_imports name_neq _). { eapply exports_in_domain_cmodule. } { eapply Hewi_cmodule. } Defined. Theorem output_module_exports x ax : find x exports = Some ax -> LabelMap.find (ax_mod_name, Global x) (Exports output_module) = Some (foreign_func_spec (ax_mod_name, x) ax). Proof. eapply CM2.make_module_exports; eauto. eapply exports_in_domain_cmodule. Qed. Notation compile_cito_to_bedrock := compile_to_bedrock. Definition output_module_impl := (compile_cito_to_bedrock gmodules imports). Open Scope bool_scope. Require Import Coq.Bool.Bool. Import MakeWrapperMake.LinkMake. Import MakeWrapperMake.LinkMake.LinkModuleImplsMake. Lemma import_module_names_good : let imported_module_names := List.map (fun x => fst (fst x)) (GLabelMap.elements imports) in forallb Cito.NameDecoration.is_good_module_name imported_module_names = true. Proof. generalize module; clear. destruct module. eapply import_module_names_good. Qed. Theorem output_module_impl_ok : moduleOk output_module_impl. 
Set Implicit Arguments. Require Import VST.msl.Axioms. Require Import compcert.lib.Coqlib. Require Import compcert.lib.Integers. Require Import sha.general_lemmas. Require Import sha.ByteBitRelations. Require Import sha.HMAC_common_defs. Require Import sha.HMAC_spec_pad. Require Import Lia. Require Import sha.SHA256. Require Import sha.HMAC_functional_prog. Require Import sha.HMAC256_functional_prog. Require Import sha.hmac_common_lemmas. Require Import sha.sha_padding_lemmas. Require Import sha.ShaInstantiation. Lemma splitandpad_equiv : forall (bits : Blist) (bytes : list byte), bytes_bits_lists bits bytes -> bytes_bits_lists (sha_splitandpad bits) (pad bytes). Proof. intros bits bytes inputs_eq. unfold concat. unfold sha_splitandpad. apply bytes_bits_ind_comp in inputs_eq. rewrite inputs_eq. apply bytes_bits_def_eq. Qed.Lemma gap_divide16 bits: NPeano.Nat.divide 16 (length (generate_and_pad' (bitsToBytes bits))). Proof. unfold generate_and_pad'. destruct (pad_len_64_nat (bitsToBytes bits)). rewrite pure_lemmas.length_bytelist_to_intlist with (n:=(x*16)%nat). exists x. trivial. rewrite H. unfold WORD. rewrite (mult_comm (Z.to_nat 4)). rewrite mult_comm. rewrite <- mult_assoc. reflexivity. Qed. Module I256 <: INST. Definition shah : Blist -> Blist -> Blist := sha_h. Definition hashblock : list int -> list int -> list int := SHA256.hash_block. Definition HHB : shah = (fun rgs bl : Blist => intsToBits (hashblock (bitsToInts rgs) (bitsToInts bl))). reflexivity. Qed. Definition hashblocks: list int -> list int -> list int := SHA256.hash_blocks. Definition d:nat := 16%nat. Definition HBS_eq : forall r msg : list int, hash_blocks r msg = match msg with | List.nil => r | _ :: _ => hash_blocks (hash_block r (firstn d msg)) (skipn d msg) end := hash_blocks_equation. End I256.Module PAD := HMAC_Pad SHA256 I256. Theorem HMAC_pad_concrete (K : list byte) (M H : list byte) (OP IP : byte) (k m h : Blist) (op ip : Blist): ((length K) * 8)%nat = (c + p)%nat -> bytes_bits_lists k K -> bytes_bits_lists m M -> bytes_bits_lists op (HMAC_SHA256.sixtyfour OP) -> bytes_bits_lists ip (HMAC_SHA256.sixtyfour IP) -> sha.HMAC_spec_pad.HMAC c p B sha_h sha_iv sha_splitandpad op ip k m = h -> HMAC_SHA256.HmacCore IP OP M K = H -> bytes_bits_lists h H. 
Theorem bitcount_0_1_power (n : Word) : bitcount #0 n = #1 <-> exists i, n = (2^i)%N. Proof. rewrite /bitcount /popCount /=. split=> [/N_popcount_1_pow2 [i def_n] | [i ->{n}]]. - by exists i. - apply N_popcount_pow2. Qed.Theorem WF_Bin_mask_power_N {p : Prefix} {m : Mask} {l r : IntSet} : WF (Bin p m l r) -> ex (fun i => m = 2^i)%N. Proof. move=> /valid_maskPowerOfTwo /= /and3P [/Eq_eq BITS _ _]. by apply bitcount_0_1_power. Qed. Theorem WF_Bin_children (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF l /\ WF r. Proof. case=> fn; inversion 1 as [|s bounds fn' desc]; subst s fn'; inversion desc as [|l' bounds_l fn_l r' bounds_r fn_r p' m' bounds' fn' desc_l desc_r is_pos sub_l sub_r def_p def_m spec_fn]; subst p' m' l' r' bounds' fn'. split; [exists fn_l | exists fn_r]; eauto using DescSem. Qed.Corollary WF_Bin_left (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF l. Proof. by move=> /WF_Bin_children []. Qed.Corollary WF_Bin_right (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF r. Proof. by move=> /WF_Bin_children []. Qed. Theorem toList_sorted (s : IntSet) : WF s -> StronglySorted _<_ (toList s). Proof. move=> WF_s; apply StronglySorted_R_ext with N.lt; last by apply to_List_sorted. move=> a b; unfold "<", Ord_Integer___ => /=. symmetry; apply rwP. apply/N.ltb_spec0. Qed.Theorem toAscList_sorted (s : IntSet) : WF s -> StronglySorted _<_ (toAscList s). Proof. apply toList_sorted. Qed.Theorem toDescList_sorted (s : IntSet) : WF s -> StronglySorted _>_ (toDescList s). Proof. move=> WF_s; rewrite toDescList_spec //. rewrite -StronglySorted_rev. by apply toList_sorted. Qed. Theorem partition_filter (s : IntSet) (p : Word -> bool) : WF s -> partition p s = (filter p s, filter (fun k => ~~ p k) s). Proof. by move=> WF_s; rewrite -partition_fst -partition_snd //; case: (partition p s). Qed.Theorem split_splitMember (x : Word) (s : IntSet) : WF s -> let: (l,m,r) := splitMember x s in split x s = (l, r) /\ member x s = m. Proof. move=> [fs Sem_s]. apply splitMember_Sem with fs => //= l fl r fr m' Sem_l Sem_r <-{m'} def_fl def_fr. split. - apply split_Sem with fs => //= l' fl' r' fr' Sem_l' Sem_r' def_fl' def_fr'. f_equal; eauto using Sem_unique. - by apply member_Sem. Qed. Theorem split_splitMember' (x : Word) (s : IntSet) : WF s -> split x s = ((splitMember x s).1.1, (splitMember x s).2) /\ member x s = (splitMember x s).1.2. 
2=1*1+1 /\ 0 <= 1 <= 2*1. Proof. simpl; auto with zarith. Qed.Theorem th_sqrt3 : 3=1*1+2 /\ 0 <= 2 <= 2*1. Proof. simpl; auto with zarith. Qed.Theorem th_sqrt_4_0_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r -> Zpos(xO (xO p)) = (2*s+1)*(2*s+1)+(4*r - (4*s+1)) /\ 0<= 4*r-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_0_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r -> Zpos(xO (xO p)) = (2*s)*(2*s)+4*r /\ 0<= 4*r <= 2*(2*s). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_2_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r+2 -> Zpos(xO (xI p)) = (2*s+1)*(2*s+1)+(4*r+2-(4*s+1)) /\ 0<= (4*r+2)-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xI p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_2_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r+2 -> Zpos(xO (xI p)) = (2*s)*(2*s)+(4*r+2) /\ 0<= 4*r+2 <= 2*(2*s). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xI p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_1_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r+1 -> Zpos(xI (xO p)) = (2*s+1)*(2*s+1)+(4*r+1-(4*s+1)) /\ 0<= (4*r+1)-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xI; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_1_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r+1 -> Zpos(xI (xO p)) = (2*s)*(2*s)+(4*r+1) /\ 0<= 4*r+1 <= 2*(2*s). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xI; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_3_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r+3 -> Zpos(xI (xI p)) = (2*s+1)*(2*s+1)+(4*r+3-(4*s+1)) /\ 0<= (4*r+3)-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xI; rewrite (Zpos_xI p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_3_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r+3 -> Zpos(xI (xI p)) = (2*s)*(2*s)+(4*r+3) /\ 0<= 4*r+3 <= 2*(2*s). 
divA eqA_dec n ltM ltM_dec Q x y -> reducestar Q y z -> reducestar Q x z. intros Q x y z H' H'0 H'1; inversion H'1. apply reducestar0; auto. apply reduceplus_trans with (1 := cs) (y := y); auto. Qed. Theorem reducestar_reduceplus : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducestar Q p q -> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q. intros Q p q H'; inversion H'; auto. Qed. Theorem reducestar_irreducible : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducestar Q p q -> irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q. intros Q p q H'; inversion H'; auto. Qed. Hint Resolve reducestar_reduceplus. Theorem reducestar_inv : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducestar Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p q /\ irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p \/ (exists r : list (Term A n), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p r /\ reducestar Q r q). intros Q p q H'; elim H'. intros p0 q0 H'0; inversion H'0. intros H'1 H'2; left; split; auto. apply irreducible_eqp_com with (1 := cs) (p := q0); auto. apply eqp_imp_canonical with (p := p0) (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. intros H'1 H'2; right; exists y; split; auto. apply reducestar0; auto. Qed. Lemma pO_reducestar : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), reducestar Q (pO A n) p -> p = pO A n. intros Q p H'. cut (reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pO A n) p); [ intros Red1 | apply reducestar_reduceplus; auto ]. apply pO_reduceplus with (2 := Red1); auto. Qed. Theorem reducestar_pO_is_pO : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), canonical A0 eqA ltM p -> reducestar Q (pO A n) (pO A n). intros Q p H' H'0; auto. apply reducestar0; auto. apply Rstar_0; auto. apply pO_irreducible. Qed. Theorem reducestar_in_pO : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)), inPolySet A A0 eqA n ltM p Q -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> reducestar Q (mults (A:=A) multA (n:=n) a p) (pO A n). 
q) n)) * S d. intros n; elim n. intros p q Hle; inversion Hle. clear n; intros n. intros Hrec p q Hle; case (le_gt_dec (S p) (S q)). simpl in |- *. intros Hle'; rewrite (le_minus_O p q). CaseEq (q - p). intros Heq_minus; exists p. simpl in |- *; split; auto with arith. rewrite <- plus_n_O. apply le_antisym; auto with arith. apply minus_O_le. auto. intros q' Heq_minus; elim (Hrec p q'). intros d; simpl in |- *; case (Qpositive_i (Qpositive_c (S p) (S q') n)); repeat rewrite <- (mult_comm (S d)); intros p'' q'' (Heq1, Heq2). exists d; split. exact Heq1. rewrite (le_plus_minus (S p) (S q)). simpl in |- *. rewrite Heq_minus; rewrite Heq2. simpl in |- *. replace (S (p + q'' * S d)) with (S p + q'' * S d). rewrite Heq1. simpl in |- *. ring. simpl in |- *; auto. auto with arith. apply le_S_n. rewrite plus_n_Sm. apply le_trans with (S p + S q). apply plus_le_compat_l. apply le_n_S. rewrite <- Heq_minus; apply minus_le. exact Hle. auto with arith. intros Hgt; simpl in |- *; CaseEq (p - q). intros H; elim (gt_not_le _ _ Hgt). apply le_n_S. apply minus_O_le. exact H. intros p'. intros Heq_minus; simpl in |- *; elim (Hrec p' q). intros d; case (Qpositive_i (Qpositive_c (S p') (S q) n)). simpl in |- *; intros p'' q'' (Heq1, Heq2). exists d; split; auto. rewrite (le_plus_minus (S q) (S p)); simpl in |- *. rewrite Heq_minus. replace (S (q + S p')) with (S q + S p'). rewrite Heq2; rewrite Heq1; ring. simpl in |- *; auto. auto with arith. rewrite <- Heq_minus. replace (p - q) with (S p - S q). rewrite <- (plus_comm (S q)). rewrite <- (le_plus_minus (S q) (S p)). apply le_trans with (S p + q). auto with arith. apply le_S_n; rewrite plus_n_Sm. exact Hle. auto with arith. auto. Qed. Theorem construct_correct2' : forall n p q : nat, 1 <= p -> 1 <= q -> p + q <= n -> exists d : nat, p = fst (Qpositive_i (Qpositive_c p q n)) * S d /\ q = snd (Qpositive_i (Qpositive_c p q n)) * S d. intros n p; case p. intros q H; inversion H. intros p' q; case q. intros Hle H; inversion H. intros q' Hle Hle2; exact (construct_correct2 n p' q'). Qed. Theorem construct_correct3 : forall n n' p q p' q' d : nat, S p = S d * p' -> S q = S d * q' -> S p + S q <= S n -> p' + q' <= S n' -> Qpositive_c (S p) (S q) (S n) = Qpositive_c p' q' (S n'). 
Export ZArithRing Extraction. Require Import Lia. Open Scope Z_scope.Definition sqrt_type2 := fun v s r => (Zpos v) = s*s+r /\ 0 <= r <= 2*s.Definition sqrt_type1 := fun p s => {r:Z | sqrt_type2 p s r}.Theorem th_sqrt1 : 1=1*1+0 /\ 0<= 0 <= 2*1. Proof. simpl;auto with zarith. Qed.Theorem th_sqrt2 : 2=1*1+1 /\ 0 <= 1 <= 2*1. Proof. simpl; auto with zarith. Qed.Theorem th_sqrt3 : 3=1*1+2 /\ 0 <= 2 <= 2*1. Proof. simpl; auto with zarith. Qed.Theorem th_sqrt_4_0_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r -> Zpos(xO (xO p)) = (2*s+1)*(2*s+1)+(4*r - (4*s+1)) /\ 0<= 4*r-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_0_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r -> Zpos(xO (xO p)) = (2*s)*(2*s)+4*r /\ 0<= 4*r <= 2*(2*s). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_2_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r+2 -> Zpos(xO (xI p)) = (2*s+1)*(2*s+1)+(4*r+2-(4*s+1)) /\ 0<= (4*r+2)-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xI p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_2_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r+2 -> Zpos(xO (xI p)) = (2*s)*(2*s)+(4*r+2) /\ 0<= 4*r+2 <= 2*(2*s). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xI p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_1_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r+1 -> Zpos(xI (xO p)) = (2*s+1)*(2*s+1)+(4*r+1-(4*s+1)) /\ 0<= (4*r+1)-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xI; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_1_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r+1 -> Zpos(xI (xO p)) = (2*s)*(2*s)+(4*r+1) /\ 0<= 4*r+1 <= 2*(2*s). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xI; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_3_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r+3 -> Zpos(xI (xI p)) = (2*s+1)*(2*s+1)+(4*r+3-(4*s+1)) /\ 0<= (4*r+3)-(4*s+1) <= 2*(2*s+1). 
Require Import Kripke FOL.BPCP_FOL.Section kvalidity. Variable R : BSRS. Context {b : logic}. Set Printing Implicit. Theorem BPCP_kprv : BPCP R <-> nil ⊢I (F R). 
Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. 
Require Import Iron.Language.SystemF2.KiJudge.Theorem subst_type_type_ix : forall ix ke t1 k1 t2 k2 , get ix ke = Some k2 -> KIND ke t1 k1 -> KIND (delete ix ke) t2 k2 -> KIND (delete ix ke) (substTT ix t2 t1) k1. Proof. intros. gen ix ke t2 k1 k2. induction t1; intros; simpl; inverts_kind; eauto. Case "TVar". fbreak_nat_compare. SCase "n = ix". rewrite H in H4. inverts H4. auto. SCase "n < ix". apply KIVar. rewrite <- H4. apply get_delete_above; auto. SCase "n > ix". apply KIVar. rewrite <- H4. destruct n. burn. simpl. nnat. apply get_delete_below. omega. Case "TForall". apply KIForall. rewrite delete_rewind. eapply IHt1; eauto. apply kind_kienv_weaken; auto. Qed. Theorem subst_type_type_ix_forall2 : forall ix ke t2 k2 ts ks , get ix ke = Some k2 -> Forall2 (KIND ke) ts ks -> KIND (delete ix ke) t2 k2 -> Forall2 (KIND (delete ix ke)) (map (substTT ix t2) ts) ks. 
] => specialize (Ncompare_spec X Y); destruct (X ?= Y); inversion 1 end; simpl in *; (rewrite (Comp_eq (@Ncompare_spec _ _)); rewr') || (rewrite (Comp_lt (@Ncompare_spec _ _)); rewr') || (rewrite (Comp_gt (@Ncompare_spec _ _)); rewr').Theorem string_lt_trans : forall s1 s2 s3, string_lt s1 s2 = true -> string_lt s2 s3 = true -> string_lt s1 s3 = true. induction s1; simpl; intuition; destruct s2; destruct s3; simpl in *; try congruence; rewr. Qed.Section hide_hints. Hint Resolve string_lt_trans. Theorem string_lt_irrel : forall s, string_lt s s = false. induction s; simpl; intuition rewr. Qed. Hint Rewrite string_lt_irrel : LabelMap. Lemma string_tail_neq : forall a1 a2 s1 s2, N_of_ascii a1 = N_of_ascii a2 -> (String a1 s1 = String a2 s2 -> False) -> (s1 = s2 -> False). intros. apply (f_equal ascii_of_N) in H. repeat rewrite ascii_N_embedding in H. congruence. Qed. Hint Immediate string_tail_neq. Theorem string_lt_sym : forall s1 s2, s1 <> s2 -> string_lt s1 s2 = false -> string_lt s2 s1 = true. induction s1; destruct s2; simpl; intuition; rewr. Qed. Hint Resolve string_lt_sym. Definition label'_lt (l1 l2 : label') : bool := match l1, l2 with | Global _, Local _ => true | Local _, Global _ => false | Global s1, Global s2 => string_lt s1 s2 | Local n1, Local n2 => match n1 ?= n2 with | Datatypes.Lt => true | _ => false end end. Theorem label'_lt_trans : forall l1 l2 l3, label'_lt l1 l2 = true -> label'_lt l2 l3 = true -> label'_lt l1 l3 = true. induction l1; simpl; intuition; destruct l2; destruct l3; simpl in *; try congruence; eauto; rewr. Qed. Hint Immediate label'_lt_trans. Theorem label'_lt_irrel : forall l, label'_lt l l = false. induction l; simpl; intuition; autorewrite with LabelMap; auto; rewr. Qed. Hint Rewrite label'_lt_irrel : LabelMap. Theorem label'_lt_sym : forall l1 l2, l1 <> l2 -> label'_lt l1 l2 = false -> label'_lt l2 l1 = true. induction l1; destruct l2; simpl; intuition. eapply string_lt_sym; eauto; congruence. rewr. Qed. Hint Resolve label'_lt_sym. Definition label'_eq : forall x y : label', {x = y} + {x <> y}. decide equality; apply string_dec || apply N_eq_dec. Defined. End hide_hints.Module LabelKey. Definition t := label. Definition eq := @eq t. Definition lt (l1 l2 : label) := string_lt (fst l1) (fst l2) = true \/ (fst l1 = fst l2 /\ label'_lt (snd l1) (snd l2) = true). Theorem eq_refl : forall x : t, eq x x. 
Require Export Iron.Language.SimpleData.SubstExpExp. Require Export Iron.Language.SimpleData.Step. Require Export Iron.Language.SimpleData.Exp. Require Import Iron.Language.SimpleData.Preservation. Require Import Iron.Language.SimpleData.TyJudge.Inductive EVAL : exp -> exp -> Prop := | EvDone : forall v2 , wnfX v2 -> EVAL v2 v2 | EvLamApp : forall x1 t11 x12 x2 v2 v3 , EVAL x1 (XLam t11 x12) -> EVAL x2 v2 -> EVAL (substX 0 v2 x12) v3 -> EVAL (XApp x1 x2) v3 | EvCon : forall dc xs vs , EVALS xs vs -> EVAL (XCon dc xs) (XCon dc vs) | EvCase : forall x1 x2 v3 dc vs alts tsArgs , EVAL x1 (XCon dc vs) -> Forall wnfX vs -> getAlt dc alts = Some (AAlt dc tsArgs x2) -> EVAL (substXs 0 vs x2) v3 -> EVAL (XCase x1 alts) v3 with EVALS : list exp -> list exp -> Prop := | EvsNil : EVALS nil nil | EvsCons : forall x v xs vs , EVAL x v -> EVALS xs vs -> EVALS (x :: xs) (v :: vs).Hint Constructors EVAL. Hint Constructors EVALS.Ltac inverts_eval := repeat (match goal with | [ H: EVAL (XApp _ _) _ |- _ ] => inverts H | [ H: EVAL (XCon _ _) _ |- _ ] => inverts H | [ H: EVAL (XCase _ _) _ |- _ ] => inverts H end). Theorem EVAL_mutind : forall (PE : exp -> exp -> Prop) (PS : list exp -> list exp -> Prop) , (forall v2 , wnfX v2 -> PE v2 v2) -> (forall x1 t11 x12 x2 v2 v3 , EVAL x1 (XLam t11 x12) -> PE x1 (XLam t11 x12) -> EVAL x2 v2 -> PE x2 v2 -> EVAL (substX 0 v2 x12) v3 -> PE (substX 0 v2 x12) v3 -> PE (XApp x1 x2) v3) -> (forall dc xs vs , EVALS xs vs -> PS xs vs -> PE (XCon dc xs) (XCon dc vs)) -> (forall x1 x2 v3 dc vs alts tsArgs , EVAL x1 (XCon dc vs) -> PE x1 (XCon dc vs) -> Forall wnfX vs -> getAlt dc alts = Some (AAlt dc tsArgs x2) -> EVAL (substXs 0 vs x2) v3 -> PE (substXs 0 vs x2) v3 -> PE (XCase x1 alts) v3) -> ( PS nil nil) -> (forall x v xs vs , EVAL x v -> PE x v -> EVALS xs vs -> PS xs vs -> PS (x :: xs) (v :: vs)) -> forall x1 x2 , EVAL x1 x2 -> PE x1 x2.Proof. 
_ c1 lsA1; lsB2 <-$ compMap _ c2 lsA2; A2 s_A (lsB1 ++ lsB2). Theorem G_2_hybrid_eq : Pr[ListHybrid_G c2] == Pr[G_hybrid 0]. unfold ListHybrid_G, G_hybrid. comp_skip. comp_simp. eapply comp_spec_eq_impl_eq. simpl. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem skipn_ge_nil : forall (A : Type)(ls : list A)(n : nat), n >= length ls -> skipn n ls = nil. induction ls; destruct n; intuition; simpl in *. omega. eapply IHls. omega. Qed. Theorem G_1_hybrid_eq : Pr[ListHybrid_G c1] == Pr[G_hybrid maxA]. unfold ListHybrid_G, G_hybrid. comp_skip. comp_simp. rewrite firstn_ge_all. comp_skip. rewrite skipn_ge_nil. eapply comp_spec_eq_impl_eq. simpl. comp_simp. rewrite app_nil_r. eapply comp_spec_eq_refl. eauto. eauto. Qed. Definition B1 i := [lsA, s_A] <-$2 A1; lsA1 <- firstn i lsA; a <- nth i lsA defA; lsA2 <- skipn (S i) lsA; incla <- if (lt_dec i (length lsA)) then true else false; ret (a, (incla, lsA1, lsA2, s_A)). Definition B2 (e : bool * _ * _ * _) b := let '(incla, lsA1, lsA2, s_A) := e in lsB1 <-$ compMap _ c1 lsA1; lsB2 <-$ compMap _ c2 lsA2; lsB <- if incla then (lsB1 ++ (b :: lsB2)) else lsB1; A2 s_A lsB. Local Open Scope list_scope. Theorem compMap_unroll : forall (A B : Set)(eqdb : EqDec B)(c : A -> Comp B)(ls : list A)(def : A), ls <> nil -> comp_spec eq (compMap _ c ls) (x <-$ c (hd def ls); y <-$ compMap _ c (tl ls); ret (x :: y)). induction ls; intuition; simpl in *. comp_skip. Qed. Theorem skipn_lt_nil_false : forall (A : Type)(ls : list A)(n : nat), n < length ls -> skipn n ls = nil -> False. induction ls; intuition; simpl in *. omega. destruct n; simpl in *; intuition. discriminate. eapply IHls; eauto. omega. Qed. Theorem hd_skip_eq_nth : forall (A : Type)(def : A)(ls : list A)(n : nat), hd def (skipn n ls) = nth n ls def. induction ls; destruct n; intuition; simpl in *. eauto. Qed. Theorem tl_skipn_eq : forall (A : Type)(ls : list A)(n : nat), tl (skipn n ls) = skipn (S n) ls. induction ls; intuition; simpl in *. rewrite skipn_nil. trivial. destruct n; simpl in *. trivial. eauto. Qed. Theorem skipn_gt_nil : forall (A : Type)(ls : list A)(n : nat), n >= length ls -> skipn n ls = nil. induction ls; destruct n; intuition; simpl in *. omega. eapply IHls; eauto. omega. Qed. Theorem G_hybrid_DistSingle_eq : forall i, Pr[G_hybrid i] == Pr[DistSingle_G (B1 i) B2 c2]. 
xp F (ActiveTxn ds d) ms sm hm * [[ exists gms, GLog.dset_match xp (GLog.effective ds (length gms)) gms ]]. Proof. unfold rep, rep_inner, GLog.rep; intros; split; cancel. eexists; eauto. Qed. Lemma notxn_dset_match_pimpl : forall xp F ds hm sm ms, rep xp F (NoTxn ds) ms sm hm <=p=> rep xp F (NoTxn ds) ms sm hm * [[ exists gms, GLog.dset_match xp (GLog.effective ds (length gms)) gms ]]. Proof. unfold rep, rep_inner, GLog.rep; intros; split; cancel. eexists; eauto. Qed. Lemma rep_inner_hashmap_subset : forall xp ms hm sm hm', (exists l, hashmap_subset l hm hm') -> forall st, rep_inner xp st ms sm hm =p=> rep_inner xp st ms sm hm'. Proof. intros. destruct st; unfold rep_inner, GLog.would_recover_any. all: try erewrite GLog.rep_hashmap_subset; eauto. cancel. erewrite GLog.rep_hashmap_subset; eauto. auto. Qed. Lemma rep_hashmap_subset : forall xp F ms hm sm hm', (exists l, hashmap_subset l hm hm') -> forall st, rep xp F st ms sm hm =p=> rep xp F st ms sm hm'. Proof. unfold rep; intros; cancel. erewrite rep_inner_hashmap_subset; eauto. Qed. Lemma intact_hashmap_subset : forall xp F ds hm sm hm', (exists l, hashmap_subset l hm hm') -> intact xp F ds sm hm =p=> intact xp F ds sm hm'. Proof. unfold intact; intros; cancel; erewrite rep_hashmap_subset; eauto. all: cancel. Qed. Lemma rep_inner_notxn_pimpl : forall xp d ms sm hm, rep_inner xp (NoTxn (d, nil)) ms sm hm =p=> exists ms', rep_inner xp (RecoveringTxn d) ms' sm hm. Proof. unfold rep_inner; intros. rewrite GLog.cached_recovering. norm'l. cancel. eassign (mk_mstate vmap0 ms'); auto. apply map_empty_vmap0. Qed. Lemma rep_inner_rollbacktxn_pimpl : forall xp d ms sm hm, rep_inner xp (RollbackTxn d) ms sm hm =p=> rep_inner xp (RecoveringTxn d) ms sm hm. Proof. unfold rep_inner; intros. rewrite GLog.rollback_recovering. cancel. Qed. Lemma readOnlyMapEmpty : forall ms, (exists ms0, readOnly ms0 ms) -> Map.Empty (MSTxn (fst ms)). Proof. unfold readOnly; intros; deex; intuition. Qed. Hint Resolve readOnlyMapEmpty. Theorem readOnlyLL : forall ms ms', GLog.readOnly (MSLL ms) (MSLL ms') -> Map.Empty (MSTxn (fst ms)) -> Map.Empty (MSTxn (fst ms')) -> readOnly ms ms'. Proof. firstorder. Qed. Hint Resolve readOnlyLL. Theorem readOnlyLL' : forall ms mstxn' msll', GLog.readOnly (MSLL ms) msll' -> Map.Empty (MSTxn (fst ms)) -> MSTxn (fst ms) = mstxn' -> readOnly ms (mk_memstate mstxn' msll'). Proof. intros; substl; eauto. Qed. Hint Resolve readOnlyLL'. Theorem readOnly_refl : forall ms, Map.Empty (MSTxn (fst ms)) -> readOnly ms ms. Proof. intuition. Qed. Hint Resolve readOnly_refl. Theorem readOnly_trans : forall ms ms' ms'', readOnly ms ms' -> readOnly ms' ms'' -> readOnly ms ms''. 
Rle_trans with (1 := H'6); auto. apply Rledouble; auto. apply Rle_trans with (2 := H'6); apply Rlt_le; auto. rewrite (Fminus_correct radix); auto with arith. case (Rle_or_lt r (2%nat * p)); intros Rl2. exists (Fminus radix r p); split; auto. rewrite <- Fopp_Fminus. apply oppBounded. apply Sterbenz; auto. apply (FcanonicBound radix b); auto with arith. apply (FcanonicBound radix b); auto with arith. apply Rmult_le_reg_l with (r := INR 2); auto with real. rewrite <- Rmult_assoc; rewrite Rinv_r; auto with real arith; rewrite Rmult_1_l; auto. apply Rle_trans with (1 := H'6); auto. apply Rledouble; auto. apply Rle_trans with (2 := H'6); apply Rlt_le; auto. rewrite (Fminus_correct radix); auto with arith. apply ExactMinusIntervalAux with (P := P) (q := q); auto. exists r; split; auto. apply (FcanonicBound radix b); auto with arith. rewrite <- H'0; ring. Qed. Theorem ExactMinusInterval : forall P, RoundedModeP b radix P -> forall p q : float, (0 <= p)%R -> (p <= q)%R -> Fbounded b p -> Fbounded b q -> (exists r : float, Fbounded b r /\ r = (q - p)%R :>R) -> forall r : float, Fbounded b r -> (p <= r)%R -> (r <= q)%R -> exists r' : float, Fbounded b r' /\ r' = (r - p)%R :>R. intros P H' p q H'0 H'1 H'2 H'3 H'4 r H'5 H'6 H'7. replace (FtoRradix r) with (FtoRradix (Fnormalize radix b precision r)); [ idtac | apply (FnormalizeCorrect radix) ]; auto. replace (FtoRradix p) with (FtoRradix (Fnormalize radix b precision p)); [ idtac | apply (FnormalizeCorrect radix) ]; auto. apply ExactMinusIntervalAux1 with (P := P) (q := Fnormalize radix b precision q); auto; try repeat rewrite (FnormalizeCorrect radix); auto; apply FnormalizeCanonic; auto with arith. Qed. Theorem MSBroundLSB : forall P : R -> float -> Prop, RoundedModeP b radix P -> forall f1 f2 : float, P f1 f2 -> ~ is_Fzero (Fminus radix f1 f2) -> (MSB radix (Fminus radix f1 f2) < LSB radix f2)%Z. intros P H' f1 f2 H'0 HZ. apply (oneExp_Zlt radix); auto. apply Rlt_le_trans with (Fulp b radix precision f2). apply Rle_lt_trans with (FtoRradix (Fabs (Fminus radix f1 f2))). unfold FtoRradix in |- *; apply MSB_le_abs; auto. unfold FtoRradix in |- *; rewrite Fabs_correct; auto with arith; rewrite Fminus_correct; auto with arith. apply RoundedModeUlp with (4 := H'); auto. apply FUlp_Le_LSigB; auto. apply RoundedModeBounded with (1 := H') (2 := H'0); auto. Qed. Theorem LSBMinus : forall p q : float, ~ is_Fzero (Fminus radix p q) -> (Zmin (LSB radix p) (LSB radix q) <= LSB radix (Fminus radix p q))%Z. 
NIndirect ^ S i) (seq 0 indlvl)) 0 in let len := NIndirect ^ S indlvl in If (lt_dec nl (start + len)) { indclear indlvl lxp bxp bn (nl - start) (len - (nl - start)) ms } else { Ret ^(ms, bn) }. Definition indshrink lxp bxp ir nl ms := let^ (ms, indptr) <- indshrink_helper 0 lxp bxp (IRIndPtr ir) nl ms; let^ (ms, dindptr) <- indshrink_helper 1 lxp bxp (IRDindPtr ir) nl ms; let^ (ms, tindptr) <- indshrink_helper 2 lxp bxp (IRTindPtr ir) nl ms; Ret ^(ms, indptr, dindptr, tindptr). Definition shrink lxp bxp (ir : irec) nr ms := let ol := (IRLen ir) in let nl := (ol - nr) in If (le_dec ol NDirect) { Ret ^(ms, upd_irec ir nl (IRIndPtr ir) (IRDindPtr ir) (IRTindPtr ir) (upd_range_fast (IRBlocks ir) nl (NDirect - nl) $0)) } else { let ol' := ol - NDirect in let nl' := nl - NDirect in let^ (ms, indptr, dindptr, tindptr) <- indshrink lxp bxp ir nl' ms; Ret ^(ms, upd_irec ir nl indptr dindptr tindptr (upd_range_fast (IRBlocks ir) nl (NDirect - nl) $0)) }. Definition indgrow lxp bxp ir off bn ms := If (lt_dec off NIndirect) { let^ (ms, v) <- indput 0 lxp bxp (IRIndPtr ir) off bn ms; Ret ^(ms, v, v, (IRDindPtr ir), (IRTindPtr ir)) } else { let off := off - NIndirect in If (lt_dec off (NIndirect ^ 2)) { let^ (ms, v) <- indput 1 lxp bxp (IRDindPtr ir) off bn ms; Ret ^(ms, v, (IRIndPtr ir), v, (IRTindPtr ir)) } else { let off := off - NIndirect ^ 2 in let^ (ms, v) <- indput 2 lxp bxp (IRTindPtr ir) off bn ms; Ret ^(ms, v, (IRIndPtr ir), (IRDindPtr ir), v) } }. Definition grow lxp bxp (ir : irec) bn ms := let len := (IRLen ir) in If (lt_dec len NDirect) { Ret ^(ms, OK (upd_irec ir (S len) (IRIndPtr ir) (IRDindPtr ir) (IRTindPtr ir) (updN (IRBlocks ir) len bn))) } else { let off := (len - NDirect) in If (waddr_eq_dec bn $0) { Ret ^(ms, OK (upd_len ir (S len))) } else { let^ (ms, v, indptr, dindptr, tindptr) <- indgrow lxp bxp ir off bn ms; If (addr_eq_dec v 0) { Ret ^(ms, Err ENOSPCBLOCK) } else { Ret ^(ms, OK (upd_irec ir (S len) indptr dindptr tindptr (IRBlocks ir))) } } }. Theorem get_ok : forall lxp bxp ir off ms, {< F Fm IFs m0 sm m l, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: Fm * rep bxp IFs ir l ]]] * [[ off < length l ]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[ r = selN l off $0 ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} get lxp ir off ms. 
list_bool_succ l m2 -> m1 = m2. Proof. intros H; revert l m1 H m2. intros ? ? [ k l | k ]; inversion 1. apply list_One_Zero_inj in H1; destruct H1; subst k0 l1; auto. symmetry in H1; apply list_One_Zero_not in H1; tauto. apply list_One_Zero_not in H1; tauto. apply list_One_inj in H1; subst; auto. Qed. Fact list_bool_succ_nil l : list_bool_succ nil l -> l = Zero::nil. Proof. intros H; symmetry; revert H; apply list_bool_succ_fun. constructor 2 with (k := 0). Qed. Fact list_bool_succ_neq : forall l m, list_bool_succ l m -> l <> m. Proof. intros ? ? [ [|k] l | [|k] ]; discriminate. Qed. Fact list_bool_succ_neq_nil l : ~ list_bool_succ l nil. Proof. inversion 1. destruct k; discriminate. Qed.End list_bool_succ_props.Section list_bool_next. Let list_bool_next_def l : { m | list_bool_succ l m }. Proof. destruct (list_bool_choose_sym l) as [ (k & tl & H) | (k & H) ]; subst l. * exists (list_repeat Zero k ++ One :: tl); constructor. * exists (list_repeat Zero (S k)); constructor. Qed. Definition list_bool_next l := proj1_sig (list_bool_next_def l). Definition list_bool_next_spec l : list_bool_succ l (list_bool_next l). Proof. apply (@proj2_sig _ _). Qed. Fact list_bool_next_neq_nil l : list_bool_next l <> nil. Proof. intros H. generalize (list_bool_next_spec l). rewrite H. apply list_bool_succ_neq_nil. Qed. Fact iter_list_bool_next_nil l n : iter list_bool_next l n = nil -> n = 0 /\ l = nil. Proof. destruct n as [ | n ]. simpl; auto. replace (S n) with (n+1) by omega. rewrite iter_plus; simpl. intros H. apply list_bool_next_neq_nil in H. destruct H. Qed.End list_bool_next.Fact list_bool_succ_nat l m : list_bool_succ l m -> 1 + list_bool_nat l = list_bool_nat m. Proof. revert l m; intros ? ? [ k l | k ]; induction k; simpl in *; omega. Qed. Section list_bool_succ_rect. Variable (P : list bool -> Type) (HP0 : P nil) (HPS : forall l m, list_bool_succ l m -> P l -> P m). Let list_bool_succ_rec n : forall l, list_bool_nat l = n -> P l. Proof. induction n as [ | n IHn ]; intros l Hl. * generalize (list_bool_nat_ge_1 l); omega. * destruct (list_bool_choose l) as [ (k & tl & H) | ([ | k] & H) ]; subst l; [ generalize (in_lbs_0 k tl) | apply HP0 | generalize (in_lbs_1 k) ]; intros E; apply HPS with (1 := E), IHn; apply list_bool_succ_nat in E; omega. Qed. Theorem list_bool_succ_rect : forall l, P l. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonDefinitions.Require Import VerdiRaft.LastAppliedCommitIndexMatchingInterface. Require Import VerdiRaft.LogMatchingInterface. Require Import VerdiRaft.StateMachineSafetyInterface. Require Import VerdiRaft.MaxIndexSanityInterface.Section LastAppliedCommitIndexMatching. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {lmi : log_matching_interface}. Context {smsi : state_machine_safety_interface}. Context {misi : max_index_sanity_interface}. Theorem lastApplied_commitIndex_match_invariant : forall net, raft_intermediate_reachable net -> lastApplied_commitIndex_match net. 
by iLeft in "Hfupd". + wpc_pures. wpc_frame_seq. wp_loadField. wp_apply (wp_SliceAppend (V:=u64) with "[$Haddrs]"). iIntros (addr_s') "Haddrs". wp_storeField. iNamed 1. wpc_pures. wpc_frame_seq. wp_apply (wp_Inode__mkHdr with "[$addrs $Haddrs]"). { autorewrite with len; simpl. word. } iIntros (s b') "(Hb&%Hencoded'&?&?)"; iNamed. iNamed 1. wpc_pures. wpc_loadField. iApply (prepare_reserved_block with "Hreserved"); auto; try lia. iSplit; first iFromCache. iIntros "Hda Hreserved". wpc_bind (Write _ _). match goal with | |- envs_entails _ (wpc _ _ _ ?Φ0 _) => set (Φ':=Φ0) end. wpc_apply (wpc_Write_ncfupd with "[$Hb]"). iSplit. { iLeft in "Hfupd". iSplitR "Hda". * iFrame. iExists _; iFrame. iExists _; iFrame. * iApply block_cinv_free_pred. iExists _; iFrame. } iNamed "Hdurable". iRight in "Hfupd". set (σ':=set inode.blocks (λ bs : list Block, bs ++ [b0]) (set inode.addrs (union {[a]}) σ)). iRight in "Hfupd". iSpecialize ("Hfupd" $! σ σ' a with "[% //] [% //]"). iMod (mark_used _ _ _ _ _ (P σ' ∗ (Φc ∧ Φ #true))%I with "Hreserved [HP Hfupd]") as "Hget_used". { solve_ndisj. } { clear. iIntros (s Hreserved) "HPalloc". iMod ("Hfupd" with "[% //] [$HP $HPalloc]") as "(HP&HPalloc&HQ)". iFrame. eauto. } iModIntro. iExists _; iFrame. iNext. iIntros "Hhdr". iMod "Hget_used" as "[ (HP&HQ) Hused]". iAssert (is_inode_durable addr (set inode.blocks (λ bs : list Block, bs ++ [b0]) (set inode.addrs (union {[a]}) σ)) (addrs ++ [a])) with "[Hhdr Hdata Hda]" as "Hdurable". { iExists _; iFrame "∗ %". iSplitR. { iPureIntro. rewrite /inode.wf /=. autorewrite with len; simpl. word. } iSplitR. { iPureIntro. simpl. rewrite list_to_set_app_L. simpl. set_solver. } simpl; auto. } iDestruct (is_inode_durable_wf with "Hdurable") as %Hwf'. iCache (Φc)%I with "HQ". { by iLeft in "HQ". } iModIntro. match goal with | |- envs_entails _ ((?P ∗ _) ∧ _) => iCache (P)%I with "HQ HP Hdurable" end. { iLeft in "HQ". iFrame. iExists _; iFrame. iExists _; iFrame. } iCache (block_cinv Ψ γalloc a) with "Hused". { iApply block_cinv_from_used; iFrame. } iSplit. { iLeft in "HQ". iFrame. iExists _. iFrame. iExists _; iFrame. } iIntros "Hb". subst Φ'; cbv beta. wpc_pures. { iLeft in "HQ". iFrame. iExists _. iFrame. iExists _; iFrame. } iModIntro. iSplitR "Hused"; last (iFromCache). iSplit. { iLeft in "HQ". iFrame. iExists _. iFrame. iExists _; iFrame. } iSplitR "HP Haddrs addrs Hdurable"; last first. { iExists _; iFrame. iModIntro. iExists _, _; iFrame "∗ %". } iModIntro. iIntros "His_locked". iSplit; first iFromCache. wpc_pures. wpc_frame_seq. wp_loadField. wp_apply (crash_lock.release_spec with "His_locked"); auto. iNamed 1. wpc_pures. by iRight in "HQ". Qed. Theorem wpc_Inode__Append_triple {l P addr} {Palloc γalloc domain} (Q: iProp Σ) (Qc: iProp Σ) (alloc_ref: loc) q (b_s: Slice.t) (b0: Block) : inodeN ## allocN → {{{ "Hinode" ∷ is_inode l P addr ∗ "Hbdata" ∷ is_block b_s q b0 ∗ "HQc" ∷ (Q -∗ Qc) ∗ "#Halloc" ∷ is_allocator Palloc Ψ allocN alloc_ref domain γalloc ∗ "#Halloc_fupd" ∷ □ reserve_fupd (⊤ ∖ ↑allocN) Palloc ∗ "#Hfree_fupd" ∷ □ (∀ a, free_fupd (⊤ ∖ ↑allocN) Palloc a) ∗ "Hfupd" ∷ (Qc ∧ (∀ σ σ' addr', ⌜σ' = set inode.blocks (λ bs, bs ++ [b0]) (set inode.addrs ({[addr']} ∪.) σ)⌝ -∗ ⌜inode.wf σ⌝ -∗ ∀ s, ⌜s !! addr' = Some block_reserved⌝ -∗ P σ ∗ ▷ Palloc s ={⊤ ∖ ↑allocN}=∗ P σ' ∗ ▷ Palloc (<[addr' := block_used]> s) ∗ Q)) }}} Inode__Append #l (slice_val b_s) #alloc_ref @ ⊤ {{{ (ok: bool), RET #ok; if ok then Q else emp }}} {{{ Qc }}}. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.Section Monic_Iso_Monic_Factorization. Context {A B : Type} {f : A → B} (fm : @is_Monic Type_Cat _ _ f). Definition Monic_Image_of : Type := {x : B & {a : A | f a = x}}. Definition Monic_From_Image_forward : Monic_Image_of → B := fun x => projT1 x. Program Definition Monic_Iso_Monic_Factor_Monic : @Monic Type_Cat Monic_Image_of B := {| mono_morphism := Monic_From_Image_forward; mono_morphism_monomorphic := fun T g h => _ |}. Next Obligation. Proof. extensionality x. assert (H' := equal_f H x); cbn in H'. destruct (g x) as [gx Hgx]; destruct (h x) as [hx Hhx]. cbn in *. destruct H'. assert (Hgx = Hhx) as ->; trivial. apply sig_proof_irrelevance. destruct Hgx as [y Hy]; destruct Hhx as [z Hz]. cbn in *. refine (equal_f (fm (unit : Type) (fun _ => y) (fun _ => z) _) tt). FunExt; cbn; auto. Qed. Definition Monic_To_Image : A → Monic_Image_of := fun a => existT _ (f a) (exist _ a eq_refl). Definition Monic_From_Image_back : Monic_Image_of → A := fun x => proj1_sig (projT2 x). Theorem Monic_From_Image_back_is_Monic : @is_Monic Type_Cat _ _ Monic_To_Image. 
inode_bitmaps + data_bitmaps + data_bitmaps + 1 + log_descr_blocks + log_descr_blocks * PaddedLog.DescSig.items_per_val) -> fs_xparams_ok (compute_xparams data_bitmaps inode_bitmaps log_descr_blocks magic). Proof. unfold fs_xparams_ok. unfold log_xparams_ok, inode_xparams_ok, balloc_xparams_ok. unfold compute_xparams; simpl. intuition. all: eapply goodSize_trans; try eassumption. all: lia. Qed. Notation MSLL := BFILE.MSLL. Notation MSAllocC := BFILE.MSAllocC. Notation MSIAllocC := BFILE.MSIAllocC. Notation MSICache := BFILE.MSICache. Notation MSAlloc := BFILE.MSAlloc. Notation MSDBlocks := BFILE.MSDBlocks. Import DIRTREE. Definition mkfs cachesize data_bitmaps inode_bitmaps log_descr_blocks := let fsxp := compute_xparams data_bitmaps inode_bitmaps log_descr_blocks SB.magic_number in cs <- BUFCACHE.init_load cachesize; cs <- SB.init fsxp cs; mscs <- LOG.init (FSXPLog fsxp) cs; mscs <- LOG.begin (FSXPLog fsxp) mscs; ms <- BFILE.init (FSXPLog fsxp) (FSXPBlockAlloc1 fsxp, FSXPBlockAlloc2 fsxp) fsxp (FSXPInode fsxp) mscs; let^ (ialloc_ms, r) <- IAlloc.alloc (FSXPLog fsxp) fsxp (BFILE.MSIAlloc ms); let mscs := IAlloc.MSLog ialloc_ms in match r with | None => mscs <- LOG.abort (FSXPLog fsxp) mscs; Ret (Err ENOSPCINODE) | Some inum => If (eq_nat_dec inum (FSXPRootInum fsxp)) { let^ (mscs, ok) <- LOG.commit (FSXPLog fsxp) mscs; If (bool_dec ok true) { mscs <- LOG.flushsync (FSXPLog fsxp) mscs; Ret (OK ((BFILE.mk_memstate (MSAlloc ms) mscs (MSAllocC ms) (IAlloc.MSCache ialloc_ms) (MSICache ms) (MSCache ms) (MSDBlocks ms)), fsxp)) } else { Ret (Err ELOGOVERFLOW) } } else { mscs <- LOG.abort (FSXPLog fsxp) mscs; Ret (Err ELOGOVERFLOW) } end. Lemma S_minus_1_helper : forall n a b, S (n + 1 + a + b) - 1 - n = S (a + b). Proof. intros; omega. Qed. Lemma S_minus_1_helper2 : forall n, S n - 1 = n. Proof. intros; omega. Qed. Ltac equate_log_rep := match goal with | [ r : BFILE.memstate, H : context [ compute_xparams ?a1 ?a2 ?a3 ?a4 ], Hi: context [IAlloc.Alloc.rep _ _ _ _ ?x_] |- LOG.rep ?xp ?F ?d ?ms _ _ =p=> LOG.rep ?xp' ?F' ?d' ?ms' _ _ * _ ] => equate d d'; equate ms' (MSLL ( BFILE.mk_memstate (MSAlloc r) ms (MSAllocC r) (IAlloc.MSCache x_) (MSICache r) (MSCache r) (MSDBlocks r) )); equate xp' (FSXPLog (compute_xparams a1 a2 a3 a4)) | [ r : BFILE.memstate, H : context [ compute_xparams ?a1 ?a2 ?a3 ?a4 ] |- LOG.rep ?xp ?F ?d ?ms _ _ =p=> LOG.rep ?xp' ?F' ?d' ?ms' _ _ * _ ] => equate d d'; equate ms' (MSLL ( BFILE.mk_memstate (MSAlloc r) ms (MSAllocC r) (IAlloc.Alloc.freelist0) (MSICache r) (MSCache r) (MSDBlocks r) )); equate xp' (FSXPLog (compute_xparams a1 a2 a3 a4)) end. Theorem mkfs_ok : forall cachesize data_bitmaps inode_bitmaps log_descr_blocks, {!!< disk, PRE:vm,hm arrayS 0 disk * [[ cachesize <> 0 /\ data_bitmaps <> 0 /\ inode_bitmaps <> 0 ]] * [[ data_bitmaps <= valulen * valulen /\ inode_bitmaps <= valulen * valulen ]] * [[ length disk = 1 + data_bitmaps * valulen + inode_bitmaps * valulen / INODE.IRecSig.items_per_val + inode_bitmaps + data_bitmaps + data_bitmaps + 1 + log_descr_blocks + log_descr_blocks * PaddedLog.DescSig.items_per_val ]] * [[ goodSize addrlen (length disk) ]] POST:vm',hm' RET:r exists ms fsxp d sm, LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn (d, nil)) (MSLL ms) sm hm' * [[ vm' = vm ]] * ( [[ isError r ]] \/ exists ilist frees, [[ r = OK (ms, fsxp) ]] * [[[ d ::: rep fsxp emp (TreeDir (FSXPRootInum fsxp) nil) ilist frees ms sm ]]] ) CRASH:hm' any >!!} mkfs cachesize data_bitmaps inode_bitmaps log_descr_blocks. 
Nza l l) (pO A n)). intros H'0; inversion H'0; auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec l (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=a) Nza) l)); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec l (mults (A:=A) multA (n:=n) (T1 A1 n) l)); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec l l); auto. apply minuspf_refl with (1 := cs); auto. apply (canonical_nzeroP A A0 eqA n ltM) with (p := l); auto. apply inPolySet_imp_canonical with (L := Q); auto. Qed. Theorem ltP_reduce : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce Q p q -> canonical A0 eqA ltM p -> ltP (A:=A) (n:=n) ltM q p. intros Q p q H'; elim H'; auto. 2: intros a b p0 q0 H'0 H'1 H'2 H'3; apply ltP_tl; auto. 2: apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA n); auto. 2: apply H'1; try apply canonical_imp_canonical with (a := a); auto. intros a b nZb p0; case p0; auto. intros q0 r H'0 H'1 H'2 H'3. change (ltP (A:=A) (n:=n) ltM r (pX a (pO A n))) in |- *. apply (canonical_pX_ltP A A0 eqA); auto. apply eqp_imp_canonical with (1 := cs) (p := pX a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb (pO A n) q0)); auto. apply canonical_spminusf_full_t with (1 := cs); auto. apply inPolySet_imp_canonical with (L := Q); auto. intros t l q0 r H'0 H'1 H'2 H'3; apply ltP_trans with (y := pX a (pO A n)); auto. apply (canonical_pX_ltP A A0 eqA); auto. apply eqp_imp_canonical with (1 := cs) (p := pX a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb (pX t l) q0)); auto. apply canonical_spminusf_full_t with (1 := cs); auto. apply inPolySet_imp_canonical with (L := Q); auto. change (ltP (A:=A) (n:=n) ltM (pX a (pO A n)) (pX a (pX t l))) in |- *; auto. Qed. Theorem canonical_reduce : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce Q p q -> canonical A0 eqA ltM p -> canonical A0 eqA ltM q. 
e)); constructor; intros x. - right; intros Hc; inv Hc. - destruct (var_dec v x); subst; auto. destruct H as [Dec]. destruct (Dec x). now left; eauto. now right; intro Hbv; inv Hbv; auto. - destruct (var_dec v x); subst; auto. destruct H as [Dec]. destruct (Dec x). now left; eauto. now right; intro Hbv; inv Hbv; auto. - destruct (var_dec v x); subst; auto. destruct H as [Dec]. destruct (Dec x). now left; eauto. now right; intro Hbv; inv Hbv; auto. - destruct (var_dec v x); subst; auto. destruct H as [Dec]. destruct (Dec x). now left; eauto. now right; intro Hbv; inv Hbv; auto. - destruct (bound_var_dec (Ecase v l)) as [Decl]. destruct (Decl x) as [Hb | Hnb]. left. now inv Hb; eauto. destruct (bound_var_dec (Ecase v l0)) as [Decl']. destruct (Decl' x) as [Hb' | Hnb']. left. now inv Hb'; eauto. destruct H as [Dec]. destruct (Dec x). left; eauto. right. intros Hc. inv Hc; auto. now eapply Hnb; eauto. now eapply Hnb'; eauto. - destruct (bound_var_fundefs_dec f) as [Decf]. destruct (Decf x) as [Hb | Hnb]; eauto. destruct H as [Dec]. destruct (Dec x). left; eauto. right. intros Hc. inv Hc; auto. - destruct (bound_var_dec e) as [Dece]. destruct (Dece x) as [Hb | Hnb]; eauto. destruct H as [Dec]. destruct (Dec x). left; eauto. right. intros Hc. inv Hc; auto. - destruct (bound_var_fundefs_dec f) as [Decf]. destruct (Decf x) as [Hb | Hnb]; eauto. destruct H as [Dec]. destruct (Dec x). left; eauto. destruct (var_dec v x); subst; auto. destruct (in_dec var_dec x l); auto. right. intros Hc. inv Hc; auto. - destruct (bound_var_dec e) as [Dece]. destruct (Dece x) as [Hb | Hnb]; eauto. destruct H as [Dec]. destruct (Dec x). left; eauto. destruct (var_dec v x); subst; auto. destruct (in_dec var_dec x l); auto. right. intros Hc. inv Hc; auto. Qed. Fixpoint names_in_fundefs_ctx B:= match B with | Fcons1_c f' _ _ _ B0 => Union var [set f'] (name_in_fundefs B0) | Fcons2_c f' _ _ _ B0 => Union var [set f'] (names_in_fundefs_ctx B0) end. Theorem name_in_fundefs_ctx_ctx: forall e cf, Same_set _ (names_in_fundefs_ctx cf) (name_in_fundefs (cf <[ e ]>)). Proof. induction cf. simpl. eauto with Ensembles_DB. simpl. rewrite IHcf. eauto with Ensembles_DB. Qed. Theorem name_in_fundefs_ctx_bound_var_fundefs : forall B, names_in_fundefs_ctx B \subset bound_var_fundefs_ctx B. Proof. intros. induction B; normalize_bound_var_ctx'; simpl; eauto with Ensembles_DB. assert (Hf4 := name_in_fundefs_bound_var_fundefs f). eauto with Ensembles_DB. Qed. Theorem name_in_fundefs_ctx_comp: forall c, forall f5, (names_in_fundefs_ctx (comp_f_ctx_f f5 c) <--> (names_in_fundefs_ctx f5)). 
with (0 * / Zpos (vNum b))%R; [ apply Rmult_le_compat_r | ring ]; auto with real zarith. 2: replace 0%R with (0 * / 2%nat)%R; [ apply Rmult_le_compat_r | ring ]; auto with real zarith. 2: apply (ClosestCompatible b radix (p + q)%R (p + q)%R r); auto. 2: apply sym_eq; apply FnormalizeCorrect; auto. 2: apply FnormalizeBounded; auto with arith. 2: apply RoundedModeBounded with (radix := radix) (P := Closest b radix) (r := (p + q)%R); auto. 2: apply ClosestRoundedModeP with (precision := precision); auto. 2: replace (Fexp (Fnormalize radix b precision r)) with (- dExp b)%Z. 2: unfold Zmin in |- *; case (Fexp p ?= Fexp q)%Z; intuition. 2: case Fs; intros H1 (H2, H3); auto. apply Rle_trans with (/ 2%nat * Fulp b radix precision r)%R. replace (Rabs (FtoRradix r - (FtoRradix p + FtoRradix q))) with (/ 2%nat * (2%nat * Rabs (FtoRradix r - (FtoRradix p + FtoRradix q))))%R; [ idtac | rewrite <- Rmult_assoc; rewrite Rinv_l; auto with real ]. apply Rmult_le_compat_l; auto with real. replace (FtoRradix r - (FtoRradix p + FtoRradix q))%R with (- (FtoRradix p + FtoRradix q - FtoRradix r))%R; [ rewrite Rabs_Ropp | ring ]. apply (ClosestUlp b radix); auto. replace (Rabs r * / 2%nat * (radix * / Zpos (vNum b)))%R with (/ 2%nat * (Rabs r * (radix * / Zpos (vNum b))))%R; [ apply Rmult_le_compat_l; auto with real | ring ]. replace (Fulp b radix precision r) with (Zpos (vNum b) * FtoR radix (Float 1%nat (Zpred (Fexp (Fnormalize radix b precision r)))) * (radix * / Zpos (vNum b)))%R. apply Rmult_le_compat_r. replace 0%R with (radix * 0)%R; [ apply Rmult_le_compat_l | ring ]; apply Rlt_le; auto with real arith; rewrite INR_IZR_INZ; apply Rlt_IZR; simpl in |- *; apply Zlt_1_O; apply Zlt_le_weak; apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. unfold FtoRradix in |- *; rewrite <- (FnormalizeCorrect _ radixMoreThanOne b precision r). rewrite <- (Fabs_correct radix); auto with arith. apply FnormalBoundAbs2 with precision; auto with arith. unfold Fulp, FtoRradix, FtoR in |- *; simpl in |- *. apply trans_eq with (nat_of_P (vNum b) * / nat_of_P (vNum b) * (radix * powerRZ radix (Zpred (Fexp (Fnormalize radix b precision r)))))%R; [ unfold IZR at 1 5; repeat rewrite <- INR_IPR; ring | idtac]. rewrite Rinv_r; auto with real arith. rewrite <- powerRZ_Zs; auto with real zarith. rewrite <- Zsucc_pred; ring. Qed. Theorem plusErrorBound1withZero : forall p q r : float, Fbounded b p -> Fbounded b q -> Closest b radix (p + q) r -> (Rabs (r - (p + q)) <= Rabs r * / 2%nat * (radix * / pPred (vNum b)))%R. 
* listpred (fun a => a |->?) l * smrep freeblocks)%pred sm ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * rep xp (rev l ++ freeblocks) ms) ]]] * [[ (Fs * smrep (rev l ++ freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} freevec lxp xp l ms. Proof. unfold freevec. safestep. eauto. eauto. prestep; norml. denote Fm as Hx. denote smrep as Hs. destruct l. denote (_ < _) as Hy; simpl in Hy; inversion Hy. rewrite listpred_isolate with (i := 0) in Hx, Hs by (rewrite skipn_length; omega). rewrite skipn_selN, Nat.add_0_r in Hx, Hs. apply sep_star_reorder_helper in Hx. apply pimpl_exists_r_star_r in Hx; destruct Hx as [ [? ?] ?]. destruct_lift Hs. safecancel. rewrite selN_cons_fold; apply Forall_selN; auto. eauto. rewrite sep_star_assoc_1, sep_star_comm. eauto. step. rewrite removeN_0_skipn; cancel. rewrite selN_cons_fold. replace ([n]) with (rev [n]) by auto. rewrite <- rev_app_distr. rewrite app_comm_cons, <- rev_unit. rewrite <- firstn_S_selN by auto. cancel. rewrite removeN_0_skipn; cancel. rewrite selN_cons_fold. rewrite smrep_cons. rewrite app_comm_cons, <- rev_unit. rewrite <- firstn_S_selN by auto. cancel. step. rewrite firstn_oob by auto. rewrite skipn_oob by auto. step. cancel. erewrite <- LOG.intact_hashmap_subset; eauto. Unshelve. all: eauto; try exact tt. exact (LOG.mk_memstate0 (BUFCACHE.cache0 0)). Qed. Hint Extern 1 ({{_}} Bind (freevec _ _ _ _) _) => apply freevec_ok : prog. Lemma xparams_ok_goodSize : forall xp a, Sig.xparams_ok xp -> a < (BmapNBlocks xp) * valulen -> goodSize addrlen a. Proof. unfold Sig.xparams_ok; intuition. eapply goodSize_trans. eapply Nat.lt_le_incl; eauto. eapply goodSize_trans. eapply mult_le_compat_r; eauto. unfold goodSize. replace addrlen with (16 + 16 + 16 + 16) by (compute; auto). rewrite <- Nat.mul_1_r at 1. repeat apply mult_pow2_bound; try apply valulen_bound. apply one_lt_pow2. Qed. Lemma bn_valid_goodSize : forall F l m ms xp a, (F * rep xp l ms)%pred m -> bn_valid xp a -> goodSize addrlen a. Proof. unfold rep, bn_valid. unfold Alloc.rep, Alloc.Alloc.rep, Alloc.Alloc.Bmp.rep, Alloc.Alloc.Bmp.items_valid, Alloc.Alloc.BmpSig.xparams_ok; intuition. destruct_lift H. eapply xparams_ok_goodSize; eauto. Qed. Lemma bn_valid_goodSize_pimpl : forall l xp ms, rep xp l ms <=p=> [[ forall a, bn_valid xp a -> goodSize addrlen a ]] * rep xp l ms. Proof. intros; split. unfold pimpl; intros. pred_apply; cancel. apply emp_star in H. eapply bn_valid_goodSize; eauto. cancel. Qed. Lemma bn_valid_facts : forall xp bn, bn_valid xp bn -> bn <> 0 /\ bn < (BmapNBlocks xp) * valulen. Proof. unfold bn_valid; auto. Qed. Theorem bn_valid_roundtrip' : forall xp a, Sig.xparams_ok xp -> bn_valid xp a -> bn_valid xp (# (natToWord addrlen a)). 
intros p; unfold FSucc, Fodd, Feven in |- *. generalize (Z_eq_bool_correct (Fnum p) (pPred (vNum b))); case (Z_eq_bool (Fnum p) (pPred (vNum b))); intros H'1. rewrite H'1; simpl in |- *; auto. unfold pPred in |- *; rewrite pGivesBound; unfold nNormMin in |- *. case (OddEvenDec radix); auto with zarith. intros H'; split; intros H'0; auto with zarith. apply EvenMultInv with (n := radix); auto. pattern radix at 1 in |- *; rewrite <- Zpower_nat_1; rewrite <- Zpower_nat_is_exp. replace (1 + pred precision) with precision; [ idtac | inversion precisionGreaterThanOne; auto ]. rewrite (Zsucc_pred (Zpower_nat radix precision)); auto with zarith. intros H'; split; intros H'0; auto with zarith. replace (pred precision) with (S (pred (pred precision))); auto with zarith. Contradict H'0; apply OddNEven. replace (Zpred (Zpower_nat radix precision)) with (Zpower_nat radix precision + - (1))%Z; [ idtac | unfold Zpred in |- *; simpl in |- *; auto ]. replace precision with (S (pred precision)); [ auto with zarith | inversion precisionGreaterThanOne; auto ]. generalize (Z_eq_bool_correct (Fnum p) (- nNormMin radix precision)); case (Z_eq_bool (Fnum p) (- nNormMin radix precision)); intros H'2. generalize (Z_eq_bool_correct (Fexp p) (- dExp b)); case (Z_eq_bool (Fexp p) (- dExp b)); intros H'3. simpl in |- *; auto with zarith. simpl in |- *; auto with zarith. rewrite H'2; unfold pPred, nNormMin in |- *; rewrite pGivesBound. case (OddEvenDec radix); auto with zarith. intros H'; split; intros H'0; auto with zarith. apply EvenOpp; apply OddSEvenInv; rewrite <- Zsucc_pred; auto with zarith. Contradict H'0; replace precision with (S (pred precision)); [ auto with zarith | inversion precisionGreaterThanOne; auto ]. intros H'; split; intros H'0; auto with zarith. Contradict H'0; replace (pred precision) with (S (pred (pred precision))); [ auto with zarith | auto with zarith ]. replace precision with (S (pred precision)); [ auto with zarith | inversion precisionGreaterThanOne; auto ]. apply OddOpp; apply EvenSOddInv; rewrite <- Zsucc_pred; auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem FoddSuc : forall p : float, Fodd p -> Feven (FSucc b radix precision p). intros p H'; case (FevenSucProp p); auto. Qed. Theorem FevenSuc : forall p : float, Feven p -> Fodd (FSucc b radix precision p). intros p H'; case (FevenSucProp p); auto. Qed. Theorem FevenFop : forall p : float, Feven p -> Feven (Fopp p). intros p; unfold Feven, Fopp in |- *; simpl in |- *; auto with zarith. Qed. Theorem FoddFop : forall p : float, Fodd p -> Fodd (Fopp p). 
End TREE.Module Tree : TREE. Open Scope Sep_scope. Fixpoint tree' (b : bag) (t : shape) (p : W) : HProp := match t with | Leaf => [| p = 0 |] | Node t1 t2 => [| p <> 0 |] * Ex i, Ex c, Ex p1, Ex p2, (p ==*> i, c, p1, p2) * (if weq c $0 then [| p1 %in b |] * [| t1 = Leaf |] else tree' b t1 p1) * tree' b t2 p2 end. Definition tree'' (b : bag) (t : shape) (p c : W) : HProp := if weq c $0 then [| p %in b |] * [| t = Leaf |] else tree' b t p. Definition tree (b : bag) (p : W) : HProp := Ex t, Ex p', Ex junk, (p ==*> p', junk) * tree' b t p'. Theorem tree_fwd : forall b p, tree b p ===> Ex t, Ex p', Ex junk, (p ==*> p', junk) * tree' b t p'. unfold tree; sepLemma. Qed. Theorem tree_bwd : forall b p, (Ex t, Ex p', Ex junk, (p ==*> p', junk) * tree' b t p') ===> tree b p. unfold tree; sepLemma. Qed. Ltac normalize := match goal with | [ |- context C[(Ex i : W, Ex c : W, Ex p1 : W, Ex p2 : W, ?p =*> i * ((?p ^+ $4) =*> c * ((?p ^+ $8) =*> p1 * (?p ^+ $12) =*> p2)) * (if weq c $0 then [| p1 %in ?b |] * [| ?t1 = Leaf |] else tree' ?b ?t1 p1) * tree' ?b ?t2 p2)%Sep] ] => let G := context C[(Ex i : W, Ex c : W, Ex p1 : W, Ex p2 : W, p =*> i * ((p ^+ $4) =*> c * ((p ^+ $8) =*> p1 * (p ^+ $12) =*> p2)) * tree'' b t1 p1 c * tree' b t2 p2)%Sep] in change G end. Theorem tree'_nil_fwd : forall b t (p : W), p = 0 -> tree' b t p ===> [| t = Leaf |]. destruct t; simpl; intros; try normalize; sepLemma. Qed. Theorem tree'_nil_bwd : forall b t (p : W), p = 0 -> [| t = Leaf |] ===> tree' b t p. destruct t; simpl; intros; try normalize; sepLemma. Qed. Theorem tree'_cons_fwd : forall b t (p : W), p <> 0 -> tree' b t p ===> Ex t1, Ex t2, Ex i, Ex c, Ex p1, Ex p2, [| t = Node t1 t2 |] * (p ==*> i, c, p1, p2) * tree'' b t1 p1 c * tree' b t2 p2. 
{ rewrite mkApps_app /=. eapply type_App'; eauto. } epose proof (fix_app_is_constructor X0 e); eauto. rewrite /is_constructor. destruct nth_error eqn:hnth => //. 2:{ eapply nth_error_None in hnth. len in hnth. } assert (All (closedn 0) (argsv ++ [av])). { eapply subject_closed in X0; eauto. rewrite closedn_mkApps in X0. move/andP: X0 => [clfix clargs]. now eapply forallb_All in clargs. } assert (All (value Σ) (argsv ++ [av])). { eapply All_app_inv; [|constructor; [|constructor]]. eapply eval_to_value in He1. eapply value_mkApps_inv in He1 as [[-> Hat]|[vh vargs]] => //. now eapply eval_to_value in He2. } solve_all. eapply nth_error_all in X3; eauto. simpl in X3. destruct X3 as [cl val]. eapply X1, value_whnf; auto. now eapply value_axiom_free. } redt _; eauto. - apply inversion_App in Ht; auto; destruct_sigma Ht. specialize (IHHe1 _ t). specialize (IHHe2 _ t0). now eapply red_app. - epose proof (subject_reduction Σ [] _ _ _ wfΣ Ht). apply inversion_Case in Ht; auto; destruct_sigma Ht. destruct c. specialize (IHHe1 _ scrut_ty). unshelve epose proof (subject_reduction Σ [] _ _ _ wfΣ _ IHHe1). 2:eauto. pose proof (subject_closed X0). etransitivity. eapply red_case_c. eapply IHHe1; eauto. rewrite closedn_mkApps in H. move/andP: H => [clcofix clargs]. assert (red Σ [] (tCase ip p (mkApps (tCoFix mfix idx) args) brs) (tCase ip p (mkApps fn args) brs)). { eapply red1_red. eapply red_cofix_case. rewrite -closed_unfold_cofix_cunfold_eq in e; eauto. } redt _; eauto. eapply IHHe2. eapply subject_reduction. 3: eapply X1. eauto. eapply subject_reduction. 3: eapply red_case_c; eauto. all:eauto. - epose proof (subject_reduction Σ [] _ _ _ wfΣ Ht). apply inversion_Proj in Ht; auto; destruct_sigma Ht. specialize (IHHe1 _ t). unshelve epose proof (subject_reduction Σ [] _ _ _ wfΣ _ IHHe1). 2:eauto. pose proof (subject_closed X0). etransitivity. eapply red_proj_c. eapply IHHe1; eauto. rewrite closedn_mkApps in H. move/andP: H => [clcofix clargs]. assert (red Σ [] (tProj p (mkApps (tCoFix mfix idx) args)) (tProj p (mkApps fn args))). { eapply red1_red. eapply red_cofix_proj. rewrite -closed_unfold_cofix_cunfold_eq in e; eauto. } redt _; eauto. eapply IHHe2. eapply subject_reduction. 3: eapply X1. eauto. eapply subject_reduction. 3: eapply red_proj_c; eauto. all:eauto. - eapply inversion_App in Ht as (? & ? & ? & Hf & Ha & Ht); auto. specialize (IHHe1 _ Hf). specialize (IHHe2 _ Ha). rewrite mkApps_app /=. now eapply red_app. - eapply inversion_App in Ht as (? & ? & ? & Hf & Ha & Ht); auto. specialize (IHHe1 _ Hf). specialize (IHHe2 _ Ha). now eapply red_app. Qed. Theorem subject_reduction_eval {t u T} : Σ ;;; [] |- t : T -> eval Σ t u -> Σ ;;; [] |- u : T. 
From Perennial.program_proof.mvcc Require Import tuple_prelude tuple_repr.Section proof. Context `{!heapGS Σ, !mvcc_ghostG Σ}. Theorem wp_tuple__appendVersion tuple (tid : u64) (val : u64) owned tidlast vers : {{{ own_tuple_phys tuple owned tidlast vers }}} Tuple__appendVersion #tuple #tid #val {{{ RET #(); own_tuple_phys tuple false (U64 (int.Z tid + 1)) (vers ++ [(tid, false, val)]) }}}. 
) : isdeceq Y . Proof. intros . intros y y' . set ( w' := weqonpaths ( invweq w ) y y' ) . set ( int := is ( ( invweq w ) y ) ( ( invweq w ) y' ) ) . destruct int as [ i | ni ] . apply ( ii1 ( ( invweq w' ) i ) ) . apply ( ii2 ( ( negf w' ) ni ) ) . Defined . Lemma isdeceqweqb { X Y : UU } ( w : weq X Y ) ( is : isdeceq Y ) : isdeceq X . Proof . intros . apply ( isdeceqweqf ( invweq w ) is ) . Defined . Theorem isdeceqinclb { X Y : UU } ( f : X -> Y ) ( is : isdeceq Y ) ( is' : isincl f ) : isdeceq X . Proof. intros . intros x x' . set ( w := weqonpathsincl f is' x x' ) . set ( int := is ( f x ) ( f x' ) ) . destruct int as [ i | ni ] . apply ( ii1 ( ( invweq w ) i ) ) . apply ( ii2 ( ( negf w ) ni ) ) . Defined . Lemma isdeceqifisaprop ( X : UU ) : isaprop X -> isdeceq X . Proof. intros X is . intros x x' . apply ( ii1 ( proofirrelevance _ is x x' ) ) . Defined .Theorem isasetifdeceq (X:UU): isdeceq X -> isaset X. Proof. intro X . intro is. intros x x' . apply ( isaproppathsfromisolated X x ( is x ) ) . Defined . Definition booleq { X : UU } ( is : isdeceq X ) ( x x' : X ) : bool . Proof . intros . destruct ( is x x' ) . apply true . apply false . Defined . Lemma eqfromdnegeq (X:UU)(is: isdeceq X)(x x':X): dneg ( paths x x' ) -> paths x x'. Proof. intros X is x x' X0. destruct ( is x x' ) . assumption . destruct ( X0 e ) . Defined .Theorem isdeceqbool: isdeceq bool. Proof. unfold isdeceq. intros x' x . destruct x. destruct x'. apply (ii1 (idpath true)). apply (ii2 nopathsfalsetotrue). destruct x'. apply (ii2 nopathstruetofalse). apply (ii1 (idpath false)). Defined. Theorem isasetbool: isaset bool. 
TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_Wf_l_new (m : BaseModuleWf_new type) : TraceInclusion (inlineAll_Rules_BaseModuleWf_new m) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineAll_pos_Rules_Wf_l m'). Qed. Lemma TraceInclusion_inlineSingle_pos_Meths_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> forall n, (WfMod type (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n))) (Base (BaseMod regs rules meths)). Proof. intros WfH n. unfold inlineSingle_Meths_pos. case_eq (nth_error meths n); intros sth; [intros sthEq|split; [assumption | apply TraceInclusion_refl]]. split. - apply nth_error_In in sthEq. pose proof (WfMod_inline_all_Meth sth (seq 0 (length meths)) sthEq WfH). repeat rewrite map_fold_right_eq in *. assumption. - apply TraceInclusion_inline_BaseModule_meths_l; auto. eapply nth_error_In; eauto. Qed. Theorem TraceInclusion_inlineSingle_pos_Meths_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> forall n, (WfMod_new type (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n))) (Base (BaseMod regs rules meths)). Proof. intros. rewrite WfMod_new_WfMod_iff in *. apply TraceInclusion_inlineSingle_pos_Meths_l; auto. Qed. Lemma TraceInclusion_inlineSingle_pos_Meths_Wf_l (m : BaseModuleWf type) n : TraceInclusion (inlineSingle_Meths_pos_BaseModuleWf m n) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineSingle_pos_Meths_l P2 n) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineSingle_pos_Meths_Wf_l_new (m : BaseModuleWf_new type) n : TraceInclusion (inlineSingle_Meths_pos_BaseModuleWf_new m n) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineSingle_pos_Meths_Wf_l m'). Qed. Lemma TraceInclusion_inlineAll_pos_Meths_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> (WfMod type (Base (BaseMod regs rules (inlineAll_Meths meths)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineAll_Meths meths))) (Base (BaseMod regs rules meths)). Proof. intros WfH. unfold inlineAll_Meths. induction (Datatypes.length meths); [simpl; split; [assumption | apply TraceInclusion_refl]|]. rewrite seq_eq. rewrite fold_left_app; simpl. destruct IHn as [IHn1 IHn2]. pose proof (TraceInclusion_inlineSingle_pos_Meths_l IHn1 n) as [sth1 sth2]. destruct n; simpl in *; auto. split; auto. eapply TraceInclusion_trans; eauto. Qed. Theorem TraceInclusion_inlineAll_pos_Meths_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> (WfMod_new type (Base (BaseMod regs rules (inlineAll_Meths meths)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineAll_Meths meths))) (Base (BaseMod regs rules meths)). Proof. repeat rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inlineAll_pos_Meths_l. Qed. Lemma TraceInclusion_inlineAll_pos_Meths_Wf_l (m : BaseModuleWf type) : TraceInclusion (inlineAll_Meths_BaseModuleWf m) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineAll_pos_Meths_l P2) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Meths_Wf_l_new (m : BaseModuleWf_new type) : TraceInclusion (inlineAll_Meths_BaseModuleWf_new m) m. 
p q, eqP A eqA n (pluspf p q) (pluspf q p). intros p q; apply (plusP_com p q (pluspf p q) (pluspf q p)); auto. Qed. Theorem plusP_zero_pOl : forall p q, plusP (pO A n) p q -> eqP A eqA n p q. intros p q H'; inversion H'; auto. Qed. Theorem plusP_zero_pOr : forall p q, plusP p (pO A n) q -> eqP A eqA n p q. intros p q H'; inversion H'; auto. Qed. Hint Resolve plusP_zero_pOl plusP_zero_pOr. Hint Resolve eqp_trans. Theorem plusP_uniq_eqP : forall p q r s, plusP p q r -> plusP p q s -> eqP A eqA n r s. intros p q r s H' H'0; rewrite (uniq_plusp (p, q) r s); auto. Qed. Hint Resolve plusP_uniq_eqP. Theorem pO_pluspf_inv1 : forall p, p = pluspf (pO A n) p. intros p. apply uniq_plusp with (l := (pO A n, p)); auto. Qed. Theorem pO_pluspf_inv2 : forall p, p = pluspf p (pO A n). intros p. apply uniq_plusp with (l := (p, pO A n)); auto. Qed. Theorem pluspf_inv1_eq : forall a b p q, ltT ltM b a -> pX a (pluspf p (pX b q)) = pluspf (pX a p) (pX b q). intros a b p q H'; rewrite (plusP_inv1 a b p q (pluspf (pX a p) (pX b q))); auto. Qed. Theorem pluspf_inv2_eq : forall a b p q, ltT ltM a b -> pX b (pluspf (pX a p) q) = pluspf (pX a p) (pX b q). intros a b p q H'; rewrite (plusP_inv2 a b p q (pluspf (pX a p) (pX b q))); auto. Qed. Theorem pluspf_inv3a_eq : forall a b p q, eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> pluspf p q = pluspf (pX a p) (pX b q). intros a b p q H' H1'; rewrite (plusP_inv3a a b p q (pluspf (pX a p) (pX b q))); auto. Qed. Theorem pluspf_inv3b_eq : forall a b p q, eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> pX (plusTerm (A:=A) plusA (n:=n) a b) (pluspf p q) = pluspf (pX a p) (pX b q). intros a b p q H' H1'; rewrite (plusP_inv3b a b p q (pluspf (pX a p) (pX b q))); auto. Qed. Theorem order_pluspf : forall l1 l2 a, canonical A0 eqA ltM (pX a l1) -> canonical A0 eqA ltM (pX a l2) -> canonical A0 eqA ltM (pX a (pluspf l1 l2)). 
match M.get v sub with | None => d | Some e => e end.Definition seto {A:Type} (x:var)(oa:option A) (map:M.t A):= match oa with | Some a => M.set x a map | None => map end.Notation get_c := (getd 0%nat). Notation get_b := (getd false). Section MEASURECONTRACT. Create HintDb mtss. Fixpoint term_size (e: exp) : nat := match e with | Econstr _ _ _ e => 1 + term_size e | Ecase _ cl => 1 + (List.fold_right (fun (p:(ctor_tag * exp)) => fun (n:nat) => let (k, e) := p in (n + (term_size e))%nat) 0%nat cl) | Eproj _ _ _ _ e => 1 + term_size e | Eletapp _ _ _ _ e => 1 + term_size e | Eapp _ _ _ => 1 | Eprim _ _ _ e => 1 + term_size e | Efun fds e => 1 + funs_size fds + term_size e | Ehalt _ => 1 end with funs_size fds : nat := match fds with | Fcons _ _ _ e fds' => 1 + funs_size fds' + term_size e | Fnil => 1 end. Definition svalue_size (v: svalue) : nat := match v with | SVconstr t lv => 0 | SVfun t lv e => term_size e end. Definition svalue_inl_size (f:(positive*svalue)) (inl:b_map): nat := (if (get_b (fst f) inl) then 0 else svalue_size (snd f)). Theorem svalue_inl_le: forall i v im, svalue_inl_size (i,v) im <= svalue_size v. Proof. intros. unfold svalue_inl_size. simpl. destruct (get_b i im). apply Peano.le_0_n. auto. Defined. Lemma term_size_inline_letapp e x C y e' : inline_letapp e x = Some (C, y) -> term_size (C |[ e' ]|) <= term_size e + term_size e'. Proof. generalize C. induction e; intros C' Heq; simpl in *; try ((destruct (inline_letapp e x) as [ [C'' z'] | ] eqn:Heq''; try congruence); inv Heq; simpl; eauto using Peano.le_n_S). congruence. eapply Peano.le_n_S. specialize (IHe C'' (eq_refl)). lia. inv Heq. simpl. reflexivity. inv Heq. simpl. eauto. Defined. Definition list_inl_size (sub:list (positive*svalue)) (inl:b_map):= fold_right plus 0 (map (fun v => svalue_inl_size v inl) sub). Theorem list_inl_size_app: forall l l' inl, list_inl_size (l++l') inl = list_inl_size l inl + list_inl_size l' inl . Proof. induction l; intros. reflexivity. unfold list_inl_size. simpl. unfold list_inl_size in IHl. rewrite IHl. rewrite <- Nat.add_assoc. reflexivity. Qed. Definition sub_inl_size (sub:ctx_map) (inl:b_map):= fold_left plus (map (fun v => svalue_inl_size v inl) (M.elements sub)) 0. Theorem sub_inl_proof: forall sub inl, sub_inl_size sub inl = list_inl_size (M.elements sub) inl. 
= a2. Proof using. intros c a1 a2 lb1 lb2 (H1, H2); apply (H1 a1 a2 lb1 lb2); auto. Qed. Theorem unique_prefix2 : forall c : code, unique_prefix c -> unique_key c. Proof using. intros c (H1, H2); auto. Qed. Theorem unique_prefix_inv : forall (c : code) (a : A) (l : list bool), unique_prefix ((a, l) :: c) -> unique_prefix c. Proof using. intros c a l (H1, H2); split. intros a1 a2 lb1 lb2 H H0 H3; apply (H1 a1 a2 lb1 lb2); simpl in |- *; auto. apply unique_key_inv with (1 := H2); auto. Qed. Theorem unique_prefix_not_null : forall (c : code) (a b : A), a <> b -> in_alphabet (a :: b :: nil) c -> unique_prefix c -> not_null c. Proof using. intros c a b H H0 H1. unfold not_null in |- *; intros a1; red in |- *; intros Ha1. case (H0 a); simpl in |- *; auto; intros l1 Hl1. case (H0 b); simpl in |- *; auto; intros l2 Hl2. case H; apply trans_equal with a1. apply sym_equal; apply unique_prefix1 with (3 := Hl1) (2 := Ha1); auto. apply unique_prefix1 with (3 := Hl2) (2 := Ha1); auto. Qed. Theorem unique_prefix_permutation : forall c1 c2 : code, permutation c1 c2 -> unique_prefix c1 -> unique_prefix c2. Proof using. intros c1 c2 H (H1, H2). cut (permutation c2 c1); [ intros HP; split | apply permutation_sym; auto ]. intros a1 a2 lb1 lb2 H0 H3 H4. apply (H1 a1 a2 lb1 lb2); auto. apply permutation_in with (2 := H0); auto. apply permutation_in with (2 := H3); auto. apply unique_key_perm with (2 := H2); auto. Qed. Fixpoint find_code (a : A) (l : code) {struct l} : list bool := match l with | nil => nil | (b, c) :: l1 => match eqA_dec a b with | left _ => c | right _ => find_code a l1 end end. Theorem find_code_correct1 : forall (c : code) (a : A) (b : bool) (l : list bool), find_code a c = b :: l -> In (a, b :: l) c. Proof using. intros c a b l; elim c; simpl in |- *; auto. intros; discriminate. intros a0; case a0. intros a1; case (eqA_dec a a1); simpl in |- *; auto. intros e l0 l1 H H0; left; apply f_equal2 with (f := pair (A:=A) (B:=list bool)); auto. Qed. Theorem find_code_correct2 : forall (c : code) (a : A) (l : list bool), unique_key c -> In (a, l) c -> find_code a c = l. 
Require Import Bool. Require Import Arith. Require Import Compare_dec. Require Import Peano_dec. Require Import General. Require Import MyList. Require Import MyRelations.Require Export Main. Require Export SortECC.Section ECC. Definition trm_ecc := term srt_ecc. Definition env_ecc := env srt_ecc. Definition ecc : CTS_spec srt_ecc := Build_CTS_spec _ axiom_ecc rules_ecc univ_ecc (beta_delta_rule _). Definition ecc_pts : PTS_sub_spec srt_ecc := cts_pts_functor _ ecc. Definition le_type : red_rule srt_ecc := Rule _ (Le_type _ (pts_le_type _ ecc_pts)). Definition typ_ecc : env_ecc -> trm_ecc -> trm_ecc -> Prop := typ _ ecc_pts. Definition wft_ecc : env_ecc -> trm_ecc -> Prop := wf_type _ ecc_pts. Definition wf_ecc : env_ecc -> Prop := wf _ ecc_pts. Definition ecc_sn := sn srt_ecc (ctxt _ (Rule _ (head_reduct _ ecc))). Hint Unfold le_type typ_ecc wft_ecc wf_ecc ecc_sn: pts. Lemma whnf : forall (e : env_ecc) (t : trm_ecc), ecc_sn e t -> {u : trm_ecc | red _ (beta_delta _) e t u & head_normal _ (beta_delta _) e u}. Proof beta_delta_whnf srt_ecc. Lemma bd_conv_hnf : forall (e : env_ecc) (x y : trm_ecc), ecc_sn e x -> ecc_sn e y -> decide (conv_hn_inv _ (beta_delta_rule _) e x y). Proof CR_WHNF_convert_hn srt_ecc ecc_sort_dec (beta_delta_rule srt_ecc) (church_rosser_beta_delta srt_ecc) whnf. Theorem ecc_is_subtype_dec : subtype_dec_CTS _ ecc. 
(nwState net) (pDst p) d h) -> (forall p' : packet, In p' ps' -> In p' (xs ++ ys)) -> currentTerm (nwState net (pDst p)) <= currentTerm d -> log d = log (nwState net (pDst p)) -> no_entries_past_current_term {| nwPackets := ps'; nwState := st' |}. Proof using. intros. unfold no_entries_past_current_term in *. intuition. - unfold no_entries_past_current_term_host in *. intros. simpl in *. find_higher_order_rewrite. break_if; eauto. subst. repeat find_rewrite. eapply le_trans; [|eauto]. eauto. - unfold no_entries_past_current_term_nw. intros. simpl in *. find_apply_hyp_hyp. match goal with | _ : In ?p _ |- _ => assert (In p (nwPackets net)) by (find_rewrite; in_crush) end. eapply_prop no_entries_past_current_term_nw; eauto. Qed. Lemma handleAppendEntriesReply_spec : forall h st h' t es r st' ms, handleAppendEntriesReply h st h' t es r = (st', ms) -> (currentTerm st <= currentTerm st' /\ log st' = log st /\ (forall m, In m ms -> ~ is_append_entries (snd m))). Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition; try solve [break_exists; congruence]; in_crush; eauto using removeAfterIndex_in. Qed. Lemma no_entries_past_current_term_append_entries_reply : raft_net_invariant_append_entries_reply no_entries_past_current_term. Proof using. unfold raft_net_invariant_append_entries_reply. intros. find_apply_lem_hyp handleAppendEntriesReply_spec. intuition eauto using no_entries_past_current_term_unaffected. Qed. Lemma handleRequestVote_spec : forall h st t h' pli plt st' m, handleRequestVote h st t h' pli plt = (st', m) -> (currentTerm st <= currentTerm st' /\ log st' = log st /\ ~ is_append_entries m). Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition; try solve [break_exists; congruence]; in_crush; eauto using removeAfterIndex_in. Qed. Lemma no_entries_past_current_term_request_vote : raft_net_invariant_request_vote no_entries_past_current_term. Proof using. unfold raft_net_invariant_request_vote. intros. find_apply_lem_hyp handleRequestVote_spec. intuition eauto using no_entries_past_current_term_unaffected_1. Qed. Lemma handleRequestVoteReply_spec : forall h st h' t v st', handleRequestVoteReply h st h' t v = st' -> (currentTerm st <= currentTerm st' /\ log st' = log st). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition. Qed. Lemma no_entries_past_current_term_request_vote_reply : raft_net_invariant_request_vote_reply no_entries_past_current_term. Proof using. unfold raft_net_invariant_request_vote_reply. intros. find_apply_lem_hyp handleRequestVoteReply_spec. intuition eauto using no_entries_past_current_term_unaffected_0. Qed. Lemma no_entries_past_current_term_state_same_packet_subset : raft_net_invariant_state_same_packet_subset no_entries_past_current_term. Proof using. unfold raft_net_invariant_state_same_packet_subset, no_entries_past_current_term, no_entries_past_current_term_host, no_entries_past_current_term_nw. intros. intuition. - repeat find_reverse_higher_order_rewrite. eauto. - find_apply_hyp_hyp. eauto. Qed. Lemma no_entries_past_current_term_reboot : raft_net_invariant_reboot no_entries_past_current_term. Proof using. unfold raft_net_invariant_reboot, no_entries_past_current_term, no_entries_past_current_term_host, no_entries_past_current_term_nw, reboot. intuition. - repeat find_higher_order_rewrite. simpl in *. subst. break_if; simpl in *; intuition. - find_reverse_rewrite. eauto. Qed. Theorem no_entries_past_current_term_invariant : forall net, raft_intermediate_reachable net -> no_entries_past_current_term net. 
apply m2 | exact (refl_equal true) | link_simp; tauto | link_simp; tauto | link_simp; tauto ].Lemma specs_cong : forall (specs : codeSpec W (settings * state)) x p, specs x = p -> forall y, x = y -> specs y = p. congruence. Qed.Implicit Arguments specs_cong [specs x p y].Hint Extern 1 (?specs _ = Some _) => match goal with | [ H : specs _ = Some _ |- _ ] => apply (specs_cong H); congruence end.Lemma use_himp : forall pc state specs (P Q : hprop pc state nil), himp specs P Q -> forall s m, interp specs (P s m) -> interp specs (Q s m). intros; apply (Imply_sound (H _ _)); auto. Qed.Lemma Imply_refl : forall pc state specs (P : PropX pc state), interp specs (P ---> P). intros; apply Imply_I; apply Env; simpl; auto. Qed.Section PropX. Variables pc state : Type. Variable P : PropX pc state. Variable specs : codeSpec pc state. Open Scope PropX_scope. Theorem injL : forall (p : Prop), (p -> interp specs P) -> interp specs ([| p |] ---> P). intros. apply Imply_I. eapply Inj_E. eauto. auto. Qed. Theorem cptrL : forall i a, (specs i = Some (fun x => a x) -> interp specs P) -> interp specs (Cptr i a ---> P). intros. apply Imply_I. eapply Cptr_E. eauto. eauto. Qed. Theorem andL : forall Q R, interp specs (Q ---> (R ---> P)) -> interp specs (Q /\ R ---> P). intros. apply Imply_I. eapply Imply_E. eapply Imply_E. eauto. eapply And_E1. eauto. eapply And_E2. eauto. Qed. Ltac hyp := eapply Env; simpl; eauto. Theorem existsL : forall A (p : A -> _), (forall x, interp specs (p x ---> P)) -> interp specs ((Exists p) ---> P). intros. apply Imply_I. eapply Exists_E. eauto. intros. eapply Imply_E. eauto. hyp. Qed. Theorem injR : forall (p : Prop), p -> interp specs (P ---> [| p |]). intros. apply Imply_I. eapply Inj_I. auto. Qed. Theorem cptrR : forall i a, specs i = Some (fun x => a x) -> interp specs (P ---> Cptr i a). intros. apply Imply_I. apply Cptr_I. auto. Qed. Theorem andR : forall Q R, interp specs (P ---> Q) -> interp specs (P ---> R) -> interp specs (P ---> Q /\ R). intros. apply Imply_I. apply And_I. eapply Imply_E. eauto. eauto. eapply Imply_E. eauto. eauto. Qed. Theorem allR : forall A (p : A -> _), (forall x, interp specs (P ---> p x)) -> interp specs (P ---> (Forall p)). 
Require Import FCF.FCF. Require Export FCF.GroupTheory.Local Open Scope group_scope.Definition RndGrpElem`{FCG : FiniteCyclicGroup}{eqd : EqDec GroupElement} := n <-$ [0 .. order); ret (g^n).Section RndGrpElem. Context`{FCG : FiniteCyclicGroup}. Hypothesis GroupElement_EqDec : EqDec GroupElement. Theorem RndGrpElem_wf : well_formed_comp RndGrpElem. unfold RndGrpElem. wftac. Qed. Theorem groupExp_closed : forall k, In (g^k) (getSupport RndGrpElem). intuition. erewrite groupExp_mod. simpl. eapply in_getUnique. eapply in_flatten. econstructor. split. eapply in_map_iff. econstructor. split. eauto. eapply filter_In. split. eapply in_getUnique. eapply in_flatten. econstructor. split. eapply in_map_iff. econstructor. split. eapply eq_refl. eapply in_getAllBvectors. simpl. left. eapply eq_refl. 2:{ rewrite bvToNat_natToBv_inverse. simpl. left. eapply eq_refl. eapply lognat_monotonic. eapply modNat_lt. } rewrite bvToNat_natToBv_inverse. unfold ltNatBool. destruct (lt_dec (modNat k order) order); trivial. exfalso. eapply n. eapply modNat_lt. eapply lognat_monotonic. eapply modNat_lt. apply g_generator. Qed. Theorem RndGrpElem_uniform : forall x y, evalDist RndGrpElem x == evalDist RndGrpElem y. 
in *. unfold eqbPair in *. simpl in *. rewrite H1 in H. case_eq (eqb a0 a); intuition. rewrite H2 in H. simpl in *. eapply IHx1; eauto. rewrite H2 in H. simpl in *. eapply IHx1; eauto. Qed. Theorem in_impl_collidesWith : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B), In (a, b) ls -> a <> a' -> collidesWith _ _ ls a' b = true. unfold collidesWith in *. induction ls; intuition; simpl in *. intuition. pairInv. case_eq (eqb a' a); intuition. rewrite eqb_leibniz in H. subst. intuition. rewrite eqb_refl. simpl in *. trivial. case_eq (eqb b1 b0); intuition. case_eq (eqb a' a0); intuition. simpl. eapply IHls; intuition. eauto. subst; intuition. simpl. eapply IHls; eauto. Qed. Theorem funcCollision_false_impl_collidesWith_false : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B), funcCollision _ _ ls = false -> In (a, b) ls -> collidesWith _ _ ls a b = false. induction ls; intuition; simpl in *. intuition. pairInv. unfold collidesWith, funcCollision in *. simpl in *. repeat rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b1); intuition. rewrite H0 in H. discriminate. unfold collidesWith, funcCollision in *. simpl in *. case_eq (eqb a0 a); intuition. rewrite eqb_leibniz in H0. subst. rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b0); intuition; rewrite H0 in H. discriminate. case_eq (eqb b1 b0); intuition. simpl. eapply IHls; intuition. simpl. eapply IHls; intuition. assert (a <> a0). intuition. subst. rewrite eqb_refl in H0. discriminate. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H3. subst. intuition. simpl. case_eq (eqb b1 b0); intuition. simpl. rewrite eqb_leibniz in H4. subst. specialize (in_impl_collidesWith _ _ ls _ H1 H2); intuition. unfold collidesWith in H4. destruct (findCollision_1 eqda eqdb ls a0 b0); discriminate. simpl. case_eq (findCollision_1 eqda eqdb ls a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). induction arr; intuition; simpl in *. discriminate. remember (split arr) as z. destruct z. simpl. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H0. intuition. rewrite H0 in H. right. eapply IHarr; intuition. eauto. Qed. Theorem arrayLookup_noCollision_eq_f : forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. 
/2/ mma_mm2_state s1  mma_mm2_state s2. Proof. split. + apply mma_mm2_compute. + intros H. apply mm2_mma_compute in H. rewrite map_map in H. do 2 rewrite mm2_mma_mm2_state in H. eq goal H; do 2 f_equal. rewrite <- (map_id P) at 2. apply map_ext, mm2_mma_mm2_instr. Qed. Local Fact mma_mm2_terminates_zero_equiv P s : (1,P) /A/ s  (0,vec_zero) <-> map mma_mm2_instr P /2/ mma_mm2_state s  (0,(0,0)). Proof. apply mma_mm2_compute_equiv. Qed. Fact mma_mm2_terminates P s : (1,P) /A/ s ↓ -> map mma_mm2_instr P /2/ mma_mm2_state s ↓. Proof. intros (y & H1 & H2). exists (mma_mm2_state y); split. + apply mma_mm2_compute_equiv; auto. + intros z H. rewrite <- (mma_mm2_mma_state z) in H. rewrite <- mma_mm2_step_equiv in H. revert H. apply sss_out_step_stall with (1 := H2). Qed. Fact mm2_mma_terminates P s : P /2/ s ↓ -> (1,map mm2_mma_instr P) /A/ mm2_mma_state s ↓. Proof. intros (y & H1 & H2). exists (mm2_mma_state y); split. + apply mm2_mma_compute; auto. + destruct y as (i,(a,b)); simpl fst. red in H2. destruct (in_out_code_dec i (1, map mm2_mma_instr P)) as [ H3 | ] ; auto. destruct in_code_subcode with (1 := H3) as (rho & H4); exfalso; revert H4. rewrite <- (mm2_mma_mm2_instr rho). generalize (mma_mm2_instr rho); clear rho; intros rho. intros H4. destruct (mma_sss_total (mm2_mma_instr rho) (i,a##b##vec_nil)) as (w & Hw). apply mma_mm2_atom in Hw. apply (H2 (mma_mm2_state w)). rewrite mma_mm2_mma_instr in Hw. exists rho; split; auto; simpl. destruct H4 as (l & r & H4 & H5). exists (map mma_mm2_instr l), (map mma_mm2_instr r); split; rew length; try lia. apply f_equal with (f := map mma_mm2_instr) in H4. rewrite map_map, map_app in H4; simpl in H4. rewrite mma_mm2_mma_instr in H4. rewrite <- H4, <- (map_id P) at 1. apply map_ext; intros; rewrite mma_mm2_mma_instr; auto. Qed. Theorem mma_mma2_reduction P s : (1,P) /A/ s ↓ <-> map mma_mm2_instr P /2/ mma_mm2_state s ↓. Proof. split. + apply mma_mm2_terminates. + intros H. apply mm2_mma_terminates in H. rewrite map_map, mm2_mma_mm2_state in H. eq goal H; do 2 f_equal. rewrite <- (map_id P) at 2. apply map_ext, mm2_mma_mm2_instr. Qed. Theorem mma_mma2_zero_reduction P s : (1,P) /A/ s ~~> (0,vec_zero) <-> map mma_mm2_instr P /2/ mma_mm2_state s  (0,(0,0)). Proof. rewrite <- mma_mm2_terminates_zero_equiv; split. + intros []; auto. + intros H; split; auto; simpl; lia. Qed.End MMA2_to_MM2.Section MMA2_MM2. Let f : MMA2_PROBLEM -> MM2_PROBLEM. Proof. intros (P & v). exact (map mma_mm2_instr P, vec_pos v pos0, vec_pos v pos1). Defined. Theorem MMA2_MM2_HALTING : MMA2_HALTING ⪯ MM2_HALTING. 
Abelian_Group.op_id_uniq sum_abelian_group. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Abelian_Group.op_inv_l_r_eq sum_abelian_group. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Abelian_Group.op_inv_sym sum_abelian_group. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Abelian_Group.op_inv_uniq sum_abelian_group. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Abelian_Group.op_inv_ex sum_abelian_group. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. Proof Abelian_Group.op_inv_uniq_ex sum_abelian_group. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Abelian_Group.op_intro_l sum_abelian_group. Theorem sum_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Abelian_Group.op_intro_r sum_abelian_group. Theorem sum_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Abelian_Group.op_cancel_l sum_abelian_group. Theorem sum_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Abelian_Group.op_cancel_r sum_abelian_group. Theorem sum_inv_l_uniq : forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y. Proof Abelian_Group.op_inv_l_uniq sum_abelian_group. Theorem sum_inv_r_uniq : forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Abelian_Group.op_inv_r_uniq sum_abelian_group. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Abelian_Group.op_inv_0_l sum_abelian_group. Theorem sum_0_inv_r : sum_is_inv_r 0 0. Proof Abelian_Group.op_inv_0_r sum_abelian_group. Theorem sum_0_inv : sum_is_inv 0 0. Proof Abelian_Group.op_inv_0 sum_abelian_group. Theorem sum_has_inv_l_0 : sum_has_inv_l 0. Proof Abelian_Group.op_has_inv_l_0 sum_abelian_group. Theorem sum_has_inv_r_0 : sum_has_inv_r 0. Proof Abelian_Group.op_has_inv_r_0 sum_abelian_group. Theorem sum_has_inv_0 : sum_has_inv 0. Proof Abelian_Group.op_has_inv_0 sum_abelian_group. Theorem sum_inv_0_eq_0 : forall x : E, sum_is_inv x 0 -> x = 0. Proof Abelian_Group.op_inv_0_eq_0 sum_abelian_group. Theorem sum_inv_0_uniq : unique (fun x => sum_is_inv x 0) 0. Proof Abelian_Group.op_inv_0_uniq sum_abelian_group. Definition sum_neg_strong : forall x : E, { y | sum_is_inv x y } := Abelian_Group.op_neg_strong sum_abelian_group. Definition sum_neg : E -> E := Abelian_Group.op_neg sum_abelian_group.Notation "{-}" := (sum_neg) : ring_scope.Notation "- x" := (sum_neg x) : ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Abelian_Group.op_neg_def sum_abelian_group. Definition sum_neg_inj : is_injective E E {-} := Abelian_Group.op_neg_inj sum_abelian_group. Theorem sum_cancel_neg : forall x : E, - (- x) = x. Proof Abelian_Group.op_cancel_neg sum_abelian_group. Theorem sum_neg_onto : is_onto E E {-}. 
Require Import UniMath.Foundations.PartD. Require Import UniMath.Foundations.Propositions. Require Import UniMath.Foundations.Sets.Require Import UniMath.Combinatorics.StandardFiniteSets.Require Import UniMath.CategoryTheory.Core.Categories. Require Import UniMath.CategoryTheory.Core.Isos. Require Import UniMath.CategoryTheory.Core.Univalence. Require Import UniMath.CategoryTheory.ProductCategory. Require Import UniMath.CategoryTheory.limits.products. Require Import UniMath.CategoryTheory.limits.binproducts. Require Import UniMath.CategoryTheory.limits.terminal.Local Open Scope cat. Section def_FinOrdProducts. Variable C : category. Definition FinOrdProducts : UU := ∏ (n : nat) (a : stn n -> C), Product (stn n) C a. Definition hasFinOrdProducts : UU := ∏ (n : nat) (a : stn n -> C), ∥ Product (stn n) C a ∥.End def_FinOrdProducts.Section FinOrdProduct_criteria. Variable C : category. Lemma TerminalToProduct (T : Terminal C): ∏ (a : stn 0 -> C), Product (stn 0) C a. Proof. intros a. use (make_Product _ _ _ T (λ i : stn 0, fromempty (weqstn0toempty i))). use (make_isProduct _ _ C). intros c g. use unique_exists. apply (TerminalArrow _ c). intros i. apply (fromempty (weqstn0toempty i)). intros y. apply impred_isaprop. intros t. apply C. intros y X. apply TerminalArrowEq. Defined. Lemma identity_to_product: ∏ (a : stn 1 -> C), Product (stn 1) C a. Proof. intros a. set (stn1ob := invweq(weqstn1tounit) tt). use (make_Product _ _ _ (a stn1ob)). intros i. exact (idtoiso ((maponpaths a (isconnectedstn1 stn1ob i)))). use (make_isProduct _ _ C). intros c g. use (unique_exists). exact (g stn1ob). intros i. rewrite <- (isconnectedstn1 stn1ob i). apply id_right. intros y. apply impred_isaprop. intros t. apply C. intros y X. rewrite <- (X stn1ob). apply pathsinv0. apply id_right. Defined. Theorem FinOrdProducts_from_Terminal_and_BinProducts : Terminal C -> BinProducts C -> FinOrdProducts C. 
: Reflexive makeRefl. Proof. constructor. Qed. Global Instance Refl_makeTrans : Transitive R -> Transitive makeRefl. Proof. intro. intro. intros. inversion H0; clear H0; subst; auto. inversion H1; clear H1; subst; auto using RStep. apply RStep. etransitivity; eauto. Qed. Inductive makeTrans (x y : T) : Prop := | TStep : R x y -> makeTrans x y | TTrans : forall z, makeTrans x z -> makeTrans z y -> makeTrans x y. Global Instance Trans_makeTrans : Transitive makeTrans. Proof. intro. intros; eapply TTrans; eassumption. Qed. Global Instance Trans_makeRefl : Reflexive R -> Reflexive makeTrans. Proof. intro. intro. apply TStep. reflexivity. Qed. Inductive leftTrans (x y : T) : Prop := | LTFin : R x y -> leftTrans x y | LTStep : forall z, R x z -> leftTrans z y -> leftTrans x y. Inductive rightTrans (x y : T) : Prop := | RTFin : R x y -> rightTrans x y | RTStep : forall z, rightTrans x z -> R z y -> rightTrans x y. Fixpoint leftTrans_rightTrans_acc x y (l : leftTrans y x) : forall z, rightTrans z y -> rightTrans z x := match l with | LTFin pf => fun z pfR => RTStep pfR pf | LTStep _ pf pfL => fun z pfR => leftTrans_rightTrans_acc pfL (RTStep pfR pf) end. Fixpoint rightTrans_leftTrans_acc x y (l : rightTrans x y) : forall z, leftTrans y z -> leftTrans x z := match l with | RTFin pf => fun z pfR => LTStep pf pfR | RTStep _ pf pfL => fun z pfR => rightTrans_leftTrans_acc pf (LTStep pfL pfR) end. Theorem leftTrans_rightTrans : forall x y, leftTrans x y <-> rightTrans x y. Proof. split. { destruct 1. apply RTFin; assumption. eapply leftTrans_rightTrans_acc. eassumption. eapply RTFin. eassumption. } { destruct 1. apply LTFin. assumption. eapply rightTrans_leftTrans_acc. eassumption. eapply LTFin. eassumption. } Qed. Fixpoint leftTrans_makeTrans_acc x y (l : leftTrans x y) : makeTrans x y := match l with | LTFin pf => TStep pf | LTStep _ pf pfL => TTrans (TStep pf) (leftTrans_makeTrans_acc pfL) end. Fixpoint leftTrans_trans x y (l : leftTrans x y) : forall z (r : leftTrans y z), leftTrans x z := match l with | LTFin pf => fun _ pfL => LTStep pf pfL | LTStep _ pf pfL => fun _ pfR => LTStep pf (leftTrans_trans pfL pfR) end. Theorem makeTrans_leftTrans : forall s s', makeTrans s s' <-> leftTrans s s'. 
iDestruct (ghost_map_lookup with "Hlogheapctx [$]") as %Hlookup_obj0. iPureIntro. congruence. Qed. Lemma durable_mapsto_mapsto_txn_agree E γ a obj1 obj2 : ↑N ⊆ E → ↑invN ⊆ E → N ## invN → is_txn_system γ -∗ durable_mapsto γ a obj1 -∗ mapsto_txn γ.(jrnl_txn_names) a obj2 -∗ |NC={E}=> ⌜obj1 = obj2⌝ ∗ durable_mapsto γ a obj1 ∗ mapsto_txn γ.(jrnl_txn_names) a obj2. Proof. iIntros (???) "#Hinv Ha_i Ha". rewrite ncfupd_eq /ncfupd_def. iIntros. iApply (fupd_level_fupd _ _ _ O). iMod (durable_mapsto_mapsto_txn_agree' with "[$] [$] [$] [$]"); auto. Qed. Theorem is_jrnl_durable_not_in_map γ a obj γdurable P0 committed_mT : durable_mapsto γ a obj -∗ is_jrnl_durable γ γdurable P0 -∗ map_ctx γdurable (1 / 2) committed_mT -∗ ⌜committed_mT !! a = None⌝. Proof. iIntros "Ha Hdur Hctx". destruct (committed_mT !! a) eqn:He; try eauto. iNamed "Hdur". iDestruct (map_ctx_agree with "Hctx Hdurable_frag") as %->. iDestruct (big_sepM_lookup with "Hold_vals") as "Ha2"; eauto. iDestruct "Ha" as (i) "[Ha _]". iDestruct "Ha2" as (i2) "[Ha2 _]". iDestruct (ephemeral_val_from_conflict with "Ha Ha2") as "H". done. Qed. Theorem lift_into_txn' E l γ dinit γtxn γdurable committed_mT a obj : ↑N ⊆ E → ↑invN ⊆ E → N ## invN → "Hjrnl_mem" ∷ is_jrnl_mem l γ dinit γtxn γdurable -∗ "Hdurable_frag" ∷ map_ctx γdurable (1/2) committed_mT -∗ "Hdurable_maps_to" ∷ durable_mapsto_own γ a obj -∗ |NC={E}=> "Hjrnl_maps_to" ∷ jrnl_maps_to γtxn a obj ∗ "Hjrnl_mem" ∷ is_jrnl_mem l γ dinit γtxn γdurable ∗ "Hdurable_frag" ∷ map_ctx γdurable (1/2) (<[a:=obj]>committed_mT) ∗ "Hdurable_maps_to" ∷ durable_mapsto γ a obj ∗ "%Hnew" ∷ ⌜committed_mT !! a = None⌝. Proof. iIntros (HN HinvN HNdisj) "? ? [Ha Ha_i]". iNamed. iNamed "Hjrnl_mem". iDestruct "Ha" as (obj0) "Ha". iMod (durable_mapsto_mapsto_txn_agree with "[$] Ha_i Ha") as "(%Heq & Ha_i & Ha)"; [ solve_ndisj.. | subst obj0 ]. iDestruct (mspec.is_jrnl_not_in_map with "Hjrnl Ha") as %Hnotin. assert ((mspec.modified <$> mT) !! a = None). { rewrite lookup_fmap Hnotin //. } assert ((mspec.committed <$> mT) !! a = None). { rewrite lookup_fmap Hnotin //. } iMod (mspec.Op_lift_one _ _ _ _ _ _ E with "[$Ha $Hjrnl]") as "Hjrnl"; auto. iMod (map_alloc a obj with "Htxn_ctx") as "[Htxn_ctx Ha]"; eauto. iDestruct (map_ctx_agree with "Hdurable Hdurable_frag") as %<-. iCombine "Hdurable Hdurable_frag" as "Hdurable". iMod (map_alloc a obj with "Hdurable") as "[Hdurable _]"; eauto. iDestruct "Hdurable" as "[Hdurable Hdurable_frag]". iModIntro. iFrame "Ha". iSplitR "Hdurable_frag Ha_i". { iExists (<[a:=object_to_versioned obj]> mT), anydirty. iFrame "Htxn_system". rewrite !fmap_insert committed_to_versioned modified_to_versioned. iFrame. iPureIntro. destruct anydirty; intuition congruence. } iFrame "Hdurable_frag". iFrame "∗ %". Qed. Theorem lift_into_txn E l γ dinit γtxn P0 a obj : ↑N ⊆ E → ↑invN ⊆ E → N ## invN → is_jrnl l γ dinit γtxn P0 -∗ durable_mapsto_own γ a obj -∗ |NC={E}=> jrnl_maps_to γtxn a obj ∗ is_jrnl l γ dinit γtxn (λ mapsto, mapsto a obj ∗ P0 mapsto). 
Exp Γ τ') : ∀ {τ}, Ctxt Γ τ' τ → Exp Γ τ → Type := | Plug_Hole : Plug (C_Nil _) e | Plug_PairL {τ1 τ2} {C : Ctxt Γ τ' τ1} {e' : Exp Γ τ1} {e2 : Exp Γ τ2} : Plug C e' → Plug (C_Cons _ (F_PairL _ e2) C) (Pair e' e2) | Plug_PairR {τ1 τ2} {C : Ctxt Γ τ' τ2} {e1 : Exp Γ τ1} {e' : Exp Γ τ2} : ValueP e1 → Plug C e' → Plug (C_Cons _ (F_PairR _ e1) C) (Pair e1 e') | Plug_Fst {τ1 τ2} {C : Ctxt Γ τ' (τ1 × τ2)} {e' : Exp Γ (τ1 × τ2)} : Plug C e' → Plug (C_Cons _ (F_Fst _) C) (Fst e') | Plug_Snd {τ1 τ2} {C : Ctxt Γ τ' (τ1 × τ2)} {e' : Exp Γ (τ1 × τ2)} : Plug C e' → Plug (C_Cons _ (F_Snd _) C) (Snd e') | Plug_AppL {dom cod} {C : Ctxt Γ τ' (dom ⟶ cod)} {e' : Exp Γ (dom ⟶ cod)} {e2 : Exp Γ dom} : Plug C e' → Plug (C_Cons _ (F_AppL _ e2) C) (APP e' e2) | Plug_AppR {dom cod} {C : Ctxt Γ τ' dom} {e' : Exp Γ dom} {e1 : Exp Γ (dom ⟶ cod)} : ValueP e1 → Plug C e' → Plug (C_Cons _ (F_AppR _ e1) C) (APP e1 e').Derive Signature for Plug.Set Elimination Schemes.Scheme Plug_ind := Induction for Plug Sort Type.Definition Plug_id {Γ τ} {x : Exp Γ τ} : Plug x (C_Nil Γ) x := Plug_Hole _. Arguments Plug_id {_ _ _} /.Fixpoint Plug_comp {Γ τ τ' τ''} {x : Exp Γ τ''} {y : Exp Γ τ'} {z : Exp Γ τ} {C : Ctxt Γ τ' τ} {C' : Ctxt Γ τ'' τ'} (P : Plug x C' y) (P' : Plug y C z) : Plug x (Ctxt_comp C C') z := match P' with | Plug_Hole _ => P | Plug_PairL _ p' => Plug_PairL _ (Plug_comp P p') | Plug_PairR _ V p' => Plug_PairR _ V (Plug_comp P p') | Plug_Fst _ p' => Plug_Fst _ (Plug_comp P p') | Plug_Snd _ p' => Plug_Snd _ (Plug_comp P p') | Plug_AppL _ p' => Plug_AppL _ (Plug_comp P p') | Plug_AppR _ V p' => Plug_AppR _ V (Plug_comp P p') end. Theorem Plug_id_left {Γ τ τ'} {C : Ctxt Γ τ' τ} {x : Exp Γ τ'} {y : Exp Γ τ} (P : Plug x C y) : Plug_comp Plug_id P ~= P. 
Require Import List. Section Last. Variable A : Type. Set Implicit Arguments. Inductive last (a:A) : list A -> Prop := | last_hd : last a (a :: nil) | last_tl : forall (b:A) (l:list A), last a l -> last a (b :: l). #[local] Hint Constructors last : core. Fixpoint last_fun (l:list A) : option A := match l with | nil => None (A:=A) | a :: nil => Some a | a :: l' => last_fun l' end. Theorem last_fun_correct : forall (a:A) (l:list A), last a l -> last_fun l = Some a. 
simpl in |- *; auto; intros p H' H'1; left. case (pow_R1 _ _ H'1); auto. intros H'0; Contradict H'0; auto with zarith; apply convert_not_O. rewrite Rinv_pow in H'1; auto. case (pow_R1 _ _ H'1); auto. intros H'0. rewrite <- H'0. apply Rmult_eq_reg_l with (r := 1%R); auto with real. pattern 1%R at 1 in |- *; rewrite <- H'0; auto with real. pattern (Rabs (/ r)) at 1 in |- *; rewrite Rabs_Rinv; try rewrite Rinv_l; auto with real. rewrite H'0; auto with real. apply Rabs_no_R0; auto. intros H'0; Contradict H'0; auto with zarith; apply convert_not_O. Qed. Theorem Rpow_eq_inv : forall (r : R) (p q : Z), r <> 0%R -> Rabs r <> 1%R -> powerRZ r p = powerRZ r q -> p = q. intros r p q H' H'0 H'1. cut (powerRZ r (p - q) = 1%R); [ intros Eq0 | idtac ]. case (Rpow_R1 _ _ H' Eq0); auto with zarith. intros H'2; case H'0; auto. apply Rmult_eq_reg_l with (r := powerRZ r q); auto with real. rewrite <- powerRZ_add; auto. replace (q + (p - q))%Z with p; auto with zarith. rewrite <- H'1; rewrite Rmult_1_r; auto with arith. Qed. Theorem Zpower_nat_powerRZ_absolu : forall n m : Z, (0 <= m)%Z -> IZR (Zpower_nat n (Zabs_nat m)) = powerRZ (IZR n) m. intros n m; case m; simpl in |- *; auto with zarith. intros p H'; elim (nat_of_P p); simpl in |- *; auto with zarith. intros n0 H'0; rewrite <- H'0; simpl in |- *; auto with zarith. rewrite <- Rmult_IZR; auto. intros p H'; Contradict H'; auto with zarith. Qed. Theorem powerRZ_R1 : forall n : Z, powerRZ 1 n = 1%R. intros n; case n; simpl in |- *; auto. intros p; elim (nat_of_P p); simpl in |- *; auto; intros n0 H'; rewrite H'; ring. intros p; elim (nat_of_P p); simpl in |- *. exact Rinv_1. intros n1 H'; rewrite Rinv_mult_distr; try rewrite Rinv_1; try rewrite H'; auto with real. Qed. Theorem Rle_powerRZ : forall (e : R) (n m : Z), (1 <= e)%R -> (n <= m)%Z -> (powerRZ e n <= powerRZ e m)%R. intros e n m H' H'0. case H'; intros E1. case (Zle_lt_or_eq _ _ H'0); intros E2. apply Rlt_le; auto with real. rewrite <- E2; auto with real. repeat rewrite <- E1; repeat rewrite powerRZ_R1; auto with real. Qed. Theorem Zlt_powerRZ : forall (e : R) (n m : Z), (1 <= e)%R -> (powerRZ e n < powerRZ e m)%R -> (n < m)%Z. 
MAP. Definition elt := X.t. Definition elt_eq := X.eq. Definition t (A: Type) := X.t -> A. Definition init (A: Type) (v: A) := fun (_: X.t) => v. Definition get (A: Type) (x: X.t) (m: t A) := m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. 
- b) * (b + a - b) = (b + a) * (b + a) + b * b - 2 * ((b + a) * b). intros a b; rewrite minus_plus. repeat rewrite mult_plus_distr_r || rewrite <- (mult_comm (b + a)). replace (b * b + a * b + (b * a + a * a) + b * b) with (b * b + a * b + (b * b + a * b + a * a)); try (ring; fail). rewrite expand_mult2; repeat rewrite minus_plus; auto with *. Qed. Theorem sub_square_identity : forall a b : nat, b <= a -> (a - b) * (a - b) = a * a + b * b - 2 * (a * b). intros a b H; rewrite (le_plus_minus b a H); apply add_sub_square_identity. Qed. Theorem square_monotonic : forall x y : nat, x < y -> x * x < y * y. intros x; case x. intros y; case y; simpl in |- *; auto with *. intros x' y Hlt; apply lt_trans with (S x' * y). rewrite (mult_comm (S x') y); apply mult_lt; auto. apply mult_lt; omega. Qed. Theorem root_monotonic : forall x y : nat, x * x < y * y -> x < y. exact (monotonic_inverse (fun x : nat => x * x) square_monotonic). Qed. Remark square_recompose : forall x y : nat, x * y * (x * y) = x * x * (y * y). intros; ring. Qed. Remark mult2_recompose : forall x y : nat, x * (2 * y) = x * 2 * y. intros; ring. Qed. Section sqrt2_decrease. Variables (p q : nat) (pos_q : 0 < q) (hyp_sqrt : p * p = 2 * (q * q)). Theorem sqrt_q_non_zero : 0 <> q * q. generalize pos_q; case q. intros H; elim (lt_n_O 0); auto. intros n H. simpl in |- *; discriminate. Qed. Hint Resolve sqrt_q_non_zero. Ltac solve_comparison := apply root_monotonic; repeat rewrite square_recompose; rewrite hyp_sqrt; rewrite mult2_recompose; apply mult_lt; auto with arith. Theorem comparison1 : q < p. replace q with (1 * q); try ring. replace p with (1 * p); try ring. solve_comparison. Qed. Theorem comparison2 : 2 * p < 3 * q. solve_comparison. Qed. Theorem comparison3 : 4 * q < 3 * p. solve_comparison. Qed. Hint Resolve comparison1 comparison2 comparison3: arith. Theorem comparison4 : 3 * q - 2 * p < q. 
transpose l l' -> transpose (a :: l) (a :: l') . Inductive perm (l : list A) : list A -> Prop := perm_id: perm l l | perm_tr: forall (l' l'' : list A), perm l l' -> transpose l' l'' -> perm l l'' . Variable A_eq_dec : forall a b:A, {a = b} + {a <> b}. Fixpoint nb_occ (a : A) (l : list A) : nat := match l with | nil => 0 | x :: l' => match A_eq_dec a x with | left _ => S (nb_occ a l') | right _ => nb_occ a l' end end. Lemma transpose_nb_occ: forall (l l' : list A), transpose l l' -> forall (a : A), nb_occ a l = nb_occ a l'. Proof. intros l l' H; elim H; simpl. - intros a b l0 x; case (A_eq_dec x a); case (A_eq_dec x b); simpl; auto. - intros a l0 l'0 H0 H1 x; case (A_eq_dec x a); simpl; auto. Qed. Lemma perm_nb_occ: forall (l l' : list A), perm l l' -> forall (a : A), nb_occ a l = nb_occ a l'. Proof. intros l l' H; elim H; auto. intros l'0; intros; transitivity (nb_occ a l'0);auto. apply transpose_nb_occ; auto. Qed. Fixpoint check_all_occs (l1 l2 l3 : list A) : bool := match l3 with nil => true | a :: tl => if Nat.eqb (nb_occ a l1) (nb_occ a l2) then check_all_occs l1 l2 tl else false end. Theorem eq_nat_bool_false: forall n1 n2, Nat.eqb n1 n2 = false -> n1 <> n2. Proof. induction n1; destruct n2; simpl; intros; discriminate || auto. Qed. Theorem check_all_occs_false: forall l1 l2 l3, check_all_occs l1 l2 l3 = false -> (exists a : A , nb_occ a l1 <> nb_occ a l2 ). Proof. simple induction l3. - simpl; intros; discriminate. - intros n l IHl; simpl. generalize (@eq_nat_bool_false (nb_occ n l1) (nb_occ n l2)). case (Nat.eqb (nb_occ n l1) (nb_occ n l2)). + auto. + intros; exists n; auto. Qed. Theorem check_all_occs_not_perm: forall l1 l2, check_all_occs l1 l2 l1 = false -> ~ perm l1 l2. Proof. intros l1 l2 Heq Hperm; elim (check_all_occs_false l1 l2 l1 Heq); intros n Hneq; elim Hneq; apply perm_nb_occ; assumption. Qed. End perms.Arguments perm {A} _ _.Ltac noperm eqdec := match goal with | |- ~ perm ?l1 ?l2 => apply (check_all_occs_not_perm eqdec) end.Require Import Peano_dec. Theorem not_perm2: ~ perm (1 :: (3 :: (2 :: nil))) (3 :: (1 :: (1 :: (4 :: (2 :: nil))))). 
ulp_le : forall { Hm : Monotone_exp fexp }, forall x y: R, (Rabs x <= Rabs y)%R -> (ulp x <= ulp y)%R. Proof. intros Hm x y Hxy. rewrite <- ulp_abs. rewrite <- (ulp_abs y). apply ulp_le_pos; trivial. apply Rabs_pos. Qed.Definition pred_pos x := if Req_bool x (bpow (ln_beta beta x - 1)) then (x - bpow (fexp (ln_beta beta x - 1)))%R else (x - ulp x)%R.Definition succ x := if (Rle_bool 0 x) then (x+ulp x)%R else (- pred_pos (-x))%R.Definition pred x := (- succ (-x))%R.Theorem pred_eq_pos: forall x, (0 <= x)%R -> (pred x = pred_pos x)%R. Proof. intros x Hx; unfold pred, succ. case Rle_bool_spec; intros Hx'. assert (K:(x = 0)%R). apply Rle_antisym; try assumption. apply Ropp_le_cancel. now rewrite Ropp_0. rewrite K; unfold pred_pos. rewrite Req_bool_false. 2: apply Rlt_not_eq, bpow_gt_0. rewrite Ropp_0; ring. now rewrite 2!Ropp_involutive. Qed.Theorem succ_eq_pos: forall x, (0 <= x)%R -> (succ x = x + ulp x)%R. Proof. intros x Hx; unfold succ. now rewrite Rle_bool_true. Qed.Lemma pred_eq_opp_succ_opp: forall x, pred x = (- succ (-x))%R. Proof. reflexivity. Qed.Lemma succ_eq_opp_pred_opp: forall x, succ x = (- pred (-x))%R. Proof. intros x; unfold pred. now rewrite 2!Ropp_involutive. Qed.Lemma succ_opp: forall x, (succ (-x) = - pred x)%R. Proof. intros x; rewrite succ_eq_opp_pred_opp. now rewrite Ropp_involutive. Qed.Lemma pred_opp: forall x, (pred (-x) = - succ x)%R. Proof. intros x; rewrite pred_eq_opp_succ_opp. now rewrite Ropp_involutive. Qed. Theorem id_m_ulp_ge_bpow : forall x e, F x -> x <> ulp x -> (bpow e < x)%R -> (bpow e <= x - ulp x)%R. Proof. intros x e Fx Hx' Hx.assert (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z. assert (0 < Ztrunc (scaled_mantissa beta fexp x))%Z. apply F2R_gt_0_reg with beta (canonic_exp beta fexp x). rewrite <- Fx. apply Rle_lt_trans with (2:=Hx). apply bpow_ge_0. omega. case (Zle_lt_or_eq _ _ H); intros Hm.pattern x at 1 ; rewrite Fx. rewrite ulp_neq_0. unfold F2R. simpl. pattern (bpow (canonic_exp beta fexp x)) at 2 ; rewrite <- Rmult_1_l. rewrite <- Rmult_minus_distr_r. change 1%R with (Z2R 1). rewrite <- Z2R_minus. change (bpow e <= F2R (Float beta (Ztrunc (scaled_mantissa beta fexp x) - 1) (canonic_exp beta fexp x)))%R. apply bpow_le_F2R_m1; trivial. now rewrite <- Fx. apply Rgt_not_eq, Rlt_gt. apply Rlt_trans with (2:=Hx), bpow_gt_0.contradict Hx'. pattern x at 1; rewrite Fx. rewrite <- Hm. rewrite ulp_neq_0. unfold F2R; simpl. now rewrite Rmult_1_l. apply Rgt_not_eq, Rlt_gt. apply Rlt_trans with (2:=Hx), bpow_gt_0. Qed. Theorem id_p_ulp_le_bpow : forall x e, (0 < x)%R -> F x -> (x < bpow e)%R -> (x + ulp x <= bpow e)%R. 
mult_minus_lemma2;trivial. Qed. Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}. apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)). unfold ltof. unfold f. intros. case (lt_eq_lt_dec (fst x) (snd x));intro. case s;intro. destruct (fst x). right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero. elim (H (S n,snd x-S n));try (intro;simpl). elim a;intro y;intro. left;exists ((fst y)+(snd y),(snd y)). simpl;apply bezout_aux1;try (auto with arith). elim b;intro y;intro. right;exists ((fst y)+(snd y),(snd y)). simpl;apply bezout_aux2;try (auto with arith). simpl;omega. rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl. destruct (snd x). left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero. elim (H (S n,fst x-S n));try (intro;simpl). elim a;intro y;intro. right;exists ((snd y),(fst y)+(snd y));apply gcd_sym. simpl;apply bezout_aux1;try (auto with arith). elim b;intro y;intro. left;exists ((snd y),(fst y)+(snd y));apply gcd_sym. simpl;apply bezout_aux2;try (auto with arith). simpl;omega. Qed. Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}. intros. elim (bezout_exists_prod (a,b));intro. elim a0;destruct x;simpl;intros. left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial. elim b0;destruct x;simpl;intros. right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial. Qed. Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \/ d=b*v-a*u. intros. elim (bezout_exists a b);intro. elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial. elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial. Qed. Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \/ 1 = b*v-a*u). intros. unfold rel_prime. split;intro. apply bezout;trivial. elim H;intro u;intro H0. elim H0;intro v;intro. unfold is_gcd;unfold is_cd. split. split;apply one_min_div. intros. elim H2;intros. elim H3;intro q;intro. elim H4;intro q';intro. rewrite H5 in H1;rewrite H6 in H1. case H1;intro. exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial. exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial. Qed. Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))). unfold is_gcd;unfold is_cd. intros. elim H;intros. elim H0;intros. split. elim H2;intro q;intro. elim H3;intro q';intro. rewrite H4;rewrite mult_assoc. rewrite H5;rewrite mult_assoc. split;[exists q;trivial | exists q';trivial]. intros. elim H4;intros. elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial). intro u;intro. elim H7;intro v;intro. elim H5;intro q;intro. elim H6;intro q';intro. case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial. Qed. Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d). 
<-> exists y: A, S y. Proof. move=> A S; split. - by case=> x Hs; exists x. by case=>y Hs; apply: my_ex_intro Hs. Qed. Theorem dist_exists_or (X : Type) (P Q : X -> Prop): (exists x, P x \/ Q x) <-> (exists x, P x) \/ (exists x, Q x). Proof. split; first by case=>x; case=>H; [left | right]; exists x=> //. by case; case=>x H; exists x; [left | right]. Qed.Theorem two_is_three A: (exists x : A, (forall R : A -> Prop, R x)) -> 2 = 3. Proof. by case=>x H; apply: H. Qed.Definition dys_imp (P Q: Prop) := (P -> Q) -> (Q -> P). Definition dys_contrap (P Q: Prop) := (P -> Q) -> (~P -> ~Q).Theorem di_false: (forall P Q: Prop, dys_imp P Q) -> False. Proof. by move/(_ _ True); apply. Qed.Theorem dc_false: (forall P Q: Prop, dys_contrap P Q) -> False. Proof. by move=>H; apply: (H False True)=>//. Qed.Theorem excluded_middle_irrefutable: forall (P : Prop), ~~(P \/ ~ P). Proof. move=>P H. apply: (H); right=>p. by apply: H; left. Qed.Definition peirce := peirce_law. Definition double_neg := forall P: Prop, ~ ~ P -> P. Definition excluded_middle := forall P: Prop, P \/ ~P. Definition de_morgan_not_and_not := forall P Q: Prop, ~ ( ~P /\ ~Q) -> P \/ Q. Definition implies_to_or := forall P Q: Prop, (P -> Q) -> (~P \/ Q).Lemma peirce_dn: peirce -> double_neg. Proof. by move=>H P Hn; apply: (H _ False)=> /Hn. Qed.Lemma dn_em : double_neg -> excluded_middle. Proof. rewrite /double_neg /excluded_middle=> Dn P. apply: (Dn (P \/ ~ P))=>H1; apply: (H1). by left; apply: (Dn)=> H2; apply: H1; right. Qed.Lemma em_dmnan: excluded_middle -> de_morgan_not_and_not. Proof. rewrite /excluded_middle /de_morgan_not_and_not=> H1 P Q H2. suff: ~P -> Q. - move=>H3. move: (H1 P); case=>//X; first by left. by right; apply: H3. move=> Pn. move: (H1 Q); case=>// Qn. suff: False=>//; apply: H2; split=>//. Qed.Lemma dmnan_ito : de_morgan_not_and_not -> implies_to_or. Proof. rewrite /de_morgan_not_and_not /implies_to_or=> H1 P Q Hi. suff: ~P \/ P. case=>//; first by left. - by move/ Hi; right. move: (H1 (~P) P)=> H2; apply: H2; case=> Hp p. suff: (P -> False) \/ False by case=>//. by apply: H1; case. Qed.Lemma ito_peirce : implies_to_or -> peirce. Proof. rewrite /peirce /peirce_law /implies_to_or=> H1 P Q H2. have X: P -> P by []. move: (H1 P P) =>/(_ X); case=>{X}// Pn. by apply: (H2)=>p. Qed. Theorem not_forall_exists A (P : A -> Prop): (forall x: A, P x) -> ~(exists y: A, ~ P y). 
Require Setoid. Require Import PeanoNat Le Gt Minus Bool Lt.Set Implicit Arguments. Open Scope list_scope. Module ListNotations. Notation "[ ]" := nil (format "[ ]") : list_scope. Notation "[ x ]" := (cons x nil) : list_scope. Notation "[ x ; y ; .. ; z ]" := (cons x (cons y .. (cons z nil) ..)) : list_scope. End ListNotations.Import ListNotations.Section Lists. Variable A : Type. Definition hd (default:A) (l:list A) := match l with | [] => default | x :: _ => x end. Definition hd_error (l:list A) := match l with | [] => None | x :: _ => Some x end. Definition tl (l:list A) := match l with | [] => nil | a :: m => m end. Fixpoint In (a:A) (l:list A) : Prop := match l with | [] => False | b :: m => b = a \/ In a m end.End Lists.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), [] <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = []}. 
apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply div_is_T1; auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_multTerm_r; auto. Qed. Theorem divTerm_multTermr : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) b. intros a b nZa nZb. apply divTerm_def with (nZb := nZb); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) a (divTerm b nZb)) b); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_multTerm_l; auto. Qed. Hint Resolve divTerm_multTermr divTerm_multTerml. Theorem divP_trans : transitive (Term A n) divP. red in |- *; intros a b c H' H'0. cut (~ zeroP (A:=A) A0 eqA (n:=n) c); [ intros nZc | auto ]. apply divTerm_def with (nZb := nZc); auto. apply divP_inv1 with (b := b); auto. 2: apply divP_inv2 with (a := b); auto. cut (~ zeroP (A:=A) A0 eqA (n:=n) b); [ intros nZb | auto ]. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) (divTerm a nZb) (divTerm b nZc)) c); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a nZb) (multTerm (A:=A) multA (n:=n) (divTerm b nZc) c)); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a nZb) b); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. inversion H'0; inversion H'. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := divTerm (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b) nZc); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_multTerm_l; auto. apply eqTerm_divTerm_comp; auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (1 := H4); auto. apply divP_inv2 with (a := a); auto. Qed. Hint Resolve divP_trans. Theorem divP_nZero : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b), divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). 
rewrite gf. rewrite H2; rewrite H3. repeat rewrite fg; split; auto. revert H0; case_eq (age1 (g z)); intros; try discriminate. inv H1. rename a into gz'. red in H. rewrite gf in *. destruct (unage_join2 _ H H0) as [gx' [gy' [? [? ?]]]]. exists (f gx'); exists (f gy'). split. red. repeat rewrite gf; auto. repeat rewrite gf. rewrite H2; rewrite H3. repeat rewrite fg; split; auto. rewrite gf. destruct (age1 (g x)) eqn: Hage; [|discriminate]. inv H. apply age_core in Hage; rewrite Hage. rewrite gf; reflexivity. Qed. End BIJECTION.Section PROD. Variable A : Type. Variable J_A: Join A. Variable saA : Perm_alg A. Variable SA : Sep_alg A. Variable agA : ageable A. Variable B: Type. Variable J_B: Join B. Variable saB : Perm_alg B. Variable SB : Sep_alg B. Variable asa : Age_alg A. Theorem asa_prod : @Age_alg (prod A B) _ (ag_prod A B agA) (Sep_prod SA SB). Proof. constructor; unfold age; simpl; unfold Join_prod. intros [xa xb] [ya yb] [za zb] [xa' xb'] [? ?]. simpl in *. case_eq (age1 xa); intros; inv H2. destruct (age1_join _ H H1) as [ya' [za' [? [? ?]]]]. exists (ya',yb); exists (za',zb); rewrite H3; rewrite H4; repeat split; auto. intros [xa xb] [ya yb] [za zb] [za' zb'] [? ?]. simpl in *. case_eq (age1 za); intros; inv H2. destruct (age1_join2 _ H H1) as [xa' [ya' [? [? ?]]]]. exists (xa',xb); exists (ya',yb); rewrite H3; rewrite H4; repeat split; auto. intros [xa xb] [xa' xb'] [ya' yb'] [za' zb'] [? ?]. simpl in *. case_eq (age1 xa); intros; inv H2. destruct (unage_join _ H H1) as [ya [za [? [? ?]]]]. exists (ya,yb'); exists (za,zb'); simpl. rewrite H3; rewrite H4; repeat split; auto. intros [za zb] [xa' xb'] [ya' yb'] [za' zb'] [? ?]. simpl in *. case_eq (age1 za); intros; inv H2. destruct (unage_join2 _ H H1) as [xa [ya [? [? ?]]]]. exists (xa,xb'); exists (ya,yb'); simpl. rewrite H3; rewrite H4; repeat split; auto. intros (?, ?) ?; simpl. destruct (age1 a) eqn: Hage; [|discriminate]. intros X; inv X. apply age_core in Hage; rewrite Hage. reflexivity. Qed. End PROD.Section PROD'. Variable A : Type. Variable J_A: Join A. Variable saA : Perm_alg A. Variable SA : Sep_alg A. Variable B: Type. Variable J_B: Join B. Variable saB : Perm_alg B. Variable SB : Sep_alg B. Variable agB : ageable B. Variable asb : Age_alg B. Theorem asa_prod' : @Age_alg (prod A B) _ (ag_prod' A B agB) (Sep_prod SA SB). 
args_ofs (Ptrofs.mul (Ptrofs.repr int_size) (Ptrofs.repr i)))) Writable)%Z /\ M.get tinfIdent lenv = Some (Vptr tinf_b tinf_ofs) /\ tinf_b <> args_b /\ tinf_b <> alloc_b /\ (forall i, 0 <= i < 4 -> Mem.valid_access m int_chunk tinf_b (Ptrofs.unsigned (Ptrofs.add tinf_ofs (Ptrofs.repr (int_size*i)))) Writable)%Z /\ deref_loc (Tarray uval maxArgs noattr) m tinf_b (Ptrofs.add tinf_ofs (Ptrofs.repr (int_size*3))) (Vptr args_b args_ofs) /\ (forall x b, Genv.find_symbol (globalenv p) x = Some b -> b <> args_b /\ b <> alloc_b /\ b <> tinf_b /\ (exists chunk, Mem.valid_access m chunk b 0%Z Nonempty)). Theorem range_perm_to_valid_access: forall alloc_b alloc_ofs limit_ofs size m, Mem.range_perm m alloc_b alloc_ofs limit_ofs Cur Writable -> forall ofs, (align_chunk size | ofs)%Z -> (alloc_ofs <= ofs)%Z -> (ofs + size_chunk size <= limit_ofs)%Z -> Mem.valid_access m size alloc_b ofs Writable. Proof. intros. constructor; auto. intro. intro. eapply H. omega. Qed. Theorem correct_tinfo_mono: forall p z lenv m, correct_tinfo p z lenv m -> forall z', (0 <= z' <= z)%Z -> correct_tinfo p z' lenv m. Proof. intros. inv H; destructAll. do 7 eexists. repeat (split; eauto). unfold int_size in *. chunk_red; omega. Qed. Theorem correct_tinfo_proper: forall p z lenv m lenv', correct_tinfo p z lenv m -> map_get_r_l _ [argsIdent; limitIdent; allocIdent; tinfIdent] lenv lenv' -> correct_tinfo p z lenv' m. Proof. intros. inv H; destructAll. exists x, x0, x1, x2, x3, x4, x5. repeat (split; auto; try (rewrite <- H0; auto; inList)). Qed. Theorem correct_tinfo_not_protected: forall p z lenv m, correct_tinfo p z lenv m -> forall x v, ~ is_protected_tinfo_id_thm x -> x <> tinfIdent -> correct_tinfo p z (M.set x v lenv) m. Proof. intros. destruct H as [alloc_b [alloc_ofs [limit_ofs [args_b [args_ofs [tinf_b [tinf_ofs H]]]]]]]. exists alloc_b, alloc_ofs, limit_ofs, args_b, args_ofs, tinf_b, tinf_ofs. destructAll. repeat (split; auto). rewrite M.gso; auto. intro. apply H0. left; auto. rewrite M.gso; auto. intro. apply H0. right; auto. rewrite M.gso; auto. intro. apply H0. right; auto. rewrite M.gso; auto. Qed. Theorem correct_tinfo_param_asgn: forall p lenv m xs z vs7 lenv', correct_tinfo p z lenv m -> lenv_param_asgn lenv lenv' xs vs7 -> (forall x, List.In x xs -> ~ (is_protected_tinfo_id_thm x \/ x = tinfIdent)) -> correct_tinfo p z lenv' m. Proof. intros. destruct H. destructAll. exists x, x0, x1, x2, x3, x4, x5. repeat (split; auto; try (eapply lenv_param_asgn_not_in with (L := fun x => (is_protected_tinfo_id_thm x \/ x = tinfIdent)); eauto; try (left; inList); try (right; reflexivity))). Qed. Theorem mem_range_valid: forall m m', (forall b ofs ofs' p, Mem.range_perm m b ofs ofs' Cur p -> Mem.range_perm m' b ofs ofs' Cur p) <-> (forall b ofs chunk p, Mem.valid_access m chunk b ofs p -> Mem.valid_access m' chunk b ofs p). 
assumption. intros q'2. generalize Hle2; case n'. generalize Heqd1 Heqd2; case p'; case q'. simpl in |- *; intros H'1 H'2 H'3 H'4; discriminate H'4. intros x; rewrite <- (mult_comm 0); simpl in |- *; intros Dummy; discriminate Dummy. simpl in |- *; intros x H'1 H'2 H'3 H'4; discriminate H'4. simpl in |- *; intros n n1 H'1 H'2; rewrite <- plus_n_Sm; intros H'3; inversion H'3. inversion H1. intros n''. intros Hle3 Heq4. simpl in |- *. CaseEq p'. intros Heqp'; generalize Heqd1; rewrite Heqp'. rewrite <- (mult_comm 0); simpl in |- *; intros Dummy; discriminate Dummy. intros p'2 Heqp'2. change (dL (Qpositive_c (S p) (S q2) (S n0)) = dL (Qpositive_c (S p'2) (S q'2) (S n''))) in |- *. apply f_equal with (f := dL). apply Hrec with d; auto with *. rewrite <- Heqp'2; assumption. rewrite <- Heq4; rewrite <- Heq2; rewrite (mult_comm (S d)). rewrite mult_minus_distr_r. repeat rewrite <- (mult_comm (S d)). rewrite <- Heqd2; rewrite <- Heqd1. simpl in |- *; auto. apply mult_S_le_reg_l with d. rewrite <- Heqd2; rewrite <- Heqd1. apply le_n_S. apply minus_O_le; assumption. intros p2 Heqp2. CaseEq (p' - q'). intros Heqm'; cut (S p - S q = 0). simpl in |- *; rewrite Heqp2; intros Dummy; discriminate Dummy. rewrite Heqd2; rewrite Heqd1. repeat rewrite (mult_comm (S d)). rewrite <- mult_minus_distr_r. rewrite Heqm'; simpl in |- *; auto. intros p'2. generalize Hle2; case n'. generalize Heqd1 Heqd2; case p'; case q'. simpl in |- *; intros H'1 H'2 H'3 H'4; discriminate H'4. intros x; rewrite <- (mult_comm 0); simpl in |- *; intros Dummy; discriminate Dummy. intros x; rewrite <- (mult_comm 0); simpl in |- *; intros Dummy1 Dummy2; discriminate Dummy2. simpl in |- *; intros n n1 H'1 H'2; rewrite <- plus_n_Sm; intros H'3; inversion H'3. inversion H0. intros n''. intros Hle3 Heq4. CaseEq q'. intros Heq5; generalize Heqd2; rewrite Heq5; simpl in |- *. rewrite <- (mult_comm 0); simpl in |- *; intros Dummy; discriminate Dummy. intros q'2 Heqq'2. change (nR (Qpositive_c (S p2) (S q) (S n0)) = nR (Qpositive_c (S p'2) (S q'2) (S n''))) in |- *. apply f_equal with (f := nR). apply Hrec with d; auto with *. rewrite <- Heq4; rewrite <- Heqp2; rewrite (mult_comm (S d)). rewrite mult_minus_distr_r. repeat rewrite <- (mult_comm (S d)). rewrite <- Heqd2; rewrite <- Heqd1. simpl in |- *; auto. rewrite <- Heqq'2; assumption. Qed. Theorem construct_correct4 : forall p q p' q' n n' : nat, S p + S q <= S n -> S p' + S q' <= S n' -> S p * S q' = S p' * S q -> Qpositive_c (S p) (S q) (S n) = Qpositive_c (S p') (S q') (S n'). 
intro Heq; subst; auto. rewrite singles_cons; auto. Qed.Theorem all_binds_dec : forall A (E F : gen_env A), ok E -> (forall w w' : A, { w = w' } + { ¬ w = w' }) -> {E ⊏ F} + {¬ E ⊏ F}. Proof. assert (forall A, (forall w w' : A, { w = w' } + { ¬ w = w' }) -> forall ws ws' : list A, { ws = ws' } + { ¬ ws = ws' }) as Hdec. intros A Hyp. induction ws as [ | w ws IHws ]; induction ws' as [ | w' ws' IHws' ]; simpl in *; auto. right; intro Heq; inversion Heq. right; intro Heq; inversion Heq. destruct (Hyp w w'); destruct (IHws ws'). left; subst; auto. right; intro Heq; inversion Heq; auto. right; intro Heq; inversion Heq; auto. right; intro Heq; inversion Heq; auto. intros A E F Hok Hdec2. assert (forall ws ws' : list A, { ws = ws' } + { ¬ ws = ws' }) as Hdec3 by auto. assert (List.NoDup (dom E)) as Hdom by (apply ok_dom_inv; auto). elim all_binds_dec_exists with A (dom E) F; auto; intro Hyp. destruct Hyp as [ vs [ Hlen Habind ] ]. elim (Hdec3 vs (img E)); intro Hyp; subst. left. rewrite dom_img_id in *; auto. right. intro Habind2. rewrite <- (dom_img_id E) in Habind2. assert (vs = img E). apply all_binds_singles_eq_inv with (dom E) F; auto. apply length_dom_img_eq. auto. right. intro Habind. apply (Hyp (img E)). apply length_dom_img_eq. rewrite dom_img_id; auto. Qed.Theorem eq_refl : forall A (E F : gen_env A), E = F -> E ≍ F. Proof. unfold eq. intro. split; apply all_binds_refl; auto. Qed.Theorem eq_sym : forall A (E F : gen_env A), E ≍ F -> F ≍ E. Proof. unfold eq; intros A E F Heq; destruct Heq; split; auto. Qed.Theorem eq_trans : forall A (E F G : gen_env A), E ≍ F -> F ≍ G -> E ≍ G. Proof. unfold eq; intros A E F G Heq1 Heq2. destruct Heq1, Heq2. split; apply all_binds_trans with F; auto. Qed. Theorem eq_binds : forall A x (v : A) (E F : gen_env A), E ≍ F -> binds x v E -> binds x v F. Proof. intros A x v E F Heq Hbind. unfold eq in *. destruct Heq. auto. Qed. Theorem eq_concat : forall A (E F G : gen_env A), E ≍ F -> (E & G) ≍ (F & G). 
false \/ is_nan _ _ y = false -> add x y = add y x. Proof. intros. apply Bplus_commut. destruct x, y; try reflexivity; now destruct H. Qed.Theorem mul_commut: forall x y, is_nan _ _ x = false \/ is_nan _ _ y = false -> mul x y = mul y x. Proof. intros. apply Bmult_commut. destruct x, y; try reflexivity; now destruct H. Qed.Theorem mul2_add: forall f, add f f = mul f (of_int (Int.repr 2%Z)). Proof. intros. apply Bmult2_Bplus. intros x y Hx Hy. unfold binop_nan. destruct x; try discriminate. simpl. rewrite Archi.choose_nan_64_idem. destruct y; reflexivity || discriminate. Qed.Definition exact_inverse : float -> option float := Bexact_inverse 53 1024 __ __.Theorem div_mul_inverse: forall x y z, exact_inverse y = Some z -> div x y = mul x z. Proof. intros. apply Bdiv_mult_inverse. 2: easy. intros x0 y0 z0 Hx Hy Hz. unfold binop_nan. destruct x0; try discriminate. destruct y0, z0; reflexivity || discriminate. Qed.Theorem cmp_swap: forall c x y, cmp (swap_comparison c) x y = cmp c y x. Proof. unfold cmp, compare; intros. rewrite (Bcompare_swap _ _ x y). apply cmp_of_comparison_swap. Qed.Theorem cmp_ne_eq: forall f1 f2, cmp Cne f1 f2 = negb (cmp Ceq f1 f2). Proof. intros; apply cmp_of_comparison_ne_eq. Qed.Theorem cmp_lt_eq_false: forall f1 f2, cmp Clt f1 f2 = true -> cmp Ceq f1 f2 = true -> False. Proof. intros f1 f2; apply cmp_of_comparison_lt_eq_false. Qed.Theorem cmp_le_lt_eq: forall f1 f2, cmp Cle f1 f2 = cmp Clt f1 f2 || cmp Ceq f1 f2. Proof. intros f1 f2; apply cmp_of_comparison_le_lt_eq. Qed.Theorem cmp_gt_eq_false: forall x y, cmp Cgt x y = true -> cmp Ceq x y = true -> False. Proof. intros f1 f2; apply cmp_of_comparison_gt_eq_false. Qed.Theorem cmp_ge_gt_eq: forall f1 f2, cmp Cge f1 f2 = cmp Cgt f1 f2 || cmp Ceq f1 f2. Proof. intros f1 f2; apply cmp_of_comparison_ge_gt_eq. Qed.Theorem cmp_lt_gt_false: forall f1 f2, cmp Clt f1 f2 = true -> cmp Cgt f1 f2 = true -> False. Proof. intros f1 f2; apply cmp_of_comparison_lt_gt_false. Qed.Theorem of_to_bits: forall f, of_bits (to_bits f) = f. Proof. intros; unfold of_bits, to_bits, bits_of_b64, b64_of_bits. rewrite Int64.unsigned_repr, binary_float_of_bits_of_binary_float; [reflexivity|]. generalize (bits_of_binary_float_range 52 11 __ __ f). change (2^(52+11+1)) with (Int64.max_unsigned + 1). lia. Qed.Theorem to_of_bits: forall b, to_bits (of_bits b) = b. Proof. intros; unfold of_bits, to_bits, bits_of_b64, b64_of_bits. rewrite bits_of_binary_float_of_bits. apply Int64.repr_unsigned. apply Int64.unsigned_range. Qed.Definition ox8000_0000 := Int.repr Int.half_modulus. Definition ox7FFF_FFFF := Int.repr Int.max_signed. Theorem of_intu_of_int_1: forall x, Int.ltu x ox8000_0000 = true -> of_intu x = of_int x. 
Require Import Verdi.GhostSimulations.Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.CommonTheorems.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.LeadersHaveLeaderLogsStrongInterface. Require Import VerdiRaft.SortedInterface. Require Import VerdiRaft.LogMatchingInterface. Require Import VerdiRaft.AppendEntriesRequestLeaderLogsInterface. Require Import VerdiRaft.NextIndexSafetyInterface.Section AppendEntriesRequestLeaderLogs. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {lhllsi : leaders_have_leaderLogs_strong_interface}. Context {rri : raft_refinement_interface}. Context {si : sorted_interface}. Context {lmi : log_matching_interface}. Context {nisi : nextIndex_safety_interface}. Theorem lift_sorted : forall net, refined_raft_intermediate_reachable net -> logs_sorted (deghost net). 
n = mod2 k -> mod2 (S n) = mod2 (S k). Proof. intros. do 2 rewrite mod2_S_not. rewrite H. auto. Qed.Theorem drop_mod2_add : forall n k, mod2 (n + 2 * k) = mod2 n. Proof. intros. induction n. simpl. rewrite Nat.add_0_r. replace (k + k) with (2 * k) by omega. apply mod2_double. replace (S n + 2 * k) with (S (n + 2 * k)) by omega. apply mod2_S_eq; auto. Qed.Lemma mod2sub: forall a b, b <= a -> mod2 (a - b) = xorb (mod2 a) (mod2 b). Proof. intros. remember (a - b) as c. revert dependent b. revert a. revert c. change (forall c, (fun c => forall a b, b <= a -> c = a - b -> mod2 c = xorb (mod2 a) (mod2 b)) c). apply strong. intros c IH a b AB N. destruct c. - assert (a=b) by omega. subst. rewrite Bool.xorb_nilpotent. reflexivity. - destruct c. + assert (a = S b) by omega. subst a. simpl (mod2 1). rewrite mod2_S_not. destruct (mod2 b); reflexivity. + destruct a; [omega|]. destruct a; [omega|]. simpl. apply IH; omega. Qed.Theorem mod2_pow2_twice: forall n, mod2 (Nat.pow 2 n + (Nat.pow 2 n + 0)) = false. Proof. intros. replace (Nat.pow 2 n + (Nat.pow 2 n + 0)) with (2 * Nat.pow 2 n) by omega. apply mod2_double. Qed.Theorem div2_plus_2 : forall n k, Nat.div2 (n + 2 * k) = Nat.div2 n + k. Proof. induction n; intros. simpl. rewrite Nat.add_0_r. replace (k + k) with (2 * k) by omega. apply div2_double. replace (S n + 2 * k) with (S (n + 2 * k)) by omega. destruct (Even.even_or_odd n). - rewrite <- even_div2. rewrite <- even_div2 by auto. apply IHn. apply Even.even_even_plus; auto. apply Even.even_mult_l; repeat constructor. - rewrite <- odd_div2. rewrite <- odd_div2 by auto. rewrite IHn. omega. apply Even.odd_plus_l; auto. apply Even.even_mult_l; repeat constructor. Qed.Lemma pred_add: forall n, n <> 0 -> pred n + 1 = n. Proof. intros; rewrite pred_of_minus; omega. Qed.Lemma pow2_zero: forall sz, (Nat.pow 2 sz > 0)%nat. Proof. induction sz; simpl; auto; omega. Qed.Section omega_compat. Ltac omega ::= lia. Theorem Npow2_nat : forall n, nat_of_N (Npow2 n) = Nat.pow 2 n. induction n as [|n IHn]; simpl; intuition. rewrite <- IHn; clear IHn. case_eq (Npow2 n); intuition. Qed.End omega_compat.Hint Rewrite Nplus_0_r nat_of_Nsucc nat_of_Nplus nat_of_Nminus N_of_nat_of_N nat_of_N_of_nat nat_of_P_o_P_of_succ_nat_eq_succ nat_of_P_succ_morphism : N. Theorem nat_of_N_eq : forall n m, nat_of_N n = nat_of_N m -> n = m. 
errC.Scheme Equality for variable. Scheme Equality for function. Scheme Equality for constructor.Module PlusSyntax <: Interface.SYNTAX. Definition variable := variable. Definition function := function. Definition constructor := constructor. Definition function_default := errF. Definition constructor_default := errC. Definition variable_eq_dec := variable_eq_dec. Definition function_eq_dec := function_eq_dec. Definition constructor_eq_dec := constructor_eq_dec. End PlusSyntax.Module Import Syn := Interface.MkSyn(PlusSyntax). Import Syn.ProgramNotations.Definition var_coercion : variable -> term := var_coercion_gen. Coercion var_coercion : variable >-> term.Notation " 'Z' " := (capply zero []). Notation " x '.+1' " := (capply succ [x:term]) (at level 60).Definition plus_prog : list rule := [ main (: x, y :) --> plus (: plus (: x, y :), plus (: x, y :) :) ; plus (: Z, y :) --> y ; plus (: x.+1, y :) --> (plus (: x, y :)) .+1 ].Module PlusProg <: Syn.PROGRAM. Definition prog := plus_prog. End PlusProg.Module Import Prog := Syn.MkProg (PlusProg). Import Prog.QI Prog.Evaluator. Definition rank : function -> nat := ltac:(autorank function_beq ranklist).Fixpoint quote_value (n : nat) : value := match n with | 0 => c_capply zero [] | S n' => c_capply succ [quote_value n'] end. Proposition UnaryAdd_is_wf: wf_prog. Proof. cbv; repeat split; tauto. Qed. Proposition UnaryAdd_is_ppo : PPO_prog rank. Proof. cbv. intros r H. decompose sum H; subst; ppo. Qed. Definition cs (c : constructor) := 1. Lemma qic_nonzero : constructor_non_zero cs. Proof. cbv; auto. Qed.Definition mcs := 1. Lemma qic_bounded : mcs_is_max_constructor_size mcs cs. Proof. cbv; auto. Qed.Definition qic (c : constructor) args := suml args + cs c. Lemma qic_additivity : additive qic cs. Proof. cbv; auto. Qed.Definition qif (f : function) args := match f with | main => 2*(suml args) | plus => suml args | errF => suml args end.Lemma qif_subterm : subterm qif. Proof. intros f l x H. destruct f; unfold qif. - apply in_le_suml; trivial. - apply le_trans with (m:= suml l). + apply in_le_suml; trivial. + omega. - apply in_le_suml; trivial. Qed.Lemma qif_monotonic : monotonicity_qif qif. Proof. intros f xs ys Hfor. destruct f; unfold qif; try apply Mult.mult_le_compat_l; apply forall2_le_suml; trivial. Qed.Lemma qi_is_compatible : compatible_QI qic qif. Proof. intros f lp t s; cbn. intros [ H | [ H | [ H | H ]]]; try tauto; injection H; clear H; intros; subst; trivial; cbn; omega. Qed.Proposition qi_is_valid : valid_QI mcs qic qif cs. Proof. repeat split. apply qic_bounded. apply qic_nonzero. apply qif_subterm. apply qif_monotonic. apply qi_is_compatible. Qed. Theorem plus_polytime: forall i s p c f lv d v, let t := fapply f lv in let pi := cbv_update i s p c t d v in cbv_wf pi -> cache_bounded qic qif c -> cbv_size pi <= global_bound mcs qif f lv c. 
unfold pure_ret_asm. rewrite fold_to_itree'. rewrite pure_asm_correct. rewrite throw_prefix_ret. cbn. red. intros. unfold interp_imp_inline, interp_asm. repeat rewrite interp_state_ret. apply eqit_Ret. split; cbn; auto. - simpl. rewrite raw_asm_block_correct. rewrite denote_after. rewrite throw_prefix_bind. rewrite throw_prefix_denote_expr. rewrite bind_bind. setoid_rewrite bind_ret_l. cbn. setoid_rewrite throw_prefix_ev. setoid_rewrite tau_eutt. setoid_rewrite throw_prefix_ret. setoid_rewrite <- bind_trigger. setoid_rewrite <- bind_ret_r at 6. rewrite <- bind_bind. setoid_rewrite bind_bind at 2. eapply bisimilar_bind'. { eapply compile_output_correct; eauto. } intros [] [] _. cbn. rewrite bind_ret_l. red. intros. unfold interp_imp_inline, interp_asm. repeat rewrite interp_state_ret. apply eqit_Ret; split; cbn; auto. - simpl. unfold pure_exc_asm. rewrite fold_to_itree'. rewrite pure_asm_correct. cbn. unfold trigger. setoid_rewrite unfold_iter_ktree. cbn. rewrite bind_ret_l. red. intros. unfold interp_imp_inline, interp_asm. repeat rewrite interp_state_ret. apply eqit_Ret. split; cbn; destruct s; auto. - inversion Hs. subst. simpl. rewrite fold_to_itree'. rewrite trycatch_asm_correct. cbn. rewrite throw_prefix_of_try_catch. rewrite try_catch_to_throw_prefix. set (fun (r : unit + sensitivity + sensitivity) (l :fin 3) => match r with | inl (inl _ ) => label_rel (inl tt) l | inl (inr s) => False | inr s => @label_rel unit (inr s) l end ) as R . eapply bisimilar_bind' with (RAA' := R). + cbn. rewrite throw_prefix_bind. setoid_rewrite <- bind_ret_r at 5. eapply bisimilar_bind'; eauto. intros. destruct a. * rewrite throw_prefix_ret. red. intros. unfold interp_imp_inline, interp_asm. repeat rewrite interp_state_ret. apply eqit_Ret. split; auto. * red. intros. unfold interp_imp_inline, interp_asm. repeat rewrite interp_state_ret. apply eqit_Ret. split; auto. + intros. destruct a as [ [ | ] | ]; try destruct s; cbn in H; try contradiction. * cbn in H. assert (a' = f0). { apply unique_fin. auto. } subst. repeat setoid_rewrite bind_ret_l. cbn. unfold from_bif, FromBifunctor_ktree_fin. red; intros. unfold interp_imp_inline, interp_asm. repeat rewrite interp_state_ret. apply eqit_Ret. split; auto. * assert (a' = fS f0). { apply unique_fin. auto. } subst. repeat setoid_rewrite bind_ret_l. cbn. repeat setoid_rewrite bind_ret_l. cbn. unfold id. setoid_rewrite unique_f0. auto. * assert (a' = fS (fS f0)). { apply unique_fin. auto. } subst. repeat setoid_rewrite bind_ret_l. cbn. repeat setoid_rewrite bind_ret_l. cbn. unfold id. setoid_rewrite unique_f0. auto. - inversion Hs. subst. rename H0 into Hp. red in Hp. cbn. unfold denote_asm_inline. rewrite throw_prefix_bind. setoid_rewrite exception_to_sum_correct_eutt_eq'. eapply bisimilar_bind'. Unshelve. 3 : { cbn. apply eq. } + red. intros. eauto. + intros; subst. cbn in a. destruct a; destruct a'; inv H; try setoid_rewrite throw_prefix_ret; cbn. * repeat intro. setoid_rewrite interp_state_ret. apply eqit_Ret; constructor; cbn; auto. * repeat intro; setoid_rewrite interp_state_ret. apply eqit_Ret. constructor; cbn; auto. destruct s0; auto. Qed. Theorem compile_correct (s : stmt) : valid_stmt s -> equivalent s (compile s). 
From iris.proofmode Require Import tactics. From iris.algebra Require Import auth. From Perennial.goose_lang Require Import proofmode notation. From Perennial.program_logic Require Import recovery_weakestpre dist_weakestpre dist_adequacy. From Perennial.goose_lang Require Export recovery_lifting dist_lifting. From Perennial.goose_lang Require Import typing adequacy lang. From Perennial.goose_lang Require Import crash_modality. Set Default Proof Using "Type".Theorem goose_dist_adequacy `{ffi_sem: ffi_semantics} `{!ffi_interp ffi} {Hffi_adequacy:ffi_interp_adequacy} Σ `{hPre: !gooseGpreS Σ} (ebσs : list node_init_cfg) g φinv (HINITG: ffi_initgP g.(global_world)) (HINIT: ∀ σ, σ ∈ init_local_state <$> ebσs → ffi_initP σ.(world) g.(global_world)) : (∀ `(HG : !gooseGlobalGS Σ), ⊢ ffi_global_start goose_ffiGlobalGS g.(global_world) ={⊤}=∗ wpd ⊤ ebσs ∗ (∀ g, ffi_global_ctx goose_ffiGlobalGS g.(global_world) -∗ |={⊤,  }=> ⌜ φinv g ⌝)) → dist_adequate (CS := goose_crash_lang) ebσs g (λ g, φinv g). Proof. intros Hwp. eapply (wpd_dist_adequacy_inv Σ _ _ _ _ _ _ _ (λ n, 10 * (n + 1))%nat). iIntros (Hinv ?) "". iMod (ffi_global_init _ _ g.(global_world)) as (ffi_namesg) "(Hgw&Hgstart)"; first by auto. iMod (credit_name_init (crash_borrow_ginv_number)) as (name_credit) "(Hcred_auth&Hcred&Htok)". iMod (proph_map_init κs g.(used_proph_id)) as (proph_names) "Hproph". set (hG := GooseGlobalGS _ _ proph_names (creditGS_update_pre _ _ name_credit) ffi_namesg). iExists global_state_interp, fork_post. iExists _, _. iMod (Hwp hG with "[$]") as "(Hwp&Hφ)". iAssert (|={⊤}=> crash_borrow_ginv)%I with "[Hcred]" as ">Hinv". { rewrite /crash_borrow_ginv. iApply (inv_alloc _). iNext. eauto. } iModIntro. iFrame "Hgw Hinv Hcred_auth Htok Hproph". iSplitR; first by eauto. iSplitL "Hwp"; last first. { iIntros (???) "Hσ". iApply ("Hφ" with "[Hσ]"). iDestruct "Hσ" as "($&_)". } rewrite /wpd/dist_weakestpre.wpd. iApply (big_sepL_mono with "Hwp"). iIntros (k' σ Hin) "H %Hc". iMod (na_heap_name_init tls σ.(init_local_state).(heap)) as (name_na_heap) "Hh". iMod (ffi_local_init _ _ σ.(init_local_state).(world)) as (ffi_names) "(Hw&Hstart)". { eapply HINIT. apply elem_of_list_fmap. eexists. split; first done. eapply elem_of_list_lookup_2. done. } iMod (trace_name_init σ.(init_local_state).(trace) σ.(init_local_state).(oracle)) as (name_trace) "(Htr&Htrfrag&Hor&Hofrag)". set (hL := GooseLocalGS Σ Hc ffi_names (na_heapGS_update_pre _ name_na_heap) (traceGS_update_pre Σ _ name_trace)). iMod ("H" $! hL with "[$] [$] [$]") as (Φ Φrx Φinv) "Hwpr". iModIntro. iExists state_interp, _, _, _. iSplitR "Hwpr"; first by iFrame. rewrite /wpr//=. Qed.Section failstop.Context `{ffi_sem: ffi_semantics} `{!ffi_interp ffi} {Hffi_adequacy:ffi_interp_adequacy}. Definition dist_adequate_failstop (ebσs: list (expr * state)) (g: global_state) := let ρs := fmap (λ ebσ, {| init_thread := fst ebσ; init_restart := of_val #(); init_local_state := snd ebσ |}) ebσs in dist_adequate (CS := goose_crash_lang) ρs g. Theorem goose_dist_adequacy_failstop Σ `{hPre: !gooseGpreS Σ} (ebσs : list (expr * state)) g φinv (HINITG: ffi_initgP g.(global_world)) (HINIT: ∀ σ, σ ∈ snd <$> ebσs → ffi_initP σ.(world) g.(global_world)) : (∀ `(HG : !gooseGlobalGS Σ), ⊢ ffi_global_start goose_ffiGlobalGS g.(global_world) ={⊤}=∗ ([∗ list] ebσ ∈ ebσs, let e := fst ebσ in let σ := snd ebσ in ∀ `(hL: !gooseLocalGS Σ), ffi_local_start (goose_ffiLocalGS) σ.(world) -∗ trace_frag σ.(trace) -∗ oracle_frag σ.(oracle) ={⊤}=∗ ∃ Φ, wp NotStuck ⊤ e Φ) ∗ (∀ g, ffi_global_ctx goose_ffiGlobalGS g.(global_world) -∗ |={⊤,  }=> ⌜ φinv g ⌝)) → dist_adequate_failstop ebσs g (λ g, φinv g). 
x, or zero x = x. Proof. intros. rewrite or_commut. apply or_zero. Qed.Theorem or_mone: forall x, or x mone = mone. Proof. bit_solve. Qed.Theorem or_idem: forall x, or x x = x. Proof. bit_solve. destruct (testbit x i); auto. Qed.Theorem and_or_distrib: forall x y z, and x (or y z) = or (and x y) (and x z). Proof. bit_solve. apply demorgan1. Qed.Corollary and_or_distrib_l: forall x y z, and (or x y) z = or (and x z) (and y z). Proof. intros. rewrite (and_commut (or x y)). rewrite and_or_distrib. f_equal; apply and_commut. Qed.Theorem or_and_distrib: forall x y z, or x (and y z) = and (or x y) (or x z). Proof. bit_solve. apply orb_andb_distrib_r. Qed.Corollary or_and_distrib_l: forall x y z, or (and x y) z = and (or x z) (or y z). Proof. intros. rewrite (or_commut (and x y)). rewrite or_and_distrib. f_equal; apply or_commut. Qed.Theorem and_or_absorb: forall x y, and x (or x y) = x. Proof. bit_solve. assert (forall a b, a && (a || b) = a) by destr_bool. auto. Qed.Theorem or_and_absorb: forall x y, or x (and x y) = x. Proof. bit_solve. assert (forall a b, a || (a && b) = a) by destr_bool. auto. Qed.Theorem xor_commut: forall x y, xor x y = xor y x. Proof. bit_solve. apply xorb_comm. Qed.Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z). Proof. bit_solve. apply xorb_assoc. Qed.Theorem xor_zero: forall x, xor x zero = x. Proof. bit_solve. apply xorb_false. Qed.Corollary xor_zero_l: forall x, xor zero x = x. Proof. intros. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_idem: forall x, xor x x = zero. Proof. bit_solve. apply xorb_nilpotent. Qed.Theorem xor_zero_one: xor zero one = one. Proof. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_one_one: xor one one = zero. Proof. apply xor_idem. Qed.Theorem xor_zero_equal: forall x y, xor x y = zero -> x = y. Proof. intros. apply same_bits_eq; intros. assert (xorb (testbit x i) (testbit y i) = false). rewrite <- bits_xor; auto. rewrite H. apply bits_zero. destruct (testbit x i); destruct (testbit y i); reflexivity || discriminate. Qed.Theorem xor_is_zero: forall x y, eq (xor x y) zero = eq x y. Proof. intros. predSpec eq eq_spec (xor x y) zero. - apply xor_zero_equal in H. subst y. rewrite eq_true; auto. - predSpec eq eq_spec x y. + elim H; subst y; apply xor_idem. + auto. Qed. Theorem and_xor_distrib: forall x y z, and x (xor y z) = xor (and x y) (and x z). 
omega. + assert (forall i, 0 < i < S n -> f 0 < f i) by (intros; apply Hf; omega). do 2 (rewrite power_decomp_factor; auto). intros E. apply div_rem_uniq in E; auto. * destruct E as (E1 & E2). intros [ | i ] Hi. - revert E2; rewrite Nat.mul_cancel_r; auto. - apply IHn with (4 := E1); try omega. ++ intros u j Hu; apply lt_minus_cancel; split; apply Hf; omega. ++ intros; apply Ha; omega. ++ intros; apply Hb; omega. * rewrite power_S. apply Nat.mul_lt_mono_pos_r. - apply power_ge_1; omega. - apply Ha; omega. * rewrite power_S. apply Nat.mul_lt_mono_pos_r. - apply power_ge_1; omega. - apply Hb; omega. Qed.End power_decomp_uniq.Fact mult_2_eq_plus x : x + x = 2 *x. Proof. ring. Qed.Section power_injective. Let power_2_inj_1 i j n : j < i -> 2* power n 2 <> power i 2 + power j 2. Proof. rewrite <- power_S; intros H4 E. generalize (@power_ge_1 j 2); intro C. destruct (lt_eq_lt_dec i (S n)) as [ [ H5 | H5 ] | H5 ]. + apply power_mono_l with (x := 2) in H5; auto. rewrite power_S in H5. apply power_mono_l with (x := 2) in H4; auto. rewrite power_S in H4; omega. + subst i; omega. + apply power_mono_l with (x := 2) in H5; auto. rewrite power_S in H5; omega. Qed. Fact power_2_inj i j : power i 2 = power j 2 -> i = j. Proof. intros H. destruct (lt_eq_lt_dec i j) as [ [ C | C ] | C ]; auto; apply power_smono_l with (x := 2) in C; omega. Qed. Let power_plus_lt a b c : a < b < c -> power a 2 + power b 2 < power c 2. Proof. intros [ H1 H2 ]. apply power_mono_l with (x := 2) in H2; auto. apply power_smono_l with (x := 2) in H1; auto. rewrite power_S in H2; omega. Qed. Let power_inj_2 i1 j1 i2 j2 : j1 < i1 -> j2 < i2 -> power i1 2 + power j1 2 = power i2 2 + power j2 2 -> i1 = i2 /\ j1 = j2. Proof. intros H1 H2 H3. destruct (lt_eq_lt_dec i1 i2) as [ [ C | C ] | C ]. + generalize (@power_plus_lt j1 i1 i2); intros; omega. + split; auto; apply power_2_inj; subst; omega. + generalize (@power_plus_lt j2 i2 i1); intros; omega. Qed. Theorem sum_2_power_2_injective i1 j1 i2 j2 : j1 <= i1 -> j2 <= i2 -> power i1 2 + power j1 2 = power i2 2 + power j2 2 -> i1 = i2 /\ j1 = j2. 
auto. apply wf_inverse_image with (R := lt); auto. apply lt_wf. Qed. Definition list_length_induction : forall P : list A -> Type, (forall l1 : list A, (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) -> forall l : list A, P l. intros P H l; apply well_founded_induction_type with (R := fun x y : list A => length x < length y); auto. apply wf_inverse_image with (R := lt); auto. apply lt_wf. Defined. Theorem in_ex_app : forall (a : A) (l : list A), In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2). Proof using. intros a l; elim l; clear l; simpl in |- *; auto. intros H; case H. intros a1 l H [H1| H1]; auto. exists (nil (A:=A)); exists l; simpl in |- *; auto. apply f_equal2 with (f := cons (A:=A)); auto. case H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2; simpl in |- *; auto. apply f_equal2 with (f := cons (A:=A)); auto. Qed. Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2. Proof using. intros l1; elim l1; simpl in |- *; auto. Qed. Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3. Proof using. intros l1; elim l1; simpl in |- *; auto. intros a l H l2 l3 H0; apply H; injection H0; auto. Qed. Theorem app_inv_tail : forall l1 l2 l3 : list A, l2 ++ l1 = l3 ++ l1 -> l2 = l3. Proof using. intros l1 l2; generalize l1; elim l2; clear l1 l2; simpl in |- *; auto. intros l1 l3; case l3; auto. intros b l H; absurd (length ((b :: l) ++ l1) <= length l1). simpl in |- *; rewrite length_app; auto with arith. rewrite <- H; auto with arith. intros a l H l1 l3; case l3. simpl in |- *; intros H1; absurd (length (a :: l ++ l1) <= length l1). simpl in |- *; rewrite length_app; auto with arith. rewrite H1; auto with arith. simpl in |- *; intros b l0 H0; injection H0. intros H1 H2; apply f_equal2 with (f := cons (A:=A)); auto. apply H with (1 := H1); auto. Qed. Theorem app_inv_app : forall l1 l2 l3 l4 a, l1 ++ l2 = l3 ++ a :: l4 -> (exists l5 : list A, l1 = l3 ++ a :: l5) \/ (exists l5 : _, l2 = l5 ++ a :: l4). 
q; induction n as [ | n IHn ]; intros q Hf1 Hf2 Ha. + rewrite msum_0; apply power_ge_1; omega. + rewrite msum_plus1; auto. apply lt_le_trans with (1*power (f n) p + a n * power (f n) p). * apply plus_lt_le_compat; auto. rewrite Nat.mul_1_l. apply IHn. - intros; apply Hf1; omega. - intros; apply Hf1; omega. - intros; apply Ha; omega. * rewrite <- Nat.mul_add_distr_r. replace q with (S (q-1)). - rewrite power_S; apply mult_le_compat; auto. ++ apply Ha; auto. ++ apply power_mono_l; try omega. generalize (Hf2 n); intros; omega. - generalize (Hf2 0); intros; omega. Qed. Lemma power_decomp_is_digit n a f : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> forall i, i < n -> is_digit (∑ n (fun i => a i * power (f i) p)) p (f i) (a i). Proof. intros Hf Ha. induction n as [ | n IHn ]; intros i Hi. + omega. + split; auto. exists (∑ (n-i) (fun j => a (S i + j) * power (f (S i+j) - f i - 1) p)), (∑ i (fun j => a j * power (f j) p)); split. - replace (S n) with (S i + (n-i)) by omega. rewrite msum_plus, msum_plus1; auto. rewrite <- plus_assoc, plus_comm; f_equal. rewrite Nat.mul_add_distr_r, plus_comm; f_equal. rewrite <- mult_assoc, mult_comm, <- sum_0n_scal_l. apply msum_ext. intros j Hj. rewrite (mult_comm (_ * _)); repeat rewrite <- mult_assoc; f_equal. rewrite <- power_S, <- power_plus; f_equal. generalize (Hf i (S i+j)); intros; omega. - apply power_decomp_lt; auto. * intros; apply Hf; omega. * intros; apply Ha; omega. Qed. Theorem power_decomp_unique n f a b : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> (forall i, i < n -> b i < p) -> ∑ n (fun i => a i * power (f i) p) = ∑ n (fun i => b i * power (f i) p) -> forall i, i < n -> a i = b i. Proof. intros Hf Ha Hb E i Hi. generalize (power_decomp_is_digit _ _ Hf Ha Hi) (power_decomp_is_digit _ _ Hf Hb Hi). rewrite E; apply is_digit_fun. Qed.End power_decomp.Section power_decomp_uniq. Variable (p : nat) (Hp : 2 <= p). Theorem power_decomp_factor n f a : (forall i, 0 < i < S n -> f 0 < f i) -> ∑ (S n) (fun i => a i * power (f i) p) = ∑ n (fun i => a (S i) * power (f (S i) - f 0 - 1) p) * power (S (f 0)) p + a 0 * power (f 0) p. 
Set Implicit Arguments. Definition is_inverse A B f g := (forall a:A, g (f a) = a) /\ (forall b:B, f (g b) = b).Record Delta A := { pi1:A; pi2:A; eq:pi1=pi2 }.Definition delta {A} (a:A) := {|pi1 := a; pi2 := a; eq := eq_refl a |}.Arguments pi1 {A} _. Arguments pi2 {A} _.Lemma diagonal_projs_same_behavior : forall A (x:Delta A), pi1 x = pi2 x. Proof. destruct x as (a1,a2,Heq); assumption. Qed.Lemma diagonal_inverse1 : forall A, is_inverse (A:=A) delta pi1. Proof. split; [trivial|]; destruct b as (a1,a2,[]); reflexivity. Qed.Lemma diagonal_inverse2 : forall A, is_inverse (A:=A) delta pi2. Proof. split; [trivial|]; destruct b as (a1,a2,[]); reflexivity. Qed.Local Notation FunctionalExtensionality := (forall A B (f g : A -> B), (forall x, f x = g x) -> f = g).Local Notation EqDeltaProjs := (forall A, pi1 = pi2 :> (Delta A -> A)).Local Notation UniqueInverse := (forall A B (f:A->B) g1 g2, is_inverse f g1 -> is_inverse f g2 -> g1 = g2).Definition action A B C (f:A->B) := (fun h:B->C => fun x => h (f x)).Local Notation BijectivityBijectiveComp := (forall A B C (f:A->B) g, is_inverse f g -> is_inverse (A:=B->C) (action f) (action g)). Theorem FunctExt_iff_EqDeltaProjs : FunctionalExtensionality <-> EqDeltaProjs. 
Require Import Coq.Lists.List Coq.Arith.Arith Coq.Bool.Bool. Require Import Bedrock.Expr Bedrock.Env. Require Import Coq.Classes.EquivDec Bedrock.EqdepClass. Require Import Bedrock.DepList. Require Import Bedrock.Word Bedrock.Prover. Require Import Bedrock.provers.ReflexivityProver Bedrock.sep.Locals.Set Implicit Arguments. Set Strict Implicit.Require Import Coq.Arith.Arith Bedrock.ILEnv Bedrock.Memory.Section LocalsProver. Variable types' : list type. Definition types := Locals.types types'. Variable funcs' : functions types. Definition funcs := Locals.funcs funcs'. Definition localsSimplify (e : expr types) : expr types := match e with | Func 11 (vs :: Const t nm :: nil) => match t return tvarD types t -> _ with | tvType 6 => fun nm => sym_sel vs nm | _ => fun _ => e end nm | _ => e end. Definition localsProve (_ : unit) (goal : expr types) := match goal with | Equal _ x y => expr_seq_dec (localsSimplify x) (localsSimplify y) | _ => false end. Lemma localsSimplify_correct : forall uvars vars (e : expr types) t v, exprD funcs uvars vars e t = Some v -> exprD funcs uvars vars (localsSimplify e) t = Some v. destruct e; simpl; intuition idtac. do 12 (destruct f; try assumption). do 2 (destruct l; try assumption). destruct e0; try assumption. destruct l; try assumption. destruct t0; try assumption. do 7 (destruct n; try assumption). simpl in *. destruct (equiv_dec (tvType 0) t); try discriminate. hnf in e0; subst. generalize (sym_sel_correct funcs' uvars vars t1 e). unfold funcs in *. match type of H with | match ?E with Some _ => _ | _ => _ end _ _ = _ => destruct E; try discriminate end. injection H; clear H; intros; subst. auto. Qed. Theorem localsProveCorrect : ProverCorrect funcs reflexivityValid localsProve. 
A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP) (genPcPf (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP Q) R -> (forall b c : poly A0 eqA ltM, In b aP -> In c aP -> redIn b c aP (a :: Q) R) -> forall b : poly A0 eqA ltM, In b aP -> ~ BuchAux.zerop A A0 eqA n ltM b -> redIn (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) b (addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP) (genPcPf (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP Q) R. intros a aP R Q H' H'0 H'1 b H'2 H'3. lapply (spolyp_addEnd_genPcPf aP); [ intros H'5; elim (H'5 Q (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) b); [ intros c E; elim E; intros H'12 H'13; elim H'13; intros H'14 H'15; elim H'14; [ intros H'16; clear H'14 H'13 E | intros H'16; clear H'14 H'13 E ] | idtac | idtac | idtac ] | idtac ]; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redln_cons_gen; auto. apply redInInclQ with (Q := a :: Q); auto with datatypes. apply ObuchPincl with (Q := genPcPf (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP Q); auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redIn1. apply red_incl with (p := addEnd A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP) (1 := cs); auto. apply ObuchPincl with (Q := genPcPf (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP Q); auto. apply redln_cons_gen; auto. apply redInInclQ with (Q := a :: Q); auto with datatypes. apply ObuchPincl with (Q := genPcPf (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a aP) aP Q); auto. Qed. Theorem OBuch_Inv : forall aP R Q : list (poly A0 eqA ltM), OBuch aP Q R -> (forall a b : poly A0 eqA ltM, In a aP -> In b aP -> redIn a b aP Q R) -> forall a b : poly A0 eqA ltM, In a R -> In b R -> reds a b R. 
forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, {eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)} + {~ eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)}. intros a b; case a; case b; simpl in |- *; auto. intros b2 c2 b3 c3. intros Zp1 Zp2. case (mk_clean c3 c2). intros x; case x. intros c b4; case b4. intros H0; left; simpl in |- *; auto. generalize (div_clean_dec1 n c3 c2); rewrite <- H0; simpl in |- *; auto. intros H1; case H1; auto; intros H2 H3; split; auto. apply divA_is_multA with (1 := cs); auto. intros H0; right; red in |- *; intros dviP_H; inversion dviP_H. generalize (div_clean_dec2 n c3 c2); simpl in |- *; auto. intros H'; lapply H'; [ intros H'0; apply H'0; clear H' | clear H' ]. rewrite <- H1; auto. rewrite <- H0; simpl in |- *; auto. Qed. Theorem zeroP_divTerm : forall a b : Term A n, zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). intros a b; case a; case b; simpl in |- *; auto. intros d H' A0' H'0 H'1 nZd; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA A0 d nZd); auto. apply divA_A0_l with (1 := cs). Qed. Theorem divTerm_on_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). intros a b; case a; case b; unfold eqT in |- *; simpl in |- *; auto. intros d c A0' c0 H' H'0 H'1; rewrite <- H'1. split; auto. apply divA_is_multA with (1 := cs); auto. rewrite mult_div_id; auto. rewrite mult_mon_zero_l; auto. Qed. Theorem divTerm_on_eqT_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqT (divTerm a nZb) (T1 A1 n). intros a b; case a; case b; unfold eqT in |- *; simpl in |- *; auto. intros b2 c b3 c0 H' H'0 H'1; rewrite H'1; auto. rewrite mult_div_id; auto. Qed. Theorem divTerm_on_plusM_minusM : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, T2M a = mult_mon n (div_mon n (T2M a) (T2M b)) (T2M b) -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). 
t T1 T2, empty |- t \typ (TArrow T1 T2) -> value t -> exists x u, t = tabs x T1 u. Admitted. Definition step_fun (t : trm) : option trm := Some t.Axiom step_fun_correct : forall t t', step_fun t = Some t' <-> step t t'.Instance dec_step (t : trm) : Dec (exists t', step t t') := {| dec := _ |}. Proof. destruct (step_fun t) eqn:Step. - left; exists t0; eapply step_fun_correct; eauto. - right => [[t' contra]]. eapply step_fun_correct in contra; congruence. Defined.Theorem progress : forall t T, empty |- t \typ T -> value t \/ exists t', t ===> t'. Admitted. Inductive appears_free_in : id -> trm -> Prop := | afi_var : forall i, appears_free_in i (tvar i) | afi_app1 : forall i t1 t2, appears_free_in i t1 -> appears_free_in i (tapp t1 t2) | afi_app2 : forall i t1 t2, appears_free_in i t2 -> appears_free_in i (tapp t1 t2) | afi_abs : forall i y T11 t12, y <> i -> appears_free_in i t12 -> appears_free_in i (tabs y T11 t12) | afi_if1 : forall i t1 t2 t3, appears_free_in i t1 -> appears_free_in i (tif t1 t2 t3) | afi_if2 : forall i t1 t2 t3, appears_free_in i t2 -> appears_free_in i (tif t1 t2 t3) | afi_if3 : forall i t1 t2 t3, appears_free_in i t3 -> appears_free_in i (tif t1 t2 t3).Hint Constructors appears_free_in.Derive ArbitrarySizedSuchThat for (fun i => appears_free_in i t). Derive SizeMonotonicSuchThatOpt for (fun i => appears_free_in i t). Derive SizedProofEqs for (fun i => appears_free_in i t). Derive GenSizedSuchThatCorrect for (fun i => appears_free_in i t). Derive GenSizedSuchThatSizeMonotonicOpt for (fun i => appears_free_in i t).Instance appears_free_in_gen_correct t : SuchThatCorrect (fun i => appears_free_in i t) (@arbitraryST _ (fun i => appears_free_in i t) _). Admitted.Definition closed (t:trm) := forall x, ~ appears_free_in x t.Instance dec_closed t : Dec (closed t). Admitted. Instance dec_bind x Gamma : Dec (exists T, bind Gamma x T). Admitted.Lemma free_in_context : forall x t, appears_free_in x t -> forall T Gamma, Gamma |- t \typ T -> exists T', bind Gamma x T'. Admitted. Corollary typable_empty__closed : forall t T, empty |- t \typ T -> closed t. Admitted. Lemma substitution_preserves_typing : forall Gamma x U t v T, cons (x,U) Gamma |- t \typ T -> empty |- v \typ U -> Gamma |- [x:=v]t \typ T. Admitted. Theorem preservation : forall t T, empty |- t \typ T -> forall t', t ===> t' -> empty |- t' \typ T. 
* intuition. apply tree_gt_implies_not_member in H4; eauto. * { remember (Node n0 t1_1 t1_2) as t1. clear Heqt1. intuition. destruct (leftmost t2) eqn:H6. - assert (n < n1). { eapply leftmost_gt_n; eauto. } simpl in H0. rewrite nat_compare_lt in H7. rewrite H7 in H0. apply tree_lt_implies_not_member in H2; eauto. - apply tree_lt_implies_not_member in H2; eauto. } + simpl. bdestruct (n0 ?= n); try omega. apply IHt1. intuition. + simpl. assert (n0 > n). { omega. } bdestruct (n0 ?= n); try omega. apply IHt2. intuition. Qed.Theorem unchanged_member_after_delete : forall (t : tree) (n m : nat), BST t -> n <> m -> member (delete t m) n = member t n. Proof.Admitted.Theorem delete_correct : forall (t : tree) (n : nat), BST t -> BST (delete t n). Proof. intros t. induction t; intros; unfold_tree. - simpl. auto. - bdestruct (n0 ?= n); unfold_tree. + destruct t1. * intuition. * { destruct (leftmost t2) eqn:H1. - remember (Node n0 t1_1 t1_2) as t1. clear Heqt1. unfold_tree. intuition. + rewrite (delete_leftmost_is_delete t2 n1); auto. + assert (n1 > n). { eapply leftmost_gt_n. apply H4. apply H1. } eapply tree_lt_trans. eauto. omega. + eapply delete_leftmost_gt_n; eauto. - intuition. } + intuition. auto. apply tree_lt_n_delete_preserve; auto. + intuition. auto. apply tree_gt_n_delete_preserve; auto. Qed.Module Type AbsSet. Parameter set : Type. Definition key := nat. Parameter empty : set. Parameter member : set -> key -> bool. Parameter insert : set -> key -> set. Axiom member_empty : forall k, member empty k = false. Axiom member_after_eq_insert : forall t n, member (insert t n) n = true. Axiom unchanged_member_after_neq_insert : forall t n m, n <> m -> member (insert t n) m = member t m. End AbsSet.Module BST <: AbsSet. Definition set := { t | BST t }. Definition key := nat. Definition empty : { t | BST t }. refine (exist BST Leaf _). constructor. Defined. Definition member (t : set) (n : key) : bool := member (proj1_sig t) n. Definition insert (t : set) (n : key) : set := exist BST (insert (proj1_sig t) n) (insert_correct (proj1_sig t) n (proj2_sig t)). Theorem member_empty : forall k, member empty k = false. Proof. intros. compute. auto. Qed. Theorem member_after_eq_insert : forall t n, member (insert t n) n = true. Proof. intros. unfold member, insert. unfold set in t; destruct t; simpl. apply member_after_eq_insert. auto. Qed. Theorem unchanged_member_after_neq_insert : forall t n m, n <> m -> member (insert t n) m = member t m. 
-> logs_sorted_nw (mkNetwork l st') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem logs_sorted_nw_no_append_entries : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. eapply logs_sorted_nw_only_new_packets_matter; eauto. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem logs_sorted_nw_not_append_entries : forall net ps' p' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold logs_sorted_nw in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_only_new_packets_matter : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_gt_prevIndex (mkNetwork l st') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_no_append_entries : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. intros. eapply packets_gt_prevIndex_only_new_packets_matter; eauto. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_not_append_entries : forall net ps' p' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. intros. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold packets_gt_prevIndex in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_ge_prevTerm_only_new_packets_matter : forall net ps' l st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_ge_prevTerm (mkNetwork l st') -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_ge_prevTerm_no_append_entries : forall net ps' l st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_ge_prevTerm (mkNetwork ps' st'). 
intro i. rewrite set.mem_xI_S. now case set.mem. Qed. Theorem decomp_top n: top ≡ e_top' n. Proof. unfold e_top'. induction n. symmetry. apply cupxb. simpl pow2. rewrite seq_double, sup_app. rewrite 2sup_map. setoid_rewrite atom_xO. setoid_rewrite atom_xI. rewrite <- 2capxsup. rewrite capC, (capC (e_var _)), <- capcup. rewrite cupC, cupneg, capxt. intros X L f. simpl. rewrite (IHn X L (fun i => f (ordS i))). rewrite 2eval_sup. apply sup_weq. 2: reflexivity. intro i. induction (atom i); first [reflexivity|apply cup_weq|apply cap_weq|apply neg_weq]; assumption. Qed. Section atom_props. Variable n: nat. Notation Atom := (ord (pow2 n)). Lemma cap_var_atom (a: Atom) b: e_var b ⊓ atom a ≡ (if set.mem a b then atom a else bot). Proof. generalize (in_seq b). unfold atom. induction (seq n). intros []. simpl (sup _ _). intros [->|Hl]. case set.mem. lattice. rewrite capA, capneg. apply capbx. rewrite capA, (capC (e_var _)), <-capA, IHl by assumption. case (set.mem a b). reflexivity. apply capxb. Qed.Lemma cup_var_atom (a: Atom) b: e_var b ⊔ !atom a ≡ (if set.mem a b then top else !atom a). Proof. generalize (in_seq b). unfold atom. induction (seq n). intros []. simpl (sup _ _). intros [->|Hl]. case set.mem. rewrite negcap, cupA, cupneg. apply cuptx. rewrite negcap, negneg. lattice. rewrite negcap at 1. rewrite cupA, (cupC (e_var _)), <-cupA, IHl by assumption. case (set.mem a b). apply cupxt. now rewrite negcap. Qed.Lemma eval_mem_cap (a: Atom) e: e ⊓ atom a ≡ if eval (set.mem a) e then atom a else bot with eval_mem_cup (a: Atom) e: e ⊔ !atom a ≡ if eval (set.mem a) e then top else !atom a. Proof. - destruct e; simpl eval. apply capbx. apply captx. rewrite capC, capcup, capC, eval_mem_cap, capC, eval_mem_cap. case (eval (set.mem a) e1); case (eval (set.mem a) e2); lattice. transitivity ((e1 ⊓ atom a) ⊓ (e2 ⊓ atom a)). lattice. rewrite 2eval_mem_cap. case (eval (set.mem a) e1); case (eval (set.mem a) e2); lattice. neg_switch. rewrite negcap, negneg, eval_mem_cup. case (eval (set.mem a) e). now rewrite <-negbot. reflexivity. apply cap_var_atom. - destruct e; simpl eval. apply cupbx. apply cuptx. transitivity ((e1 ⊔ !atom a) ⊔ (e2 ⊔ !atom a)). lattice. rewrite 2eval_mem_cup. case (eval (set.mem a) e1); case (eval (set.mem a) e2); lattice. rewrite cupC, cupcap, cupC, eval_mem_cup, cupC, eval_mem_cup. case (eval (set.mem a) e1); case (eval (set.mem a) e2); lattice. neg_switch. rewrite negcup, 2negneg, eval_mem_cap. case (eval (set.mem a) e). apply negneg. apply negtop. apply cup_var_atom. Qed. Theorem decomp_expr e: e ==_[BL] \sup_(i \in filter (fun f => eval (set.mem f) e) (seq (pow2 n))) atom i. 
Require Import Classical.Require Import Ensembles. Require Import Relations_1. Require Import Relations_1_facts. Require Import podefs. Require Import podefs_1.Section The_power_set_partial_order. Variable U : Type. Inductive Power_set (A : Ensemble U) : Ensemble (Ensemble U) := Definition_of_Power_set : forall X : Ensemble U, Included U X A -> In (Ensemble U) (Power_set A) X. Hint Resolve Definition_of_Power_set. Variable A : Ensemble U. Theorem Empty_set_minimal : forall X : Ensemble U, Included U (Empty_set U) X. Proof. red in |- *; intros X x H'; elim H'. Qed. Hint Resolve Empty_set_minimal. Theorem Power_set_non_empty : forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A). Proof. intro A'; apply Non_empty_intro with (Empty_set U); auto. Qed. Hint Resolve Power_set_non_empty. Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U). Proof. auto 8. Qed. Hint Resolve Inclusion_is_an_order. Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U). elim Inclusion_is_an_order; auto. Qed. Hint Resolve Inclusion_is_transitive. Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U). Proof. generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H'; auto. Qed. Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U). Proof. elim Same_set_equivalence; auto. Qed. Hint Resolve Same_set_reflexive. Theorem Power_set_PO : PO (Ensemble U). Proof. apply Definition_of_PO with (Power_set A) (Included U); auto. Defined. Theorem Union_minimal : forall a b X : Ensemble U, Included U a X -> Included U b X -> Included U (Union U a b) X. 
Export alphaeq. Notation "tls {[ m ]}" := (selectbt tls m) (at level 99). Definition NTrel {o} := @NTerm o -> @NTerm o -> [univ]. Definition olift {p} (R : NTrel) (x y : NTerm) : [univ] := nt_wf x # nt_wf y # forall sub: @Substitution p, wf_sub sub -> isprogram (lsubst x sub) -> isprogram (lsubst y sub) -> R (lsubst x sub) (lsubst y sub). Definition oliftp {p} (R : NTrel) (x y :NTerm) : [univ] := nt_wf x # nt_wf y # forall sub: @CSub p, cover_vars x sub -> cover_vars y sub -> R (csubst x sub) (csubst y sub).Definition blift {p} (R: NTrel) (bt1 bt2: BTerm): [univ] := {lv: (list NVar) & {nt1,nt2 : @NTerm p $ R nt1 nt2 # alpha_eq_bterm bt1 (bterm lv nt1) # alpha_eq_bterm bt2 (bterm lv nt2) }}.Definition lblift {p} (R: NTrel) (tls trs: list (@BTerm p)): [univ] := length tls = length trs # forall n : nat, n < length tls -> blift R (tls{[n]}) (trs{[n]}).Definition blift_old {p} (R : NTerm -> NTerm -> Type) (a b : BTerm) : Type := num_bvars a = num_bvars b # forall lnt : list (@NTerm p), length lnt = num_bvars a -> (forall nt : NTerm, LIn nt lnt -> isprogram nt) -> R (apply_bterm a lnt) (apply_bterm b lnt). Definition is_rel_on_progs {p} (R: bin_rel (@NTerm p)) : Type := forall t1 t2, R t1 t2 -> isprogram t1 # isprogram t2.Theorem le_blift {p} : forall (R1 R2 : bin_rel (@NTerm p)), le_bin_rel R1 R2 -> le_bin_rel (blift R1) (blift R2). Proof. unfold le_bin_rel. intros R1 R2 Hle a b Hrel. allunfold @blift. sp. exists lv nt1 nt2. split; eauto. Defined.Theorem le_olift {p} : forall (R1 R2 : bin_rel (@NTerm p)), le_bin_rel R1 R2 -> le_bin_rel (olift R1) (olift R2). Proof. unfold le_bin_rel, olift. sp. Defined.Hint Resolve @le_olift : slow. Theorem le_blift2 {p} : forall (R1 R2 : bin_rel (@NTerm p)), (le_bin_rel R1 R2) -> forall a b, (blift R1 a b) -> (blift R2 a b). Proof. intros R1 R2 n H. fold (@le_bin_rel (BTerm ) (blift R1 ) (blift R2 )). apply le_blift. auto. Defined.Hint Resolve le_blift2 : slow.Theorem le_lblift {p} : forall (R1 R2 : bin_rel (@NTerm p)), (le_bin_rel R1 R2) -> le_bin_rel (lblift R1) (lblift R2). Proof. unfold lblift; sp. unfold le_bin_rel; sp. generalize (X0 n); sp. apply @le_blift2 with (R1 := R1); sp. Defined. Theorem le_lblift2 {p} : forall (R1 R2 : bin_rel (@NTerm p)), (le_bin_rel R1 R2) -> forall a b, (lblift R1 a b) -> (lblift R2 a b). 
id c out st l net, handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st). Proof using tsi. unfold logs_sorted_host. intros. find_apply_lem_hyp handleClientRequest_log. intuition. + repeat find_rewrite. eauto. + find_apply_lem_hyp no_entries_past_current_term_invariant. break_exists; intuition; repeat find_rewrite. simpl. intuition eauto. * find_eapply_lem_hyp maxIndex_is_max; eauto. lia. * unfold no_entries_past_current_term, no_entries_past_current_term_host in *. intuition. simpl in *. find_apply_hyp_hyp. lia. Qed. Theorem logs_sorted_client_request : raft_net_invariant_client_request logs_sorted. Proof using tsi. unfold raft_net_invariant_client_request. unfold logs_sorted. intuition. - unfold logs_sorted_host in *. simpl in *. intros. find_higher_order_rewrite. break_match; eauto. subst. eauto using handleClientRequest_logs_sorted. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using logs_sorted_nw_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_gt_prevIndex_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_ge_prevTerm_packets_unchanged. Qed. Theorem handleTimeout_log : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> log st' = log st. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; auto. Qed. Theorem logs_sorted_nw_only_new_packets_matter : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> logs_sorted_nw (mkNetwork l st') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem logs_sorted_nw_no_append_entries : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. eapply logs_sorted_nw_only_new_packets_matter; eauto. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem logs_sorted_nw_not_append_entries : forall net ps' p' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold logs_sorted_nw in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_only_new_packets_matter : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_gt_prevIndex (mkNetwork l st') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_no_append_entries : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_gt_prevIndex (mkNetwork ps' st'). 
y = f y x. Structure Abelian_Group : Type := abelian_group { E : Set; E_0 : E; op : E -> E -> E; op_is_assoc : Monoid.is_assoc E op; op_is_comm : is_comm E op; op_id_l : Monoid.is_id_l E op E_0; op_inv_l_ex : forall x : E, exists y : E, op y x = E_0 }.Arguments E_0 {a}.Arguments op {a} x y.Arguments op_is_assoc {a} x y z.Arguments op_is_comm {a} x y.Arguments op_id_l {a} x.Arguments op_inv_l_ex {a} x.Notation "0" := E_0 : abelian_group_scope.Notation "x + y" := (op x y) (at level 50, left associativity) : abelian_group_scope.Notation "{+}" := op : abelian_group_scope.Open Scope abelian_group_scope.Section Theorems. Variable g : Abelian_Group. Let E := E g. Definition op_is_id_l := Monoid.is_id_l E {+}. Definition op_is_id_r := Monoid.is_id_r E {+}. Definition op_is_id := Monoid.is_id E {+}. Theorem op_is_id_lr : forall x : E, op_is_id_l x -> op_is_id_r x. Proof fun x H y => H y || a = y @a by op_is_comm y x. Theorem op_is_id_lid : forall x : E, op_is_id_l x -> op_is_id x. Proof fun x H => conj H (op_is_id_lr x H). Theorem op_id_r : op_is_id_r 0. Proof op_is_id_lr 0 op_id_l. Theorem op_id : op_is_id 0. Proof conj op_id_l op_id_r. Definition op_is_inv_l := Monoid.is_inv_l E {+} 0 op_id. Definition op_is_inv_r := Monoid.is_inv_r E {+} 0 op_id. Definition op_is_inv := Monoid.is_inv E {+} 0 op_id. Theorem op_inv_r_ex : forall x : E, exists y : E, op_is_inv_r x y. Proof fun x => ex_ind (fun (y : E) (H : op_is_inv_l x y) => ex_intro (op_is_inv_r x) y (H || a = 0 @a by op_is_comm x y)) (op_inv_l_ex x). Definition op_group := Group.group E 0 {+} op_is_assoc op_id_l op_id_r op_inv_l_ex op_inv_r_ex. Definition op_monoid := Group.op_monoid op_group. Definition has_inv_l := Group.has_inv_l op_group. Definition has_inv_r := Group.has_inv_r op_group. Definition has_inv := Group.has_inv op_group. Theorem op_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Group.op_id_l_uniq op_group. Theorem op_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Group.op_id_r_uniq op_group. Theorem op_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Group.op_id_uniq op_group. Theorem op_inv_l_r_eq : forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z. Proof Group.op_inv_l_r_eq op_group. Theorem op_inv_sym : forall x y : E, op_is_inv x y <-> op_is_inv y x. Proof Group.op_inv_sym op_group. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. 
inversion H3; monad_inv; subst; clear H3. inversion H1; monad_inv; clear H1. subst. inversion H2; monad_inv; subst; clear H2. destruct s0. monad_inv. destruct (world σ1 !! int.Z n) eqn:Heq; rewrite Heq in H4; subst; last first. { inv_monad_false. } inversion H4; monad_inv; subst; clear H4. edestruct (state_compat_write_inv) as (cb&Hlookupcb&Hcases); eauto. destruct Hcases as [(Hcbeq&Hcase1)|(Hneq&Hcase2)]. ** do 2 eexists; split_and!; eauto; []. repeat econstructor => //=. { rewrite lookup_insert //=. } { rewrite //=. destruct H as (Hheap&?). rewrite -Hheap //=. } { rewrite //=. simpl in * => //=. rewrite /RecordSet.set //=. rewrite insert_insert //=. f_equal; eauto. f_equal. destruct pσ2; f_equal; eauto. rewrite //=. rewrite //= in Hlookupcb. Unshelve. 2:{exact true. } rewrite /ADP.cblk_upd//=. rewrite insert_id; eauto. rewrite -Hcbeq. eauto. } ** do 2 eexists; split_and!; eauto; []. repeat econstructor => //=. { rewrite lookup_insert //=. } { rewrite //=. destruct H as (Hheap&?). rewrite -Hheap //=. } { rewrite //=. simpl in * => //=. rewrite /RecordSet.set //=. rewrite insert_insert //=. f_equal; eauto. f_equal. destruct pσ2; f_equal; eauto. rewrite //=. rewrite //= in Hlookupcb. Unshelve. 2:{exact false. } rewrite /ADP.cblk_upd//=. rewrite insert_id; eauto. rewrite Hlookupcb. f_equal. rewrite /RecordSet.set //= in Hcase2. destruct H as (_&Hdisk&_). simpl in Hdisk. destruct Hdisk as (?&Hval). edestruct (Hval) as (?&Hin&Hval'); eauto. { apply: lookup_insert. } rewrite Hlookupcb in Hval'. inversion Hval'. rewrite //=. } * rewrite /head_step//= in Hstep. destruct_head. inversion Hstep; monad_inv. clear Hstep. destruct_head. inversion H1; monad_inv; clear H1. do 2 eexists; split_and!; eauto. econstructor; eauto; repeat (econstructor; eauto). do 2 f_equal. erewrite state_compat_disk_size; eauto. * rewrite /head_step//= in Hstep. destruct_head. inversion Hstep; monad_inv. clear Hstep. destruct_head. inversion H1; monad_inv; clear H1. exists pσ2. edestruct (state_compat_post_flush_inv); eauto. eexists; split_and!; eauto. econstructor; eauto; repeat (econstructor; eauto). rewrite decide_True //. - rewrite /head_step//= in Hstep. inversion Hstep; monad_inv. inversion H; monad_inv; clear H. inversion H0; monad_inv; clear H0. inversion H3; monad_inv; clear H3. exists ({| heap := heap σ1; oracle := oracle σ1; trace := trace σ1; world := world pσ2 |}). eexists ({| used_proph_id := used_proph_id g1 |}). inversion H4. inversion H5. intuition. ** simpl in *. split_and!; eauto. ** split_and!; eauto. ** econstructor. *** repeat (econstructor; eauto). *** rewrite H16. repeat econstructor => //=. f_equal. destruct pσ2, pg2; subst. simpl in * => //=. rewrite /state_init_heap/state_insert_list. rewrite /RecordSet.set //=. do 2 f_equal; eauto. rewrite -H7 H6. done. - rewrite /head_step//= in Hstep. destruct_head. do 2 eexists. intuition; eauto. repeat (econstructor; eauto). Qed. Theorem prim_step'_simulation e1 σ1 g1 κ e2 σ2 g2 efs : prim_step' e1 σ1 g1 κ e2 σ2 g2 efs → ∀ pg2 pσ2, state_compat σ2 pσ2 → global_compat g2 pg2 → ∃ pσ1 pg1, state_compat σ1 pσ1 ∧ global_compat g1 pg1 ∧ prim_step' e1 pσ1 pg1 κ e2 pσ2 pg2 efs. 
Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. 
Require Import Bool. Definition bool_not (b:bool) : bool := if b then false else true. Definition bool_xor (b b':bool) : bool := if b then bool_not b' else b'.Definition bool_and (b b':bool) : bool := if b then b' else false.Definition bool_or (b b':bool) := if b then true else b'. Definition bool_eq (b b':bool) := if b then b' else bool_not b'. Theorem bool_xor_not_eq : forall b1 b2:bool, bool_xor b1 b2 = bool_not (bool_eq b1 b2). Proof. destruct b1, b2; reflexivity. Qed.Theorem bool_not_and : forall b1 b2:bool, bool_not (bool_and b1 b2) = bool_or (bool_not b1) (bool_not b2). Proof. destruct b1, b2; reflexivity. Qed.Theorem bool_not_not : forall b:bool, bool_not (bool_not b) = b. Proof. now destruct b. Qed.Theorem bool_ex_middle : forall b:bool, bool_or b (bool_not b) = true. Proof. now destruct b. Qed.Theorem bool_eq_reflect : forall b1 b2:bool, bool_eq b1 b2 = true -> b1 = b2. Proof. destruct b1, b2; (reflexivity || discriminate). Qed.Theorem bool_eq_reflect2 : forall b1 b2:bool, b1 = b2 -> bool_eq b1 b2 = true. Proof. destruct b1, b2; trivial; discriminate. Qed.Theorem bool_not_or : forall b1 b2:bool, bool_not (bool_or b1 b2) = bool_and (bool_not b1) (bool_not b2). Proof. now destruct b1, b2. Qed. Theorem bool_or_and_distr : forall b1 b2 b3:bool, bool_or (bool_and b1 b3) (bool_and b2 b3) = bool_and (bool_or b1 b2) b3. 
Require Export Max. Require Export Min. Require Export Sets.Ensembles.Module JoinSemiLattice. Inductive lbool : Type := | LBoolValue : bool -> lbool.Hint Constructors lbool.Definition lbool_reveal lb := match lb with | LBoolValue b => b end.Definition lbool_merge lb1 lb2 := match (lb1, lb2) with | (LBoolValue b1, LBoolValue b2) => (LBoolValue (orb b1 b2)) end. Theorem lbool_merge_assoc : forall (lb1 lb2 lb3 : lbool), lbool_merge (lbool_merge lb1 lb2) lb3 = lbool_merge lb3 (lbool_merge lb1 lb2). 
(k & Hu); try lia. destruct Pell_alpha_nat with (3 := H43) as (m & Hs & Hr); try lia. destruct Pell_alpha_nat' with (2 := H50) as (n & Hx); try lia. destruct (@division_by_even n (S m)) as (l & j & Hlj); try lia. assert (divides (k*u) (S m)) as H60'. { subst u s; apply alpha_nat_divisibility_2; try lia; auto. } assert (divides u (S m)) as H60. { apply divides_trans with (2 := H60'), divides_mult, divides_refl. } assert (v = alpha_nat b (S (S m)) - alpha_nat b m) as H61. { rewrite alpha_nat_fix_2, <- Hs, <- Hr; lia. } assert (rem x v = rem (alpha_nat b n) v) as H62_1. { rewrite Hx; apply alpha_nat_congruence_0; lia. } assert (rem x u = rem n u) as H65. { rewrite Hx, alpha_nat_congruence_0 with (3 := H48); try lia. f_equal; apply alpha_nat_2; auto. } assert (2 <= b) as Hb by lia. generalize (alpha_nat_2lm Hb H61 Hlj); intros H62_2. assert (2*alpha_nat b j < v) as H63. { apply le_lt_trans with ((b-2)*alpha_nat b (S m)). { apply mult_le_compat; try lia. red in Hlj; apply alpha_nat_mono; tauto. } apply plus_lt_reg_l with (2*r). rewrite (plus_comm _ v), H46, Hr, Hs. replace b with (2+(b-2)) at 4 by lia. rewrite Nat.mul_add_distr_r. apply plus_lt_le_compat; auto. apply mult_lt_compat_l; auto. apply alpha_nat_inc; auto. } rewrite plus_comm, <- rem_plus_rem, <- H62_1, <- H53, rem_plus_rem, plus_comm in H62_2. apply rem_eq_diff_eq in H62_2; auto. assert (2*j < u) as H66. { apply le_lt_trans with (2 := H51), mult_le_compat; auto. subst; apply alpha_nat_ge_n; auto. } rewrite <- H55 in H65. assert (c = j) as H67. { destruct H60 as (q & Hq). destruct Hlj as (G1 & [ G2 | (G2 & G3) ]). + apply rem_eq_diff_eq with u; auto. left. rewrite H65, rem_erase with (n := 2*l*q) (r := j); auto. rewrite G2, Hq; ring. + apply rem_eq_diff_eq with u; auto. right. rewrite plus_comm, <- rem_plus_rem, H65, rem_plus_rem, G3. apply rem_prop with (2*l*q); try lia. rewrite Hq, mult_assoc. assert (2*l*q <> 0) as G4. { intros H. apply mult_is_O in H; destruct H as [ H | H ]; try (subst; discriminate). apply mult_is_O in H; destruct H; lia. } assert (1*u <= 2*l*q*u). { apply mult_le_compat; auto. revert G4; generalize (2*l*q); intros; lia. } rewrite Nat.mul_1_l in H. revert H; generalize (2*l*q*u); intros; lia. } subst; auto. Qed.End diophantine_sufficiency.Section diophantine_necessity. Variables (a b c : nat). Theorem alpha_necessity : 3 < b /\ a = alpha_nat b c -> exists u t r s v w x y, alpha_conditions a b c u t r s v w x y. 
Hsf; subst; rename H5 into He; rename H6 into Hsfbr. - eapply is_true_equiv in He; eauto. exfalso; eapply is_true_is_false; eauto. - edestruct IHRunsTo as [IHRunsTo' ?]; eauto. edestruct IHRunsTo' as [s_st' [Hsst' Heq']]; eauto. exists s_st'; split. + eapply RunsToIfFalse; eauto. + eauto. } { inject Hcomp. copy_as Hsyn Hsyn'. eapply is_syntax_ok_while_elim in Hsyn. destruct Hsyn as [Hsyne Hsynb]. inversion Hsf; unfold_all; subst. - edestruct IHRunsTo1 as [IHRunsTo1' ?]; eauto. edestruct IHRunsTo1' as [s_st' [Hsst' Heq']]; eauto. edestruct IHRunsTo2 as [IHRunsTo2' ?]; eauto. edestruct (IHRunsTo2' (While e s)) as [s_st'' [Hsst'' Heq'']]; try eapply Heq'; eauto. exists s_st''; split. + eapply RunsToWhileTrue; eauto. + eauto. - rename H5 into He. eapply is_false_equiv in He; eauto. exfalso; eapply is_true_is_false; eauto. } { inject Hcomp. eapply is_syntax_ok_while_elim in Hsyn. destruct Hsyn as [Hsyne Hsynb]. inversion Hsf; unfold_all; subst. - rename H2 into He. eapply is_true_equiv in He; eauto. exfalso; eapply is_true_is_false; eauto. - exists s_st; split. + eapply RunsToWhileFalse; eauto. + eauto. } { inject Hcomp. rename s into x. rename H into He. rename H0 into Hnadt. rename H1 into Hst'. eapply is_syntax_ok_assign_elim in Hsyn. destruct Hsyn as [Hsynx Hsyne]. erewrite <- eval_equiv in He by eauto. erewrite <- not_mapsto_adt_equiv in Hnadt by eauto. exists (add x (SCA w) s_st); split. - eapply RunsToAssign; eauto. - rewrite Hst'. eapply add_equiv; eauto. } { unfold_all. intros x' f' args' f_w' spec' input' t_callee_st' ret' Heq Hfw Hspec Hmm Hsfb Hrtb Hret Hnadt Hst''2. inject Heq. unif (@SCA ADTValue f_w'). rename H1 into Hspec'. rewrite Hspec' in Hspec. discriminate. } { unfold_all. intros x' f' args' f_w' spec' input' t_callee_st' ret' Heq Hfw Hspec Hmm Hsfb Hrtb Hret' Hnadt Hst''2. inject Heq. unif (@SCA ADTValue f_w'). rename H1 into Hspec'. rewrite Hspec in Hspec'. rename H6 into Hret. inject Hspec'. unif input'. destruct spec'; simpl in *. edestruct IHRunsTo as [IHRunsTo' trash]; eauto. edestruct IHRunsTo' as [s_callee_st' [Hstb Hscst']]; eauto. { eapply equiv_refl. eapply args_name_ok_make_map; eauto. } rename H8 into Hst''. rewrite Hst'' in Hst''2. eapply add_add_remove_many_eq_elim in Hst''2; eauto; try (rewrite map_length; eauto). destruct Hst''2 as [Hreteq Houteq]. exists s_callee_st'. repeat try_split; eauto. { rewrite (map_find_equiv s_callee_st' callee_st') by eauto. eauto. } { unfold sel in *. rewrite (find_equiv s_callee_st' callee_st') by eauto. rewrite Hret. rewrite Hret'. rewrite Hreteq. eauto. } { Arguments no_adt_leak_equiv st1 st2 [_] _ _ _ _ _ _ _. eapply (no_adt_leak_equiv _ callee_st'); eauto. } } Qed. Theorem compile_runsto t t_env t_st t_st' : FRunsTo t_env t t_st t_st' -> forall s_env, fenv_impls_env t_env s_env -> (forall s, t = compile s -> is_syntax_ok s = true -> forall s_st, Safe s_env s s_st -> s_st === t_st -> exists s_st', RunsTo s_env s s_st s_st' /\ s_st' === t_st'). 
Require Import iris.bi.bi.Module Type ERRORS. Section with_bi. Context {PROP : bi}. Parameter ERROR : forall {T : Type}, T -> PROP. Parameter UNSUPPORTED : forall {T : Type}, T -> PROP. Parameter ERROR_elim : forall {T} (t : T), ERROR t ⊢ False. Parameter UNSUPPORTED_elim : forall {T} (t : T), UNSUPPORTED t ⊢ False. End with_bi. End ERRORS.Module Errors : ERRORS. Section with_bi. Context {PROP : bi}. Definition ERROR : forall {T : Type}, T -> PROP := fun _ _ => False%I. Definition UNSUPPORTED : forall {T : Type}, T -> PROP := fun _ _ => False%I. Theorem ERROR_elim : forall {T} (t : T), ERROR t ⊢ False. 
ii r) end end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. induction i; simpl; auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x. Proof. induction i; destruct m; simpl; auto. Qed. Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None. Proof. exact gempty. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. induction i; intros; destruct j; destruct m; simpl; try rewrite <- (gleaf A i); auto; try apply IHi; congruence. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then Some x else get i m. Proof. intros. destruct (peq i j); [ rewrite e; apply gss | apply gso; auto ]. Qed. Theorem gsident: forall (A: Type) (i: positive) (m: t A) (v: A), get i m = Some v -> set i v m = m. Proof. induction i; intros; destruct m; simpl; simpl in H; try congruence. rewrite (IHi m2 v H); congruence. rewrite (IHi m1 v H); congruence. Qed. Theorem set2: forall (A: Type) (i: elt) (m: t A) (v1 v2: A), set i v2 (set i v1 m) = set i v2 m. Proof. induction i; intros; destruct m; simpl; try (rewrite IHi); auto. Qed. Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf. Proof. destruct i; simpl; auto. Qed. Theorem grs: forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None. Proof. induction i; destruct m. simpl; auto. destruct m1; destruct o; destruct m2 as [ | ll oo rr]; simpl; auto. rewrite (rleaf A i); auto. cut (get i (remove i (Node ll oo rr)) = None). destruct (remove i (Node ll oo rr)); auto; apply IHi. apply IHi. simpl; auto. destruct m1 as [ | ll oo rr]; destruct o; destruct m2; simpl; auto. rewrite (rleaf A i); auto. cut (get i (remove i (Node ll oo rr)) = None). destruct (remove i (Node ll oo rr)); auto; apply IHi. apply IHi. simpl; auto. destruct m1; destruct m2; simpl; auto. Qed. Theorem gro: forall (A: Type) (i j: positive) (m: t A), i <> j -> get i (remove j m) = get i m. 
fold t; rewrite Hulpt; right; field. } apply (Rle_trans _ (u_ro / sqrt (1 + 4 * u_ro))). { apply (Rle_trans _ (u_ro * bpow e / (sqrt (1 + 4 * u_ro) * bpow e))). { unfold Rdiv; apply Rmult_le_compat_l; [now apply Rmult_le_pos; [apply Peps|apply bpow_ge_0]|]. apply Rinv_le. { apply Rmult_lt_0_compat; [apply sqrt_lt_R0; lra|apply bpow_gt_0]. } now rewrite Ht; apply Rmult_le_compat_r; [apply bpow_ge_0|apply sqrt_le_1_alt]. } right; field; split; apply Rgt_not_eq, Rlt_gt; [apply sqrt_lt_R0; lra|apply bpow_gt_0]. } apply sqrt_error_N_FLX_aux3. } revert H; unfold Rdiv; rewrite Rabs_mult, Rabs_Rinv; [|fold t; lra]; intro H. apply (Rmult_le_reg_r (/ Rabs (sqrt x))); [apply Rinv_0_lt_compat, Rabs_pos_lt; fold t; lra|]. apply (Rle_trans _ _ _ H); right; field; split; [apply Rabs_no_R0;fold t|]; lra. Qed.Theorem sqrt_error_N_FLX_ex x (Fx : format x) : exists eps, (Rabs eps <= 1 - 1 / sqrt (1 + 2 * u_ro))%R /\ round beta (FLX_exp prec) (Znearest choice) (sqrt x) = (sqrt x * (1 + eps))%R. Proof. now apply relative_error_le_conversion; [apply valid_rnd_N|apply om1ds1p2u_ro_pos|apply sqrt_error_N_FLX]. Qed.Lemma sqrt_error_N_round_ex_derive : forall x rx, (exists eps, (Rabs eps <= 1 - 1 / sqrt (1 + 2 * u_ro))%R /\ rx = (x * (1 + eps))%R) -> exists eps, (Rabs eps <= sqrt (1 + 2 * u_ro) - 1)%R /\ x = (rx * (1 + eps))%R. Proof. intros x rx (d, (Bd, Hd)). assert (H := Rabs_le_inv _ _ Bd). assert (H' := om1ds1p2u_ro_le_u_rod1pu_ro). assert (H'' := u_rod1pu_ro_le_u_ro beta prec). assert (H''' := u_ro_lt_1 beta prec prec_gt_0_). assert (Hpos := s1p2u_rom1_pos). destruct (Req_dec rx 0) as [Zfx|Nzfx]. { exists 0%R; split; [now rewrite Rabs_R0|]. rewrite Rplus_0_r, Rmult_1_r, Zfx; rewrite Zfx in Hd. destruct (Rmult_integral _ _ (sym_eq Hd)); lra. } destruct (Req_dec x 0) as [Zx|Nzx]. { now exfalso; revert Hd; rewrite Zx; rewrite Rmult_0_l. } set (d' := ((x - rx) / rx)%R). assert (Hd' : (Rabs d' <= sqrt (1 + 2 * u_ro) - 1)%R). { unfold d'; rewrite Hd. replace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra]. unfold Rdiv; rewrite Rabs_mult, Rabs_Ropp. rewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra]. apply (Rmult_le_reg_r (1 + d)); [lra|]. rewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra]. apply (Rle_trans _ _ _ Bd). apply (Rle_trans _ ((sqrt (1 + 2 * u_ro) - 1) * (1/sqrt (1 + 2 * u_ro)))); [right; field|apply Rmult_le_compat_l]; lra. } now exists d'; split; [exact Hd'|]; unfold d'; field. Qed. Theorem sqrt_error_N_FLX_round_ex : forall x, format x -> exists eps, (Rabs eps <= sqrt (1 + 2 * u_ro) - 1)%R /\ sqrt x = (round beta (FLX_exp prec) (Znearest choice) (sqrt x) * (1 + eps))%R. 
ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. Admitted. Theorem leb_refl : forall n:nat, true = leb n n. Admitted. Theorem zero_nbeq_S : forall n:nat, beq_nat 0 (S n) = false. Admitted. Theorem andb_false_r : forall b : bool, andb b false = false. Admitted. Derive ArbitrarySizedSuchThat for (fun m => le n m). Derive SizeMonotonicSuchThatOpt for (fun m => le n m). Derive GenSizedSuchThatSizeMonotonicOpt for (fun m => le n m). Derive SizedProofEqs for (fun m => le n m). Derive GenSizedSuchThatCorrect for (fun m => le n m).Theorem plus_ble_compat_l : forall n m p : nat, leb n m = true -> leb (p + n) (p + m) = true. Admitted.Theorem S_nbeq_0 : forall n:nat, beq_nat (S n) 0 = false. Admitted. Theorem mult_1_l : forall n:nat, 1 * n = n. Admitted. Theorem all3_spec : forall b c : bool, orb (andb b c) (orb (negb b) (negb c)) = true. Admitted. Theorem mult_plus_distr_r : forall n m p : nat, (n + m) * p = (n * p) + (m * p). 
with Some x => f x | _ => None end) (match PTree.get i t with Some x => f x | _ => None end). Proof. intros. destruct (s ! i) eqn:?H; [ | apply I]. pose proof (PTree.elements_correct s i H0). rewrite Forall_forall in H. apply H in H1. simpl in H1. rewrite H1. apply sub_option_refl. Qed.Lemma sub_option_get {A: Type} (s t: PTree.t A): Forall (fun x => PTree.get (fst x) t = Some (snd x)) (PTree.elements s) -> forall i, sub_option (PTree.get i s) (PTree.get i t). Proof. intros; specialize (sub_option_get' s t A Some H i); intros. destruct (s!i); [simpl; destruct (t!i); inv H0 | ]; trivial. Qed. Lemma tycontext_sub_nofunc_tycontext: forall V1 G1 V2 G2, (forall id, sub_option (make_tycontext_g V1 G1) ! id (make_tycontext_g V2 G2) ! id) -> (forall id, sub_option (make_tycontext_s G1) ! id (make_tycontext_s G2) ! id) -> tycontext_sub (nofunc_tycontext V1 G1) (nofunc_tycontext V2 G2). Proof. intros. split3; [ | | split3]; simpl; auto. intros; destruct ((PTree.empty type) ! id); auto. split. intros; apply semax_prog.sub_option_subsumespec; auto. intros; apply Annotation_sub_refl. Qed.Ltac adapt_module module := match type of module with @semax_func _ _ _ ?cs _ _ _ => eapply @semax_func_subsumption; [ | | eapply (@semax_func_mono _ cs); [ | | | apply module]]; [ | | | intros; apply sub_option_refl | intros; apply sub_option_refl]; [ | apply @sub_option_get; repeat (apply Forall_cons; [reflexivity | ]); apply Forall_nil | red; red; apply @sub_option_get; repeat (apply Forall_cons; [reflexivity | ]); apply Forall_nil] end; apply tycontext_sub_nofunc_tycontext; apply sub_option_get; repeat (apply Forall_cons; [reflexivity | ]); apply Forall_nil.Module FunspecOrder <: Orders.TotalLeBool. Definition t := (ident * funspec)%type. Definition leb := fun x y : (ident * funspec)=> Pos.leb (fst x) (fst y). Theorem leb_total : forall a1 a2, leb a1 a2 = true \/ leb a2 a1 = true. Proof. intros. unfold leb. pose proof (Pos.leb_spec (fst a1) (fst a2)). pose proof (Pos.leb_spec (fst a2) (fst a1)). inv H; inv H0; auto. clear - H2 H3. pose proof (Pos.lt_trans _ _ _ H2 H3). apply Pos.lt_irrefl in H. contradiction. Qed. End FunspecOrder. Module SortFunspec := Mergesort.Sort(FunspecOrder).Definition ident_of_proof (p: semax_body_proof) : ident := match p with | @mk_body _ _ _ _ id _ _ => id | @mk_external id _ _ _ _ _ _ _ _ => id end.Module BodyProofOrder <: Orders.TotalLeBool. Definition t := semax_body_proof. Definition leb := fun x y : semax_body_proof=> Pos.leb (ident_of_proof x) (ident_of_proof y). Theorem leb_total : forall a1 a2, leb a1 a2 = true \/ leb a2 a1 = true. 
Hl) k). omega. Qed.Theorem valid_exp_large' : forall k l, (fexp k < k)%Z -> (l <= k)%Z -> (fexp l < k)%Z. Proof. intros k l Hk H. apply Znot_ge_lt. intros H'. apply Zge_le in H'. assert (Hl := Zle_trans _ _ _ H H'). apply valid_exp in Hl. assert (H1 := proj2 Hl k H'). omega. Qed.Definition canonic_exp x := fexp (ln_beta beta x).Definition canonic (f : float beta) := Fexp f = canonic_exp (F2R f).Definition scaled_mantissa x := (x * bpow (- canonic_exp x))%R.Definition generic_format (x : R) := x = F2R (Float beta (Ztrunc (scaled_mantissa x)) (canonic_exp x)). Theorem generic_format_0 : generic_format 0. Proof. unfold generic_format, scaled_mantissa. rewrite Rmult_0_l. change (Ztrunc 0) with (Ztrunc (Z2R 0)). now rewrite Ztrunc_Z2R, F2R_0. Qed.Theorem canonic_exp_opp : forall x, canonic_exp (-x) = canonic_exp x. Proof. intros x. unfold canonic_exp. now rewrite ln_beta_opp. Qed.Theorem canonic_exp_abs : forall x, canonic_exp (Rabs x) = canonic_exp x. Proof. intros x. unfold canonic_exp. now rewrite ln_beta_abs. Qed.Theorem generic_format_bpow : forall e, (fexp (e + 1) <= e)%Z -> generic_format (bpow e). Proof. intros e H. unfold generic_format, scaled_mantissa, canonic_exp. rewrite ln_beta_bpow. rewrite <- bpow_plus. rewrite <- (Z2R_Zpower beta (e + - fexp (e + 1))). rewrite Ztrunc_Z2R. rewrite <- F2R_bpow. rewrite F2R_change_exp with (1 := H). now rewrite Zmult_1_l. now apply Zle_minus_le_0. Qed.Theorem generic_format_bpow' : forall e, (fexp e <= e)%Z -> generic_format (bpow e). Proof. intros e He. apply generic_format_bpow. destruct (Zle_lt_or_eq _ _ He). now apply valid_exp_. rewrite <- H. apply valid_exp. rewrite H. apply Zle_refl. Qed.Theorem generic_format_F2R : forall m e, ( m <> 0 -> canonic_exp (F2R (Float beta m e)) <= e )%Z -> generic_format (F2R (Float beta m e)). Proof. intros m e. destruct (Z_eq_dec m 0) as [Zm|Zm]. intros _. rewrite Zm, F2R_0. apply generic_format_0. unfold generic_format, scaled_mantissa. set (e' := canonic_exp (F2R (Float beta m e))). intros He. specialize (He Zm). unfold F2R at 3. simpl. rewrite F2R_change_exp with (1 := He). apply F2R_eq_compat. rewrite Rmult_assoc, <- bpow_plus, <- Z2R_Zpower, <- Z2R_mult. now rewrite Ztrunc_Z2R. now apply Zle_left. Qed.Lemma generic_format_F2R': forall (x:R) (f:float beta), F2R f = x -> ((x <> 0)%R -> (canonic_exp x <= Fexp f)%Z) -> generic_format x. Proof. intros x f H1 H2. rewrite <- H1; destruct f as (m,e). apply generic_format_F2R. simpl in *; intros H3. rewrite H1; apply H2. intros Y; apply H3. apply F2R_eq_0_reg with beta e. now rewrite H1. Qed. Theorem canonic_opp : forall m e, canonic (Float beta m e) -> canonic (Float beta (-m) e). 
Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_r prod_monoid. Theorem recipr_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_sum_distrib : is_distrib E prod sum. Proof conj prod_sum_distrib_l prod_sum_distrib_r. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof fun x => let H : (0 # x) + (0 # x) = (0 # x) + 0 := eq_refl (0 # x) || a # x = 0 # x @a by (sum_id_l 0) || a = 0 # x @a by <- prod_sum_distrib_r x 0 0 || (0 # x) + (0 # x) = a @a by sum_id_r (0 # x) in sum_cancel_l (0 # x) 0 (0 # x) H. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof fun x => let H : (x # 0) + (x # 0) = 0 + (x # 0) := eq_refl (x # 0) || x # a = x # 0 @a by sum_id_r 0 || a = x # 0 @a by <- prod_sum_distrib_l x 0 0 || (x # 0) + (x # 0) = a @a by sum_id_l (x # 0) in sum_cancel_r (x # 0) 0 (x # 0) H. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof ex_ind (fun x (H : x # 0 = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_r x)). Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof ex_ind (fun x (H : 0 # x = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_l x)). Theorem prod_0_inv : ~ prod_has_inv 0. Proof ex_ind (fun x H => prod_0_inv_l (ex_intro (fun x => prod_is_inv_l 0 x) x (proj1 H))). Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof fun x y H (H0 : y = 0) => distinct_0_1 (proj1 H || a # x = 1 @a by <- H0 || a = 1 @a by <- prod_0_l x). Definition E_n1_strong : { x : E | sum_is_inv 1 x } := constructive_definite_description (sum_is_inv 1) (sum_inv_uniq_ex 1). Definition E_n1 : E := proj1_sig E_n1_strong. Notation "{-1}" := E_n1 : ring_scope. Theorem E_n1_def : sum_is_inv 1 {-1}. Proof proj2_sig E_n1_strong. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof proj1 E_n1_def. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof proj2 E_n1_def. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. 
E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. Proof Ring.prod_inv_l_r_eq ring. Theorem prod_inv_sym : forall x y : E, prod_is_inv x y <-> prod_is_inv y x. Proof Ring.prod_inv_sym ring. Theorem prod_cancel_l : forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y. Proof Ring.prod_cancel_l ring. Theorem prod_cancel_r : forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y. Proof Ring.prod_cancel_r ring. Theorem prod_inv_l_uniq : forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Ring.prod_inv_l_uniq ring. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Ring.prod_inv_r_uniq ring. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Ring.prod_inv_uniq ring. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Ring.prod_inv_1 ring. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Ring.prod_has_inv_l_1 ring. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Ring.prod_has_inv_r_1 ring. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof Ring.prod_0_inv_r ring. Theorem prod_0_inv : ~ prod_has_inv 0. Proof Ring.prod_0_inv ring. Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof Ring.prod_inv_0 ring. Definition E_n1_strong : { x : E | sum_is_inv 1 x } := Ring.E_n1_strong ring. Definition E_n1 : E := Ring.E_n1 ring. Notation "{-1}" := E_n1 : commutative_ring_scope. Definition E_n1_def : sum_is_inv 1 {-1} := Ring.E_n1_def ring. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. 
:= pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. 2: apply canonical_pluspf with (1 := os); auto. 2: apply canonical_mults with (1 := cs); auto. 2: apply inPolySet_imp_canonical with (L := R); auto. 2: apply CombLinear_canonical with (eqA_dec := eqA_dec) (ltM_dec := ltM_dec) (1 := cs) (Q := R); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply CombLinear_pluspf with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. 2: apply H'3 with (b := b); auto. case (inPolySet_addEnd q b Q); auto. rewrite <- H'5; auto. intros H'7; rewrite H'7; auto. intros; (apply CombLinear_id with (1 := cs); auto). Qed. Theorem Cb_trans : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a (addEnd b Q) -> Cb b Q -> Cb a Q. intros a b; case a; case b; simpl in |- *; auto. intros x c x0 H' Q H'0 H'1. apply CombLinear_trans1 with (R := addEnd (exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c) Q) (b := exist (fun l : list (Term A n) => canonical A0 eqA ltM l) x c); auto. Qed. Theorem Cb_incl : forall (a : poly A0 eqA ltM) (P Q : list (poly A0 eqA ltM)), (forall a : poly A0 eqA ltM, In a P -> In a Q) -> Cb a P -> Cb a Q. intros a; case a; simpl in |- *; auto. intros x H' P Q H'0 H'1. apply CombLinear_incl with (1 := cs) (P := P); auto. intros a0 H'2. apply Incl_inp_inPolySet with (P := P); auto. Qed. Theorem Cb_in1 : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a Q -> Cb a (b :: Q). intros a b Q H'. apply Cb_incl with (P := Q); simpl in |- *; auto. Qed. Theorem Cb_in : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a Q -> Cb a (addEnd b Q). intros a b Q H'. apply Cb_incl with (P := Q); simpl in |- *; auto. intros a0 H'0; apply addEnd_id2; auto. Qed. Theorem Cb_sp : forall (a b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a Q -> Cb b Q -> Cb (spolyp a b) Q. 
Require Import List. Require Import Arith. From Huffman Require Import Permutation. From Huffman Require Import sTactic. Section UniqueList. Variable A : Type. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Inductive ulist : list A -> Prop := | ulist_nil : ulist nil | ulist_cons : forall a l, ~ In a l -> ulist l -> ulist (a :: l). Hint Constructors ulist : core. Theorem ulist_inv : forall a l, ulist (a :: l) -> ulist l. Proof using. intros a l H; inversion H; auto. Qed. Theorem ulist_app : forall l1 l2, ulist l1 -> ulist l2 -> (forall a : A, In a l1 -> In a l2 -> False) -> ulist (l1 ++ l2). 
!lfunE ?rmorphM ?rmorph1. have [|nu cGnu Dnu] := kHom_to_gal _ (normalFieldf 1) hom_nu. by rewrite !subvf. exists nu => //; apply: (fmorph_inj QnC). rewrite -Dnu ?memvf // lfunE DnuQ rmorphX DnuC //. by rewrite prim_expr_order // fmorph_primitive_root. have{defQn} imItoQ: calG = ItoQ @: {:I}. apply/setP=> nu; apply/idP/imsetP=> [cGnu | [k _ ->] //]. have pr_nu_e: n.-primitive_root (nu eps) by rewrite fmorph_primitive_root. have [i Dnue] := prim_rootP pr_eps (prim_expr_order pr_nu_e). rewrite Dnue prim_root_exp_coprime // coprime_sym in pr_nu_e. apply: ex_intro2 (Sub i _) _ _ => //; apply/eqP. rewrite /calG /= -defQn in ItoQ inItoQ defItoQ nu cGnu Dnue *. by rewrite gal_adjoin_eq // defItoQ -Dnue. have injItoQ: {in {:I} &, injective ItoQ}. move=> k1 k2 _ _ /(congr1 (fun nu : gal_of _ => nu eps))/eqP. by apply: contraTeq; rewrite !defItoQ (eq_prim_root_expr pr_eps) !modn_small. pose pi1 := \prod_(s in S) chi s; pose pi2 := \prod_(s in S) `|chi s| ^+ 2. have Qpi1: pi1 \in Crat. have [a Da] := QnGg _ Nchi; suffices ->: pi1 = QnC (galNorm 1 {:Qn} a). have /vlineP[q ->] := mem_galNorm galQn (memvf a). by rewrite rmorphZ_num rmorph1 mulr1 Crat_rat. rewrite /galNorm rmorph_prod -/calG imItoQ big_imset //=. rewrite /pi1 -(eq_bigl _ _ imItoS) -big_uniq // big_map big_filter /=. apply: eq_bigr => k _; have [nuC DnuC] := gQnC (ItoQ k); rewrite DnuC Da. have [r ->] := char_sum_irr Nchi; rewrite !sum_cfunE rmorph_sum. apply: eq_bigr => i _; have /QnGg[b Db] := irr_char i. have Lchi_i: 'chi_i \is a linear_char by rewrite irr_cyclic_lin. have /(prim_rootP pr_eps)[m Dem]: b ^+ n = 1. apply/eqP; rewrite -(fmorph_eq1 QnC) rmorphX Db -lin_charX //. by rewrite -expg_mod_order orderE defG modnn lin_char1. rewrite -Db -DnuC Dem rmorphX /= defItoQ exprAC -{m}Dem rmorphX {b}Db. by rewrite lin_charX. clear I ItoS imItoS injItoS ItoQ inItoQ defItoQ imItoQ injItoQ. clear Qn galQn QnC gQnC eps pr_eps QnGg calG. have{Qpi1} Zpi1: pi1 \in Cint. by rewrite Cint_rat_Aint // rpred_prod // => s _; apply: Aint_char. have{pi1 Zpi1} pi2_ge1: 1 <= pi2. have ->: pi2 = `|pi1| ^+ 2. by rewrite (big_morph Num.norm (@normrM _) (@normr1 _)) -prodrXl. by rewrite Cint_normK // sqr_Cint_ge1 //; apply/prodf_neq0. have Sgt0: (#|S| > 0)%N by rewrite (cardD1 g) [g \in S]Sg. rewrite -mulr_natr -ler_pdivl_mulr ?ltr0n //. have n2chi_ge0 s: s \in S -> 0 <= `|chi s| ^+ 2 by rewrite exprn_ge0 ?normr_ge0. rewrite -(expr_ge1 Sgt0); last by rewrite divr_ge0 ?ler0n ?sumr_ge0. by rewrite (ler_trans pi2_ge1) // lerif_AGM. Qed. Theorem nonlinear_irr_vanish gT (G : {group gT}) i : 'chi[G]_i 1%g > 1 -> exists2 x, x \in G & 'chi_i x = 0. 
addZ (pos 0) y = succZ y. Proof. auto with arith. Qed.Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y). Proof. auto with arith. Qed.Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y. Proof. auto with arith. Qed.Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y). Proof. auto with arith. Qed. Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).intros; elim x.reflexivity.trivial.simple destruct n.simpl in |- *; symmetry in |- *; exact (succ_predZ y). intros; symmetry in |- *; rewrite addZ_eq5. apply succ_predZ. Qed. Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).intros; elim x.reflexivity.simple destruct n. simpl in |- *; rewrite pred_succZ; trivial. intros; rewrite addZ_eq3; rewrite pred_succZ; trivial. trivial. Qed. Lemma tech_add_pos_succZ : forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y). Proof addZ_eq3. Lemma tech_add_neg_predZ : forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y). Proof addZ_eq5. Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).intros; elim x.reflexivity.simple induction n.reflexivity.intros. do 2 rewrite (tech_add_pos_succZ n0). elim H; reflexivity.simple induction n.simpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.intros. do 2 rewrite (tech_add_neg_predZ n0). rewrite H. symmetry in |- *; apply succ_pred_pred_succZ. Qed. Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).intros; elim x.reflexivity.simple induction n.simpl in |- *; apply succ_pred_pred_succZ.intros. do 2 rewrite (tech_add_pos_succZ n0). rewrite H; apply succ_pred_pred_succZ.simple induction n.reflexivity.intros. do 2 rewrite (tech_add_neg_predZ n0). elim H; reflexivity. Qed. Lemma add_OZ : forall x : Z, addZ x OZ = x.simple induction x.reflexivity.simple induction n. reflexivity. intros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.simple induction n. reflexivity. intros; rewrite tech_add_neg_predZ; rewrite H; reflexivity. Qed. Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.intros. cut (succZ OZ = IZ); intros. elim H. rewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity. reflexivity. Qed. Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.intros. cut (predZ OZ = neg 0); intros. elim H. rewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity. reflexivity. Qed. Theorem addZ_commutativity : commutativity Z addZ.unfold commutativity in |- *; intros; elim x.simpl in |- *; symmetry in |- *; exact (add_OZ y).simple induction n.simpl in |- *; symmetry in |- *; exact (add_IZ_succZ y).intros; rewrite (tech_add_pos_succZ n0 y). 
⌝ ∗ Φ k v lv ∗ ∀ v' lv', Φ k v' lv' -∗ big_sepML Φ (<[k := v']> m) (<[i := lv']> l). Proof. iIntros (Hi) "Hml". rewrite big_sepML_eq /big_sepML_def. iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_lookup_l_some with "Hml") as (xm) "%"; eauto. iDestruct (big_sepM2_insert_acc with "Hml") as "[Hx Hml]"; eauto. eapply map_to_list_some_list in H1 as H1'; eauto. destruct H1'. iExists _, _. iSplitR; first by done. iFrame. iIntros (v' lv') "Hx". iSpecialize ("Hml" with "Hx"). iExists (<[k := lv']> lm). iFrame. iPureIntro. eapply map_to_list_insert_overwrite; eauto. Qed. Theorem big_sepML_mono Φ Ψ m l : big_sepML Φ m l -∗ ⌜ ∀ k v lv, Φ k v lv -∗ Ψ k v lv ⌝ -∗ big_sepML Ψ m l. Proof. rewrite big_sepML_eq; iIntros "Hml %". iDestruct "Hml" as (lm) "[% Hml]". iExists lm; iSplitR; first by eauto. iApply big_sepM2_mono; eauto. Qed. Theorem big_sepML_lookup_l_Some Φ m l i lv : l !! i = Some lv -> big_sepML Φ m l -∗ ⌜ ∃ k v, m !! k = Some v ⌝. Proof. iIntros (Hl) "Hml". iDestruct (big_sepML_lookup_l_acc with "Hml") as (k v) "[% Hml]"; eauto. Qed. Theorem big_sepML_lookup_m_Some Φ m l k v : m !! k = Some v -> big_sepML Φ m l -∗ ⌜ ∃ i lv, l !! i = Some lv ⌝. Proof. iIntros (Hm) "Hml". iDestruct (big_sepML_lookup_m_acc with "Hml") as (i lv) "[% Hml]"; eauto. Qed. Theorem big_sepML_empty_m Φ m : big_sepML Φ m [] -∗ ⌜ m =  ⌝. Proof. rewrite big_sepML_eq /big_sepML_def. iIntros "Hml". iDestruct "Hml" as (lm) "[% Hml]". destruct (map_to_list lm) eqn:Heq. - apply map_to_list_empty_iff in Heq; subst. iDestruct (big_sepM2_empty_l with "Hml") as %He. done. - simpl in *. apply Permutation_nil_cons in H0. eauto. Qed. Theorem big_sepML_empty_l Φ l : big_sepML Φ  l -∗ ⌜ l = [] ⌝. Proof. rewrite big_sepML_eq /big_sepML_def. iIntros "Hml". iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_empty_r with "Hml") as %He; subst. rewrite map_to_list_empty /= in H0. iPureIntro. eapply Permutation_nil_r. done. Qed. Theorem big_sepML_sep Φ Ψ m l : big_sepML (λ k v lv, Φ k v lv ∗ Ψ k v lv) m l -∗ big_sepML Φ m l ∗ big_sepML Ψ m l. Proof. iIntros "Hml". rewrite big_sepML_eq. iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_sep with "Hml") as "[Hml0 Hml1]". iSplitL "Hml0". { iExists _. iFrame. done. } { iExists _. iFrame. done. } Qed. Theorem big_sepML_sepM Φ (P : K -> V -> PROP) m l : big_sepML (λ k v lv, Φ k v lv ∗ P k v) m l ⊣⊢ big_sepML Φ m l ∗ big_opM _ P m. 
{E ⊏ F} + {¬ E ⊏ F}. Proof. assert (forall A, (forall w w' : A, { w = w' } + { ¬ w = w' }) -> forall ws ws' : list A, { ws = ws' } + { ¬ ws = ws' }) as Hdec. intros A Hyp. induction ws as [ | w ws IHws ]; induction ws' as [ | w' ws' IHws' ]; simpl in *; auto. right; intro Heq; inversion Heq. right; intro Heq; inversion Heq. destruct (Hyp w w'); destruct (IHws ws'). left; subst; auto. right; intro Heq; inversion Heq; auto. right; intro Heq; inversion Heq; auto. right; intro Heq; inversion Heq; auto. intros A E F Hok Hdec2. assert (forall ws ws' : list A, { ws = ws' } + { ¬ ws = ws' }) as Hdec3 by auto. assert (List.NoDup (dom E)) as Hdom by (apply ok_dom_inv; auto). elim all_binds_dec_exists with A (dom E) F; auto; intro Hyp. destruct Hyp as [ vs [ Hlen Habind ] ]. elim (Hdec3 vs (img E)); intro Hyp; subst. left. rewrite dom_img_id in *; auto. right. intro Habind2. rewrite <- (dom_img_id E) in Habind2. assert (vs = img E). apply all_binds_singles_eq_inv with (dom E) F; auto. apply length_dom_img_eq. auto. right. intro Habind. apply (Hyp (img E)). apply length_dom_img_eq. rewrite dom_img_id; auto. Qed.Theorem eq_refl : forall A (E F : gen_env A), E = F -> E ≍ F. Proof. unfold eq. intro. split; apply all_binds_refl; auto. Qed.Theorem eq_sym : forall A (E F : gen_env A), E ≍ F -> F ≍ E. Proof. unfold eq; intros A E F Heq; destruct Heq; split; auto. Qed.Theorem eq_trans : forall A (E F G : gen_env A), E ≍ F -> F ≍ G -> E ≍ G. Proof. unfold eq; intros A E F G Heq1 Heq2. destruct Heq1, Heq2. split; apply all_binds_trans with F; auto. Qed. Theorem eq_binds : forall A x (v : A) (E F : gen_env A), E ≍ F -> binds x v E -> binds x v F. Proof. intros A x v E F Heq Hbind. unfold eq in *. destruct Heq. auto. Qed. Theorem eq_concat : forall A (E F G : gen_env A), E ≍ F -> (E & G) ≍ (F & G). Proof. unfold eq; intros A E F G Heq. destruct Heq. split; apply all_binds_concat_compat; auto. Qed. Theorem eq_concat_comm : forall A (E F : gen_env A), ok (E & F) -> (E & F) ≍ (F & E). 
total. rewrite <- Htotal in *. repeat split; auto. { apply (Sum_transfer (st_balances S) total from to v (st_balances S')); auto with arith. } { exists creator. exists name. exists decimals. exists sym. inversion Hassert. exists x. apply assert_genesis_event_app; auto. } - unfold funcspec_balanceOf in H2. subst spec. simpl in *. destruct H5 as [Hx1 [Hx2 Hx3]]. rewrite H4 in Hx3. rewrite <- Hx3. split; auto. exists total. repeat split; auto. exists creator. exists name. exists decimals. exists sym. inversion Hassert. exists x. apply assert_genesis_event_app; auto. - unfold funcspec_approve in H1. subst spec. simpl in *. destruct H2 as [Hx1 [Hx2 [Hx3 [Hx4 [Hx5 [Hx6 [Hx7 Hx8]]]]]]]. rewrite <- Hx7 in *. split; auto. exists total. rewrite Hx3 in *. rewrite Hx7 in *. repeat split; auto. exists creator. exists name. exists decimals. exists sym. inversion Hassert. exists x. apply assert_genesis_event_app; auto. - unfold funcspec_allowance in H1. subst spec. simpl in *. destruct H2 as [Hx1 [Hx2 Hx3]]. subst S'. split; auto. exists total. simpl. repeat split; auto. exists creator. exists name. exists decimals. exists sym. inversion Hassert. exists x. apply assert_genesis_event_app; auto. - unfold funcspec_totalSupply in H1. subst spec. simpl in *. destruct H5 as [Hx1 [Hx2 Hx3]]. rewrite H4 in Hx3. rewrite <- Hx3. split. + auto. + exists total. repeat split; auto. exists creator. exists name. exists decimals. exists sym. inversion Hassert. exists x. apply assert_genesis_event_app; auto. - unfold funcspec_Burn in H1. subst spec. simpl in *. destruct H5 as [Hx1 [Hx2 Hx3]]. rewrite H4 in Hx3. destruct Hx3 as [Hx31 [Hx32 [Hx33 [Hx34 [Hx35 Hx36]]]]]. split. + rewrite Hx32. intros a. unfold a2v_upd_dec. destruct (beq_dec a (m_sender msg)). { rewrite Nat.eqb_eq in H1. subst a. rewrite (tmap_get_upd_eq _ _ _). generalize (Hblncs (m_sender msg)). intros Hs. rewrite H2 in Hx1. destruct Hx1. rewrite (minus_safe _ _ H1). omega. } { apply beq_sym in H1. rewrite (tmap_get_upd_ne _ _ _ _ H1). generalize (Hblncs a). intros. omega. } + exists (total-v). repeat split; auto. rewrite Hx31. auto. rewrite Hx32. rewrite H2 in Hx1. destruct Hx1. generalize H1. generalize Htv. apply Sum_dec. exists creator. exists name. exists decimals. exists sym. inversion Hassert. exists (v+x). assert (total - v + (v+x) = total+x). apply sub_add_add. rewrite H2 in Hx1. assert (total >= st_balances S (m_sender msg)). rewrite Htotal. apply Sum_ge. rewrite Htotal in Htv. auto. destruct Hx1. generalize H6. generalize H5. apply abc. rewrite H5. apply assert_genesis_event_app; auto. Qed. Theorem create_INV : forall env0 env C E, create env0 C E -> env_step env0 env -> INV env (w_st C) E. 
r at 1 in |- *; replace r with (r * 1%nat)%R; [ apply Rmult_le_compat_l | simpl; ring ]; auto with real arith. case (MinEx b radix precision) with (r := r); auto with arith; intros min Hmin. cut (Fbounded b (Float (Fnum min) (Zsucc (Fexp min)))); [ intros F2 | idtac ]. cut (FtoRradix (Float (Fnum min) (Zsucc (Fexp min))) = (radix * min)%R :>R); [ intros F2Eq | idtac ]. apply Rle_trans with (FtoRradix (Float (Fnum min) (Zsucc (Fexp min)))). case H'6. intros H'7 H'8; elim H'8; intros H'9 H'10; apply H'10; clear H'8; auto. case (Rle_or_lt r (Float (Fnum min) (Zsucc (Fexp min)))); auto; intros Rlt0. absurd (Float (Fnum min) (Zsucc (Fexp min)) <= min)%R. apply Rgt_not_le. rewrite F2Eq; auto with real. rewrite Rmult_comm. pattern (FtoRradix min) at 2 in |- *; replace (FtoRradix min) with (min * 1%nat)%R; auto with real. red in |- *; apply Rmult_lt_compat_l; auto with real arith. case (RleMinR0 r min); auto. intros H'8; case H'1. intros H'11; absurd (Float 1%nat (- dExp b) <= min)%R. apply Rgt_not_le; auto. rewrite <- H'8; auto. apply (MonotoneMin b radix) with (p := FtoRradix (Float 1%nat (- dExp b))) (q := r); auto. apply (RoundedModeProjectorIdem (isMin b radix)); auto. apply MinRoundedModeP with (precision := precision); auto. repeat split. simpl in |- *; auto with zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. simpl in |- *; auto with zarith. intros H'11; absurd (min = Float 1%nat (- dExp b) :>R). rewrite <- H'8. apply Rlt_dichotomy_converse; left; auto. apply (MinUniqueP b radix r); auto. rewrite <- H'11. apply (RoundedModeProjectorIdem (isMin b radix)); auto. apply MinRoundedModeP with (precision := precision); auto. repeat split. simpl in |- *; auto with zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. simpl in |- *; auto with zarith. case Hmin. intros H'8 H'11; elim H'11; intros H'12 H'13; apply H'13; clear H'11; auto. apply Rlt_le; auto. rewrite F2Eq. apply Rmult_le_compat_l; auto with real arith. replace 0%R with (INR 0); auto with real arith. apply isMin_inv1 with (1 := Hmin). unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite powerRZ_Zs; auto with real zarith; ring. cut (Fbounded b min); [ unfold Fbounded in |- *; intros Fb0 | case Hmin; auto ]. elim Fb0; intros H H0; auto. repeat (split; simpl in |- *); auto. apply Zle_trans with (Fexp min); auto with zarith. Qed. Theorem roundedModeMoreMult : forall (P : R -> float -> Prop) (p : float) (r : R), RoundedModeP b radix P -> P r p -> (r <= Float (- 1%nat) (- dExp b))%R -> (radix * r <= p)%R. 
apply andb_comm. } { repeat (red; intros; subst). auto. } rewrite allb_map. apply allb_ext. generalize (liftExpr_wt (types := types) tf tU nil nil G'' G' G). simpl. auto. Qed. Theorem WellTyped_hash : forall tf tp tU tG (s : SE.sexpr types pcType stateType), SE.WellTyped_sexpr tf tp tU tG s = WellTyped_sheap tf tp tU (rev (fst (hash s)) ++ tG) (snd (hash s)). Proof. clear. intros tf tp tU tG s. revert tG. induction s; simpl; intros; unfold WellTyped_sheap; simpl in *; think; auto. { destruct (is_well_typed tf tU tG e tvProp); auto. } { destruct (hash s1); destruct (hash s2); simpl in *. rewrite <- WellTyped_sheap_eq. rewrite <- WellTyped_sheap_star. rewrite rev_app_distr. rewrite app_ass. f_equal. rewrite (liftSHeap_wt tf tp tU nil (rev v0) (rev v ++ tG)). simpl. rewrite rev_length. reflexivity. rewrite (liftSHeap_wt tf tp tU (rev v0) (rev v) tG). repeat rewrite rev_length. reflexivity. } { destruct (hash s); simpl in *. destruct s0; simpl in *. rewrite WellTyped_sheap_eq. simpl. repeat rewrite app_ass; reflexivity. } { unfold WellTyped_impures, MM.mmap_add. simpl. rewrite andb_true_r. rewrite MF.PROPS.fold_add; eauto with typeclass_instances. rewrite MF.PROPS.fold_Empty; eauto using FM.empty_1 with typeclass_instances. destruct (nth_error tp f); auto. simpl. destruct (all2 (is_well_typed tf tU tG) l t); auto. repeat (red; intros); repeat match goal with | |- context [ match ?X with _ => _ end ] => destruct X | |- _ => rewrite Bool.andb_true_l | |- _ => rewrite Bool.andb_true_r | |- context [ allb ?A ?B ] => destruct (allb A B) end; try reflexivity. rewrite MF.FACTS.empty_in_iff; auto. } Qed. Definition applySHeap (F : expr types -> expr types) (sh : SHeap) : SHeap := {| impures := MM.mmap_map (map F) (impures sh) ; pures := map F (pures sh) ; other := other sh |}. Theorem applySHeap_defn : forall F sh, applySHeap F sh = {| impures := MM.mmap_map (map F) (impures sh) ; pures := map F (pures sh) ; other := other sh |}. Proof. reflexivity. Qed. Lemma starred_nil : forall T U G cs (F : T -> _) B, heq funcs preds U G cs (starred F nil B) B. Proof. clear. reflexivity. Qed. Lemma starred_cons : forall T U G cs (F : T -> _) a A B, heq funcs preds U G cs (starred F (a :: A) B) (Star (F a) (starred F A B)). Proof. clear. intros; rewrite starred_def. simpl. rewrite <- starred_def. reflexivity. Qed. Theorem applySHeap_spec : forall cs U G U' G' s F, (forall e t, exprD funcs U G e t = exprD funcs U' G' (F e) t) -> SE.ST.heq cs (sexprD funcs preds U G (sheapD s)) (sexprD funcs preds U' G' (sheapD (applySHeap F s))). 
clear H. dependent destruction H3; simpl. assert (prefix_pred (List.tl l) (state_stack_of_stack stack0)). unfold tl; destruct l; [constructor | inversion H2]... pose proof H. destruct H3. specialize (IHsymbols_to_pop stack0 A (action0 n) _ _ H4 H7 H H0 H6). revert IHsymbols_to_pop. fold (noninitstate_type x); generalize (pop symbols_to_pop stack0 (action0 n)). destruct r as [|[]]; intuition... destruct l; constructor... * apply n0. inversion H0; subst. inversion H; subst... Qed. Lemma prefix_ass: forall (l1 l2 l3:list symbol), prefix l1 l2 -> prefix l2 l3 -> prefix l1 l3. Proof. induction l1; intros. constructor. inversion H; subst. inversion H0; subst. constructor; eauto. Qed. Lemma prefix_pred_ass: forall (l1 l2 l3:list (state->bool)), prefix_pred l1 l2 -> prefix_pred l2 l3 -> prefix_pred l1 l3. Proof. induction l1; intros. constructor. inversion H; subst. inversion H0; subst. constructor; eauto. intro. specialize (H3 x). specialize (H4 x). destruct (f0 x); simpl in *; intuition. rewrite H4 in H3; intuition. Qed. Lemma reduce_step_stack_invariant_conserved stack prod buff: stack_invariant stack -> valid_for_reduce (state_of_stack init stack) prod -> match reduce_step init stack prod buff with | OK (Fail_sr | Accept_sr _ _) => True | OK (Progress_sr stack_new _) => stack_invariant stack_new | Err => False end. Proof with eauto. unfold valid_for_reduce. intuition. unfold reduce_step. pose proof (pop_stack_invariant_conserved (prod_rhs_rev prod) stack _ (prod_action' prod)). destruct (pop (prod_rhs_rev prod) stack (prod_action' prod)) as [|[]]. apply H0... destruct H0... pose proof (goto_head_symbs (state_of_stack init s) (prod_lhs prod)). pose proof (goto_past_state (state_of_stack init s) (prod_lhs prod)). unfold bind2. destruct H0. specialize (H2 _ H3)... destruct (goto_table (state_of_stack init stack0) (prod_lhs prod)) as [[]|]. constructor. simpl. constructor. eapply prefix_ass... unfold state_stack_of_stack; simpl; constructor. intro; destruct (singleton_state_pred x x0); reflexivity. eapply prefix_pred_ass... constructor... constructor... destruct stack0 as [|[]]... destruct (compare_eqdec (prod_lhs prod) (start_nt init))... apply n, H2, eq_refl. apply H2, eq_refl. Qed. Lemma step_stack_invariant_conserved (stack:stack) buffer: stack_invariant stack -> match step init stack buffer with | OK (Fail_sr | Accept_sr _ _) => True | OK (Progress_sr stack_new _) => stack_invariant stack_new | Err => False end. Proof with eauto. intro. unfold step. pose proof (shift_head_symbs (state_of_stack init stack)). pose proof (shift_past_state (state_of_stack init stack)). pose proof (reduce_ok (state_of_stack init stack)). destruct (action_table (state_of_stack init stack)). apply reduce_step_stack_invariant_conserved... destruct buffer as [[]]; simpl. specialize (H0 x); specialize (H1 x); specialize (H2 x). destruct (l x)... destruct H. constructor. unfold state_of_stack. constructor. eapply prefix_ass... unfold state_stack_of_stack; simpl; constructor. intro; destruct (singleton_state_pred s0 x0)... eapply prefix_pred_ass... constructor... constructor... apply reduce_step_stack_invariant_conserved... Qed. Theorem parse_no_err buffer n_steps: parse init buffer n_steps <> Err. 
Require Import List. From Huffman Require Import Aux. From Huffman Require Import Code. From Huffman Require Import Build. From Huffman Require Import ISort. Require Import Compare_dec. From Huffman Require Import Permutation. From Huffman Require Import UniqueKey. From Huffman Require Import sTactic. Section PBTree. Variable A : Type. Variable empty : A. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Inductive pbtree : Type := | pbleaf : A -> pbtree | pbleft : pbtree -> pbtree | pbright : pbtree -> pbtree | pbnode : pbtree -> pbtree -> pbtree. Theorem pbleaf_or_not : forall p, (exists a : _, p = pbleaf a) \/ (forall a : A, p <> pbleaf a). 
(Nat.log2 x) 6). assert (y = 5). assert (S y = 6). rewrite H. trivial. omega. rewrite H2. simpl. assert (x >= Nat.pow 2 6). rewrite <- e. eapply Nat.log2_spec. destruct (eq_nat_dec x 0). subst. rewrite log2_0 in H. omega. omega. eapply le_trans. 2:{ eapply H3. } simpl. omega. assert ( S (y + (y + y * y)) <= div2 x). eapply IHy. trivial. omega. assert (2 * y + 3 <= div2 x). eapply double_log_plus_3_le_h; trivial. omega. eapply le_trans. eapply plus_le_compat. eapply H2. eapply H3. eapply div2_ge_double. Qed.Theorem S_log_square_lt : forall x, Nat.pow 2 6 <= x-> S (Nat.log2 x) * S (Nat.log2 x) <= x. intuition. eapply S_log_square_lt_h; trivial. eapply le_trans. 2:{ eapply Nat.log2_le_mono. eapply H. } rewrite Nat.log2_pow2; omega. Qed.Theorem log_square_lt : forall x, Nat.pow 2 6 <= x-> Nat.log2 x * Nat.log2 x < x. intuition. assert (Nat.log2 x < S (Nat.log2 x)). omega. eapply lt_le_trans. eapply mult_lt_compat. eapply H0. eapply H0. eapply S_log_square_lt. trivial. Qed.Theorem poly_lt_exp_ge_6 : forall c x, x >= (Nat.pow 2 c) -> x >= (Nat.pow 2 6) -> Nat.pow x c < Nat.pow 2 x. intuition. specialize (Nat.log2_spec_alt); intuition. destruct (H1 x). eapply lt_le_trans. 2:{ eapply H. } eapply (expnat_2_ge_1 c). intuition. destruct (eq_nat_dec x0 0). rewrite e in H3. rewrite plus_0_r in *. rewrite H3. rewrite <- Nat.pow_mul_r. eapply Nat.pow_lt_mono_r. omega. rewrite <- H3. assert (c <= Nat.log2 x). eapply (@Nat.pow_le_mono_r_iff 2). omega. rewrite <- H3. trivial. eapply le_lt_trans. eapply mult_le_compat. eapply le_refl. eapply H4. eapply log_square_lt. eapply le_trans. 2:{ eapply H0. } eapply Nat.pow_le_mono_r. omega. omega. destruct (eq_nat_dec c 0). rewrite e. simpl. eapply le_lt_trans. assert (1 <= expnat 2 0). trivial. eapply H4. eapply Nat.pow_lt_mono_r. omega. omega. assert (expnat x c < expnat (2 ^ S (Nat.log2 x)) c). eapply Nat.pow_lt_mono_l. omega. eapply Nat.log2_spec. omega. eapply lt_le_trans. eapply H4. rewrite <- Nat.pow_mul_r. eapply Nat.pow_le_mono_r. omega. assert (c <= S (Nat.log2 x)). eapply (@Nat.pow_le_mono_r_iff 2). omega. eapply le_trans. eapply H. eapply lt_le_weak. eapply Nat.log2_spec. omega. eapply le_trans. eapply mult_le_compat. eapply le_refl. eapply H6. eapply S_log_square_lt. eapply le_trans. 2:{ eapply H0. } eapply Nat.pow_le_mono_r. omega. omega. Qed.Theorem poly_lt_exp : forall c, exists x, forall y, y >= x -> expnat y c < expnat 2 y. intuition. exists (expnat 2 (max c 6)). intuition. eapply poly_lt_exp_ge_6. eapply le_trans. 2:{ eapply H. } eapply Nat.pow_le_mono_r. omega. eapply Max.le_max_l. eapply le_trans. 2:{ eapply H. } eapply Nat.pow_le_mono_r. omega. eapply Max.le_max_r. Qed. Theorem negligible_exp_den : negligible (fun n => 1 / expnat 2 n)%rat. 
apply notin_single; auto. apply notin_single; auto. Qed.Theorem binds_remove_inv : forall A x y (v : A) (E : gen_env A), x <> y -> x ∹ v ⋲ (E ∖ {y}) -> x ∹ v ⋲ E. Proof. intros A x y v E Hneq Hbind. induction E as [ | E z w IHE ] using env_ind. rewrite remove_empty in Hbind. apply binds_empty in Hbind. inversion Hbind. destruct (eq_keys_dec y z); subst. rewrite remove_belongs_concat_r in Hbind. rewrite remove_single_eq in Hbind; auto. rewrite concat_empty_r in Hbind. apply binds_concat_l; auto. apply notin_single; auto. apply belongs_single; auto. destruct (eq_keys_dec x z); subst. rewrite remove_belongs_concat_l in Hbind. apply binds_concat_inv in Hbind. destruct Hbind as [ Hbind | [ Hnotin Hbind ] ]. apply binds_concat_r; auto. apply notin_single_inv in Hnotin. elim Hnotin; auto. apply notin_single; auto. rewrite remove_belongs_concat_l in Hbind. apply binds_concat_inv in Hbind. destruct Hbind as [ Hbind | [ Hnotin Hbind ] ]. apply binds_single_inv in Hbind. destruct Hbind; contradiction. apply binds_concat_l; auto. apply notin_single; auto. Qed.Theorem binds_all_remove : forall A x ys (v : A) (E : gen_env A), ¬ List.In x ys -> x ∹ v ⋲ E -> x ∹ v ⋲ (E ∖ ys). Proof. induction ys as [ | y ys IHys ]; intros; simpl in *; auto. rewrite all_remove_nil; auto. rewrite all_remove_remove. assert (y <> x ∧ ¬ List.In x ys) as Hnot. split; auto. destruct Hnot. apply IHys; auto. apply binds_remove; auto. Qed.Theorem binds_all_remove_inv : forall A x ys (v : A) (E : gen_env A), ¬ List.In x ys -> x ∹ v ⋲ (E ∖ ys) -> x ∹ v ⋲ E. Proof. induction ys as [ | y ys ]; intros v E Hnotin Hbind; simpl in *; auto. rewrite all_remove_nil in Hbind; auto. rewrite all_remove_remove in Hbind. assert (y <> x ∧ ¬ List.In x ys) as Hneq. split; auto. destruct Hneq. apply binds_remove_inv with y; auto. Qed. Theorem binds_concat_ok_comm : forall A x (v : A) (F G : gen_env A), binds x v (F & G) -> ok (F & G) -> binds x v (G & F). Proof. intros A x v F G Hbind Hok. apply binds_concat_inv in Hbind. destruct Hbind as [ Hbind | [ Hnotin Hbind ] ]. assert (x ∈ G) by (apply binds_belongs with v; auto). assert (x ∉ F) by (apply belongs_ok_concat_inv_r with G; auto). apply binds_concat_l; auto. apply binds_concat_r; auto. Qed. Theorem binds_dec_exists : forall A x (E : gen_env A), { v | x ∹ v ⋲ E } + { forall v, ¬ x ∹ v ⋲ E }. 
generalize dependent Denotation. generalize dependent Domain0. generalize dependent l. clear. induction l; simpl; intros; destruct Domain0; auto. inversion H; clear H; subst. revert H2. case_eq (exprD fs uvars vars a t); intros. erewrite H3 by eassumption. eauto. congruence. } Qed.Lemma applyD_weaken : forall types (funcs : functions types) l D R F U G UE GE v, applyD (exprD funcs U G) D l R F = Some v -> applyD (exprD funcs (U ++ UE) (G ++ GE)) D l R F = Some v. Proof. induction l; destruct D; simpl; intros; try congruence. consider (exprD funcs U G a t); intros. erewrite exprD_weaken by eauto. auto. congruence. Qed.Lemma Provable_weaken : forall types (fs : functions types) P U G UE GE, Provable fs U G P -> Provable fs (U ++ UE) (G ++ GE) P. Proof. unfold Provable; intros. consider (exprD fs U G P tvProp); intros; try contradiction. erewrite exprD_weaken; eauto. Qed.Lemma AllProvable_weaken : forall types (fs : functions types) U G UE GE P, AllProvable fs U G P -> AllProvable fs (U ++ UE) (G ++ GE) P. Proof. induction P; auto; intros; simpl in *; intuition eauto using Provable_weaken. Qed.Lemma liftExpr_ext : forall types (funcs : functions types) U U' U'' G G' G'' e t, exprD funcs (U'' ++ U) (G'' ++ G) e t = exprD funcs (U'' ++ U' ++ U) (G'' ++ G' ++ G) (liftExpr (length U'') (length U') (length G'') (length G') e) t. Proof. clear. induction e; simpl; intros; unfold lookupAs; think; try reflexivity; repeat match goal with | [ |- context [ NPeano.ltb ?X ?Y ] ] => consider (NPeano.ltb X Y); intros | [ |- _ ] => rewrite nth_error_app_L by omega | [ |- _ ] => rewrite nth_error_app_R by omega | [ |- match nth_error _ ?X with _ => _ end = match nth_error _ ?Y with _ => _ end ] => cutrewrite (X = Y); try (reflexivity || omega) end; auto. destruct (nth_error funcs f); auto. destruct (equiv_dec (Range s) t); auto. unfold equiv in *. subst. destruct s; simpl. generalize dependent Domain0; induction H; destruct Domain0; simpl; intros; think; auto. destruct (exprD funcs (U'' ++ U' ++ U) (G'' ++ G' ++ G) (liftExpr (length U'') (length U') (length G'') (length G') x) t); think; auto. Qed.Section exists_subst. Variable types : list type. Variable funcs : functions types. Theorem exprSubstU_spec : forall e a b c e', exprSubstU a b c e = e' -> forall A B C D t v, length B = a -> length B + length C = b -> length A = c -> exprD funcs A (B ++ C ++ D) e t = Some v -> exprD funcs (A ++ C) (B ++ D) e' t = Some v. 
specialize (H s x). specialize (H0 s m). eapply Imply_E. eapply valid_weaken. eapply H0. firstorder. propxIntuition. eauto. eapply Imply_E. eapply valid_weaken. eauto. firstorder. econstructor; firstorder. Qed. Theorem himp_subst_c : forall P Q R S, himp S Q -> himp P (star S R) -> himp P (star Q R). Proof. unfold himp, star, interp; intros. eapply Imply_I. eapply valid_extend. eapply Imply_E. eapply valid_weaken. specialize (H0 s m). eassumption. firstorder. eauto. propxIntuition; eauto. eapply Imply_E. eapply valid_weaken. eapply H. firstorder. econstructor; firstorder. Qed. Theorem heq_subst : forall P Q R S, heq P S -> heq (star S Q) R -> heq (star P Q) R. Proof. unfold heq. intros. intuition; generalize himp_subst_p; generalize himp_subst_c; eauto. Qed. Theorem himp_star_emp_p : forall P Q, himp P Q -> himp (star emp P) Q. Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply Imply_E. eapply valid_weaken; [ eapply H | firstorder ]. eapply HT.split_semp in H0; eauto; subst. propxIntuition. Qed. Theorem himp_star_emp_p' : forall P Q, himp (star emp P) Q -> himp P Q. Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply Imply_E. eapply valid_weaken; [ eapply H | firstorder ]. propxIntuition. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. Qed. Theorem himp_star_emp_c : forall P Q, himp P Q -> himp P (star emp Q). Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. eapply Imply_E. eapply valid_weaken; [ eapply H | firstorder ]. propxIntuition. Qed. Theorem himp_star_emp_c' : forall P Q, himp P (star emp Q) -> himp P Q. Proof. unfold emp, inj, star, himp, interp; intuition; propxIntuition. eapply valid_extend. eapply Imply_E. eapply valid_weaken. eapply (H s m). firstorder. econstructor; firstorder. propxIntuition. eapply HT.split_semp in H0; eauto; subst. propxIntuition. Qed. Theorem heq_star_emp_l : forall P, heq (star emp P) P. intros. unfold heq in *; intuition. eapply himp_star_emp_p. reflexivity. eapply himp_star_emp_c. reflexivity. Qed. Theorem heq_star_emp_r : forall P, heq (star P emp) P. Proof. intros. unfold heq, himp, star, emp, inj, interp in *; intuition. propxIntuition. eapply HT.split_comm in H. eapply HT.split_semp in H; eauto; subst. propxIntuition. propxIntuition. eapply HT.split_comm. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. Qed. Theorem himp_star_cancel : forall P Q R, himp Q R -> himp (star P Q) (star P R). intros. eapply himp_star_frame. reflexivity. auto. Qed. Theorem heq_star_cancel : forall P Q R, heq Q R -> heq (star P Q) (star P R). intros. eapply heq_star_frame. reflexivity. auto. Qed. Theorem himp_ex_p : forall T (P : T -> _) Q, (forall v, himp (P v) Q) -> himp (ex P) Q. 
Theorem injection_is_involution_in_Prop (f : Prop -> Prop) (inj : forall A B, (f A <-> f B) -> (A <-> B)) (ext : forall A B, A <-> B -> f A <-> f B) : forall A, f (f A) <-> A. 
sz)) start, let freelist := itemlist_to_freelist' bs start in ~In 0 freelist. Proof. induction bs; cbn; intuition. apply in_app_or in H. intuition eauto. eapply bits_to_freelist_no_zero; eauto. Qed. Lemma itemlist_to_freelist_bound: forall sz (bs : list (word sz)), let freelist := itemlist_to_freelist bs in forall x, In x freelist -> x < length (to_bits bs). Proof. cbn; unfold itemlist_to_freelist; intros. replace x with (0 + x) in H by omega. eapply itemlist_to_freelist'_bound in H. omega. Qed. Lemma itemlist_to_freelist_spec: forall sz (bs : list (word sz)), let freelist := itemlist_to_freelist bs in forall i, i <> 0 -> In i freelist <-> selN (to_bits bs) i inuse = avail. Proof. cbn; unfold itemlist_to_freelist; intros. replace i with (0 + i) in * by omega. auto using itemlist_to_freelist'_spec. Qed. Lemma itemlist_to_freelist_nodup: forall sz bs, let freelist := @itemlist_to_freelist sz bs in NoDup freelist. Proof. intros. apply itemlist_to_freelist'_nodup. Qed. Lemma itemlist_to_freelist_no_zero: forall sz bs, let freelist := @itemlist_to_freelist sz bs in ~In 0 freelist. Proof. intros. apply itemlist_to_freelist'_no_zero. Qed. Lemma freelist_bmap_equiv_itemlist_to_freelist_spec: forall sz (bs : list (word sz)) freelist, NoDup freelist -> freelist_bmap_equiv freelist (to_bits bs) -> permutation addr_eq_dec (itemlist_to_freelist bs) (remove addr_eq_dec 0 freelist). Proof. cbv [permutation freelist_bmap_equiv Avail]; intuition. pose proof (itemlist_to_freelist_nodup bs). rewrite (NoDup_count_occ addr_eq_dec) in *. pose proof count_occ_In as Hc. unfold gt in Hc. repeat match goal with | H: context [count_occ] |- _ => specialize (H x) end. destruct (in_dec addr_eq_dec 0 freelist). - destruct (addr_eq_dec 0 x); subst. rewrite count_occ_remove_eq. apply count_occ_not_In. apply itemlist_to_freelist_no_zero. repeat rewrite count_occ_remove_ne by auto. destruct (zerop (count_occ addr_eq_dec freelist x)) as [Ha | Ha]; destruct (zerop (count_occ addr_eq_dec (itemlist_to_freelist bs) x)) as [Hb | Hb]; try omega. all: rewrite <- count_occ_not_In, <- Hc in *. apply itemlist_to_freelist_spec in Hb. rewrite <- H2 in *. congruence. intro; subst. eapply itemlist_to_freelist_no_zero; eauto. destruct (addr_eq_dec x 0); subst; intuition. rewrite H2 in *. rewrite <- itemlist_to_freelist_spec in Ha by auto. intuition. - rewrite remove_not_In by auto. destruct (zerop (count_occ addr_eq_dec freelist x)) as [Ha | Ha]; destruct (zerop (count_occ addr_eq_dec (itemlist_to_freelist bs) x)) as [Hb | Hb]; try omega. all: rewrite <- count_occ_not_In, <- Hc in *. apply itemlist_to_freelist_spec in Hb. rewrite <- H2 in *. congruence. intro; subst. eapply itemlist_to_freelist_no_zero; eauto. destruct (addr_eq_dec x 0); subst; intuition. rewrite H2 in *. rewrite <- itemlist_to_freelist_spec in Ha by auto. intuition. Qed. Hint Extern 0 (okToUnify (listpred ?prd _ ) (listpred ?prd _)) => constructor : okToUnify. Theorem init_ok : forall V FP lxp xp ms, {< F Fm m0 sm m bl, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * arrayN (@ptsto _ _ _) (BMPStart xp) bl) ]]] * [[ xparams_ok xp /\ BMPStart xp <> 0 /\ length bl = BMPLen xp ]] POST:hm' RET:ms exists m' freelist freepred, LOG.rep lxp F (LOG.ActiveTxn m0 m') ms sm hm' * [[[ m' ::: (Fm * @rep V FP xp freelist freepred) ]]] * [[ forall bn, bn < (BMPLen xp) * valulen -> In bn freelist ]] * [[ forall dl, length dl = ((BMPLen xp) * valulen)%nat -> Forall FP dl -> arrayN (@ptsto _ _ _) 0 dl =p=> freepred ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init lxp xp ms. 
a |=> v. Proof. unfold cachepred; intros. case_eq (Map.find a m); intros; try destruct p, b. - rewrite sync_xform_exists_comm. apply pimpl_exists_l; intro. rewrite sync_xform_sep_star_dist, sync_xform_lift_empty. rewrite sync_xform_ptsto_subset_precise; simpl. cancel. apply in_cons; auto. - rewrite sync_xform_sep_star_dist, sync_xform_lift_empty. rewrite sync_xform_ptsto_subset_precise; simpl. cancel. - rewrite sync_xform_ptsto_subset_precise; cancel. Qed. Lemma sync_xform_mem_pred_cachepred : forall cm m, sync_xform (mem_pred (cachepred cm) m) =p=> exists m', mem_pred (cachepred (Map.empty (valu * bool))) m' * [[ possible_crash m m' ]]. Proof. intros. rewrite sync_xform_mem_pred. unfold mem_pred at 1. xform_norm; subst. rename hm_avs into l. revert H; revert l. induction l; simpl; intros. cancel. apply mem_pred_empty_mem. unfold possible_crash; intuition. inversion H; destruct a; subst; simpl in *. unfold mem_pred_one; simpl. rewrite IHl by auto. xform_norm. rewrite sync_xform_cachepred. norml; unfold stars; simpl. apply pimpl_exists_r. exists (upd m' n (v, nil)). rewrite <- mem_pred_absorb. unfold cachepred at 3; unfold ptsto_subset. rewrite MapFacts.empty_o; cancel. erewrite <- notindomain_mem_eq; auto. eapply possible_crash_notindomain; eauto. apply avs2mem_notindomain; auto. apply possible_crash_upd; eauto. Qed. Theorem init_recover_ok : forall cachesize, {< d F, PRE:hm exists cs, rep cs d * [[ F d ]] * [[ cachesize <> 0 ]] POST:hm' RET:cs exists d', rep cs d' * [[ (crash_xform F) d' ]] CRASH:hm' exists cs, rep cs d >} init_recover cachesize. Proof. unfold init_recover, init, rep. step. prestep; norml; unfold stars; simpl. rewrite sync_xform_sep_star_dist. rewrite sync_xform_mem_pred_cachepred; norm. cancel. rewrite sync_xform_sync_invariant; auto. intuition eauto. unfold size_valid in *; intuition. unfold addr_valid in *; intuition. eapply MapFacts.empty_in_iff; eauto. unfold crash_xform; eexists; eauto. Qed. Hint Extern 1 ({{_}} Bind (init_recover _) _) => apply init_recover_ok : prog. Lemma sync_xform_arrayS : forall l start, sync_xform (arrayS start l) =p=> arrayS start l. Proof. induction l; simpl; intros. rewrite sync_xform_emp; cancel. rewrite sync_xform_sep_star_dist. rewrite sync_xform_ptsto_subset_preserve. rewrite IHl. cancel. Qed. Theorem init_load_ok : forall cachesize, {!< disk, PRE:vm,hm arrayS 0 disk * [[ cachesize <> 0 ]] POST:vm',hm' RET:cs exists d, rep cs d * [[ arrayS 0 disk d ]] * [[ vm' = vm ]] CRASH:hm' arrayS 0 disk >!} init_load cachesize. Proof. unfold init_load, init, rep. step. eapply pimpl_ok2; monad_simpl; eauto. simpl; intros. unfold pimpl; intros. destruct_lift H; subst. repeat (apply sep_star_lift_apply'; eauto). apply sep_star_comm; apply emp_star_r. exists m. repeat (apply sep_star_lift_apply'; eauto). apply sep_star_comm. repeat (apply sep_star_lift_apply'; eauto). apply sync_xform_arrayS in H. eapply mem_pred_cachepred_refl_arrayS; eauto. intuition. apply size_valid_cache0; eauto. apply addr_valid_empty. apply sync_xform_arrayS in H; eauto. Qed. Hint Extern 1 ({{_}} Bind (init_load _) _) => apply init_load_ok : prog. Theorem write_ok : forall cs a v, {< d (F : rawpred) v0, PRE:hm rep cs d * [[ (F * a |+> v0)%pred d ]] POST:hm' RET:cs exists d', rep cs d' * [[ (F * a |+> (v, vsmerge v0))%pred d' ]] XCRASH:hm' exists cs' d', rep cs' d' * [[ (F * a |+> (v, vsmerge v0))%pred d' ]] >} write a v cs. 
inv H; auto. Qed.Theorem repr_val_id_L_L6_L7_ptr: forall v6 m L lenv x, repr_val_id_L_L6_L7 v6 m L lenv x -> exists v7, repr_val_L_L6_L7 v6 m L v7 /\ ((M.get x lenv = Some v7 /\ Genv.find_symbol (Genv.globalenv p) x = None) \/ (exists b, v7 = Vptr b Ptrofs.zero /\ Genv.find_symbol (Genv.globalenv p) x = Some b)). Proof. intros. inv H. - exists (Vptr b (Ptrofs.zero)). split; auto. right. exists b; auto. - exists v7. split; auto. Qed. Theorem get_var_or_funvar_eval: forall lenv a v m, find_symbol_domain finfo_env -> finfo_env_correct -> get_var_or_funvar lenv a v -> eval_expr (globalenv p) empty_env lenv m (var_or_funvar_f a) v. Proof. intros. specialize (H a). inv H. unfold var_or_funvar_f. inv H1. - rewrite H. destruct (H3 (ex_intro _ b H)). unfold makeVar. rewrite H1. destruct x. specialize (H0 _ _ f H1). destruct H0. destruct x. rewrite H0. econstructor. constructor 2. apply M.gempty. eauto. constructor. auto. - rewrite H. constructor. auto. Qed.Theorem get_var_or_funvar_semcast: forall v a m lenv, find_symbol_domain finfo_env -> finfo_env_correct -> get_var_or_funvar lenv a v -> sem_cast v (typeof (var_or_funvar_f a)) uval m = Some v. Proof. intros. unfold var_or_funvar_f. specialize (H a). inv H. inv H1. - rewrite H. destruct (H3 (ex_intro _ b H)). unfold makeVar. rewrite H1. destruct x. specialize (H0 _ _ f H1). destruct H0. destruct x. rewrite H0. constructor. - rewrite H. destruct v; inv H5; auto. Qed. Theorem repr_val_id_implies_var_or_funvar: forall v6 m L lenv x, repr_val_id_L_L6_L7 v6 m L lenv x -> exists v7, get_var_or_funvar lenv x v7 /\ repr_val_L_L6_L7 v6 m L v7. Proof. intros. inv H. - exists (Vptr b Ptrofs.zero). split. constructor; auto. auto. - exists v7. split. constructor 2; auto. inv H2; auto. auto. Qed.Theorem repr_val_id_set: forall v6 m L lenv x, repr_val_id_L_L6_L7 v6 m L lenv x -> forall x0 v, x <> x0 -> repr_val_id_L_L6_L7 v6 m L (M.set x0 v lenv) x. Proof. intros. inv H. - econstructor; eauto. - econstructor 2; eauto. rewrite M.gso; auto. Qed. Scheme repr_val_ind' := Minimality for repr_val_L_L6_L7 Sort Prop with repr_val_list_ind' := Minimality for repr_val_ptr_list_L_L6_L7 Sort Prop. Theorem nthN_pos_pred: forall {A} (a:A) vs v6 p0, nthN (a :: vs) (N.pos p0) = Some v6 -> nthN vs (N.pred (N.pos p0)) = Some v6. Proof. intros. destruct p0; auto. Qed.Theorem Z_mul_4: forall p, Z.pos p~0~0 = (4 * Z.pos p)%Z. Proof. intro. replace ((xO (xO p0))) with (Zpower.shift 2%Z p0) by reflexivity. rewrite Zpower.shift_equiv; auto. omega. Qed. Theorem repr_val_ptr_list_L_Z_nth: forall {m L v6 vs n b i}, repr_val_ptr_list_L_L6_L7_Z vs m L b i -> nthN vs n = Some v6 -> exists v7, Mem.load int_chunk m b (i + (Z.of_N n * int_size)) = Some v7 /\ repr_val_L_L6_L7 v6 m L v7. 
interp specs p -> simplify p SNil. intros; apply simplify_fwd'; auto. Qed. Fixpoint simplifyH G (p : propX pc state G) : subs G -> Prop := match p with | Inj _ P => fun _ => P | Cptr _ f a => fun s => exists a', specs f = Some a' /\ forall x, a' x = Substs s (a x) | And _ p1 p2 => fun s => simplifyH p1 s /\ simplifyH p2 s | Or _ p1 p2 => fun s => simplifyH p1 s \/ simplifyH p2 s | _ => fun _ => True end. Lemma Substs_Cptr : forall G (s : subs G) f a, exists a', Substs s (Cptr f a) = Cptr f a' /\ forall x, a' x = Substs s (a x). induction s; simpl; intuition eauto. Qed. Lemma simplifyH_ok : forall G (p : propX pc state G) s PG p', In (Substs s p) PG -> (simplifyH p s -> valid specs PG (Substs s p')) -> valid specs PG (Substs s p'). induction p; simpl; intuition; autorewrite with Substs in *. eapply Inj_E; [ constructor; eauto | auto ]. destruct (Substs_Cptr s p p0) as [? [ Heq ] ]; rewrite Heq in *. eapply Cptr_E; [ constructor; eauto | eauto ]. assert (valid specs PG (Substs s p1 ---> Substs s p2 ---> Substs s p')%PropX). repeat apply Imply_I. apply IHp1. simpl; tauto. intro. apply IHp2. simpl; tauto. eauto. eapply Imply_E. eapply Imply_E. eassumption. eapply And_E1; econstructor; eauto. eapply And_E2; econstructor; eauto. eapply Or_E. constructor; eauto. intuition. intuition. Qed. Theorem simplify_Imply : forall p1 p2, (simplifyH p1 SNil -> simplify p2 SNil) -> interp specs (Imply p1 p2). intros. change (interp specs (Imply (Substs SNil p1) (Substs SNil p2))). apply Imply_I. eapply simplifyH_ok. simpl; tauto. intros. apply valid_weaken1. apply simplify_bwd. auto. Qed. Theorem Imply_easyL' : forall G (p1 p2 p : PropX pc state), (simplifyH p1 SNil -> valid specs G (Imply p2 p)) -> valid specs G (Imply (And p1 p2) p). intros; apply Imply_easyL''. apply Imply_I. change (p2 ---> p)%PropX with (Substs SNil (p2 ---> p)%PropX). eapply simplifyH_ok. simpl; tauto. intro. simpl. apply valid_weaken1; auto. Qed. Theorem Imply_easyL : forall (p1 p2 p : PropX pc state), (simplifyH p1 SNil -> interp specs (Imply p2 p)) -> interp specs (Imply (And p1 p2) p). intros; apply Imply_easyL'; auto. Qed. Theorem Imply_trans' : forall G (p1 p2 p3 : PropX pc state), valid specs G (Imply p1 p2) -> valid specs G (Imply p2 p3) -> valid specs G (Imply p1 p3). 
p)); simpl in |- *; auto. intros tmp; Contradict tmp; auto with arith. intros n H H0; change (precision = S n + (precision - S n)) in |- *. apply le_plus_minus; auto. apply pGivesDigit; auto. repeat rewrite Zabs_Zmult. apply Zle_Zmult_comp_l. apply Zle_ZERO_Zabs. apply Zle_Zmult_comp_r. apply Zle_ZERO_Zabs. rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith. unfold Fdigit in |- *; apply digitLess; auto. intros H'0; right; split; auto; split. rewrite MinR; clear MinR; auto. cut (- dExp b <= Fexp p)%Z; [ idtac | auto with float ]. case p; simpl in |- *. intros Fnum1 Fexp1 H'2; rewrite inj_abs; auto with zarith. rewrite MinR. rewrite <- (fun x => Zabs_eq (Zpos x)). unfold Fshift in |- *; simpl in |- *. apply Zlt_le_trans with (Zabs (radix * (Zpower_nat radix (Fdigit radix p) * Zpower_nat radix (Zabs_nat (dExp b + Fexp p))))). repeat rewrite Zabs_Zmult. apply Zmult_gt_0_lt_compat_l. apply Zlt_gt; rewrite Zabs_eq; auto with zarith. apply Zmult_gt_0_lt_compat_r. apply Zlt_gt; rewrite Zabs_eq; auto with zarith. rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith. unfold Fdigit in |- *; apply digitMore; auto. pattern radix at 1 in |- *; rewrite <- (Zpower_nat_1 radix). repeat rewrite <- Zpower_nat_is_exp; auto with zarith. apply Zle_trans with (Zabs (Zpower_nat radix precision)). repeat rewrite Zabs_eq; auto with zarith. rewrite pGivesBound. rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith. red in |- *; simpl in |- *; red in |- *; intros; discriminate. Qed. Theorem NormalAndSubNormalNotEq : forall p q : float, Fnormal p -> Fsubnormal q -> p <> q :>R. intros p q H' H'0; red in |- *; intros H'1. case (Rtotal_order 0 p); intros H'2. absurd (q < p)%R. rewrite <- H'1; auto with real. apply FsubnormalnormalLtPos; auto with real. rewrite <- H'1; auto with real. absurd (p < q)%R. rewrite <- H'1; auto with real. apply FsubnormalnormalLtNeg; auto with real. rewrite <- H'1; auto with real. elim H'2; intros H'3; try rewrite <- H'3; auto with real. elim H'2; intros H'3; try rewrite <- H'3; auto with real. Qed. Theorem FcanonicUnique : forall p q : float, Fcanonic p -> Fcanonic q -> p = q :>R -> p = q. intros p q H' H'0 H'1; case H'; case H'0; intros H'2 H'3. apply FnormalUnique; auto. Contradict H'1; apply NormalAndSubNormalNotEq; auto. absurd (q = p :>R); auto; apply NormalAndSubNormalNotEq; auto. apply FsubnormalUnique; auto. Qed. Theorem FcanonicLeastExp : forall x y : float, x = y :>R -> Fbounded b x -> Fcanonic y -> (Fexp y <= Fexp x)%Z. 
l : list A, Permutation l l. Proof. induction l; constructor. exact IHl. Qed. Theorem Permutation_sym : forall l l' : list A, Permutation l l' -> Permutation l' l. Proof. intros l l' Hperm; induction Hperm; auto. apply perm_trans with (l':=l'); assumption. Qed. Theorem Permutation_trans : forall l l' l'' : list A, Permutation l l' -> Permutation l' l'' -> Permutation l l''. Proof. exact perm_trans. Qed. Hint Resolve Permutation_refl Permutation_sym Permutation_trans. Theorem Permutation_in : forall (l l' : list A) (x : A), Permutation l l' -> In x l -> In x l'. Proof. intros l l' x Hperm; induction Hperm; simpl; tauto. Qed. Lemma Permutation_app_tail : forall (l l' tl : list A), Permutation l l' -> Permutation (l++tl) (l'++tl). Proof. intros l l' tl Hperm; induction Hperm as [|x l l'|x y l|l l' l'']; simpl; auto. eapply Permutation_trans with (l':=l'++tl); trivial. Qed. Lemma Permutation_app_head : forall (l tl tl' : list A), Permutation tl tl' -> Permutation (l++tl) (l++tl'). Proof. intros l tl tl' Hperm; induction l; [trivial | repeat rewrite <- app_comm_cons; constructor; assumption]. Qed. Theorem Permutation_app : forall (l m l' m' : list A), Permutation l l' -> Permutation m m' -> Permutation (l++m) (l'++m'). Proof. intros l m l' m' Hpermll' Hpermmm'; induction Hpermll' as [|x l l'|x y l|l l' l'']; repeat rewrite <- app_comm_cons; auto. apply Permutation_trans with (l' := (x :: y :: l ++ m)); [idtac | repeat rewrite app_comm_cons; apply Permutation_app_head]; trivial. apply Permutation_trans with (l' := (l' ++ m')); try assumption. apply Permutation_app_tail; assumption. Qed. Theorem Permutation_app_swap : forall (l l' : list A), Permutation (l++l') (l'++l). Proof. induction l as [|x l]. simpl; intro l'; rewrite <- app_nil_end; trivial. induction l' as [|y l']. simpl; rewrite <- app_nil_end; trivial. simpl; apply Permutation_trans with (l' := x :: y :: l' ++ l). constructor; rewrite app_comm_cons; apply IHl. apply Permutation_trans with (l' := y :: x :: l' ++ l); constructor. apply Permutation_trans with (l' := x :: l ++ l'); auto. Qed. Theorem Permutation_cons_app : forall (l l1 l2:list A) a, Permutation l (l1 ++ l2) -> Permutation (a :: l) (l1 ++ a :: l2). Proof. intros l l1; revert l. induction l1. simpl. intros; apply perm_skip; auto. simpl; intros. apply perm_trans with (a0::a::l1++l2). apply perm_skip; auto. apply perm_trans with (a::a0::l1++l2). apply perm_swap; auto. apply perm_skip; auto. Qed. Hint Resolve Permutation_cons_app. Theorem Permutation_length : forall (l l' : list A), Permutation l l' -> length l = length l'. 
m e1 e2 : Z, (1 < m)%Z -> (bpow e2 < F2R (Float beta m e1))%R -> (bpow e2 <= F2R (Float beta (m - 1) e1))%R. Proof. intros m e1 e2 Hm. case (Zle_or_lt e1 e2); intros He. replace e2 with (e2 - e1 + e1)%Z by ring. rewrite bpow_plus. unfold F2R. simpl. rewrite <- (IZR_Zpower beta (e2 - e1)). intros H. apply Rmult_le_compat_r. apply bpow_ge_0. apply Rmult_lt_reg_r in H. apply IZR_le. rewrite (Zpred_succ (Zpower _ _)). apply Zplus_le_compat_r. apply Zlt_le_succ. now apply lt_IZR. apply bpow_gt_0. now apply Zle_minus_le_0. intros H. apply Rle_trans with (1*bpow e1)%R. rewrite Rmult_1_l. apply bpow_le. now apply Zlt_le_weak. unfold F2R. simpl. apply Rmult_le_compat_r. apply bpow_ge_0. apply IZR_le. lia. Qed.Theorem F2R_lt_bpow : forall f : float beta, forall e', (Z.abs (Fnum f) < Zpower beta (e' - Fexp f))%Z -> (Rabs (F2R f) < bpow e')%R. Proof. intros (m, e) e' Hm. rewrite <- F2R_Zabs. destruct (Zle_or_lt e e') as [He|He]. unfold F2R. simpl. apply Rmult_lt_reg_r with (bpow (-e)). apply bpow_gt_0. rewrite Rmult_assoc, <- 2!bpow_plus, Zplus_opp_r, Rmult_1_r. rewrite <-IZR_Zpower. 2: now apply Zle_left. now apply IZR_lt. elim Zlt_not_le with (1 := Hm). simpl. assert (H: (e' - e < 0)%Z) by lia. clear -H. destruct (e' - e)%Z ; try easy. apply Zabs_pos. Qed.Theorem F2R_change_exp : forall e' m e : Z, (e' <= e)%Z -> F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e')) e'). Proof. intros e' m e He. unfold F2R. simpl. rewrite mult_IZR, IZR_Zpower, Rmult_assoc. apply f_equal. pattern e at 1 ; replace e with (e - e' + e')%Z by ring. apply bpow_plus. now apply Zle_minus_le_0. Qed.Theorem F2R_prec_normalize : forall m e e' p : Z, (Z.abs m < Zpower beta p)%Z -> (bpow (e' - 1)%Z <= Rabs (F2R (Float beta m e)))%R -> F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e' + p)) (e' - p)). Proof. intros m e e' p Hm Hf. assert (Hp: (0 <= p)%Z). destruct p ; try easy. now elim (Zle_not_lt _ _ (Zabs_pos m)).replace (e - e' + p)%Z with (e - (e' - p))%Z by ring. apply F2R_change_exp. cut (e' - 1 < e + p)%Z. lia. apply (lt_bpow beta). apply Rle_lt_trans with (1 := Hf). rewrite <- F2R_Zabs, Zplus_comm, bpow_plus. apply Rmult_lt_compat_r. apply bpow_gt_0. rewrite <- IZR_Zpower. now apply IZR_lt. exact Hp. Qed. Theorem mag_F2R_bounds : forall x m e, (0 < m)%Z -> (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R -> mag beta x = mag beta (F2R (Float beta m e)) :> Z. 
map_length; eauto. rewrite dsupd_nthd. cancel. rewrite effective_dsupd_comm. eapply dset_match_dsupd_notin; eauto. subst; repeat xcrash_rewrite. xform_norm. or_l; cancel. xform_normr; cancel. erewrite dset_match_nthd_effective_fst; eauto. rewrite recover_before_any_fst by eauto; cancel. or_r; cancel. xform_normr; cancel. xform_normr; cancel. rewrite nthd_0; simpl. eassign (mk_mstate vmap0 nil x_1); simpl; cancel. all: simpl; eauto. apply dset_match_nil. Qed. Hint Extern 1 ({{_}} Bind (dwrite' _ _ _ _) _) => apply dwrite'_ok : prog. Lemma diskset_ptsto_bound_effective : forall F xp a vs ds ts, dset_match xp (effective ds (length ts)) ts -> (F * a |-> vs)%pred (list2nmem ds!!) -> a < length (nthd (length (snd ds) - length ts) ds). Proof. intros. apply list2nmem_ptsto_bound in H0. erewrite dset_match_nthd_effective_fst; eauto. erewrite <- replay_seq_latest_length; auto. rewrite latest_effective; auto. apply H. Qed. Theorem dwrite_ok: forall xp a v ms, {< F Fd ds vs, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[[ ds !! ::: (Fd * a |-> vs) ]]] * [[ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (dsupd ds a (v, vsmerge vs))) ms' hm' >> XCRASH:hm' << F, would_recover_any: xp ds hm' -- >> \/ << F, would_recover_any: xp (dsupd ds a (v, vsmerge vs)) hm' -- >> >} dwrite xp a v ms. Proof. unfold dwrite, rep. step. prestep; unfold rep; cancel. prestep; unfold rep; safecancel. substl (MSVMap a0); eauto. substl (MSTxns a0); simpl. rewrite Nat.sub_0_r, <- latest_nthd. simpl; pred_apply; cancel. auto. step. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. or_r; cancel. do 2 (xform_norm; cancel). repeat rewrite nthd_0; simpl. substl (MSTxns a0); simpl. rewrite Nat.sub_0_r, <- latest_nthd. rewrite <- dsupd_latest. rewrite synced_recover_any; eauto. rewrite effective_dsupd_comm, map_length. eapply dset_match_dsupd; eauto. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. prestep; unfold rep; cancel. apply MapFacts.not_find_in_iff; auto. eapply list2nmem_ptsto_cancel_pair. eapply diskset_ptsto_bound_effective; eauto. prestep. norm. cancel. intuition simpl. pred_apply. repeat rewrite map_length. rewrite <- surjective_pairing in *. erewrite dset_match_nthd_effective_fst; eauto. erewrite diskset_vmap_find_none; eauto; auto. cancel. erewrite <- diskset_vmap_find_none with (v := vs_cur). erewrite <- dset_match_nthd_effective_fst; eauto. all: eauto. apply MapFacts.not_find_in_iff; auto. rewrite latest_effective; eauto. apply MapFacts.not_find_in_iff; auto. rewrite latest_effective; eauto. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. or_r; cancel. do 2 (xform_norm; cancel). rewrite nthd_0; simpl. rewrite <- surjective_pairing in *; simpl. rewrite <- dsupd_nthd. rewrite MLog.synced_recover_before. rewrite dsupd_nthd. erewrite dset_match_nthd_effective_fst by eauto. rewrite <- dsupd_fst, <- effective_dsupd_comm. rewrite recover_before_any_fst. erewrite diskset_vmap_find_none; eauto. apply MapFacts.not_find_in_iff; auto. rewrite latest_effective; eauto. rewrite effective_dsupd_comm. eapply dset_match_dsupd; eauto. rewrite map_length; eauto. rewrite map_length; auto. Qed. Theorem dsync_ok: forall xp a ms, {< F Fd ds vs, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[[ ds !! ::: (Fd * a |-> vs) ]]] * [[ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (dssync ds a)) ms' hm' >> CRASH:hm' << F, would_recover_any: xp ds hm' -- >> >} dsync xp a ms. 
|- *. intros a H1; case (H0 a); auto. Qed. Theorem in_alphabet_nil : forall c, in_alphabet nil c. Proof using. intros c a H; inversion H. Qed. Hint Resolve in_alphabet_nil : core. Theorem in_alphabet_cons : forall (m : list A) c a ca, In (a, ca) c -> in_alphabet m c -> in_alphabet (a :: m) c. Proof using. intros m c a ca H H0; red in |- *; simpl in |- *. intros a1 [H1| H1]. exists ca; rewrite <- H1; auto. case (H0 a1); auto. Qed. Hint Resolve in_alphabet_cons : core. Theorem in_alphabet_inv : forall (c : code) (a : A) (l : list A), in_alphabet (a :: l) c -> in_alphabet l c. Proof using. intros c a l H; red in |- *. intros a1 H1; apply H; simpl in |- *; auto. Qed. Definition code_dec : forall (c : code) a, {(exists l : list bool, In (a, l) c)} + {(forall l : list bool, ~ In (a, l) c)}. intros c a; elim c; simpl in |- *; auto. intros (a1, l1) l H; case (eqA_dec a1 a); intros H1. left; exists l1; rewrite H1; auto. case H. intros e; left; case e; intros l2 H2; exists l2; auto. intros n; right; intros l0; red in |- *; intros [H0| H0]; [ case H1 | case (n l0) ]; auto. injection H0; auto. Defined. Definition in_alphabet_dec : forall m c, {in_alphabet m c} + {~ in_alphabet m c}. intros m; elim m; simpl in |- *; auto. intros a l H c; case (H c); intros H1. case (code_dec c a); intros H2. left; red in |- *; simpl in |- *. intros a1 [H3| H3]; [ case H2; intros l1 Hl1; exists l1; rewrite <- H3 | idtac ]; auto. right; red in |- *; intros H3; case (H3 a); simpl in |- *; auto. right; Contradict H1; auto; red in |- *. intros a0 H0; case (H1 a0); simpl in |- *; auto. intros x H2; exists x; auto. Defined. Definition not_null (c : code) := forall a : A, ~ In (a, nil) c. Theorem not_null_inv : forall (a : A * list bool) l, not_null (a :: l) -> not_null l. Proof using. intros a l H; red in |- *. intros a0; red in |- *; intros H0; case (H a0); simpl in |- *; auto. Qed. Theorem not_null_cons : forall a b (l : list (A * list bool)), b <> nil -> not_null l -> not_null ((a, b) :: l). 
apply unique_key_inv with (1 := H); auto. intros n; apply unique_key_cons; auto. intros b; red in |- *; intros H0; case add_frequency_list_in_inv with (1 := H0); auto. intros H2; case (unique_key_in _ _ _ _ b _ H); auto. apply Rec; apply unique_key_inv with (1 := H); auto. Qed. Theorem add_frequency_list_1 : forall a l, (forall ca, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l). Proof using. intros a l; generalize a; elim l; clear a l; simpl in |- *; auto. intros (a1, l1) l0 H a H0. case (eqA_dec a a1); auto. intros H1; case (H0 l1); left; apply f_equal2 with (f := pair (A:=A) (B:=nat)); auto. intros n; apply in_cons; auto; apply H; auto. intros ca; red in |- *; intros H1; case (H0 ca); auto. Qed. Theorem add_frequency_list_in : forall m a n, unique_key m -> In (a, n) m -> In (a, S n) (add_frequency_list a m). Proof using. intros m; elim m; clear m; simpl in |- *; auto. intros (a1, l1) l Rec a n H H1; case (eqA_dec a a1); simpl in |- *; auto. intros H2; case H1; auto. intros H3; left; apply f_equal2 with (f := pair (A:=A) (B:=nat)); injection H3; auto. rewrite H2; intros H3; case unique_key_in with (1 := H) (b2 := n); auto. intros n0; right; apply Rec. apply unique_key_inv with (1 := H); auto. case H1; auto. intros H0; case n0; injection H0; auto. Qed. Theorem add_frequency_list_not_in : forall m a b n, a <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m). Proof using. intros m; elim m; clear m; simpl in |- *; auto. intros (a1, l1) l H a0 b n H0 [H1| H1]; case (eqA_dec b a1); simpl in |- *; auto. intros H2; case H0; injection H1; auto. intros; apply trans_equal with (2 := sym_equal H2); auto. Qed. Fixpoint frequency_list (l : list A) : list (A * nat) := match l with | nil => nil | a :: l1 => add_frequency_list a (frequency_list l1) end. Theorem frequency_list_in : forall a n m, In (a, n) (frequency_list m) -> In a m. Proof using. intros a n m; generalize n; elim m; clear m n; simpl in |- *; auto. intros a0 l H n H0; case add_frequency_list_in_inv with (1 := H0); auto. intros H1; right; apply (H n); auto. Qed. Theorem frequency_list_perm : forall l : list A, permutation l (flat_map (fun p => id_list (fst p) (snd p)) (frequency_list l)). 
eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L). intros L p q H; apply Cb_incl with (1 := cs) (P := addEnd A A0 eqA n ltM p L); auto. elim L; simpl in |- *; auto. intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto. case (H0 a0); auto. Qed. Theorem Cb_cons_addEnd : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (addEnd A A0 eqA n ltM p L). intros L p q H; apply Cb_incl with (1 := cs) (P := p :: L); auto. elim L; simpl in |- *; auto. intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto. case H1; auto. Qed. Theorem Cb_trans_cons : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L. intros L p q H H0. apply Cb_trans with (1 := cs) (b := p); auto. apply Cb_cons_addEnd; auto. Qed. Theorem Cb_cons : forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p L) (p :: L). intros p L; unfold nf, LetP in |- *; auto. case (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os L p); simpl in |- *; auto. intros x0; case x0; simpl in |- *. intros x c H'. change (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec (p :: L) (mults (A:=A) multA (n:=n) (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x c)) x)) in |- *. apply CombLinear_mults1 with (1 := cs); auto. apply unit_nZ with (1 := cs); auto. apply reducestar_cb1 with (1 := cs); auto. Qed. Theorem Cb_comp : forall L1 L2 : list (poly A0 eqA ltM), (forall p : poly A0 eqA ltM, In p L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2) -> forall q : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2. 
Require Import Sets. Require Import Axioms.Definition Class_succ (E : Ens) := Union (Paire E (Sing E)). Definition Nat : nat -> Ens. simple induction 1; intros. exact Vide. exact (Class_succ X). Defined.Definition Omega : Ens := sup nat Nat.Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E). intros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc. Qed. Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E). unfold INC in |- *; unfold Class_succ in |- *. intros. apply IN_Union with E; auto with zfc. Qed.Hint Resolve IN_Class_succ INC_Class_succ: zfc. Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \/ IN E' E. 
listpred' (l1 ++ l2) =p=> listpred' l1 * listpred' l2. Proof. unfold listpred'. induction l1; destruct l2; unfold sep_star_fold; try cancel; rewrite IHl1; unfold sep_star_fold; cancel. Qed. Theorem listpred'_app_bwd: forall l1 l2, listpred' l1 * listpred' l2 =p=> listpred' (l1 ++ l2). Proof. unfold listpred'. induction l1; destruct l2; unfold sep_star_fold; try cancel; rewrite <- IHl1; unfold sep_star_fold; cancel. Qed. Theorem listpred_app: forall l1 l2, listpred (l1 ++ l2) <=p=> listpred l1 * listpred l2. Proof. intros; replace listpred with listpred'. unfold piff; split. apply listpred'_app_fwd. apply listpred'_app_bwd. apply functional_extensionality. apply listpred_listpred'. Qed. Theorem listpred_isolate : forall l i def, i < length l -> listpred l <=p=> listpred (removeN l i) * prd (selN l i def). Proof. intros. unfold removeN. rewrite listpred_app. unfold piff; split. rewrite listpred_fwd by eauto; cancel. eapply pimpl_trans2. apply listpred_bwd; eauto. cancel. Qed. Theorem listpred_split : forall l n, listpred l <=p=> listpred (firstn n l) * listpred (skipn n l). Proof. intros. setoid_rewrite <- firstn_skipn with (n := n) at 1. rewrite listpred_app. split; cancel. Qed. Theorem listpred_isolate_fwd : forall l i def, i < length l -> listpred l =p=> listpred (removeN l i) * prd (selN l i def). Proof. intros. apply listpred_isolate; auto. Qed. Theorem listpred_updN : forall l i v, i < length l -> listpred (updN l i v) <=p=> listpred (removeN l i) * prd v. Proof. intros; rewrite listpred_isolate with (def:=v); [ | rewrite length_updN; eauto]. rewrite removeN_updN. rewrite selN_updN_eq; auto. Qed. Theorem listpred_updN_selN: forall l i v def, i < length l -> prd (selN l i def) =p=> prd v -> listpred l =p=> listpred (updN l i v). Proof. intros. rewrite listpred_updN by auto. rewrite listpred_isolate with (def:=def) at 1 by eauto. cancel; auto. Qed. Theorem listpred_nodup : forall l m, (forall x y : T, {x = y} + {x <> y}) -> (forall (y : T) m', ~ (prd y * prd y)%pred m') -> listpred l m -> NoDup l. Proof. induction l; intuition; constructor; simpl in H0. intro Hin. revert H0. erewrite listpred_pick by (apply Hin). unfold_sep_star; intuition. do 2 destruct H0. intuition. destruct H4. do 2 destruct H3. intuition. eapply H. unfold_sep_star. exists x. exists x2. repeat split; intuition; eauto. subst. apply mem_disjoint_comm. apply mem_disjoint_comm in H0. rewrite mem_union_comm in H0. eapply mem_disjoint_union. eauto. eauto. revert H0. unfold_sep_star. intuition. do 2 destruct H0. intuition. eapply IHl; eauto. Qed. Theorem listpred_nodup_piff : forall l, (forall x y : T, {x = y} + {x <> y}) -> (forall (y : T) m', ~ (prd y * prd y)%pred m') -> listpred l <=p=> [[ NoDup l ]] * listpred l. 
Proof Ring.sum_inv_uniq_ex ring. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Ring.sum_intro_l ring. Theorem sum_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Ring.sum_intro_r ring. Theorem sum_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Ring.sum_cancel_l ring. Theorem sum_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Ring.sum_cancel_r ring. Theorem sum_inv_l_uniq : forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y. Proof Ring.sum_inv_l_uniq ring. Theorem sum_inv_r_uniq : forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Ring.sum_inv_r_uniq ring. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Ring.sum_0_inv_l ring. Theorem sum_0_inv_r : sum_is_inv_r 0 0. Proof Ring.sum_0_inv_r ring. Theorem sum_0_inv : sum_is_inv 0 0. Proof Ring.sum_0_inv ring. Theorem sum_has_inv_l_0 : sum_has_inv_l 0. Proof Ring.sum_has_inv_l_0 ring. Theorem sum_has_inv_r_0 : sum_has_inv_r 0. Proof Ring.sum_has_inv_r_0 ring. Theorem sum_has_inv_0 : sum_has_inv 0. Proof Ring.sum_has_inv_0 ring. Theorem sum_inv_0_eq_0 : forall x : E, sum_is_inv x 0 -> x = 0. Proof Ring.sum_inv_0_eq_0 ring. Theorem sum_inv_0_uniq : unique (fun x => sum_is_inv x 0) 0. Proof Ring.sum_inv_0_uniq ring. Definition sum_neg_strong : forall x : E, { y | sum_is_inv x y } := Ring.sum_neg_strong ring. Definition sum_neg : E -> E := Ring.sum_neg ring.Notation "{-}" := (sum_neg) : commutative_ring_scope.Notation "- x" := (sum_neg x) : commutative_ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Ring.sum_neg_def ring. Theorem sum_neg_inj : is_injective E E sum_neg. Proof Ring.sum_neg_inj ring. Theorem sum_cancel_neg : forall x : E, sum_neg (- x) = x. Proof Ring.sum_cancel_neg ring. Theorem sum_neg_onto : is_onto E E sum_neg. Proof Ring.sum_neg_onto ring. Theorem sum_neg_bijective : is_bijective E E sum_neg. Proof Ring.sum_neg_bijective ring. Theorem sum_neg_rev : forall x y : E, - x = y -> - y = x. Proof Ring.sum_neg_rev ring. Theorem sum_neg_distrib_inv_l : forall x y : E, sum_is_inv_l (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_l ring. Theorem sum_neg_distrib_inv_r : forall x y : E, sum_is_inv_r (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_r ring. Theorem sum_neg_distrib_inv : forall x y : E, sum_is_inv (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv ring. Theorem sum_neg_distrib : forall x y : E, - (x + y) = - y + - x. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations. From Categories Require Import Functor.Representable.Hom_Func. From Categories Require Import Cat.Cat Cat.Cat_Iso. From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.NatIso.Local Open Scope functor_scope.Section Hom_Func_Twist. Context (C : Category). Theorem Hom_Func_Twist : (Hom_Func (C^op)) = (Hom_Func C) ∘ (Twist_Func C (C^op)). Proof. Func_eq_simpl; cbn; auto. Qed.End Hom_Func_Twist.Section Prod_Func_Hom_Func_NT. Context {A B C D : Category} {F : A –≻ C^op} {F' : A –≻ D^op} {G : B –≻ C} {G' : B –≻ D} (N : (((Hom_Func C) ∘ (Prod_Functor F G)) –≻ ((Hom_Func D) ∘ (Prod_Functor F' G')))%nattrans ) . Local Obligation Tactic := idtac. Program Definition Prod_Func_Hom_Func_NT : (((Hom_Func (C^op)) ∘ (Prod_Functor G F)) –≻ ((Hom_Func (D^op)) ∘ (Prod_Functor G' F')))%nattrans := {| Trans := fun c h => Trans N (snd c, fst c) h |}. Next Obligation. Proof. intros [c1 c2] [c1' c2'] [h1 h2]. extensionality x; cbn. repeat rewrite assoc_sym. exact (equal_f (@Trans_com _ _ _ _ N (c2, c1) (c2', c1') (h2, h1)) x). Qed. Next Obligation. Proof. symmetry. apply Prod_Func_Hom_Func_NT_obligation_1. Qed.End Prod_Func_Hom_Func_NT. Section Prod_Func_Hom_Func. Context {A B C D : Category} {F : A –≻ C^op} {F' : A –≻ D^op} {G : B –≻ C} {G' : B –≻ D} (N : ( ((Hom_Func C) ∘ (Prod_Functor F G))%functor ≃ ((Hom_Func D) ∘ (Prod_Functor F' G'))%functor )%natiso ) . Local Ltac TRC := match goal with [|- ?W = _] => match W with Trans ?A ?X (Trans ?B ?X ?Z) => change W with (Trans (NatTrans_compose B A) X Z) end end. Local Obligation Tactic := apply NatTrans_eq_simplify; FunExt; basic_simpl; TRC; solve [(cbn_rewrite (right_inverse N); trivial) | (cbn_rewrite (left_inverse N); trivial)]. Program Definition Prod_Func_Hom_Func : ((((Hom_Func (C^op)) ∘ (Prod_Functor G F))%functor) ≃ ((Hom_Func (D^op)) ∘ (Prod_Functor G' F'))%functor)%natiso := {| iso_morphism := Prod_Func_Hom_Func_NT (iso_morphism N); inverse_morphism := Prod_Func_Hom_Func_NT (inverse_morphism N) |} . End Prod_Func_Hom_Func.Section Prod_Func_Hom_Func_invl. Context {A B C D : Category} {F : A –≻ C^op} {F' : A –≻ D^op} {G : B –≻ C} {G' : B –≻ D} (N : ( ((Hom_Func C) ∘ (Prod_Functor F G))%functor ≃ ((Hom_Func D) ∘ (Prod_Functor F' G'))%functor )%natiso ) . Theorem Prod_Func_Hom_Func_invl : N = Prod_Func_Hom_Func (Prod_Func_Hom_Func N). 
Require Import Morphisms BinInt ZDivEucl. Local Open Scope Z_scope.Module ZEuclid. Definition modulo a b := Z.modulo a (Z.abs b). Definition div a b := (Z.sgn b) * (Z.div a (Z.abs b)). Instance mod_wd : Proper (eq==>eq==>eq) modulo. Proof. congruence. Qed. Instance div_wd : Proper (eq==>eq==>eq) div. Proof. congruence. Qed. Theorem div_mod a b : b<>0 -> a = b*(div a b) + modulo a b. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main.Local Open Scope morphism_scope.Section Algebras. Context {C : Category} (T : (C --> C)%functor). Record Algebra : Type := { Alg_Carrier : C; Constructors : (T _o Alg_Carrier)%object --> Alg_Carrier }. Record Algebra_Hom (alg alg' : Algebra) : Type := { Alg_map : (Alg_Carrier alg) --> (Alg_Carrier alg'); Alg_map_com : ((Constructors alg') ∘ (T _a Alg_map) = Alg_map ∘ (Constructors alg))%morphism }. Arguments Alg_map {_ _} _. Arguments Alg_map_com {_ _} _. Program Definition Algebra_Hom_compose {alg alg' alg'' : Algebra} (h : Algebra_Hom alg alg') (h' : Algebra_Hom alg' alg'') : Algebra_Hom alg alg'' := {| Alg_map := ((Alg_map h') ∘ (Alg_map h))%morphism |}. Next Obligation. Proof. destruct h as [alm almcm]; destruct h' as [alm' almcm']; cbn. rewrite F_compose. rewrite assoc_sym. rewrite almcm'. rewrite assoc. rewrite almcm. auto. Qed. Lemma Algebra_Hom_eq_simplify (alg alg' : Algebra) (ah ah' : Algebra_Hom alg alg') : (Alg_map ah) = (Alg_map ah') -> ah = ah'. Proof. intros; destruct ah; destruct ah'; cbn in *. ElimEq. PIR. trivial. Qed. Theorem Algebra_Hom_compose_assoc {alg alg' alg'' alg''' : Algebra} (f : Algebra_Hom alg alg') (g : Algebra_Hom alg' alg'') (h : Algebra_Hom alg'' alg''') : (Algebra_Hom_compose f (Algebra_Hom_compose g h)) = (Algebra_Hom_compose (Algebra_Hom_compose f g) h). Proof. apply Algebra_Hom_eq_simplify; cbn; auto. Qed. Program Definition Algebra_Hom_id (alg : Algebra) : Algebra_Hom alg alg := {| Alg_map := id |}. Theorem Algebra_Hom_id_unit_left {alg alg' : Algebra} (f : Algebra_Hom alg alg') : (Algebra_Hom_compose f (Algebra_Hom_id alg')) = f. 
Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition Fweight (p : float) := (Fnum p + Fexp p * Zpower_nat radix precision)%Z. Theorem FweightLt : forall p q : float, Fcanonic radix b p -> Fcanonic radix b q -> (0 <= p)%R -> (p < q)%R -> (Fweight p < Fweight q)%Z. intros p q H' H'0 H'1 H'2. cut (Fbounded b p); [ intros Fb1 | apply FcanonicBound with (1 := H') ]; auto. cut (Fbounded b q); [ intros Fb2 | apply FcanonicBound with (1 := H'0) ]; auto. case (FcanonicLtPos _ radixMoreThanOne b precision) with (p := p) (q := q); auto with arith; intros Zl1. unfold Fweight in |- *; simpl in |- *. replace (Fexp q) with (Fexp q - Fexp p + Fexp p)%Z; [ idtac | ring ]. rewrite Zmult_plus_distr_l. rewrite Zplus_assoc. repeat rewrite (fun x y z : Z => Zplus_comm x (y * z)). apply Zplus_lt_compat_l. apply Zlt_le_trans with (Zpower_nat radix precision); auto with zarith. apply Zle_lt_trans with (Zpred (Zpower_nat radix precision)); auto with zarith. apply Zle_Zabs_inv2; auto with float zarith. apply Zle_Zpred; auto with float zarith. rewrite <- pGivesBound; auto with float. apply Zle_trans with ((Fexp q - Fexp p) * Zpower_nat radix precision)%Z; auto with zarith. pattern (Zpower_nat radix precision) at 1 in |- *; replace (Zpower_nat radix precision) with (Zsucc 0 * Zpower_nat radix precision)%Z; auto. apply Zle_Zmult_comp_r; auto with zarith. unfold Zsucc in |- *; ring. cut (0 <= Fnum q)%Z; auto with zarith. apply (LeR0Fnum radix); auto. apply Rle_trans with (FtoRradix p); auto; apply Rlt_le; auto. elim Zl1; intros H'3 H'4; clear Zl1. unfold Fweight in |- *; simpl in |- *. rewrite <- H'3. repeat rewrite (fun x y z : Z => Zplus_comm x (y * z)). apply Zplus_lt_compat_l; auto. Qed. Theorem FweightEq : forall p q : float, Fcanonic radix b p -> Fcanonic radix b q -> p = q :>R -> Fweight p = Fweight q. intros p q H' H'0 H'1. rewrite (FcanonicUnique _ radixMoreThanOne b precision) with (p := p) (q := q); auto with arith. Qed. Theorem FweightZle : forall p q : float, Fcanonic radix b p -> Fcanonic radix b q -> (0 <= p)%R -> (p <= q)%R -> (Fweight p <= Fweight q)%Z. 
Section Cover. Variable A : Type. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Variable empty : A. Inductive cover : list (btree A) -> btree A -> Prop := | cover_one : forall t, cover (t :: nil) t | cover_node : forall l1 l2 t1 t2 t3, permutation l1 (t1 :: t2 :: l2) -> cover (node t1 t2 :: l2) t3 -> cover l1 t3. Hint Constructors cover : core.Theorem cover_permutation : forall t l1 l2, cover l1 t -> permutation l1 l2 -> cover l2 t. Proof using. intros t l1 l2 H; generalize l2; elim H; clear H t l1 l2; auto. intros t l2 H; rewrite (permutation_one_inv _ _ _ H); auto. intros l1 l2 t1 t2 t3 H H0 H1 l0 H2. apply cover_node with (2 := H0). apply permutation_trans with (2 := H). apply permutation_sym; auto. Qed. Theorem cover_cons_l : forall t1 t2 l1, cover l1 t1 -> cover (t2 :: l1) (node t2 t1). intros t1 t2 l1 H; elim H; clear t1 l1 H; simpl in |- *; auto. intros t; apply cover_node with (l2 := nil (A:=btree A)) (t1 := t2) (t2 := t); auto. intros l1 l2 t1 t0 t3 H H0 H1. apply cover_node with (l2 := t2 :: l2) (t1 := t1) (t2 := t0); auto. apply permutation_trans with (t2 :: t1 :: t0 :: l2); auto. apply permutation_trans with (t1 :: t2 :: t0 :: l2); auto. apply cover_permutation with (1 := H1); auto. Qed. Theorem cover_not_nil : forall l t, cover l t -> l <> nil. Proof using. intros l t H; case H; simpl in |- *; auto. intros t0; discriminate. intros l1 l2 t1 t2 t3 H0 H1; red in |- *; intros H2; absurd (length l1 = length (t1 :: t2 :: l2)); auto. rewrite H2; simpl in |- *; intros; discriminate. apply permutation_length with (1 := H0); auto. Qed. Theorem one_cover_ex : forall l : list (btree A), l <> nil -> exists t : btree A, cover l t. Proof using. intros l; elim l; simpl in |- *; auto. intros H; case H; auto. intros a l0; case l0; auto. intros H H0; exists a; auto. intros b l1 H H0; case H. red in |- *; intros; discriminate. intros x H1; exists (node a x). apply cover_cons_l; auto. Qed. Theorem cover_in_inb_inb : forall l t1 t2 t3, cover l t1 -> In t2 l -> inb t3 t2 -> inb t3 t1. 
<- !Z2Zp_plus. rewrite <- H2, Nat2Z.inj_mul, Z2Zp_mult, Z2Zp_of_nat, nat2Zp_p, Zp_mult_zero; auto. + repeat (rewrite !Z2Zp_minus || rewrite !Z2Zp_plus). rewrite !Z2Zp_mult. rewrite <- E1, <- E2, <- E3, <- E4. rewrite <- !Z2Zp_mult. repeat (rewrite <- !Z2Zp_minus || rewrite <- !Z2Zp_plus). rewrite <- Z2Zp_zero; f_equal; ring. + repeat (rewrite !Z2Zp_minus || rewrite !Z2Zp_plus). rewrite !Z2Zp_mult. rewrite <- E1, <- E2, <- E3, <- E4. rewrite <- !Z2Zp_mult. repeat (rewrite <- !Z2Zp_minus || rewrite <- !Z2Zp_plus). rewrite <- Z2Zp_zero; f_equal; ring. + repeat (rewrite !Z2Zp_minus || rewrite !Z2Zp_plus). rewrite !Z2Zp_mult. rewrite <- E1, <- E2, <- E3, <- E4. rewrite <- !Z2Zp_mult. repeat (rewrite <- !Z2Zp_minus || rewrite <- !Z2Zp_plus). rewrite <- Z2Zp_zero; f_equal; ring. } clear x1 x2 x3 x4 H2 H3 y1 E1 y2 E2 y3 E3 y4 E4 Hr. destruct Q as (a & b & c & d & H & Ha & Hb & Hc & Hd). apply Z2Zp_zero_inv in Ha; destruct Ha as (x & ->). apply Z2Zp_zero_inv in Hb; destruct Hb as (y & ->). apply Z2Zp_zero_inv in Hc; destruct Hc as (z & ->). apply Z2Zp_zero_inv in Hd; destruct Hd as (w & ->). exists r; split; try lia. exists x, y, z, w. apply Z.mul_cancel_r with (p := Z.of_nat (m*m)). { intros E. apply Nat2Z.inj with (m := 0) in E. destruct m; try discriminate; lia. } rewrite <- Nat2Z.inj_mul, mult_assoc, H. rewrite Nat2Z.inj_mul; ring. Qed. End lagrange_prime_step. Let lagrange_prime_step m : 1 < m < p -> P m -> exists r, 1 <= r < m /\ P r. Proof. intros H1 (x1 & x2 & x3 & x4 & H2); apply lagrange_prime_step' with (3 := H2); lia. Qed. Lemma lagrange_prime : exists a b c d, Z.of_nat p = (a*a+b*b+c*c+d*d)%Z. Proof using Hp. replace p with (1*p) by lia; change (P 1). destruct (lagrange_prelim Hp) as (n & a & b & H1 & H2 & H3). cut (P n). + revert H2 H3; clear H1. induction on n as IH with measure n. intros H2 H3 H. destruct (le_lt_dec n 1) as [ | Hn ]. * now replace 1 with n by lia. * destruct lagrange_prime_step with (2 := H) as (m & H4 & H5); auto. generalize H5; destruct H5; apply IH; auto; lia. + exists 0%Z, 1%Z, (Z.of_nat a), (Z.of_nat b). rewrite H1, !Nat2Z.inj_add, !Nat2Z.inj_mul. simpl Z.of_nat at 1; lia. Qed.End lagrange_for_primes.Section lagrange. Open Scope Z_scope. Theorem lagrange_theorem_nat : forall n, exists a b c d, Z.of_nat n = a*a+b*b+c*c+d*d. 
= BmapNBlocks xp ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[ (Fs * smrep nil)%pred sm ]] * [[[ m' ::: (Fm * rep xp nil ms) ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init_nofree lxp xp ms. Proof. unfold init_nofree, rep, MSLog; intros. step. step. Qed. Theorem steal_ok : forall lxp xp bn ms, {< F Fm Fs m0 sm m freeblocks, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLog ms) sm hm * [[[ m ::: (Fm * rep xp freeblocks ms) ]]] * [[ (Fs * smrep freeblocks)%pred sm ]] * [[ bn_valid xp bn /\ In bn freeblocks ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * bn |->? * rep xp (remove addr_eq_dec bn freeblocks) ms) ]]] * [[ (Fs * bn |->? * smrep (remove addr_eq_dec bn freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} steal lxp xp bn ms. Proof. unfold steal, rep, bn_valid, MSLog. step. prestep. norm. cancel. intuition simpl. pred_apply. denote pimpl as Hx; rewrite Hx. cancel; cancel. pred_apply; unfold smrep. rewrite listpred_remove; eauto using ptsto_conflict. cancel. eauto. Unshelve . all: try exact addr_eq_dec; auto. Qed. Theorem alloc_ok : forall lxp xp ms, {< F Fm Fs m0 sm m freeblocks, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLog ms) sm hm * [[[ m ::: (Fm * rep xp freeblocks ms) ]]] * [[ (Fs * smrep freeblocks)%pred sm ]] POST:hm' RET:^(ms, r) [[ r = None ]] * LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLog ms) sm hm' \/ exists bn m', [[ r = Some bn ]] * [[ bn_valid xp bn ]] * LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * bn |->? * rep xp (remove addr_eq_dec bn freeblocks) ms) ]]] * [[ (Fs * bn |->? * smrep (remove addr_eq_dec bn freeblocks))%pred sm ]] * [[ In bn freeblocks ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} alloc lxp xp ms. Proof. unfold alloc, rep, bn_valid, MSLog. hoare. match goal with | [ H1 : (_ =p=> ?F * _)%pred, H2 : context [ ?F ] |- _ ] => rewrite H1 in H2 end. unfold smrep in *. rewrite listpred_remove in * by eauto using ptsto_conflict. or_r; cancel. Qed. Theorem free_ok : forall lxp xp bn ms, {< F Fm Fs m0 sm m freeblocks, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLog ms) sm hm * [[ bn_valid xp bn ]] * [[[ m ::: (Fm * rep xp freeblocks ms* bn |->?) ]]] * [[ (Fs * bn |->? * smrep freeblocks)%pred sm ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * rep xp (bn :: freeblocks) ms) ]]] * [[ (Fs * smrep (bn :: freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} free lxp xp bn ms. 
net e' (currentTerm (snd (nwState net host)))) by (unfold lifted_committed; exists host, e'; intuition; eapply lifted_no_entries_past_current_term_host_invariant; eauto). find_eapply_lem_hyp handleAppendEntries_log_detailed. intuition; repeat find_rewrite; eauto. + find_copy_eapply_lem_hyp lifted_state_machine_safety_nw'_invariant; eauto. assert (eIndex e' > 0) by (eapply lifted_entries_gt_0_invariant; eauto). intuition; try lia. find_copy_eapply_lem_hyp msg_lifted_sorted_host. exfalso. enough (exists e, eIndex e = (maxIndex es) /\ In e (log (snd (nwState net host)))) by (break_exists; intuition; eapply findAtIndex_None; eauto). eapply contiguous_range_exact_lo_elim_exists; [apply lifted_entries_contiguous_invariant; auto|]. intuition. * find_apply_lem_hyp maxIndex_non_empty. break_exists; intuition; repeat find_rewrite. enough (eIndex x > 0) by lia. eapply lifted_entries_contiguous_nw_invariant; eauto. * enough (eIndex e' <= maxIndex (log (snd (nwState net host)))) by lia. apply maxIndex_is_max; auto. + find_copy_eapply_lem_hyp lifted_state_machine_safety_nw'_invariant; eauto. assert (eIndex e' > 0) by (eapply lifted_entries_gt_0_invariant; eauto). intuition; try lia. break_exists. intuition. find_apply_lem_hyp maxIndex_non_empty. break_exists_name maxEntry; intuition. repeat find_rewrite. find_false. f_equal. find_apply_lem_hyp findAtIndex_elim. intuition. eapply uniqueIndices_elim_eq; [| |eauto|]; eauto using sorted_uniqueIndices,lifted_entries_sorted_nw. match goal with | |- In ?e _ => assert (lifted_committed net e (currentTerm (snd (nwState net host)))) by (unfold lifted_committed; exists host, e'; intuition; eapply lifted_no_entries_past_current_term_host_invariant; eauto) end. find_copy_eapply_lem_hyp lifted_state_machine_safety_nw'_invariant; eauto. assert (eIndex x > 0) by (eapply lifted_entries_gt_0_invariant; eauto). intuition; lia. + find_copy_eapply_lem_hyp lifted_state_machine_safety_nw'_invariant; eauto. intuition; try solve [apply in_app_iff; right; apply removeAfterIndex_le_In; auto; lia]; [idtac]. find_copy_eapply_lem_hyp msg_lifted_sorted_host. exfalso. enough (exists e, eIndex e = (maxIndex es) /\ In e (log (snd (nwState net host)))) by (break_exists; intuition; eapply findAtIndex_None; eauto). eapply contiguous_range_exact_lo_elim_exists; [apply lifted_entries_contiguous_invariant; auto|]. intuition. * find_apply_lem_hyp maxIndex_non_empty. break_exists; intuition; repeat find_rewrite. enough (eIndex x0 > 0) by lia. enough (eIndex x0 > pli) by lia. eapply lifted_entries_contiguous_nw_invariant; eauto. * enough (eIndex e' <= maxIndex (log (snd (nwState net host)))) by lia. apply maxIndex_is_max; auto. + find_copy_eapply_lem_hyp lifted_state_machine_safety_nw'_invariant; eauto. intuition; try solve [apply in_app_iff; right; apply removeAfterIndex_le_In; auto; lia]; [idtac]. break_exists. intuition. find_apply_lem_hyp maxIndex_non_empty. break_exists_name maxEntry; intuition. repeat find_rewrite. find_false. f_equal. find_apply_lem_hyp findAtIndex_elim. intuition. eapply uniqueIndices_elim_eq; [| |eauto|]; eauto using sorted_uniqueIndices,lifted_entries_sorted_nw. match goal with | |- In ?e _ => assert (lifted_committed net e (currentTerm (snd (nwState net host)))) by (unfold lifted_committed; exists host, e'; intuition; eapply lifted_no_entries_past_current_term_host_invariant; eauto) end. find_copy_eapply_lem_hyp lifted_state_machine_safety_nw'_invariant; eauto. intuition; try lia; enough (pli < eIndex maxEntry) by lia; eapply lifted_entries_contiguous_nw_invariant; eauto. Qed. Lemma handleAppendEntries_currentTerm_le : forall h st t n pli plt es ci st' m, handleAppendEntries h st t n pli plt es ci = (st', m) -> currentTerm st <= currentTerm st'. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; do_bool; auto. Qed. Theorem handleAppendEntries_log_detailed : forall h st t n pli plt es ci st' ps, handleAppendEntries h st t n pli plt es ci = (st', ps) -> (commitIndex st' = commitIndex st /\ log st' = log st) \/ (leaderId st' <> None /\ currentTerm st' = t /\ commitIndex st' = max (commitIndex st) (min ci (maxIndex es)) /\ es <> nil /\ pli = 0 /\ t >= currentTerm st /\ log st' = es /\ haveNewEntries st es = true ) \/ (leaderId st' <> None /\ currentTerm st' = t /\ commitIndex st' = max (commitIndex st) (min ci (maxIndex (es ++ (removeAfterIndex (log st) pli)))) /\ es <> nil /\ exists e, In e (log st) /\ eIndex e = pli /\ eTerm e = plt) /\ t >= currentTerm st /\ log st' = es ++ (removeAfterIndex (log st) pli) /\ haveNewEntries st es = true. 
r) ===> usl s p. Axiom nil_fwd : forall s n (p : W), p = 0 -> usl' s n p ===> [| s %= empty /\ n = O |]. Axiom nil_bwd : forall s n (p : W), p = 0 -> [| s %= empty /\ n = O |] ===> usl' s n p. Axiom cons_fwd : forall s n (p : W), p <> 0 -> usl' s n p ===> Ex n', Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| freeable p 2 /\ n = S n' /\ v %in s |]. Axiom cons_bwd : forall s n (p : W), p <> 0 -> (Ex n', Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| freeable p 2 /\ n = S n' /\ v %in s |]) ===> usl' s n p. End USL.Module Usl : USL. Open Scope Sep_scope. Fixpoint usl' (s : set) (n : nat) (p : W) : HProp := match n with | O => [| p = 0 /\ s %= empty |] | S n' => [| p <> 0 /\ freeable p 2 |] * Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| v %in s |] end. Definition usl (s : set) (p : W) := [| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r. Theorem usl'_extensional : forall s n p, HProp_extensional (usl' s n p). destruct n; reflexivity. Qed. Theorem usl_extensional : forall s p, HProp_extensional (usl s p). reflexivity. Qed. Theorem usl'_set_extensional : forall n s s' p, s %= s' -> usl' s n p ===> usl' s' n p. induction n; sepLemma. Qed. Theorem usl_fwd : forall s p, usl s p ===> [| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r. unfold usl; sepLemma. Qed. Theorem usl_bwd : forall s p, ([| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r) ===> usl s p. unfold usl; sepLemma. Qed. Theorem nil_fwd : forall s n (p : W), p = 0 -> usl' s n p ===> [| s %= empty /\ n = O |]. 
From stdpp Require Import namespaces. From iris.proofmode Require Import tactics. From iris.algebra Require Import excl. From Perennial.base_logic.lib Require Import invariants. From Perennial.program_logic Require Export weakestpre. From Perennial.Helpers Require Import Qextra.From Perennial.goose_lang Require Export lang typing. From Perennial.goose_lang Require Import proofmode wpc_proofmode notation crash_borrow. From Perennial.goose_lang Require Import persistent_readonly. From Perennial.goose_lang.lib Require Import typed_mem. From Perennial.goose_lang.lib Require Export rwlock.impl. From Perennial.goose_lang.lib Require Export rwlock.rwlock_noncrash. Require Import Field. Add Field Qcfield : Qcanon.Qcft. Set Default Proof Using "Type". Opaque crash_borrow.Section goose_lang. Context `{ffi_sem: ffi_semantics}. Context `{!ffi_interp ffi}. Context {ext_tys: ext_types ext}.Local Coercion Var' (s:string): expr := Var s.Section proof. Context `{!heapGS Σ} (N : namespace). Context `{!stagedG Σ}. Definition rfrac: Qp := (Qp.inv (Qp_of_Z (2^64)))%Qp. Definition is_crash_rwlock lk R Rc := is_rwlock N lk (λ q, crash_borrow (R q) (Rc q)). Global Instance is_crash_rwlock_persistent l R Rc : Persistent (is_crash_rwlock l R Rc). Proof. apply _. Qed. Definition is_free_lock (l: loc): iProp Σ := l ↦ #1 ∗ later_tok ∗ later_tok ∗ later_tok ∗ later_tok. Theorem is_free_lock_ty lk : is_free_lock lk -∗ ⌜val_ty #lk rwlockRefT⌝. Proof. iIntros "Hlk". iPureIntro. val_ty. Qed. Theorem alloc_lock E l R Rc : □ (∀ q1 q2, R (q1 + q2)%Qp ∗-∗ R q1 ∗ R q2) -∗ □ (∀ q1 q2, Rc (q1 + q2)%Qp ∗-∗ Rc q1 ∗ Rc q2) -∗ □ (∀ q, R q -∗ Rc q) -∗ l ↦ #1 -∗ crash_borrow (R 1%Qp) (Rc 1%Qp) ={E}=∗ is_crash_rwlock #l R Rc. 
in H; nauto. Qed. Local Hint Resolve ε₀_neq_0 : core. Lemma ε₀_closed_under_ω_exp : ∀α ∈ ε₀, ω ^ α ∈ ε₀. Proof with nauto. intros α Hα. assert (Hoα: α ⋵ 𝐎𝐍). apply (ord_is_ords ε₀)... apply ε₀E in Hα as [n [Hn Hα]]. apply (ε₀I n⁺). apply ω_inductive... rewrite ω_tower_suc... apply ordExp_preserve_lt... Qed. Definition ε_number := λ ε, ε ⋵ 𝐎𝐍 ∧ ω ^ ε = ε. Lemma ε₀_is_ε_number : ε₀ ⋵ ε_number. Proof with neauto. split... ext. - rewrite ordExp_limit in H... apply FUnionE in H as [α [Hα Hx]]. eapply ord_trans... apply ε₀_closed_under_ω_exp... - rewrite ordExp_limit... eapply FUnionI... apply ε₀E in H as [n [Hn Hx]]. eapply ordExp_enlarge_l_strictly... Qed. Lemma ε_number_neq_0 : ∀ε ⋵ ε_number, ε  0. Proof with eauto. intros ε [Hε Heq]. intros H. subst. rewrite ordExp_0_r in Heq... Qed. Lemma ε_number_neq_1 : ∀ε ⋵ ε_number, ε  1. Proof with neauto. intros ε [Hε Heq]. intros H. subst. rewrite ordExp_1_r in Heq... assert (1 ∈ ω)... rewrite Heq in H. eapply nat_irrefl... Qed. Lemma ε_number_has_tower_n : ∀n ∈ ω, ∀ε ⋵ ε_number, ω ^^ᴸ n ∈ ε. Proof with neauto. intros n Hn. ω_induction n; intros ε [Hε Heq]. - rewrite <- zero, ω_tower_0, <- Heq. apply ordExp_enlarge_r... apply ord_neq_0_1_gt_1... apply ε_number_neq_0. split... apply ε_number_neq_1. split... - rewrite ω_tower_suc, <- Heq... apply ordExp_preserve_lt... apply IH. split... Qed. Lemma ε₀_is_the_least_ε_number : ∀α ⋵ ε_number, ε₀ ⋸ α. Proof with eauto. intros ε [Hε Heq]. apply ord_le_iff_sub... intros x Hx. apply ε₀E in Hx as [n [Hn Hx]]. eapply ord_trans... apply ε_number_has_tower_n... split... Qed. Definition ε := Enumerate ε_number. Lemma ε_number_sub_𝐎𝐍 : ε_number ⫃ 𝐎𝐍. Proof. intros α []; auto. Qed. Local Hint Resolve ε_number_sub_𝐎𝐍 : core. Lemma ε_number_unbounded : unbounded ε_number. Proof. apply fixed_point_class_unbounded, ordExp_normal; nauto. Qed. Local Hint Resolve ε_number_unbounded : core. Lemma ε_spec : ∀α ⋵ 𝐎𝐍, ∀ξ ⋵ ε_number, ξ ∉ {ε x | x ∊ α} → ε α ⋸ ξ. Proof. intros α Hα ξ Hξ. apply enum_spec; auto. Qed. Lemma ε_is_ε_number : ε :ᶜ 𝐎𝐍 ⇒ ε_number. Proof. apply enum_into_class; auto. Qed. Local Hint Resolve ε_is_ε_number : core. Lemma ε_operative : ε :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍. Proof. intros. apply enum_operative; auto. Qed. Local Hint Resolve ε_operative : core. Theorem ε_0 : ε 0 = ε₀. Proof with auto. ord_ext... - apply ε_spec... apply ε₀_is_ε_number. intros H. apply ReplAx in H as [x [Hx _]]. exfalso0. - apply ε₀_is_the_least_ε_number... Qed. Theorem ε_monotone : monotone ε. 
Require Import List Permutation Arith.From Undecidability.ILL Require Import ILL CLL ill_cll.Set Implicit Arguments.Fact app_eq_single_inv X (l m : list X) x : l++m = x::nil -> l = nil /\ m = x::nil \/ l = x::nil /\ m = nil. Proof. intros H. destruct l as [ | y l ]; auto. right. inversion H. destruct l; destruct m; auto; discriminate. Qed.Tactic Notation "app" "inv" "singleton" "in" hyp(H) := apply app_eq_single_inv in H as [ (-> & ->) | (-> & ->) ].Tactic Notation "app" "inv" "nil" "in" hyp(H) := apply app_eq_nil in H as (-> & ->).Local Infix "~p" := (@Permutation _) (at level 70). Section S_ill_cll_restr. Notation "Γ '⊢i' A" := (S_ill_restr Γ A) (at level 70). Notation "Γ '⊢c' Δ" := (S_cll_restr Γ Δ) (at level 70). Hint Resolve Permutation_map : core. Theorem S_ill_cll_restr Γ A : Γ ⊢i A -> ⟦Γ⟧ ⊢c [A]:: . 
Import ConseqFacts. Import StoreB.Theorem semax_store_forward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall e1 e2 sh P, writable_share sh -> @semax CS Espec Delta (|> ( (tc_lvalue Delta e1) && (tc_expr Delta (Ecast e2 (typeof e1))) && (`(mapsto_ sh (typeof e1)) (eval_lvalue e1) * P))) (Sassign e1 e2) (normal_ret_assert (`(mapsto sh (typeof e1)) (eval_lvalue e1) (`force_val (`(sem_cast (typeof e2) (typeof e1)) (eval_expr e2))) * P)). Proof. intros. eapply semax_pre; [| apply semax_store_backward]. apply (exp_right sh). normalize. apply andp_left2. apply later_derives. apply andp_derives; auto. apply sepcon_derives; auto. apply wand_sepcon_adjoint. rewrite sepcon_comm. apply derives_refl. Qed.End StoreB2F.Module Type CLIGHT_SEPARATION_HOARE_LOGIC_CALL_FORWARD.Declare Module CSHL_Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF.Import CSHL_Def.Axiom semax_call_forward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall A P Q NEP NEQ ts x (F: environ -> mpred) ret argsig retsig cc a bl, Cop.classify_fun (typeof a) = Cop.fun_case_f (type_of_params argsig) retsig cc -> (retsig = Tvoid -> ret = None) -> tc_fn_return Delta ret retsig -> @semax CS Espec Delta ((|>((tc_expr Delta a) && (tc_exprlist Delta (snd (split argsig)) bl))) && (`(func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) && |>(F * `(P ts x: environ -> mpred) (make_args' (argsig,retsig) (eval_exprlist (snd (split argsig)) bl))))) (Scall ret a bl) (normal_ret_assert (EX old:val, substopt ret (`old) F * maybe_retval (Q ts x) retsig ret)).End CLIGHT_SEPARATION_HOARE_LOGIC_CALL_FORWARD.Module Type CLIGHT_SEPARATION_HOARE_LOGIC_CALL_BACKWARD.Declare Module CSHL_Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF.Import CSHL_Def.Axiom semax_call_backward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall ret a bl R, @semax CS Espec Delta (EX argsig: _, EX retsig: _, EX cc: _, EX A: _, EX P: _, EX Q: _, EX NEP: _, EX NEQ: _, EX ts: _, EX x: _, !! (Cop.classify_fun (typeof a) = Cop.fun_case_f (type_of_params argsig) retsig cc /\ (retsig = Tvoid -> ret = None) /\ tc_fn_return Delta ret retsig) && (|>((tc_expr Delta a) && (tc_exprlist Delta (snd (split argsig)) bl))) && `(func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) && |>((`(P ts x: environ -> mpred) (make_args' (argsig,retsig) (eval_exprlist (snd (split argsig)) bl))) * oboxopt Delta ret (maybe_retval (Q ts x) retsig ret -* R))) (Scall ret a bl) (normal_ret_assert R).End CLIGHT_SEPARATION_HOARE_LOGIC_CALL_BACKWARD.Module CallF2B (Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF) (Conseq: CLIGHT_SEPARATION_HOARE_LOGIC_CONSEQUENCE with Module CSHL_Def := Def) (Extr: CLIGHT_SEPARATION_HOARE_LOGIC_EXTRACTION with Module CSHL_Def := Def) (CallF: CLIGHT_SEPARATION_HOARE_LOGIC_CALL_FORWARD with Module CSHL_Def := Def): CLIGHT_SEPARATION_HOARE_LOGIC_CALL_BACKWARD with Module CSHL_Def := Def.Module CSHL_Def := Def. Module ConseqFacts := GenConseqFacts (Def) (Conseq). Module ExtrFacts := GenExtrFacts (Def) (Conseq) (Extr). Import Def. Import Conseq. Import ConseqFacts. Import Extr. Import ExtrFacts. Import CallF. Theorem semax_call_backward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall ret a bl R, @semax CS Espec Delta (EX argsig: _, EX retsig: _, EX cc: _, EX A: _, EX P: _, EX Q: _, EX NEP: _, EX NEQ: _, EX ts: _, EX x: _, !! (Cop.classify_fun (typeof a) = Cop.fun_case_f (type_of_params argsig) retsig cc /\ (retsig = Tvoid -> ret = None) /\ tc_fn_return Delta ret retsig) && (|>((tc_expr Delta a) && (tc_exprlist Delta (snd (split argsig)) bl))) && `(func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) && |>((`(P ts x: environ -> mpred) (make_args' (argsig,retsig) (eval_exprlist (snd (split argsig)) bl))) * oboxopt Delta ret (maybe_retval (Q ts x) retsig ret -* R))) (Scall ret a bl) (normal_ret_assert R). 
x input0_ Hin end end) _). - inversion Hr0; auto. - inversion Hr1; auto. - intros H; symmetry in H; move: H. apply eq_ind. eapply (ex_intro input0_). Defined. Defined. admit. Admitted. refine ((fun x' => ex_intro _ _) _). refine (ex_intro _). refine (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) _ x input0_). (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_). Definition s A (input0_ : A) := (fun x => conj (fun Hin => match Hin with | ex_intro s Hc => match Hc with | conj Hl Hin => nat_ind (fun n => forall x (input0_ : A), Basics.impl ((let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) x) ((@eq A) x input0_)) (fun x (input0_ : A) hin => match hin with | or_introl Hr0 => eq_ind _ _ (eq_refl _) _ Hr0 | or_intror Hl0 => False_ind _ Hl0 end) (fun size0 IHs x (input0_ : A) hin => match hin with | or_introl Hr1 => eq_ind _ _ (eq_refl _) _ Hr1 | or_intror Hl1 => False_ind _ Hl1 end) s x input0_ Hin end end) (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_)). *) Theorem plus_id_exercise : forall n m o : nat, n = m -> m = o -> n + m = m + o. Admitted. QuickChick plus_id_exercise.Theorem mult_0_plus : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem mult_S_1 : forall n m : nat, m = S n -> m * (1 + n) = m * m. Admitted. Theorem plus_1_neq_0_firsttry : forall n : nat, beq_nat (n + 1) 0 = false. Admitted. Theorem negb_involutive : forall b : bool, negb (negb b) = b. Admitted. Theorem andb_commutative : forall b c, andb b c = andb c b. 
- eapply_prop msg_refined_raft_net_invariant_do_generic_server'; eauto. eapply MRRIR_doGenericServer; eauto. Qed. Ltac workhorse := try match goal with | [ |- mkNetwork _ _ = mkNetwork _ _ ] => f_equal end; try match goal with | [ |- (fun _ => _) = (fun _ => _) ] => apply functional_extensionality; intros end; repeat break_match; repeat match goal with | [ H : (_, _) = (_, _) |- _ ] => invc H end; repeat (simpl in *; subst); repeat rewrite map_app; repeat rewrite map_map. Notation mgv_deghost := (@mgv_deghost _ _ ghost_log_params). Theorem simulation_1 : forall net, msg_refined_raft_intermediate_reachable net -> refined_raft_intermediate_reachable (mgv_deghost net). Proof using. intros. induction H. - constructor. - simpl in *. pose proof (RRIR_step_failure). specialize (H1 failed (mgv_deghost net) failed' (mgv_deghost net') out). apply H1; auto. apply (@mgv_ghost_simulation_1 _ _ _ ghost_log_params); auto. - unfold mgv_deghost in *. simpl in *. eapply RRIR_handleInput; eauto. + simpl in *. repeat break_match. simpl in *. eauto. + intros. simpl in *. repeat break_match; subst; simpl in *; repeat find_higher_order_rewrite; break_if; subst; simpl in *; congruence. + intros. simpl in *. in_crush. find_apply_hyp_hyp. in_crush. right. unfold add_ghost_msg in *. do_in_map. subst. simpl in *. apply in_map_iff. eauto. - unfold mgv_deghost in *. simpl in *. pose proof (RRIR_handleMessage). specialize (H5 (@mkPacket _ raft_refined_multi_params (pSrc p) (pDst p) (snd (pBody p)))). eapply H5; eauto. + simpl in *. repeat break_match. simpl in *. repeat find_rewrite. eauto. + simpl in *. unfold mgv_refined_base_params, raft_refined_base_params, refined_base_params, raft_msg_refined_multi_params, raft_refined_multi_params in *. simpl in *. unfold mgv_refined_base_params, raft_refined_base_params, refined_base_params, raft_msg_refined_multi_params, raft_refined_multi_params in *. simpl in *. repeat find_rewrite. map_crush. eauto. + intros. repeat break_match. simpl in *. repeat find_higher_order_rewrite. repeat break_match; congruence. + in_crush. find_apply_hyp_hyp. in_crush. right. unfold add_ghost_msg in *. do_in_map. subst. simpl in *. apply in_map_iff. eauto. - unfold mgv_deghost in *. simpl in *. eapply RRIR_doLeader; eauto. + simpl in *. repeat break_match. simpl in *. eauto. + simpl in *. intros. repeat break_match; simpl in *; repeat find_higher_order_rewrite; repeat break_match; congruence. + in_crush. find_apply_hyp_hyp. in_crush. right. unfold add_ghost_msg in *. do_in_map. subst. simpl in *. apply in_map_iff. eauto. - unfold mgv_deghost in *. simpl in *. eapply RRIR_doGenericServer; eauto. + simpl in *. repeat break_match. simpl in *. eauto. + simpl in *. intros. repeat break_match; simpl in *; repeat find_higher_order_rewrite; repeat break_match; congruence. + in_crush. find_apply_hyp_hyp. in_crush. right. unfold add_ghost_msg in *. do_in_map. subst. simpl in *. apply in_map_iff. eauto. Qed. Theorem msg_lift_prop : forall P, (forall net, refined_raft_intermediate_reachable net -> P net) -> (forall net, msg_refined_raft_intermediate_reachable net -> P (mgv_deghost net)). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.PRF. Require Import hmacfcf.splitVector. Require Import hmacfcf.cAU. Require Import FCF.CompFold.Local Open Scope list_scope.Section hF. Variable b k c : nat. Variable h : Bvector c -> Bvector b -> Bvector c. Variable F : Bvector k -> list (Bvector b) -> Bvector b. Definition hF key m := [k_Out, k_In] <-2 splitVector c k key; h k_Out (F k_In m). Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Hypothesis A_wf : well_formed_oc A. Definition G0 := k_in <-$ {0, 1}^k; k_out <-$ {0, 1}^c; [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Definition G1 := k_in <-$ {0, 1}^k; [b, _] <-$2 A _ _ (fun (s : list (Bvector b * Bvector c)) m => randomFunc ({0, 1}^c) _ s (F k_in m)) nil; ret b. Definition G2 := [b, _] <-$2 A _ _ (fun (s : list (list (Bvector b) * Bvector c)) m => randomFunc ({0, 1}^c) _ s m) nil; ret b. Definition G0_1 := [k_out, k_in] <-$2 ( key <-$ {0, 1}^(c + k); ret splitVector c k key); [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Theorem G0_1_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1]. 
-> Prop. Variable order_trans : forall a b c : A, order a b -> order b c -> order a c. Inductive ordered : list A -> Prop := | ordered_nil : ordered nil | ordered_one : forall a : A, ordered (a :: nil) | ordered_cons : forall (a b : A) (l : list A), order a b -> ordered (b :: l) -> ordered (a :: b :: l). Hint Constructors ordered : core. Theorem ordered_inv_order : forall (a b : A) (l : list A), ordered (a :: b :: l) -> order a b. Proof using. intros a b l H; inversion H; auto. Qed. Theorem ordered_inv : forall (a : A) (l : list A), ordered (a :: l) -> ordered l. Proof using. intros a l H; inversion H; auto. Qed. Theorem ordered_skip : forall (a b : A) (l : list A), ordered (a :: b :: l) -> ordered (a :: l). Proof using A order order_trans. intros a b l; case l; clear l; auto. intros c l H; apply ordered_cons. apply order_trans with (b := b); auto. apply ordered_inv_order with (1 := H). apply ordered_inv_order with (1 := ordered_inv _ _ H). apply ordered_inv with (1 := ordered_inv _ _ H). Qed. Theorem ordered_trans : forall (a b : A) (l : list A), ordered (a :: l) -> In b l -> order a b. Proof using A order order_trans. intros a b l; generalize a b; elim l; clear l a b. intros a b H H2; inversion H2. simpl in |- *; intros c l H a b H0 [H1| H1]. rewrite <- H1; apply ordered_inv_order with (1 := H0). apply order_trans with (b := c); auto. apply ordered_inv_order with (1 := H0). apply H; auto. apply ordered_inv with (1 := H0). Qed. Theorem ordered_trans_app : forall (a b : A) (l1 l2 : list A), ordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b. Proof using A order order_trans. intros a b l1 l2; generalize a b; elim l1; simpl in |- *; clear l1 a b. intros a b H H1; case H1. intros c l H a b H0 [H1| H1] H2. rewrite <- H1; apply ordered_trans with (1 := H0); auto with datatypes. apply H; auto. apply ordered_inv with (1 := H0); auto. Qed. Theorem ordered_perm_antisym_eq : (forall a b : A, order a b -> order b a -> a = b) -> forall l1 l2 : list A, permutation l1 l2 -> ordered l1 -> ordered l2 -> l1 = l2. 
q) | ltP_tl : forall x y p q, eqT x y -> ltP p q -> ltP (pX x p) (pX y q). Set Strict Implicit. Unset Implicit Arguments. Lemma fltP : forall p q, ltP p q -> Ltl _ ltM (fP p) (fP q). intros p q H'; elim H'; auto. simpl in |- *; intros; apply (Lt_nil (mon n)); auto. simpl in |- *; intros; apply (Lt_hd (mon n)); auto. simpl in |- *; unfold eqT in |- *; (intros x y p1 q1 H; rewrite H). simpl in |- *; intros; apply (Lt_tl (mon n)); auto. Qed. Hint Resolve fltP. Theorem ltp_not_refl : forall x, ~ ltP x x. intros x; elim x. red in |- *; intros H'; inversion H'. intros a l H'; red in |- *; intros H'0; simple inversion H'0. discriminate H. injection H1. injection H0. intros H'1 H'2 H'3 H'4; rewrite H'2; rewrite H'4; intros H'5. apply (ltT_not_refl a); auto. injection H1; injection H2. intros H'1 H'2 H'3 H'4; rewrite H'1; rewrite H'3; auto. Qed. Hint Resolve ltPO. Theorem ltP_trans : forall x y z, ltP x y -> ltP y z -> ltP x z. intros x y z H'; generalize z; clear z; elim H'. intros x0 p z; case z; auto. intros H'0; inversion H'0. intros x0 y0 p q H'0 z H'1; simple inversion H'1. discriminate H. rewrite <- H1. intros H'2; try assumption. apply ltP_hd; auto. apply ltT_trans with (y := y0); auto. injection H0. intros H'3 H'4; rewrite <- H'4; auto. rewrite <- H2. intros H'2 H'3; apply ltP_hd; auto. apply ltT_eqTl with (a := x1); auto. injection H1. intros H'4 H'5; rewrite H'5; auto. intros x0 y0 p q H'0 H'1 H'2 z H'3; simple inversion H'3. discriminate H. rewrite <- H1; auto. intros H'4; apply ltP_hd; auto. apply ltT_eqTr with (a := y0). apply (eqT_sym A n); auto. injection H0. intros H'5 H'6; rewrite <- H'6; auto. rewrite <- H2. intros H'4 H'5; apply ltP_tl; auto. apply (eqT_trans A n) with (y := x1); auto. injection H1. intros H'6 H'7; rewrite H'7; auto. apply H'2; auto. injection H1. intros H'6; rewrite <- H'6; auto. Qed. Theorem olist_pX_ltP : forall a p, olist (pX a p) -> ltP p (pX a pO). intros a p; case p; auto. intros b l H'. apply ltP_hd; auto. apply olist_pX_order with (l := l); auto. Qed. Theorem ltP_pX_olist : forall a p, olist p -> ltP p (pX a pO) -> olist (pX a p). 
Require Import List Arith Omega. Require Import utils_tac utils_list sums php.Set Implicit Arguments.Local Notation "∑" := (msum plus 0).Section nat_swap. Variables (i j : nat). Definition swap n := if eq_nat_dec n i then j else if eq_nat_dec n j then i else n. Fact swap_spec_i : swap i = j. Proof. unfold swap; destruct (eq_nat_dec i i); auto; omega. Qed. Fact swap_spec_j : swap j = i. Proof. unfold swap. destruct (eq_nat_dec j i); auto. destruct (eq_nat_dec j j); auto; omega. Qed. Fact swap_spec n : n <> i -> n <> j -> swap n = n. Proof. unfold swap; intros. destruct (eq_nat_dec n i); try omega. destruct (eq_nat_dec n j); omega. Qed. Fact swap_involutive n : swap (swap n) = n. Proof. destruct (eq_nat_dec n i). { subst n; rewrite swap_spec_i, swap_spec_j; auto. } destruct (eq_nat_dec n j). { subst n; rewrite swap_spec_j, swap_spec_i; auto. } { do 2 (rewrite swap_spec; auto). } Qed. Fact swap_inj n m : swap n = swap m -> n = m. Proof. intros; rewrite <- (swap_involutive n), H. apply swap_involutive. Qed. End nat_swap.Opaque swap.Section php_fun. Variable (n : nat) (f : nat -> nat) (Hf : forall i, i <= n -> f i < n). Theorem php_fun : exists i j, i < j <= n /\ f i = f j. 
Require Export FroundProp. Require Export Closest. Section Fclosestp2. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Coercion FtoRradix : float >-> R. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Theorem ClosestOpp : forall (p : float) (r : R), Closest b radix r p -> Closest b radix (- r) (Fopp p). intros p r H'; split. apply oppBounded; auto. case H'; auto. intros f H'0. rewrite Fopp_correct. replace (- FtoR radix p - - r)%R with (- (FtoR radix p - r))%R; [ idtac | ring ]. replace (FtoR radix f - - r)%R with (- (- FtoR radix f - r))%R; [ idtac | ring ]. rewrite <- Fopp_correct. repeat rewrite Rabs_Ropp. case H'; auto with float. Qed. Theorem ClosestFabs : forall (p : float) (r : R), Closest b radix r p -> Closest b radix (Rabs r) (Fabs p). 
len key tss p. Axiom stack_cons_fwd : forall len key tss (p : W), p <> 0 -> stack len key tss p ===> Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p'. Axiom stack_cons_bwd : forall len key tss (p : W), p <> 0 -> (Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p') ===> stack len key tss p. End ADT.Module Adt : ADT. Open Scope Sep_scope. Fixpoint tree (len key : W) (sk : skel) (ts : tuples) (p : W) : HProp := match sk with | Leaf => [| p = 0 |] * [| empty ts |] | Node sk1 sk2 => [| p <> 0 |] * Ex p1, Ex k, Ex t0, Ex p2, (p ==*> p1, k, t0, p2) * tree len key sk1 (keepLt ts key k) p1 * tuples0 len (keepEq ts key k) t0 * tree len key sk2 (keepGt ts key k) p2 end. Fixpoint stack (len key : W) (tss : list (tuples * W)) (p : W) : HProp := match tss with | nil => [| p = 0 |] | (ts, tp) :: tss' => [| p <> 0 |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p' end. Definition tuples1 (len key : W) (ts : tuples) (c : W) : HProp := [| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]. Theorem stack_nil_fwd : forall len key tss (p : W), p = 0 -> stack len key tss p ===> [| tss = nil |]. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_nil_bwd : forall len key tss (p : W), p = 0 -> [| tss = nil |] ===> stack len key tss p. 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.PRF. Require Import hmacfcf.splitVector. Require Import hmacfcf.cAU. Require Import FCF.CompFold.Local Open Scope list_scope.Section hF. Variable b k c : nat. Variable h : Bvector c -> Bvector b -> Bvector c. Variable F : Bvector k -> list (Bvector b) -> Bvector b. Definition hF key m := [k_Out, k_In] <-2 splitVector c k key; h k_Out (F k_In m). Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Hypothesis A_wf : well_formed_oc A. Definition G0 := k_in <-$ {0, 1}^k; k_out <-$ {0, 1}^c; [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Definition G1 := k_in <-$ {0, 1}^k; [b, _] <-$2 A _ _ (fun (s : list (Bvector b * Bvector c)) m => randomFunc ({0, 1}^c) _ s (F k_in m)) nil; ret b. Definition G2 := [b, _] <-$2 A _ _ (fun (s : list (list (Bvector b) * Bvector c)) m => randomFunc ({0, 1}^c) _ s m) nil; ret b. Definition G0_1 := [k_out, k_in] <-$2 ( key <-$ {0, 1}^(c + k); ret splitVector c k key); [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Theorem G0_1_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1]. unfold PRF_G_A, G0_1. inline_first. comp_skip. unfold f_oracle, hF. remember (splitVector c k x) as z. comp_simp. reflexivity. Qed. Require Import FCF.DetSem FCF.SemEquiv. Theorem G0_1_G0_equiv : Pr[G0_1] == Pr[G0]. unfold G0_1, G0. eapply eqRat_trans. eapply evalDist_seq_eq. eapply Rnd_split_equiv. intros. eapply eqRat_refl. inline_first. comp_swap_r. comp_skip. inline_first. comp_skip. Qed. Theorem G0_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0]. 
A0 eqA ltM)) (p q : list (Term A n)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p. intros Q p q H'; elim H'; auto. intros p0 q0 H'0 H'1 H'2 H'3. apply CombLinear_reduceplus with (q := q0); auto. Qed. Theorem Reducestar_pO_imp_CombLinear : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n q (pO A n) -> CombLinear Q p. intros Q p q H' H'0 H'1; inversion H'1; auto. apply CombLinear_reducestar with (q := q); auto. rewrite <- H; auto. Qed. Inductive Grobner (Q : list (poly A0 eqA ltM)) : Prop := Grobner0 : (forall p q : list (Term A n), CombLinear Q p -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> eqP A eqA n q (pO A n)) -> Grobner Q. Theorem Grobner_imp_SpolyQ : forall Q : list (poly A0 eqA ltM), Grobner Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q. intros Q H'; elim H'. intros H'1. apply SpolyQ0; auto. intros p q H'0 H'2 H'3 H'4. elim reduce0_reducestar with (ltM_dec := ltM_dec) (eqA_dec := eqA_dec) (1 := cs) (Q := Q) (p := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q H'2 H'4); auto. intros t E; apply Spoly_10 with (Cp := H'2) (Cq := H'4); auto. apply reducestar_eqp_com with (1 := cs) (p := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q H'2 H'4) (q := t); auto. apply spolyf_canonical with (1 := cs); auto. apply H'1 with (p := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q H'2 H'4); auto. apply CombLinear_spoly; auto. apply spolyf_canonical with (1 := cs); auto. Qed. Inductive ConfluentReduce (Q : list (poly A0 eqA ltM)) : Prop := ConfluentReduce0 : (forall p : list (Term A n), canonical A0 eqA ltM p -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p) -> ConfluentReduce Q. Theorem SpolyQ_imp_ConfluentReduce : forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce Q. 
rewrite exps_length_trans. f_equal. rewrite -(trans_shift' prims p e' t k 0 ev wf H). now rewrite N.add_0_l. lia_f_equal. Qed.Lemma subst_subst_list e k t args : subst e k (subst_list t args) = subst_list (subst e (exps_length args + k) t) (substs e k args). Proof. induction args in e, k, t |- *; cbn; auto. rewrite substs_map_exps exps_length_map. rewrite IHargs. f_equal. 2:rewrite substs_map_exps //. pose proof substitution. simpl in H. rewrite H. lia. lia_f_equal. Qed.Lemma sbst_list_subst_list t args : exps_wf 0 args -> subst_list t args = sbst_list t args. Proof. induction args in t |- *; cbn. - now cbn. - intros ewf; depelim ewf. rewrite (proj1 (closed_subst_sbst _ _)); auto. rewrite -IHargs //. rewrite subst_subst_list. lia_f_equal. pose proof (proj1 (proj2 (subst_closed_id e))). simpl in H0. rewrite (H0 0) //. Qed.Lemma subst_env_aux_subst' e a k k' b : k' <= k -> subst_env_aux e k (subst a k' b) = subst (subst_env_aux e (k - k') a) k' (subst_env_aux e (1 + k) b). Proof. revert a k b. induction e; simpl; intros. reflexivity. pose (substitution b a0 (snd a) k' k). simpl in e0. rewrite e0; try lia. rewrite IHe //. Qed.Lemma subst_env_aux_subst_list (e : env) (a : exp) (k : N) (b : exps) : subst_env_aux e k (subst_list a b) = subst_list (subst_env_aux e (exps_length b + k) a) (map_exps (subst_env_aux e k) b). Proof. induction b in a, k |- *; cbn; auto. rewrite exps_length_map {}IHb. f_equal. rewrite subst_env_aux_subst'. lia. lia_f_equal. Qed.Tactic Notation "relativize" open_constr(c) := let ty := type of c in let x := fresh in evar (x : ty); replace c with x; subst x.Lemma sbst_list_instantiate e e' n brs nargs args t : crctEnv e -> eval_env (translate_env [] e) e' -> wf_tr_environ e' -> crctTerms e 0 args -> crctTerm e 0 (instantiatel args 0 t) -> List.length nargs = tlength args -> crctBs e 0 brs -> bnth n brs = Some (nargs, t) -> subst_env_aux e' 0 (trans e' [] 0 (instantiatel args 0 t)) = (subst_list (subst_env_aux e' (N.of_nat (Datatypes.length nargs)) (trans e' [] (N.of_nat (Datatypes.length nargs)) t)) (map_exps (subst_env_aux e' 0) (trans_args (trans e' []) 0 args))). Proof. intros cre crargs crt hn. intros crct hneq crbs hbr. eapply bnth_pres_Crct in crbs; eauto. rewrite Nat.add_0_r in crbs. rewrite (trans_instantiatel [] e e' _ 0); auto. rewrite -hneq Nat.add_0_r //. rewrite subst_env_aux_subst_list. lia_f_equal. rewrite exps_length_trans. lia. Qed. Theorem translate_correct_subst prims (Heq : prims = []) (e : environ Term) (t t' : Term) : crctEnv e -> crctTerm e 0 t -> L3eval.WcbvEval e t t' -> let e' := translate_env prims e in forall e'', eval_env e' e'' -> eval (subst_env e'' (translate e'' prims t)) (subst_env e'' (translate e'' prims t')). 
From Huffman Require Export BTree. From Huffman Require Export Ordered. Require Import ArithRing. Section WeightTree. Variable A : Type. Variable f : A -> nat.Fixpoint sum_leaves (t : btree A) : nat := match t with | leaf n => f n | node t1 t2 => sum_leaves t1 + sum_leaves t2 end.Definition sum_order x y := sum_leaves x <= sum_leaves y.Definition le_sum x y := le_bool (sum_leaves x) (sum_leaves y). Theorem le_sum_correct1 : forall a b1 : btree A, le_sum a b1 = true -> sum_order a b1. Proof using. intros a b1; apply (le_bool_correct3 (sum_leaves a) (sum_leaves b1)). Qed. Theorem le_sum_correct2 : forall a b1 : btree A, le_sum a b1 = false -> sum_order b1 a. Proof using. intros a b1; apply (le_bool_correct4 (sum_leaves a) (sum_leaves b1)). Qed. Fixpoint weight_tree (t : btree A) : nat := match t with | leaf n => 0 | node t1 t2 => sum_leaves t1 + weight_tree t1 + (sum_leaves t2 + weight_tree t2) end. Definition weight_tree_list : list (btree A) -> nat := fold_right (fun x : btree A => plus (weight_tree x)) 0. Theorem weight_tree_list_node : forall (t1 t2 : btree A) (l : list (btree A)), weight_tree_list (node t1 t2 :: l) = sum_leaves t1 + sum_leaves t2 + weight_tree_list (t1 :: t2 :: l). Proof using. intros t1 t2 l; simpl in |- *; ring. Qed. Theorem weight_tree_list_permutation : forall l1 l2 : list (btree A), permutation l1 l2 -> weight_tree_list l1 = weight_tree_list l2. Proof using. intros l1 l2 H; elim H; auto. simpl in |- *; auto; intros; ring. simpl in |- *; auto; intros; ring. intros l0 l3 l4 H0 H1 H2 H3; apply trans_equal with (1 := H1); auto. Qed. End WeightTree. Arguments sum_leaves [A]. Arguments sum_order [A]. Arguments le_sum [A]. Arguments weight_tree [A]. Arguments weight_tree_list [A]. Theorem ordered_sum_leaves_eq : forall (A : Type) (f : A -> nat) (l1 l2 : list (btree A)), permutation l1 l2 -> ordered (sum_order f) l1 -> ordered (sum_order f) l2 -> map (sum_leaves f) l1 = map (sum_leaves f) l2. 
CPrdE1 in Hp as [a [Ha [b [Hb Hp]]]]. subst p. apply CPrdI... eapply ω_trans... * exists 1. split... apply meta_function. intros _ _... + intros x1 Hx1 x2 Hx2 Heq. assert (< , x1> ∈ Func 1 A (λ _, x1)). { apply SepI. apply CPrdI... apply suc_has_0... zfc_simple. } rewrite Heq in H. apply SepE in H as [_ H]. zfc_simple. Qed. Lemma sq_sub_ifunion_arrow : ∀ A, 𝗦𝗾 A ⊆ ⋃ᵢ λ i, i ⟶ A. Proof with eauto. intros A f Hf. apply SepE in Hf as [_ [n [Hn Hf]]]. eapply IFUnionI... apply arrowI... Qed. Fact ω_eqnum_sq_ω : ω ≈ 𝗦𝗾 ω. Proof. apply Schröeder_Bernstein. apply dominated_by_sq. eapply dominate_trans. apply dominate_sub. apply sq_sub_ifunion_arrow. apply ifunion_arrow_ω_cnt. Qed.Fact sq_cnt : ∀ A, countable A → countable (𝗦𝗾 A). Proof with eauto; try congruence. intros A [g Hg]. eapply dominate_trans; revgoals. { apply eqnum_dominate. now rewrite ω_eqnum_sq_ω. } set (Func (𝗦𝗾 A) (𝗦𝗾 ω) (λ f, Func (dom f) ω (λ n, g[f[n]]) )) as F. exists F. apply meta_injection. - intros f Hf. apply SepE in Hf as [_ [n [Hn Hf]]]. assert (Hf' := Hf). destruct Hf' as [_ [Hdf _]]. apply SepI. + apply PowerAx. intros p Hp. apply SepE in Hp as [Hp _]. apply CPrdE1 in Hp as [a [Ha [b [Hb Hp]]]]. subst p. apply CPrdI... eapply ω_trans... + exists n. split... rewrite Hdf. apply meta_function. intros x Hx. eapply ap_ran. apply injection_is_func... eapply ap_ran... - intros f1 H1 f2 H2 Heq. apply SepE in H1 as [_ [n1 [Hn1 [Hf1 [Hdf1 Hrf1]]]]]. apply SepE in H2 as [_ [n2 [Hn2 [Hf2 [Hdf2 Hrf2]]]]]. assert (Hf1x: ∀x ∈ dom f1, f1[x] ∈ A). { intros x Hx. eapply ap_ran... split... } assert (Hf2x: ∀x ∈ dom f2, f2[x] ∈ A). { intros x Hx. eapply ap_ran... split... } assert (H1: ∀x ∈ dom f1, g[f1[x]] ∈ ω). { intros x Hx. eapply ap_ran. apply injection_is_func... apply Hf1x... } assert (H2: ∀x ∈ dom f2, g[f2[x]] ∈ ω). { intros x Hx. eapply ap_ran. apply injection_is_func... apply Hf2x... } apply func_ext_elim in Heq as [Heq1 Heq2]; [|apply func_is_func..]. rewrite meta_dom, meta_dom in Heq1... rewrite meta_dom in Heq2... apply func_ext_intro... intros x Hx. apply Heq2 in Hx as Heq. rewrite meta_func_ap, meta_func_ap in Heq; revgoals... apply meta_function... apply meta_function... destruct Hg as [Hi [Hd Hr]]. eapply injectiveE; eauto; rewrite Hd. apply Hf1x... apply Hf2x... Qed. Theorem cardLe_union : AC_I → ∀ 𝒜, ∀ ⋵ 𝐂𝐃, (∀A ∈ 𝒜, |A| ≤  ) → |⋃ 𝒜| ≤ |𝒜|   . 
(a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. induction x1; intuition; simpl in *. remember (split x1) as z. destruct z. simpl in *. unfold collidesWith in *. simpl in *. case_eq (eqb b2 b1); intuition. rewrite H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem randomFunc_mem_preserves_coll : forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (randomFunc_mem _ _ RndR c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold randomFunc_mem in *. destruct (arrayLookup _ c0 (a, b0)). repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem F_randomFunc_wf : forall x y z, well_formed_comp (F_randomFunc x y z). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import hmacfcf.HMAC_spec. Require Import FCF.PRF. Require Import hmacfcf.NMAC_to_HMAC. Require Import hmacfcf.hF. Require Import hmacfcf.GNMAC_PRF.Section GHMAC_PRF. Variable c p : nat. Definition b := @b c p. Variable h : Bvector c -> Bvector b -> Bvector c. Variable iv : Bvector c. Variable fpad : Bvector c -> Bvector p. Variable opad ipad : Bvector b. Hypothesis opad_ne_ipad : opad <> ipad. Definition GHMAC := GHMAC h iv fpad opad ipad. Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Hypothesis A_wf : well_formed_oc A. Theorem GHMAC_PRF : PRF_Advantage (Rnd b) (Rnd c) GHMAC _ _ A <= RKA_Advantage _ _ _ ({ 0 , 1 }^b) ({ 0 , 1 }^c) (dual_f h) (BVxor b) (HMAC_RKA_A h iv fpad opad ipad A) + (PRF_Advantage ({ 0 , 1 }^c) ({ 0 , 1 }^c) h _ _ (PRF_h_A (h_star_pad h fpad) A) + cAU.Adv_WCR _ _ (h_star_pad h fpad) ({ 0 , 1 }^c) (au_F_A A)). 
Require Import Coq.omega.Omega. Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Bootstrap Bedrock.Platform.Malloc Bedrock.Platform.Buffers Bedrock.Platform.XmlLex Bedrock.Platform.XmlLang Bedrock.Platform.Arrays8 Bedrock.Platform.ArrayOps. Require Import Bedrock.Platform.RelDb Bedrock.Platform.XmlOutput Bedrock.Platform.Bags Bedrock.Platform.Io Bedrock.Platform.Http Bedrock.Platform.HttpQ Bedrock.Platform.Thread. Module Type HIDE. Parameter heapSize4 : N -> N. Axiom heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. Parameter to_nat : N -> nat. Axiom to_nat_eq : to_nat = N.to_nat. End HIDE.Module Hide : HIDE. Definition heapSize4 n := (n * 4)%N. Theorem heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. auto. Qed. Definition to_nat := N.to_nat. Theorem to_nat_eq : to_nat = N.to_nat. auto. Qed. End Hide.Record wf (ts : tables) (pr : program) (buf_size outbuf_size : N) : Prop := { WellFormed : XmlLang.wf ts pr; NotTooGreedy : (reserved pr <= 86)%nat; Buf_size_lower : (buf_size >= 2)%N; Buf_size_upper : (buf_size * 4 < Npow2 32)%N; Outbuf_size_lower : (outbuf_size >= 2)%N; Outbuf_size_upper : (outbuf_size * 4 < Npow2 32)%N; ND : NoDup (Names ts); GoodSchema : twfs ts; UF : uf ts }.Module Type S. Parameter ts : tables. Parameter pr : program. Parameters buf_size outbuf_size heapSize : N. Axiom Wf : wf ts pr buf_size outbuf_size. Parameters port numWorkers : W. End S.Module Make(M : S). Import M.Module Locations. Definition globalSched : W := ((heapSize + 50) * 4)%N. Definition globalSock : W := globalSched ^+ $4. End Locations.Import Locations.Module M'''. Definition globalSched := globalSched. Local Open Scope Sep_scope. Definition globalInv (fs : files) : HProp := db ts * Ex fr, globalSock =*> fr * [| fr %in fs |]. End M'''.Module T := Thread.Make(M''').Import T M'''. Export T M'''.Module MyM. Definition sched := sched. Definition globalInv := globalInv. Definition buf_size := outbuf_size. Theorem buf_size_lower : (nat_of_N buf_size >= 2)%nat. 
sumList_body_eq. intuition. eapply ratMult_assoc. } eapply NoDup_Permutation. eapply filter_NoDup. eapply getUnique_NoDup. eapply getSupport_NoDup. intuition. apply filter_In in H1. intuition. destruct (in_dec (EqDec_dec H) x (getSupport (c2 a0))). trivial. discriminate. eapply filter_In. intuition. eapply in_getUnique. eapply in_flatten. econstructor. split. eapply in_map_iff. econstructor. split. eapply eq_refl. eauto. eauto. destruct (in_dec (EqDec_dec H) x (getSupport (c2 a0)) ). trivial. intuition. Qed.Theorem evalDist_commute_eq : forall (A B : Set)(c1 : Comp A)(c2 : Comp B)(C : Set)(c3 : A -> B -> Comp C), dist_sem_eq (a <-$ c1; b <-$ c2; (c3 a b)) (b <-$ c2; a <-$ c1; (c3 a b)). intuition. unfold dist_sem_eq. intuition. simpl. eapply eqRat_trans. eapply sumList_body_eq. intuition. symmetry. eapply sumList_factor_constant_l. symmetry. eapply eqRat_trans. eapply sumList_body_eq. intuition. symmetry. eapply sumList_factor_constant_l. rewrite sumList_summation. eapply sumList_body_eq. intuition. eapply sumList_body_eq. intuition. repeat rewrite <- ratMult_assoc. eapply ratMult_eqRat_compat; intuition. eapply ratMult_comm. Qed.Lemma evalDist_Repeat_eq : forall (A : Set)(c1 c2 : Comp A)(P1 P2 : A -> bool) v1 v2, evalDist c1 v1 == evalDist c2 v2 -> P1 v1 = P2 v2 -> In v1 (filter P1 (getSupport c1)) -> sumList (filter P1 (getSupport c1)) (evalDist c1) == sumList (filter P2 (getSupport c2)) (evalDist c2) -> evalDist (Repeat c1 P1) v1 == evalDist (Repeat c2 P2) v2. intuition. simpl. eapply ratMult_eqRat_compat; intuition. eapply ratMult_eqRat_compat. unfold indicator. rewrite H0. intuition. eapply ratInverse_eqRat_compat. intuition. eapply getSupport_In_evalDist. eapply filter_In. eauto. eapply sumList_0 in H3; eauto. trivial. Qed.Definition intersect(A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) := filter (fun x => if (in_dec eqd x ls1) then true else false) ls2. Lemma in_intersect : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a, In a (intersect eqd ls1 ls2) <-> In a ls1 /\ In a ls2. unfold intersect in *. intuition. apply filter_In in H. intuition. destruct (in_dec eqd a ls1). trivial. discriminate. apply filter_In in H. intuition. eapply filter_In. intuition. destruct (in_dec eqd a ls1); intuition. Qed.Lemma intersect_comm : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A), NoDup ls1 -> NoDup ls2 -> Permutation (intersect eqd ls1 ls2) (intersect eqd ls2 ls1). intuition. eapply NoDup_Permutation. apply filter_NoDup; trivial. apply filter_NoDup; trivial. unfold intersect in *. intuition. apply filter_In. apply filter_In in H1. intuition. destruct (in_dec eqd x ls1); intuition. discriminate. destruct (in_dec eqd x ls2); intuition. apply filter_In. apply filter_In in H1. intuition. destruct (in_dec eqd x ls2); intuition. discriminate. destruct (in_dec eqd x ls1); intuition. Qed. Theorem fundamental_lemma_h : forall (A : Set)(eqda : EqDec A)(c1 c2 : Comp (A * bool)), (evalDist (Bind c1 (fun x => ret snd x)) true == evalDist (Bind c2 (fun x => ret snd x)) true) -> (forall a, evalDist c1 (a, false) == evalDist c2 (a, false)) -> forall a, ratDistance (evalDist (Bind c1 (fun x => ret (fst x))) a) (evalDist (Bind c2 (fun x => ret (fst x))) a) <= evalDist (Bind c1 (fun x => ret snd x)) true. 
op_group. Theorem op_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof Group.op_neg_def op_group. Theorem op_neg_inj : is_injective E E op_neg. Proof Group.op_neg_inj op_group. Theorem op_cancel_neg : forall x : E, op_neg (- x) = x. Proof Group.op_cancel_neg op_group. Theorem op_neg_onto : is_onto E E op_neg. Proof Group.op_neg_onto op_group. Theorem op_neg_bijective : is_bijective E E op_neg. Proof Group.op_neg_bijective op_group. Theorem op_neg_rev : forall x y : E, - x = y -> - y = x. Proof Group.op_neg_rev op_group. Theorem op_neg_distrib_inv_l : forall x y : E, op_is_inv_l (x + y) (- y + - x). Proof Group.op_neg_distrib_inv_l op_group. Theorem op_neg_distrib_inv_r : forall x y : E, op_is_inv_r (x + y) (- y + - x). 
-> forall p h t ll e, In (t, ll) (leaderLogs (fst (nwState net h))) -> In e ll -> In p (nwPackets net) -> pBody p = RequestVoteReply (eTerm e) true -> currentTerm (snd (nwState net (pDst p))) = eTerm e -> wonElection (dedup name_eq_dec (pSrc p :: votesReceived (snd (nwState net (pDst p))))) = true -> type (snd (nwState net (pDst p))) <> Candidate. Proof using. intros. eapply_prop_hyp leaderLogs_candidateEntries In; eauto. eapply wonElection_candidateEntries_rvr; auto. eauto. auto. auto. Qed. Theorem leaderLogs_sublog_request_vote_reply : refined_raft_net_invariant_request_vote_reply leaderLogs_sublog. Proof using vci cci llcei lltsi lsi rri. unfold refined_raft_net_invariant_request_vote_reply, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleRequestVoteReply_RVR_spec. intuition. - subst. repeat find_rewrite. repeat update_destruct_max_simplify; eauto; find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition eauto; unfold raft_data in *; congruence. - repeat update_destruct_max_simplify; try congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition eauto. subst_max. repeat find_rewrite. discriminate. + eauto. - repeat update_destruct_max_simplify. + repeat find_rewrite. find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * exfalso. eauto using contradict_leaderLogs_term_sanity. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. exfalso. eapply leaderLogs_candidate_entries_rvr; eauto; eauto using leaderLogs_candidate_entries_invariant, votes_correct_invariant, cronies_correct_invariant. congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * eauto. * subst. unfold raft_data in *. repeat find_rewrite. eapply lifted_leader_sublog_host; eauto. + eauto. - repeat update_destruct_max_simplify. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. eauto. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. discriminate. + eauto. Qed. Theorem leaderLogs_sublog_do_leader : refined_raft_net_invariant_do_leader leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_leader, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doLeader_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doLeader_same_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_do_generic_server : refined_raft_net_invariant_do_generic_server leaderLogs_sublog. 
destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. destruct H33. auto. Qed. Lemma INV_step_total_Supply_fixed: forall env C C' E' msg , step env C msg C' E' -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. inversion H. - subst spec. destruct H6 as [H61 [H62 H63]]. rewrite H5 in H63. destruct H63. auto. - subst spec. destruct H6 as [H61 [H62 H63]]. rewrite H5 in H63. destruct H63. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. rewrite H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. - subst spec. destruct H3 as [H31 [H32 H33]]. rewrite H1 in H33. simpl in H33. destruct H33. auto. Qed.Theorem Property_totalSupply_fixed_after_initialization: forall env0 env msg C E C' E', create env0 msg C E -> step env C msg C' E' -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. apply INV_step_total_Supply_fixed with env E' msg. auto. Qed.Lemma INV_steps_total_supply_fixed: forall ml env0 C0 C E env, steps env0 C0 ml env C E -> (st_totalSupply (w_st C0)) = (st_totalSupply (w_st C)). Proof. intros ml. induction ml. + intros. unfold steps in H. destruct H. rewrite H. trivial. + intros. inversion_clear H. rename x into envx. inversion H0 as [C'' [E'' [E' [Hs1 [Hs2 [Hs3 Hs4]]]]]]. apply INV_step_total_Supply_fixed in Hs1. apply IHml in Hs2. rewrite Hs1. auto. Qed.Theorem Property_totalSupply_fixed_after_initialization1: forall env0 env msg ml C E C' E', create env0 msg C E -> run env C ml C' E' -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. unfold run in H0. inversion H0 as [env' H0']. apply INV_steps_total_supply_fixed in H0'. auto. Qed. Theorem Property_totalSupply_fixed_delegate_transfer_1: forall env C C' E' from msg to v spec, spec = funcspec_transferFrom_1 from to v (w_a C) env msg -> (spec_require spec) (w_st C) /\ (spec_events spec) (w_st C) E' /\ (spec_trans spec) (w_st C) (w_st C') -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). 
Require Import Bedrock.Platform.Thread Bedrock.Platform.Arrays8 Bedrock.Platform.MoreArrays Bedrock.Platform.Buffers Bedrock.Platform.Io Bedrock.Platform.tests.StringDb. Require Import Coq.Strings.Ascii.Definition W_of_ascii (ch : ascii) : W := N_of_ascii ch. Coercion W_of_ascii : ascii >-> W.Local Hint Extern 1 (@eq W _ _) => words. Section strings. Open Scope Sep_scope. Fixpoint strings (n : nat) (p : W) : HProp := Ex len, p =*> len * match n with | O => [| len = 0 |] | S n' => [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Definition strings' (n : nat) (p len : W) : HProp := match n with | O => [| len = 0 |] | S n' => [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Theorem strings_fwd : forall n p, strings n p ===> Ex len, p =*> len * strings' n p len. destruct n; sepLemma. Qed. Theorem strings_bwd : forall n p, Ex len, p =*> len * strings' n p len ===> strings n p. destruct n; sepLemma. Qed. Theorem strings'_fwd_zero : forall n p (len : W), len = 0 -> strings' n p len ===> Emp. destruct n; sepLemma. Qed. Theorem strings'_fwd_nonzero : forall n p (len : W), len <> 0 -> strings' n p len ===> Ex n', [| n = S n' |] * [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len'). destruct n; sepLemma. Qed. Definition keyValues := starB (fun p => Ex q, Ex len, q =*> len * (q ^+ $4) =?>8 wordToNat len * [| p = q ^+ $4 ^+ len |] * Ex len', p =*> len' * (p ^+ $4) =?>8 wordToNat len'). Theorem keyValues_empty_bwd : Emp ===> keyValues empty. 
(x + ulp x). Proof. intros x Zx Fx. destruct (mag beta x) as (ex, Ex). specialize (Ex (Rgt_not_eq _ _ Zx)). assert (Ex' := Ex). rewrite Rabs_pos_eq in Ex'. destruct (id_p_ulp_le_bpow x ex) ; try easy. unfold generic_format, scaled_mantissa, cexp. rewrite mag_unique with beta (x + ulp x)%R ex. pattern x at 1 3 ; rewrite Fx. rewrite ulp_neq_0. unfold scaled_mantissa. rewrite cexp_fexp with (1 := Ex). unfold F2R. simpl. rewrite Rmult_plus_distr_r. rewrite Rmult_assoc. rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r. change (bpow 0) with 1%R. rewrite <- plus_IZR. rewrite Ztrunc_IZR. rewrite plus_IZR. rewrite Rmult_plus_distr_r. now rewrite Rmult_1_l. now apply Rgt_not_eq. rewrite Rabs_pos_eq. split. apply Rle_trans with (1 := proj1 Ex'). pattern x at 1 ; rewrite <- Rplus_0_r. apply Rplus_le_compat_l. apply ulp_ge_0. exact H. apply Rplus_le_le_0_compat. now apply Rlt_le. apply ulp_ge_0. rewrite H. apply generic_format_bpow. apply valid_exp. destruct (Zle_or_lt ex (fexp ex)) ; trivial. elim Rlt_not_le with (1 := Zx). rewrite Fx. replace (Ztrunc (scaled_mantissa beta fexp x)) with Z0. rewrite F2R_0. apply Rle_refl. unfold scaled_mantissa. rewrite cexp_fexp with (1 := Ex). destruct (mantissa_small_pos beta fexp x ex) ; trivial. rewrite Ztrunc_floor. apply sym_eq. apply Zfloor_imp. split. now apply Rlt_le. exact H2. now apply Rlt_le. now apply Rlt_le. Qed.Lemma generic_format_pred_pos : forall x, F x -> (0 < x)%R -> F (pred_pos x). Proof. intros x Fx Zx. unfold pred_pos; case Req_bool_spec; intros H. now apply generic_format_pred_aux2. now apply generic_format_pred_aux1. Qed.Theorem generic_format_succ : forall x, F x -> F (succ x). Proof. intros x Fx. unfold succ; case Rle_bool_spec; intros Zx. destruct Zx as [Zx|Zx]. now apply generic_format_succ_aux1. rewrite <- Zx, Rplus_0_l. apply generic_format_ulp_0. apply generic_format_opp. apply generic_format_pred_pos. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem generic_format_pred : forall x, F x -> F (pred x). Proof. intros x Fx. unfold pred. apply generic_format_opp. apply generic_format_succ. now apply generic_format_opp. Qed.Lemma pred_pos_lt_id : forall x, (x <> 0)%R -> (pred_pos x < x)%R. Proof. intros x Zx. unfold pred_pos. case Req_bool_spec; intros H.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. rewrite ulp_neq_0; trivial. apply bpow_gt_0. Qed.Theorem succ_gt_id : forall x, (x <> 0)%R -> (x < succ x)%R. Proof. intros x Zx; unfold succ. case Rle_bool_spec; intros Hx. pattern x at 1; rewrite <- (Rplus_0_r x). apply Rplus_lt_compat_l. rewrite ulp_neq_0; trivial. apply bpow_gt_0. pattern x at 1; rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar. apply pred_pos_lt_id. auto with real. Qed. Theorem pred_lt_id : forall x, (x <> 0)%R -> (pred x < x)%R. 
continuous (OrdTetL (ε α)). Proof. intros α Hα. apply ordTetL_limit; auto. Qed. Lemma ε_tower_ran : ∀ α β ⋵ 𝐎𝐍, ε α ^^ᴸ β ⋵ 𝐎𝐍. Proof. auto. Qed. Local Hint Resolve ε_tower_ran : core. Lemma ε_tower_n_ascending : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ε α ^^ᴸ n ∈ ε α ^^ᴸ n⁺. Proof. intros α Hα. apply ordTetL_n_ascending; nauto. Qed. Lemma ε_tower_n_monotone : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ∀m ∈ n, ε α ^^ᴸ m ∈ ε α ^^ᴸ n. Proof. intros α Hα. apply ordTetL_n_monotone; nauto. Qed. Lemma ε_tower_n_has_ω : ∀α ⋵ 𝐎𝐍, ∀n ∈ ω, ω ∈ ε α ^^ᴸ n. Proof with auto. intros α Hα n Hn. ω_induction n. - rewrite ε_tower_0... apply ε_has_ω... - eapply ord_trans. auto. apply IH. apply ε_tower_n_ascending... Qed. Local Hint Resolve ε_tower_n_has_ω : core. Lemma ε_tower_n_has_n : ∀α ⋵ 𝐎𝐍, ∀ m n ∈ ω, m ∈ ε α ^^ᴸ n. Proof. intros α Hα m Hm n Hn. eapply ord_trans; eauto. Qed. Local Hint Resolve ε_tower_n_has_n : core. Lemma ε_tower_n_injective : ∀α ⋵ 𝐎𝐍, ∀ m n ∈ ω, ε α ^^ᴸ m = ε α ^^ᴸ n → m = n. Proof with neauto. intros α Hα n Hn. ω_induction n; intros k Hk H. - ω_destruct k... rewrite ε_tower_0, ε_tower_suc in H... rewrite <- ordExp_1_r in H at 1... apply ordExp_cancel in H... exfalso. apply (ord_irrefl 1)... rewrite H at 2... - ω_destruct k. + rewrite ε_tower_suc, ε_tower_0 in H... rewrite <- ordExp_1_r in H... apply ordExp_cancel in H... exfalso. apply (ord_irrefl 1)... rewrite <- H at 2... + rewrite ε_tower_suc, ε_tower_suc in H... apply ordExp_cancel in H... apply IH in H... subst... Qed. Definition εtω := λ α, sup {ε α ^^ᴸ n | n ∊ ω}. Remark εtω_normal_form : ∀α ⋵ 𝐎𝐍, εtω α = ε α ^^ᴸ ω. Proof. intros α Hα. symmetry. apply ε_tower_limit; nauto. Qed. Lemma εtω_is_limord : εtω :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍ˡⁱᵐ. Proof with auto. intros α Hα. apply union_of_limords_is_limord. intros x Hx. apply ReplAx in Hx as [n [Hn Hx]]. subst. apply ordTetL_is_limord_l... Qed. Local Hint Resolve εtω_is_limord : core. Corollary εtω_ran : εtω :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍. Proof. apply εtω_is_limord. Qed. Local Hint Resolve εtω_ran : core. Lemma εtω_neq_0 : ∀α ⋵ 𝐎𝐍, εtω α  0. Proof. intros α Hα. eapply EmptyNI. exists ω. apply (FUnionI _ _ 0); nauto. Qed. Local Hint Resolve εtω_neq_0 : core. Theorem εtω_is_ε_number : ∀α ⋵ 𝐎𝐍, εtω α ⋵ ε_number. 
H3; auto. + destruct H as [? | ?]. - revert H; revert l; cofix H; intros. destruct l. apply ReleaseLater. * pose proof (H0 0); auto. * apply H. intros. specialize (H0 (S n)); auto. - destruct H as [n H]. revert H; revert l; induction n; intros. * intuition; specialize (H0 0). apply ReleaseHere; auto. * destruct l; simpl in *; intuition. apply ReleaseLater. specialize (H0 0); intuition. apply IHn; intuition. specialize (H0 (S i)); intuition. Qed. End Semantics. Ltac ltl_fsimpl := ltl_simpl; repeat ( try rewrite Always_semantics in *; try rewrite Eventually_semantics in *; try rewrite Until_semantics in *; intros; try match goal with | [ H : exists x, _ |- _ ] => let x := fresh x in destruct H as [x H] end ). Section Absorption. Lemma nth_tail_eq_n : forall (l : Stream A) (n n' : nat), n = n' -> nth_tail n l = nth_tail n' l. Proof. intros; subst; auto. Qed. Theorem Eventually_absorb : forall (P : LTLProp A), Eventually (Always (Eventually P)) ~= Always (Eventually P). Proof. ltl_simpl. + ltl_fsimpl. specialize (H n); simpl in *; ltl_fsimpl. exists (n0 + n1); simpl in *. repeat rewrite nth_tail_assoc in *. erewrite nth_tail_eq_n; try eassumption; omega. + rewrite Eventually_semantics. exists 0; auto. Qed. Theorem Always_absorb : forall (P : LTLProp A), Always (Eventually (Always P)) ~= Eventually (Always P). Proof. ltl_simpl. + rewrite Always_semantics in H; specialize (H 0); auto. + ltl_fsimpl. exists n0; ltl_fsimpl. specialize (H (n1 + n)). repeat rewrite nth_tail_assoc in *. erewrite nth_tail_eq_n; try eassumption; omega. Qed. End Absorption. Section Distributivity. Theorem Next_Or_dist : forall (P Q : LTLProp A), Next (Or P Q) ~= Or (Next P) (Next Q). Proof. ltl_simpl. Qed. Theorem Next_And_dist : forall (P Q : LTLProp A), Next (And P Q) ~= And (Next P) (Next Q). Proof. ltl_simpl. Qed. Lemma tail_eq : forall (l l' : Stream A), l = l' -> tail l = tail l'. Proof. intros; subst; auto. Qed. Theorem Next_Until_dist : forall (P Q : LTLProp A), Next (Until P Q) ~= Until (Next P) (Next Q). Proof. ltl_simpl. + revert a. induction H0; ltl_simpl. + ltl_fsimpl. exists n; intuition; ltl_simpl. - apply tail_eq in H. rewrite <- tail_nth_tail_comm in H; simpl in H; subst; auto. - specialize (H1 i H); ltl_simpl. apply tail_eq in H0. rewrite <- tail_nth_tail_comm in H0; simpl in H0; subst; auto. Qed. Theorem Eventually_Or_dist : forall (P Q : LTLProp A), Eventually (Or P Q) ~= Or (Eventually P) (Eventually Q). 
pred_apply; cancel. pred_apply; unfold smrep. rewrite listpred_remove; eauto using ptsto_conflict. cancel. Qed. Theorem free_ok : forall lxp xp bn ms, {< F Fm Fs m0 sm m freeblocks, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ bn_valid xp bn ]] * [[[ m ::: (Fm * rep xp freeblocks * bn |->?) ]]] * [[ (Fs * bn |->? * smrep freeblocks)%pred sm ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms sm hm' * [[[ m' ::: (Fm * rep xp (bn :: freeblocks)) ]]] * [[ (Fs * smrep (bn :: freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} free lxp xp bn ms. Proof. unfold free, rep, bn_valid. hoare. exists (list2nmem m); pred_apply; cancel. unfold FP in *; eauto. Qed. Hint Extern 1 ({{_}} Bind (init _ _ _) _) => apply init_ok : prog. Hint Extern 1 ({{_}} Bind (init_nofree _ _ _) _) => apply init_nofree_ok : prog. Hint Extern 1 ({{_}} Bind (steal _ _ _ _) _) => apply steal_ok : prog. Hint Extern 1 ({{_}} Bind (alloc _ _ _) _) => apply alloc_ok : prog. Hint Extern 1 ({{_}} Bind (free _ _ _ _) _) => apply free_ok : prog. Hint Extern 0 (okToUnify (rep ?xp _) (rep ?xp _)) => constructor : okToUnify. Hint Extern 0 (okToUnify (smrep ?l) (smrep ?l)) => constructor : okToUnify. Lemma sep_star_reorder_helper : forall a b c d : (@pred _ addr_eq_dec valuset), ((a * b) * (c * d)) =p=> d * (a * b * c). Proof. intros; cancel. Qed. Lemma smrep_cons: forall l a b, smrep l * a |-> b =p=> smrep (a :: l). Proof. unfold smrep. cancel. Qed. Definition freevec lxp xp l ms := let^ (ms) <- ForN i < length l Hashmap hm Ghost [ F Fm Fs crash m0 freeblocks sm ] Loopvar [ ms ] Invariant exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms sm hm * [[[ m' ::: (Fm * rep xp (rev (firstn i l) ++ freeblocks)) * listpred (fun a => a |->?) (skipn i l) ]]] * [[ (Fs * smrep (rev (firstn i l) ++ freeblocks) * listpred (fun a => a |->?) (skipn i l))%pred sm ]] OnCrash crash Begin ms <- free lxp xp (selN l i 0) ms; Ret ^(ms) Rof ^(ms); Ret ms. Theorem freevec_ok : forall lxp xp l ms, {< F Fm Fs m0 sm m freeblocks, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ Forall (bn_valid xp) l ]] * [[[ m ::: (Fm * rep xp freeblocks * listpred (fun a => a |->?) l ) ]]] * [[ (Fs * listpred (fun a => a |->?) l * smrep freeblocks)%pred sm ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms sm hm' * [[[ m' ::: (Fm * rep xp (rev l ++ freeblocks)) ]]] * [[ (Fs * smrep (rev l ++ freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} freevec lxp xp l ms. 
(a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. induction x1; intuition; simpl in *. remember (split x1) as z. destruct z. simpl in *. unfold collidesWith in *. simpl in *. case_eq (eqb b2 b1); intuition. rewrite H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem randomFunc_mem_preserves_coll : forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (randomFunc_mem _ _ RndR c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold randomFunc_mem in *. destruct (arrayLookup _ c0 (a, b0)). repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem F_randomFunc_wf : forall x y z, well_formed_comp (F_randomFunc x y z). 
Hp'n] := CM_facts.inc_value_mod Hp'. apply: (first_step (index_try_spec (CM.state p', (p'j, p'n))) l (§0^(CM.value p' - 1) ++ [§1] ++ §0^(m - (CM.value p' - 1)) ++ [§1] ++ r)); [by lia | by auto with M | by rewrite ?app_norm; do 4 f_equal; lia |]. rewrite ?app_norm. have ->: (1 + (CM.value p' - 1)) = CM.value p' by lia. apply: (first_goto_1 HN (increase_time C N + 2 * goto_time C N + 1)); [ by eauto with M | by lia | by lia | ]. set k := (m - (CM.value p' - 1)). have ?: (k + 1) * (1 + p'n) <= CM.value p'. { suff: (CM.value (CM1.step P p') - CM.value p') * (1 + p'n) = CM.value p' by nia. suff: CM.value (CM1.step P p') = (CM.value p') * (p'n + 2) / (p'n + 1). { move=> ->. by have := divides_frac_diff Hp'n. } rewrite /CM1.step. have {1}->: CM1.value p' = S (CM1.value p' - 1) by lia. move: Hp'iP => /nth_error_Some_In_iP ->. by rewrite Hp'n. } have -> : CM.value p' = (k+1)*(1+p'n)+(CM.value p' - (k+1)*(1+p'n)) by lia. move: (Hp'iP) => /(fail_increase HN r (§0^(CM.value p' - (k + 1) * (1 + p'n)) ++ [§1] ++ l)) => /(_ k). have ? := iP_capped Hp'iP. have ? : 4 <= G by (rewrite /G; lia). have ? : (k + 1) * (2 + p'n) - (G + 1) <= C by lia. move /(_ ltac:(lia)). apply: (reachable_n_trans' (2 * goto_time C N + 1)); first by lia. { rewrite ?app_norm. have ->: ((k + 1) * (1 + p'n) + (CM.value p' - (k + 1) * (1 + p'n))) = CM.value p' by lia. by rewrite Hp'n. } apply: (first_goto_1 HN (goto_time C N + 1)); [ by eauto with M | by lia | by lia |]. apply: (first_step (increase_no_spec (CM.state p', (p'j, p'n))) (§0^(CM.value p' - (k + 1) * (1 + p'n)) ++ [§1] ++ l) (§0^((k + 1) * (1 + p'n) + k) ++ [§1] ++ r)); [by lia | by auto with M | done | ]. apply: (first_goto_1 HN 0); [by eauto with M | by move: ((k + 1) * (1 + p'n)); lia | by lia |]. apply: reachable_n_refl'. rewrite ?app_norm ?nat_norm. do 4 f_equal. by lia. Qed. Section Reflection. Variable NM : nat. Variable NM_spec : SM.bounded M NM. Theorem bounded_M_to_terminating_P : CM.halting P (Nat.iter NM (CM.step P) cm_start). 
Pr[RepeatCore_G c1] - Pr[RepeatCore_G c2] |.End RepeatCore. Section DistMult_impl_RepeatCore. Variable A B : Set. Hypothesis B_EqDec : EqDec B. Variable P : B -> bool. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A1 : Comp (A * A_State). Variable A2 : A_State -> B -> Comp bool. Hypothesis A1_wf : well_formed_comp A1. Hypothesis A2_wf : forall s_A b, well_formed_comp (A2 s_A b). Hypothesis c1_wf : forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c1 a). Hypothesis c1_repeat_wf : forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c1 a))). Hypothesis c2_wf : forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c2 a). Hypothesis c2_repeat_wf : forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c2 a))). Variable n : nat. Definition DM_RC_G1(c : A -> Comp B) := [a, s_A] <-$2 A1; p <-$ Repeat (b <-$ (c a); g <-$ (A2 s_A b); ret (b, g)) (fun p => P (fst p)); ret (snd p). Theorem DM_RC_G1_equiv : forall c x, (forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c a)) -> (forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c a)))) -> evalDist (RepeatCore_G P A1 A2 c) x == evalDist (DM_RC_G1 c) x. intuition. unfold RepeatCore_G, DM_RC_G1. comp_skip. comp_simp. assert (evalDist (b0 <-$ Repeat (c a) P; A2 a0 b0) x == evalDist (p <-$ (b0 <-$ Repeat (c a) P; b <-$ A2 a0 b0; ret (b0, b)); ret (snd p)) x). inline_first. comp_skip. inline_first. rewrite <- evalDist_right_ident. comp_skip. comp_simp. simpl. reflexivity. rewrite H2. comp_skip. eapply repeat_fission; intuition. eauto. eauto. Qed. Definition DM_RC_G2(c : A -> Comp B) := [a, s_A] <-$2 A1; p <-$ Repeat (b <-$ (c a); g <-$ (A2 s_A b); ret (b, g)) (fun p => P (fst p)); ret (Some (snd p)). Theorem DM_RC_G2_equiv : forall c x, evalDist (DM_RC_G1 c) x == evalDist (DM_RC_G2 c) (Some x). intuition. unfold DM_RC_G1, DM_RC_G2. comp_skip. comp_simp. comp_skip. dist_compute. Qed. Definition DM_RC_G3(c : A -> Comp B) := [a, s_A] <-$2 A1; ls <-$ compMap _ (fun _ => b <-$ c a; g <-$ (A2 s_A b); ret (b, g)) (forNats n); ret hd_error (map (fun x => snd x) (filter (fun p => P (fst p)) ls)). Theorem DM_RC_G2_G3_close : forall (c : A -> Comp B) k x, (forall a s_A, In (a, s_A) (getSupport A1) -> well_formed_comp (c a)) -> (forall a s_A, In (a, s_A) (getSupport A1) -> exists b, In b (filter P (getSupport (c a)))) -> (forall a s_A, In (a, s_A) (getSupport A1) -> Pr[b <-$ c a; ret (negb (P b))] <= k) -> | evalDist (DM_RC_G2 c) x - evalDist (DM_RC_G3 c) x | <= expRat k n. 
Require Import Bool. Require Import Word. Require Import BFile Bytes Rec Inode. Require Import String. Require Import Pred. Require Import Arith. Require Import List ListUtils. Require Import FunctionalExtensionality. Require Import AsyncDisk. Require Import SepAuto. Require Import GenSepN. Require Import GenSepAuto. Require Import DirTreePath. Require Import DirTreeDef. Require Import DirTreePred. Require Import DirTreeRep. Require Import DirTreeNames. Require Import DirTreeInodes. Import ListNotations.Set Implicit Arguments. Definition dirtree_safe ilist1 free1 tree1 ilist2 free2 tree2 := BFILE.ilist_safe ilist1 free1 ilist2 free2 /\ forall inum off bn pathname f, find_subtree pathname tree2 = Some (TreeFile inum f) -> BFILE.block_belong_to_file ilist2 bn inum off -> ((BFILE.block_belong_to_file ilist1 bn inum off /\ exists pathname' f', find_subtree pathname' tree1 = Some (TreeFile inum f')) \/ BFILE.block_is_unused free1 bn). Theorem dirtree_safe_refl : forall i f t, dirtree_safe i f t i f t. 
auto. destruct o; auto. destruct m2; auto. destruct (remove i m1); auto. destruct m1; auto. destruct m2; auto. } rewrite REMOVE. destruct i; simpl in H. + destruct (IHm2 i (xI j) H) as (l1 & l2 & EQ & EQ'). exists (xelements m1 (xO j) nil ++ match o with None => nil | Some x => (prev j, x) :: nil end ++ l1); exists l2; split. rewrite xelements_node, EQ, ! app_ass. auto. rewrite xelements_node, EQ', ! app_ass. auto. + destruct (IHm1 i (xO j) H) as (l1 & l2 & EQ & EQ'). exists l1; exists (l2 ++ match o with None => nil | Some x => (prev j, x) :: nil end ++ xelements m2 (xI j) nil); split. rewrite xelements_node, EQ, ! app_ass. auto. rewrite xelements_node, EQ', ! app_ass. auto. + subst o. exists (xelements m1 (xO j) nil); exists (xelements m2 (xI j) nil); split. rewrite xelements_node. rewrite prev_append_prev. auto. rewrite xelements_node; auto. Qed. Theorem elements_remove: forall (A: Type) i v (m: t A), get i m = Some v -> exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2. Proof. intros. exploit xelements_remove. eauto. instantiate (1 := xH). rewrite prev_append_prev. auto. Qed. Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B) (i: positive) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := xfold f (xO i) l v in xfold f (xI i) r v1 | Node l (Some x) r => let v1 := xfold f (xO i) l v in let v2 := f v1 (prev i) x in xfold f (xI i) r v2 end. Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) := xfold f xH m v. Lemma xfold_xelements: forall (A B: Type) (f: B -> positive -> A -> B) m i v l, List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. 
| [ H : exists _, _ |- _ ] => destruct H as [quorum'] end. break_and. assert (NoDup nodes) by eauto using all_fin_NoDup. match goal with | H : NoDup nodes, _ : NoDup ?l1, _ : NoDup ?l2 |- _ => eapply pigeon with (l := nodes) (sub1 := l1) (sub2 := l2) in H end; eauto using all_fin_all, name_eq_dec, div2_correct. match goal with | [ H : exists _, _ |- _ ] => destruct H as [a] end. break_and. find_apply_hyp_hyp. find_apply_hyp_hyp. break_exists. break_and. assert (In e x). { assert (allEntries_votesWithLog net) by eauto using allEntries_votesWithLog_invariant. unfold allEntries_votesWithLog in *. eapply_prop_hyp In In; eauto. break_or_hyp; auto. break_exists. break_and. match goal with | [ H : context [ In _ _ -> _ \/ _ ], H' : In _ _ |- _ ] => eapply H in H' end. repeat (try break_or_hyp; break_and); try omega. congruence. } assert (sorted x) by (eapply votesWithLog_sorted_invariant; eauto). assert (maxTerm x >= eTerm e) by eauto using maxTerm_is_max. assert (maxIndex x >= eIndex e) by eauto using maxIndex_is_max. assert (exists e', In e' l /\ eTerm e' = maxTerm l /\ eIndex e' = maxIndex l). { assert (eTerm e >= 1 /\ eIndex e >= 1) by match goal with | [ H : In _ (votesWithLog _) |- _ ] => solve [eapply terms_and_indices_from_one_invariant in H; eauto] end. destruct l. - simpl in *. unfold moreUpToDate in *. do_bool. repeat (intuition; do_bool); try omega. - simpl in *. eauto. } match goal with | [ H : exists _, _ |- _ ] => destruct H as [e'] end. break_and. find_apply_hyp_hyp. unfold moreUpToDate in *. do_bool; repeat (try break_or_hyp; break_and; do_bool); omega. - match goal with | [ H : context [In], H' : context [In] |- _ ] => apply H in H'; intuition; omega end. Qed. Theorem leader_completeness_committed_invariant : forall net, refined_raft_intermediate_reachable net -> leader_completeness_committed net. Proof using lllmi taifoi vwlsi aevwli llvwli eewci llpi lltsi pwti. unfold leader_completeness_committed, committed. intros. break_exists. break_and. find_copy_apply_lem_hyp leader_completeness_directly_committed_invariant. unfold leader_completeness_directly_committed in *. match goal with | [ H : _, H' : directly_committed _ _ |- _ ] => eapply H in H' end; [ | |eauto]; [| omega]. assert (entries_match (Raft.log (snd (nwState net x))) log) by (eapply leaderLogs_entries_match_invariant; eauto). match goal with | [ H : entries_match _ _ |- _ ] => eapply H end; eauto. Qed. Theorem leader_completeness_invariant : forall net, refined_raft_intermediate_reachable net -> leader_completeness net. 
P p. Proof. intros P peq e. now elim (uip 1 e). Defined.Ltac eqdec_loop t u := (left; reflexivity) || (solve [right; intro He; inversion He]) || (let x := match t with | context C [ _ ?x ] => constr:(x) end in let y := match u with | context C [ _ ?y ] => constr:(y) end in let contrad := let Hn := fresh in intro Hn; right; intro He; apply Hn; inversion He; reflexivity in let good := intros ->; let t' := match t with | context C [ ?x _ ] => constr:(x) end in let u' := match u with | context C [ ?y _ ] => constr:(y) end in try (eqdec_loop t' u') in match goal with | [ H : forall z, sum (Id _ z) _ |- _ ] => case (H y); [good|contrad] | _ => case (eq_dec x y); [good|contrad] end) || idtac.Ltac eqdec_proof := try red; intros; match goal with | |- sum (Id ?x ?y) _ => revert y; induction x; intros until y; depelim y; match goal with |- sum (Id ?x ?y) _ => eqdec_loop x y end end.Section EqdepDec. Universe i. Context {A : Type@{i}} `{EqDec A}. Let comp {x y y':A} (eq1:x = y) (eq2:x = y') : y = y' := Id_rect _ _ (fun a _ => a = y') eq2 _ eq1. Remark trans_sym_eq : forall (x y:A) (u:x = y), comp u u = id_refl y. Proof. intros. case u; compute. apply id_refl. Defined. Variable x : A. Let nu {y:A} (u:x = y) : x = y := match eq_dec x y with | inl eqxy => eqxy | inr neqxy => Empty_rect (fun _ => _) (neqxy u) end. Let nu_constant : forall (y:A) (u v:x = y), nu u = nu v. intros. unfold nu in |- *. case (eq_dec x y); intros. reflexivity. case e; trivial. Defined. Let nu_inv {y:A} (v:x = y) : x = y := comp (nu (id_refl x)) v. Remark nu_left_inv : forall (y:A) (u:x = y), nu_inv (nu u) = u. Proof. intros. case u; unfold nu_inv in |- *. apply trans_sym_eq. Defined. Theorem eq_proofs_unicity : forall (y:A) (p1 p2:x = y), p1 = p2. Proof. intros. elim nu_left_inv with (u := p1). elim nu_left_inv with (u := p2). elim nu_constant with y p1 p2. reflexivity. Defined. Theorem K_dec : forall P:x = x -> Type@{i}, P (id_refl x) -> forall p:x = x, P p. 
(n-length l). Proof. revert l. induction n; intros [|a l] H; auto; try solve [inversion H]. simpl in *. apply IHn. auto with arith. Qed. Hypothesis eq_dec : forall x y : A, {x = y}+{x <> y}. Fixpoint remove (x : A) (l : list A) : list A := match l with | [] => [] | y::tl => if (eq_dec x y) then remove x tl else y::(remove x tl) end. Theorem remove_In : forall (l : list A) (x : A), ~ In x (remove x l). Proof. induction l as [|x l]; auto. intro y; simpl; destruct (eq_dec y x) as [yeqx | yneqx]. apply IHl. unfold not; intro HF; simpl in HF; destruct HF; auto. apply (IHl y); assumption. Qed. Fixpoint last (l:list A) (d:A) : A := match l with | [] => d | [a] => a | a :: l => last l d end. Fixpoint removelast (l:list A) : list A := match l with | [] => [] | [a] => [] | a :: l => a :: removelast l end. Lemma app_removelast_last : forall l d, l <> [] -> l = removelast l ++ [last l d]. Proof. induction l. destruct 1; auto. intros d _. destruct l; auto. pattern (a0::l) at 1; rewrite IHl with d; auto; discriminate. Qed. Lemma exists_last : forall l, l <> [] -> { l' : (list A) & { a : A | l = l' ++ [a]}}. Proof. induction l. destruct 1; auto. intros _. destruct l. exists [], a; auto. destruct IHl as [l' (a',H)]; try discriminate. rewrite H. exists (a::l'), a'; auto. Qed. Lemma removelast_app : forall l l', l' <> [] -> removelast (l++l') = l ++ removelast l'. Proof. induction l. simpl; auto. simpl; intros. assert (l++l' <> []). destruct l. simpl; auto. simpl; discriminate. specialize (IHl l' H). destruct (l++l'); [elim H0; auto|f_equal; auto]. Qed. Fixpoint count_occ (l : list A) (x : A) : nat := match l with | [] => 0 | y :: tl => let n := count_occ tl x in if eq_dec y x then S n else n end. Theorem count_occ_In l x : In x l <-> count_occ l x > 0. Proof. induction l as [|y l]; simpl. - split; [destruct 1 | apply gt_irrefl]. - destruct eq_dec as [->|Hneq]; rewrite IHl; intuition. Qed. Theorem count_occ_not_In l x : ~ In x l <-> count_occ l x = 0. 
_ => No end ); inversion 1. Defined. Inductive sequential: Instruction -> Prop := | sequential_Mov: forall src dest, sequential (InstMov src dest) | sequential_Add: forall val dest, sequential (InstAdd val dest) . Hint Constructors sequential: core. Theorem sequential_always_next instr: sequential instr -> forall (program: list Instruction) cur next, (cur_instr cur program) = Some instr -> Step program cur next -> counter next = S (counter cur). Proof. intros ????? HStep; destruct instr; inversion HStep; auto. Qed. Notation segment_sequential segment := (Forall sequential segment). Notation NextStep program instr cur next := ((cur_instr cur (program%list)) = Some instr -> Step (program%list) cur next) (only parsing). Definition execute_instruction: forall instr (cur: MachineState), ~stopping instr -> {next: MachineState | forall program, NextStep program instr cur next} . refine (fun instr cur => match instr with | InstMov src dest => fun _ => this (machine_state (incr cur) (update cur dest (eval_operand cur src)) ) | InstAdd val dest => fun _ => this (machine_state (incr cur) (update cur dest ((eval_operand cur val) + (get cur dest))) ) | _ => fun _ => impossible end ); destruct instr; try contradiction; auto. Defined. Inductive Steps (program: list Instruction) : list MachineState -> MachineState -> Prop := | Steps_start: forall start, Steps program cur [] | Steps_Step: forall start steps prev cur, Steps program start steps prev -> Step program prev cur -> Steps program start (steps ++ [prev]) cur . Theorem Steps_start_inversion program cur next: Steps program cur [] next -> Step program cur next. Proof. inversion 1; subst; trivial; apply app_eq_nil in H0 as [_ Hfalse]; discriminate Hfalse. Qed. Theorem Steps_connect_tail_last program first steps tail last: Steps program first (steps ++ [tail]) last -> Step program tail last. Proof. inversion 1; subst. - apply app_cons_not_nil in H0; contradiction. - apply app_inj_tail in H0 as []; subst; assumption. Qed. Theorem Steps_connect_first_head program first head steps last: Steps program first ([head] ++ steps) last -> Step program first head. Proof. inversion 1; subst. subst. intros H; induction H. - admit. - assumption. generalize dependent steps. induction steps. - inversion 1. subst. apply app_singleton in H0 as [[]|[]]; subst. + subst_injection H2; inversion H1; subst; auto; apply Steps_start_inversion; assumption. + discriminate H2.- intros. Qed. Theorem list_split_around_meet {T} items: forall n (Hlength: n < length items), exists meet, meet = safe_lookup steps Hlength /\ items = (take n items) ++ [use meet] ++ (drop (S n) items). Theorem Steps_split program first steps last: Steps program first steps last -> forall n (Hlength: n < length steps), exists meet, meet = safe_lookup steps Hlength /\ Steps program first (take n steps) (use meet) /\ Steps program (use meet) (drop (S n) steps) last. 
univ x3 s3}. refine (fun x1 x2 : srt_ecc => match x1, x2 return {x3 : srt_ecc | rules_ecc x1 x2 x3 & forall s1 s2 s3 : srt_ecc, rules_ecc s1 s2 s3 -> univ x1 s1 -> univ x2 s2 -> univ x3 s3} with | Sprop, _ => exist2 _ _ x2 _ _ | Stype n, Sprop => exist2 _ _ Sprop _ _ | Stype n, Stype n' => exist2 _ _ (Stype (max_nat n n')) _ _ end). auto with pts.simple induction 1; intros; auto with arith pts. apply univ_trans with (Stype m); auto with arith pts.auto with pts.intros. apply univ_inv with Sprop s2; intros. auto with arith pts.generalize H. inversion_clear H2; intros. inversion_clear H2; auto with arith pts.unfold max_nat in |- *. elim (le_gt_dec n n'); auto with arith pts.intros. apply univ_inv with (Stype n) s1; intros; auto with arith pts. apply univ_inv with (Stype n') s2; intros; auto with arith pts. generalize H. inversion_clear H2. inversion_clear H3; intros. inversion_clear H3. cut (max_nat n n' <= p); auto with arith pts. apply least_upper_bound_max_nat. apply le_trans with m; auto with arith pts.apply le_trans with m0; auto with arith pts. Qed. End SortsOfECC. Definition term := term srt_ecc. Definition env := env srt_ecc. Definition ecc : CTS_spec srt_ecc := Build_CTS_spec _ axiom_ecc rules_ecc univ_ecc (beta_delta_rule _). Definition ecc_pts : PTS_sub_spec srt_ecc := cts_pts_functor _ ecc. Definition le_type : red_rule srt_ecc := Rule _ (Le_type _ (pts_le_type _ ecc_pts)).Definition typ : env -> term -> term -> Prop := typ _ ecc_pts. Definition typ_ppal : env -> term -> term -> Prop := typ_ppal _ ecc_pts. Definition wft : env -> term -> Prop := wf_type _ ecc_pts. Definition wf : env -> Prop := wf _ ecc_pts. Definition sn := sn srt_ecc (ctxt _ (Rule _ (head_reduct _ ecc))). Definition red := red _ (Rule _ (beta_delta_rule srt_ecc)). Definition conv := conv _ (Rule _ (beta_delta_rule srt_ecc)). Hint Unfold le_type typ wft wf sn: pts. Lemma whnf : forall (e : env) (t : term), sn e t -> {u : term | red _ (beta_delta _) e t u & head_normal _ (beta_delta _) e u}. Proof beta_delta_whnf srt_ecc. Lemma bd_conv_hnf : forall (e : env) (x y : term), sn e x -> sn e y -> decide (conv_hn_inv _ (beta_delta_rule _) e x y). Proof CR_WHNF_convert_hn srt_ecc ecc_sort_dec (beta_delta_rule srt_ecc) (church_rosser_beta_delta srt_ecc) whnf. Theorem ecc_is_subtype_dec : subtype_dec_CTS _ ecc. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). 
Qed.Lemma Z_div_exact_1 : forall a b:Z, b > 0 -> a = b*(a/b) -> a mod b = 0. Proof. intros; apply Z_div_exact_full_1; auto with zarith. Qed.Lemma Z_div_exact_2 : forall a b:Z, b > 0 -> a mod b = 0 -> a = b*(a/b). Proof. intros; apply Z_div_exact_full_2; auto with zarith. Qed.Lemma Z_mod_zero_opp : forall a b:Z, b > 0 -> a mod b = 0 -> (-a) mod b = 0. Proof. intros; apply Z_mod_zero_opp_full; auto with zarith. Qed.Fixpoint Zmod_POS (a : positive) (b : Z) : Z := match a with | xI a' => let r := Zmod_POS a' b in let r' := (2 * r + 1) in if r' <? b then r' else (r' - b) | xO a' => let r := Zmod_POS a' b in let r' := (2 * r) in if r' <? b then r' else (r' - b) | xH => if 2 <=? b then 1 else 0 end.Definition Zmod' a b := match a with | Z0 => 0 | Zpos a' => match b with | Z0 => 0 | Zpos _ => Zmod_POS a' b | Zneg b' => let r := Zmod_POS a' (Zpos b') in match r with Z0 => 0 | _ => b + r end end | Zneg a' => match b with | Z0 => 0 | Zpos _ => let r := Zmod_POS a' b in match r with Z0 => 0 | _ => b - r end | Zneg b' => - (Zmod_POS a' (Zpos b')) end end. Theorem Zmod_POS_correct a b : Zmod_POS a b = snd (Z.pos_div_eucl a b). Proof. induction a as [a IH|a IH| ]; simpl; rewrite ?IH. destruct (Z.pos_div_eucl a b) as (p,q); simpl; case Z.ltb_spec; reflexivity. destruct (Z.pos_div_eucl a b) as (p,q); simpl; case Z.ltb_spec; reflexivity. case Z.leb_spec; trivial. Qed.Theorem Zmod'_correct: forall a b, Zmod' a b = a mod b. Proof. intros a b; unfold Z.modulo; case a; simpl; auto. intros p; case b; simpl; auto. intros p1; refine (Zmod_POS_correct _ _); auto. intros p1; rewrite Zmod_POS_correct; auto. case (Z.pos_div_eucl p (Zpos p1)); simpl; intros z1 z2; case z2; auto. intros p; case b; simpl; auto. intros p1; rewrite Zmod_POS_correct; auto. case (Z.pos_div_eucl p (Zpos p1)); simpl; intros z1 z2; case z2; auto. intros p1; rewrite Zmod_POS_correct; simpl; auto. case (Z.pos_div_eucl p (Zpos p1)); auto. Qed. Theorem Zdiv_eucl_extended : forall b:Z, b <> 0 -> forall a:Z, {qr : Z * Z | let (q, r) := qr in a = b * q + r /\ 0 <= r < Z.abs b}. 
Require Import Bool. Require Import Arith. Require Import Compare_dec. Require Import Peano_dec. Require Import General. Require Import MyList. Require Import MyRelations.Require Export Main. Require Export SortV6.Section CoqV6. Definition trm_v6 := term srt_v6. Definition env_v6 := env srt_v6. Definition v6 : CTS_spec srt_v6 := Build_CTS_spec _ axiom_v6 rules_v6 univ_v6 (beta_delta_rule _). Definition v6_pts : PTS_sub_spec srt_v6 := cts_pts_functor _ v6. Definition le_type : red_rule srt_v6 := Rule _ (Le_type _ (pts_le_type _ v6_pts)). Definition typ_v6 : env_v6 -> trm_v6 -> trm_v6 -> Prop := typ _ v6_pts. Definition wft_v6 : env_v6 -> trm_v6 -> Prop := wf_type _ v6_pts. Definition wf_v6 : env_v6 -> Prop := wf _ v6_pts. Definition v6_sn := sn srt_v6 (ctxt _ (Rule _ (head_reduct _ v6))). Hint Unfold le_type typ_v6 wft_v6 wf_v6 v6_sn: pts. Lemma whnf : forall (e : env_v6) (t : trm_v6), v6_sn e t -> {u : trm_v6 | red _ (beta_delta _) e t u & head_normal _ (beta_delta _) e u}. Proof beta_delta_whnf srt_v6. Lemma bd_conv_hnf : forall (e : env_v6) (x y : trm_v6), v6_sn e x -> v6_sn e y -> decide (conv_hn_inv _ (beta_delta_rule _) e x y). Proof CR_WHNF_convert_hn srt_v6 v6_sort_dec (beta_delta_rule srt_v6) (church_rosser_beta_delta srt_v6) whnf. Theorem v6_is_subtype_dec : subtype_dec_CTS _ v6. apply Build_subtype_dec_CTS. exact (church_rosser_beta_delta srt_v6).exact (bd_hn_sort srt_v6).exact (bd_hn_prod srt_v6).exact whnf.exact bd_conv_hnf.exact univ_v6_dec. Qed. Lemma sound_v6_bd : rule_sound _ v6_pts (beta_delta _). unfold beta_delta in |- *. simpl in |- *. apply union_sound. apply beta_sound; auto with arith pts. simpl in |- *. apply cumul_inv_prod. exact v6_is_subtype_dec.apply delta_sound. Qed. Axiom v6_normalise : forall (e : env_v6) (t T : trm_v6), typ_v6 e t T -> v6_sn e t. Lemma v6_is_norm_sound : norm_sound_CTS _ v6. Proof. refine (Build_norm_sound_CTS srt_v6 v6 sound_v6_bd v6_normalise _ _ _). left. apply v6_inf_axiom.exact v6_inf_rule.intros. elim v6_inf_axiom with s1; intros. split with x. apply (pp_ok p). Qed. Theorem v6_algorithms : PTS_TC _ v6_pts. 
Require Import ZArith. Require Import Omega Ring InitialRing. Require Import Recdef. Require Import Tactics.CpdtTactics.Set Implicit Arguments. Section Matrix2. Variable A : Type. Variable zero one : A. Variable add mul sub : A -> A -> A. Variable opp : A -> A. Variable rt : ring_theory zero one add mul sub opp (@eq A). Add Ring Aring : rt. Notation "0" := (zero). Notation "1" := (one). Notation "x + y" := (add x y). Notation "x - y" := (sub x y). Notation "x * y" := (mul x y). Record Matrix : Type := { c00 : A; c01 : A; c10 : A; c11 : A; }. Definition Matrix2 := Matrix. Definition Unit2 : Matrix2 := {| c00 := 1; c01 := 0; c10 := 0; c11 := 1; |}. Definition Matrix2_mul (m n : Matrix2) : Matrix2 := {| c00 := c00 m * c00 n + c01 m * c10 n; c01 := c00 m * c01 n + c01 m * c11 n; c10 := c10 m * c00 n + c11 m * c10 n; c11 := c10 m * c01 n + c11 m * c11 n; |}. Theorem Matrix2_mul_assoc : forall (m n p : Matrix2), Matrix2_mul m (Matrix2_mul n p) = Matrix2_mul (Matrix2_mul m n) p. Proof. intros; destruct m, n, p. unfold Matrix2_mul; simpl; f_equal; ring. Qed. Theorem Matrix2_left_Unit : forall (m : Matrix2), Matrix2_mul Unit2 m = m. Proof. intros; destruct m. unfold Unit2, Matrix2_mul; simpl; f_equal; ring. Qed. Theorem Matrix2_right_Unit : forall (m : Matrix2), Matrix2_mul m Unit2 = m. Proof. intros; destruct m. unfold Unit2, Matrix2_mul; simpl; f_equal; ring. Qed. End Matrix2. Module ZMatrix2. Definition ZMatrix2 := Matrix2 Z. Definition ZMatrix2_mul := Matrix2_mul Z.add Z.mul. Definition ZUnit2 := Unit2 Z.zero Z.one. Theorem ZMatrix2_mul_assoc : forall (m n p : ZMatrix2), ZMatrix2_mul m (ZMatrix2_mul n p) = ZMatrix2_mul (ZMatrix2_mul m n) p. 
(oddb n = true -> Podd n) -> (oddb n = false -> Peven n) -> combine_odd_even Podd Peven n. Proof. Admitted.Theorem combine_odd_even_elim_odd : forall (Podd Peven : nat -> Prop) (n : nat), combine_odd_even Podd Peven n -> oddb n = true -> Podd n. Proof. Admitted.Theorem combine_odd_even_elim_even : forall (Podd Peven : nat -> Prop) (n : nat), combine_odd_even Podd Peven n -> oddb n = false -> Peven n. Proof. Admitted.Check plus_comm. Lemma plus_comm3 : forall n m p, n + (m + p) = (p + m) + n.Proof. intros n m p. rewrite plus_comm. rewrite plus_comm. Abort.Lemma plus_comm3_take2 : forall n m p, n + (m + p) = (p + m) + n. Proof. intros n m p. rewrite plus_comm. assert (H : m + p = p + m). { rewrite plus_comm. reflexivity. } rewrite H. reflexivity. Qed.Lemma plus_comm3_take3 : forall n m p, n + (m + p) = (p + m) + n. Proof. intros n m p. rewrite plus_comm. rewrite (plus_comm m). reflexivity. Qed.Example lemma_application_ex : forall {n : nat} {ns : list nat}, In n (map (fun m => m * 0) ns) -> n = 0. Proof. intros n ns H. destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H) as [m [Hm _]]. rewrite mult_0_r in Hm. rewrite <- Hm. reflexivity. Qed.Example function_equality_ex1 : plus 3 = plus (pred 4). Proof. reflexivity. Qed.Example function_equality_ex2 : (fun x => plus x 1) = (fun x => plus 1 x). Proof. Abort.Axiom functional_extensionality : forall {X Y: Type} {f g : X -> Y}, (forall (x:X), f x = g x) -> f = g.Example function_equality_ex2 : (fun x => plus x 1) = (fun x => plus 1 x). Proof. apply functional_extensionality. intros x. apply plus_comm. Qed.Print Assumptions function_equality_ex2.Fixpoint rev_append {X} (l1 l2 : list X) : list X := match l1 with | [] => l2 | x :: l1' => rev_append l1' (x :: l2) end.Definition tr_rev {X} (l : list X) : list X := rev_append l [].Lemma tr_rev_correct : forall X, @tr_rev X = @rev X. Admitted.Theorem evenb_double : forall k, evenb (double k) = true. Proof. intros k. induction k as [|k' IHk']. - reflexivity. - simpl. apply IHk'. Qed. Theorem evenb_double_conv : forall n, exists k, n = if evenb n then double k else S (double k). Proof. Admitted. Theorem even_bool_prop : forall n, evenb n = true <-> exists k, n = double k. 
Set Implicit Arguments.Section Streams.Variable A : Type.CoInductive Stream : Type := Cons : A -> Stream -> Stream. Definition hd (x:Stream) := match x with | Cons a _ => a end.Definition tl (x:Stream) := match x with | Cons _ s => s end. Fixpoint Str_nth_tl (n:nat) (s:Stream) : Stream := match n with | O => s | S m => Str_nth_tl m (tl s) end.Definition Str_nth (n:nat) (s:Stream) : A := hd (Str_nth_tl n s).Lemma tl_nth_tl : forall (n:nat) (s:Stream), tl (Str_nth_tl n s) = Str_nth_tl n (tl s). Proof. simple induction n; simpl; auto. Qed. Hint Resolve tl_nth_tl: datatypes.Lemma Str_nth_tl_plus : forall (n m:nat) (s:Stream), Str_nth_tl n (Str_nth_tl m s) = Str_nth_tl (n + m) s. simple induction n; simpl; intros; auto with datatypes. rewrite <- H. rewrite tl_nth_tl; trivial with datatypes. Qed.Lemma Str_nth_plus : forall (n m:nat) (s:Stream), Str_nth n (Str_nth_tl m s) = Str_nth (n + m) s. intros; unfold Str_nth; rewrite Str_nth_tl_plus; trivial with datatypes. Qed.CoInductive EqSt (s1 s2: Stream) : Prop := eqst : hd s1 = hd s2 -> EqSt (tl s1) (tl s2) -> EqSt s1 s2.Ltac coinduction proof := cofix proof; intros; constructor; [ clear proof | try (apply proof; clear proof) ]. Theorem EqSt_reflex : forall s:Stream, EqSt s s. coinduction EqSt_reflex. reflexivity. Qed.Theorem sym_EqSt : forall s1 s2:Stream, EqSt s1 s2 -> EqSt s2 s1. coinduction Eq_sym. case H; intros; symmetry ; assumption. case H; intros; assumption. Qed. Theorem trans_EqSt : forall s1 s2 s3:Stream, EqSt s1 s2 -> EqSt s2 s3 -> EqSt s1 s3. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main. From Categories Require Import Cat.Cat. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso. Local Obligation Tactic := idtac.Section Prod_Functor_NatTrans. Context {C D : Category} {F G : (C --> D)%functor} (N : (F --> G)%nattrans) {C' D' : Category} {F' G' : (C' --> D')%functor} (N' : (F' --> G')%nattrans). Program Definition Prod_Functor_NatTrans : ((Prod_Functor F F') --> (Prod_Functor G G'))%nattrans := {| Trans := fun c => (Trans N (fst c), Trans N' (snd c)) |}. Next Obligation. basic_simpl. do 2 rewrite Trans_com; trivial. Qed. Next Obligation. symmetry. apply Prod_Functor_NatTrans_obligation_1. Qed.End Prod_Functor_NatTrans.Section Prod_Functor_NatTrans_id. Context {C D : Category} (F : (C --> D)%functor) {C' D' : Category} {F' : (C' --> D')%functor}. Theorem Prod_Functor_NatTrans_id : Prod_Functor_NatTrans (NatTrans_id F) (NatTrans_id F') = NatTrans_id (Prod_Functor F F'). 
Require Import Raux Defs Digits.Section Float_prop.Variable beta : radix. Notation bpow e := (bpow beta e).Theorem Rcompare_F2R : forall e m1 m2 : Z, Rcompare (F2R (Float beta m1 e)) (F2R (Float beta m2 e)) = Z.compare m1 m2. Proof. intros e m1 m2. unfold F2R. simpl. rewrite Rcompare_mult_r. apply Rcompare_IZR. apply bpow_gt_0. Qed. Theorem le_F2R : forall e m1 m2 : Z, (F2R (Float beta m1 e) <= F2R (Float beta m2 e))%R -> (m1 <= m2)%Z. 
fexp x). now rewrite <- Fx. Qed. Lemma pred_pos_plus_ulp_aux2 : forall x, (0 < x)%R -> F x -> let e := ln_beta_val beta x (ln_beta beta x) in x = bpow (e - 1) -> (x - bpow (fexp (e-1)) <> 0)%R -> ((x - bpow (fexp (e-1))) + ulp (x - bpow (fexp (e-1))) = x)%R. Proof. intros x Zx Fx e Hxe Zp. replace (ulp (x - bpow (fexp (e - 1)))) with (bpow (fexp (e - 1))). ring. assert (He:(fexp (e-1) <= e-1)%Z). apply generic_format_bpow_inv with beta; trivial. rewrite <- Hxe; assumption. case (Zle_lt_or_eq _ _ He); clear He; intros He.rewrite ulp_neq_0; trivial. apply f_equal. unfold canonic_exp; apply f_equal. apply sym_eq. apply ln_beta_unique. rewrite Rabs_right. split. apply Rplus_le_reg_l with (bpow (fexp (e-1))). ring_simplify. apply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R. apply Rplus_le_compat; apply bpow_le; omega. apply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac]. apply Rle_trans with (bpow 1*bpow (e - 2))%R. apply Rmult_le_compat_r. apply bpow_ge_0. replace 2%R with (Z2R 2) by reflexivity. replace (bpow 1) with (Z2R beta). apply Z2R_le. apply <- Zle_is_le_bool. now destruct beta. simpl. unfold Zpower_pos; simpl. now rewrite Zmult_1_r. rewrite <- bpow_plus. replace (1+(e-2))%Z with (e-1)%Z by ring. now right. rewrite <- Rplus_0_r, Hxe. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0. apply Rle_ge; apply Rle_0_minus. rewrite Hxe. apply bpow_le. omega.contradict Zp. rewrite Hxe, He; ring. Qed.Lemma pred_pos_plus_ulp_aux3 : forall x, (0 < x)%R -> F x -> let e := ln_beta_val beta x (ln_beta beta x) in x = bpow (e - 1) -> (x - bpow (fexp (e-1)) = 0)%R -> (ulp 0 = x)%R. Proof. intros x Hx Fx e H1 H2. assert (H3:(x = bpow (fexp (e - 1)))). now apply Rminus_diag_uniq. assert (H4: (fexp (e-1) = e-1)%Z). apply bpow_inj with beta. now rewrite <- H1. unfold ulp; rewrite Req_bool_true; trivial. case negligible_exp_spec. intros K. specialize (K (e-1)%Z). contradict K; omega. intros n Hn. rewrite H3; apply f_equal. case (Zle_or_lt n (e-1)); intros H6. apply valid_exp; omega. apply sym_eq, valid_exp; omega. Qed. Theorem pred_pos_plus_ulp : forall x, (0 < x)%R -> F x -> (pred_pos x + ulp (pred_pos x) = x)%R. Proof. intros x Zx Fx. unfold pred_pos. case Req_bool_spec; intros H. case (Req_EM_T (x - bpow (fexp (ln_beta_val beta x (ln_beta beta x) -1))) 0); intros H1. rewrite H1, Rplus_0_l. now apply pred_pos_plus_ulp_aux3. now apply pred_pos_plus_ulp_aux2. now apply pred_pos_plus_ulp_aux1. Qed. Theorem ln_beta_plus_eps: forall x, (0 < x)%R -> F x -> forall eps, (0 <= eps < ulp x)%R -> ln_beta beta (x + eps) = ln_beta beta x :> Z. 
?; apply H3, in_app_iff; auto. * apply HB; auto. - intros s G1 G2; apply (H1 _ G1), in_app_iff; auto. - intros; apply H2, in_app_iff; auto. - intros ? ?; apply H3, in_app_iff; auto. + apply fol_quant_sem_ext; intros x. rewrite <- HA with (φ := x·φ); unfold M; simpl; try tauto. * intros s G1 G2; apply (H1 _ G1). simpl; apply in_flat_map. exists (S (σ s)); simpl; auto. * intros [|n] Hn; simpl; auto. apply H2; simpl; apply in_flat_map. exists (S n); simpl; auto. Qed. End completeness.End remove_constants.Section reduction. Variable (Σ : fo_signature) (Σ0 : forall s, ar_syms Σ s = 0) (Σd : discrete (syms Σ)). Section syms_map. Variable A : fol_form Σ. Let ls := fol_syms A. Let K := list_discr_pos_n Σd ls. Let n := projT1 K. Let v : vec _ n := projT1 (projT2 K). Let g : _ -> option (pos n) := proj1_sig (projT2 (projT2 K)). Let HK := proj2_sig (projT2 (projT2 K)). Let H1 x : in_vec x v <-> In x ls. Proof. apply (proj1 HK). Qed. Let H2 x : In x ls <-> g x <> None. Proof. apply (proj1 (proj2 HK)). Qed. Let H3 p : g (vec_pos v p) = Some p. Proof. apply (proj1 (proj2 (proj2 HK))). Qed. Let H4 x p : g x = Some p -> vec_pos v p = x. Proof. apply (proj2 (proj2 (proj2 HK))). Qed. Let σ s := match g s with | Some p => pos2nat p | None => 0 end. Let f x : option (syms Σ) := match le_lt_dec n x with | left _ => None | right H => Some (vec_pos v (nat2pos H)) end. Let Hfσ s : In s ls -> f (σ s) = Some s. Proof. rewrite H2. unfold f, σ. generalize (H4 s). destruct (g s) as [ p | ]. + intros E _. specialize (E _ eq_refl); subst. generalize (pos2nat_prop p). destruct (le_lt_dec n (pos2nat p)) as [ | H ]. * intros; exfalso; lia. * rewrite nat2pos_pos2nat; auto. + intros _ []; auto. Qed. Local Fact syms_map : { σ : syms Σ -> nat & { f : nat -> option (syms Σ) | forall s, In s ls -> f (σ s) = Some s } }. Proof using Σd. exists σ, f; auto. Qed. End syms_map. Hint Resolve incl_refl : core. Theorem Sig_rem_cst_dep_red A : { B | @fo_form_fin_dec_SAT Σ A <-> @fo_form_fin_dec_SAT (Σrem_cst Σ) B }. 
s0))); [ trivial | intros ]. absurd (Posible Sini0 (fun s : Stream S => ~ P s)). assumption. apply posible with (1 := H0). constructor 1; assumption. elim H0; simpl in |- *; intros. apply (u (hd s0)); intros. generalize H0; clear H0; generalize H3; clear H3. rewrite <- H1; case s0; simpl in |- *; intros. apply (notPosible (P:=fun s : Stream S => ~ P s) H H0); assumption. inversion_clear H2; simpl in |- *. unfold isTraceFrom in |- *; split; trivial. Qed. Lemma not_EX : forall (P : Stream S -> Prop) (x : Stream S) (s : S), ~ ExistsS P (s ^ x) -> ~ ExistsS P x. Proof. unfold not in |- *; intros. apply (H (Further s H0)). Qed. Theorem Equiv4 : forall (Sini : S) (P : Stream S -> Prop), SafePath Sini P <-> ~ Inevitable Sini (fun s : Stream S => ~ P s). Proof. unfold iff, Inevitable, not in |- *; intros; split. intro sp; inversion sp; intros. generalize H0; elim (H1 x H); intros. inversion_clear H3 in H2. apply (H2 H4). apply H3; inversion_clear H4; assumption. intro H; elim (not_all_ex_not (Stream S) (fun x : Stream S => isTraceFrom Sini x -> ExistsS (fun s : Stream S => P s -> False) x) H). intros. generalize (not_imply_elim2 (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0). generalize (not_imply_elim (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0); intros. apply safePath with (1 := H1). generalize H1; clear H1; generalize H2; clear H2. generalize x; generalize Sini; cofix u. simple destruct x0; intros; constructor. elim (classic (P (s ^ s0))); [ trivial | intro ]. elim (H2 (Here (P:=fun s : Stream S => ~ P s) H3)). apply u with (Sini := hd s0). generalize H2; clear H2; case s0; unfold not in |- *; intros. apply (not_EX H2 H3). elim H1; intros ig trace; inversion_clear trace. unfold isTraceFrom in |- *; split; trivial. Qed. Theorem Mon_I_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ForAllS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ForAllS Pp x. Proof. cofix u; intro x; case x; intros. case H; constructor. apply (H0 (s1 ^ x0) H1). apply (u x0 Pg Pp H2 H0). Qed. Theorem Conj_S : forall (x : Stream S) (P1 P2 : Stream S -> Prop), ForAllS P1 x -> ForAllS P2 x -> ForAllS (fun s : Stream S => P1 s /\ P2 s) x. 
a b) c) d). apply compatible. apply point_angle.plus_assoc. apply reflexive. apply transitive with (plus (plus a b) (plus c d)). apply symetrique. apply point_angle.plus_assoc. apply transitive with (plus (plus a b) (plus d c)). apply compatible. apply reflexive. apply plus_sym. apply transitive with (plus (plus (plus a b) d) c). apply transitive with (plus (plus a b) (plus d c)). apply reflexive. apply point_angle.plus_assoc. apply compatible. apply symetrique. apply point_angle.plus_assoc. apply reflexive. Qed. Lemma somme_pi : forall u v w : V, R (plus (cons u v) (plus (cons w (opp u)) (cons (opp v) (opp w)))) pi. intros u v w; try assumption. apply transitive with (plus (cons u v) (plus (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) pi)) (cons w (opp u)))). apply compatible. apply reflexive. cut (R (plus (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) pi)) (cons w (opp u))) (plus (cons w (opp u)) (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) pi)))). intros. apply transitive with (plus (cons w (opp u)) (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) pi))). apply compatible. apply reflexive. apply transitive with (plus (cons (opp v) (opp w)) zero). apply symetrique. apply plus_zero. apply compatible. apply reflexive. apply transitive with (plus pi pi). apply symetrique. try exact pi_plus_pi. apply symetrique. apply compatible. apply oppu_u. apply reflexive. apply plus_sym. apply plus_sym. cut (R (plus (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) pi)) (cons w (opp u))) (plus (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) (cons w (opp u)))) pi)). intros. apply transitive with (plus (cons u v) (plus (plus (cons (opp v) (opp w)) (plus (cons (opp w) w) (cons w (opp u)))) pi)). apply compatible. apply reflexive. try exact H. apply transitive with (plus (cons u v) (plus (cons (opp v) (opp u)) pi)). apply compatible. apply reflexive. apply compatible. apply symetrique. apply (Chasles_2 (opp v) (opp w) w (opp u)). apply reflexive. apply transitive with (plus (plus (cons u v) (cons (opp v) (opp u))) pi). apply point_angle.plus_assoc. apply transitive with (plus zero pi). apply compatible. apply transitive with (plus (cons u v) (cons v u)). apply compatible. apply reflexive. apply oppu_oppv. apply transitive with (cons u u). apply Chasles. apply angle_nul. apply reflexive. apply transitive with (plus pi zero). apply plus_sym. apply pi_plus_zero. apply calcul2. Qed. Theorem somme_triangle : forall A B C : PO, R (plus (cons (vec A B) (vec A C)) (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi. 
: forall (P:A -> Type) (y y':P x), sigmaI P x y = sigmaI P x y' -> y = y'. Proof. intros. cut (proj (sigmaI P x y) y = proj (sigmaI P x y') y). unfold proj. simpl in |- *. case (eq_dec_point x). intro e. elim e using K_dec_point; trivial. intros. unfold proj in H1. case n; trivial. case H0. reflexivity. Defined. Lemma inj_right_sigma_refl_point (P : A -> Type) (y : P x) : inj_right_sigma_point (y:=y) (y':=y) eq_refl = eq_refl. Proof. unfold inj_right_sigma_point. intros. unfold eq_rect. unfold proj. rewrite eq_dec_refl_point. unfold K_dec_point. simpl. unfold eq_proofs_unicity_point. subst proj. simpl. unfold nu_inv, comp, nu. simpl. unfold eq_ind, nu_left_inv, trans_sym_eq, eq_rect, nu_constant. rewrite eq_dec_refl_point. reflexivity. Defined.End PointEqdepDec.Section PEqdepDec. Context {A : Type} `{EqDec A}. Let comp (x y y':A) (eq1:x = y) (eq2:x = y') : y = y' := eq_ind _ (fun a => a = y') eq2 _ eq1. Remark ptrans_sym_eq : forall (x y:A) (u:x = y), comp u u = refl_equal. Proof. intros. case u; trivial. Defined. Variable x : A. Let nu (y:A) (u:x = y) : x = y := match eq_dec x y with | left eqxy => eqxy | right neqxy => False_ind _ (neqxy u) end. Let nu_constant : forall (y:A) (u v:x = y), nu u = nu v. intros. unfold nu in |- *. case (eq_dec x y); intros. reflexivity. case n; trivial. Defined. Let nu_inv (y:A) (v:x = y) : x = y := comp (nu refl_equal) v. Remark pnu_left_inv : forall (y:A) (u:x = y), nu_inv (nu u) = u. Proof. intros. case u; unfold nu_inv in |- *. apply ptrans_sym_eq. Defined. Theorem peq_proofs_unicity : forall (y:A) (p1 p2:x = y), p1 = p2. Proof. intros. elim pnu_left_inv with (u := p1). elim pnu_left_inv with (u := p2). elim nu_constant with y p1 p2. reflexivity. Defined. Theorem pK_dec : forall P:x = x -> Prop, P refl_equal -> forall p:x = x, P p. Proof. intros. elim peq_proofs_unicity with x refl_equal p. trivial. Defined. Lemma peq_dec_refl : eq_dec x x = left _ eq_refl. Proof. case eq_dec. intros. f_equal. apply peq_proofs_unicity. intro. congruence. Defined. Let projs (P:A -> Type) (exP:sigma P) (def:P x) : P x := match exP with | sigmaI _ x' prf => match eq_dec x' x with | left eqprf => eq_rect x' P prf x eqprf | _ => def end end. Theorem inj_right_sigma : forall (P:A -> Type) (y y':P x), sigmaI P x y = sigmaI P x y' -> y = y'. 
Require Import Arith. Require Import List. Require Export NatGroundTac. Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m. intros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto. Qed.Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m. intros n m p H; auto with arith. Qed.Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m. intros n m p H H1; red; apply mult_lt_compat_l; auto. Qed.Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p. intros n m p; case p; auto with arith. Qed.Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m. intros n m p H; case (le_or_lt m n); auto with arith; intros H1. absurd (p * n < p * m); auto with arith. apply le_not_lt; apply mult_le_compat_l; auto. Qed. Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0. 
Require Import Coq.Lists.List. Require Import Bedrock.Expr Bedrock.Env. Require Import Bedrock.Word Bedrock.Prover.Set Implicit Arguments. Set Strict Implicit.Local Notation "[ x , .. , y ]" := (cons x .. (cons y nil) ..).Section ReflexivityProver. Context {types : list type}. Variable fs : functions types. Definition reflexivityValid (_ _ : env types) (_ : unit) := True. Definition reflexivitySummarize (_ : list (expr types)) := tt. Definition reflexivityProve (_ : unit) (goal : expr types) := match goal with | Equal _ x y => if expr_seq_dec x y then true else false | _ => false end. Definition reflexivityLearn (sum : unit) (hyps : list (expr types)) := sum. Lemma reflexivitySummarizeCorrect : forall uvars vars hyps, AllProvable fs uvars vars hyps -> reflexivityValid uvars vars (reflexivitySummarize hyps). Proof. unfold reflexivityValid; auto. Qed. Lemma reflexivityLearnCorrect : forall uvars vars sum, reflexivityValid uvars vars sum -> forall hyps, AllProvable fs uvars vars hyps -> reflexivityValid uvars vars (reflexivityLearn sum hyps). Proof. unfold reflexivityValid; auto. Qed. Theorem reflexivityProverCorrect : ProverCorrect fs reflexivityValid reflexivityProve. 
intros. lia. rewrite -> H. reflexivity. * apply Z.mod_pos_bound. lia. Qed. Lemma pad_len_64 : forall (msg : list byte), exists (n : Z), Zlength (pad msg) = 64 * n /\ n >= 0. Proof. intros msg. pose proof pad_len_64_mod msg as pad_len_mod. rewrite -> Zmod_divides in *. 2: lia. destruct pad_len_mod. exists x. split. apply H. specialize (Zlength_nonneg (pad msg)); intros. lia. Qed.Lemma pad_len_64_nat : forall (msg : list byte), exists (n : nat), (length (pad msg))%nat = (64 * n)%nat. Proof. intros msg. pose proof pad_len_64 msg as pad_len_64. rewrite -> Zlength_correct in *. destruct pad_len_64. exists (Z.to_nat x). destruct H. assert (app_each : Z.to_nat (Z.of_nat (length (pad msg))) = Z.to_nat (64 * x)). rewrite -> H. reflexivity. rewrite -> Nat2Z.id in app_each. rewrite -> app_each. rewrite -> Z2Nat.inj_mul. assert (n_64 : Z.to_nat 64 = 64%nat). reflexivity. rewrite -> n_64. reflexivity. * lia. * lia. Qed.Lemma total_pad_len_Zlist : forall (msg : list byte), exists (n : nat), length (msg ++ [Byte.repr 128] ++ repeat Byte.zero (Z.to_nat (- (Zlength msg + 9) mod 64))) = (n * Z.to_nat WORD )%nat. Proof. intros msg. pose proof pad_len_64_nat msg as pad_len_64_nat. unfold pad in *. repeat rewrite -> app_length in *. destruct pad_len_64_nat. assert (sym: (64 * x)%nat = (x * 64)%nat) by lia. rewrite -> sym in *. clear sym. simpl in *. assert (Pos.to_nat 4 = 4%nat) by reflexivity. rewrite -> repeat_length in *. assert (add_both: (length msg + S (Z.to_nat (- (Zlength msg + 9) mod 64) ))%nat = (x * 64 - 8)%nat) by lia. clear H. rewrite -> add_both. assert ((x * 64 - 8)%nat = (4 * (16 * x - 2))%nat) by lia. rewrite -> H. exists (16 * x - 2)%nat. lia. Qed.Lemma pad_inwords : forall (msg : list byte), InWords (msg ++ [Byte.repr 128] ++ repeat Byte.zero (Z.to_nat (- (Zlength msg + 9) mod 64))). Proof. intros msg. apply InWords_len4. pose proof total_pad_len_Zlist. specialize (H msg). unfold Nat.divide. apply H. Qed.Definition fulllen (len : Z) := len + 1%Z + (- (len + 9) mod 64).Lemma app_left : forall (a b c d : list byte), a ++ b ++ c ++ d = (a ++ b ++ c) ++ d.Proof. intros a b c d. assert (b ++ (c ++ d) = (b ++ c) ++ d) as assert1. rewrite -> app_assoc. reflexivity. rewrite -> assert1. rewrite -> app_assoc. reflexivity. Qed. Theorem pad_compose_equal : forall (msg : list byte), generate_and_pad' msg = generate_and_pad msg. 
Require Import TestSuite.admit.Require Import Coq.Sets.Ensembles. Require Import Coq.Strings.String. Global Set Implicit Arguments. Global Set Asymmetric Patterns. Ltac clearbodies := repeat match goal with | [ H := _ |- _ ] => clearbody H end.Inductive Comp : Type -> Type := | Return : forall A, A -> Comp A | Bind : forall A B, Comp A -> (A -> Comp B) -> Comp B. Inductive computes_to : forall A, Comp A -> A -> Prop := | ReturnComputes : forall A v, @computes_to A (Return v) v | BindComputes : forall A B comp_a f comp_a_value comp_b_value, @computes_to A comp_a comp_a_value -> @computes_to B (f comp_a_value) comp_b_value -> @computes_to B (Bind comp_a f) comp_b_value.Inductive is_computational : forall A, Comp A -> Prop := | Return_is_computational : forall A (x : A), is_computational (Return x) | Bind_is_computational : forall A B (cA : Comp A) (f : A -> Comp B), is_computational cA -> (forall a, @computes_to _ cA a -> is_computational (f a)) -> is_computational (Bind cA f). Theorem is_computational_inv A (c : Comp A) : is_computational c -> match c with | Return _ _ => True | Bind _ _ x f => is_computational x /\ forall v, computes_to x v -> is_computational (f v) end. 
case (H l2 l0 l4 a0 b); auto. injection H0; auto. intros (l5, HH1); left; exists l5; apply f_equal2 with (f := cons (A:=A)); auto; injection H0; auto. intros [H1| (H1, H2)]; auto. right; right; split; auto; apply f_equal2 with (f := cons (A:=A)); auto; injection H0; auto. Qed. Theorem same_length_ex : forall (a : A) l1 l2 l3, length (l1 ++ a :: l2) = length l3 -> exists l4 : _, (exists l5 : _, (exists b : B, length l1 = length l4 /\ length l2 = length l5 /\ l3 = l4 ++ b :: l5)). Proof using. intros a l1; elim l1; simpl in |- *; auto. intros l2 l3; case l3; simpl in |- *; try (intros; discriminate). intros b l H; exists (nil (A:=B)); exists l; exists b; repeat (split; auto). intros a0 l H l2 l3; case l3; simpl in |- *; try (intros; discriminate). intros b l0 H0. case (H l2 l0); auto. intros l4 (l5, (b1, (HH1, (HH2, HH3)))). exists (b :: l4); exists l5; exists b1; repeat (simpl in |- *; split; auto). apply f_equal2 with (f := cons (A:=B)); auto. Qed. Theorem in_map_inv : forall (b : B) (l : list A), In b (map f l) -> exists a : A, In a l /\ b = f a. Proof using. intros b l; elim l; simpl in |- *; auto. intros tmp; case tmp. intros a0 l0 H [H1| H1]; auto. exists a0; auto. case (H H1); intros a1 (H2, H3); exists a1; auto. Qed. Theorem in_map_fst_inv : forall a (l : list (B * C)), In a (map (fst (B:=_)) l) -> exists c : _, In (a, c) l. Proof using. intros a l; elim l; simpl in |- *; auto. intros H; case H. intros a0 l0 H [H0| H0]; auto. exists (snd a0); left; rewrite <- H0; case a0; simpl in |- *; auto. case H; auto; intros l1 Hl1; exists l1; auto. Qed. Theorem length_map : forall l, length (map f l) = length l. Proof using. intros l; elim l; simpl in |- *; auto. Qed. Theorem map_app : forall l1 l2, map f (l1 ++ l2) = map f l1 ++ map f l2. Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H l2; apply f_equal2 with (f := cons (A:=B)); auto. Qed. Theorem in_flat_map : forall (l : list B) (f : B -> list C) a b, In a (f b) -> In b l -> In a (flat_map f l). 
{tl:list A | l = x::tl}}+{l = nil}. Proof. induction l as [|a tl]. right; reflexivity. left; exists a; exists tl; reflexivity. Qed. Theorem head_nil : head (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem head_cons : forall (l : list A) (x : A), head (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl in |- *; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl in |- *; auto. Qed. Theorem in_nil : forall a:A, ~ In a nil. Proof. unfold not in |- *; intros a H; inversion_clear H. Qed. Lemma In_split : forall x (l:list A), In x l -> exists l1, exists l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists (@nil A); exists l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1); exists l2; simpl; f_equal; auto. Qed. Theorem in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem In_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl in |- *; auto. destruct IHl; simpl in |- *; auto. right; unfold not in |- *; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), nil <> x ++ a :: y. Proof. unfold not in |- *. destruct x as [| a l]; simpl in |- *; intros. discriminate H. discriminate H. Qed. Theorem app_nil_end : forall l:list A, l = l ++ nil. Proof. induction l; simpl in |- *; auto. rewrite <- IHl; auto. Qed. Theorem app_ass : forall l m n:list A, (l ++ m) ++ n = l ++ m ++ n. Proof. intros. induction l; simpl in |- *; auto. now_show (a :: (l ++ m) ++ n = a :: l ++ m ++ n). rewrite <- IHl; auto. Qed. Hint Resolve app_ass. Theorem ass_app : forall l m n:list A, l ++ m ++ n = (l ++ m) ++ n. Proof. auto using app_ass. Qed. Theorem app_comm_cons : forall (x y:list A) (a:A), a :: (x ++ y) = (a :: x) ++ y. 
m le b y -> Val.divs x y = Some z -> exists v, eval_expr ge sp e m le (divs_base a b) v /\ Val.lessdef z v. Proof. intros. unfold divs_base. exists z; split. EvalOp. auto. Qed.Theorem eval_mods_base: forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val.mods x y = Some z -> exists v, eval_expr ge sp e m le (mods_base a b) v /\ Val.lessdef z v. Proof. intros; unfold mods_base. exploit Val.mods_divs; eauto. intros [v [A B]]. subst. econstructor; split; eauto. apply eval_mod_aux with (semdivop := Val.divs); auto. Qed.Theorem eval_divu_base: forall le a x b y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val.divu x y = Some z -> exists v, eval_expr ge sp e m le (divu_base a b) v /\ Val.lessdef z v. Proof. intros. unfold divu_base. exists z; split. EvalOp. auto. Qed.Theorem eval_modu_base: forall le a x b y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val.modu x y = Some z -> exists v, eval_expr ge sp e m le (modu_base a b) v /\ Val.lessdef z v. Proof. intros; unfold modu_base. exploit Val.modu_divu; eauto. intros [v [A B]]. subst. econstructor; split; eauto. apply eval_mod_aux with (semdivop := Val.divu); auto. Qed.Theorem eval_shrximm: forall le a n x z, eval_expr ge sp e m le a x -> Val.shrx x (Vint n) = Some z -> exists v, eval_expr ge sp e m le (shrximm a n) v /\ Val.lessdef z v. Proof. intros. unfold shrximm. predSpec Int.eq Int.eq_spec n Int.zero. subst n. exists x; split; auto. destruct x; simpl in H0; try discriminate. destruct (Int.ltu Int.zero (Int.repr 31)); inv H0. replace (Int.shrx i Int.zero) with i. auto. unfold Int.shrx, Int.divs. rewrite Int.shl_zero. change (Int.signed Int.one) with 1. rewrite Z.quot_1_r. rewrite Int.repr_signed; auto. econstructor; split. EvalOp. auto. Qed.Theorem eval_shl: binary_constructor_sound shl Val.shl. Proof. red; intros until y; unfold shl; case (shl_match b); intros. InvEval. apply eval_shlimm; auto. TrivialExists. Qed.Theorem eval_shr: binary_constructor_sound shr Val.shr. Proof. red; intros until y; unfold shr; case (shr_match b); intros. InvEval. apply eval_shrimm; auto. TrivialExists. Qed.Theorem eval_shru: binary_constructor_sound shru Val.shru. Proof. red; intros until y; unfold shru; case (shru_match b); intros. InvEval. apply eval_shruimm; auto. TrivialExists. Qed. Theorem eval_negf: unary_constructor_sound negf Val.negf. 
Require Import Psatz. Require Export Reals ZArith. Require Export Zaux.Section Rmissing. Theorem Rle_0_minus : forall x y, (x <= y)%R -> (0 <= y - x)%R. 
1. intros yy; elim (yy true). simple induction x1.apply EQ_tran with A; auto with zfc.intros; cut (EQ (Sing B') Vide). simpl in |- *. simple induction 1. intros yy; elim (yy true). simple induction x1.apply EQ_tran with A; auto with zfc.intros yy. elim (HB true); simpl in |- *. simple induction x0. change (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE. apply IN_Sing_EQ. apply IN_sound_right with (Sing A); auto with zfc. change (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *. intros zz. elimtype F. apply (not_EQ_Sing_Vide A'). apply EQ_tran with B. apply IN_Sing_EQ. apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc. apply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.Qed.Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'. unfold Couple in |- *; simpl in |- *. simple induction 1; intros H1 H2. elim (H1 false). intros bb1; elim bb1. intros HF. change (EQ (Paire Vide (Sing A')) (Sing B)) in HF. cut F. simple induction 1. apply (not_EQ_Vide_Sing A'). apply EQ_tran with B. apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc. apply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc. change (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *. intros HP; cut (EQ (Sing A') (Sing B')). intros; auto with zfc. cut (IN (Sing A') (Paire Vide (Sing B'))). intros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI). intros; cut F. simple induction 1. apply not_EQ_Sing_Vide with A'; assumption. trivial with zfc. apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.Qed.Definition Prod (E E' : Ens) : Ens := match E, E' with | sup A f, sup A' f' => sup _ (fun c : prod_t A A' => match c with | pair_t a a' => Couple (f a) (f' a') end) end. Hint Resolve Paire_sound_left Paire_sound_right: zfc. Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B). unfold Couple in |- *; intros; auto with zfc. Qed.Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B'). unfold Couple in |- *; intros; auto with zfc. Qed. Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2). 
end. Fixpoint rem' {A} (p: positive) (m: tree' A) : tree A := match p, m with | xH, Node001 r => Nodes m | xH, Node010 _ => Empty | xH, Node011 _ r => Nodes (Node001 r) | xH, Node100 l => Nodes m | xH, Node101 l r => Nodes m | xH, Node110 l _ => Nodes (Node100 l) | xH, Node111 l _ r => Nodes (Node101 l r) | xO q, Node001 r => Nodes m | xO q, Node010 y => Nodes m | xO q, Node011 y r => Nodes m | xO q, Node100 l => Node (rem' q l) None Empty | xO q, Node101 l r => Node (rem' q l) None (Nodes r) | xO q, Node110 l y => Node (rem' q l) (Some y) Empty | xO q, Node111 l y r => Node (rem' q l) (Some y) (Nodes r) | xI q, Node001 r => Node Empty None (rem' q r) | xI q, Node010 y => Nodes m | xI q, Node011 y r => Node Empty (Some y) (rem' q r) | xI q, Node100 l => Nodes m | xI q, Node101 l r => Node (Nodes l) None (rem' q r) | xI q, Node110 l y => Nodes m | xI q, Node111 l y r => Node (Nodes l) (Some y) (rem' q r) end. Definition remove' := Eval cbv [rem' Node] in @rem'. Definition remove {A} (p: positive) (m: tree A) : tree A := match m with | Empty => Empty | Nodes m' => remove' p m' end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. reflexivity. Qed. Lemma gEmpty: forall (A: Type) (i: positive), get i (@Empty A) = None. Proof. reflexivity. Qed. Lemma gss0: forall {A} p (x: A), get' p (set0 p x) = Some x. Proof. induction p; simpl; auto. Qed. Lemma gso0: forall {A} p q (x: A), p<>q -> get' p (set0 q x) = None. Proof. induction p; destruct q; simpl; intros; auto; try apply IHp; congruence. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: tree A), get i (set i x m) = Some x. Proof. intros. destruct m as [|m]; simpl. - apply gss0. - revert m; induction i; destruct m; simpl; intros; auto using gss0. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: tree A), i <> j -> get i (set j x m) = get i m. 
LTLProp A), Not (Until P Q) ~= Release (Not P) (Not Q). Proof. split. + revert l; cofix H; intros. destruct l. pose proof (classic (P (Cons a l))) as [? | ?]. - apply ReleaseLater; [ ltl_simpl | apply H; ltl_simpl ]. - apply ReleaseHere; auto. intros Hcontra. ltl_simpl. + apply Not_inverse'. revert l; induction 1. - intros Hcontra. inversion Hcontra; subst; auto. - intros Hcontra. apply IHUntil. inversion Hcontra; subst; congruence. Qed. Theorem Release_Until_dual : forall (P Q : LTLProp A), Not (Release P Q) ~= Until (Not P) (Not Q). Proof. split. + apply Not_inverse. revert l; cofix H; intros. destruct l. pose proof (classic (P (Cons a l))) as [? | ?]. - apply ReleaseHere; auto. apply NNPP. intros Hcontra; ltl_simpl. - apply ReleaseLater. apply NNPP. intros Hcontra; ltl_simpl. apply H. intros Hcontra; apply H0; ltl_simpl. + induction 1. - intros Hcontra; apply H. inversion Hcontra; subst; auto. - intros Hcontra; apply IHUntil. inversion Hcontra; subst; auto; congruence. Qed. End Duality. Section Idempotency. Theorem Always_idempotent : forall (P : LTLProp A), Always (Always P) ~= Always P. Proof. split; revert l; cofix H; intros; destruct l; constructor; ltl_simpl. Qed. Theorem Eventually_idempotent : forall (P : LTLProp A), Eventually (Eventually P) ~= Eventually P. Proof. split; induction 1; ltl_simpl. Qed. Theorem Until_idempotent_left : forall (P Q : LTLProp A), Until P (Until P Q) ~= Until P Q. Proof. split; induction 1; ltl_simpl. Qed. Theorem Until_idempotent_right : forall (P Q : LTLProp A), Until (Until P Q) Q ~= Until P Q. Proof. split; induction 1; ltl_simpl. Qed. End Idempotency. Section Semantics. Theorem Always_semantics : forall (l : Stream A) (P : LTLProp A), Always P l <-> forall (n : nat), P (nth_tail n l). Proof. split. + intros; revert H; revert l. induction n; intros; destruct l; simpl; ltl_simpl. + revert l; cofix H; intros. destruct l; constructor. - pose proof (H0 0); simpl in *; auto. - apply H; intros. pose proof (H0 (S n)); simpl in *; auto. Qed. Theorem Eventually_semantics : forall (l : Stream A) (P : LTLProp A), Eventually P l <-> exists (n : nat), P (nth_tail n l). Proof. split; intros. + induction H. - exists 0; auto. - destruct IHEventually as [n IHEventually]. exists (S n); auto. + destruct H as [n H]. revert H. revert l. induction n; intros; destruct l; simpl in *; ltl_simpl. Qed. Theorem Until_semantics : forall (l : Stream A) (P Q : LTLProp A), Until P Q l <-> exists (n : nat), Q (nth_tail n l) /\ (forall i, i < n -> P (nth_tail i l)). 
From Coq Require Import ZArith Lia Zquot. From Coq Require SpecFloat.Notation cond_Zopp := SpecFloat.cond_Zopp (only parsing). Notation iter_pos := SpecFloat.iter_pos (only parsing).Section Zmissing. Theorem Zopp_le_cancel : forall x y : Z, (-y <= -x)%Z -> Z.le x y. 
_ ] => inverts H | [ H: KIND _ (TVar _) _ |- _ ] => inverts H | [ H: KIND _ (TForall _) _ |- _ ] => inverts H | [ H: KIND _ (TApp _ _) _ |- _ ] => inverts H end). Lemma kind_wfT : forall ke t k , KIND ke t k -> wfT (length ke) t. Proof. intros ke t k HK. gen ke k. induction t; intros; inverts_kind; burn. - eapply WfT_TForall. rrwrite (S (length ke) = length (ke :> KStar)). eauto. Qed. Hint Resolve kind_wfT. Lemma kind_wfT_Forall : forall ks ts , Forall (fun t => KIND ks t KStar) ts -> Forall (wfT (length ks)) ts. Proof. snorm; eauto. Qed. Hint Resolve kind_wfT_Forall. Lemma kind_wfT_Forall2 : forall (ke: kienv) ts ks , Forall2 (KIND ke) ts ks -> Forall (wfT (length ke)) ts. Proof. intros. eapply (Forall2_Forall_left (KIND ke)); snorm; eauto. Qed. Hint Resolve kind_wfT_Forall2.Lemma kind_empty_is_closed : forall t k , KIND nil t k -> closedT t. Proof. intros. unfold closedT. have (@length ki nil = 0). rewrite <- H0. eapply kind_wfT. eauto. Qed. Hint Resolve kind_empty_is_closed. Lemma kind_kienv_insert : forall ke ix t k1 k2 , KIND ke t k1 -> KIND (insert ix k2 ke) (liftTT 1 ix t) k1. Proof. intros. gen ix ke k1. induction t; intros; simpl; inverts_kind; eauto. - Case "TVar". lift_cases; intros; repeat nnat; auto. - Case "TForall". apply KIForall. rewrite insert_rewind. auto. Qed. Lemma kind_kienv_weaken : forall ke t k1 k2 , KIND ke t k1 -> KIND (ke :> k2) (liftTT 1 0 t) k1. Proof. intros. assert (ke :> k2 = insert 0 k2 ke). simpl. destruct ke; auto. rewrite H0. apply kind_kienv_insert. auto. Qed. Theorem subst_type_type_ix : forall ix ke t1 k1 t2 k2 , get ix ke = Some k2 -> KIND ke t1 k1 -> KIND (delete ix ke) t2 k2 -> KIND (delete ix ke) (substTT ix t2 t1) k1. Proof. intros. gen ix ke t2 k1 k2. induction t1; intros; simpl; inverts_kind; eauto. - Case "TVar". fbreak_nat_compare. SCase "n = ix". rewrite H in H4. inverts H4. auto. SCase "n < ix". apply KIVar. rewrite <- H4. apply get_delete_above; auto. SCase "n > ix". apply KIVar. rewrite <- H4. destruct n. burn. simpl. nnat. apply get_delete_below. omega. - Case "TForall". apply KIForall. rewrite delete_rewind. eapply IHt1; eauto. apply kind_kienv_weaken; auto. Qed. Theorem subst_type_type_ix_forall2 : forall ix ke t2 k2 ts ks , get ix ke = Some k2 -> Forall2 (KIND ke) ts ks -> KIND (delete ix ke) t2 k2 -> Forall2 (KIND (delete ix ke)) (map (substTT ix t2) ts) ks. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Nat_Facts Ext_Cons.Prod_Cat.Operations. From Categories Require Import Functor.Main. From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop. From Categories Require Import NatTrans.Main. From Categories Require Import Adjunction.Adjunction Adjunction.Duality. From Categories Require Import Cat.Cat Cat.Exponential Cat.Exponential_Facts. From Categories Require Import Yoneda.Yoneda. From Categories Require Import Functor.Functor_Extender.Local Open Scope functor_scope.Section Hom_Adjunct_left_iso. Context {C D : Category} {F F' : C –≻ D} (N : (F' ≃ F)%natiso) {G : D –≻ C} (adj : F ⊣_hom G) . Definition Hom_Adjunct_left_iso : F' ⊣_hom G := (adj ∘ ((NatTrans_id_Iso (Hom_Func D)) ∘_h (Prod_Functor_NatIso (N^op) (NatTrans_id_Iso (Functor_id D)))) )%isomorphism%natiso.End Hom_Adjunct_left_iso.Section Hom_Adjunct_right_iso. Context {C D : Category} {F : C –≻ D} {G G' : D –≻ C} (N : (G ≃ G')%natiso) (adj : F ⊣_hom G) . Definition Hom_Adjunct_right_iso : F ⊣_hom G' := Hom_Adjunct_Duality (Hom_Adjunct_left_iso ((N^op)⁻¹)%isomorphism%natiso (Hom_Adjunct_Duality adj)).End Hom_Adjunct_right_iso.Section Adjunct_left_iso. Context {C D : Category} (F F' : C –≻ D) (N : (F' ≃ F)%natiso) (G : D –≻ C) (adj : F ⊣ G) . Definition Adjunct_left_iso : F' ⊣ G := Hom_Adj_to_Adj (Hom_Adjunct_left_iso N (Adj_to_Hom_Adj adj)).End Adjunct_left_iso.Section Adjunct_right_iso. Context {C D : Category} (F : C –≻ D) (G G' : D –≻ C) (N : (G ≃ G')%natiso) (adj : F ⊣ G) . Definition Adjunct_right_iso : F ⊣ G' := Hom_Adj_to_Adj (Hom_Adjunct_right_iso N (Adj_to_Hom_Adj adj)).End Adjunct_right_iso.Section Hom_Adjunct_left_unique. Context {C D : Category} {F F' : C –≻ D} {G : D –≻ C} (adj : F ⊣_hom G) (adj' : F' ⊣_hom G) . Definition Hom_Adjunct_left_unique : (F ≃ F')%natiso. Proof. apply (@Opposite_NatIso _ _ (F^op) (F'^op)). eapply (Embedding_mono (Yoneda_Emb (D^op))). eapply Isomorphism_Compose; [eapply Inverse_Isomorphism; apply Exp_Cat_morph_ex_compose_Iso |]. eapply Isomorphism_Compose; [|apply Exp_Cat_morph_ex_compose_Iso]. apply Exp_Cat_morph_ex_Iso. eapply Isomorphism_Compose. apply adj. eapply Inverse_Isomorphism. apply adj'. Defined.End Hom_Adjunct_left_unique. Section Hom_Adjunct_right_unique. Context {C D : Category} {F : C –≻ D} {G G' : D –≻ C} (adj : F ⊣_hom G) (adj' : F ⊣_hom G') . Theorem Hom_Adjunct_right_unique : (G ≃ G')%natiso. Proof. apply Hom_Adjunct_Duality in adj. apply Hom_Adjunct_Duality in adj'. apply (@Opposite_NatIso _ _ (G^op) (G'^op)). apply (Hom_Adjunct_left_unique adj adj'). Defined.End Hom_Adjunct_right_unique.Section Adjunct_left_unique. Context {C D : Category} {F F' : C –≻ D} {G : D –≻ C} (adj : F ⊣ G) (adj' : F' ⊣ G) . Theorem Adjunct_left_unique : (F ≃ F' )%natiso. 
intros (k & P & Q). exists k; auto. Qed. Lemma xelements_keys_norepet: forall (A: Type) (m: t A) (i: positive), list_norepet (xkeys m i). Proof. induction m; intros. - rewrite xkeys_leaf; constructor. - assert (NOTIN1: ~ In (prev i) (xkeys m1 (xO i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (NOTIN2: ~ In (prev i) (xkeys m2 (xI i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (DISJ: forall x, In x (xkeys m1 (xO i)) -> In x (xkeys m2 (xI i)) -> False). { intros. exploit in_xkeys. eexact H. intros (j1 & EQ1). exploit in_xkeys. eexact H0. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H0. destruct H0. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall (A: Type) (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil. Proof. induction m; intros. auto. rewrite xelements_node. rewrite IHm1, IHm2. destruct o; auto. generalize (H xH); simpl; congruence. intros. apply (H (xI i0)). intros. apply (H (xO i0)). Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros until n. unfold elements. generalize 1%positive. revert m n. induction m; intros. - simpl. rewrite xelements_empty. constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. - destruct n as [ | n1 o' n2 ]. + rewrite (xelements_empty (Node m1 o m2)). simpl; constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. + rewrite ! xelements_node. repeat apply list_forall2_app. apply IHm1. intros. apply (H (xO i)). generalize (H xH); simpl; intros OR; inv OR. constructor. constructor. auto. constructor. apply IHm2. intros. apply (H (xI i)). Qed. Theorem elements_canonical_order: forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) -> (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). 
(vNum b)) at 1 in |- *; rewrite (PosNormMin radix) with (precision := precision); auto with zarith. apply Zle_Zmult_comp_l; auto with zarith. replace (- Zsucc (Fnum a))%Z with (Zpred (- Fnum a)). auto with float zarith. unfold pPred in |- *; apply Zle_Zpred. case (Zle_lt_or_eq (nNormMin radix precision) (- Fnum a)); auto. rewrite <- Zabs_eq_opp; auto with float zarith. apply pNormal_absolu_min with (b := b); auto. intros H'4; Contradict H'2; rewrite H'4; ring. apply Zpred_Zopp_Zs; auto. Qed. Theorem FSuccNormNegNormMin : Fsubnormal radix b (FSucc (Float (- nNormMin radix precision) (- dExp b))). unfold FSucc in |- *; simpl in |- *. generalize (Z_eq_bool_correct (- nNormMin radix precision) (pPred (vNum b))); case (Z_eq_bool (- nNormMin radix precision) (pPred (vNum b))); intros H'; auto. absurd (0%nat < pPred (vNum b))%Z; auto. rewrite <- H'; auto with float zarith. replace (Z_of_nat 0) with (- (0))%Z; [ idtac | simpl in |- *; auto ]. apply Zle_not_lt; apply Zle_Zopp; auto with float zarith. apply Zlt_le_weak; auto with float zarith. apply nNormPos; auto with float zarith. unfold pPred in |- *; apply Zlt_succ_pred; simpl in |- *; auto with float zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with float zarith. generalize (Z_eq_bool_correct (- nNormMin radix precision) (- nNormMin radix precision)); case (Z_eq_bool (- nNormMin radix precision) (- nNormMin radix precision)); intros H'0. 2: Contradict H'0; auto. generalize (Z_eq_bool_correct (- dExp b) (- dExp b)); case (Z_eq_bool (- dExp b) (- dExp b)); intros H'1. 2: Contradict H'1; auto. repeat split; simpl in |- *; auto with zarith. apply Zle_lt_trans with (m := nNormMin radix precision); auto with float zarith. rewrite <- Zopp_Zpred_Zs; rewrite Zabs_Zopp; rewrite Zabs_eq; auto with float zarith. apply Zle_Zpred; simpl in |- *; auto with float zarith. apply nNormPos; auto with float zarith. rewrite Zabs_Zmult; rewrite (Zabs_eq radix); auto with zarith. rewrite (PosNormMin radix) with (precision := precision); auto with zarith. apply Zmult_gt_0_lt_compat_l; auto with float zarith. rewrite <- Zopp_Zpred_Zs; rewrite Zabs_Zopp. rewrite Zabs_eq; auto with zarith. apply Zle_Zpred; simpl in |- *; auto with float zarith. apply nNormPos; auto with float zarith. Qed. Theorem FSuccNegCanonic : forall a : float, (a <= 0)%R -> Fcanonic radix b a -> Fcanonic radix b (FSucc a). intros a H' H'0; case H'0; intros H'1. case (floatDec a (Float (- nNormMin radix precision) (- dExp b))); intros H'2. rewrite H'2; right; apply FSuccNormNegNormMin; auto. left; apply FSuccNormNegNotNormMin; auto. apply FSuccSubnormal; auto. Qed. Theorem FSuccCanonic : forall a : float, Fcanonic radix b a -> Fcanonic radix b (FSucc a). 
=> [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Theorem strings_fwd : forall n p, strings n p ===> Ex len, p =*> len * strings' n p len. destruct n; sepLemma. Qed. Theorem strings_bwd : forall n p, Ex len, p =*> len * strings' n p len ===> strings n p. destruct n; sepLemma. Qed. Theorem strings'_fwd_zero : forall n p (len : W), len = 0 -> strings' n p len ===> Emp. destruct n; sepLemma. Qed. Theorem strings'_fwd_nonzero : forall n p (len : W), len <> 0 -> strings' n p len ===> Ex n', [| n = S n' |] * [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len'). destruct n; sepLemma. Qed. Definition keyValues := starB (fun p => Ex q, Ex len, q =*> len * (q ^+ $4) =?>8 wordToNat len * [| p = q ^+ $4 ^+ len |] * Ex len', p =*> len' * (p ^+ $4) =?>8 wordToNat len'). Theorem keyValues_empty_bwd : Emp ===> keyValues empty. apply starB_empty_bwd. Qed. Theorem keyValues_add_bwd : forall b p, keyValues b * (Ex q, Ex len, q =*> len * (q ^+ $4) =?>8 wordToNat len * [| p = q ^+ $4 ^+ len |] * Ex len', p =*> len' * (p ^+ $4) =?>8 wordToNat len') ===> keyValues (b %+ p). apply starB_add_bwd. Qed. Definition keyValues_pick (_ : W) := keyValues. Ltac keyValues := eauto; simpl; match goal with | [ |- context[starB ?P ?B] ] => change (starB P B) with (keyValues B) end; sepLemma. Theorem keyValues_pick_fwd : forall p b, p %in b -> keyValues_pick p b ===> keyValues (b %- p) * (Ex q, Ex len, q =*> len * (q ^+ $4) =?>8 wordToNat len * [| p = q ^+ $4 ^+ len |] * Ex len', p =*> len' * (p ^+ $4) =?>8 wordToNat len'). intros; eapply Himp_trans; [ apply starB_del_fwd | ]; keyValues. Qed. Theorem keyValues_pick_bwd : forall p b, p %in b -> keyValues (b %- p) * (Ex q, Ex len, q =*> len * (q ^+ $4) =?>8 wordToNat len * [| p = q ^+ $4 ^+ len |] * Ex len', p =*> len' * (p ^+ $4) =?>8 wordToNat len') ===> keyValues_pick p b. 
:= [ ("a", "x") ; ("b", "y") ] ; outs := [ ("c", "z") ] |}. Eval compute in interp [mod_nand_ex] nand_context [("x", false) ; ("y", true) ]. Theorem mod_nand_theorem (a b : bool) : interp [mod_nand_ex] nand_context [("x", a) ; ("y", b) ] = Some [("z", nandb a b) ; ("x", a) ; ("y", b) ] . auto. Qed. Definition module_seq := list (string * circuit). Definition mod_interp := list (string * bool) -> option (list (string * bool)). End circ3.Module circ4. Record func_call := { name : string; args : list string; }. Record func_def := { params : list string; body : list (list string * func_call); return_vars : list string; }. Definition func_def_seq := list (string * func_def). End circ4. Module flipflop.Definition State s a := s -> a * s.Definition flip_flop (x : bool) : State bool bool := fun _ => (x, x).Definition pure {s a : Type} (x : a) : State s a := fun s => (x, s).Definition fmap {s a b : Type} (f : a -> b) (x : State s a) : State s b := fun s => let (y, s2) := x s in (f y, s2).Definition clock : State bool bool := fun s => ( s, negb s). inputs : list string: outputs : list string; : Module mod_val } Definition step ( state : ) (inputs ) : outputs * state Definition step_rel in out := step in = out.Inductive step : state -> state -> Prop := *) End flipflop. Fixpoint interp_bexp c inputs := match c with | Wire s => lookup s inputs | Nand c1 c2 => bind (interp_bexp c1 inputs) (fun b1 => bind (interp_bexp c2 inputs) ( fun b2 => Some (nandb b1 b2))) end. Fixpoint interp c inputs := match c with | Let s b c => bind (interp_bexp b inputs) (fun b => interp c ( (s, b ) :: inputs)) | Output s b c => bind (interp_bexp b inputs) (fun b => bind (interp c inputs) (fun res => Some ((s, b) :: res) )) | Done => Some [] end. Definition neg (x : bexpr) : bexpr := Nand x x. Definition negc (s : string) : circuit := Output "a" (Wire s) Done. Definition negc2 : circuit := let a := Wire "a" in Output "b" (Nand a a) Done. Theorem neggo (a : bool) : interp negc2 [("a", a)] = Some [("b" , negb a)]. 
Set Implicit Arguments.Require Import FCF.FCF.Definition D := evalDist. Definition dist_iso := evalDist_iso.Ltac r_ident_r := symmetry; rewrite <- evalDist_right_ident; symmetry.Ltac xorTac_once := match goal with | [|- context[?x xor (?x xor ?x0)] ]=> rewrite <- BVxor_assoc; rewrite BVxor_same_id; rewrite BVxor_id_l | [|- context[(?x xor ?x0) xor ?x] ]=> rewrite <- BVxor_comm end.Ltac xorTac := repeat xorTac_once; simpl; try reflexivity; try eapply in_getAllBvectors. Section OTP. Variable c : nat. Definition OTP (x : Bvector c) : Comp (Bvector c) := p <-$ {0, 1}^c; ret (BVxor c p x). Theorem OTP_eq_Rnd: forall (x y : Bvector c), D (OTP x) y == D ({0, 1}^c) y. intuition. unfold OTP. r_ident_r. eapply (dist_iso (BVxor c x) (BVxor c x)); intuition; xorTac. Qed.End OTP. *) Section OTP. Variable T : Set. Hypothesis T_EqDec : EqDec T. Variable RndT : Comp T. Variable T_op : T -> T -> T. Hypothesis op_assoc : forall x y z, T_op (T_op x y) z = T_op x (T_op y z). Variable T_inverse : T -> T. Variable T_ident : T. Hypothesis inverse_l_ident : forall x, T_op (T_inverse x) x = T_ident. Hypothesis inverse_r_ident : forall x, T_op x (T_inverse x) = T_ident. Hypothesis ident_l : forall x, T_op T_ident x = x. Hypothesis ident_r : forall x, T_op x T_ident = x. Hypothesis RndT_uniform : forall x y, comp_spec (fun a b => a = x <-> b = y) RndT RndT. Theorem all_in_support : forall y, In y (getSupport RndT) -> forall x, In x (getSupport RndT). intuition. eapply getSupport_In_evalDist. intuition. eapply getSupport_In_evalDist. eapply H. rewrite <- H0. eapply comp_spec_impl_eq. trivial. Qed. Theorem OTP_inf_th_sec_l : forall (x : T), comp_spec eq RndT (r <-$ RndT; ret (T_op x r)). 
apply Zle_Zopp; auto with arith zarith. rewrite <- H. apply FnormalizeCorrect. Qed. Theorem FcanonicLtPos : forall p q : float, Fcanonic p -> Fcanonic q -> (0 <= p)%R -> (p < q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z. intros p q H' H'0 H'1 H'2; case H'; case H'0. intros H'3 H'4; apply FnormalLtPos; auto. intros H'3 H'4; absurd (p < q)%R; auto. apply Rlt_asym. apply FsubnormalnormalLtPos; auto. apply Rle_trans with (r2 := FtoRradix p); auto with real. intros H'3 H'4; case (Z_eq_dec (Fexp q) (- dExp b)); intros H'5. right; split. rewrite H'5; case H'4; intros H1 H2; case H2; auto. apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with zarith. rewrite H'5; case H'4; intros H1 H2; case H2; auto. left. replace (Fexp p) with (- dExp b)%Z; [ idtac | apply sym_equal; auto with float ]. case (Zle_lt_or_eq (- dExp b) (Fexp q)); auto with float zarith. intros H'3 H'4; right; split. apply trans_equal with (- dExp b)%Z; auto with float. apply sym_equal; auto with float. apply FsubnormalLt; auto. Qed. Theorem FcanonicLePos : forall p q : float, Fcanonic p -> Fcanonic q -> (0 <= p)%R -> (p <= q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p <= Fnum q)%Z. intros p q H' H'0 H'1 H'2. case H'2; intros H'3. case FcanonicLtPos with (p := p) (q := q); auto with zarith arith. rewrite FcanonicUnique with (p := p) (q := q); auto with zarith arith. Qed. Theorem Fcanonic_Rle_Zle : forall x y : float, Fcanonic x -> Fcanonic y -> (Rabs x <= Rabs y)%R -> (Fexp x <= Fexp y)%Z. intros x y H H0 H1. cut (forall z : float, Fexp z = Fexp (Fabs z) :>Z); [ intros E | intros; unfold Fabs in |- *; simpl in |- *; auto with zarith ]. rewrite (E x); rewrite (E y). cut (Fcanonic (Fabs x)); [ intros D | apply FcanonicFabs; auto ]. cut (Fcanonic (Fabs y)); [ intros G | apply FcanonicFabs; auto ]. case H1; intros Z2. case (FcanonicLtPos (Fabs x) (Fabs y)); auto with zarith. rewrite (Fabs_correct radix); auto with real zarith. repeat rewrite (Fabs_correct radix); auto with real zarith. rewrite (FcanonicUnique (Fabs x) (Fabs y)); auto with float zarith. repeat rewrite (Fabs_correct radix); auto with real zarith. Qed. Theorem FcanonicLtNeg : forall p q : float, Fcanonic p -> Fcanonic q -> (q <= 0)%R -> (p < q)%R -> (Fexp q < Fexp p)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z. 
end (eq_trans (eq_trans (UIP (eq_refl) (eq_refl)) z) (eq_sym (UIP (eq_refl) (eq_refl))))). destruct z. destruct (UIP _ _). reflexivity. Defined.Theorem UIP_shift : forall U, UIP_refl_ U -> forall x:U, UIP_refl_ (x = x). Proof. exact (fun U UIP_refl x => @UIP_shift_on U x (UIP_refl x)). Defined. Lemma uip_refl_refl {A} {E : UIP A} (x : A) : uip (x:=x) eq_refl eq_refl = eq_refl. Proof. assert (Us:=UIP_shift). specialize (Us A). compute in Us. apply Us. intros. apply uip. Defined.Theorem UIP_K {A} {U : UIP A} (x : A) : forall P : x = x -> Type, P eq_refl -> forall p : x = x, P p. Proof. intros P peq e. now elim (uip refl_equal e). Defined.Section EqdepDec. Context {A : Type} `{EqDec A}. Let comp (x y y':A) (eq1:x = y) (eq2:x = y') : y = y' := eq_ind _ (fun a => a = y') eq2 _ eq1. Remark trans_sym_eq : forall (x y:A) (u:x = y), comp u u = refl_equal. Proof. intros. case u; trivial. Defined. Variable x : A. Let nu (y:A) (u:x = y) : x = y := match eq_dec x y with | left eqxy => eqxy | right neqxy => False_ind _ (neqxy u) end. Let nu_constant : forall (y:A) (u v:x = y), nu u = nu v. intros. unfold nu in |- *. case (eq_dec x y); intros. reflexivity. case n; trivial. Defined. Let nu_inv (y:A) (v:x = y) : x = y := comp (nu refl_equal) v. Remark nu_left_inv : forall (y:A) (u:x = y), nu_inv (nu u) = u. Proof. intros. case u; unfold nu_inv in |- *. apply trans_sym_eq. Defined. Theorem eq_proofs_unicity : forall (y:A) (p1 p2:x = y), p1 = p2. Proof. intros. elim nu_left_inv with (u := p1). elim nu_left_inv with (u := p2). elim nu_constant with y p1 p2. reflexivity. Defined. Theorem K_dec : forall P:x = x -> Type, P refl_equal -> forall p:x = x, P p. Proof. intros. elim eq_proofs_unicity with x refl_equal p. trivial. Defined. Lemma eq_dec_refl : eq_dec x x = left _ eq_refl. Proof. case eq_dec. intros. f_equal. apply eq_proofs_unicity. intro. congruence. Defined. Let proj (P:A -> Type) (exP:sigT P) (def:P x) : P x := match exP with | existT _ x' prf => match eq_dec x' x with | left eqprf => eq_rect x' P prf x eqprf | _ => def end end. Theorem inj_right_pair : forall (P:A -> Type) (y y':P x), existT P x y = existT P x y' -> y = y'. 
?B => remember A as C1; remember B as C2 end. assert (cnt1: OrdinalPool.containsThread C1 0). { clear - HeqC1. unfold OrdinalPool.containsThread. subst C1; auto. } assert (cnt2: OrdinalPool.containsThread C2 0). { clear - HeqC2. unfold OrdinalPool.containsThread. subst C2; auto. } replace (Krun c) with (OrdinalPool.getThreadC cnt2) by (subst C2; simpl; auto). replace (Krun thread_target) with (OrdinalPool.getThreadC cnt1) by (subst C1; simpl; auto). clear - EQ. subst C1; auto. f_equal. eapply Axioms.proof_irr. *) + eapply SAFE. - intros. eapply Clight_initial_safe; auto. - clear H. split; eauto; econstructor; repeat split; try reflexivity; eauto. - rewrite program_proof; apply CPROOF_initial_mem. Qed. Notation sc_execution := (@Executions.fine_execution _ BareDilMem BareMachine.resources BareMachine.BareMachineSig). Theorem CSL2FineBareAsm_safety: forall U, exists (init_mem_target init_mem_target':Memory.mem) init_thread_target, let init_tp_target := threadPool.ThreadPool.mkPool (Sem:=SemTarget) (resources:=BareMachine.resources) (Krun init_thread_target) tt in permissionless_init_machine Asm_program _ init_mem_target init_tp_target init_mem_target' Main_ptr nil /\ (forall n, HybridMachineSig.HybridMachineSig.HybridFineMachine.fsafe (dilMem:= BareDilMem) (ThreadPool:=threadPool.OrdinalPool.OrdinalThreadPool (resources:=BareMachine.resources) (Sem:=SemTarget)) (machineSig:= BareMachine.BareMachineSig) init_tp_target (@HybridMachineSig.diluteMem BareDilMem init_mem_target') U n) /\ (forall final_state final_mem tr, sc_execution (U, [::], init_tp_target) (@HybridMachineSig.diluteMem BareDilMem init_mem_target') ([::], tr, final_state) final_mem -> SpinLocks.spinlock_synchronized tr). Proof. intros U. destruct (CSL2CoarseAsm_safety U) as (init_mem_target & init_mem_target' & init_thread_target & INIT & Hsafe). simpl in INIT. unfold HybridMachineSig.init_machine'' in INIT. destruct INIT as [Hinit_mem Hinit]. simpl in Hinit. unfold HybridMachine.DryHybridMachine.init_mach in Hinit. destruct Hinit as [c [Hinit Heq]]. exists init_mem_target, init_mem_target', init_thread_target. assert (init_thread_target = c). { inversion Heq. assert (0 < 1)%nat by auto. eapply Extensionality.EqdepTh.inj_pair2 in H0. apply equal_f in H0. inversion H0; subst. reflexivity. simpl. econstructor; now eauto. } subst. split. - simpl. unfold HybridMachineSig.init_machine''. split; auto. simpl. unfold BareMachine.init_mach. exists c. simpl. split; auto. - intros. destruct (init_mem_wd Hinit_mem ) as [Hvalid_mem Hvalid_ge]. pose (fineConc_safe.FineConcInitial.Build_FineInit Hvalid_mem Hvalid_ge). eapply @X86Safe.x86SC_safe with (Main_ptr := Main_ptr) (FI := f); eauto. intro; apply Classical_Prop.classic. intros. pose proof (CSL2CoarseAsm_safety sched) as (init_mem_target2 & init_mem_target2' & init_thread_target2 & INIT2 & Hsafe2). simpl in INIT2. unfold HybridMachineSig.init_machine'' in INIT2. destruct INIT2 as [Hinit_mem2 Hinit2]. rewrite Hinit_mem2 in Hinit_mem. inversion Hinit_mem; subst. simpl in Hinit2. unfold HybridMachine.DryHybridMachine.init_mach in Hinit2. destruct Hinit2 as [c2 [Hinit2 Heq2]]. destruct (Asm.semantics_determinate Asm_program). simpl in sd_initial_determ. simpl in Hinit, Hinit2. destruct Hinit as [Hinit ?], Hinit2 as [Hinit2 ?]; subst. specialize (sd_initial_determ _ _ _ _ _ Hinit Hinit2); subst. now eauto. Qed. End MainTheorem. Arguments permissionless_init_machine _ _ _ _ _ _ _: clear implicits. Section CleanMainTheorem. Import CC_correct. Import Integers.Ptrofs Values Ctypes. Import MemoryWD machine_semantics. Import HybridMachineSig.HybridMachineSig.HybridFineMachine. Import ThreadPool BareMachine CoreInjections HybridMachineSig. Import main_definitions. Import Args. Theorem main_safety_clean: CSL_correct C_program -> CompCert_compiler C_program = Some Asm_program -> forall (src_m:Memory.mem) (src_cpm:state), CSL_init_setup C_program src_m src_cpm -> entry_point (globalenv C_program) src_m src_cpm (main_ptr C_program) nil -> forall (limited_builtins:Asm_core.safe_genv x86_context.X86Context.the_ge), asm_prog_well_formed Asm_program limited_builtins -> forall U, exists tgt_m0 tgt_m tgt_cpm, permissionless_init_machine Asm_program limited_builtins tgt_m0 tgt_cpm tgt_m (main_ptr C_program) nil /\ spinlock_safe U tgt_cpm tgt_m. 
bool) m. Let w := 0##0##vec_map stack_enc v. Let w_prop : bsm_state_enc v w. Proof. red; unfold w, tmp1, tmp2; repeat split; rew vec. intros p; unfold reg; simpl. rewrite vec_pos_map; trivial. Qed. Let Q_spec1 : (iP,cP) /BSM/ (iP,v) ↓ -> exists w', Q /MM/ (1,w) ~~> (code_end Q, w') /\ w'#>tmp1 = 0 /\ w'#>tmp2 = 0. Proof. intros ((i1,v1) & H1). destruct HQ1 with (1 := conj w_prop H1) as (w' & H2 & H3). rewrite <- (proj2 (proj2 Hlnk) i1), <- (proj1 (proj2 Hlnk)). * exists w'; split; auto; red in H2; tauto. * apply H1. Qed. Let Q_spec2 : Q /MM/ (1,w) ↓ -> (iP,cP) /BSM/ (iP,v) ↓. Proof. intros ((j,w2) & H1). rewrite <- (proj1 (proj2 Hlnk)) in H1. destruct HQ2 with (1 := conj w_prop H1) as (i2 & v2 & H2 & H3 & _). exists (i2,v2); auto. Qed. Definition bsm_mm_sim := snd Q. Theorem bsm_mm_sim_spec : (iP,cP) /BSM/ (iP,v) ↓ <-> (1,bsm_mm_sim) /MM/ (1,w) ↓. Proof. rewrite <- (proj1 Hlnk) at 1. rewrite <- surjective_pairing. split; auto. intros H. destruct (Q_spec1 H) as (w' & H1 & _). exists (code_end Q, w'); auto. Qed. Let iE := code_end Q. Let cN := mm_nullify tmp1 iE (map (fun p => pos_nxt (pos_nxt p)) (pos_list m)). Let cE := cN ++ DEC tmp1 0 :: nil. Let E_spec w' : w'#>tmp1 = 0 -> w'#>tmp2 = 0 -> (iE,cE) /MM/ (iE,w') -+> (0,vec_zero). Proof. intros H1 H2. unfold cE. apply sss_compute_progress_trans with (length cN+iE,vec_zero). + apply subcode_sss_compute with (P := (iE,cN)); auto. apply mm_nullify_compute; auto. * intros p Hp. apply in_map_iff in Hp. destruct Hp as (x & H3 & H4); subst; discriminate. * intros p Hp. apply in_map_iff in Hp. destruct Hp as (x & H3 & H4); subst; apply vec_zero_spec. * intros p Hp. unfold n, tmp1, tmp2 in *; simpl in p. pos_inv p; auto. pos_inv p; auto. destruct Hp; apply in_map_iff; exists p; split; auto. apply pos_list_prop. + apply subcode_sss_progress with (P := (length cN+iE,DEC tmp1 0::nil)); auto. mm sss DEC 0 with tmp1 0. apply subcode_refl. mm sss stop. Qed. Definition bsm_mm := snd Q ++ cE. Let cQ_sim : Q <sc (1,bsm_mm). Proof. unfold bsm_mm; destruct Q as (iQ,cQ); simpl in Hlnk. simpl snd; rewrite (proj1 Hlnk); auto. Qed. Let cE_sim : (iE,cE) <sc (1,bsm_mm). Proof. unfold iE, bsm_mm; subcode_tac; solve list eq. rewrite (proj1 Hlnk); auto. Qed. Theorem bsm_mm_spec : (iP,cP) /BSM/ (iP,v) ↓ <-> (1,bsm_mm) /MM/ (1,w) ~~> (0,vec_zero). 
B → infinite A ∨ infinite B ↔ infinite (A × B). Proof. intros. unfold infinite. rewrite <- cprd_finite_iff; tauto. Qed. Lemma finite_arrow_l : ∀ A B, 2 ≤ |B| → finite (A ⟶ B) → finite A. Proof with nauto. intros * H2 Hfin. rewrite (card_of_nat 2), cardLe_iff, two in H2... assert (H02: 0 ∈ 2%zfc1) by apply PairI1. assert (H12: 1 ∈ 2%zfc1) by (rewrite one; apply PairI2). destruct H2 as [f [Hif [Hdf Hrf]]]. assert (Hif' := Hif). destruct Hif' as [Hff _]. apply (dominated_by_finite_is_finite _ (A ⟶ B))... set (λ a, Func A B (λ x, match (ixm (x = a)) with | inl _ => f[0] | inr _ => f[1] end)) as G. set (Func A (A ⟶ B) (λ a, G a)) as g. assert (HG: ∀a ∈ A, G a: A ⇒ B). { intros a Ha. apply meta_function. intros x Hx. destruct (ixm (x = a)); apply Hrf; eapply ranI; apply func_correct; auto; rewrite Hdf... } exists g. apply meta_injection. - intros a Ha. apply SepI. + apply PowerAx. intros p Hp. apply SepE1 in Hp... + apply HG... - intros x1 H1 x2 H2 Heq. assert ((G x1)[x1] = (G x2)[x1]) by congruence. unfold G in H. do 2 (rewrite meta_func_ap in H; [|apply HG|])... destruct (ixm (x1 = x1)); destruct (ixm (x1 = x2))... + exfalso. apply injectiveE in H; auto; rewrite Hdf... + exfalso... Qed. Lemma finite_arrow_r : ∀ A B, ⦿ A → finite (A ⟶ B) → finite B. Proof with auto. intros * [a Ha] Hfin. apply (dominated_by_finite_is_finite _ (A ⟶ B))... set (λ b, Func A B (λ x, b)) as F. set (Func B (A ⟶ B) (λ b, F b)) as f. assert (HF: ∀b ∈ B, F b: A ⇒ B). { intros b Hb. apply meta_function. intros _ _... } exists f. apply meta_injection. - intros b Hb. apply SepI. + apply PowerAx. intros p Hp. apply SepE1 in Hp... + apply HF... - intros x1 H1 x2 H2 Heq. assert ((F x1)[a] = (F x2)[a]) by congruence. unfold F in H. do 2 (rewrite meta_func_ap in H; [|apply HF|])... Qed. Lemma finite_arrow : ∀ A B, ⦿ A → 2 ≤ |B| → finite (A ⟶ B) → finite A ∧ finite B. Proof with eauto. intros * Ha Hb Hfin. split. - eapply finite_arrow_l... - eapply finite_arrow_r... Qed. Theorem arrow_finite_iff : ∀ A B, ⦿ A → 2 ≤ |B| → finite A ∧ finite B ↔ finite (A ⟶ B). 
Require Import Relation_Definitions. Require Import CoefStructure. Require Import moreCoefStructure. Require Import OrderStructure. Require Import Monomials. Section Term. Load "hCoefStructure". Load "mCoefStructure". Load "hOrderStructure". Load "mOrderStructure". Definition M1 := zero_mon n. Definition Term := (A * mon n)%type. Set Implicit Arguments. Unset Strict Implicit. Definition zeroP : Term -> Prop. intros H'; case H'. intros a H'1; exact (eqA a A0). Defined. Definition eqTerm : Term -> Term -> Prop. intros H'; case H'. intros a a' H'2; case H'2. intros b b'; exact (eqA a b /\ a' = b'). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem eqTerm_refl : reflexive Term eqTerm. 
with (z1 + 1 * z2)%Z; auto with zarith. apply Zplus_le_compat_l. rewrite Zopp_mult_distr_l. apply Zle_Zmult_comp_r; auto with zarith. unfold Zminus in |- *; rewrite Zopp_mult_distr_l; auto with zarith. Qed. Definition Zdivides (n m : Z) := exists q : Z, n = (m * q)%Z. Theorem ZdividesZquotient : forall n m : Z, m <> 0%Z -> Zdivides n m -> n = (Zquotient n m * m)%Z. intros n m H' H'0. case H'0; intros z1 Hz1. case (ZquotientProp n m); auto; intros z2 (Hz2, (Hz3, Hz4)). cut (z2 = 0%Z); [ intros H1; pattern n at 1 in |- *; rewrite Hz2; rewrite H1; ring | idtac ]. cut (z2 = ((z1 - Zquotient n m) * m)%Z); [ intros H2 | idtac ]. case (Z_eq_dec (z1 - Zquotient n m) 0); intros H3. rewrite H2; rewrite H3; ring. Contradict Hz4. replace (Zabs m) with (1 * Zabs m)%Z; [ idtac | ring ]. apply Zle_not_lt; rewrite H2. rewrite Zabs_Zmult; apply Zle_Zmult_comp_r; auto with zarith. generalize H3; case (z1 - Zquotient n m)%Z; try (intros H1; case H1; auto; fail); simpl in |- *; intros p; case p; simpl in |- *; auto; intros; red in |- *; simpl in |- *; auto; red in |- *; intros; discriminate. rewrite Zmult_minus_distr_r; rewrite (Zmult_comm z1); rewrite <- Hz1; (pattern n at 1 in |- *; rewrite Hz2); ring. Qed. Theorem ZdividesZquotientInv : forall n m : Z, n = (Zquotient n m * m)%Z -> Zdivides n m. intros n m H'; red in |- *. exists (Zquotient n m); auto. pattern n at 1 in |- *; rewrite H'; auto with zarith. Qed. Theorem ZdividesMult : forall n m p : Z, Zdivides n m -> Zdivides (p * n) (p * m). intros n m p H'; red in H'. elim H'; intros q E. red in |- *. exists q. rewrite E. auto with zarith. Qed. Theorem Zeq_mult_simpl : forall a b c : Z, c <> 0%Z -> (a * c)%Z = (b * c)%Z -> a = b. intros a b c H H0. case (Zle_or_lt c 0); intros Zl1. apply Zle_antisym; apply Zmult_le_reg_r with (p := (- c)%Z); try apply Zlt_gt; auto with zarith; repeat rewrite <- Zopp_mult_distr_r; rewrite H0; auto with zarith. apply Zle_antisym; apply Zmult_le_reg_r with (p := c); try apply Zlt_gt; auto with zarith; rewrite H0; auto with zarith. Qed. Theorem ZdividesDiv : forall n m p : Z, p <> 0%Z -> Zdivides (p * n) (p * m) -> Zdivides n m. 
: forall P, RoundedModeP b radix P -> forall p q : float, (0 <= p)%R -> (p <= q)%R -> Fbounded b p -> Fbounded b q -> (exists r : float, Fbounded b r /\ r = (q - p)%R :>R) -> forall r : float, Fbounded b r -> (p <= r)%R -> (r <= q)%R -> exists r' : float, Fbounded b r' /\ r' = (r - p)%R :>R. intros P H' p q H'0 H'1 H'2 H'3 H'4 r H'5 H'6 H'7. replace (FtoRradix r) with (FtoRradix (Fnormalize radix b precision r)); [ idtac | apply (FnormalizeCorrect radix) ]; auto. replace (FtoRradix p) with (FtoRradix (Fnormalize radix b precision p)); [ idtac | apply (FnormalizeCorrect radix) ]; auto. apply ExactMinusIntervalAux1 with (P := P) (q := Fnormalize radix b precision q); auto; try repeat rewrite (FnormalizeCorrect radix); auto; apply FnormalizeCanonic; auto with arith. Qed. Theorem MSBroundLSB : forall P : R -> float -> Prop, RoundedModeP b radix P -> forall f1 f2 : float, P f1 f2 -> ~ is_Fzero (Fminus radix f1 f2) -> (MSB radix (Fminus radix f1 f2) < LSB radix f2)%Z. intros P H' f1 f2 H'0 HZ. apply (oneExp_Zlt radix); auto. apply Rlt_le_trans with (Fulp b radix precision f2). apply Rle_lt_trans with (FtoRradix (Fabs (Fminus radix f1 f2))). unfold FtoRradix in |- *; apply MSB_le_abs; auto. unfold FtoRradix in |- *; rewrite Fabs_correct; auto with arith; rewrite Fminus_correct; auto with arith. apply RoundedModeUlp with (4 := H'); auto. apply FUlp_Le_LSigB; auto. apply RoundedModeBounded with (1 := H') (2 := H'0); auto. Qed. Theorem LSBMinus : forall p q : float, ~ is_Fzero (Fminus radix p q) -> (Zmin (LSB radix p) (LSB radix q) <= LSB radix (Fminus radix p q))%Z. intros p q H'1. elim (LSB_rep_min radix) with (p := p); auto; intros z E. elim (LSB_rep_min radix) with (p := q); auto; intros z0 E0. replace (LSB radix (Fminus radix p q)) with (LSB radix (Fminus radix (Float z (LSB radix p)) (Float z0 (LSB radix q)))). replace (Zmin (LSB radix p) (LSB radix q)) with (Fexp (Fminus radix (Float z (LSB radix p)) (Float z0 (LSB radix q)))); [ idtac | simpl in |- *; auto ]. apply Fexp_le_LSB; auto. apply sym_equal; apply LSB_comp; auto. repeat rewrite Fminus_correct; auto with arith. unfold FtoRradix in E; unfold FtoRradix in E0; rewrite E; rewrite E0; auto. Qed. Theorem LSBPlus : forall p q : float, ~ is_Fzero (Fplus radix p q) -> (Zmin (LSB radix p) (LSB radix q) <= LSB radix (Fplus radix p q))%Z. 
gmap u64 T) (am : gmap addr T) : Prop := ( ∀ a v, am !! a = Some v -> valid_addr a ∧ fm !! (addr2flat a) = Some v ) ∧ ( ∀ fa v, fm !! fa = Some v -> ∃ a, valid_addr a ∧ addr2flat a = fa ∧ am !! a = Some v ). Theorem flatid_addr_lookup fm am a : flatid_addr_map fm am -> valid_addr a -> fm !! (addr2flat a) = am !! a. Proof. unfold flatid_addr_map; intros. destruct (am !! a) eqn:Heq. - apply H; eauto. - destruct (fm !! addr2flat a) eqn:Heq2; eauto. apply H in Heq2; eauto. destruct Heq2; intuition idtac. apply addr2flat_eq in H1; eauto; subst. congruence. Qed. Theorem flatid_addr_lookup_valid fm am a : flatid_addr_map fm am -> is_Some (am !! a) -> valid_addr a. Proof. unfold flatid_addr_map; intros. destruct H0. apply H in H0. intuition eauto. Qed. Theorem flatid_addr_insert fm am a v : flatid_addr_map fm am -> valid_addr a -> flatid_addr_map (<[addr2flat a := v]> fm) (<[a := v]> am). Proof. rewrite /flatid_addr_map; split; intros. - destruct (decide (a = a0)); subst. + rewrite lookup_insert in H1; inversion H1; clear H1; subst. repeat rewrite -> lookup_insert; eauto. + rewrite -> lookup_insert_ne in H1 by eauto. apply H in H1; intuition eauto. rewrite -> lookup_insert_ne by (apply addr2flat_ne; eauto). eauto. - destruct (decide (addr2flat a = fa)); subst. + rewrite lookup_insert in H1; inversion H1; clear H1; subst. eexists. repeat rewrite -> lookup_insert; eauto. + rewrite -> lookup_insert_ne in H1 by eauto. apply H in H1; destruct H1. intuition eauto. exists x; intuition eauto. rewrite -> lookup_insert_ne; eauto. congruence. Qed. Theorem flatid_addr_insert_inv_2 fm am a v : flatid_addr_map fm (<[a := v]> am) -> valid_addr a ∧ fm !! (addr2flat a) = Some v ∧ flatid_addr_map (delete (addr2flat a) fm) (delete a am). Proof. intros. destruct H. edestruct H. { erewrite lookup_insert; eauto. } intuition eauto. split; intros. - destruct (decide (a = a0)); subst. { rewrite lookup_delete in H3; congruence. } rewrite lookup_delete_ne in H3; eauto. edestruct H. { rewrite lookup_insert_ne; eauto. } intuition eauto. rewrite lookup_delete_ne; eauto. eapply addr2flat_ne; eauto. - destruct (decide (addr2flat a = fa)); subst. { rewrite lookup_delete in H3; congruence. } rewrite lookup_delete_ne in H3; eauto. apply H0 in H3. destruct H3. exists x. intuition eauto. rewrite -> lookup_insert_ne in H6 by congruence. rewrite -> lookup_delete_ne by congruence. eauto. Qed. Theorem flatid_addr_insert_inv_1 fm am fa v : flatid_addr_map (<[fa := v]> fm) am -> ∃ a, valid_addr a ∧ fa = addr2flat a ∧ am !! a = Some v ∧ flatid_addr_map (delete fa fm) (delete a am). 
| [|- context[bound_not_stem_fundefs_ctx (Fcons2_c _ _ _ _ _)]] => rewrite bound_not_stem_Fcons2_c end. Ltac normalize_bound_not_stem_ctx_in_ctx := match goal with | [ H: context[bound_not_stem_ctx Hole_c] |- _] => rewrite bound_not_stem_Hole_c in H | [ H : context[bound_not_stem_ctx (Econstr_c _ _ _ _)] |- _ ] => rewrite bound_not_stem_Econstr_c in H | [ H : context[bound_not_stem_ctx (Eproj_c _ _ _ _ _)] |- _ ] => rewrite bound_not_stem_Eproj_c in H | [H: context[bound_not_stem_ctx (Ecase_c _ _ _ _ _)] |- _] => rewrite bound_not_stem_Case_c in H | [ H : context[bound_not_stem_ctx (Efun1_c _ _)] |- _ ] => rewrite bound_not_stem_Fun1_c in H | [ H : context[bound_not_stem_ctx (Efun2_c _ _)] |- _ ] => rewrite bound_not_stem_Fun2_c in H | [ H : context[bound_not_stem_ctx (Eprim_c _ _ _ _)] |- _ ] => rewrite bound_not_stem_Eprim_c in H | [H:context[bound_not_stem_fundefs_ctx (Fcons1_c _ _ _ _ _)] |- _] => rewrite bound_not_stem_Fcons1_c in H | [H: context[bound_not_stem_fundefs_ctx (Fcons2_c _ _ _ _ _)] |- _] => rewrite bound_not_stem_Fcons2_c in H end. Theorem bound_var_stem_or_not_stem_mut: (forall c, bound_var_ctx c <--> bound_not_stem_ctx c :|: bound_stem_ctx c) /\ (forall f,bound_var_fundefs_ctx f <--> names_in_fundefs_ctx f :|: (bound_not_stem_fundefs_ctx f :|: bound_stem_fundefs_ctx f)). Proof. apply exp_fundefs_ctx_mutual_ind; intros; try normalize_bound_var_ctx; try normalize_bound_stem_ctx; try normalize_bound_not_stem_ctx; try rewrite H; eauto 25 with Ensembles_DB. - split; eauto 25 with Ensembles_DB. - assert (Hn := Decidable_name_in_fundefs f4). split; intro; intros. inv H0; eauto 25 with Ensembles_DB. inv Hn. specialize (Dec x). inv Dec; eauto. left. left. split; auto. inv H1; eauto with Ensembles_DB. inv H0. inv H1. inv H0; auto. auto. inv H1; auto. apply name_in_fundefs_bound_var_fundefs in H0. auto. - split; intro; intros H0; inv H0; eauto 25 with Ensembles_DB. inv H1; auto. inv H0; auto. inv H1; auto. inv H1; auto. - assert (Hf6 := Decidable_name_in_fundefs f6). split; intro; intros H0. inv H0. left; constructor; auto. inv H1. right; right; auto. inv H0; auto. inv H1; auto. inv Hf6. specialize (Dec x). inv Dec. left. constructor 2; auto. right. left. right. split; auto. inv H0. inv H1. auto. apply name_in_fundefs_bound_var_fundefs in H0. auto. inv H1; auto. inv H0; auto. inv H1. auto. inv H0; auto. - split; intro; intros H0; inv H0; eauto 25 with Ensembles_DB. left; constructor; auto. inv H1; auto. inv H0; auto. inv H1; auto. left; constructor 2; auto. inv H0; auto. inv H1; auto. inv H1; auto. inv H0; auto. inv H1; auto. right. right. right. auto. right. right. right. auto. Qed. Theorem bound_stem_var: (forall c, bound_stem_ctx c \subset bound_var_ctx c) /\ (forall fc, bound_stem_fundefs_ctx fc \subset bound_var_fundefs_ctx fc). 
z. Proof Ring.prod_intro_r ring. Definition prod_is_inv_l := Ring.prod_is_inv_l ring. Definition prod_is_inv_r := Ring.prod_is_inv_r ring. Definition prod_is_inv := Ring.prod_is_inv ring. Definition prod_has_inv_l := Ring.prod_has_inv_l ring. Definition prod_has_inv_r := Ring.prod_has_inv_r ring. Definition prod_has_inv := Ring.prod_has_inv ring. Theorem prod_is_inv_lr : forall x y : E, prod_is_inv_l x y -> prod_is_inv_r x y. Proof fun x y H => H || a = 1 @a by prod_is_comm x y. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. Proof Ring.prod_inv_l_r_eq ring. Theorem prod_inv_sym : forall x y : E, prod_is_inv x y <-> prod_is_inv y x. Proof Ring.prod_inv_sym ring. Theorem prod_cancel_l : forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y. Proof Ring.prod_cancel_l ring. Theorem prod_cancel_r : forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y. Proof Ring.prod_cancel_r ring. Theorem prod_inv_l_uniq : forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Ring.prod_inv_l_uniq ring. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Ring.prod_inv_r_uniq ring. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Ring.prod_inv_uniq ring. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Ring.prod_inv_1 ring. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Ring.prod_has_inv_l_1 ring. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Ring.prod_has_inv_r_1 ring. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. 
Hrest_blocks Hrest_used"). iDestruct "IH" as (s_inodes) "H"; iNamed "H". iExists (s_inodes ++ [(inode.mk  [])]). iSplitR. ++ iPureIntro. rewrite app_length; simpl. lia. ++ rewrite big_sepL_app. iFrame "Hinodes". repeat rewrite big_sepL_singleton. replace (Z.of_nat n) with (int.Z (U64 n)) by word. rewrite Hinode_len. replace (n+0)%nat with n by word. replace (Z.of_nat n) with (int.Z (U64 n)) by word. iDestruct (init_inode with "Hinode") as "Hinode". iFrame. } iSplitL "Hfree Hallused". { pose proof (new_alloc_state_properties num_inodes (sz-num_inodes)  ltac:(set_solver)) as (Hdom&Hpost_crash&Hused&Hunused). iExists (new_alloc_state num_inodes (sz-num_inodes)  ). iSplitR; first eauto. iSplitR. { replace ((num_inodes + (sz - num_inodes) - Z.of_nat num_inodes)%Z) with ((sz - num_inodes)%Z) by word. rewrite /alloc.domain in Hdom; eauto. } rewrite /Palloc Hused. iSplitL "Hallused". + iExists (gset_to_gmap  (set_seq 0 num_inodes)). iFrame "Hallused". iSplit; iPureIntro; set_unfold; lia. + rewrite Hunused difference_empty_L. rewrite /rangeSet. rewrite big_sepS_list_to_set; last first. { apply seq_U64_NoDup; word. } rewrite big_sepL_fmap. unfold allocΨ. iApply (big_sepL_mono with "Hfree"). iIntros (???) "H". iExists _. iExists _. iExactEq "H". f_equiv. * apply lookup_seqZ in H. word. * eauto. } iPureIntro. intros idx Hidx. exists []. apply lookup_gset_to_gmap_Some; split; auto. set_unfold. lia. Qed. Lemma pre_inodes_to_cinv inode_refs s_inodes : ([∗ list] i↦inode_ref;s_inode ∈ inode_refs;s_inodes, pre_inode inode_ref i s_inode) -∗ ([∗ list] i↦s_inode ∈ s_inodes, inode_cinv_precrash i s_inode). Proof. iIntros "Hpre". iApply big_sepL2_to_sepL_2 in "Hpre". iApply (big_sepL_mono with "Hpre"). iIntros (???) "Hpre". iDestruct "Hpre" as (inode_ref) "(?&Hpre)". iApply pre_inode_to_cinv; eauto. Qed. Lemma pre_inodes_to_cinv' inode_refs s_inodes : ([∗ list] i↦inode_ref;s_inode ∈ inode_refs;s_inodes, pre_inode inode_ref i s_inode) -∗ ([∗ list] i↦s_inode ∈ s_inodes, inode_cinv_postcrash i s_inode). Proof. iIntros "Hpre". iApply big_sepL2_to_sepL_2 in "Hpre". iApply (big_sepL_mono with "Hpre"). iIntros (???) "Hpre". iDestruct "Hpre" as (inode_ref) "(?&Hpre)". iApply pre_inode_to_cinv'; eauto. Qed. Lemma inodes_cinv_post_to_pre k s_inodes : ([∗ list] i↦s_inode ∈ s_inodes, inode_cinv_postcrash (k + i) s_inode) -∗ ([∗ list] i↦s_inode ∈ s_inodes, inode_cinv_precrash (k + i) s_inode). Proof. iIntros "Hpre". iApply (big_sepL_mono with "Hpre"). iIntros (???) "Hpre". by iApply inode_cinv_post_to_pre. Qed. Lemma pre_dir_to_cinv l sz dir : pre_dir l sz dir -∗ dir_cinv sz dir true. Proof. iNamed 1. iDestruct "Hinodes" as (s_inodes) "Hpre_inodes". iNamed "Halloc". iExists _, _; iFrame. iSplitL "Hpre_inodes". - iDestruct (big_sepL2_length with "Hpre_inodes") as %Hlen'. iExists s_inodes; iFrame. iSplit. { iPureIntro; congruence. } iApply big_sepL2_flip in "Hpre_inodes". iApply (big_sepL2_elim_big_sepL with "[] Hpre_inodes"); first auto. iIntros "!>" (???????) "[Hpre HP]". assert (x = z) by congruence; subst. iFrame. iApply pre_inode_to_cinv'; eauto. - iDestruct (is_allocator_pre_post_crash with "Halloc_mem") as %?. iExists _; iFrame "∗ %". Qed. Theorem is_dir_alloc l (sz: Z) σ : (5 ≤ sz < 2^64)%Z → ▷ P σ -∗ pre_dir l sz σ ={⊤}=∗ init_cancel (is_dir l sz) (∃ σ', dir_cinv sz σ' false ∗ ▷ P σ'). 
prog. Theorem get_dcache_ok : forall lxp ixp dnum ms, {< F Fi Fm m0 sm m dmap ilist frees bxp f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fi Fm m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms', cache) exists f', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fi Fm m bxp ixp dnum dmap ilist frees f' ms' sm * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] * [[ BFILE.BFCache f' = Some cache ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} get_dcache lxp ixp dnum ms. Proof. unfold get_dcache, rep_macro. hoare. Unshelve. all: eauto. Qed. Hint Extern 1 ({{_}} Bind (get_dcache _ _ _ _) _) => apply get_dcache_ok : prog. Theorem lookup_ok : forall lxp bxp ixp dnum name ms, {< F Fi Fm m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fi Fm m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms', r) exists f', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fi Fm m bxp ixp dnum dmap ilist frees f' ms' sm * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] * ( [[ r = None /\ notindomain name dmap ]] \/ exists inum isdir Fd, [[ r = Some (inum, isdir) /\ inum <> 0 /\ (Fd * name |-> (inum, isdir))%pred dmap ]]) * [[ True ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} lookup lxp ixp dnum name ms. Proof. unfold lookup. hoare. subst_cache. denote (Dcache.find) as Hf. denote (BFILE.BFCache _ = _) as Hb. erewrite Hf in * by eauto. destruct (dmap name) eqn:?; [ or_r | or_l ]. assert (fst p <> 0). destruct p; cbn in *. intro; subst; eauto using SDIR.rep_no_0_inum. repeat ( denote! (SDIR.rep _ _) as Hx; clear Hx ). cancel. eauto using any_sep_star_ptsto. cancel. Unshelve. all: repeat (solve [eauto] || constructor). Qed. Hint Extern 1 ({{_}} Bind (lookup _ _ _ _ _) _) => apply lookup_ok : prog. Theorem readdir_ok : forall lxp bxp ixp dnum ms, {< F Fi Fm m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fi Fm m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms', r) rep_macro Fi Fm m bxp ixp dnum dmap ilist frees f ms' sm * LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * [[ listpred SDIR.readmatch r dmap ]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ True ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} readdir lxp ixp dnum ms. 
lia. } iMod (fmlist_update (take new_durable (possible crash_heaps)) with "Hcrash_durable_auth") as "(Hcrash_durable_auth&_)"; eauto. { apply take_prefix_le. lia. } iModIntro. iSplitL "Hinstalled Hcrash_all_auth Hcrash_durable_auth Hpossible_heaps Hcrash_heaps_lb". { iExists _. iFrame. simpl. iSplitL "". { iPureIntro. intros. rewrite -Hlast. f_equal. } iSplitL "". { iPureIntro. eapply wal_wf_advance_installed_lb; last by (intuition; simpl; lia). eapply wal_wf_advance_durable_lb; eauto. } iFrame "%". } iExists _, _, _. iFrame. iFrame "Hinstalledfrag". iPureIntro. intros σ' i Hr1 Hr2 Hlookup. rewrite -Hlast. rewrite -(Hdisk_at i σ'); last eauto. eapply no_updates_since_last_disk; eauto. eapply (no_updates_since_mono σ blkno new_installed); eauto. } } iIntros (ok bl) "Hbl". destruct ok. { iDestruct "Hbl" as (b') "(Hbl & HQ)". wp_pures. iApply "HΦ". iFrame. } wp_pures. iNamed "Hbl". iDestruct "Hbl" as "(Hall_lb&Hfupd)". wp_apply (wp_Walog__ReadInstalled _ (λ b', Q b') with "[$Hwal $Hin_bounds Hfupd Hall_lb]"). { iIntros (σ0 σ1 b0) "%Hwf' %Hrelation Hwalinv". simpl in *; monad_inv. simpl in *; monad_inv. match goal with | H : context[unwrap ?x] |- _ => destruct x eqn:? end. 2: simpl in *; monad_inv. simpl in *; monad_inv. iNamed "Hwalinv". iDestruct "Hfupd" as "(Hownlb&Hnoupd&Hfupd)". iDestruct "Hnoupd" as %Hnoupd. iDestruct (fmlist_agree_2 with "Hcrash_all_auth Hall_lb") as %Hprefix. destruct Hprefix as (disks2&Hprefix). rewrite Hprefix. iDestruct (wal_heap_inv_crashes_list_at_ids with "Hcrash_heaps") as %Hdisk_at. iDestruct (own_valid_2 with "Hinstalled Hownlb") as %Hval. apply auth_both_dfrac_valid_discrete in Hval as (_&Hle%max_nat_included&_). simpl in Hle. destruct (decide (txn_id < length (disks1 ++ [curr]))). * iMod ("Hfupd" $! disks2 0 curr with "[$Hcrash_all_auth]") as (b' Hlookup) "(Hcrash_all_auth&HQ)". { eauto. } assert (curr !! blkno = Some b). { etransitivity; last eapply Heqo. edestruct (lookup_lt_is_Some_2 ((disks1 ++ [curr]) ++ disks2) txn_id) as (σ&Hget_σ). { rewrite app_length. lia. } symmetry. etransitivity; last eapply (Hnoupd σ txn_id); try lia. { eapply Hdisk_at; eassumption. } { rewrite lookup_app_l in Hget_σ; eauto. } } assert (b = b') as -> by congruence. iFrame "HQ". iModIntro. iExists _. rewrite -Hprefix. iFrame. iFrame "%". * iNamed "Hcrash_heaps". edestruct (lookup_lt_is_Some_2 ((disks1 ++ [curr]) ++ disks2) txn_id) as (σ&Hget_σ). { lia. } iMod ("Hfupd" $! disks2 (S (txn_id - (length (disks1 ++ [curr])))) σ with "[$Hcrash_all_auth]") as (b' Hlookup) "(Hcrash_all_auth&HQ)". { iPureIntro. rewrite lookup_app_r in Hget_σ; last lia. simpl. eauto. } assert (σ !! blkno = Some b). { etransitivity; last eapply Heqo. symmetry. eapply Hdisk_at; eauto. } assert (b = b') as -> by congruence. iFrame "HQ". iModIntro. iExists _. rewrite -Hprefix. iFrame. iFrame "%". iPureIntro. congruence. } iIntros (?) "H". iDestruct "H" as (b) "(?&?)". iApply "HΦ". by iFrame. Qed. Theorem wp_Walog__Flush_heap l γd γe (txn_id : nat) (pos : u64) Q : {{{ is_walheap γd γe l ∗ txn_pos γe txn_id pos ∗ (∀ disks_all disks_durable, ⌜ txn_id ≤ length disks_durable ⌝ ∗ heap_all γe disks_all ∗ heap_durable γd disks_durable ={⊤ ∖ ↑walN}=∗ heap_all γe disks_all ∗ heap_durable γd disks_durable ∗ Q) }}} wal.Walog__Flush #l #pos {{{ RET #(); Q }}}. 
<-> (forall (x: elt), match get x m1, get x m2 with | None, None => True | Some y1, Some y2 => beqA y1 y2 = true | _, _ => False end). Proof. intros. rewrite beq_correct_bool. unfold beq_optA. split; intros. - specialize (H x). destruct (get x m1), (get x m2); intuition congruence. - specialize (H x). destruct (get x m1), (get x m2); intuition auto. Qed. End BOOLEAN_EQUALITY. Fixpoint prev_append (i j: positive) {struct i} : positive := match i with | xH => j | xI i' => prev_append i' (xI j) | xO i' => prev_append i' (xO j) end. Definition prev (i: positive) : positive := prev_append i xH. Lemma prev_append_prev i j: prev (prev_append i j) = prev_append j i. Proof. revert j. unfold prev. induction i as [i IH|i IH|]. 3: reflexivity. intros j. simpl. rewrite IH. reflexivity. intros j. simpl. rewrite IH. reflexivity. Qed. Lemma prev_involutive i : prev (prev i) = i. Proof (prev_append_prev i xH). Lemma prev_append_inj i j j' : prev_append i j = prev_append i j' -> j = j'. Proof. revert j j'. induction i as [i Hi|i Hi|]; intros j j' H; auto; specialize (Hi _ _ H); congruence. Qed. Fixpoint map' {A B} (f: positive -> A -> B) (m: tree' A) (i: positive) {struct m} : tree' B := match m with | Node001 r => Node001 (map' f r (xI i)) | Node010 x => Node010 (f (prev i) x) | Node011 x r => Node011 (f (prev i) x) (map' f r (xI i)) | Node100 l => Node100 (map' f l (xO i)) | Node101 l r => Node101 (map' f l (xO i)) (map' f r (xI i)) | Node110 l x => Node110 (map' f l (xO i)) (f (prev i) x) | Node111 l x r => Node111 (map' f l (xO i)) (f (prev i) x) (map' f r (xI i)) end. Definition map {A B} (f: positive -> A -> B) (m: tree A) := match m with | Empty => Empty | Nodes m => Nodes (map' f m xH) end. Lemma gmap': forall {A B} (f: positive -> A -> B) (i j : positive) (m: tree' A), get' i (map' f m j) = option_map (f (prev (prev_append i j))) (get' i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Theorem gmap: forall {A B} (f: positive -> A -> B) (i: positive) (m: t A), get i (map f m) = option_map (f i) (get i m). 
y : Y ) ( is : isofhlevel (S n) (paths y y) ) : isofhlevelf (S n) (hfiberpr1 f y). Proof. intros . unfold isofhlevelf. intro x. apply (isofhlevelweqf (S n) ( ezweq1g f y x ) ). apply isofhlevelsn. intro X1. destruct X1. assumption. Defined . Corollary isofhlevelfhfiberpr1 ( n : nat ) { X Y : UU } ( f : X -> Y ) ( y : Y ) ( is : isofhlevel (S n) Y ) : isofhlevelf n ( hfiberpr1 f y ) . Proof. intros. apply isofhlevelfhfiberpr1y. intro y' . apply (is y' y). Defined. Theorem isofhlevelff ( n : nat ) { X Y Z : UU } (f : X -> Y ) ( g : Y -> Z ) : isofhlevelf n (fun x : X => g ( f x) ) -> isofhlevelf (S n) g -> isofhlevelf n f. Proof. intros n X Y Z f g X0 X1. unfold isofhlevelf. intro y . set (ye:= hfiberpair g y (idpath (g y))). apply (isofhlevelweqb n ( ezweqhf f g (g y) ye ) (isofhlevelffromXY n _ (X0 (g y)) (X1 (g y)) ye)). Defined.Theorem isofhlevelfgf ( n : nat ) { X Y Z : UU } ( f : X -> Y ) ( g : Y -> Z ) : isofhlevelf n f -> isofhlevelf n g -> isofhlevelf n (fun x:X => g(f x)). Proof. intros n X Y Z f g X0 X1. unfold isofhlevelf. intro z. assert (is1: isofhlevelf n (hfibersgftog f g z)). unfold isofhlevelf. intro ye. apply (isofhlevelweqf n ( ezweqhf f g z ye ) (X0 (pr1 ye))). assert (is2: isofhlevel n (hfiber g z)). apply (X1 z). apply (isofhlevelXfromfY n _ is1 is2). Defined.Theorem isofhlevelfgwtog (n:nat ) { X Y Z : UU } ( w : weq X Y ) ( g : Y -> Z ) ( is : isofhlevelf n (fun x : X => g ( w x ) ) ) : isofhlevelf n g . Proof. intros . intro z . assert ( is' : isweq ( hfibersgftog w g z ) ) . intro ye . apply ( iscontrweqf ( ezweqhf w g z ye ) ( pr2 w ( pr1 ye ) ) ) . apply ( isofhlevelweqf _ ( weqpair _ is' ) ( is _ ) ) . Defined . Theorem isofhlevelfgtogw (n:nat ) { X Y Z : UU } ( w : weq X Y ) ( g : Y -> Z ) ( is : isofhlevelf n g ) : isofhlevelf n (fun x : X => g ( w x ) ) . 
right associativity) : list_scope. Open Scope list_scope. Definition head (l:list) := match l with | nil => error | x :: _ => value x end. Definition hd (default:A) (l:list) := match l with | nil => default | x :: _ => x end. Definition tail (l:list) : list := match l with | nil => nil | a :: m => m end. Fixpoint length (l:list) : nat := match l with | nil => 0 | _ :: m => S (length m) end.Parameter size : list -> nat. Axiom size_nil : size nil = 0. Fixpoint In (a:A) (l:list) {struct l} : Prop := match l with | nil => False | b :: m => b = a \/ In a m end. Fixpoint app (l m:list) {struct l} : list := match l with | nil => m | a :: l1 => a :: app l1 m end. Infix "++" := app (right associativity, at level 60) : list_scope.End Lists.Arguments nil {A}. Infix "::" := cons (at level 60, right associativity) : list_scope. Infix "++" := app (right associativity, at level 60) : list_scope.Open Scope list_scope.Delimit Scope list_scope with list.Bind Scope list_scope with list.Arguments list _%type_scope.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), nil <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = nil}. Proof. induction l as [|a tl]. right; reflexivity. left; exists a; exists tl; reflexivity. Qed. Theorem head_nil : head (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem head_cons : forall (l : list A) (x : A), head (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl in |- *; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl in |- *; auto. Qed. Theorem in_nil : forall a:A, ~ In a nil. Proof. unfold not in |- *; intros a H; inversion_clear H. Qed. Lemma In_split : forall x (l:list A), In x l -> exists l1, exists l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists (@nil A); exists l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1); exists l2; simpl; f_equal; auto. Qed. Theorem in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. 
Qed. Theorem Property_finish_minting_unresumable: forall msg to amount, m_func msg = mc_mint to amount -> forall C, st_mintingFinished (w_st C) = true -> forall env C' evts, ~ step env C msg C' evts. Proof. intros msg to amount Hfunc C Hfinished env C' evts Hstep. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [[_ [Hfinished' _]] _]. rewrite Hfinished in Hfinished'. inversion Hfinished'. Qed. Theorem Property_restricted_owner_for_transfer: forall msg to v, m_func msg = mc_transfer to v -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) /\ acct <> to -> st_balances (w_st C) acct = st_balances (w_st C') acct. Proof. intros msg to v Hfunc env C C' evts Hstep Hsender acct Hacct. destruct Hacct as [Hacct_owner Hacct_to]. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]. rewrite Hbalances. unfold a2v_upd_dec, a2v_upd_inc. subst sender. apply neq_beq_false in Hacct_owner. apply neq_beq_false in Hacct_to. rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)). rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_owner)). reflexivity. Qed. Theorem Property_restricted_owner_for_transferFrom: forall msg from to v, m_func msg = mc_transferFrom from to v -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> from /\ acct <> to -> st_balances (w_st C) acct = st_balances (w_st C') acct. Proof. intros msg from to v Hfunc env C C' evts Hstep Hsender acct Hacct. destruct Hacct as [Hacct_from Hacct_to]. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). - subst; simpl in *. destruct H5 as [_ [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]]. rewrite Hbalances. unfold a2v_upd_dec, a2v_upd_inc. subst sender. apply neq_beq_false in Hacct_from. apply neq_beq_false in Hacct_to. rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)). rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_from)). reflexivity. - subst; simpl in *; destruct H5 as [_ [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]]; rewrite Hbalances; unfold a2v_upd_dec, a2v_upd_inc; subst sender; apply neq_beq_false in Hacct_from; apply neq_beq_false in Hacct_to; rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)); rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_from)); reflexivity. Qed. Theorem Property_restricted_owner_for_approve: forall msg _spender _value, m_func msg = mc_approve _spender _value -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) -> forall spender, st_allowed (w_st C) (acct, spender) = st_allowed (w_st C') (acct, spender). 
|- *; intros; discriminate. rewrite Zmult_minus_distr_r; rewrite (Zmult_comm z1); rewrite <- Hz1; (pattern n at 1 in |- *; rewrite Hz2); ring. Qed. Theorem ZdividesZquotientInv : forall n m : Z, n = (Zquotient n m * m)%Z -> Zdivides n m. intros n m H'; red in |- *. exists (Zquotient n m); auto. pattern n at 1 in |- *; rewrite H'; auto with zarith. Qed. Theorem ZdividesMult : forall n m p : Z, Zdivides n m -> Zdivides (p * n) (p * m). intros n m p H'; red in H'. elim H'; intros q E. red in |- *. exists q. rewrite E. auto with zarith. Qed. Theorem Zeq_mult_simpl : forall a b c : Z, c <> 0%Z -> (a * c)%Z = (b * c)%Z -> a = b. intros a b c H H0. case (Zle_or_lt c 0); intros Zl1. apply Zle_antisym; apply Zmult_le_reg_r with (p := (- c)%Z); try apply Zlt_gt; auto with zarith; repeat rewrite <- Zopp_mult_distr_r; rewrite H0; auto with zarith. apply Zle_antisym; apply Zmult_le_reg_r with (p := c); try apply Zlt_gt; auto with zarith; rewrite H0; auto with zarith. Qed. Theorem ZdividesDiv : forall n m p : Z, p <> 0%Z -> Zdivides (p * n) (p * m) -> Zdivides n m. intros n m p H' H'0. case H'0; intros q E. exists q. apply Zeq_mult_simpl with (c := p); auto. rewrite (Zmult_comm n); rewrite E; ring. Qed. Definition ZdividesP : forall n m : Z, {Zdivides n m} + {~ Zdivides n m}. intros n m; case m. case n. left; red in |- *; exists 0%Z; auto with zarith. intros p; right; red in |- *; intros H; case H; simpl in |- *; intros f H1; discriminate. intros p; right; red in |- *; intros H; case H; simpl in |- *; intros f H1; discriminate. intros p; generalize (Z_eq_bool_correct (Zquotient n (Zpos p) * Zpos p) n); case (Z_eq_bool (Zquotient n (Zpos p) * Zpos p) n); intros H1. left; apply ZdividesZquotientInv; auto. right; Contradict H1; apply sym_equal; apply ZdividesZquotient; auto. red in |- *; intros; discriminate. intros p; generalize (Z_eq_bool_correct (Zquotient n (Zneg p) * Zneg p) n); case (Z_eq_bool (Zquotient n (Zneg p) * Zneg p) n); intros H1. left; apply ZdividesZquotientInv; auto. right; Contradict H1; apply sym_equal; apply ZdividesZquotient; auto. red in |- *; intros; discriminate. Defined. Theorem Zquotient1 : forall m : Z, Zquotient m 1 = m. 
R, (r2 < r1)%R -> (0 < r1 - r2)%R. intros r1 r2 H; replace 0%R with (r1 - r1)%R; unfold Rminus in |- *; auto with real. Qed. Hint Resolve Rlt_Rminus_ZERO: real. Theorem Rabsolu_left1 : forall a : R, (a <= 0)%R -> Rabs a = (- a)%R. intros a H; case H; intros H1. apply Rabs_left; auto. rewrite H1; simpl in |- *; rewrite Rabs_right; auto with real. Qed. Theorem RmaxLess1 : forall r1 r2 : R, (r1 <= Rmax r1 r2)%R. intros r1 r2; unfold Rmax in |- *; case (Rle_dec r1 r2); auto with real. Qed. Theorem RmaxLess2 : forall r1 r2 : R, (r2 <= Rmax r1 r2)%R. intros r1 r2; unfold Rmax in |- *; case (Rle_dec r1 r2); auto with real; intros; apply Ropp_le_cancel; auto with real. Qed. Theorem RmaxSym : forall p q : R, Rmax p q = Rmax q p. intros p q; unfold Rmax in |- *. case (Rle_dec p q); case (Rle_dec q p); auto; intros H1 H2; apply Rle_antisym; auto. case (Rle_or_lt p q); auto; intros H'0; Contradict H1; apply Rlt_le; auto. case (Rle_or_lt q p); auto; intros H'0; Contradict H2; apply Rlt_le; auto. Qed. Theorem RmaxAbs : forall p q r : R, (p <= q)%R -> (q <= r)%R -> (Rabs q <= Rmax (Rabs p) (Rabs r))%R. intros p q r H' H'0; case (Rle_or_lt 0 p); intros H'1. repeat rewrite Rabs_right; auto with real. apply Rle_trans with r; auto with real. apply RmaxLess2; auto. apply Rge_trans with p; auto with real; apply Rge_trans with q; auto with real. apply Rge_trans with p; auto with real. rewrite (Rabs_left p); auto. case (Rle_or_lt 0 q); intros H'2. repeat rewrite Rabs_right; auto with real. apply Rle_trans with r; auto. apply RmaxLess2; auto. apply Rge_trans with q; auto with real. rewrite (Rabs_left q); auto. case (Rle_or_lt 0 r); intros H'3. repeat rewrite Rabs_right; auto with real. apply Rle_trans with (- p)%R; auto with real. apply RmaxLess1; auto. rewrite (Rabs_left r); auto. apply Rle_trans with (- p)%R; auto with real. apply RmaxLess1; auto. Qed. Theorem Rabsolu_Zabs : forall z : Z, Rabs (IZR z) = IZR (Zabs z). intros z; case z; simpl in |- *; auto with real. apply Rabs_right; auto with real. intros p0; apply Rabs_right; auto with real zarith. intros p0; unfold IZR; rewrite <- INR_IPR; rewrite Rabs_Ropp. apply Rabs_right; auto with real zarith. Qed. Theorem RmaxRmult : forall p q r : R, (0 <= r)%R -> Rmax (r * p) (r * q) = (r * Rmax p q)%R. 
(E F : gen_env A), ok E -> ok F -> E ≍ F -> E ∖ xs ≍ F ∖ xs. Proof. intros A xs E F Hok1 Hok2 Heq. unfold eq in *. destruct Heq. split; apply all_binds_all_remove_compat; auto. Qed.Theorem eq_update : forall A (E F G : gen_env A), E ≍ F -> (E ::= G) ≍ (F ::= G). Proof. intros A E F G Heq. unfold eq in *. destruct Heq. split; apply all_binds_update; auto. Qed.Theorem eq_belongs : forall A x (E F : gen_env A), E ≍ F -> x ∈ E -> x ∈ F. Proof. intros A x E F Heq Hin. unfold eq in *. destruct Heq as [ Habind1 Habind2 ]. unfold all_binds in *. apply belongs_binds in Hin. destruct Hin as [ v Hbind ]. apply Habind1 in Hbind. apply binds_belongs with v; auto. Qed.Theorem eq_all_belongs : forall A xs (E F : gen_env A), E ≍ F -> xs ⊂ E -> xs ⊂ F. Proof. intros A xs E F Heq Hin. unfold eq in *. destruct Heq as [ Habind1 Habind2 ]. apply all_binds_belongs in Habind1. apply all_belongs_def. intros. apply all_belongs_def_inv with (dom E); auto. apply belongs_dom. apply all_belongs_def_inv with xs; auto. Qed.Theorem eq_notin : forall A x (E F : gen_env A), E ≍ F -> x ∉ E -> x ∉ F. Proof. intros A x E F Heq Hnotin. unfold eq in *. destruct Heq as [ Habind1 Habind2 ]. unfold all_binds in *. apply not_belongs_notin. intro Hin. apply belongs_binds in Hin. destruct Hin as [ v Hbind ]. apply Habind2 in Hbind. apply binds_belongs in Hbind. apply notin_belongs in Hnotin. contradiction. Qed.Theorem eq_all_notin : forall A xs (E F : gen_env A), E ≍ F -> xs ⊄ E -> xs ⊄ F. Proof. intros A xs E F Heq Hnotin. apply all_notin_def. intros. apply eq_notin with E; auto. apply all_notin_def_inv with xs; auto. Qed. Theorem eq_dec : forall A (E F : gen_env A), (forall w w' : A, { w = w' } + { ¬ w = w' }) -> ok E -> ok F -> { E ≍ F } + { ¬ E ≍ F }. Proof. intros A E F Hdec Hok1 Hok2; unfold eq. elim all_binds_dec with A E F; elim all_binds_dec with A F E; intros; auto; right; intro Heq; destruct Heq; contradiction. Qed. Theorem update_is_remove_concat : forall A x (v : A) (E : gen_env A), x ∈ E -> E ::= (x ∶ v) ≍ (E ∖ {x}) & (x ∶ v). 
big_sepL2_sep; iFrame. iAssert ([∗ list] k↦v ∈ inode_refs, emp)%I as "Hinode_refs". { iApply big_sepL_emp. done. } iDestruct (big_sepL2_sepL_2 with "Hinode_refs HPinodes") as "Hmerge"; eauto. iApply (big_sepL2_mono with "Hmerge"). iIntros (?????) "[_ H]". iFrame. } iExists _; iFrame "∗ %". Qed. Theorem wpc_Dir__Read (Q: option Block → iProp Σ) l sz (idx: u64) (i: u64) : int.nat idx < num_inodes → {{{ "#Hdir" ∷ is_dir l sz ∗ "Hfupd" ∷ (∀ σ blocks mb, ⌜σ.(dir.inodes) !! int.nat idx = Some blocks ∧ mb = blocks !! int.nat i⌝ -∗ ▷ P σ ={⊤ ∖ ↑N}=∗ ▷ P σ ∗ Q mb) }}} Dir__Read #l #idx #i @ ⊤ {{{ (s:Slice.t) mb, RET (slice_val s); match mb with | None => ⌜s = Slice.nil⌝ | Some b => is_block s 1 b end ∗ Q mb }}} {{{ True }}}. Proof. iIntros (Hidx Φ Φc) "Hpre HΦ"; iNamed "Hpre". wpc_call. { crash_case; auto. } { crash_case; auto. } iCache with "HΦ Hfupd". { crash_case; auto. } iNamed "Hdir". iNamed "Hro_state". edestruct (lookup_lt_is_Some_2 inode_refs) as [inode_ref Hinode_ref]. { rewrite Hlen. done. } iDestruct (big_sepL_lookup _ _ _ _ Hinode_ref with "Hinodes") as "Hinode {Hinodes}". wpc_pures. wpc_frame_seq. wp_loadField. iMod (readonly_load with "inodes_s") as (qinodes) "{inodes_s} inodes_s". wp_apply (wp_SliceGet _ _ _ _ _ inode_refs with "[$inodes_s //]"). iIntros "inodes_s Hrest". iNamed "Hrest". wpc_pures. iApply (wpc_step_strong_mono _ _ _ _ _ (λ v, (∃ s mb, ⌜ v = slice_val s ⌝ ∗ match mb with | Some b => is_block s 1 b | None => ⌜s = Slice.nil⌝ end ∗ Q mb))%I _ True with "[-HΦ] [HΦ]"); auto. 2: { iSplit. * iNext. iIntros (?) "H". iDestruct "H" as (??) "(%&?)". subst. iModIntro. iRight in "HΦ". by iApply "HΦ". * iLeft in "HΦ". iIntros. iModIntro. by iApply "HΦ". } iApply (wpc_Inode__Read with "[Hinode]"); first done. iSplit; first eauto. iIntros "!>" (σI mb) "[%Hmb HPI]". iNamed "HPI". iInv dirN as (σD) "[>Hdir HPD]". rewrite /dir_inv. iNamed "Hdir". destruct (Hdom _ Hidx) as [σI' HσI']. iDestruct (inode_blocks_lookup with "Hownblocks Hγblocks") as %Hblock. simplify_eq. iMod fupd_mask_subseteq as "HcloseM"; last iMod ("Hfupd" with "[] HPD") as "[HPD HQ]". { solve_ndisj. } { iPureIntro. eauto. } iMod "HcloseM" as "_". iModIntro. iSplitL "Hγblocks HPD". { eauto 10 with iFrame. } iModIntro. iSplitL "Hownblocks Hused1". { rewrite /Pinode. eauto 10 with iFrame. } iSplit. { eauto. } iIntros (s) "Hpost". iExists _, _; iSplit; first eauto; iFrame; eauto. Qed. Theorem wpc_Dir__Size (Q: u64 → iProp Σ) l sz (idx: u64): int.nat idx < num_inodes → {{{ "#Hdir" ∷ is_dir l sz ∗ "Hfupd" ∷ (∀ σ blocks sz, ⌜σ.(dir.inodes) !! int.nat idx = Some blocks ∧ int.nat sz = length blocks⌝ -∗ ▷ P σ ={⊤ ∖ ↑N}=∗ ▷ P σ ∗ Q sz) }}} Dir__Size #l #idx @ ⊤ {{{ sz, RET #sz; Q sz }}} {{{ True }}}. 
list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> eqP A eqA n (minuspf (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) a q)) (mults (A:=A) multA (n:=n) a (minuspf p q)). intros a p q H' H'0 H'1. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (mults (A:=A) multA (n:=n) a q))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) a) q)); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) a (invTerm (A:=A) invA (n:=n) (T1 A1 n))) q)); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a p) (mults (A:=A) multA (n:=n) a (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) a (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q))); apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem minuspf_zero : forall (a : Term A n) (p q : list (Term A n)), eqP A eqA n (minuspf (pX a p) (pX a q)) (minuspf p q). intros a p q; try assumption. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := minuspf p q); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n). apply minuspf_inv3a; auto. Qed. Hint Resolve canonical_minuspf. Theorem pluspf_minuspf_id : forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqP A eqA n (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (minuspf p q) q) p. 
(m : nat), IZR (Zpower_nat n m) = powerRZ (IZR n) (Z_of_nat m). intros n m; elim m; simpl in |- *; auto with real. intros m1 H'; rewrite Pnat.nat_of_P_o_P_of_succ_nat_eq_succ; simpl in |- *. replace (Zpower_nat n (S m1)) with (n * Zpower_nat n m1)%Z. rewrite Rmult_IZR; auto with real. rewrite H'; simpl in |- *. case m1; simpl in |- *; auto with real. intros m2; rewrite Pnat.nat_of_P_o_P_of_succ_nat_eq_succ; auto. unfold Zpower_nat in |- *; auto. Qed. Theorem powerRZ_lt : forall (e : R) (z : BinInt.Z), (0 < e)%R -> (0 < powerRZ e z)%R. intros e z; case z; simpl in |- *; auto with real. Qed. Hint Resolve powerRZ_lt: real. Theorem powerRZ_le : forall (e : R) (z : BinInt.Z), (0 < e)%R -> (0 <= powerRZ e z)%R. intros e z H'; apply Rlt_le; auto with real. Qed. Hint Resolve powerRZ_le: real. Theorem Rlt_powerRZ : forall (e : R) (n m : BinInt.Z), (1 < e)%R -> (n < m)%Z -> (powerRZ e n < powerRZ e m)%R. intros e n m; case n; case m; simpl in |- *; try (unfold Zlt in |- *; intros; discriminate); auto with real. intros p p0 H' H'0; apply Rlt_pow; auto with real. apply Pnat.nat_of_P_lt_Lt_compare_morphism; auto. intros p H' H'0; replace 1%R with (/ 1)%R; auto with real. intros p p0 H' H'0; apply Rlt_trans with (r2 := 1%R). replace 1%R with (/ 1)%R; auto with real. apply Rlt_pow_R1; auto with real. intros p p0 H' H'0; apply Rinv_1_lt_contravar; auto with real. apply Rlt_pow; auto with real. apply Pnat.nat_of_P_lt_Lt_compare_morphism; rewrite BinPos.ZC4; auto. Qed. Hint Resolve Rlt_powerRZ: real. Theorem Rpow_R1 : forall (r : R) (z : BinInt.Z), r <> 0%R -> powerRZ r z = 1%R -> Rabs r = 1%R \/ z = 0%Z. intros r z; case z; simpl in |- *; auto; intros p H' H'1; left. case (pow_R1 _ _ H'1); auto. intros H'0; Contradict H'0; auto with zarith; apply convert_not_O. rewrite Rinv_pow in H'1; auto. case (pow_R1 _ _ H'1); auto. intros H'0. rewrite <- H'0. apply Rmult_eq_reg_l with (r := 1%R); auto with real. pattern 1%R at 1 in |- *; rewrite <- H'0; auto with real. pattern (Rabs (/ r)) at 1 in |- *; rewrite Rabs_Rinv; try rewrite Rinv_l; auto with real. rewrite H'0; auto with real. apply Rabs_no_R0; auto. intros H'0; Contradict H'0; auto with zarith; apply convert_not_O. Qed. Theorem Rpow_eq_inv : forall (r : R) (p q : BinInt.Z), r <> 0%R -> Rabs r <> 1%R -> powerRZ r p = powerRZ r q -> p = q. 
From Coq Require Import Lists.List NArith Structures.OrderedType micromega.Lia. From Coq Require Strings.Byte. Import ListNotations. #[local] Set Default Proof Using "Type".Definition byte_parse (b : Byte.byte) : Byte.byte := b. Definition byte_print (b : Byte.byte) : Byte.byte := b. Definition byte_cmp (a b : Byte.byte) : comparison := N.compare (Byte.to_N a) (Byte.to_N b).Delimit Scope byte_scope with byte. String Notation Byte.byte byte_parse byte_print : byte_scope.Bind Scope byte_scope with Byte.byte.Lemma byte_cmp_refl a : byte_cmp a a = Eq. Proof. intros. apply N.compare_refl. Qed.Lemma byte_to_N_inj x y : Byte.to_N x = Byte.to_N y <-> x = y. Proof. split. 2: now intros ->. intros Heq. enough (Some x = Some y) as [= ->] by easy. do 2 rewrite <- Byte.of_to_N. now rewrite Heq. Qed.Module OT_byte <: OrderedType.OrderedType with Definition t := Byte.byte. Definition t := Byte.byte. Definition eq := fun l r => byte_cmp l r = Eq. Definition lt := fun l r => byte_cmp l r = Lt. Theorem eq_refl (x : t) : eq x x. Proof. intros; apply N.compare_refl. Qed. Theorem eq_sym (x y : t) : eq x y -> eq y x. 
update_destruct; subst; rewrite_update; auto; repeat find_rewrite; simpl; auto. - find_copy_apply_lem_hyp doGenericServer_spec. break_and. auto. - eauto using doGenericServer_same_type. Qed. Lemma candidate_entries_do_generic_server : refined_raft_net_invariant_do_generic_server CandidateEntries. Proof using. red. unfold CandidateEntries. intros. intuition; simpl in *. - unfold candidateEntries_host_invariant in *. intros. eapply candidateEntries_ext; eauto. repeat find_higher_order_rewrite. update_destruct; subst; rewrite_update. + simpl in *. find_copy_apply_lem_hyp doGenericServer_spec. break_and. find_rewrite. repeat match goal with | [ H : nwState ?net ?h = (_, ?d), H' : context [ log ?d ] |- _ ] => replace (log d) with (log (snd (nwState net h))) in H' by (repeat find_rewrite; auto) end. eauto using doGenericServer_preserves_candidateEntries. + eauto using doGenericServer_preserves_candidateEntries. - unfold candidateEntries_nw_invariant in *. intros. simpl in *. eapply candidateEntries_ext; eauto. find_apply_hyp_hyp. intuition. + eauto using doGenericServer_preserves_candidateEntries. + do_in_map. find_copy_apply_lem_hyp doGenericServer_spec. break_and. subst. simpl in *. find_apply_hyp_hyp. exfalso. find_rewrite. eauto 20. Qed. Lemma candidate_entries_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset CandidateEntries. Proof using. red. unfold CandidateEntries. intros. intuition. - unfold candidateEntries_host_invariant in *. intros. repeat find_reverse_higher_order_rewrite. apply candidateEntries_ext with (sigma := nwState net); eauto. - unfold candidateEntries_nw_invariant in *. intros. find_apply_hyp_hyp. eapply_prop_hyp In In; eauto. apply candidateEntries_ext with (sigma := nwState net); eauto. Qed. Lemma reboot_log_same : forall d, log (reboot d) = log d. Proof using. unfold reboot. auto. Qed. Lemma reboot_preservers_candidateEntries : forall net h d gd e, nwState net h = (gd, d) -> candidateEntries e (nwState net) -> candidateEntries e (update name_eq_dec (nwState net) h (gd, reboot d)). Proof using. unfold reboot, candidateEntries. intros. break_exists. exists x. break_and. rewrite update_fun_comm. simpl in *. update_destruct; subst; rewrite_update; auto. repeat find_rewrite. simpl in *. intuition. discriminate. Qed. Lemma candidate_entries_reboot : refined_raft_net_invariant_reboot CandidateEntries. Proof using. red. unfold CandidateEntries. intros. intuition. - unfold candidateEntries_host_invariant in *. intros. repeat find_higher_order_rewrite. eapply candidateEntries_ext; eauto. subst. find_rewrite_lem update_fun_comm. simpl in *. find_rewrite_lem update_fun_comm. simpl in *. update_destruct; subst; rewrite_update. + repeat match goal with | [ H : nwState ?net ?h = (_, ?d), H' : context [ log ?d ] |- _ ] => replace (log d) with (log (snd (nwState net h))) in H' by (repeat find_rewrite; auto) end. find_apply_hyp_hyp. eauto using reboot_preservers_candidateEntries. + eauto using reboot_preservers_candidateEntries. - unfold candidateEntries_nw_invariant in *. intros. repeat find_reverse_rewrite. eapply_prop_hyp In In; eauto. eapply candidateEntries_ext; eauto. eauto using reboot_preservers_candidateEntries. Qed. Lemma candidate_entries_init : refined_raft_net_invariant_init CandidateEntries. Proof using. red. unfold CandidateEntries. unfold candidateEntries_host_invariant, candidateEntries_nw_invariant. intuition; repeat match goal with | [ H : In _ _ |- _ ] => compute in H end; intuition. Qed. Theorem candidate_entries_invariant : forall (net : network), refined_raft_intermediate_reachable net -> CandidateEntries net. 
with (r - min - (max - r))%R; [ idtac | simpl in |- *; ring ]. apply Rle_minus; auto. exists max; split; auto. apply ClosestMax with (min := min); auto. replace (2%nat * r)%R with (r + r)%R; [ idtac | simpl in |- *; ring ]. apply Rminus_le; auto. replace (min + max - (r + r))%R with (max - r - (r - min))%R; [ idtac | simpl in |- *; ring ]. apply Rle_minus; auto. rewrite H'2; auto with real. case (Req_dec min max); intros H'5. right; intros q H'3. case (ClosestMinOrMax _ _ H'3); intros isM0. rewrite <- H'5. apply MinEq with (1 := isM0); auto. apply MaxEq with (1 := isM0); auto. left. apply FNevenEq with (f1 := FNSucc b radix precision min); auto. apply FcanonicBound with (radix := radix). apply FNSuccCanonic; auto with arith. case H'; auto. case H'0; auto. apply MaxEq with (b := b) (r := r); auto. apply MinMax; auto with arith. Contradict H'5; auto. fold FtoRradix in H'5; rewrite H'5 in H'2. replace (FtoRradix max) with (min + (max - min))%R; [ rewrite <- H'2 | idtac ]; ring. apply FNoddSuc; auto. case H'; auto. exists max; split; auto. apply ClosestMax with (min := min); auto. replace (2%nat * r)%R with (r + r)%R; [ idtac | simpl in |- *; ring ]. apply Rminus_le; auto. replace (min + max - (r + r))%R with (max - r - (r - min))%R; [ idtac | simpl in |- *; ring ]. apply Rle_minus; auto with real. right; intros q H'2. apply ClosestMaxEq with (r := r) (min := min); auto. replace (2%nat * r)%R with (r + r)%R; [ idtac | simpl in |- *; ring ]. apply Rminus_lt; auto. replace (min + max - (r + r))%R with (max - r - (r - min))%R; [ idtac | simpl in |- *; ring ]. apply Rlt_minus; auto. Qed. Theorem EvenClosestCompatible : CompatibleP b radix EvenClosest. red in |- *; simpl in |- *. intros r1 r2 p q H' H'0 H'1 H'2; red in |- *. inversion H'. split. apply (ClosestCompatible r1 r2 p q); auto. case H0; intros H1. left. apply FNevenEq with (f1 := p); auto. case H; auto. right; intros q0 H'3. unfold FtoRradix in |- *; rewrite <- H'1; auto. apply H1; auto. apply (ClosestCompatible r2 r1 q0 q0); auto. case H'3; auto. Qed. Theorem EvenClosestMinOrMax : MinOrMaxP b radix EvenClosest. 
with (y := plusA (plusA (multA a b) (multA (invA a) b)) (invA (multA a b))); auto. apply eqA_trans with (y := plusA (plusA (multA (invA a) b) (multA a b)) (invA (multA a b))); auto. apply eqA_trans with (y := plusA (multA (invA a) b) (plusA (multA a b) (invA (multA a b)))); auto. apply eqA_trans with (y := plusA (multA (invA a) b) A0); auto. apply plusA_eqA_comp with (1 := cs); auto. apply multA_dist_r. Qed. Hint Resolve multA_invA_com_l. Theorem multA_invA_com_r : forall a b : A, eqA (multA a (invA b)) (invA (multA a b)). intros a b; apply eqA_trans with (y := multA (invA b) a); auto. apply eqA_trans with (y := invA (multA b a)); auto. Qed. Hint Resolve multA_invA_com_r. Theorem divA_multA_comp_l : forall (a b c : A) (nZc : ~ eqA c A0), eqA (divA (multA a b) c nZc) (multA a (divA b c nZc)). intros a b c nZc; apply eqA_trans with (y := divA (multA b a) c nZc); auto. apply eqA_trans with (y := multA (divA b c nZc) a); auto. apply divA_multA_comp_r with (1 := cs); auto. Qed. Hint Resolve divA_multA_comp_l. Theorem invA_is_invA1 : forall a : A, eqA (invA a) (multA (invA A1) a). intros a; apply eqA_trans with (y := plusA (invA a) A0); auto. apply eqA_trans with (y := plusA (invA a) (multA A0 a)); auto. apply eqA_trans with (y := plusA (invA a) (multA (plusA A1 (invA A1)) a)); auto. apply eqA_trans with (y := plusA (invA a) (plusA (multA A1 a) (multA (invA A1) a))); auto. apply plusA_eqA_comp with (1 := cs); auto. apply eqA_sym; auto. apply multA_dist_r. apply eqA_trans with (y := plusA (invA a) (plusA a (multA (invA A1) a))); auto. apply eqA_trans with (y := plusA (plusA (invA a) a) (multA (invA A1) a)); auto. apply eqA_trans with (y := plusA (plusA a (invA a)) (multA (invA A1) a)); auto. apply eqA_trans with (y := plusA A0 (multA (invA A1) a)); auto. apply eqA_trans with (y := plusA (multA (invA A1) a) A0); auto. Qed. Theorem divA_A0_l : forall (a : A) (nZa : ~ eqA a A0), eqA (divA A0 a nZa) A0. intros a nZa; apply eqA_trans with (y := divA (multA A0 a) a nZa). apply divA_eqA_comp with (1 := cs); auto. apply eqA_trans with (y := multA A0 (divA a a nZa)); auto. Qed. Hint Resolve divA_A0_l. Theorem A_sep : forall a b : A, eqA (multA a b) A0 -> eqA a A0 \/ eqA b A0. 
Z.add_assoc in H7. split; chunk_red; omega. + econstructor; eauto. unfold int_size in *; simpl size_chunk in *. apply IHvs. rewrite <- Hi4. simpl length in H. rewrite Nat2Z.inj_succ in H. assert (0 <= Ptrofs.unsigned i)%Z by apply Ptrofs.unsigned_range. assert (0 <= Z.of_nat (length vs))%Z by apply Zle_0_nat. inv H. rewrite Z.mul_succ_l in H6. rewrite Z.add_assoc in H6. split; chunk_red; omega. rewrite <- Hi4. auto. Qed. Inductive repr_val_id_L_L6_L7: L6.cps.val -> mem -> locProp -> temp_env -> positive -> Prop := | RVid_F: forall b f lenv fds L m, Genv.find_symbol (Genv.globalenv p) f = Some b -> repr_val_L_L6_L7 (cps.Vfun (M.empty cps.val) fds f) m L (Vptr b (Ptrofs.zero)) -> repr_val_id_L_L6_L7 (cps.Vfun (M.empty cps.val) fds f) m L lenv f | RVid_V: forall x m lenv L v6 v7, Genv.find_symbol (Genv.globalenv p) x = None -> M.get x lenv = Some v7 -> repr_val_L_L6_L7 v6 m L v7 -> repr_val_id_L_L6_L7 v6 m L lenv x. Theorem repr_val_id_L_L6_L7_vint_or_vptr: forall v6 m L v7, repr_val_L_L6_L7 v6 m L v7 -> Vint_or_Vptr v7 = true. Proof. intros; inv H; auto. Qed.Theorem repr_val_id_L_L6_L7_ptr: forall v6 m L lenv x, repr_val_id_L_L6_L7 v6 m L lenv x -> exists v7, repr_val_L_L6_L7 v6 m L v7 /\ ((M.get x lenv = Some v7 /\ Genv.find_symbol (Genv.globalenv p) x = None) \/ (exists b, v7 = Vptr b Ptrofs.zero /\ Genv.find_symbol (Genv.globalenv p) x = Some b)). Proof. intros. inv H. - exists (Vptr b (Ptrofs.zero)). split; auto. right. exists b; auto. - exists v7. split; auto. Qed. Theorem get_var_or_funvar_eval: forall lenv a v m, find_symbol_domain finfo_env -> finfo_env_correct -> get_var_or_funvar lenv a v -> eval_expr (globalenv p) empty_env lenv m (var_or_funvar_f a) v. Proof. intros. specialize (H a). inv H. unfold var_or_funvar_f. inv H1. - rewrite H. destruct (H3 (ex_intro _ b H)). unfold makeVar. rewrite H1. destruct x. specialize (H0 _ _ f H1). destruct H0. destruct x. rewrite H0. econstructor. constructor 2. apply M.gempty. eauto. constructor. auto. - rewrite H. constructor. auto. Qed.Theorem get_var_or_funvar_semcast: forall v a m lenv, find_symbol_domain finfo_env -> finfo_env_correct -> get_var_or_funvar lenv a v -> sem_cast v (typeof (var_or_funvar_f a)) uval m = Some v. Proof. intros. unfold var_or_funvar_f. specialize (H a). inv H. inv H1. - rewrite H. destruct (H3 (ex_intro _ b H)). unfold makeVar. rewrite H1. destruct x. specialize (H0 _ _ f H1). destruct H0. destruct x. rewrite H0. constructor. - rewrite H. destruct v; inv H5; auto. Qed. Theorem repr_val_id_implies_var_or_funvar: forall v6 m L lenv x, repr_val_id_L_L6_L7 v6 m L lenv x -> exists v7, get_var_or_funvar lenv x v7 /\ repr_val_L_L6_L7 v6 m L v7. 
unfold inv_typ in |- *; clear INVTYP; intros). Lemma typ_free_db : forall (e : env) (t T : term), typ e t T -> free_db (length e) t. Proof. simple induction 1; intros; auto with pts. inversion_clear H1. constructor. elim H3; simpl in |- *; auto with arith.constructor; trivial. inversion_clear H1; trivial. Qed. Lemma wft_free_db : forall (e : env) (t : term), wf_type e t -> free_db (length e) t. simple destruct 1; try constructor; intros. apply typ_free_db with (1 := H0). Qed. Hint Resolve wft_free_db: pts. Theorem typ_weak : forall (g : env) (d : decl) (e : env) (t T : term), typ e t T -> forall (n : nat) (f : env), ins_in_env g d n e f -> wf f -> typ f (lift_rec 1 t n) (lift_rec 1 T n). simple induction 1; simpl in |- *; intros; auto with arith pts. elim (le_gt_dec n v); intros; apply type_var; auto with arith pts. elim H1; intros. rewrite H4. unfold lift in |- *. rewrite simpl_lift_rec; simpl in |- *; auto with arith pts. exists x; auto with arith pts. apply ins_item_ge with (1 := H2); auto with arith pts.apply ins_item_lift_lt with (1 := H2); auto with arith pts.cut (wf (Ax (lift_rec 1 T0 n) :: f)). intro. apply type_abs with s; auto with arith pts. fold (lift_decl 1 (Ax T0) n) in |- *; auto with arith pts.Inversion_typ (H1 _ _ H4 H5). apply wf_var with s1; auto with arith pts.rewrite distr_lift_subst. apply type_app with (lift_rec 1 V n); auto with arith pts.cut (wf (Ax (lift_rec 1 T0 n) :: f)). intro. apply type_prod with s1 s2; auto with arith pts. fold (lift_decl 1 (Ax T0) n) in |- *; auto with arith pts.apply wf_var with s1; auto with arith pts.apply type_conv with (lift_rec 1 U n) s; auto with arith pts. apply le_type_lift with (2 := H5); trivial with arith pts.apply type_conv_srt with (lift_rec 1 U n); auto with arith pts. fold (lift_rec 1 (Srt s) n) in |- *. apply le_type_lift with (2 := H3); auto with arith pts. Qed. Theorem thinning : forall (e : env) (t T : term) (d : decl), typ e t T -> wf (d :: e) -> typ (d :: e) (lift 1 t) (lift 1 T). unfold lift in |- *. intros. apply typ_weak with e d e; auto with arith pts. Qed. Theorem thinning_n : forall (n : nat) (e f : env), trunc n e f -> forall t T : term, typ f t T -> wf e -> typ e (lift n t) (lift n T). 
Z := (2^64 - num_readers n). Definition remaining_frac (n: u64) := ((Qp_of_Z (remaining_readers n)) * rfrac)%Qp. Lemma remaining_frac_read_acquire n : 1 ≤ int.Z n → int.Z n < int.Z (word.add n 1) → remaining_frac n = Qp.add (remaining_frac (word.add n 1)) rfrac. Proof. intros Hle1 Hle2. intros. rewrite -Qp.to_Qc_inj_iff/Qp_of_Z//=. assert (Heq1: Qc_of_Z (1 `max` remaining_readers n) = Qc_of_Z (remaining_readers n)). { f_equal. rewrite /remaining_readers. rewrite Z.max_r //. rewrite /num_readers. word_cleanup. } assert (Heq2: Qc_of_Z (1 `max` remaining_readers (word.add n 1)) = Qc_of_Z (remaining_readers (word.add n 1))). { f_equal. rewrite /remaining_readers. rewrite Z.max_r //. rewrite /num_readers. word_cleanup. } rewrite ?Heq1 ?Heq2. assert (Heq3: (remaining_readers (word.add n 1)) = remaining_readers n - 1). { rewrite /remaining_readers/num_readers. word_cleanup. assert ((int.Z (word.add n 1) - 1) = int.Z n) as ->. { word_cleanup. } lia. } rewrite Heq3 //=. rewrite Z2Qc_inj_sub. field_simplify => //=. f_equal. rewrite Z2Qc_inj_1. field. Qed. Lemma remaining_frac_read_release n : 1 < int.Z n → Qp.add (remaining_frac n) rfrac = remaining_frac (word.sub n 1). Proof. intros Hlt. rewrite -Qp.to_Qc_inj_iff/Qp_of_Z//=. assert (Heq1: Qc_of_Z (1 `max` remaining_readers n) = Qc_of_Z (remaining_readers n)). { f_equal. rewrite /remaining_readers. rewrite Z.max_r //. rewrite /num_readers. word_cleanup. } assert (Heq2: Qc_of_Z (1 `max` remaining_readers (word.sub n 1)) = Qc_of_Z (remaining_readers (word.sub n 1))). { f_equal. rewrite /remaining_readers. rewrite Z.max_r //. rewrite /num_readers. word_cleanup. } rewrite ?Heq1 ?Heq2. assert (Heq3: (remaining_readers (word.sub n 1)) = remaining_readers n + 1). { rewrite /remaining_readers/num_readers. word_cleanup. } rewrite Heq3 //=. rewrite Z2Qc_inj_add. field_simplify => //=. Qed. Lemma remaining_free : remaining_frac 1 = 1%Qp. Proof. rewrite -Qp.to_Qc_inj_iff/Qp_of_Z//=. assert (Heq1: Qc_of_Z (1 `max` remaining_readers 1) = Qc_of_Z (remaining_readers 1)). { f_equal. } rewrite Heq1 //=. field_simplify => //=. rewrite Z2Qc_inj_1. auto. Qed. Definition rwlock_inv (l : loc) (R: Qp → iProp Σ) : iProp Σ := (∃ u : u64, l ↦{1/4} #u ∗ if decide (u = U64 0) then True else l ↦{3/4} #u ∗ R (remaining_frac u)). Definition is_rwlock (lk : val) R : iProp Σ := □ (∀ q1 q2, ▷ R (q1 + q2)%Qp -∗ post_expr  (R q1 ∗ R q2)) ∗ □ (∀ q1 q2, ▷ R q1 -∗ ▷ R q2 -∗ post_expr  (R (q1 + q2)%Qp)) ∗ (∃ l: loc, ⌜lk = #l⌝ ∧ inv N (rwlock_inv l R))%I. Theorem is_rwlock_flat lk R : is_rwlock lk R -∗ ⌜∃ (l:loc), lk = #l⌝. Proof. iIntros "(_&_&Hl)"; iDestruct "Hl" as (l) "[-> _]"; eauto. Qed. Theorem is_rwlock_ty lk R : is_rwlock lk R -∗ ⌜val_ty lk rwlockRefT⌝. 
& H4 & H5 & H7). inversion H1; subst x y; clear H1. msplit 2; intros. + rewrite H2, H4; auto. + rewrite H3, H5; auto. + destruct H6; subst; auto. Qed. Local Fact HK4 u : U u -> forall x, K u x -> x = ⦳. Proof. intros Hu; intro pair as x y; unfold K; simpl. intros (_ & _ & H); destruct H; subst; auto. Qed. Local Fact HKa x y : K a (x##y##vec_nil) <-> y = 0. Proof using sem Hba Ha. split; unfold K; simpl. + intros []; auto. + intros ->; msplit 2; auto; intros; tauto. Qed. Local Fact HKb x y : K b (x##y##vec_nil) <-> x = 0. Proof using sem Hb Hab. split; unfold K; simpl. + intros (? & ? & ?); auto. + intros ->; msplit 2; auto; tauto. Qed. Local Fact HKi : forall x, K ∞ x -> x = ⦳. Proof using Hbi Hai. intro pair as x y; unfold K; simpl. intros (H1 & H2 & ?); rewrite H1, H2; auto. Qed. Local Lemma sem_Σ c : c ∊ Σ -> ⟦⟬ c⟭⟧ ⦳. Proof using Hba Hb Hab Ha. intros H. destruct c as [ p | [] p q | [] p q | [] p q ]; simpl; apply imsell_tps_imp_zero; intro pair as x y; simpl; intros H1. + specialize (H1 ⦳); rewrite vec_zero_plus in H1. apply H1; constructor; auto. + constructor 2 with (1 := H). apply (H1 (1##0##vec_nil)). simpl; rewrite HKa; auto. + constructor 3 with (1 := H). apply (H1 (0##1##vec_nil)); auto. simpl; rewrite HKb; auto. + destruct H1 as ((-> & ->) & _); simpl. intro pair as x y; simpl; rewrite (plus_comm x), (plus_comm y). constructor 4 with q; auto. + destruct H1 as ((-> & ->) & _); simpl. intro pair as x y; simpl; rewrite (plus_comm x), (plus_comm y). constructor 5 with q; auto. + rewrite HKb in H1. destruct H1 as (H1 & ->). constructor 6 with q; auto. + rewrite HKa in H1. destruct H1 as (H1 & ->). constructor 7 with q; auto. Qed. Hint Resolve HK1 HK2 HK3 HK4 HKa HKb HKi sem_Σ : core. Local Fact sem_Σ_zero : ⟪map (fun c => ![∞]⟬ c⟭) Σ⟫ ⦳. Proof using Hba Hb Hab Ha. apply imsell_tps_list_zero. intros A; rewrite in_map_iff. intros (c & <- & Hc); simpl; auto. Qed. Theorem ndmm2_imsell_complete p x y : ⟬Σ,x,y⟭ ⊢ ⌊p⌋ -> Σ //ₙ x ⊕ y ⊦ p. 
canonical_Rminus; auto. apply canonical_imp_canonical with (a := a); auto. apply canonical_imp_canonical with (a := a0); auto. change (canonical A0 eqA ltM (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) (pX b q))) in |- *; auto. Qed. Theorem Rminus_is_reduceplus : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (q : list (Term A n)) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), canonical A0 eqA ltM q -> inPolySet A A0 eqA n ltM (pX a q) Q -> forall r : list (Term A n), canonical A0 eqA ltM r -> divPp a r -> forall p : list (Term A n), canonical A0 eqA ltM p -> incl r p -> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (Rminus a nZa p (pX a q) r). intros Q a q nZa Op0 in0 r; elim r; clear r. simpl in |- *; intros H' H'0 p H'1 H'2; auto. apply Rstar_0; auto. intros a0 r1 Rec Op1 divp0 p Op2 incl0. cut (canonical A0 eqA ltM r1); [ intros Cr1 | apply canonical_imp_canonical with (a := a0); auto ]. cut (canonical A0 eqA ltM (pX a q)); [ intros Caq | apply inPolySet_imp_canonical with (L := Q); auto ]. elim divp0; intros H' H'0; clear divp0. apply reduceplus_trans with (1 := cs) (y := Rminus a nZa p (pX a q) r1); auto. apply Rec; auto. red in |- *; intros p' H; apply incl0; auto with datatypes. apply reduceplus_eqp_com with (1 := cs) (p := Rminus a nZa p (pX a q) r1) (q := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (Rminus a nZa p (pX a q) r1) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a0 (b:=a) nZa) (pX a q))); auto. apply reduce_imp_reduceplus with (1 := cs); auto. apply minus_is_reduce; auto. apply Rminus_in; auto with datatypes. Qed. Definition Dmult : forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), list (Term A n) -> list (Term A n) -> list (Term A n). intros a nZa p q; elim p; clear p. exact (pO A n). intros a1 p1 rec; exact (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (divpf a nZa (mults (A:=A) multA (n:=n) a1 q)) rec). Defined. Theorem canonical_Dmult : forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM (Dmult a nZa p q). 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Poly.Theorem silly1 : forall (n m o p : nat), n = m -> [n;o] = [n;p] -> [n;o] = [m;p]. Admitted. Theorem silly2 : forall (n m o p : nat), n = m -> (forall (q r : nat), q = r -> [q;o] = [r;p]) -> [n;o] = [m;p]. Admitted. Theorem silly3_firsttry : forall (n : nat), n = 5 -> beq_nat (S (S n)) 7 = true. Admitted. QuickChick silly3_firsttry. *) Theorem rev_exercise1 : forall (l l' : list nat), l = rev l' -> l' = rev l. Admitted. QuickChick rev_exercise1. *)Theorem trans_eq : forall (X:Type) (n m o : X), n = m -> m = o -> n = o. Admitted. QuickChick trans_eq. *)Example trans_eq_example' : forall (a b c d e f : nat), [a;b] = [c;d] -> [c;d] = [e;f] -> [a;b] = [e;f]. Admitted. Example trans_eq_exercise : forall (n m o p : nat), m = (minustwo o) -> (n + p) = m -> (n + p) = (minustwo o). Admitted. Theorem S_injective : forall (n m : nat), S n = S m -> n = m. Admitted. Theorem beq_nat_0_l : forall n, 0 = n -> n = 0. Admitted. QuickChick beq_nat_0_l. *)Theorem inversion_ex4 : forall (n : nat), S n = O -> 2 + 2 = 5. Admitted. Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A), x = y -> f x = f y. Admitted. Theorem plus_n_n_injective : forall n m, n + n = m + m -> n = m. 
Require Import Prog. Require Import AsyncDisk. Require Import Hashmap. Require Import Word. Require Import FSLayout. Require Import BasicProg. Require Import Cache. Require Import Pred. Require Import PredCrash. Require Import Hoare. Require Import Mem. Require Import SepAuto. Require Import List. Require Import Array. Require Import EqdepFacts. Require Import Arith. Require Import ListUtils. Require Import Omega.Set Implicit Arguments. Definition hash_list h values := let^ (hash) <- ForEach item items_rest values Hashmap hm' Ghost [ l crash ] Loopvar [ hash ] Invariant exists items_prefix, [[ values = items_prefix ++ items_rest ]] * [[ hash_list_rep (rev items_prefix ++ l) hash hm' ]] OnCrash crash Begin hash <- Hash2 item hash; Ret ^(hash) Rof ^(h); Ret hash. Theorem hash_list_ok : forall h values, {< l, PRE:hm emp * [[ hash_list_rep l h hm ]] POST:hm' RET:h' emp * [[ hash_list_rep (rev values ++ l) h' hm' ]] CRASH:hm' emp * [[ exists i hash, hash_list_rep (rev (firstn i values) ++ l) hash hm' ]] >} hash_list h values. 
: FunctionCostModel)(cm : CompCostModel) : OC_CostModel := | oc_cost_Query : forall (A B : Set)(a : A), oc_cost fm cm (OC_Query B a) (fun n => n) | oc_cost_Run : forall (A B C : Set)(c : OracleComp A B C) f1, oc_cost fm cm c f1 -> forall (A' B' S : Set)(eqds : EqDec S)(eqdb : EqDec B)(eqda : EqDec A) (o : S -> A -> OracleComp A' B' (B * S)) x1 x2 f2, fm _ _ o x1 -> (forall x, fm _ _ (o x) x2) -> (forall x y, oc_cost fm cm (o x y) f2) -> forall s, oc_cost fm cm (OC_Run _ _ _ c o s) (fun n => f1 (x1 + x2 + (f2 n))) | oc_cost_Ret : forall (A B C : Set)(c : Comp C) n, cm _ c n -> oc_cost fm cm (OC_Ret A B c) (fun _ => n) | oc_cost_Bind : forall (A B C C' : Set)(c : OracleComp A B C)(f : C -> OracleComp A B C') f1 x f2, oc_cost fm cm c f1 -> fm _ _ f x-> (forall y, oc_cost fm cm (f y) f2) -> oc_cost fm cm (OC_Bind c f) (fun n => (f1 n) + x + (f2 n)) | oc_cost_le : forall (A B C : Set)(c : OracleComp A B C) f1 f2, oc_cost fm cm c f1 -> (forall x, f1 x <= f2 x) -> oc_cost fm cm c f2.Section CostTheory. Context `{function_cost_model}. Theorem cost_compose_unary : forall (A B C: Type) (f1 : A -> B)(f2 : B ->C) c1 c2, cost f1 c1 -> cost f2 c2 -> cost (fun a => f2 (f1 a)) (c1 + c2). intuition. eapply cost_le. eapply (cost_compose f1 _ ). eauto. intuition. eapply cost_const. intuition. eauto. omega. Qed. Theorem cost_compose_binary : forall (A B C D: Type) (f1 : A -> B)(f2 : A ->C)(f3 : B -> C -> D) c1 c2 c3 c4, cost f1 c1 -> cost f2 c2 -> cost f3 c3 -> (forall a, cost (f3 a) c4) -> cost (fun a => f3 (f1 a) (f2 a)) (c1 + c2 + c3 + c4). intuition. eapply cost_le. eapply (cost_compose f2 (fun a x => f3 (f1 a) x)). eauto. intuition. eapply (cost_compose f1 (fun a => f3)). eauto. intuition. eapply cost_const. intuition. eauto. intuition. omega. Qed. Theorem cost_pair_1 : forall (A B : Type), cost (@pair A B) 0. 
Require Import Setoid Program. Require Import VST.concurrency.paco.src.paco. CoInductive stream := | cons : nat -> stream -> stream. Definition sunf s := match s with cons n s' => cons n s' end.Lemma sunf_eq : forall s, s = sunf s. Proof. destruct s; auto. Qed. CoFixpoint enumerate n : stream := cons n (enumerate (S n)).CoFixpoint map f s : stream := match s with cons n s' => cons (f n) (map f s') end. Inductive seq_gen seq : stream -> stream -> Prop := | _seq_gen : forall n s1 s2 (R : seq s1 s2 : Prop), seq_gen seq (cons n s1) (cons n s2). Hint Constructors seq_gen.CoInductive seq : stream -> stream -> Prop := | seq_fold : forall s1 s2, seq_gen seq s1 s2 -> seq s1 s2. Theorem example : forall n, seq (enumerate n) (cons n (map S (enumerate n))). Proof. cofix CIH. intros; apply seq_fold. pattern (enumerate n) at 1; rewrite sunf_eq; simpl. constructor. rewrite (sunf_eq (enumerate n)); simpl. rewrite (sunf_eq (map _ _)); simpl. apply CIH. Qed.Definition seq' s1 s2 := paco2 seq_gen bot2 s1 s2. Hint Unfold seq'. Lemma seq_gen_mon: monotone2 seq_gen. Proof. pmonauto. Qed. Hint Resolve seq_gen_mon : paco.Theorem example' : forall n, seq' (enumerate n) (cons n (map S (enumerate n))). Proof. pcofix CIH. intros; pfold. rewrite sunf_eq at 1; simpl. constructor. rewrite (sunf_eq (enumerate n)); simpl. rewrite (sunf_eq (map _ _)); simpl. right; apply CIH. Qed. Theorem seq_cons : forall n1 n2 s1 s2 (SEQ : seq (cons n1 s1) (cons n2 s2)), n1 = n2 /\ seq s1 s2. 
f l Hole_c fds_c)). Proof. intros. induction fds. - simpl. rewrite IHfds. auto. - simpl. reflexivity. Qed. Theorem rename_all_fundefs_ctx_append: forall sig fdc fds, rename_all_fun_ctx_ns sig (fundefs_ctx_append fds fdc) = fundefs_ctx_append (rename_all_fun_ns sig fds) (rename_all_fun_ctx_ns sig fdc). Proof. induction fds; auto. simpl. rewrite IHfds. auto. Qed. Theorem app_f_ctx_fundefs_ctx_append: forall fdc e fds, fundefs_ctx_append fds fdc <[ e ]> = fundefs_append fds (fdc <[e]>). Proof. induction fds; auto. simpl; rewrite IHfds. auto. Qed. Theorem bound_var_fundefs_ctx_append_f: forall im fdc, Included _ (names_in_fundefs_ctx fdc) (bound_var_fundefs_ctx (inlined_fundefs_ctx_f fdc im)). Proof. induction fdc. - simpl. normalize_bound_var_ctx. intro. intro. inv H; auto. apply name_in_fundefs_bound_var_fundefs in H0. auto. - simpl. normalize_bound_var_ctx. intro; intro. inv H; auto. Qed. Theorem name_in_fundefs_ctx_append: forall fdc fds, Same_set _ (names_in_fundefs_ctx (fundefs_ctx_append fds fdc)) (Union _ (name_in_fundefs fds) (names_in_fundefs_ctx fdc)). Proof. induction fds. - simpl. rewrite IHfds; auto with Ensembles_DB. - simpl. auto with Ensembles_DB. Qed. Theorem bound_var_fundefs_ctx_append: forall fdc fds, Same_set _ (bound_var_fundefs_ctx (fundefs_ctx_append fds fdc)) (Union _ (bound_var_fundefs fds) (bound_var_fundefs_ctx fdc)). Proof. induction fds; simpl; normalize_bound_var; try normalize_bound_var_ctx; eauto with Ensembles_DB. rewrite IHfds. eauto with Ensembles_DB. Qed. Theorem name_in_fundefs_not_inlined: forall f im fds, get_b f im = false -> (name_in_fundefs fds f <-> name_in_fundefs (inlined_fundefs_f fds im) f). Proof. induction fds; simpl; intros. 2: split; intro; auto. destruct (var_dec v f). - subst. rewrite H. simpl. split; intro. left; auto. left; auto. - split. intro. inv H0. exfalso. apply n. inv H1. auto. apply IHfds in H1; auto. destruct (get_b v im); auto. constructor 2. auto. intro. right. apply IHfds; auto. destruct (get_b v im). auto. inv H0. exfalso; apply n; inv H1; auto. auto. Qed. Theorem Included_name_in_fundefs_inlined: forall im fds, Included _ (name_in_fundefs (inlined_fundefs_f fds im)) (name_in_fundefs fds). Proof. induction fds; eauto with Ensembles_DB. simpl. destruct (get_b v im); simpl; auto with Ensembles_DB. Qed. Theorem name_in_fundefs_not_inlined': forall f fds im, name_in_fundefs fds f -> get_b f im = false -> bound_var_fundefs (inlined_fundefs_f fds im) f. Proof. induction fds; simpl; intros. - inv H. inv H1. rewrite H0. apply bound_var_fundefs_Fcons. auto. specialize (IHfds _ H1 H0). destruct (get_b v im); eauto with Ensembles_DB. - inv H. Qed. Theorem fundefs_ctx_append_num_occur: forall B1 B2, forall (x : var) (n m : nat), num_occur_fds B1 x n -> num_occur_fdc B2 x m -> num_occur_fdc (fundefs_ctx_append B1 B2) x (n + m). Proof. induction B1; intros. - simpl in H. inv H. simpl. eapply num_occur_fdc_n. constructor. eauto. apply IHB1; eauto. lia. - inv H. auto. Qed. Theorem fundefs_ctx_append_num_occur': forall (B1: fundefs) B2 (nm : nat) (x : var), num_occur_fdc (fundefs_ctx_append B1 B2) x nm -> exists n m : nat, num_occur_fds B1 x n /\ num_occur_fdc B2 x m /\ n + m = nm. 
*; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_exists_intro: forall A (a: A) (P: A -> Assertion) state, P a state -> (\exists a, P a) state. Proof. intros; hnf; eauto. Qed. Theorem state_exists_inversion: forall X (P: X -> Assertion) state, (\exists x, P x) state -> exists x, P x state. Proof. intros ??? A; hnf in A; eauto. Qed. Theorem state_forall_intro: forall A (P: A -> Assertion) state, (forall a, P a state) -> (state_forall P) state. Proof. intros; hnf; assumption. Qed. Theorem state_forall_inversion: forall A (P: A -> Assertion) state, (state_forall P) state -> forall a, P a state. Proof. intros; hnf; trivial. Qed. Theorem state_implies_forall_r: forall A (P: A -> Assertion) H, (forall a, H **> P a) -> H **> (state_forall P). Proof. intros ??? M ???; apply M; assumption. Qed. Theorem state_implies_forall_l: forall A a (P: A -> Assertion) H, (P a **> H) -> (state_forall P) **> H. Proof. intros ???? M ??; apply M; trivial. Qed. Theorem state_forall_specialize: forall A a (P: A -> Assertion), (state_forall P) **> (P a). Proof. intros; apply (state_implies_forall_l a); auto. Qed. Theorem state_wand_equiv: forall H0 H1 H2, (H0 **> H1 \-* H2) <-> (H1 \* H0 **> H2). Proof. unfold state_wand. iff M. { rewrite state_star_comm. applys state_implies_state_star_trans_l (rm M). rewrite state_star_state_exists. applys state_implies_state_exists_l. intros H. rewrite (state_star_comm H). rewrite state_star_assoc. rewrite (state_star_comm H H1). applys~ state_implies_state_star_state_pure_l. } { applys state_implies_state_exists_r H0. rewrite <- (state_star_hempty_r H0) at 1. applys state_implies_frame_r. applys state_implies_hempty_state_pure M. } Qed. Theorem state_implies_state_wand_r: forall H1 H2 H3, H2 \* H1 **> H3 -> H1 **> (H2 \-* H3). Proof. introv M. rewrite~ state_wand_equiv. Qed. Theorem state_implies_state_wand_r_inv: forall H1 H2 H3, H1 **> (H2 \-* H3) -> H2 \* H1 **> H3. Proof. introv M. rewrite~ <- state_wand_equiv. Qed. Theorem state_wand_cancel: forall H1 H2, H1 \* (H1 \-* H2) **> H2. Proof. intros. applys state_implies_state_wand_r_inv. applys state_implies_refl. Qed. Arguments state_wand_cancel: clear implicits. Theorem state_implies_hempty_state_wand_same: forall H, \[] **> (H \-* H). Proof. intros. apply state_implies_state_wand_r. rewrite~ state_star_hempty_r. Qed. Theorem state_wand_hempty_l: forall H, (\[] \-* H) = H. Proof. intros. applys state_implies_antisym. { rewrite <- state_star_hempty_l at 1. applys state_wand_cancel. } { rewrite state_wand_equiv. rewrite~ state_star_hempty_l. } Qed. Theorem state_wand_state_pure_l: forall P H, P -> (\[P] \-* H) = H. Proof. introv HP. applys state_implies_antisym. { lets K: state_wand_cancel \[P] H. applys state_implies_trans K. applys* state_implies_state_star_state_pure_r. } { rewrite state_wand_equiv. applys* state_implies_state_star_state_pure_l. } Qed. Theorem state_wand_curry: forall H1 H2 H3, (H1 \* H2) \-* H3 **> H1 \-* (H2 \-* H3). 
multA (n:=n) (T1 A1 n) a0); auto. apply (eqTerm_imp_eqT A eqA n); auto. apply nzeroP_comp_eqTerm with (1 := cs) (a := invTerm (A:=A) invA (n:=n) a); auto. apply nZero_invTerm_nZero with (1 := cs); auto. apply canonical_nzeroP with (ltM := ltM) (p := p0); auto. rewrite pX_invl with (1 := H'3); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n))) a0); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply mult_invTerm_com with (1 := cs); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (multTerm (A:=A) multA (n:=n) (T1 A1 n) a0); apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. rewrite H'3; change (canonical A0 eqA ltM (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (pX a0 l))) in |- *; auto. Qed. Theorem reduce_mults_invr : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce Q (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p) q -> canonical A0 eqA ltM p -> reduce Q p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q). intros Q p q H' H'0. apply reduce_mults_inv_lem with (p := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p); auto. Qed. Definition irreducible (Q : list (poly A0 eqA ltM)) (p : list (Term A n)) := forall q : list (Term A n), ~ reduce Q p q. Lemma irreducible_inv_px_l : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)), canonical A0 eqA ltM (pX a p) -> irreducible Q (pX a p) -> irreducible Q (pX a (pO A n)). unfold irreducible in |- *. intros Q a p H' H'0 q; red in |- *; intros H'1. inversion_clear H'1. apply H'0 with (q := spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q0); auto. inversion_clear H; auto. Qed. Lemma pO_irreducible : forall Q : list (poly A0 eqA ltM), irreducible Q (pO A n). unfold irreducible in |- *; auto. intros Q q; red in |- *; intros H'; inversion H'. Qed. Hint Resolve pO_irreducible. Theorem irreducible_eqp_com : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), irreducible Q p -> canonical A0 eqA ltM p -> eqP A eqA n p q -> irreducible Q q. 
: forall (xs : list (Bool @# type)) a, fold_left andb (map (@evalExpr _) xs) a = true <-> Forall utila_is_true xs /\ a = true. Proof. induction xs; simpl; auto; split; intros; auto. - tauto. - rewrite IHxs in H. rewrite andb_true_iff in H. split; try tauto. constructor; simpl; tauto. - dest. inv H. unfold utila_is_true in *; simpl in *. pose proof (conj H4 H3). rewrite <- IHxs in H. auto. Qed. Theorem fold_left_andb_forall : forall xs : list (Bool @# type), fold_left andb (map (@evalExpr _) xs) true = true <-> Forall utila_is_true xs. Proof. intros. rewrite fold_left_andb_forall'. tauto. Qed. Theorem utila_all_correct : forall xs : list (Bool @# type), utila_all xs ==> true <-> Forall utila_is_true xs. Proof. apply fold_left_andb_forall. Qed. Theorem fold_left_andb_forall_false' : forall (xs : list (Bool @# type)) a, fold_left andb (map (@evalExpr _) xs) a = false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs \/ a = false. Proof. induction xs; simpl; auto; intros; split; try tauto. - intros; auto. destruct H; auto. inv H. - rewrite IHxs. intros. rewrite andb_false_iff in H. destruct H. + left. right; auto. + destruct H. * auto. * left. left. auto. - intros. rewrite IHxs. rewrite andb_false_iff. destruct H. + inv H; auto. + auto. Qed. Theorem fold_left_andb_forall_false : forall xs : list (Bool @# type), fold_left andb (map (@evalExpr _) xs) true = false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. Proof. intros. rewrite fold_left_andb_forall_false'. split; intros. - destruct H; congruence. - auto. Qed. Theorem utila_all_correct_false : forall xs : list (Bool @# type), utila_all xs ==> false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. Proof. apply fold_left_andb_forall_false. Qed. Theorem fold_left_orb_exists' : forall (xs : list (Bool @# type)) a, fold_left orb (map (@evalExpr _) xs) a = true <-> Exists utila_is_true xs \/ a = true. Proof. induction xs; simpl; auto; split; intros; try discriminate. - auto. - destruct H; auto. inv H. - rewrite IHxs in H. rewrite orb_true_iff in H. destruct H. + left. right. auto. + destruct H; auto. - assert (sth: Exists utila_is_true xs \/ (a0||evalExpr a)%bool = true). { destruct H. - inv H. + right. rewrite orb_true_iff. auto. + auto. - right. rewrite orb_true_iff. auto. } rewrite <- IHxs in sth. auto. Qed. Theorem fold_left_orb_exists : forall xs : list (Bool @# type), fold_left orb (map (@evalExpr _) xs) false = true <-> Exists utila_is_true xs. 
destruct (E0_eq_dec alpha E0zero). - subst alpha; intro k; rewrite H'_eq1; cbn;auto with arith. - intro k;unfold id; now apply Nat.lt_le_incl, H'_alpha_gt. Qed. Lemma H'_alpha_mono_weak : forall k l, k <= l -> H'_ alpha k <= H'_ alpha l. Proof. intros. destruct (Lt.le_lt_or_eq k l H). - now apply Nat.lt_le_incl, H'_alpha_mono. - subst; auto. Qed.End Abstract_Properties. Lemma H'_mono_l_0 alpha beta : alpha o< beta -> {n : nat | forall p, n <= p -> H'_ alpha (S p) <= H'_ beta (S p)}. Proof. intro H; destruct (Lemma2_6_1_E0 H) as [n Hn]. exists (S n). intros; apply H'_restricted_mono_l. eapply Cor12_E0 with n; eauto. lia. Qed.Lemma H'_mono_l_1 alpha beta : alpha o<= beta -> {n : nat | forall p, n <= p -> H'_ alpha (S p) <= H'_ beta (S p)}. Proof. intro H; destruct (le_lt_eq_dec H). - now apply H'_mono_l_0. -subst; exists 0; auto with arith. Qed.Section Proof_of_H'_mono_l. Variables alpha beta: E0. Hypothesis H_alpha_beta: alpha o< beta. Section Succ_case. Variable gamma: E0. Hypothesis Hgamma : beta = E0succ gamma. Remark R1 : alpha o<= gamma. Proof. subst; now apply lt_Succ_le_2. Qed. Remark R2 : {n : nat | forall p, n <= p -> H'_ alpha (S p) <= H'_ gamma (S p)}. Proof. apply H'_mono_l_1, R1. Qed. Remark R3 : {n: nat | forall p, n <= p -> H'_ alpha (S p) < H'_ beta (S p)}. Proof. destruct R2 as [n Hn]; exists (Max.max n 1). intros p H; apply Nat.le_lt_trans with (H'_ gamma (S p)). - apply Hn; lia. - subst beta; apply (H'_alpha_dom gamma (S p)); auto with arith. Qed. End Succ_case. Section Limit_case. Hypothesis Hbeta: E0limit beta. Remark R4 : E0succ alpha o< beta. Proof. now apply Succ_lt_T1limit. Qed. Remark R5 : {n: nat | forall p, n <= p -> H'_ alpha (S p) < H'_ beta (S p)}. Proof. assert (E0succ alpha o<= beta) by (apply Lt_Le_incl; apply R4). destruct (H'_mono_l_1 _ _ H) as [x Hx]. exists x; intros. apply Lt.lt_le_trans with (H'_ (E0succ alpha) (S p)). - apply (H'_alpha_dom alpha (S p)); auto with arith. - auto. Qed. End Limit_case. Lemma H'_mono_l : {n: nat | forall p, n <= p -> H'_ alpha (S p) < H'_ beta (S p)}. Proof. destruct (Zero_Limit_Succ_dec beta) as [[H0 | Hl] | [gamma Hgamma]]. - subst; destruct (E0_not_Lt_zero H_alpha_beta). - now apply R5. - eapply R3; eauto. Qed. Theorem H'_dom : dominates_strong (H'_ beta) (H'_ alpha). 
Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Ring.prod_has_inv_r_1 ring. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof Ring.prod_0_inv_r ring. Theorem prod_0_inv : ~ prod_has_inv 0. Proof Ring.prod_0_inv ring. Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof Ring.prod_inv_0 ring. Definition E_n1_strong : { x : E | sum_is_inv 1 x } := Ring.E_n1_strong ring. Definition E_n1 : E := Ring.E_n1 ring. Notation "{-1}" := E_n1 : commutative_ring_scope. Definition E_n1_def : sum_is_inv 1 {-1} := Ring.E_n1_def ring. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof Ring.E_n1_inv_l ring. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof Ring.E_n1_inv_r ring. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof Ring.E_n1_uniq ring. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). Proof Ring.prod_n1_x_inv_l ring. Theorem prod_x_n1_inv_l : forall x : E, sum_is_inv_l x (x # {-1}). Proof Ring.prod_x_n1_inv_l ring. Theorem prod_n1_x_inv_r : forall x : E, sum_is_inv_r x ({-1} # x). Proof Ring.prod_n1_x_inv_r ring. Theorem prod_x_n1_inv_r : forall x : E, sum_is_inv_r x (x # {-1}). Proof Ring.prod_x_n1_inv_r ring. Theorem prod_n1_x_inv : forall x : E, sum_is_inv x ({-1} # x). Proof Ring.prod_n1_x_inv ring. Theorem prod_x_n1_inv : forall x : E, sum_is_inv x (x # {-1}). Proof Ring.prod_x_n1_inv ring. Theorem prod_n1_neg : {#} {-1} = sum_neg. Proof Ring.prod_n1_neg ring. Theorem prod_x_n1_neg : forall x : E, x # {-1} = - x. Proof Ring.prod_x_n1_neg ring. Theorem prod_n1_x_neg : forall x : E, {-1} # x = - x. Proof Ring.prod_n1_x_neg ring. Theorem prod_n1_eq : forall x : E, {-1} # x = x # {-1} . Proof Ring.prod_n1_eq ring. Theorem neg_1 : {-} 1 = {-1}. Proof Ring.neg_1 ring. Theorem neg_n1 : sum_neg {-1} = 1. Proof Ring.neg_n1 ring. Theorem prod_n1_n1 : {-1} # {-1} = 1. 
(rem' q r) | xI q, Node010 y => Nodes m | xI q, Node011 y r => Node Empty (Some y) (rem' q r) | xI q, Node100 l => Nodes m | xI q, Node101 l r => Node (Nodes l) None (rem' q r) | xI q, Node110 l y => Nodes m | xI q, Node111 l y r => Node (Nodes l) (Some y) (rem' q r) end. Definition remove' := Eval cbv [rem' Node] in @rem'. Definition remove {A} (p: positive) (m: tree A) : tree A := match m with | Empty => Empty | Nodes m' => remove' p m' end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. reflexivity. Qed. Lemma gEmpty: forall (A: Type) (i: positive), get i (@Empty A) = None. Proof. reflexivity. Qed. Lemma gss0: forall {A} p (x: A), get' p (set0 p x) = Some x. Proof. induction p; simpl; auto. Qed. Lemma gso0: forall {A} p q (x: A), p<>q -> get' p (set0 q x) = None. Proof. induction p; destruct q; simpl; intros; auto; try apply IHp; congruence. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: tree A), get i (set i x m) = Some x. Proof. intros. destruct m as [|m]; simpl. - apply gss0. - revert m; induction i; destruct m; simpl; intros; auto using gss0. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: tree A), i <> j -> get i (set j x m) = get i m. Proof. intros. destruct m as [|m]; simpl. - apply gso0; auto. - revert m j H; induction i; destruct j,m; simpl; intros; auto; solve [apply IHi; congruence | apply gso0; congruence | congruence]. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then Some x else get i m. Proof. intros. destruct (peq i j); [ rewrite e; apply gss | apply gso; auto ]. Qed. Lemma gNode: forall {A} (i: positive) (l: tree A) (x: option A) (r: tree A), get i (Node l x r) = match i with xH => x | xO j => get j l | xI j => get j r end. Proof. intros. destruct l, x, r; simpl; auto; destruct i; auto. Qed. Theorem grs: forall (A: Type) (i: positive) (m: tree A), get i (remove i m) = None. 
Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Malloc Bedrock.Platform.tests.PrintInt Bedrock.Platform.Bootstrap. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 0. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 0. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "test"!"main" @ [PrintInt.mainS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREonly[_] 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREonly[_] mallocHeap 0];; Call "test"!"main"() [PREonly[_] [| False |] ] end }}. Theorem ok : moduleOk boot. vcgen; abstract genesis. Qed. Definition m0 := link Malloc.m boot. Definition m1 := link PrintInt.m m0. Lemma ok0 : moduleOk m0. link Malloc.ok ok. Qed. Lemma ok1 : moduleOk m1. link PrintInt.ok ok0. Qed. Variable stn : settings. Variable prog : program. Hypothesis inj : forall l1 l2 w, Labels stn l1 = Some w -> Labels stn l2 = Some w -> l1 = l2. Hypothesis agree : forall l pre bl, LabelMap.MapsTo l (pre, bl) (XCAP.Blocks m1) -> exists w, Labels stn l = Some w /\ prog w = Some bl. Hypothesis agreeImp : forall l pre, LabelMap.MapsTo l pre (XCAP.Imports m1) -> exists w, Labels stn l = Some w /\ prog w = None. Hypothesis omitImp : forall l w, Labels stn ("sys", l) = Some w -> prog w = None. Variable w : W. Hypothesis at_start : Labels stn ("main", Global "main") = Some w. Variable st : state. Hypothesis mem_low : forall n, (n < size * 4)%nat -> st.(Mem) n <> None. Hypothesis mem_high : forall w, $ (size * 4) <= w -> st.(Mem) w = None. Theorem safe : sys_safe stn prog (w, st). 
: forall n m p : nat, n <= p -> m < n -> p - n < p - m. intros n m p H'; generalize m; clear m; elim H'. intros m H'0; rewrite <- minus_n_n; elim H'0. rewrite <- minus_Sn_m; auto with arith. intros m0 H'1 H'2; rewrite <- minus_Sn_m; auto with arith. intros m H'0 H'1 m0 H'2; repeat rewrite <- minus_Sn_m; auto with arith. apply le_trans with n; auto with arith. Qed. Theorem lt_mult_anti_compatibility : forall n n1 n2 : nat, 0 < n -> n * n1 < n * n2 -> n1 < n2. intros n n1 n2 H' H'0; case (le_or_lt n2 n1); auto. intros H'1; Contradict H'0; auto. apply le_not_lt; auto with arith. Qed. Theorem le_mult_anti_compatibility : forall n n1 n2 : nat, 0 < n -> n * n1 <= n * n2 -> n1 <= n2. intros n n1 n2 H' H'0; case (le_or_lt n1 n2); auto. intros H'1; Contradict H'0; auto. apply lt_not_le; auto with arith. Qed. Theorem min_n_0 : forall n : nat, min n 0 = 0. intros n; case n; simpl in |- *; auto. Qed.Hint Resolve Rabs_pos: real. Theorem Rlt_Rminus_ZERO : forall r1 r2 : R, (r2 < r1)%R -> (0 < r1 - r2)%R. intros r1 r2 H; replace 0%R with (r1 - r1)%R; unfold Rminus in |- *; auto with real. Qed. Hint Resolve Rlt_Rminus_ZERO: real. Theorem Rabsolu_left1 : forall a : R, (a <= 0)%R -> Rabs a = (- a)%R. intros a H; case H; intros H1. apply Rabs_left; auto. rewrite H1; simpl in |- *; rewrite Rabs_right; auto with real. Qed. Theorem RmaxLess1 : forall r1 r2 : R, (r1 <= Rmax r1 r2)%R. intros r1 r2; unfold Rmax in |- *; case (Rle_dec r1 r2); auto with real. Qed. Theorem RmaxLess2 : forall r1 r2 : R, (r2 <= Rmax r1 r2)%R. intros r1 r2; unfold Rmax in |- *; case (Rle_dec r1 r2); auto with real; intros; apply Ropp_le_cancel; auto with real. Qed. Theorem RmaxSym : forall p q : R, Rmax p q = Rmax q p. intros p q; unfold Rmax in |- *. case (Rle_dec p q); case (Rle_dec q p); auto; intros H1 H2; apply Rle_antisym; auto. case (Rle_or_lt p q); auto; intros H'0; Contradict H1; apply Rlt_le; auto. case (Rle_or_lt q p); auto; intros H'0; Contradict H2; apply Rlt_le; auto. Qed. Theorem RmaxAbs : forall p q r : R, (p <= q)%R -> (q <= r)%R -> (Rabs q <= Rmax (Rabs p) (Rabs r))%R. 
Require Import List Arith Omega.Require Import ILL.Definitions.Require Import utils pos vec. Require Import subcode sss. Require Import tiles_solvable bsm_defs bsm_pcp.Fact tile_concat_itau ln lt : tile_concat ln lt = (itau1 lt (rev ln), itau2 lt (rev ln)). Proof. induction ln as [ | i ln IH ]; simpl; auto. rewrite itau1_app, itau2_app; simpl. unfold card, string; generalize (nth i lt ([] / [])); intros (a,b); rewrite IH. repeat rewrite <- app_nil_end; auto. Qed.Theorem tiles_solvable_iBPCP lt : tiles_solvable lt <-> iBPCP lt. Proof. split. + intros (ln & H1 & H2 & H3). rewrite tile_concat_itau in H3. exists (rev ln). rewrite <- Forall_forall. repeat split; auto. * apply Forall_rev; auto. * contradict H1; rewrite <- (rev_involutive ln), H1; auto. + intros (ln & H1 & H2 & H3). exists (rev ln). rewrite tile_concat_itau, rev_involutive. repeat split; auto. * contradict H2; rewrite <- (rev_involutive ln), H2; auto. * apply Forall_rev, Forall_forall; auto. Qed.Local Notation "P // s ->> t" := (sss_compute (@bsm_sss _) P s t). Local Notation "P // s ~~> t" := (sss_output (@bsm_sss _) P s t). Local Notation "P // s ↓" := (sss_terminates (@bsm_sss _) P s). Section iBPCP_BSM_HALTING. Let f (lt : list (card bool)) : BSM_PROBLEM. Proof. exists 4, 1, (pcp_bsm lt). exact (vec_set_pos (fun _ => nil)). Defined. Goal forall x, | pcp_bsm x| >= 80. intros; rewrite pcp_bsm_size; omega. Qed. Theorem iBPCP_BSM_HALTING : iBPCP ⪯ BSM_HALTING. 
dm) | Meth None => Meth None end. Lemma decompositionDrop_substep: forall o u ul cs, reachable o imp -> Substep imp o u ul cs -> Substep spec (theta o) (theta u) (liftPUnitLabel o ul) (liftToMap1 p cs). Proof. intros; destruct ul as [[|]|[|]]. - apply substepRuleMap in H0; auto. - inv H0; simpl; rewrite Htheta1; constructor. - apply substepMethMap in H0; auto. - inv H0; simpl; rewrite Htheta1; constructor. Qed. Lemma p_disj_unitLabel: forall n d, ~ M.In n d -> ~ M.In n (liftToMap1 p d). Proof. intros; findeq. rewrite liftToMap1_find. rewrite H; auto. Qed. Lemma decompositionDrop_substepsInd: forall o u l, reachable o imp -> SubstepsInd imp o u l -> SubstepsInd spec (theta o) (theta u) (liftPLabel (liftToMap1 p) ruleMap o l). Proof. induction 2; [simpl; rewrite Htheta1; constructor|]. subst. rewrite Htheta2. rewrite liftPLabel_mergeLabel. - econstructor. + apply IHSubstepsInd. + apply decompositionDrop_substep; auto. eassumption. + unfold CanCombineUUL in *; dest; simpl in *. repeat split; auto. * destruct l as [a d c]; simpl in *; auto. * destruct l as [a d c]; simpl in *. destruct a as [[|]|]; destruct sul as [[|]|[|]]; simpl in *; auto; try (destruct a as [n t]; simpl in *; case_eq (p n t); simpl; intros; auto; apply p_disj_unitLabel; auto). + reflexivity. + f_equal. unfold getLabel; cbn; f_equal. * unfold liftPUnitLabel. destruct sul as [[|]|[|]]; try reflexivity. * unfold liftToMap1, liftPUnitLabel; simpl. destruct sul as [[|]|[|]]; try reflexivity. destruct a; cbn. unfold rmModify. destruct (p attrName attrType); try reflexivity. - clear -H2. unfold CanCombineUUL in H2; unfold CanCombineLabel. destruct l as [a d c]; simpl in *; dest. repeat split; auto; try (destruct a as [|]; destruct sul as [[|]|[|]]; auto; destruct a; simpl in *; auto). Qed. Lemma decompositionDrop_stepInd: forall o u l, reachable o imp -> StepInd imp o u l -> StepInd spec (theta o) (theta u) (liftPLabel (liftToMap1 p) ruleMap o l). Proof. intros; inv H0. rewrite liftPLabel_hide with (imp:= imp); auto. - constructor. + apply decompositionDrop_substepsInd; auto. + rewrite <-liftPLabel_hide with (imp:= imp); auto. * eapply liftPLabel_wellHidden; eauto. * eapply substepsInd_defs_in; eauto. * eapply substepsInd_calls_in; eauto. - eapply substepsInd_defs_in; eauto. - eapply substepsInd_calls_in; eauto. Qed. Lemma decompositionDrop_step: forall o u l, reachable o imp -> Step imp o u l -> Step spec (theta o) (theta u) (liftPLabel (liftToMap1 p) ruleMap o l). Proof. intros. apply step_consistent in H0. apply step_consistent. apply decompositionDrop_stepInd; auto. Qed. Theorem decompositionDrop: traceRefines (liftToMap1 p) imp spec. 
tr => node n tl tr end.Lemma tunf_eq : forall t, t = tunf t. Proof. destruct t; auto. Qed. CoFixpoint one : inftree := node 1 one two with two : inftree := node 2 one two.CoFixpoint eins : inftree := node 1 eins (node 2 eins zwei) with zwei : inftree := node 2 eins zwei.Inductive teq_gen teq : inftree -> inftree -> Prop := | _teq_gen : forall n t1l t1r t2l t2r (Rl : teq t1l t2l : Prop) (Rr : teq t1r t2r), teq_gen teq (node n t1l t1r) (node n t2l t2r). Hint Constructors teq_gen.CoInductive teq t1 t2 : Prop := | teq_fold (IN : teq_gen teq t1 t2). Theorem teq_one : teq one eins. Proof. cofix CIH. apply teq_fold. rewrite (tunf_eq one), (tunf_eq eins); simpl. constructor; auto. apply teq_fold. rewrite (tunf_eq two); simpl. constructor; auto. cofix CIH'. apply teq_fold. rewrite (tunf_eq two), (tunf_eq zwei); simpl. constructor; auto. Qed.Theorem teq_two : teq two zwei. Proof. cofix CIH. apply teq_fold. rewrite (tunf_eq two), (tunf_eq zwei); simpl. constructor; auto. cofix CIH'. apply teq_fold. rewrite (tunf_eq one), (tunf_eq eins); simpl. constructor; auto. apply teq_fold. rewrite (tunf_eq two); simpl. constructor; auto. Qed.Definition teq' t1 t2 := paco2 teq_gen bot2 t1 t2. Hint Unfold teq'. Lemma teq_gen_mon: monotone2 teq_gen. Proof. pmonauto. Qed. Hint Resolve teq_gen_mon : paco.Theorem teq'_one : teq' one eins. Proof. pcofix CIH. pfold. rewrite (tunf_eq one), (tunf_eq eins); simpl. constructor; auto. left; pfold. rewrite (tunf_eq two); simpl. constructor; auto. left; pcofix CIH'. pfold. rewrite (tunf_eq two), (tunf_eq zwei); simpl. constructor; auto. Qed.Theorem teq'_two : teq' two zwei. Proof. pcofix CIH. pfold. rewrite (tunf_eq two), (tunf_eq zwei); simpl. constructor; auto. left; pcofix CIH'. pfold. rewrite (tunf_eq one), (tunf_eq eins); simpl. constructor; auto. left; pfold. rewrite (tunf_eq two); simpl. constructor; auto. Qed.Lemma teq_two_one_bad : teq two zwei -> teq one eins. Proof. intros; rewrite (tunf_eq two), (tunf_eq zwei) in H. destruct H; inversion IN; auto. Defined.Lemma teq_two_one : teq two zwei -> teq one eins. Proof. intros; cofix CIH. apply teq_fold. rewrite (tunf_eq one), (tunf_eq eins); simpl. constructor; auto. apply teq_fold. rewrite (tunf_eq two); simpl. constructor; auto. Defined.Lemma teq_one_two : teq one eins -> teq two zwei. Proof. intros; cofix CIH. apply teq_fold. rewrite (tunf_eq two), (tunf_eq zwei); simpl. constructor; auto. Defined.Theorem teq_eins : teq one eins. Proof. cofix CIH. apply teq_two_one, teq_one_two, CIH. Qed.Theorem teq_zwei : teq two zwei. Proof. cofix CIH. apply teq_one_two, teq_two_one, CIH. Qed. Theorem teq_eins_bad : teq one eins. 
Some st') -> c / st \\ st'. Proof. intros c st st' H. inversion H as [i E]. clear H. generalize dependent st'. generalize dependent st. generalize dependent c. induction i as [| i' ]. - intros c st st' H. inversion H. - intros c st st' H. destruct c; simpl in H; inversion H; subst; clear H. + apply E_Skip. + apply E_Ass. reflexivity. + destruct (ceval_step st c1 i') eqn:Heqr1. * apply E_Seq with s. apply IHi'. rewrite Heqr1. reflexivity. apply IHi'. simpl in H1. assumption. * inversion H1. + destruct (beval st b) eqn:Heqr. * apply E_IfTrue. rewrite Heqr. reflexivity. apply IHi'. assumption. * apply E_IfFalse. rewrite Heqr. reflexivity. apply IHi'. assumption. + destruct (beval st b) eqn :Heqr. * destruct (ceval_step st c i') eqn:Heqr1. { apply E_WhileTrue with s. rewrite Heqr. reflexivity. apply IHi'. rewrite Heqr1. reflexivity. apply IHi'. simpl in H1. assumption. } { inversion H1. } * inversion H1. apply E_WhileFalse. rewrite <- Heqr. subst. reflexivity. Qed.[] *)Theorem ceval_step_more: forall i1 i2 st st' c, i1 <= i2 -> ceval_step st c i1 = Some st' -> ceval_step st c i2 = Some st'. Proof. induction i1 as [|i1']; intros i2 st st' c Hle Hceval. - simpl in Hceval. inversion Hceval. - destruct i2 as [|i2']. inversion Hle. assert (Hle': i1' <= i2') by omega. destruct c. + simpl in Hceval. inversion Hceval. reflexivity. + simpl in Hceval. inversion Hceval. reflexivity. + simpl in Hceval. simpl. destruct (ceval_step st c1 i1') eqn:Heqst1'o. * apply (IHi1' i2') in Heqst1'o; try assumption. rewrite Heqst1'o. simpl. simpl in Hceval. apply (IHi1' i2') in Hceval; try assumption. * inversion Hceval. + simpl in Hceval. simpl. destruct (beval st b); apply (IHi1' i2') in Hceval; assumption. + simpl in Hceval. simpl. destruct (beval st b); try assumption. destruct (ceval_step st c i1') eqn: Heqst1'o. * apply (IHi1' i2') in Heqst1'o; try assumption. rewrite -> Heqst1'o. simpl. simpl in Hceval. apply (IHi1' i2') in Hceval; try assumption. * simpl in Hceval. inversion Hceval. Qed. Theorem ceval__ceval_step: forall c st st', c / st \\ st' -> exists i, ceval_step st c i = Some st'. Proof. intros c st st' Hce. induction Hce. Admitted. Theorem ceval_and_ceval_step_coincide: forall c st st', c / st \\ st' <-> exists i, ceval_step st c i = Some st'. Proof. intros c st st'. split. apply ceval__ceval_step. apply ceval_step__ceval. Qed. Theorem ceval_deterministic' : forall c st st1 st2, c / st \\ st1 -> c / st \\ st2 -> st1 = st2. 
S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. Admitted. Theorem leb_refl : forall n:nat, true = leb n n. Admitted. Theorem zero_nbeq_S : forall n:nat, beq_nat 0 (S n) = false. Admitted. Theorem andb_false_r : forall b : bool, andb b false = false. Admitted. Derive ArbitrarySizedSuchThat for (fun m => le n m). Derive SizeMonotonicSuchThatOpt for (fun m => le n m). Derive GenSizedSuchThatSizeMonotonicOpt for (fun m => le n m). Derive SizedProofEqs for (fun m => le n m). Derive GenSizedSuchThatCorrect for (fun m => le n m).Theorem plus_ble_compat_l : forall n m p : nat, leb n m = true -> leb (p + n) (p + m) = true. Admitted.Theorem S_nbeq_0 : forall n:nat, beq_nat (S n) 0 = false. Admitted. Theorem mult_1_l : forall n:nat, 1 * n = n. Admitted. Theorem all3_spec : forall b c : bool, orb (andb b c) (orb (negb b) (negb c)) = true. Admitted. Theorem mult_plus_distr_r : forall n m p : nat, (n + m) * p = (n * p) + (m * p). Admitted. Theorem mult_assoc : forall n m p : nat, n * (m * p) = (n * m) * p. Admitted. Theorem beq_nat_refl : forall n : nat, true = beq_nat n n. Admitted. Theorem plus_swap' : forall n m p : nat, n + (m + p) = m + (n + p). 
++ lys).Hint Constructors Denotes.Definition WF {A} (dxs: DList A) : Prop := exists lxs, Denotes dxs lxs.Ltac prove_WF fdenotes:= rewrite /WF; repeat move=>[? ?]; eexists; eapply fdenotes; eauto.Theorem empty_WF {A} : WF (@empty A). Proof. prove_WF (@emptyD A). Qed.Theorem singleton_WF {A} (x : A) : WF (singleton x). Proof. prove_WF (@singletonD A). Qed.Theorem cons__WF {A} (x : A) (dxs : DList A) : WF dxs -> WF (cons_ x dxs). Proof. prove_WF (@consD A). Qed.Theorem append_WF {A} (dxs dys : DList A) : WF dxs -> WF dys -> WF (dxs +++ dys). Proof. prove_WF (@appendD A). Qed.Theorem fromDList_Denotes {A} (dxs : DList A) (lxs lys : list A) : Denotes dxs lxs -> fromDList dxs lys = lxs ++ lys. Proof. intro H. generalize dependent lys. induction H; intros. - reflexivity. - reflexivity. - destruct dxs. simpl in *. f_equal. apply IHDenotes. - destruct dxs; destruct dys. simpl in *. rewrite -app_assoc. specialize (IHDenotes1 (lys ++ lys0)). rewrite -IHDenotes1. f_equal. apply IHDenotes2. Qed.Theorem reflection {A} : forall lxs : list A, exists dxs, Denotes dxs lxs. Proof. induction lxs. - exists []. constructor. - destruct IHlxs. exists (a ::: x). constructor; auto. Qed.Definition reify {A} := @toList A.Theorem Denotes_reify {A} (dxs : DList A) (lxs : list A) : Denotes dxs lxs -> reify dxs = lxs. Proof. move=>H. destruct dxs. rewrite /reify /=. rename fromDList into l. replace l with (fromDList (MkDList l)). replace lxs with (lxs ++ []). by apply fromDList_Denotes. by rewrite app_nil_r. done. Qed.Theorem reify_P {A} (dxs : DList A) (lxs : list A) (P : list A -> Prop) : Denotes dxs lxs -> P lxs -> P (reify dxs). Proof. intros. apply Denotes_reify in H. by rewrite H. Qed.Theorem reify_Denotes {A} (dxs : DList A) (lxs : list A) : WF dxs -> reify dxs = lxs -> Denotes dxs lxs. Proof. intros. rewrite -H0. inversion H. eapply reify_P. apply H1. done. Qed.Notation "x 'in' y" := (In x (reify y)) (at level 61). Notation "x =l y" := (reify x = reify y) (at level 62). Notation "'len' x" := (Datatypes.length (reify x)) (at level 61).Theorem append_singletons {A} (x y : A) : toList (append (singleton x) (singleton y)) = [x; y]. Proof. done. Qed.Theorem toList_cons_ {A} (x : A) (dxs : DList A) : toList (cons_ x dxs) = x :: toList dxs. Proof. by move: dxs => [fxs] /=. Qed. Theorem appendA {A} : associative (@append A). 
= #true⌝ ∗ P ∨ ⌜v = #false⌝ ∗ Φ #() }}) -∗ WP (for: cond; (λ: <>, Skip)%V := body) @ stk; E {{ Φ }}. Proof. iIntros "HP #Hloop". iApply (wp_forBreak_cond (λ b, ⌜b = true⌝ ∗ P ∨ ⌜b = false⌝ ∗ Φ #()) with "[] [-]")%I. - iIntros "!#" (Φ') "Hinv HΦ'". iDestruct "Hinv" as "[[_ HP]|[% _]]"; last done. iSpecialize ("Hloop" with "HP"). iApply (wp_wand with "[HΦ' Hloop]"). { iApply wp_frame_step_l'. iFrame. } iIntros (v) "[HP [[-> Hpost]|[-> Hpost]]]". + iApply "HP". iLeft. eauto. + iApply "HP". iRight. eauto. - iLeft. eauto. - iNext. iIntros "[[% _]|[_ HΦ]]"; first done. eauto. Qed.Theorem wp_forBreak' (P: iProp Σ) stk E (body: val) (Φ : val → iProp Σ) : P -∗ □ (P -∗ WP body #() @ stk; E {{ v, ⌜v = #true⌝ ∗ P ∨ ⌜v = #false⌝ ∗ Φ #() }}) -∗ WP (for: (λ: <>, #true)%V; (λ: <>, Skip)%V := body) @ stk; E {{ Φ }}. Proof. iIntros "HP #Hloop". iApply (wp_forBreak_cond' with "HP"). iIntros "!# HP". wp_pures. iApply "Hloop". done. Qed.Local Opaque load_ty store_ty.Theorem wp_forUpto (I: u64 -> iProp Σ) stk E (start max:u64) (l:loc) (body: val) : int.Z start <= int.Z max -> (∀ (i:u64), {{{ I i ∗ l ↦[uint64T] #i ∗ ⌜int.Z i < int.Z max⌝ }}} body #() @ stk; E {{{ RET #true; I (word.add i (U64 1)) ∗ l ↦[uint64T] #i }}}) -∗ {{{ I start ∗ l ↦[uint64T] #start }}} (for: (λ:<>, #max > ![uint64T] #l)%V ; (λ:<>, #l <-[uint64T] ![uint64T] #l + #1)%V := body) @ stk; E {{{ RET #(); I max ∗ l ↦[uint64T] #max }}}. Proof. iIntros (Hstart_max) "#Hbody". iIntros (Φ) "!> (H0 & Hl) HΦ". rewrite /For /Continue. wp_lam. wp_let. wp_let. wp_pure (Rec _ _ _). match goal with | |- context[RecV (BNamed "loop") _ ?body] => set (loop:=body) end. remember start as x. assert (int.Z start <= int.Z x <= int.Z max) as Hbounds by (subst; word). clear Heqx Hstart_max. iDestruct "H0" as "HIx". iLöb as "IH" forall (x Hbounds). wp_pures. wp_load. wp_pures. wp_bind (If _ _ _). wp_if_destruct. - wp_apply ("Hbody" with "[$HIx $Hl]"). { iPureIntro; lia. } iIntros "[HIx Hl]". wp_pures. wp_load. wp_pures. wp_store. iApply ("IH" with "[] HIx Hl"). { iPureIntro; word. } iFrame. - wp_pures. assert (int.Z x = int.Z max) by word. apply word.unsigned_inj in H; subst. iApply ("HΦ" with "[$]"). Qed. Theorem wp_simpleFor (I: u64 -> iProp Σ) (max:u64) (body: val) : (∀ (l:loc) (i:u64), {{{ I i ∗ l ↦[uint64T] #i ∗ ⌜int.Z i < int.Z max⌝ }}} body #l {{{ RET #true; I (word.add i (U64 1)) ∗ l ↦[uint64T] #i }}}) -∗ {{{ I (U64 0) }}} (let: "i" := ref_to uint64T #0 in (for: (λ:<>, ![uint64T] (Var "i") < #max)%E; (λ:<>, (Var "i") <-[uint64T] ![uint64T] (Var "i") + #1)%E := (λ:<>, body (Var "i")))) {{{ RET #(); I max }}}. 
Require Export Iron.Language.SystemF2.Ty. Require Export Iron.Language.SystemF2Store.Def. Require Export Iron.Language.SystemF2Store.ExpDataCon.Inductive exp : Type := | XVar : nat -> exp | XLoc : nat -> exp | XLAM : exp -> exp | XAPP : exp -> ty -> exp | XLam : ty -> exp -> exp | XApp : exp -> exp -> exp | XCon : datacon -> list ty -> list exp -> exp | XCase : exp -> list alt -> exp | XUpdate : datacon -> nat -> list ty -> exp -> exp -> exp with alt : Type := | AAlt : datacon -> exp -> alt.Hint Constructors exp. Hint Constructors alt. Theorem exp_mutind : forall (PX : exp -> Prop) (PA : alt -> Prop) , (forall n, PX (XVar n)) -> (forall l, PX (XLoc l)) -> (forall x1, PX x1 -> PX (XLAM x1)) -> (forall x1 t2, PX x1 -> PX (XAPP x1 t2)) -> (forall t x1, PX x1 -> PX (XLam t x1)) -> (forall x1 x2, PX x1 -> PX x2 -> PX (XApp x1 x2)) -> (forall dc ts xs, Forall PX xs -> PX (XCon dc ts xs)) -> (forall x aa, PX x -> Forall PA aa -> PX (XCase x aa)) -> (forall dc i ts x1 x2, PX x1 -> PX x2 -> PX (XUpdate dc i ts x1 x2)) -> (forall dc x, PX x -> PA (AAlt dc x)) -> forall x, PX x. 
Set Warnings "-notation-overridden,-parsing". Require Export Tactics.Check 3 = 3. Check forall n m : nat, n + m = m + n. Check forall n : nat, n = 2. Check 3 = 4. Theorem plus_2_2_is_4 : 2 + 2 = 4. Proof. reflexivity. Qed.Definition plus_fact : Prop := 2 + 2 = 4. Check plus_fact. Theorem plus_fact_is_true : plus_fact. Proof. reflexivity. Qed.Definition is_three (n : nat) : Prop := n = 3. Check is_three. Definition injective {A B} (f : A -> B) := forall x y : A, f x = f y -> x = y.Lemma succ_inj : injective S. Proof. intros n m H. inversion H. reflexivity. Qed.Check @eq. Example and_example : 3 + 4 = 7 /\ 2 * 2 = 4.Proof. split. - reflexivity. - reflexivity. Qed.Lemma and_intro : forall A B : Prop, A -> B -> A /\ B. Proof. intros A B HA HB. split. - apply HA. - apply HB. Qed.Example and_example' : 3 + 4 = 7 /\ 2 * 2 = 4. Proof. apply and_intro. - reflexivity. - reflexivity. Qed. Example and_exercise : forall n m : nat, n + m = 0 -> n = 0 /\ m = 0. Proof. Admitted. Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Proof. intros n m H. destruct H as [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example2' : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Proof. intros n m [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Proof. intros n m Hn Hm. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example3 : forall n m : nat, n + m = 0 -> n * m = 0. Proof. intros n m H. assert (H' : n = 0 /\ m = 0). { apply and_exercise. apply H. } destruct H' as [Hn Hm]. rewrite Hn. reflexivity. Qed.Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Proof. intros P Q [HP HQ]. apply HP. Qed. Lemma proj2 : forall P Q : Prop, P /\ Q -> Q. Proof. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. 
Hrec Hneq Hlt; repeat rewrite <- (fun x : nat => mult_n_Sm x (S c'')). auto with *. Qed. Remark add_sub_square_identity : forall a b : nat, (b + a - b) * (b + a - b) = (b + a) * (b + a) + b * b - 2 * ((b + a) * b). intros a b; rewrite minus_plus. repeat rewrite mult_plus_distr_r || rewrite <- (mult_comm (b + a)). replace (b * b + a * b + (b * a + a * a) + b * b) with (b * b + a * b + (b * b + a * b + a * a)); try (ring; fail). rewrite expand_mult2; repeat rewrite minus_plus; auto with *. Qed. Theorem sub_square_identity : forall a b : nat, b <= a -> (a - b) * (a - b) = a * a + b * b - 2 * (a * b). intros a b H; rewrite (le_plus_minus b a H); apply add_sub_square_identity. Qed. Theorem square_monotonic : forall x y : nat, x < y -> x * x < y * y. intros x; case x. intros y; case y; simpl in |- *; auto with *. intros x' y Hlt; apply lt_trans with (S x' * y). rewrite (mult_comm (S x') y); apply mult_lt; auto. apply mult_lt; omega. Qed. Theorem root_monotonic : forall x y : nat, x * x < y * y -> x < y. exact (monotonic_inverse (fun x : nat => x * x) square_monotonic). Qed. Remark square_recompose : forall x y : nat, x * y * (x * y) = x * x * (y * y). intros; ring. Qed. Remark mult2_recompose : forall x y : nat, x * (2 * y) = x * 2 * y. intros; ring. Qed. Section sqrt2_decrease. Variables (p q : nat) (pos_q : 0 < q) (hyp_sqrt : p * p = 2 * (q * q)). Theorem sqrt_q_non_zero : 0 <> q * q. generalize pos_q; case q. intros H; elim (lt_n_O 0); auto. intros n H. simpl in |- *; discriminate. Qed. Hint Resolve sqrt_q_non_zero. Ltac solve_comparison := apply root_monotonic; repeat rewrite square_recompose; rewrite hyp_sqrt; rewrite mult2_recompose; apply mult_lt; auto with arith. Theorem comparison1 : q < p. replace q with (1 * q); try ring. replace p with (1 * p); try ring. solve_comparison. Qed. Theorem comparison2 : 2 * p < 3 * q. 
Set Warnings "-notation-overridden,-parsing". Require Export ProofObjects. Check nat_ind. Theorem mult_0_r' : forall n:nat, n * 0 = 0. Proof. apply nat_ind. - reflexivity. - simpl. intros n' IHn'. rewrite -> IHn'. reflexivity. Qed. Theorem plus_one_r' : forall n:nat, n + 1 = S n. 
Sigma. Variable f : nat -> R. Definition sigma (low high:nat) : R := sum_f_R0 (fun k:nat => f (low + k)) (high - low). Theorem sigma_split : forall low high k:nat, (low <= k)%nat -> (k < high)%nat -> sigma low high = sigma low k + sigma (S k) high. Proof. intros; induction k as [| k Hreck]. cut (low = 0%nat). intro; rewrite H1; unfold sigma; rewrite <- minus_n_n; rewrite <- minus_n_O; simpl; replace (high - 1)%nat with (pred high). apply (decomp_sum (fun k:nat => f k)). assumption. apply pred_of_minus. inversion H; reflexivity. cut ((low <= k)%nat \/ low = S k). intro; elim H1; intro. replace (sigma low (S k)) with (sigma low k + f (S k)). rewrite Rplus_assoc; replace (f (S k) + sigma (S (S k)) high) with (sigma (S k) high). apply Hreck. assumption. apply lt_trans with (S k); [ apply lt_n_Sn | assumption ]. unfold sigma; replace (high - S (S k))%nat with (pred (high - S k)). pattern (S k) at 3; replace (S k) with (S k + 0)%nat; [ idtac | ring ]. replace (sum_f_R0 (fun k0:nat => f (S (S k) + k0)) (pred (high - S k))) with (sum_f_R0 (fun k0:nat => f (S k + S k0)) (pred (high - S k))). apply (decomp_sum (fun i:nat => f (S k + i))). apply lt_minus_O_lt; assumption. apply sum_eq; intros; replace (S k + S i)%nat with (S (S k) + i)%nat. reflexivity. ring. replace (high - S (S k))%nat with (high - S k - 1)%nat. apply pred_of_minus. omega. unfold sigma; replace (S k - low)%nat with (S (k - low)). pattern (S k) at 1; replace (S k) with (low + S (k - low))%nat. symmetry ; apply (tech5 (fun i:nat => f (low + i))). omega. omega. rewrite <- H2; unfold sigma; rewrite <- minus_n_n; simpl; replace (high - S low)%nat with (pred (high - low)). replace (sum_f_R0 (fun k0:nat => f (S (low + k0))) (pred (high - low))) with (sum_f_R0 (fun k0:nat => f (low + S k0)) (pred (high - low))). apply (decomp_sum (fun k0:nat => f (low + k0))). apply lt_minus_O_lt. apply le_lt_trans with (S k); [ rewrite H2; apply le_n | assumption ]. apply sum_eq; intros; replace (S (low + i)) with (low + S i)%nat. reflexivity. ring. omega. inversion H; [ right; reflexivity | left; assumption ]. Qed. Theorem sigma_diff : forall low high k:nat, (low <= k)%nat -> (k < high)%nat -> sigma low high - sigma low k = sigma (S k) high. 
of x with | irec => let b := fresh in destruct x as [? b] eqn:? ; destruct_irec' b | iattr => let b := fresh in destruct x as [? b] eqn:? ; destruct_irec' b | prod _ _ => let b := fresh in destruct x as [? b] eqn:? ; destruct_irec' b | _ => idtac end. Ltac destruct_irec x := match x with | (?a, ?b) => (destruct_irec a || destruct_irec b) | fst ?a => destruct_irec a | snd ?a => destruct_irec a | _ => destruct_irec' x; simpl end. Ltac smash_rec_well_formed' := match goal with | [ |- Rec.well_formed ?x ] => destruct_irec x end. Ltac smash_rec_well_formed := subst; autorewrite with defaults; repeat smash_rec_well_formed'; unfold Rec.well_formed; simpl; try rewrite Forall_forall; intuition. Ltac irec_wf := smash_rec_well_formed; match goal with | [ H : ?p %pred ?mm |- length ?d = NDirect ] => match p with | context [ IRec.rep ?xp ?ll ?cc ] => eapply irec_blocks_length' with (m := mm) (l := ll) (cache := cc) (xp := xp); eauto; pred_apply; cancel end end. Arguments Rec.well_formed : simpl never. Lemma inode_match_init_emp: forall bxp, inode_match bxp (inode0, emp) IRec.Defs.item0 <=p=> emp. Proof. unfold inode_match. unfold IRec.Defs.item0 at 1. rewrite Rec.of_word_zero_reczero; cbn. intros. rewrite Ind.rep_piff_direct by (cbn; omega). unfold Ind.rep_direct. split; cancel; rewrite ?Ind.indrep_0 by auto; try cancel. constructor. setoid_rewrite Rec.of_word_zero_reczero. repeat constructor. apply list_same_repeat. Qed. Lemma inode_match_init_ok : forall bxp n, emp =p=> listmatch (inode_match bxp) (repeat (inode0, emp) n) (repeat IRec.Defs.item0 n). Proof. induction n; simpl; intros. unfold listmatch; cancel. rewrite listmatch_cons. rewrite <- IHn. rewrite inode_match_init_emp. cancel. Qed. Theorem init_ok : forall lxp bxp xp ms, {< F Fm Fs m0 sm m l, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * arrayN (@ptsto _ _ _) (IXStart xp) l) ]]] * [[ Fs sm ]] * [[ length l = (IXLen xp) /\ (IXStart xp) <> 0 ]] POST:hm' RET:ms exists m' IFs, LOG.rep lxp F (LOG.ActiveTxn m0 m') ms sm hm' * [[[ m' ::: (Fm * rep bxp IFs xp (repeat inode0 ((IXLen xp) * IRecSig.items_per_val)) (IRec.cache0)) ]]] * [[ (Fs * IFs)%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init lxp xp ms. Proof. unfold init, rep. step. cbv; auto. step. unfold IRec.rep. cancel. rewrite combine_repeat. apply inode_match_init_ok. apply IRec.cache_rep_empty. autorewrite with lists; auto. apply Ind.pred_fold_left_repeat_emp. Qed. Theorem getlen_ok : forall lxp bxp xp inum cache ms, {< F Fm Fi m0 sm m IFs ilist ino, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * rep bxp IFs xp ilist cache) ]]] * [[[ ilist ::: Fi * inum |-> ino ]]] POST:hm' RET:^(cache', ms,r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[[ m ::: (Fm * rep bxp IFs xp ilist cache') ]]] * [[ r = length (IBlocks ino) ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} getlen lxp xp inum cache ms. 
From stdpp Require Import gmap. From stdpp Require Import vector fin_maps. From RecordUpdate Require Import RecordSet. From iris.algebra Require Import numbers. From Perennial.algebra Require Import ghost_async_map log_heap. From iris.proofmode Require Import tactics. From Perennial.program_logic Require Import ectx_lifting.From Perennial.Helpers Require Import CountableTactics Transitions. From Perennial.goose_lang Require Import lang lifting slice typing. From Perennial.goose_lang Require Import crash_modality. From Perennial.goose_lang.ffi Require Export async_disk_syntax.Set Default Proof Using "Type". Set Printing Projections.Definition disk_state := gmap Z (async Block).Definition disk_model : ffi_model. Proof. refine (mkFfiModel disk_state () _ _). Defined.Fixpoint init_disk (d: disk_state) (sz: nat) : disk_state := match sz with | O => d | S n => <[(Z.of_nat n) := sync block0]> (init_disk d n) end.Lemma length_Block_to_vals {ext: ffi_syntax} b : length (Block_to_vals b) = block_bytes. Proof. rewrite /Block_to_vals fmap_length vec_to_list_length //. Qed.Lemma replicate_zero_to_block0 `{ext_ty: ext_types} : replicate (int.nat 4096) (zero_val byteT) = Block_to_vals block0. Proof. reflexivity. Qed.Class diskGS Σ := DiskGS { diskG_ghost_async_mapG :> ghost_async_mapG Σ Z Block ; diskG_ghost_async_name : gname }.Class disk_preG Σ := { disk_preG_ghost_async_mapG :> ghost_async_mapG Σ Z Block }.Definition diskΣ : gFunctors := #[ghost_async_mapΣ Z Block].#[global] Instance subG_diskG Σ : subG diskΣ Σ → disk_preG Σ. Proof. solve_inG. Qed.Definition disk_update_pre {Σ} (dG: disk_preG Σ) (n: gname) := {| diskG_ghost_async_mapG := disk_preG_ghost_async_mapG; diskG_ghost_async_name := n |}.Section disk. Existing Instances disk_op disk_model disk_ty. Definition disk_val (d : ()) : val := ExtV d. Definition Get: val := λ: <>, disk_val (). Definition Read: val := λ: "a", let: "p" := ExternalOp ReadOp (Var "a") in raw_slice byteT (Var "p") #4096. Definition ReadTo: val := λ: "a" "buf", let: "p" := ExternalOp ReadOp (Var "a") in MemCpy_rec byteT (slice.ptr (Var "buf")) (Var "p") #4096. Definition Write: val := λ: "a" "b", ExternalOp WriteOp (Var "a", slice.ptr (Var "b")). Definition Barrier: val := λ: <>, ExternalOp BarrierOp #(). Definition Size: val := λ: "v", ExternalOp SizeOp (Var "v"). Theorem Size_t :  ⊢ Size #() : uint64T. 
c. Proof. intros; omega. Qed. Lemma le_add_le_sub : forall a b c, a <= c -> b <= c - a -> a + b <= c. Proof. intros. omega. Qed. Lemma items_valid_app2 : forall xp st a b, length b <= (roundup (length a) items_per_val - length a) -> items_valid xp st a -> Forall Rec.well_formed b -> items_valid xp st (a ++ b). Proof. unfold items_valid, roundup; intuition. pose proof (well_formed_app_iff itemtype a b); intuition. rewrite app_length. eapply le_add_helper. apply H. rewrite le_plus_minus_r. apply mult_le_compat_r. apply divup_le; lia. apply roundup_ge. apply items_per_val_gt_0. Qed. Lemma items_valid_app3 : forall xp st a b na, length a = na * items_per_val -> items_valid xp st (a ++ b) -> items_valid xp (st + na) b. Proof. unfold items_valid; intros; split; intros; pose proof (well_formed_app_iff itemtype a b); rewrite app_length in *; intuition. apply le_add_le_sub; auto. eapply Nat.mul_le_mono_pos_r. apply items_per_val_gt_0. rewrite <- H; omega. rewrite Nat.sub_add_distr. rewrite Nat.mul_sub_distr_r. apply Nat.le_add_le_sub_l. setoid_rewrite <- H; auto. Qed. Lemma items_valid_app4 : forall xp st a b na, length a = na * items_per_val -> items_valid xp st a -> items_valid xp (st + na) b -> items_valid xp st (a ++ b). Proof. unfold items_valid, roundup; intuition. apply well_formed_app_iff; intuition. rewrite app_length. rewrite Nat.sub_add_distr in H8. rewrite Nat.mul_sub_distr_r in H8. rewrite <- H in H8. omega. Qed. Lemma synced_array_is : forall xp start items, synced_array xp start items =p=> arrayS ((RAStart xp) + start) (combine (ipack items) (nils (length (ipack items)))). Proof. unfold synced_array, rep_common; cancel; subst; auto. Qed. Lemma array_rep_sync_nil : forall xp a, xparams_ok xp -> a <= (RALen xp) -> array_rep xp a (Synced nil) <=p=> emp. Proof. unfold array_rep, synced_array, rep_common; intros. split; cancel; subst; simpl; unfold items_valid, eqlen; try setoid_rewrite ipack_nil; simpl; intuition; auto. Qed. Lemma array_rep_sync_nil_emp : forall xp a, array_rep xp a (Synced nil) =p=> emp. Proof. unfold array_rep, synced_array, rep_common; intros. cancel; subst; simpl; unfold items_valid, eqlen; try setoid_rewrite ipack_nil; simpl; intuition; auto. Qed. Lemma array_rep_sync_nil_sep_star : forall xp a l, array_rep xp a (Synced l) =p=> array_rep xp a (Synced nil) * array_rep xp a (Synced l). Proof. intros. unfold array_rep, synced_array, rep_common, eqlen; intros. norm. eassign (@nil valu). cancel. subst; repeat setoid_rewrite ipack_nil; simpl; auto; unfold items_valid in *; intuition. rewrite nils_length; auto. Qed. Theorem sync_invariant_array_rep : forall xp a st, sync_invariant (array_rep xp a st). Proof. unfold array_rep, synced_array, unsync_array; destruct st; eauto. Qed. Theorem sync_invariant_avail_rep : forall xp a n, sync_invariant (avail_rep xp a n). 
Require Import Description. Require Import base. Require Import function. Require Import ProofIrrelevance. Require Import Bool.Require Import Arith. Require Import Wf. Require Import Wellfounded. Require Import Wf_nat.Module Monoid. Definition is_assoc (T : Type) (f : T -> T -> T) : Prop := forall x y z : T, f x (f y z) = f (f x y) z. Definition is_id_l (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f E x = x. Definition is_id_r (T : Type) (f : T -> T -> T) (E : T) : Prop := forall x : T, f x E = x. Definition is_id (T : Type) (f : T -> T -> T) (E : T) : Prop := is_id_l T f E /\ is_id_r T f E. Definition is_inv_l (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f y x = E. Definition is_inv_r (T : Type) (f : T -> T -> T) (E : T) (_ : is_id T f E) (x y : T) : Prop := f x y = E. Definition is_inv (T : Type) (f : T -> T -> T) (E : T) (H : is_id T f E) (x y : T) : Prop := is_inv_l T f E H x y /\ is_inv_r T f E H x y. Structure Monoid : Type := monoid { E: Set; E_0: E; op: E -> E -> E; op_is_assoc : is_assoc E op; op_id_l : is_id_l E op E_0; op_id_r : is_id_r E op E_0 }.Arguments E_0 {m}.Arguments op {m} x y.Arguments op_is_assoc {m} x y z.Arguments op_id_l {m} x.Arguments op_id_r {m} x.Notation "0" := E_0 : monoid_scope.Notation "x + y" := (op x y) (at level 50, left associativity) : monoid_scope.Notation "{+}" := op : monoid_scope.Open Scope monoid_scope.Section Theorems. Variable m : Monoid. Let M := E m. Definition op_is_id_l := is_id_l M {+}. Definition op_is_id_r := is_id_r M {+}. Definition op_is_id := is_id M {+}. Theorem op_id : is_id M {+} 0. Proof conj op_id_l op_id_r. Theorem op_id_l_uniq : forall x : M, (op_is_id_l x) -> x = 0. 
l1 (concat l2 l3). Proof. intros. induction l1. rewrite -> concat_nil_left. simpl. reflexivity. simpl. rewrite -> IHl1. reflexivity. Qed. Fixpoint snoc (l: natlist) (v: nat) : natlist := match l with | nil => cons v nil | cons h t => cons h (snoc t v) end. Fixpoint rev (l: natlist) : natlist := match l with | nil => nil | cons h t => snoc (rev t) h end. Theorem rev_snoc : forall x l, rev (snoc l x) = cons x (rev l). Proof. intros. induction l. simpl. reflexivity. simpl. rewrite -> IHl. simpl. reflexivity. Qed.Theorem rev_involutive : forall l : natlist, rev (rev l) = l. Proof. intros. induction l. simpl. reflexivity. simpl. rewrite -> rev_snoc. rewrite -> IHl. reflexivity. Qed.Theorem concat_cons_snoc : forall l1 x l2, concat l1 (cons x l2) = concat (snoc l1 x) l2. Proof. intros. induction l1. simpl. reflexivity. simpl. rewrite -> IHl1. reflexivity. Qed.Module LogicExercises1.Theorem goright_example : 0 = 1 \/ 1 = 1. Proof. right. reflexivity. Qed.Theorem go_somewhere : 0 = 1 \/ (2 = 2 \/ 2 = 3). Proof. right. left. reflexivity. Qed.Theorem B_is_enough : forall A B : Prop, B -> A \/ B. Proof. intros. right. apply H. Qed.End LogicExercises1.Module LogicExercises2.Theorem two_facts : nil = nil /\ 42 = 42. Proof. split. reflexivity. reflexivity. Qed.Theorem more_facts : 1 = 2 \/ (1 = 1 /\ nil = nil). Proof. right. split. reflexivity. reflexivity. Qed.Theorem A_and_B : forall A B : Prop, A -> B -> A /\ B. Proof. intros. split. apply H. apply H0. Qed.End LogicExercises2.Theorem snoc_concat_end : forall (l: natlist) (n: nat), snoc l n = concat l (cons n nil). Proof. intros. rewrite -> concat_cons_snoc. rewrite -> concat_nil_right. reflexivity. Qed.Theorem rev_distributes_over_concat : forall l1 l2 : natlist, rev (concat l1 l2) = concat (rev l2) (rev l1). Proof. intros. induction l1. simpl. rewrite -> concat_nil_right. reflexivity. simpl. rewrite -> IHl1. rewrite -> snoc_concat_end. rewrite -> concat_associativity. rewrite -> snoc_concat_end. reflexivity. Qed. Fixpoint map (f: nat -> nat) (l: natlist) := match l with | nil => nil | cons x xs => cons (f x) (map f xs) end.Theorem map_commutes : forall f g l, (forall x, f (g x) = g (f x)) -> map f (map g l) = map g (map f l). Proof. intros. induction l. simpl. reflexivity. simpl. rewrite -> IHl. rewrite -> H. reflexivity. Qed. Theorem map_fusion : forall f g l, map f (map g l) = map (fun x => f (g x)) l. 
H'1. case (Rdichotomy _ _ H'1); intros H'2. generalize H'; case n; auto. intros n0 H'0. cut (r <> 0%R); [ intros Eq1 | idtac ]. 2: Contradict H'0; auto with arith. 2: simpl in |- *; rewrite H'0; rewrite Rmult_0_l; auto with real. cut (Rabs r <> 0%R); [ intros Eq2 | apply Rabs_no_R0 ]; auto. absurd (Rabs (/ r) ^ 0 < Rabs (/ r) ^ S n0)%R; auto. replace (Rabs (/ r) ^ S n0)%R with 1%R. simpl in |- *; apply Rlt_irrefl; auto. rewrite Rabs_Rinv; auto. rewrite <- Rinv_pow; auto. rewrite RPow_abs; auto. rewrite H'0; rewrite Rabs_right; auto with real. apply Rlt_pow; auto with arith. rewrite Rabs_Rinv; auto. apply Rmult_lt_reg_l with (r := Rabs r). case (Rabs_pos r); auto. intros H'3; case Eq2; auto. rewrite Rmult_1_r; rewrite Rinv_r; auto with real. generalize H'; case n; auto. intros n0 H'0. cut (r <> 0%R); [ intros Eq1 | auto with real ]. 2: Contradict H'0; simpl in |- *; rewrite H'0; rewrite Rmult_0_l; auto with real. cut (Rabs r <> 0%R); [ intros Eq2 | apply Rabs_no_R0 ]; auto. absurd (Rabs r ^ 0 < Rabs r ^ S n0)%R; auto with real arith. repeat rewrite RPow_abs; rewrite H'0; simpl in |- *; auto with real. Qed. Theorem Zpower_NR0 : forall (e : BinInt.Z) (n : nat), (0 <= e)%Z -> (0 <= Zpower_nat e n)%Z. intros e n; elim n; unfold Zpower_nat in |- *; simpl in |- *; auto with zarith. Qed. Theorem Zpower_NR1 : forall (e : BinInt.Z) (n : nat), (1 <= e)%Z -> (1 <= Zpower_nat e n)%Z. intros e n; elim n; unfold Zpower_nat in |- *; simpl in |- *; auto with zarith. Qed. Hint Resolve Zpower_NR0 Zpower_NR1: zarith. Definition powerRZ (e : R) (n : BinInt.Z) := match n with | BinInt.Z0 => 1%R | BinInt.Zpos p => (e ^ BinPos.nat_of_P p)%R | BinInt.Zneg p => (/ e ^ BinPos.nat_of_P p)%R end. Theorem powerRZ_O : forall e : R, powerRZ e 0 = 1%R. simpl in |- *; auto. Qed. Theorem powerRZ_1 : forall e : R, powerRZ e (Zsucc 0) = e. simpl in |- *; auto with real. Qed. Theorem powerRZ_NOR : forall (e : R) (z : BinInt.Z), e <> 0%R -> powerRZ e z <> 0%R. intros e z; case z; simpl in |- *; auto with real. Qed. Hint Resolve powerRZ_O powerRZ_1 powerRZ_NOR: real. Theorem powerRZ_add : forall (e : R) (n m : BinInt.Z), e <> 0%R -> powerRZ e (n + m) = (powerRZ e n * powerRZ e m)%R. 
:= Func (existT _ 0 dum) Vector.nil. Definition f_P x y := Pred (existT _ 2 P) (Vector.cons x (Vector.cons y Vector.nil)). Notation "x ≡ y" := (Pred (existT _ 2 equiv) (Vector.cons x (Vector.cons y Vector.nil))) (at level 20). Notation "x ≢ y" := (¬ (x ≡ y)) (at level 20). Notation "x ≺ y" := (Pred (existT _ 2 less) (Vector.cons x (Vector.cons y Vector.nil))) (at level 20). Fixpoint tprep (x : list bool) (y : term) := match x with | nil => y | b::x => t_f b (tprep x y) end. Lemma tprep_eval D (I : interp D) rho x t : eval rho (tprep x t) = iprep x (eval rho t). Proof. induction x; cbn. - reflexivity. - rewrite IHx. reflexivity. Qed. Definition tenc (x : list bool) := tprep x t_e. Definition ax_P := ∀ ∀ f_P #1 #0 --> (#1 ≢ t_dum) ∧ (#0 ≢ t_dum). Definition ax_S1 := ∀ ¬ (#0 ≺ #0). Definition ax_S2 := ∀ ∀ ∀ #2 ≺ #1 --> #1 ≺ #0 --> #2 ≺ #0. Definition ax_HF1_true := ∀ t_f true #0 ≢ t_e. Definition ax_HF1_false := ∀ t_f false #0 ≢ t_e. Definition ax_HF2_true := ∀ ∀ t_f true #1 ≢ t_dum --> t_f true #1 ≡ t_f true #0 --> #1 ≡ #0. Definition ax_HF2_false := ∀ ∀ t_f false #1 ≢ t_dum --> t_f false #1 ≡ t_f false #0 --> #1 ≡ #0. Definition ax_HF2 := ∀ ∀ t_f true #1 ≡ t_f false #0 --> (t_f true #1 ≡ t_dum ∧ t_f false #0 ≡ t_dum). Definition ax_HF3_true := ∀ t_f true #0 ≢ t_dum --> #0 ≢ t_dum. Definition ax_HF3_false := ∀ t_f false #0 ≢ t_dum --> #0 ≢ t_dum. Definition ax_HI' c := (#1 ≡ tenc (fst c) ∧ #0 ≡ tenc (snd c)) ∨ (∃ ∃ #3 ≡ tprep (fst c) #1 ∧ #2 ≡ tprep (snd c) #0 ∧ f_P #1 #0 ∧ ((#1 ≺ #3 ∧ #0 ≡ #2) ∨ (#0 ≺ #2 ∧ #1 ≡ #3) ∨ (#1 ≺ #3 ∧ #0 ≺ #2))). Definition ax_HI (R : BSRS) := ∀ ∀ f_P #1 #0 --> list_or (map ax_HI' R). Definition finsat_formula (R : BSRS) := ax_P ∧ ax_S1 ∧ ax_S2 ∧ ax_HF1_true ∧ ax_HF1_false ∧ ax_HF2_true ∧ ax_HF2_false ∧ ax_HF2 ∧ ax_HF3_true ∧ ax_HF3_false ∧ ax_HI R ∧ ∃ f_P #0 #0. Theorem finsat_reduction R : dPCPb R <-> finsat (finsat_formula R). 
x, or zero x = x. Proof. intros. rewrite or_commut. apply or_zero. Qed.Theorem or_mone: forall x, or x mone = mone. Proof. bit_solve. Qed.Theorem or_idem: forall x, or x x = x. Proof. bit_solve. destruct (testbit x i); auto. Qed.Theorem and_or_distrib: forall x y z, and x (or y z) = or (and x y) (and x z). Proof. bit_solve. apply demorgan1. Qed.Corollary and_or_distrib_l: forall x y z, and (or x y) z = or (and x z) (and y z). Proof. intros. rewrite (and_commut (or x y)). rewrite and_or_distrib. f_equal; apply and_commut. Qed.Theorem or_and_distrib: forall x y z, or x (and y z) = and (or x y) (or x z). Proof. bit_solve. apply orb_andb_distrib_r. Qed.Corollary or_and_distrib_l: forall x y z, or (and x y) z = and (or x z) (or y z). Proof. intros. rewrite (or_commut (and x y)). rewrite or_and_distrib. f_equal; apply or_commut. Qed.Theorem and_or_absorb: forall x y, and x (or x y) = x. Proof. bit_solve. assert (forall a b, a && (a || b) = a) by destr_bool. auto. Qed.Theorem or_and_absorb: forall x y, or x (and x y) = x. Proof. bit_solve. assert (forall a b, a || (a && b) = a) by destr_bool. auto. Qed.Theorem xor_commut: forall x y, xor x y = xor y x. Proof. bit_solve. apply xorb_comm. Qed.Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z). Proof. bit_solve. apply xorb_assoc. Qed.Theorem xor_zero: forall x, xor x zero = x. Proof. bit_solve. apply xorb_false. Qed.Corollary xor_zero_l: forall x, xor zero x = x. Proof. intros. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_idem: forall x, xor x x = zero. Proof. bit_solve. apply xorb_nilpotent. Qed.Theorem xor_zero_one: xor zero one = one. Proof. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_one_one: xor one one = zero. Proof. apply xor_idem. Qed.Theorem xor_zero_equal: forall x y, xor x y = zero -> x = y. Proof. intros. apply same_bits_eq; intros. assert (xorb (testbit x i) (testbit y i) = false). rewrite <- bits_xor; auto. rewrite H. apply bits_zero. destruct (testbit x i); destruct (testbit y i); reflexivity || discriminate. Qed.Theorem xor_is_zero: forall x y, eq (xor x y) zero = eq x y. Proof. intros. predSpec eq eq_spec (xor x y) zero. - apply xor_zero_equal in H. subst y. rewrite eq_true; auto. - predSpec eq eq_spec x y. + elim H; subst y; apply xor_idem. + auto. Qed. Theorem and_xor_distrib: forall x y z, and x (xor y z) = xor (and x y) (and x z). 
destruct H7. unfold funcspec_constructor in H2. subst spec preP evP postP; simpl in *. destruct H7 as [Hx1 [Hx2 [Hx3 [Hx4 [Hx5 [Hx6 [Hx7 Hx8]]]]]]]. unfold INV. split. - subst. rewrite Hx5. clear Hx5. simpl. intros a. destruct (beq_dec sender a). + apply Nat.eqb_eq in H. subst a. rewrite (tmap_get_upd_eq _ _ _). auto. + rewrite (tmap_get_upd_ne _ _ _ _ H). rewrite (tmap_emp_zero _). unfold TMap.zero. unfold value_Range. omega. - exists _initialAmount. repeat split; auto. + apply Sum_sig in Hx5. trivial. + exists (m_sender msg). exists _initialAmount. exists _tokenName. exists _decimalUnits. exists _tokenSymbol. exists _unLockTime. unfold assert_genesis_event. rewrite H. trivial. Qed.Lemma step_contract_address_constant : forall env C msg C' E', step env C msg C' E' -> w_a C = w_a C'. Proof. intros. destruct C as [a S]. destruct C' as [a' S']. induction H; simpl; auto; intuition. Qed.Lemma steps_INV: forall ml env C E, INV env (w_st C) E -> forall env' C' E', steps env C ml env' C' E' -> INV env' (w_st C') (E ++ E'). Proof. induction ml. - intros. inversion_clear H0. destruct H2. subst. rewrite app_nil_r. trivial. - intros. inversion_clear H0. rename x into envx. rename a into msg. destruct H1 as [Cx [Ex [Ey [H1 [H2 [H3 H4]]]]]]. subst E'. assert (Hx : INV envx (w_st Cx) (E ++ Ex)). { assert (w_a C = w_a Cx). { apply step_contract_address_constant with env msg Ex. apply H1. } destruct C as [C_a C_st]. destruct Cx as [Cx_a Cx_st]. simpl. simpl in H. simpl in H0. generalize H. generalize H4. apply step_INV with C_a msg. subst Cx_a. apply H1. } substH IHml with (IHml envx Cx (E ++ Ex) Hx). rewrite app_assoc. apply IHml; trivial. Qed.Lemma INV_implies_totalSupply_fixed : forall env S E, INV env S E -> Sum (st_balances S) (st_totalSupply S). Proof. intros env S E HI. unfold INV in HI. destruct HI as [_ [total [Ht [HT HI]]]]. rewrite Ht in HT. trivial. Qed. Theorem Property_totalSupply_equal_to_sum_balances : forall env0 env msg ml C E C' E', create env0 msg C E -> env_step env0 env -> run env C ml C' E' -> Sum (st_balances (w_st C')) (st_totalSupply (w_st C')). Proof. intros env0 env msg ml C E C' E' Hc He Hr. unfold run in Hr. destruct Hr as [env' Hsteps]. apply INV_implies_totalSupply_fixed with env' (E++E'). substH Hc with (create_INV _ _ _ _ _ Hc He). eapply steps_INV; eauto. Qed. Theorem Property_totalSupply_fixed_transfer: forall env C C' E' msg to v spec preP evP postP, spec = funcspec_transfer to v (w_a C) env msg -> preP = spec_require spec -> evP = spec_events spec -> postP = spec_trans spec -> preP (w_st C) /\ evP (w_st C) E' /\ postP (w_st C) (w_st C') -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). 
eqb_leibniz in H0. subst. rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b0); intuition; rewrite H0 in H. discriminate. case_eq (eqb b1 b0); intuition. simpl. eapply IHls; intuition. simpl. eapply IHls; intuition. assert (a <> a0). intuition. subst. rewrite eqb_refl in H0. discriminate. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H3. subst. intuition. simpl. case_eq (eqb b1 b0); intuition. simpl. rewrite eqb_leibniz in H4. subst. specialize (in_impl_collidesWith _ _ ls _ H1 H2); intuition. unfold collidesWith in H4. destruct (findCollision_1 eqda eqdb ls a0 b0); discriminate. simpl. case_eq (findCollision_1 eqda eqdb ls a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). induction arr; intuition; simpl in *. discriminate. remember (split arr) as z. destruct z. simpl. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H0. intuition. rewrite H0 in H. right. eapply IHarr; intuition. eauto. Qed. Theorem arrayLookup_noCollision_eq_f : forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. induction x1; intuition; simpl in *. remember (split x1) as z. destruct z. simpl in *. unfold collidesWith in *. simpl in *. case_eq (eqb b2 b1); intuition. rewrite H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. 
1 + funs_size fds' + term_size e | Fnil => 1 end. Definition svalue_size (v: svalue) : nat := match v with | SVconstr t lv => 0 | SVfun t lv e => term_size e end. Definition svalue_inl_size (f:(positive*svalue)) (inl:b_map): nat := (if (get_b (fst f) inl) then 0 else svalue_size (snd f)). Theorem svalue_inl_le: forall i v im, svalue_inl_size (i,v) im <= svalue_size v. Proof. intros. unfold svalue_inl_size. simpl. destruct (get_b i im). apply Peano.le_0_n. auto. Defined. Lemma term_size_inline_letapp e x C y e' : inline_letapp e x = Some (C, y) -> term_size (C |[ e' ]|) <= term_size e + term_size e'. Proof. generalize C. induction e; intros C' Heq; simpl in *; try ((destruct (inline_letapp e x) as [ [C'' z'] | ] eqn:Heq''; try congruence); inv Heq; simpl; eauto using Peano.le_n_S). congruence. eapply Peano.le_n_S. specialize (IHe C'' (eq_refl)). lia. inv Heq. simpl. reflexivity. inv Heq. simpl. eauto. Defined. Definition list_inl_size (sub:list (positive*svalue)) (inl:b_map):= fold_right plus 0 (map (fun v => svalue_inl_size v inl) sub). Theorem list_inl_size_app: forall l l' inl, list_inl_size (l++l') inl = list_inl_size l inl + list_inl_size l' inl . Proof. induction l; intros. reflexivity. unfold list_inl_size. simpl. unfold list_inl_size in IHl. rewrite IHl. rewrite <- Nat.add_assoc. reflexivity. Qed. Definition sub_inl_size (sub:ctx_map) (inl:b_map):= fold_left plus (map (fun v => svalue_inl_size v inl) (M.elements sub)) 0. Theorem sub_inl_proof: forall sub inl, sub_inl_size sub inl = list_inl_size (M.elements sub) inl. Proof. unfold sub_inl_size, list_inl_size. intros. apply fold_symmetric; intros; lia. Qed. Theorem min_term_size: forall e, 1 <= term_size e. Proof. intro. destruct e; simpl; apply lt_le_S; apply Nat.lt_0_succ. Defined. Theorem min_funs_size: forall f, 1 <= funs_size f. Proof. destruct f; simpl; apply lt_le_S; apply Nat.lt_0_succ. Defined. Theorem funs_size_append: forall f2 f1, funs_size (fundefs_append f1 f2) = funs_size f1 + funs_size f2 - 1. Proof. induction f1; simpl; intros. rewrite IHf1. assert (Hf2 := min_funs_size f2). assert (Hf1 := min_funs_size f1). lia. lia. Defined. Definition term_sub_inl_size (esi: (exp * ctx_map * b_map)): nat := term_size (fst (fst esi)) + sub_inl_size (snd (fst esi)) (snd esi). Theorem NoDup_list_norepet: forall {A} (l:list A), NoDup l <-> Coqlib.list_norepet l. Proof. intros. induction l; split; intro; auto. constructor. constructor. inv H; constructor; eauto. apply IHl. auto. inv H; constructor; auto. apply IHl. auto. Qed. Theorem fold_right_plus_init: forall l n, fold_right plus n l = fold_right plus 0 l + n. Proof. induction l; intros. reflexivity. simpl. rewrite IHl. lia. Qed. Theorem svalue_inl_not: forall a x im, fst a <> x -> svalue_inl_size a (M.set x true im) = svalue_inl_size a im. 
Hstep as [ds' [dinv' [MATCH' [dtr' stp']]]]. econstructor 4; eauto. { apply stp'. } intro U''; specialize (Hsafe U''). destruct Hsafe as [[? [Hphi Hext]] Hsafe]. specialize (Hsafe _ Hphi [:: Some (ghost_PCM.ext_ref tt, NoneP)]) as (? & ? & ? & ? & Hr & ? & Hsafe); auto. { apply join_sub_refl. } eapply MTCH_tp_update in MATCH'; eauto. } Qed. Theorem erasure_safety: forall ge cd j js ds m n, Erasure.match_state ge cd j js m ds m -> jm_csafe js m n -> HybridMachineSig.HybridCoarseMachine.csafe ds m n. Proof. intros ? ? ? ? ? ? ? MATCH jsafe. inversion MATCH. subst. eapply erasure_safety'; eauto. Qed. End ErasureSafety.End ErasureSafety.Require Import VST.concurrency.juicy.semax_to_juicy_machine.Lemma no_locks_no_locks_perm : forall r, Parching.no_locks_perm r <-> initial_world.no_locks r. Proof. unfold Parching.no_locks_perm, initial_world.no_locks, perm_of_res_lock; split; intros. - destruct addr as (b, ofs); specialize (H b ofs). destruct (r @ (b, ofs)); try discriminate. destruct (perm_of_sh (Share.glb Share.Rsh sh0)) eqn: Hsh. destruct k; discriminate. { contradiction r0. apply perm_of_empty_inv in Hsh as ->; auto. } - specialize (H (b, ofs)). destruct (r @ (b, ofs)); auto. specialize (H sh r0). destruct k; auto. specialize (H n i p). contradiction; auto. Qed. Lemma juice2Perm_match : forall m r, access_cohere' m r -> Parching.match_rmap_perm r (juice2Perm r m, empty_map). Proof. split; auto; simpl. intros; apply juic2Perm_correct; auto. Qed.Section DrySafety. Variable (CPROOF : CSL_proof). Instance Sem : Semantics := ClightSemanticsForMachines.Clight_newSem (Clight.globalenv CPROOF.(CSL_prog)). Definition ge := Clight.globalenv CPROOF.(CSL_prog). Instance DTP : threadPool.ThreadPool.ThreadPool := Parching.DTP ge. Instance DMS : HybridMachineSig.MachineSig := Parching.DMS ge. Definition init_mem := proj1_sig (init_mem CPROOF). Definition init_rmap n := m_phi (initial_jm CPROOF n). Lemma init_match n : Parching.match_rmap_perm (init_rmap n) (getCurPerm init_mem, empty_map). Proof. split; auto; simpl. unfold init_rmap, initial_jm, spr. destruct (semax_prog.semax_prog_rule' _ _ _ _ _ _ _ _) as (? & ? & ? & s); simpl. destruct (s n tt) as (jm & ? & ? & ? & ? & ? & ?); simpl. destruct jm; simpl in *; subst; intros. rewrite <- (JMaccess (b, ofs)). unfold access_at, PMap.get; simpl. rewrite PTree.gmap1. fold init_mem; destruct ((snd (Mem.mem_access init_mem)) ! b); auto. Qed. Lemma init_no_locks n : Parching.no_locks_perm (init_rmap n). Proof. apply no_locks_no_locks_perm. unfold init_rmap, initial_jm, spr. destruct (semax_prog.semax_prog_rule' _ _ _ _ _ _ _ _) as (? & ? & ? & s); simpl. destruct (s n tt) as (jm & ? & ? & ? & ? & ? & ?); auto. Qed. Theorem dry_safety_initial_state (sch : HybridMachineSig.schedule) (n : nat) : HybridMachineSig.HybridCoarseMachine.csafe (sch, [::], DryHybridMachine.initial_machine(Sem := Sem) (getCurPerm init_mem) (initial_corestate CPROOF)) init_mem n. 
: Z. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith.Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Coercion Z_of_N: N >-> Z. Record Fbound : Set := Bound {vNum : positive; dExp : N}. Definition Fbounded (b : Fbound) (d : float) := (Zabs (Fnum d) < Zpos (vNum b))%Z /\ (- dExp b <= Fexp d)%Z. Theorem FboundedNum : forall (b : Fbound) (p : float), Fbounded b p -> (Zabs (Fnum p) < Zpos (vNum b))%Z. intros b p H; case H; intros H1 H2; case H1; auto. Qed. Theorem FboundedExp : forall (b : Fbound) (p : float), Fbounded b p -> (- dExp b <= Fexp p)%Z. intros b p H; case H; auto. Qed. Hint Resolve FboundedNum FboundedExp: float. Theorem isBounded : forall (b : Fbound) (p : float), {Fbounded b p} + {~ Fbounded b p}. intros b p; case (Z_le_gt_dec (Zpos (vNum b)) (Zabs (Fnum p))); intros H'. right; red in |- *; intros H'3; Contradict H'; auto with float zarith. case (Z_le_gt_dec (- dExp b) (Fexp p)); intros H'1. left; repeat split; auto with zarith. right; red in |- *; intros H'3; Contradict H'1; auto with float zarith. Qed. Theorem FzeroisZero : forall b : Fbound, Fzero (- dExp b) = 0%R :>R. intros b; unfold FtoRradix, FtoR in |- *; simpl in |- *; auto with real. Qed. Theorem FboundedFzero : forall b : Fbound, Fbounded b (Fzero (- dExp b)). intros b; repeat (split; simpl in |- *). replace 0%Z with (- 0%nat)%Z; [ idtac | simpl in |- *; auto ]. apply Zeq_le; auto with arith. Qed. Hint Unfold Fbounded. Theorem FboundedZeroSameExp : forall (b : Fbound) (p : float), Fbounded b p -> Fbounded b (Fzero (Fexp p)). intros b p H'; (repeat split; simpl in |- *; auto with float zarith). Qed. Theorem FBoundedScale : forall (b : Fbound) (p : float) (n : nat), Fbounded b p -> Fbounded b (Float (Fnum p) (Fexp p + n)). intros b p n H'; repeat split; simpl in |- *; auto with float. apply Zle_trans with (Fexp p); auto with float. pattern (Fexp p) at 1 in |- *; (replace (Fexp p) with (Fexp p + 0%nat)%Z; [ idtac | simpl in |- *; ring ]). apply Zplus_le_compat_l. apply inj_le; auto with arith. Qed. Theorem FvalScale : forall (b : Fbound) (p : float) (n : nat), Float (Fnum p) (Fexp p + n) = (powerRZ radix n * p)%R :>R. 
Set Warnings "-notation-overridden,-parsing". Require Export Logic. Require Coq.omega.Omega. Inductive ev : nat -> Prop := | ev_0 : ev 0 | ev_SS : forall n : nat, ev n -> ev (S (S n)).Fail Inductive wrong_ev (n : nat) : Prop := | wrong_ev_0 : wrong_ev 0 | wrong_ev_SS : forall n, wrong_ev n -> wrong_ev (S (S n)). Theorem ev_4 : ev 4. Proof. apply ev_SS. apply ev_SS. apply ev_0. Qed.Theorem ev_4' : ev 4. Proof. apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.Theorem ev_plus4 : forall n, ev n -> ev (4 + n). Proof. intros n. simpl. intros Hn. apply ev_SS. apply ev_SS. apply Hn. Qed. Theorem ev_double : forall n, ev (double n). Proof. Admitted. Theorem ev_minus2 : forall n, ev n -> ev (pred (pred n)). Proof. intros n E. inversion E as [| n' E']. - simpl. apply ev_0. - simpl. apply E'. Qed.Theorem ev_minus2' : forall n, ev n -> ev (pred (pred n)). Proof. intros n E. destruct E as [| n' E']. - simpl. apply ev_0. - simpl. apply E'. Qed.Theorem evSS_ev : forall n, ev (S (S n)) -> ev n.Proof. intros n E. destruct E as [| n' E']. - Abort.Theorem evSS_ev : forall n, ev (S (S n)) -> ev n. Proof. intros n E. inversion E as [| n' E']. apply E'. Qed.Theorem one_not_even : ~ ev 1. Proof. intros H. inversion H. Qed. Theorem SSSSev__even : forall n, ev (S (S (S (S n)))) -> ev n. Proof. Admitted.Theorem even5_nonsense : ev 5 -> 2 + 2 = 9. Proof. Admitted. Lemma ev_even_firsttry : forall n, ev n -> exists k, n = double k. Proof. intros n E. inversion E as [| n' E']. - exists 0. reflexivity. - simpl. assert (I : (exists k', n' = double k') -> (exists k, S (S n') = double k)). { intros [k' Hk']. rewrite Hk'. exists (S k'). reflexivity. } apply I. Admitted. Lemma ev_even : forall n, ev n -> exists k, n = double k. Proof. intros n E. induction E as [|n' E' IH]. - exists 0. reflexivity. - destruct IH as [k' Hk']. rewrite Hk'. exists (S k'). reflexivity. Qed.Theorem ev_even_iff : forall n, ev n <-> exists k, n = double k. Proof. intros n. split. - apply ev_even. - intros [k Hk]. rewrite Hk. apply ev_double. Qed. Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m). 
length (bsm_instr_compile lnk i ii) = bsm_instr_compile_length ii. Proof. destruct ii as [ | ? [] ]; simpl; auto. Qed. Fact bsm_instr_compile_length_geq ii : 1 <= bsm_instr_compile_length ii. Proof. destruct ii as [ | ? [] ]; simpl; auto; lia. Qed. Hint Resolve bsm_instr_compile_length_eq bsm_instr_compile_length_geq : core. Lemma bsm_instr_compile_sound : instruction_compiler_sound bsm_instr_compile (@bsm_sss _) (@mm_sss _) bsm_state_enc. Proof using Hvr1 Hvr2 Hvr3 Hv12 Hv13 Hv23 Hreg. intros lnk I i1 v1 i2 v2 w1 H; revert H w1. change v1 with (snd (i1,v1)) at 2. change i1 with (fst (i1,v1)) at 2 3 4 6 7 8. change v2 with (snd (i2,v2)) at 2. change i2 with (fst (i2,v2)) at 2. generalize (i1,v1) (i2,v2); clear i1 v1 i2 v2. induction 1 as [ i p j k v Hv | i p j k v ll Hll | i p j k v ll Hll | i p [] v ]; simpl; intros w1 H0 H; generalize H; intros (H1 & H2 & Htmp3 & H3). + exists w1; split; auto. apply mm_pop_void_progress; auto using Hv12, Hvr1, Hvr2. rewrite H3, Hv; auto. + exists (w1[(stack_enc ll)/reg p]); repeat split; auto; rew vec. * apply mm_pop_Zero_progress; auto using Hv12, Hvr1, Hvr2. rewrite H3, Hll; auto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc ll)/reg p]); repeat split; auto; rew vec. * apply mm_pop_One_progress; auto using Hv12, Hvr1, Hvr2. rewrite H3, Hll; auto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc (One::v#>p))/reg p]); repeat split; auto; rew vec. 2:{ rewrite vec_change_neq. 2: congruence. eauto. } 2:{ rewrite vec_change_neq. 2: congruence. eauto. } 2:{ rewrite vec_change_neq. 2: congruence. eauto. } rewrite H0; apply mm_push_One_progress; auto using Hv12, Hvr1, Hvr2. intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc (Zero::v#>p))/reg p]); repeat split; auto; rew vec. rewrite H0; apply mm_push_Zero_progress; auto using Hv12, Hvr1, Hvr2. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * intros q; dest p q. assert (reg p <> reg q); rew vec. Qed. Hint Resolve bsm_instr_compile_sound : core. Theorem bsm_mm_compiler : compiler_t (@bsm_sss _) (@mm_sss _) bsm_state_enc. 
n using nat_double_rec. destruct x; auto. destruct x; auto. intros n0 m H; case H. intro eq; rewrite eq ; auto. intro neg; right; red ; injection 1; auto. Defined.Definition eq_nat_dec' : forall n p:nat, {n=p}+{n <> p}. decide equality. Defined.Print Acc. Require Import Minus.Fail Fixpoint div (x y:nat){struct x}: nat := if eq_nat_dec x 0 then 0 else if eq_nat_dec y 0 then x else S (div (x-y) y). Lemma minus_smaller_S: forall x y:nat, x - y < S x. Proof. intros x y; pattern y, x; elim x using nat_double_ind. destruct x0; auto with arith. simpl; auto with arith. simpl; auto with arith. Qed.Lemma minus_smaller_positive : forall x y:nat, x <>0 -> y <> 0 -> x - y < x. Proof. destruct x; destruct y; ( simpl;intros; apply minus_smaller_S || intros; absurd (0=0); auto). Qed.Definition minus_decrease : forall x y:nat, Acc lt x -> x <> 0 -> y <> 0 -> Acc lt (x-y). Proof. intros x y H; case H. intros Hz posz posy. apply Hz; apply minus_smaller_positive; assumption. Defined.Print minus_decrease.Fixpoint div_aux (x y:nat)(H: Acc lt x):nat. refine (if eq_nat_dec x 0 then 0 else if eq_nat_dec y 0 then y else div_aux (x-y) y _). apply (minus_decrease x y H);assumption. Defined. Print div_aux. Require Import Wf_nat. Definition div x y := div_aux x y (lt_wf x).Extraction div. Extraction div_aux.Lemma vector0_is_vnil : forall (A:Set)(v:Vector.t A 0), v = Vector.nil A. Proof. intros A v;inversion v. Abort. Fail Lemma vector0_is_vnil_aux : forall (A:Set)(n:nat)(v:Vector.t A n), n= 0 -> v = Vector.nil A. Require Import JMeq.Lemma vector0_is_vnil_aux : forall (A:Set)(n:nat)(v:Vector.t A n), n= 0 -> JMeq v (Vector.nil A). Proof. destruct v. auto. intro; discriminate. Qed.Lemma vector0_is_vnil : forall (A:Set)(v:Vector.t A 0), v = Vector.nil A. Proof. intros a v;apply JMeq_eq. apply vector0_is_vnil_aux. trivial. Qed. Arguments Vector.cons [A] _ [n]. Arguments Vector.nil [A]. Arguments Vector.hd [A n]. Arguments Vector.tl [A n].Definition Vid : forall (A : Type)(n:nat), Vector.t A n -> Vector.t A n. Proof. destruct n; intro v. exact Vector.nil. exact (Vector.cons (Vector.hd v) (Vector.tl v)). Defined.Eval simpl in (fun (A:Set)(v:Vector.t A 0) => (Vid _ _ v)).Eval simpl in (fun (A:Set)(v:Vector.t A 0) => v).Lemma Vid_eq : forall (n:nat) (A:Type)(v:Vector.t A n), v=(Vid _ n v). Proof. destruct v. reflexivity. reflexivity. Defined.Theorem zero_nil : forall A (v:Vector.t A 0), v = Vector.nil. Proof. intros. change (Vector.nil (A:=A)) with (Vid _ 0 v). apply Vid_eq. Defined. Theorem decomp : forall (A : Set) (n : nat) (v : Vector.t A (S n)), v = Vector.cons (Vector.hd v) (Vector.tl v). 
_ (f_oracle GNMAC _ x) tt; ret b. Definition A_HMAC := x <-$ {0, 1}^b; [b, _] <-$2 A _ _ (f_oracle GHMAC _ x) tt; ret b. Theorem GHMAC_2K_GNMAC_equiv : forall k ls, let (k_Out, k_In) := splitVector b b k in let k' := Vector.append (h iv k_Out) (h iv k_In) in GHMAC_2K k ls = GNMAC k' ls. intuition. unfold GHMAC_2K, HMAC_spec.GHMAC_2K, GNMAC, HMAC_spec.GNMAC, b, HMAC_spec.b. remember (splitVector (c + p) (c + p) k) as z. destruct z. rewrite splitVector_append. unfold app_fpad, hash_words. simpl. trivial. Qed. Definition HMAC_RKA_A : OracleComp (Bvector b * Bvector c) (Bvector c) bool := k_Out <--$ OC_Query _ (opad, iv); k_In <--$ OC_Query _ (ipad, iv); [b, _] <--$2 $ A _ _ (f_oracle GNMAC _ (Vector.append k_Out k_In)) tt; $ ret b. Local Opaque evalDist. Theorem A_HMAC_RKA_equiv : Pr[A_HMAC] == Pr[RKA_G0 _ (Rnd b) (dual_f h) (BVxor b) HMAC_RKA_A]. unfold A_HMAC, RKA_G0, GHMAC, HMAC_RKA_A, GNMAC, HMAC_spec.GHMAC. comp_skip. simpl. repeat ( inline_first; comp_simp). comp_skip. eapply comp_spec_eq_impl_eq. eapply comp_spec_consequence. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => a = b)). trivial. intuition. unfold f_oracle. eapply comp_spec_ret; intuition. simpl. specialize (GHMAC_2K_GNMAC_equiv (Vector.append (x xor opad) (x xor ipad)) a0); intuition. rewrite splitVector_append in H1. unfold dual_f. eapply eq_trans. eapply H1. unfold GNMAC. f_equal. f_equal. f_equal. eapply BVxor_comm. f_equal. eapply BVxor_comm. intuition. destruct b2; simpl in *; subst; intuition. comp_simp. simpl. inline_first. comp_simp. intuition. Qed. Definition A_NMAC_G1 := x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_0 := [x1, x2] <-$2 ( x <-$ {0, 1}^(c + c); ret (splitVector c c x)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_1 := [x1, x2] <-$2 ( x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; ret (x1, x2)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Theorem A_NMAC_G1_0_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1_0]. unfold A_NMAC, A_NMAC_G1_0. inline_first. comp_skip. remember (splitVector c c x) as z. comp_simp. erewrite append_splitVector. reflexivity. trivial. Qed. Theorem A_NMAC_G1_0_1_equiv : Pr[A_NMAC_G1_0] == Pr[A_NMAC_G1_1]. unfold A_NMAC_G1_0, A_NMAC_G1_1. comp_skip. eapply Rnd_split_equiv. reflexivity. Qed. Theorem A_NMAC_G1_1_equiv : Pr[A_NMAC_G1_1] == Pr[A_NMAC_G1]. unfold A_NMAC_G1_1, A_NMAC_G1. inline_first. comp_skip. inline_first. comp_skip. Qed. Theorem A_NMAC_G1_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1]. rewrite A_NMAC_G1_0_equiv. rewrite A_NMAC_G1_0_1_equiv. apply A_NMAC_G1_1_equiv. Qed. Theorem xor_1_1 : forall (n : nat)(x y z : Bvector n), BVxor _ y x = BVxor _ z x -> y = z. 
_ _ _ _ _ _ _ _ _ cs n); auto. apply Rstar_0; auto. Qed. Theorem red_id : forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), red (spolyp a a) aL. intros a P; case a. unfold red in |- *; simpl in |- *; auto. intros x H'. apply rstar_rtopO; auto. apply spolyf_canonical with (1 := cs); auto. apply Rstar_0; auto. apply spolyf_pO with (1 := cs); auto. Qed. Theorem inP_reduce : forall P Q : list (poly A0 eqA ltM), (forall a : list (Term A n), inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) -> forall a b : list (Term A n), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b. intros P Q H' a b H'0; elim H'0; auto. intros a0 b0 nZb p q r H'1 H'2 H'3; auto. apply reducetop with (b := b0) (nZb := nZb) (q := q); auto. Qed. Theorem inP_reduceplus : forall P Q : list (poly A0 eqA ltM), (forall a : list (Term A n), inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) -> forall a b : list (Term A n), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b. intros P Q H' a b H'0; elim H'0; auto. intros; apply Rstar_0; auto. intros x y z H'1 H'2 H'3. apply Rstar_n with (y := y); auto. apply inP_reduce with (Q := Q); auto. Qed. Theorem inP_reducestar : forall P Q : list (poly A0 eqA ltM), (forall a : list (Term A n), inPolySet A A0 eqA n ltM a Q -> inPolySet A A0 eqA n ltM a P) -> forall a b : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P a b. intros P Q H' a b H'0; inversion H'0; auto. apply inP_reduceplus with (Q := Q); auto. Qed. Theorem red_incl : forall (a : poly A0 eqA ltM) (p q : list (poly A0 eqA ltM)), incl p q -> red a p -> red a q. 
replace (Q ∨ P) with (P ∨ Q) in n4_22c by now apply n4_22c. exact n4_22c. Qed. Theorem n4_73 : ∀ P Q : Prop, Q → (P ↔ (P ∧ Q)). Proof. intros P Q. specialize Simp2_02 with P Q. intros Simp2_02a. specialize n4_71 with P Q. intros n4_71a. replace ((P → Q) ↔ (P ↔ P ∧ Q)) with (((P→Q)→(P↔P∧Q))∧((P↔P∧Q)→(P→Q))) in n4_71a by now rewrite Equiv4_01. specialize Simp3_26 with ((P → Q) → P ↔ P ∧ Q) (P ↔ P ∧ Q → P → Q). intros Simp3_26a. MP Simp3_26a n4_71a. Syll Simp2_02a Simp3_26a Sa. exact Sa. Qed.Theorem n4_74 : ∀ P Q : Prop, ¬P → (Q ↔ (P ∨ Q)). Proof. intros P Q. specialize n2_21 with P Q. intros n2_21a. specialize n4_72 with P Q. intros n4_72a. apply propositional_extensionality in n4_72a. replace (P → Q) with (Q ↔ P ∨ Q) in n2_21a by now apply n4_72a. exact n2_21a. Qed.Theorem n4_76 : ∀ P Q R : Prop, ((P → Q) ∧ (P → R)) ↔ (P → (Q ∧ R)). Proof. intros P Q R. specialize n4_41 with (¬P) Q R. intros n4_41a. replace (¬P ∨ Q) with (P→Q) in n4_41a by now rewrite Impl1_01. replace (¬P ∨ R) with (P→R) in n4_41a by now rewrite Impl1_01. replace (¬P ∨ Q ∧ R) with (P → Q ∧ R) in n4_41a by now rewrite Impl1_01. specialize n4_21 with ((P → Q) ∧ (P → R)) (P → Q ∧ R). intros n4_21a. apply propositional_extensionality in n4_21a. replace ((P → Q ∧ R) ↔ (P → Q) ∧ (P → R)) with ((P → Q) ∧ (P → R) ↔ (P → Q ∧ R)) in n4_41a by now apply n4_41a. exact n4_41a. Qed.Theorem n4_77 : ∀ P Q R : Prop, ((Q → P) ∧ (R → P)) ↔ ((Q ∨ R) → P). Proof. intros P Q R. specialize n3_44 with P Q R. intros n3_44a. specialize n2_2 with Q R. intros n2_2a. specialize Add1_3 with Q R. intros Add1_3a. specialize Syll2_06 with Q (Q ∨ R) P. intros Syll2_06a. MP Syll2_06a n2_2a. specialize Syll2_06 with R (Q ∨ R) P. intros Syll2_06b. MP Syll2_06b Add1_3a. Conj Syll2_06a Syll2_06b Ca. specialize Comp3_43 with ((Q ∨ R)→P) (Q→P) (R→P). intros Comp3_43a. MP Comp3_43a Ca. clear n2_2a. clear Add1_3a. clear Ca. clear Syll2_06a. clear Syll2_06b. Conj n3_44a Comp3_43a Cb. Equiv Cb. exact Cb. Qed. Theorem n4_78 : ∀ P Q R : Prop, ((P → Q) ∨ (P → R)) ↔ (P → (Q ∨ R)). 
llist (b %- (v1, v2)) n' p ba. Axiom llist_nonempty_bwd : forall b n (fr ba : W), fr <> 0 -> focusOnFront -> (Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba) ===> llist b n fr ba. Axiom llist_end_bwd : forall (ba : W) n (fr : W) b, fr <> 0 -> focusOnBack -> (Ex v1, Ex v2, Ex v1', Ex v2', Ex n', Ex p, [| n = S (S n') |] * [| (v1', v2') %in b |] * [| (v1, v2) %in b %- (v1', v2')|] * lseg (b %- (v1, v2) %- (v1', v2')) n' fr p * [| p <> 0 |] * [| freeable p 3 |] * (p ==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. End QUEUE.Module Queue : QUEUE. Open Scope Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). 
D)(E F S: Set)(eqds : EqDec S)(ls1 : list A)(ls2 : list B)(c1 : A -> Comp C)(c2 : B -> OracleComp E F D)o (s : S), list_pred P1 ls1 ls2 -> (forall a b z, P1 a b -> comp_spec (fun x y => P2 x (fst y)) (c1 a) (c2 b _ _ o z)) -> comp_spec (fun a b => list_pred P2 a (fst b)) (compMap _ c1 ls1) ((oc_compMap _ c2 ls2) _ _ o s). induction ls1; inversion 1; subst; intuition; simpl in *. comp_simp. eapply comp_spec_ret; simpl; econstructor. simpl. comp_skip. comp_simp. comp_skip. comp_simp. eapply comp_spec_ret; intuition. simpl. econstructor; eauto. Qed.Theorem oc_compMap_eq : forall (A B C D : Set){eqd : EqDec D}(f1 f2 : A -> OracleComp B C D)(ls : list A) (S : Set){eqds : EqDec S} o (s : S), (forall s a, comp_spec eq ((f1 a) _ _ o s) ((f2 a) _ _ o s)) -> comp_spec eq ((oc_compMap _ f1 ls) _ _ o s) ((oc_compMap _ f2 ls) _ _ o s). induction ls; intuition; simpl in *. comp_simp. eapply comp_spec_eq_refl. comp_skip. comp_skip. comp_simp. eapply comp_spec_eq_refl. Qed.Require Import FCF.PRF.Theorem compMap_randomFunc_NoDup : forall (A B C: Set){eqda : EqDec A}{eqdb : EqDec B}{eqdc : EqDec C}(ls : list A)(f : A -> B -> Comp C)(rndB : Comp B)(lsf : list (A * B)), NoDup ls -> (forall a, In a ls -> arrayLookup _ lsf a = None) -> comp_spec (fun a b => fst a = fst b) ((oc_compMap _ (fun x => y <--$ query x; $ f x y) ls) _ _ (@randomFunc A B rndB _) lsf) ((oc_compMap _ (fun x => y <--$ query x; $ f x y) ls) _ _ (fun s a => b <-$ rndB; ret (b, s)) tt). induction ls; intuition; simpl in *. comp_simp. eapply comp_spec_ret; intuition. inversion H; clear H; subst. simpl; inline_first. unfold randomFunc. rewrite H0. inline_first. comp_skip. comp_simp. inline_first. comp_skip. comp_simp. comp_skip. eapply IHls; intuition. simpl. case_eq (eqb a0 a); intuition. rewrite eqb_leibniz in H7. subst. intuition. comp_simp. simpl in *; subst. eapply comp_spec_ret; intuition. intuition. Qed.Theorem oc_compMap_wf : forall (A B C D : Set)(eqd : EqDec B)(c : A -> OracleComp C D B) ls, (forall a, In a ls -> well_formed_oc (c a)) -> well_formed_oc (oc_compMap eqd c ls). induction ls; intuition; simpl in *; econstructor; wftac; intuition. Qed. Theorem compFold_oc_equiv_h : forall (A B S : Set)(eqdb : EqDec B)(eqds : EqDec S)(O : S -> A -> Comp (B * S))(lsa : list A)(initS : S)(lsb : list B), comp_spec eq (compFold _ (fun (acc : list B * S) (d : A) => [rs, s]<-2 acc; z <-$ O s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (lsb, initS) lsa) ([lsb', s'] <-$2 ((oc_compMap _ (fun a : A => query a) lsa) S _ O initS); ret (lsb ++ lsb', s')). 
intros. assert (~Col A B D). eauto with Geom. unfold parallelogram in *. intros. decompose [and] H. repeat split; Geometry. Qed.Hint Resolve para_2: Geom.Theorem para_3 : forall A B C D : Point, parallelogram A B C D -> parallelogram D C B A. Proof. intros. assert (~Col D C B). eauto with Geom. unfold parallelogram in *. intros. decompose [and] H. repeat split; Geometry. Qed.Hint Resolve para_3: Geom.Theorem para_4 : forall A B C D : Point, parallelogram A B C D -> parallelogram C B A D. Proof. intros. assert (~Col D C B). eauto with Geom. unfold parallelogram in *. intros. decompose [and] H. repeat split; Geometry. Qed.Hint Resolve para_4: Geom. Theorem not_para_eq_1 : forall A B C, ~ parallelogram A A B C. Proof. intuition idtac. assert (~ Col A A C). eauto with Geom. intuition. Qed.Theorem not_para_eq_2 : forall A B C, ~ parallelogram A B C C. Proof. intuition idtac. assert (~ Col B C C). eauto with Geom. intuition. Qed. Theorem not_para_eq_3 : forall A B C, ~ parallelogram A B C A. Proof. intuition idtac. assert (~ Col A B A). eauto with Geom. intuition. Qed.Theorem not_para_eq_4 : forall A B C, ~ parallelogram A B B C. Proof. intuition idtac. assert (~ Col A B B). eauto with Geom. intuition. Qed.Theorem not_para_eq_5 : forall A B C, ~ parallelogram A B A C. Proof. intuition idtac. assert (~ Col A A C). eauto with Geom. intuition. Qed. Theorem not_para_eq_6 : forall A B C, ~ parallelogram A B C B. Proof. intuition idtac. assert (~ Col B C B). eauto with Geom. intuition. Qed. Hint Resolve not_para_eq_1 not_para_eq_2 not_para_eq_3 not_para_eq_4 not_para_eq_5 not_para_eq_6 : Geom. Theorem para_not_eq_1 : forall A B C D, parallelogram A B C D -> A<>B. Proof. intros. unfold not;intro. subst A. cut (~parallelogram B B C D). auto. Geometry. Qed.Theorem para_not_eq_2 : forall A B C D, parallelogram A B C D -> A<>C. Proof. intros. unfold not;intro. subst A. cut (~parallelogram C B C D). auto. Geometry. Qed.Theorem para_not_eq_3 : forall A B C D, parallelogram A B C D -> A<>D. Proof. intros. unfold not;intro. subst A. cut (~parallelogram D B C D). auto. Geometry. Qed.Theorem para_not_eq_4 : forall A B C D, parallelogram A B C D -> B<>C. Proof. intros. unfold not;intro. subst B. cut (~parallelogram A C C D). auto. Geometry. Qed. Theorem para_not_eq_5 : forall A B C D, parallelogram A B C D -> B<>D. 
tg' + length tg) (length tu) s) t. Proof. induction s; simpl; intros; think; auto. { consider (NPeano.ltb x (length tg)); intros; simpl. repeat rewrite nth_error_app_L in * by omega. reflexivity. consider (NPeano.ltb x (length tg' + length tg)); simpl; intros. repeat rewrite nth_error_app_R in * by omega. repeat rewrite nth_error_app_L in * by omega. repeat rewrite nth_error_app_R in * by omega. cutrewrite (length tu + x - length tg - length tu = x - length tg); [ | omega ]. reflexivity. repeat (rewrite nth_error_app_R in * by omega). cutrewrite (x + length tg - (length tg' + length tg) - length tg = x - length tg - length tg'); [ | omega ]. reflexivity. } { consider (NPeano.ltb x (length tu)); intros; simpl. rewrite nth_error_app_L in * by omega. reflexivity. rewrite nth_error_app_R in * by omega. repeat rewrite nth_error_past_end by omega. auto. } { destruct (nth_error tf f); auto. destruct (tvar_seqb t (TRange t0)); auto. rewrite all2_map_1. destruct t0; simpl in *. clear - H; generalize dependent TDomain0; induction H; destruct TDomain0; simpl; intros; auto. think. reflexivity. } Qed. Lemma nth_error_length : forall T (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n. Proof. induction ls; simpl; intros. rewrite Plus.plus_0_r. auto. cutrewrite (n + S (length ls) = S n + length ls); [ | omega ]. simpl. auto. Qed. Fixpoint forallEach (ls : variables) : (env -> Prop) -> Prop := match ls with | nil => fun cc => cc nil | a :: b => fun cc => forall x : tvarD a, forallEach b (fun r => cc (existT _ a x :: r)) end. Theorem forallEach_sem : forall ls P, forallEach ls P <-> (forall env, typeof_env env = ls -> P env). Proof. induction ls; simpl; split; intros. destruct env0; auto. simpl in *; congruence. eapply H; reflexivity. destruct env0; simpl in *; try congruence. inversion H0; clear H0; subst. specialize (H (projT2 s)). eapply IHls in H; eauto. destruct s; simpl in *; auto. eapply IHls. intros. subst. eapply H. auto. Qed. Fixpoint existsEach (ls : variables) : (env.env -> Prop) -> Prop := match ls with | nil => fun cc => cc nil | a :: b => fun cc => exists x : tvarD a, existsEach b (fun r => cc (existT _ a x :: r)) end. Theorem existsEach_sem : forall ls P, existsEach ls P <-> (exists env, typeof_env env = ls /\ P env). 
_ |- _ => rename H into Hp; repeat rewrite <- Hp in * end. autorewrite with lists in *. cbn [length] in *. repeat rewrite Nat.add_sub in *. rewrite skipn_app in *. cancel. + erewrite skipn_selN_skipn with (l := firstn _ (skipn _ fsl)) at 1. erewrite skipn_selN_skipn with (l := firstn _ (skipn _ l_part)) at 1. cbn [combine]. rewrite listmatch_cons. cancel. all: omega. + erewrite skipn_selN_skipn with (off := length prefix). rewrite pred_fold_left_cons. cancel. reflexivity. omega. + step. repeat match goal with |- context [?b + S ?a - ?a] => replace (b + S a - a) with (b + 1) by omega end. rewrite skipn_app_r_ge by omega. rewrite minus_plus. rewrite <- plus_n_Sm, <- plus_n_O. rewrite indrep_n_tree_0. cancel. repeat match goal with |- context [?b + S ?a - ?a] => replace (b + S a - a) with (b + 1) by omega end. rewrite <- plus_n_Sm, <- plus_n_O. cancel. + cancel. - step. match goal with H: context [lift_empty] |- _ => destruct_lift H end. rewrite combine_length_eq in * by auto. repeat rewrite upd_range_eq_upd_range' by omega. unfold upd_range'. repeat rewrite combine_app. repeat rewrite skipn_skipn. replace (z0 + z) with (z + z0) in * by omega. rewrite firstn_combine_comm, skipn_combine by auto. repeat rewrite <- listmatch_app; cancel. repeat rewrite Nat.sub_0_r. repeat rewrite skipn_oob by indrep_n_tree_bound. rewrite listmatch_indrep_n_tree_empty'. unfold listmatch; cancel. autorewrite with lists; auto. indrep_n_tree_bound. autorewrite with lists. match goal with H: context [lift_empty] |- _ => destruct_lift H end. rewrite combine_length_eq in * by auto. rewrite firstn_length_l, skipn_length by omega. omega. repeat rewrite pred_fold_left_app. cancel. rewrite skipn_skipn. rewrite skipn_oob by indrep_n_tree_bound. rewrite pred_fold_left_repeat_emp. cancel. - cancel. eauto using LOG.intact_hashmap_subset. Grab Existential Variables. all : eauto; split. Qed. Local Hint Extern 1 ({{_}} Bind (indclear_aligned _ _ _ _ _ _ _ ) _) => apply indclear_aligned_ok : prog. Definition update_block lxp bxp bn contents new ms := If (list_eq_dec waddr_eq_dec new (repeat $0 NIndirect)) { ms <- BALLOCC.free lxp bxp bn ms; Ret ^(ms, 0) } else { If (list_eq_dec waddr_eq_dec contents new) { Ret ^(ms, bn) } else { lms <- IndRec.write lxp bn new (BALLOCC.MSLog ms); Ret ^(BALLOCC.upd_memstate lms ms, bn) } }. Lemma indrep_n_helper_valid_sm: forall Fs bxp ir l, ir <> 0 -> indrep_n_helper Fs bxp ir l =p=> indrep_n_helper Fs bxp ir l * [[ Fs <=p=> ir |->? ]]. Proof. unfold indrep_n_helper. intros. destruct addr_eq_dec; try congruence. cancel. Qed. Theorem update_block_ok : forall lxp bxp ir indbns indbns' ms, {< F Fm Fs IFs m0 sm m freelist, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (BALLOCC.MSLog ms) sm hm * [[ BALLOCC.bn_valid bxp ir ]] * [[ IndRec.items_valid ir indbns' ]] * [[[ m ::: (Fm * indrep_n_helper IFs bxp ir indbns) * BALLOCC.rep bxp freelist ms ]]] * [[ (Fs * BALLOCC.smrep freelist * IFs)%pred sm ]] POST:hm' RET: ^(ms, ir') exists m' freelist' IFs', LOG.rep lxp F (LOG.ActiveTxn m0 m') (BALLOCC.MSLog ms) sm hm' * [[[ m' ::: (Fm * indrep_n_helper IFs' bxp ir' indbns' * BALLOCC.rep bxp freelist' ms) ]]] * [[ (Fs * BALLOCC.smrep freelist' * IFs')%pred sm ]] * [[ incl freelist freelist' ]] * ([[ ir' = 0 ]] \/ [[ ir' = ir ]]) CRASH:hm' LOG.intact lxp F m0 sm hm' >} update_block lxp bxp ir indbns indbns' ms. 
cs]. unfold hide; simpl; f_equal; apply M.subtractKV_idempotent. Qed.Lemma hide_empty: forall a, hide {| annot := a; defs := []%fmap; calls := []%fmap |} = {| annot := a; defs := []%fmap; calls := []%fmap |}. Proof. reflexivity. Qed.Lemma step_empty: forall m o a, (a = None \/ a = Some None) -> Step m o []%fmap {| annot := a; defs := []%fmap; calls := []%fmap |}. Proof. intros; apply step_consistent. rewrite <-hide_empty. constructor; [|unfold wellHidden; cbn; split; apply M.KeysDisj_empty]. destruct H; subst. - constructor. - eapply SubstepsCons. + apply SubstepsNil. + apply EmptyRule. + repeat split; auto. + reflexivity. + reflexivity. Qed.Lemma step_hide: forall m o u l, Step m o u l -> hide l = l. Proof. intros; apply step_consistent in H; inv H. rewrite <-hide_idempotent; auto. Qed.Inductive HiddenLabelSeq: LabelSeqT -> Prop := | HLSNil: HiddenLabelSeq nil | HLSCons: forall l ll, HiddenLabelSeq ll -> hide l = l -> HiddenLabelSeq (l :: ll).Lemma behavior_hide: forall m n ll, Behavior m n ll -> HiddenLabelSeq ll. Proof. intros; inv H. induction HMultistepBeh; [constructor|]. constructor; auto. eapply step_hide; eauto. Qed.Section EmptyDefs. Variable m: Modules. Variable o: RegsT. Variable defsZero: getDefsBodies m = nil. Theorem substepsInd_zero u l: SubstepsInd m o u l -> defs l = M.empty _ /\ Substep m o u match annot l with | None => Meth None | Some r => Rle r end (calls l). Proof. intros si. dependent induction si. - constructor; econstructor; eauto. - dest; destruct l; subst. inv H; simpl in *; repeat rewrite M.union_empty_L; constructor; auto; repeat rewrite M.union_empty_R; unfold CanCombineUUL in *; simpl in *; dest. + destruct annot; intuition. inversion H4. econstructor; eauto. + destruct annot; auto. + destruct annot. * intuition. * inversion H4. rewrite M.union_empty_L, M.union_empty_R. econstructor; eauto. + rewrite defsZero in *. intuition. + rewrite defsZero in *. intuition. Qed. Theorem substepsInd_zero_hide u l: SubstepsInd m o u l -> hide l = l. Proof. intros si. apply substepsInd_zero in si; dest. unfold hide; destruct l; simpl in *; subst. rewrite M.subtractKV_empty_1. rewrite M.subtractKV_empty_2. reflexivity. Qed. Theorem step_zero u l: Step m o u l -> defs l = M.empty _ /\ Substep m o u match annot l with | None => Meth None | Some r => Rle r end (calls l). Proof. intros si. apply step_consistent in si. inv si. apply substepsInd_zero. rewrite substepsInd_zero_hide with (u := u); auto. Qed. Theorem substepZero_imp_step u a cs: Substep m o u a cs -> Step m o u (getLabel a cs). 
-> r -> r) -> (a -> r) -> r -> Bag a -> r := fix referenceFoldBag arg_27__ arg_28__ arg_29__ arg_30__ := match arg_27__ , arg_28__ , arg_29__ , arg_30__ with | t , u , e , Mk_EmptyBag => e | t , u , e , (Mk_UnitBag x) => u x | t , u , e , (Mk_TwoBags b1 b2) => t (referenceFoldBag t u e b1) (referenceFoldBag t u e b2) | t , u , e , (Mk_ListBag xs) => Coq.Lists.List.fold_right (Coq.Program.Basics.compose t u) e xs end. Theorem referenceFoldBag_ok {A R} (f : R -> R -> R) (u : A -> R) (z : R) (b : Bag A) : associative f -> right_id z f -> left_id z f -> referenceFoldBag f u z b = fold_right f z (map u (bagToList b)). Proof. move=> f_assoc z_right_id z_left_id. elim: b => [| x | l IHl r IHr | xs] //=. - by rewrite bagToList_TwoBags IHl IHr -fold_right_fold_right // map_app fold_right_app. - by rewrite bagToList_ListBag fold_right_map. Qed.Corollary foldBag_is_referenceFoldBag_if_id {A R} (f : R -> R -> R) (u : A -> R) (z : R) (b : Bag A) : associative f -> right_id z f -> left_id z f -> foldBag f u z b = referenceFoldBag f u z b. Proof. move=> f_assoc z_right_id z_left_id. rewrite foldBag_ok // referenceFoldBag_ok //. Qed.Corollary foldBag_isn't_referenceFoldBag_unless_id {R} (f : R -> R -> R) (z : R) : associative f -> (exists x, f x z <> x) \/ (exists x, f z x <> x) -> exists {A} (u : A -> R) (b : Bag A), foldBag f u z b <> referenceFoldBag f u z b. Proof. move=> f_assoc [[a z_not_right_id] | [a z_not_left_id]]. - by exists unit, (fun _ => a), (Mk_UnitBag tt). - admit. Abort.Module BagNeedsUnit. Definition pure {A} (x : A) : list A := [x]. Lemma same_empty_list' {A} (tail : list A) (b : Bag A) : foldBag app pure tail b = referenceFoldBag app pure [] b ++ tail. Proof. elim: b tail => [| x | l IHl r IHr | xs] //= tail. - by rewrite IHr IHl app_assoc. - by rewrite /Data.Foldable.foldr /Foldable.Foldable__list /Data.Foldable.foldr__ hs_coq_foldr_list' fold_right_cons fold_right_cons_nil. Qed. Lemma same_empty_list {A} (b : Bag A) : foldBag app pure [] b = referenceFoldBag app pure [] b. Proof. by rewrite same_empty_list' app_nil_r. Qed. Theorem counterexample {A} (x : A) (xs : list A) : exists b, well_formed_bag b /\ foldBag app pure (x :: xs) b <> referenceFoldBag app pure (x :: xs) b. 
(MPair M1 M2) (MPair N1 N2). unfold irreducible in |- *. unfold reduce in |- *. intros. red in |- *. intro. elim H. intro. intro. cut (analysis_def h M1 N1 /\ analysis_def h M2 N2). intro. elim H2. intros. case H1; intro H5; apply H5; trivial. apply SynInc; trivial. apply SynInc; trivial. cut (is_analysis h (analysis_def h)); try apply analysis_is_analysis. unfold is_analysis in |- *. intros. elim H2. unfold analysis_cond in |- *. intros. elim H3. intros. unfold stable_analysis in H6. unfold inclusion in H6. split; apply H6. apply (AnaSplitL (analysis_def h) M1 M2 N1 N2); apply AnaInc; trivial. apply (AnaSplitR (analysis_def h) M1 M2 N1 N2); apply AnaInc; trivial. Qed. Definition is_irreducible (h : hedge) := equal h (irreducible h). Theorem h_le_h_ana_h : forall h : hedge, le_h h (analysis_def h). intro. apply inclusion_impl_le_h. generalize (analysis_is_analysis h). intro. unfold is_analysis in H. unfold analysis_cond in H. elim H. intros. tauto. Qed. Theorem ana_h_equiv_irr_h : forall h : hedge, equiv_h (analysis_def h) (irreducible h). unfold irreducible in |- *. intro. apply h_equiv_h_red. Qed. Theorem h_le_h_irr_h : forall h : hedge, le_h h (irreducible h). intro. apply le_h_trans with (analysis_def h). apply h_le_h_ana_h. generalize (ana_h_equiv_irr_h h). unfold equiv_h in |- *. tauto. Qed. Lemma ana_irr_incl_ana : forall h : hedge, inclusion (analysis_def (irreducible h)) (analysis_def h). intro. generalize (analysis_is_analysis (irreducible h)). unfold is_analysis in |- *. unfold analysis_cond in |- *. intros. elim H. intros. apply H1. split. unfold irreducible in |- *. apply red_incl_h. generalize (analysis_is_analysis h). unfold is_analysis in |- *. unfold analysis_cond in |- *. tauto. Qed. Lemma irr_irr_incl_irr : forall h : hedge, inclusion (irreducible (irreducible h)) (irreducible h). unfold irreducible in |- *. intro. apply inclusion_le_h_reduce_inclusion. replace (reduce (analysis_def h)) with (irreducible h). apply ana_irr_incl_ana. unfold irreducible in |- *. trivial. replace (reduce (analysis_def h)) with (irreducible h). apply le_h_trans with (irreducible h). generalize ana_h_equiv_irr_h. unfold equiv_h in |- *. intros. elim (H h); tauto. apply h_le_h_ana_h. unfold irreducible in |- *. trivial. Qed. Lemma irr_incl_irr_irr : forall h : hedge, inclusion (irreducible h) (irreducible (irreducible h)). unfold irreducible in |- *. intros. apply inclusion_le_h_impl_inclusion_red. generalize (analysis_is_analysis (reduce (analysis_def h))). unfold is_analysis in |- *. unfold analysis_cond in |- *. tauto. apply le_h_trans with (analysis_def h). apply inclusion_impl_le_h. fold (irreducible h) in |- *. apply ana_irr_incl_ana. fold (irreducible h) in |- *. generalize ana_h_equiv_irr_h. unfold equiv_h in |- *. intros. elim (H h); auto. Qed. Theorem irreducible_is_irreducible : forall h : hedge, is_irreducible (irreducible h). 
comp_skip. eapply O1_count_Oi_eq_until_bad. simpl in *; intuition. fcf_simp. destruct p; simpl in *. fcf_spec_ret; fcf_compute; assert (b1 <= q)%nat by omega; intuition; subst; pairInv; trivial. unfold G1_count. fcf_inline_first. fcf_irr_l. fcf_simp. inline_first. fcf_irr_l. apply oc_comp_wf; intuition. eapply O1_count_wf. fcf_simp. unfold snd. fcf_compute. destruct p. eapply (qam_count (A1_qam s s0 _) (fun x => snd x)) in H0. simpl in *. omega. intuition. simpl. apply O1_count_increases in H1. omega. trivial. eapply rat0_le_all. Grab Existential Variables. eauto. Qed. Theorem G2_eq_Gi_0 : Pr[G2] == Pr[Gi 0%nat]. unfold G2, Gi. fcf_skip. fcf_simp. fcf_to_prhl_eq. comp_skip. eapply (fcf_oracle_eq (fun a b => a = fst b)); trivial; intuition; subst. unfold Oi. comp_simp. destruct (ge_dec n 0). simpl. fcf_ident_expand_l. comp_skip. eapply comp_spec_ret; intuition. omega. simpl in H1. intuition; subst. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_close : | Pr[G1] - Pr[G2] | <= (q / 1) * k. rewrite G1_eq_Gi_q. rewrite G2_eq_Gi_0. rewrite ratDistance_comm. specialize (distance_le_prod_f (fun i => Pr[Gi i])); intuition. Qed.End OracleHybrid.Require Import FCF.CompFold. Require Import FCF.OracleCompFold. Require Import FCF.PRF.Section OracleMapHybrid. Variable A B C State S_A : Set. Variable b : B. Hypothesis eqdA : EqDec A. Hypothesis eqdB : EqDec B. Hypothesis eqdState : EqDec State. Hypothesis eqdS_A : EqDec S_A. Variable A1 : Comp (State * (list A * S_A)). Variable A2 : S_A -> list B -> Comp bool. Hypothesis A1_wf : well_formed_comp A1. Hypothesis A2_wf : forall s_A lsb, well_formed_comp (A2 s_A lsb). Variable q : nat. Variable k : Rat. Hypothesis max_queries : forall ls s s_A, In (s, (ls, s_A)) (getSupport A1) -> (length ls <= q)%nat. Variable O1 O2 : State -> A -> Comp (B * State). Hypothesis O1_wf : forall s a, well_formed_comp (O1 s a). Hypothesis O2_wf : forall s a, well_formed_comp (O2 s a). Definition OMH_G O := [s, p] <-$2 A1; [lsa, s_A] <-2 p; [lsb, _] <-$2 oracleMap _ _ O s lsa; A2 s_A lsb. Definition OMH_G_i i := [s, p] <-$2 A1; [lsa, s_A] <-2 p; [lsb1, s'] <-$2 oracleMap _ _ O1 s (firstn i lsa); [lsb2, _] <-$2 oracleMap _ _ O2 s' (skipn i lsa); A2 s_A (lsb1 ++ lsb2). Hypothesis adjacent_close : forall i, | Pr[OMH_G_i i] - Pr[OMH_G_i (S i)] | <= k. Definition OMH_G_oc (p : list A * S_A) := [lsa, s_A] <-2 p; lsb <--$ oc_compMap _ (fun a => OC_Query _ a) lsa; $ A2 s_A lsb. Theorem OMH_G_oc_wf : forall p, well_formed_oc (OMH_G_oc p). 
:= M.find img (images db).Fixpoint find_categories (db : ImageDb) (categories : list CategoryId) : list Image := find_imgs db (list_from_set (find_categories_ids db categories)).Fixpoint delete_image (db : ImageDb) (img : ImageId) : ImageDb := {| images := M.remove img (images db); indices := M.map (S.remove img) (indices db); next_id := next_id db |}.Fixpoint tag_image (db: ImageDb) (img : ImageId) (cat : CategoryId) : ImageDb := let idxs := match M.find cat (indices db) with | None => M.add cat (S.singleton img) (indices db) | Some idx => M.add cat (S.add img idx) (indices db) end in {| images := images db; indices := idxs; next_id := next_id db |}.Fixpoint untag_image (db : ImageDb) (img : ImageId) (cat : CategoryId) : ImageDb := let idxs := match M.find cat (indices db) with | None => indices db | Some idx => M.add cat (S.remove img idx) (indices db) end in {| images := images db; indices := idxs; next_id := next_id db |}. Definition num_images (db : ImageDb) := M.cardinal (images db). Definition mem_image (db : ImageDb) (img : ImageId) := M.mem img (images db). Theorem count_empty_db : num_images newDb = 0. Proof. compute. tauto. Qed.Definition InternallyConsistent (db : ImageDb) := forall (some_id : ImageId), M.In some_id (images db) -> N.lt some_id (next_id db).Lemma lt_zero : forall (n : N), N.lt n N.zero -> False. Proof. induction n. compute. intro. discriminate. compute. intro. discriminate. Qed. Theorem preserves_consistency_1 : (InternallyConsistent newDb). Proof. intro. intro. rewrite MF.empty_in_iff in H. contradiction. Qed.Theorem preserves_consistency_2 : forall (db : ImageDb) (img : Image), InternallyConsistent db -> InternallyConsistent (create_image db img). Proof. intros. intro. intro. simpl. apply N.lt_succ_r. simpl in H0. apply MF.add_in_iff in H0. destruct H0. apply N.le_lteq. right. symmetry. apply H0. apply H in H0. apply N.le_lteq. left. apply H0. Qed.Theorem preserves_consistency_3 : forall (db : ImageDb) (img : ImageId), InternallyConsistent db -> InternallyConsistent (delete_image db img). Proof. intros. intro. intro. destruct db. unfold delete_image in H0. unfold next_id in H0. unfold images in H0. unfold delete_image. unfold next_id. unfold InternallyConsistent in H. apply MP.F.remove_in_iff in H0. destruct H0. specialize (H some_id H1). unfold next_id in H. apply H. Qed. Theorem preserves_consistency_4 : forall (db : ImageDb) (img : ImageId) (cat : CategoryId), InternallyConsistent db -> InternallyConsistent (tag_image db img cat). Proof. intros. destruct db. intro. intro. unfold tag_image. unfold next_id. unfold InternallyConsistent in H. specialize (H some_id H0). unfold next_id in H. apply H. Qed. Theorem preserves_consistency_5 : forall (db : ImageDb) (img : ImageId) (cat : CategoryId), InternallyConsistent db -> InternallyConsistent (untag_image db img cat). 
Int.eq Int.eq_spec n Int.zero. exists x. split. apply H. destruct x; simpl; auto. rewrite H0. rewrite Int64.shru'_zero. constructor. destruct (Int.ltu n Int64.iwordsize') eqn:LT; simpl. - rewrite Val.shrlu_rolml by apply LT. apply eval_rolml. auto. - TrivialExists. constructor; eauto. constructor. EvalOp. simpl; eauto. constructor. constructor. Qed.Theorem eval_shrlimm: forall n, unary_constructor_sound (fun e => shrlimm e n) (fun v => Val.shrl v (Vint n)). Proof. intros; unfold shrlimm. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shrlimm; auto. red; intros. predSpec Int.eq Int.eq_spec n Int.zero. exists x; split; auto. subst n; destruct x; simpl; auto. destruct (Int.ltu Int.zero Int64.iwordsize'); auto. change (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero). rewrite Int64.shr_zero; auto. destruct (Int.ltu n Int64.iwordsize') eqn:LT; simpl. assert (DEFAULT: exists v, eval_expr ge sp e m le (Eop (Oshrlimm n) (a:::Enil)) v /\ Val.lessdef (Val.shrl x (Vint n)) v) by TrivialExists. destruct (shrlimm_match a); InvEval. - TrivialExists. simpl; rewrite LT; auto. - destruct (Int.ltu (Int.add n n1) Int64.iwordsize') eqn:LT'; auto. subst. econstructor; split. EvalOp. simpl; eauto. destruct v1; simpl; auto. rewrite LT'. destruct (Int.ltu n1 Int64.iwordsize') eqn:LT1; auto. simpl; rewrite LT. rewrite Int.add_commut, Int64.shr'_shr'; auto. rewrite Int.add_commut; auto. - apply DEFAULT. - TrivialExists. constructor; eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Theorem eval_shll: binary_constructor_sound shll Val.shll. Proof. unfold shll. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shll; auto. red; intros. destruct (is_intconst b) as [n2|] eqn:C. - exploit is_intconst_sound; eauto. intros EQ; subst y. apply eval_shllimm; auto. - TrivialExists. Qed.Theorem eval_shrlu: binary_constructor_sound shrlu Val.shrlu. Proof. unfold shrlu. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shrlu; auto. red; intros. destruct (is_intconst b) as [n2|] eqn:C. - exploit is_intconst_sound; eauto. intros EQ; subst y. apply eval_shrluimm; auto. - TrivialExists. Qed.Theorem eval_shrl: binary_constructor_sound shrl Val.shrl. Proof. unfold shrl. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shrl; auto. red; intros. destruct (is_intconst b) as [n2|] eqn:C. - exploit is_intconst_sound; eauto. intros EQ; subst y. apply eval_shrlimm; auto. - TrivialExists. Qed.Theorem eval_negl: unary_constructor_sound negl Val.negl. Proof. unfold negl. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_negl; auto. red; intros. destruct (is_longconst a) as [n|] eqn:C. - exploit is_longconst_sound; eauto. intros EQ; subst x. econstructor; split. apply eval_longconst. auto. - TrivialExists. Qed.Theorem eval_addlimm: forall n, unary_constructor_sound (addlimm n) (fun v => Val.addl v (Vlong n)). Proof. unfold addlimm. red; intros. predSpec Int64.eq Int64.eq_spec n Int64.zero. exists x. split; auto. rewrite H0. destruct x; auto. simpl. rewrite Int64.add_zero. constructor. destruct (addlimm_match a). - econstructor; split. apply eval_longconst. simpl. InvEval. unfold Val.rolml. auto. - InvEval. TrivialExists. simpl. rewrite <- H. rewrite Val.addl_assoc. reflexivity. - InvEval. TrivialExists. Qed. Theorem eval_addl: binary_constructor_sound addl Val.addl. 
find_inversion; auto. Qed. Lemma doLeader_log : forall st h os st' ms, doLeader st h = (os, st', ms) -> log st' = log st. Proof using. unfold doLeader. intros. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleAppendEntriesReply_log : forall h st h' t es r st' ms, handleAppendEntriesReply h st h' t es r = (st', ms) -> log st' = log st. Proof using. unfold handleAppendEntriesReply, advanceCurrentTerm. intros. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleRequestVoteReply_log : forall h st h' t r st', handleRequestVoteReply h st h' t r = st' -> log st' = log st. Proof using. intros. eapply handleRequestVoteReply_spec; eauto. Qed. Lemma handleRequestVoteReply_log_rewrite : forall h st h' t r, log (handleRequestVoteReply h st h' t r) = log st. Proof using. intros. erewrite handleRequestVoteReply_log; eauto. Qed. Lemma handleAppendEntriesReply_packets : forall h st from t es s st' ps, handleAppendEntriesReply h st from t es s = (st', ps) -> ps = []. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; subst; auto. Qed. Lemma doGenericServer_packets : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> ps = []. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; simpl in *; subst; auto. Qed. Theorem handleAppendEntries_not_append_entries : forall h st t n pli plt es ci st' m, handleAppendEntries h st t n pli plt es ci = (st', m) -> ~ is_append_entries m. Proof using. intros. unfold handleAppendEntries in *. repeat break_match; find_inversion; intuition; break_exists; congruence. Qed. Lemma handleAppendEntries_clientCache: forall h st (d : raft_data) (m : msg) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex), handleAppendEntries h st t n pli plt es ci = (d, m) -> clientCache d = clientCache st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleAppendEntriesReply_clientCache: forall h st (d : raft_data) (m : list (name * msg)) (t : nat) (es : list entry) (res : bool) h', handleAppendEntriesReply h st h' t es res = (d, m) -> clientCache d = clientCache st. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat (break_match; try find_inversion; simpl in *; auto). Qed. Lemma advanceCurrentTerm_clientCache : forall st t, clientCache (advanceCurrentTerm st t) = clientCache st. Proof using. unfold advanceCurrentTerm. intros. break_if; auto. Qed. Theorem handleTimeout_clientCache : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> clientCache st' = clientCache st. 
induction p as [ | p IHp ]. + rewrite power_0; lia. + rewrite power_S; split. * intros H. apply mult_is_O in H. rewrite IHp in H; lia. * intros (?&?); subst; simpl; auto. Qed. Fact plus_cancel_l : forall a b c, a + b = a + c -> b = c. Proof. intros; lia. Qed. Let plus_cancel_l':= plus_cancel_l. Fact sum_0n_scal_l n k f : ∑ n (fun i => k*f i) = k*∑ n f. Proof. apply sum_0n_distr_l with (3 := Nat_mult_monoid); auto. intros; ring. Qed. Fact sum_0n_scal_r n k f : ∑ n (fun i => (f i)*k) = (∑ n f)*k. Proof. apply sum_0n_distr_r with (3 := Nat_mult_monoid); auto. intros; ring. Qed. Fact sum_0n_mono n f g : (forall i, i < n -> f i <= g i) -> ∑ n f <= ∑ n g. Proof. revert f g; induction n as [ | n IHn ]; intros f g H. + do 2 rewrite msum_0; auto. + do 2 rewrite msum_S; apply plus_le_compat. * apply H; lia. * apply IHn; intros; apply H; lia. Qed. Fact sum_0n_le_one n f i : i < n -> f i <= ∑ n f. Proof. revert f i; induction n as [ | n IHn ]; intros f i H. + lia. + rewrite msum_S. destruct i as [ | i ]; try lia. apply lt_S_n, IHn with (f := fun i => f (S i)) in H. lia. Qed. Fact sum_power_lt k n f : k <> 0 -> (forall i, i < n -> f i < k) -> ∑ n (fun i => f i * power i k) < power n k. Proof. intros Hk. revert f; induction n as [ | n IHn ]; intros f Hf. + rewrite msum_0, power_0; lia. + rewrite msum_S, power_S, power_0, Nat.mul_1_r. apply le_trans with (k+ k * (power n k-1)). * apply (@plus_le_compat (S (f 0))). - apply Hf; lia. - rewrite msum_ext with (g := fun i => k*(f (S i)*power i k)). ++ rewrite sum_0n_distr_l with (one := 1); auto; try (intros; ring). apply mult_le_compat_l. apply le_S_n, le_trans with (power n k); try lia. apply IHn; intros; apply Hf; lia. ++ intros; rewrite power_S; ring. * generalize (power_ge_1 n Hk); intros ?. replace (power n k) with (1+(power n k - 1)) at 2 by lia. rewrite Nat.mul_add_distr_l. apply plus_le_compat; lia. Qed. Theorem Newton_nat a b n : power n (a + b) = ∑ (S n) (fun i => binomial n i * power (n - i) a * power i b). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor. From Categories Require Import Cat.Cat.Section NatTrans. Context {C C' : Category}. Record NatTrans (F F' : (C –≻ C')%functor) := { Trans (c : C) : ((F _o c) –≻ (F' _o c))%object%morphism; Trans_com {c c' : C} (h : (c –≻ c')%morphism) : ((Trans c') ∘ F _a h = F' _a h ∘ (Trans c))%morphism; Trans_com_sym {c c' : C} (h : (c –≻ c')%morphism) : (F' _a h ∘ (Trans c) = (Trans c') ∘ F _a h)%morphism }. Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope. Lemma NatTrans_eq_simplify {F F' : (C –≻ C')%functor} (N N' : (F –≻ F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'. Proof. destruct N; destruct N'. basic_simpl. ElimEq. PIR; trivial. Qed.End NatTrans.Arguments Trans {_ _ _ _} _ _. Arguments Trans_com {_ _ _ _} _ {_ _} _. Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.Bind Scope nattrans_scope with NatTrans.Notation "F –≻ F'" := (NatTrans F F') : nattrans_scope.Local Open Scope nattrans_scope.Section NatTrans_Compose. Context {C C' : Category}. Program Definition NatTrans_compose {F F' F'' : (C –≻ C')%functor} (tr : F –≻ F') (tr' : F' –≻ F'') : (F –≻ F'')%nattrans := {| Trans := fun c : Obj => ((Trans tr' c) ∘ (Trans tr c)) % morphism |}. Next Obligation. Proof. rewrite assoc. rewrite Trans_com. rewrite assoc_sym. rewrite Trans_com; auto. Qed. Next Obligation. Proof. symmetry. apply NatTrans_compose_obligation_1. Qed.End NatTrans_Compose.Notation "N ∘ N'" := (NatTrans_compose N' N) : nattrans_scope.Section NatTrans_Props. Context {C C' : Category}. Theorem NatTrans_compose_assoc {F G H I : (C –≻ C')%functor} (N : F –≻ G) (N' : G –≻ H) (N'' : H –≻ I) : ((N'' ∘ N') ∘ N = N'' ∘ (N' ∘ N))%nattrans . Proof. apply NatTrans_eq_simplify; cbn; auto. Qed. Program Definition NatTrans_id (F : (C –≻ C')%functor) : F –≻ F := {| Trans := fun x : Obj => id |}. Theorem NatTrans_id_unit_left {F G : (C –≻ C')%functor} (N : F –≻ G) : (NatTrans_id G) ∘ N = N. Proof. apply NatTrans_eq_simplify; cbn; auto. Qed. Theorem NatTrans_id_unit_right {F G : (C –≻ C')%functor} (N : F –≻ G) : N ∘ (NatTrans_id F) = N. 
b q, 0<b -> a < b*q -> a/b < q. Proof. intros. rewrite (mul_lt_mono_pos_l b) by trivial. apply le_lt_trans with a; trivial. now apply mul_div_le. Qed.Theorem div_le_upper_bound: forall a b q, 0<b -> a <= b*q -> a/b <= q. Proof. intros. rewrite <- (div_mul q b) by order. apply div_le_mono; trivial. now rewrite mul_comm. Qed.Theorem div_le_lower_bound: forall a b q, 0<b -> b*q <= a -> q <= a/b. Proof. intros. rewrite <- (div_mul q b) by order. apply div_le_mono; trivial. now rewrite mul_comm. Qed.Lemma div_le_compat_l: forall p q r, 0<=p -> 0<q<=r -> p/r <= p/q. Proof. exact div_le_compat_l. Qed.Lemma mod_add : forall a b c, c~=0 -> (a + b * c) mod c == a mod c. Proof. intros. symmetry. apply mod_unique with (a/c+b); trivial. now apply mod_bound_or. rewrite mul_add_distr_l, add_shuffle0, <- div_mod by order. now rewrite mul_comm. Qed.Lemma div_add : forall a b c, c~=0 -> (a + b * c) / c == a / c + b. Proof. intros. apply (mul_cancel_l _ _ c); try order. apply (add_cancel_r _ _ ((a+b*c) mod c)). rewrite <- div_mod, mod_add by order. rewrite mul_add_distr_l, add_shuffle0, <- div_mod by order. now rewrite mul_comm. Qed.Lemma div_add_l: forall a b c, b~=0 -> (a * b + c) / b == a + c / b. Proof. intros a b c. rewrite (add_comm _ c), (add_comm a). now apply div_add. Qed.Lemma div_mul_cancel_r : forall a b c, b~=0 -> c~=0 -> (a*c)/(b*c) == a/b. Proof. intros. symmetry. apply div_unique with ((a mod b)*c).destruct (lt_ge_cases 0 c). rewrite <-(mul_0_l c), <-2mul_lt_mono_pos_r, <-2mul_le_mono_pos_r by trivial. now apply mod_bound_or. rewrite <-(mul_0_l c), <-2mul_lt_mono_neg_r, <-2mul_le_mono_neg_r by order. destruct (mod_bound_or a b); tauto.rewrite (div_mod a b) at 1 by order. rewrite mul_add_distr_r. rewrite add_cancel_r. rewrite <- 2 mul_assoc. now rewrite (mul_comm c). Qed.Lemma div_mul_cancel_l : forall a b c, b~=0 -> c~=0 -> (c*a)/(c*b) == a/b. Proof. intros. rewrite !(mul_comm c); now apply div_mul_cancel_r. Qed.Lemma mul_mod_distr_l: forall a b c, b~=0 -> c~=0 -> (c*a) mod (c*b) == c * (a mod b). Proof. intros. rewrite <- (add_cancel_l _ _ ((c*b)* ((c*a)/(c*b)))). rewrite <- div_mod. rewrite div_mul_cancel_l by trivial. rewrite <- mul_assoc, <- mul_add_distr_l, mul_cancel_l by order. apply div_mod; order. rewrite <- neq_mul_0; auto. Qed.Lemma mul_mod_distr_r: forall a b c, b~=0 -> c~=0 -> (a*c) mod (b*c) == (a mod b) * c. Proof. intros. rewrite !(mul_comm _ c); now rewrite mul_mod_distr_l. Qed. Theorem mod_mod: forall a n, n~=0 -> (a mod n) mod n == a mod n. 
exact Hd. elim Hx. rewrite <- Hd. apply generic_format_round... apply Rle_0_minus. apply round_UP_pt... Qed. Theorem error_le_ulp : forall rnd { Zrnd : Valid_rnd rnd } x, (Rabs (round beta fexp rnd x - x) <= ulp x)%R. Proof with auto with typeclass_instances. intros rnd Zrnd x. case (Req_dec x 0). intros Zx; rewrite Zx, round_0... unfold Rminus; rewrite Rplus_0_l, Ropp_0, Rabs_R0. apply ulp_ge_0. intros Zx; left. now apply error_lt_ulp. Qed. Theorem error_le_half_ulp : forall choice x, (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp x)%R. Proof with auto with typeclass_instances. intros choice x. destruct (generic_format_EM beta fexp x) as [Hx|Hx].rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. apply Rmult_le_pos. apply Rlt_le. apply Rinv_0_lt_compat. now apply (Z2R_lt 0 2). apply ulp_ge_0.set (d := round beta fexp Zfloor x). destruct (round_N_pt beta fexp choice x) as (Hr1, Hr2). destruct (Rle_or_lt (x - d) (d + ulp x - x)) as [H|H].apply Rle_trans with (Rabs (d - x)). apply Hr2. apply (round_DN_pt beta fexp x). rewrite Rabs_left1. rewrite Ropp_minus_distr. apply Rmult_le_reg_r with 2%R. now apply (Z2R_lt 0 2). apply Rplus_le_reg_r with (d - x)%R. ring_simplify. apply Rle_trans with (1 := H). right. field. apply Rle_minus. apply (round_DN_pt beta fexp x).assert (Hu: (d + ulp x)%R = round beta fexp Zceil x). unfold d. now rewrite <- round_UP_DN_ulp. apply Rle_trans with (Rabs (d + ulp x - x)). apply Hr2. rewrite Hu. apply (round_UP_pt beta fexp x). rewrite Rabs_pos_eq. apply Rmult_le_reg_r with 2%R. now apply (Z2R_lt 0 2). apply Rplus_le_reg_r with (- (d + ulp x - x))%R. ring_simplify. apply Rlt_le. apply Rlt_le_trans with (1 := H). right. field. apply Rle_0_minus. rewrite Hu. apply (round_UP_pt beta fexp x). Qed. Theorem ulp_DN : forall x, (0 < round beta fexp Zfloor x)%R -> ulp (round beta fexp Zfloor x) = ulp x. Proof with auto with typeclass_instances. intros x Hd. rewrite 2!ulp_neq_0. now rewrite canonic_exp_DN with (2 := Hd). intros T; contradict Hd; rewrite T, round_0... apply Rlt_irrefl. now apply Rgt_not_eq. Qed.Theorem round_neq_0_negligible_exp: negligible_exp=None -> forall rnd { Zrnd : Valid_rnd rnd } x, (x <> 0)%R -> (round beta fexp rnd x <> 0)%R. Proof with auto with typeclass_instances. intros H rndn Hrnd x Hx K. case negligible_exp_spec'. intros (_,Hn). destruct (ln_beta beta x) as (e,He). absurd (fexp e < e)%Z. apply Zle_not_lt. apply exp_small_round_0 with beta rndn x... apply (Hn e). intros (n,(H1,_)). rewrite H in H1; discriminate. Qed. Theorem error_lt_ulp_round : forall { Hm : Monotone_exp fexp } rnd { Zrnd : Valid_rnd rnd } x, ( x <> 0)%R -> (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R. 
auto with zarith. rewrite H'5; case H'4; intros H1 H2; case H2; auto. left. replace (Fexp p) with (- dExp b)%Z; [ idtac | apply sym_equal; auto with float ]. case (Zle_lt_or_eq (- dExp b) (Fexp q)); auto with float zarith. intros H'3 H'4; right; split. apply trans_equal with (- dExp b)%Z; auto with float. apply sym_equal; auto with float. apply FsubnormalLt; auto. Qed. Theorem FcanonicLePos : forall p q : float, Fcanonic p -> Fcanonic q -> (0 <= p)%R -> (p <= q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p <= Fnum q)%Z. intros p q H' H'0 H'1 H'2. case H'2; intros H'3. case FcanonicLtPos with (p := p) (q := q); auto with zarith arith. rewrite FcanonicUnique with (p := p) (q := q); auto with zarith arith. Qed. Theorem Fcanonic_Rle_Zle : forall x y : float, Fcanonic x -> Fcanonic y -> (Rabs x <= Rabs y)%R -> (Fexp x <= Fexp y)%Z. intros x y H H0 H1. cut (forall z : float, Fexp z = Fexp (Fabs z) :>Z); [ intros E | intros; unfold Fabs in |- *; simpl in |- *; auto with zarith ]. rewrite (E x); rewrite (E y). cut (Fcanonic (Fabs x)); [ intros D | apply FcanonicFabs; auto ]. cut (Fcanonic (Fabs y)); [ intros G | apply FcanonicFabs; auto ]. case H1; intros Z2. case (FcanonicLtPos (Fabs x) (Fabs y)); auto with zarith. rewrite (Fabs_correct radix); auto with real zarith. repeat rewrite (Fabs_correct radix); auto with real zarith. rewrite (FcanonicUnique (Fabs x) (Fabs y)); auto with float zarith. repeat rewrite (Fabs_correct radix); auto with real zarith. Qed. Theorem FcanonicLtNeg : forall p q : float, Fcanonic p -> Fcanonic q -> (q <= 0)%R -> (p < q)%R -> (Fexp q < Fexp p)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z. intros p q H' H'0 H'1 H'2. cut ((Fexp (Fopp q) < Fexp (Fopp p))%Z \/ Fexp (Fopp q) = Fexp (Fopp p) /\ (Fnum (Fopp q) < Fnum (Fopp p))%Z). simpl in |- *. intros H'3; elim H'3; clear H'3; intros H'3; [ idtac | elim H'3; clear H'3; intros H'3 H'4 ]; auto; right; split; auto with zarith. apply FcanonicLtPos; try apply FcanonicFopp; auto; unfold FtoRradix in |- *; repeat rewrite Fopp_correct; replace 0%R with (-0)%R; auto with real. Qed. Theorem FcanonicFnormalizeEq : forall p : float, Fcanonic p -> Fnormalize p = p. 
(fold_tree m2) end. Proof. - abstract (intros; unfold unapp_half in teq2; symmetry in teq2; name_term len_x_n_l0 (length (x::y::a::l1)) LEN; rewrite <- LEN in *; simpl in LEN; assert (L0: len_x_n_l0 > 0) by omega; apply lt_div2 in L0; assert (len_x_n_l0 - div2 len_x_n_l0 > 0) by omega; symmetry in teq2; apply unapp_reduce_m2 in teq2; auto; simpl in teq2; [rewrite <- LEN in *; apply teq2| simpl; auto with arith]). - abstract (intros; unfold unapp_half in teq2; apply unapp_reduce_m1 in teq2; [apply teq2| clear teq2; name_term len_x_n_l0 (length (x::y::a::l1)) LEN; rewrite <- LEN in *; simpl in LEN; assert (L0: len_x_n_l0 > 0) by omega; apply lt_div2 in L0; assert (L1: len_x_n_l0 > 1) by omega; rewrite LEN at 2; simpl; omega]). Defined. Lemma f_comm1 a b c: f a (f b c) = f b (f a c). Proof. rewrite <- fAssoc. rewrite <- fAssoc. assert (sth:f a b = f b a) by apply fComm; rewrite sth; rewrite <- sth. auto. Qed. Lemma f_comm2 a b c: f a (f b c) = f (f a b) c. Proof. rewrite <- fAssoc. reflexivity. Qed. Lemma fold_right_f_assoc: forall i m1 seed, f i (fold_right f seed m1) = fold_right f (f i seed) m1. Proof. intros i m1. assert (exists k, length m1 <= k) as [k K] by (exists (length m1); auto). revert i m1 K. induction k as [| k]; intros * K *. - assert (A1: length m1 = 0) by omega. apply length_zero_iff_nil in A1. subst m1. reflexivity. - destruct m1 as [| y ys]. + reflexivity. + simpl in K. apply le_S_n in K. simpl. rewrite <- IHk; auto. apply f_comm1. Qed. Lemma fold_right_slideout: forall m seed, fold_right f seed m = f (fold_right f unit m) seed. Proof. induction m as [| x xs]; intros. - now simpl. - simpl. rewrite IHxs. destruct xs. apply f_comm2. apply f_comm2. Qed. Lemma fold_right_homomorphism: forall m1 m2, fold_right f unit (m1 ++ m2) = f (fold_right f unit m1) (fold_right f unit m2). Proof. intros *. name_term lhs (f (fold_right f unit m1) (fold_right f unit m2)) LHS. rewrite <- LHS. rewrite fold_right_inclusion. rewrite fold_right_slideout. now subst lhs. Qed. Lemma fold_right_homomorphism_unapp: forall m m1 m2, (m1, m2) = unapp_half m -> fold_right f unit m = f (fold_right f unit m1) (fold_right f unit m2). Proof. intros. apply unapp_half_app in H. rewrite <- H. eapply fold_right_homomorphism. Qed. Theorem fold_right_fold_tree: forall m, fold_right f unit m = fold_tree m. 
cl', rp'; simpl. ** destruct (H3 x x) as [ | [] ]; auto. ** rewrite Q1. destruct (H3 x (rp p)) as [ | H ]; auto. unfold T in Q2. specialize (Q1 p). contradict Q1. rewrite (proj1 (Q2 _)); try tauto; discriminate. ++ intros u; unfold cl'; split. ** intros H; destruct (H3 x u) as [ F1 | F1 ]. { contradict H; apply H2 with x; auto. } rewrite (proj1 (Q2 _)); auto. intros (? & ?); tauto. ** destruct (H3 x u) as [ F1 | F1 ]; try discriminate. intros F2 F3. destruct (proj1 (Q3 u u)) as (E & ?). red; auto. destruct (cl u); try discriminate; tauto. ++ intros u v; split. ** intros H. unfold cl'. destruct (H3 x u) as [ F1 | F1 ]. { split; try discriminate. destruct (H3 x v) as [ F2 | F2 ]; auto. contradict F2; apply H2 with u; auto. } destruct (H3 x v) as [ F2 | F2 ]. { contradict F1; apply H2 with v; auto. } destruct (proj1 (Q3 u v)) as (F3 & F4). { red; auto. } rewrite <- F3. destruct (cl u); auto. split; auto; discriminate. ** intros (F1 & F2); revert F1 F2. unfold cl'. { destruct (H3 x u) as [ F1 | F1 ]; destruct (H3 x v) as [ F2 | F2 ]. + intros _ _; apply H2 with x; auto. + destruct (cl v); discriminate. + destruct (cl u); discriminate. + case_eq (cl u). 2: intros _ _ []; auto. case_eq (cl v); try discriminate. intros p Hp q Hq E _; apply Q3. rewrite Hp, Hq; split; try discriminate. f_equal. apply Some_inj, pos_nxt_inj in E; subst; auto. } - exists _ cl rp; auto. ++ intros u; split. ** intros H; apply Q2; unfold T; tauto. ** intros H; apply Q2 in H; contradict H; split; auto. contradict Hx; apply H2 with u; auto. ++ intros u v; split. ** intros H; apply Q3. split; auto. contradict Hx; apply H2 with u; auto. ** intros H; apply Q3 in H; destruct H; auto. Qed. Record fin_quotient R := Mk_finite_quotient { fq_size : nat; fq_class : X -> pos fq_size; fq_repr : pos fq_size -> X; fq_surj : forall c, fq_class (fq_repr c) = c; fq_equiv : forall x y, R x y <-> fq_class x = fq_class y }. Theorem decidable_EQUIV_fin_quotient l R : (forall x, R x x) -> (forall x y, R x y -> R y x) -> (forall x y z, R x y -> R y z -> R x z) -> (forall x y, { R x y } + { ~ R x y }) -> (forall x : X, exists y, In y l /\ R x y) -> fin_quotient R. 
Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition boundNat (n : nat) := Float 1%nat (digit radix n). Theorem boundNatCorrect : forall n : nat, (n < boundNat n)%R. intros n; unfold FtoRradix, FtoR, boundNat in |- *; simpl in |- *. rewrite Rmult_1_l. rewrite <- Zpower_nat_Z_powerRZ; auto with real zarith. rewrite INR_IZR_INZ; auto with real zarith. apply Rle_lt_trans with (Zabs n); [rewrite (Zabs_eq (Z_of_nat n))|idtac];auto with real zarith. Qed. Theorem boundBoundNat : forall n : nat, Fbounded b (boundNat n). intros n; repeat split; unfold boundNat in |- *; simpl in |- *; auto with zarith. apply vNumbMoreThanOne with (radix := radix) (precision := precision); auto with zarith. apply Zle_trans with 0%Z;[case (dExp b)|idtac]; auto with zarith. Qed. Definition boundR (r : R) := boundNat (Zabs_nat (up (Rabs r))). Theorem boundRCorrect1 : forall r : R, (r < boundR r)%R. intros r; case (Rle_or_lt r 0); intros H'. apply Rle_lt_trans with (1 := H'). unfold boundR, boundNat, FtoRradix, FtoR in |- *; simpl in |- *; auto with real. rewrite Rmult_1_l; auto with real zarith. apply Rlt_trans with (2 := boundNatCorrect (Zabs_nat (up (Rabs r)))). replace (Rabs r) with r; auto with real. apply Rlt_le_trans with (r2 := IZR (up r)); auto with real zarith. case (archimed r); auto. rewrite INR_IZR_INZ; auto with real zarith. unfold Rabs in |- *; case (Rcase_abs r); auto with real. intros H'0; Contradict H'0; auto with real. Qed. Theorem boundRrOpp : forall r : R, boundR r = boundR (- r). intros R; unfold boundR in |- *. rewrite Rabs_Ropp; auto. Qed. Theorem boundRCorrect2 : forall r : R, (Fopp (boundR r) < r)%R. intros r; case (Rle_or_lt r 0); intros H'. rewrite boundRrOpp. pattern r at 2 in |- *; rewrite <- (Ropp_involutive r). unfold FtoRradix in |- *; rewrite Fopp_correct. apply Ropp_lt_contravar; apply boundRCorrect1; auto. apply Rle_lt_trans with 0%R; auto. replace 0%R with (-0)%R; auto with real. unfold FtoRradix in |- *; rewrite Fopp_correct. apply Ropp_le_contravar. unfold boundR, boundNat, FtoRradix, FtoR in |- *; simpl in |- *; auto with real zarith. rewrite Rmult_1_l; apply Rlt_le; auto with real zarith arith. Qed. Definition mBFloat (p : R) := map (fun p : Z * Z => Float (fst p) (snd p)) (mProd Z Z (Z * Z) (mZlist (- pPred (vNum b)) (pPred (vNum b))) (mZlist (- dExp b) (Fexp (boundR p)))). Theorem mBFadic_correct1 : forall (r : R) (q : float), ~ is_Fzero q -> (Fopp (boundR r) < q)%R -> (q < boundR r)%R -> Fbounded b q -> In q (mBFloat r). 
l HF. set (m:=@nil A) in HF; assert (m = nil); [reflexivity|idtac]; clearbody m. induction HF; try elim (nil_cons (sym_eq H)); auto. Qed. Theorem Permutation_nil_cons : forall (l : list A) (x : A), ~ Permutation nil (x::l). Proof. unfold not; intros l x HF. elim (@nil_cons A x l). apply sym_eq. exact (Permutation_nil HF). Qed. Theorem Permutation_refl : forall l : list A, Permutation l l. Proof. induction l; constructor. exact IHl. Qed. Theorem Permutation_sym : forall l l' : list A, Permutation l l' -> Permutation l' l. Proof. intros l l' Hperm; induction Hperm; auto. apply perm_trans with (l':=l'); assumption. Qed. Theorem Permutation_trans : forall l l' l'' : list A, Permutation l l' -> Permutation l' l'' -> Permutation l l''. Proof. exact perm_trans. Qed. Hint Resolve Permutation_refl Permutation_sym Permutation_trans. Theorem Permutation_in : forall (l l' : list A) (x : A), Permutation l l' -> In x l -> In x l'. Proof. intros l l' x Hperm; induction Hperm; simpl; tauto. Qed. Lemma Permutation_app_tail : forall (l l' tl : list A), Permutation l l' -> Permutation (l++tl) (l'++tl). Proof. intros l l' tl Hperm; induction Hperm as [|x l l'|x y l|l l' l'']; simpl; auto. eapply Permutation_trans with (l':=l'++tl); trivial. Qed. Lemma Permutation_app_head : forall (l tl tl' : list A), Permutation tl tl' -> Permutation (l++tl) (l++tl'). Proof. intros l tl tl' Hperm; induction l; [trivial | repeat rewrite <- app_comm_cons; constructor; assumption]. Qed. Theorem Permutation_app : forall (l m l' m' : list A), Permutation l l' -> Permutation m m' -> Permutation (l++m) (l'++m'). Proof. intros l m l' m' Hpermll' Hpermmm'; induction Hpermll' as [|x l l'|x y l|l l' l'']; repeat rewrite <- app_comm_cons; auto. apply Permutation_trans with (l' := (x :: y :: l ++ m)); [idtac | repeat rewrite app_comm_cons; apply Permutation_app_head]; trivial. apply Permutation_trans with (l' := (l' ++ m')); try assumption. apply Permutation_app_tail; assumption. Qed. Theorem Permutation_app_swap : forall (l l' : list A), Permutation (l++l') (l'++l). Proof. induction l as [|x l]. simpl; intro l'; rewrite <- app_nil_end; trivial. induction l' as [|y l']. simpl; rewrite <- app_nil_end; trivial. simpl; apply Permutation_trans with (l' := x :: y :: l' ++ l). constructor; rewrite app_comm_cons; apply IHl. apply Permutation_trans with (l' := y :: x :: l' ++ l); constructor. apply Permutation_trans with (l' := x :: l ++ l'); auto. Qed. Theorem Permutation_cons_app : forall (l l1 l2:list A) a, Permutation l (l1 ++ l2) -> Permutation (a :: l) (l1 ++ a :: l2). 
l, In (a1, b1) (add_frequency_list a2 l) -> a1 = a2 \/ In (a1, b1) l. Proof using. intros a1 a2 b1 l; elim l; simpl in |- *; auto. intros [H1| H1]; auto; injection H1; auto. intros (a3, b3) l1 Rec; simpl in |- *; auto. case (eqA_dec a2 a3); simpl in |- *; auto. intros e H; cut (In (a1, b1) ((a2, S b3) :: l1)); auto. simpl in |- *; intros [H1| H1]; auto. injection H1; auto. intuition. Qed. Theorem add_frequency_list_unique_key : forall (a : A) l, unique_key l -> unique_key (add_frequency_list a l). Proof using. intros a l; elim l; simpl in |- *; auto. intros (a1, n1) l1 Rec H; case (eqA_dec a a1). intros e; apply unique_key_perm with (l1 := (a, S n1) :: l1); auto. apply unique_key_cons; auto. intros b; red in |- *; intros H0; case (unique_key_in _ _ _ _ b _ H); auto. rewrite <- e; auto. apply unique_key_inv with (1 := H); auto. intros n; apply unique_key_cons; auto. intros b; red in |- *; intros H0; case add_frequency_list_in_inv with (1 := H0); auto. intros H2; case (unique_key_in _ _ _ _ b _ H); auto. apply Rec; apply unique_key_inv with (1 := H); auto. Qed. Theorem add_frequency_list_1 : forall a l, (forall ca, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l). Proof using. intros a l; generalize a; elim l; clear a l; simpl in |- *; auto. intros (a1, l1) l0 H a H0. case (eqA_dec a a1); auto. intros H1; case (H0 l1); left; apply f_equal2 with (f := pair (A:=A) (B:=nat)); auto. intros n; apply in_cons; auto; apply H; auto. intros ca; red in |- *; intros H1; case (H0 ca); auto. Qed. Theorem add_frequency_list_in : forall m a n, unique_key m -> In (a, n) m -> In (a, S n) (add_frequency_list a m). Proof using. intros m; elim m; clear m; simpl in |- *; auto. intros (a1, l1) l Rec a n H H1; case (eqA_dec a a1); simpl in |- *; auto. intros H2; case H1; auto. intros H3; left; apply f_equal2 with (f := pair (A:=A) (B:=nat)); injection H3; auto. rewrite H2; intros H3; case unique_key_in with (1 := H) (b2 := n); auto. intros n0; right; apply Rec. apply unique_key_inv with (1 := H); auto. case H1; auto. intros H0; case n0; injection H0; auto. Qed. Theorem add_frequency_list_not_in : forall m a b n, a <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m). 
nil ⊢I F (h10:=h10) -> H10UPC_SAT h10. Proof. intros H%soundness. apply inverseTransport. intros D I rho. apply H. easy. Qed. End provability. Section kripke_validity. Context {ff : falsity_flag}. Context {h10 : list h10upc}. Lemma kripkeTransport : H10UPC_SAT h10 -> kvalid (F (h10:=h10)). Proof. intros H. intros D M u rho. eapply ksoundness with nil. - now apply proofTransport. - intros a []. Qed. Lemma kripkeInverseTransport : kvalid (F (h10:=h10)) -> H10UPC_SAT h10. Proof. intros H. apply inverseTransport. intros D I rho. apply kripke_tarski. apply H. Qed. End kripke_validity. Section classical_provability. Context {ff : falsity_flag}. Context {h10 : list h10upc}. Context (LEM : forall P:Prop, P \/ ~P). Lemma classicalProvabilityTransport : H10UPC_SAT h10 -> nil ⊢C F (h10:=h10). Proof using LEM. intros [φ Hφ]. apply intuitionistic_is_classical. eapply transport_prove. exact Hφ. Qed. Lemma classicalProvabilityInverseTransport : nil ⊢C F (h10:=h10) -> H10UPC_SAT h10. Proof using LEM. intros H%(classical_soundness LEM). apply inverseTransport. intros D I rho. apply H. easy. Qed. End classical_provability. Section satisfiability. Context {h10 : list h10upc}. Lemma satisTransport : (~ H10UPC_SAT h10) -> satis ((F (ff:=falsity_on) (h10:=h10)) --> falsity). Proof. intros H. exists dom. exists (IB (h10:=h10)). exists (fun _ => Num 0). intros HF. apply H. eapply IB_fulfills. easy. Qed. Lemma satisInverseTransport : satis ((F (ff:=falsity_on) (h10:=h10)) --> falsity) -> (~ H10UPC_SAT h10). Proof. intros [D [I [rho HF]]] H. apply HF, (transport (ff:=falsity_on) H). Qed. End satisfiability. Section ksatisfiability. Context {h10 : list h10upc}. Lemma ksatisTransport : (~ H10UPC_SAT h10) -> ksatis ((F (ff:=falsity_on) (h10:=h10)) --> falsity). Proof. intros H. exists dom. pose (kripke_tarski (ff:=falsity_on) (IB (h10:=h10))) as Hk. exists (interp_kripke (IB (h10:=h10))). exists tt. exists (fun _ => Num 0). rewrite <- Hk. intros HF. apply H. eapply IB_fulfills. easy. Qed. Lemma ksatisInverseTransport : ksatis ((F (ff:=falsity_on) (h10:=h10)) --> falsity) -> (~ H10UPC_SAT h10). Proof. intros [D [M [u [rho HF]]]] H. specialize (HF u). apply HF. - apply reach_refl. - apply (kripkeTransport (ff:=falsity_on) H). Qed. End ksatisfiability.Require Import Undecidability.Synthetic.Definitions. Section undecResults. Definition minimalSignature (f:funcs_signature) (p:preds_signature) : Prop := match f,p with {|syms := F; ar_syms := aF|},{|preds := P; ar_preds := aP|} => (F -> False) /\ exists pp : P, aP pp = 2 end. Lemma sig_is_minimal : minimalSignature sig_empty sig_binary. Proof. split. * intros []. * now exists tt. Qed. Theorem validReduction : H10UPC_SAT ⪯ @valid sig_empty sig_binary falsity_off. Proof. exists (fun l => @F falsity_off l). split. * apply transport. * apply inverseTransport. Qed. Theorem satisReduction : complement H10UPC_SAT ⪯ @satis sig_empty sig_binary falsity_on. 
Require Import Undecidability.Synthetic.Undecidability. Require Import Undecidability.Synthetic.ReducibilityFacts. Require Import Undecidability.DiophantineConstraints.H10C. From Undecidability.FRACTRAN Require Import FRACTRAN Reductions.MM_FRACTRAN. From Undecidability.MinskyMachines Require Import MM Reductions.BSM_MM. From Undecidability.StackMachines Require Import BSM Reductions.SBTM_HALT_to_HaltBSM. Require Import Undecidability.TM.SBTM_undec.From Undecidability.DiophantineConstraints.Reductions Require FRACTRAN_to_H10C_SAT H10C_SAT_to_H10SQC_SAT H10SQC_SAT_to_H10UC_SAT H10UC_SAT_to_H10UPC_SAT.From Undecidability.FRACTRAN Require Import FRACTRAN FRACTRAN_undec. Theorem H10C_SAT_undec : undecidable H10C_SAT. Proof. apply (undecidability_from_reducibility FRACTRAN_undec). apply (reduces_transitive FRACTRAN_DIO.FRACTRAN_HALTING_DIO_LOGIC_SAT). apply (reduces_transitive FRACTRAN_DIO.DIO_LOGIC_ELEM_SAT). exact FRACTRAN_to_H10C_SAT.DIO_ELEM_H10C_SAT. Qed. Theorem H10SQC_SAT_undec : undecidable H10SQC_SAT. 
m, (forall x y : T, {x = y} + {x <> y}) -> (forall (y : T) m', ~ (prd y * prd y)%pred m') -> listpred l m -> NoDup l. Proof. induction l; intuition; constructor; simpl in H0. intro Hin. revert H0. erewrite listpred_pick by (apply Hin). unfold_sep_star; intuition. do 2 destruct H0. intuition. destruct H4. do 2 destruct H3. intuition. eapply H. unfold_sep_star. exists x. exists x2. repeat split; intuition; eauto. subst. apply mem_disjoint_comm. apply mem_disjoint_comm in H0. rewrite mem_union_comm in H0. eapply mem_disjoint_union. eauto. eauto. revert H0. unfold_sep_star. intuition. do 2 destruct H0. intuition. eapply IHl; eauto. Qed. Theorem listpred_nodup_piff : forall l, (forall x y : T, {x = y} + {x <> y}) -> (forall (y : T) m', ~ (prd y * prd y)%pred m') -> listpred l <=p=> [[ NoDup l ]] * listpred l. Proof. intros. split. apply lift_impl. intros. eapply listpred_nodup; eauto. cancel. Qed. Theorem listpred_nodup_F : forall l m, (forall x y : T, {x = y} + {x <> y}) -> (forall (y : T) m', ~ (prd y * prd y)%pred m') -> (exists F, F * listpred l)%pred m -> NoDup l. Proof. intros. destruct_lift H0. rewrite listpred_nodup_piff in H0 by eauto. destruct_lift H0. eauto. Qed. Lemma listpred_permutation: forall a b, Permutation a b -> listpred a <=p=> listpred b. Proof. intros. induction H; cbn; auto. rewrite IHPermutation. auto. split; cancel. rewrite IHPermutation1. rewrite IHPermutation2. auto. Qed. Theorem listpred_remove : forall (dec : forall x y : T, {x = y} + {x <> y}) x l, (forall (y : T) m', ~ (prd y * prd y)%pred m') -> In x l -> listpred l =p=> prd x * listpred (remove dec x l). Proof. intros. induction l. cancel. rewrite listpred_nodup_piff; eauto. simpl; destruct (dec x a). cancel; inversion H2; rewrite remove_not_In; eauto. rewrite IHl; [ cancel | destruct H0; subst; tauto ]. Qed. Theorem listpred_remove' : forall (dec : forall x y : T, {x = y} + {x <> y}) x l, (forall (y : T) m', ~ (prd y * prd y)%pred m') -> NoDup l -> In x l -> prd x * listpred (remove dec x l) =p=> listpred l. Proof. intros. induction l. cancel. simpl; destruct (dec x a); subst. - inversion H0. rewrite remove_not_In; eauto. - simpl; cancel. rewrite <- IHl. cancel. inversion H0. eauto. eauto. Qed. Theorem listpred_remove_piff : forall (dec : forall x y : T, {x = y} + {x <> y}) x l, (forall (y : T) m', ~ (prd y * prd y)%pred m') -> NoDup l -> In x l -> listpred l <=p=> prd x * listpred (remove dec x l). 
Require Import Arith List Wellfounded Extraction.Set Implicit Arguments.Definition eqdec X := forall x y : X, { x = y } + { x <> y }.Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).Tactic Notation "eq" "goal" hyp(H) := match goal with |- ?b => match type of H with ?t => replace b with t; auto end end.Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.Tactic Notation "spec" "in" hyp(H) := let Q := fresh in match goal with G: ?h -> _ |- _ => match G with | H => assert (h) as Q; [ | specialize (H Q); clear Q ] end end.Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.Tactic Notation "solve" "list" "eq" := solve_list_eq.Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H. Tactic Notation "solve" "list" "eq" "in" hyp(H) := let Q := fresh in match goal with |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q end.Ltac msplit n := match n with | 0 => idtac | S ?n => split; [ | msplit n ] end.Ltac lsplit n := match n with | 0 => idtac | S ?n => split; [ lsplit n | ] end.Fact equal_equiv (P Q : Prop) : P = Q -> P <-> Q. Proof. intros []; tauto. Qed.Section forall_equiv. Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n). Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n). Proof using HPQ. split; intros H n Hn; generalize (H _ Hn); apply HPQ; auto. Qed.End forall_equiv.Section exists_equiv. Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n). Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n). 
Add LoadPath "/home/blaine/lab/cpdtlib" as Cpdt. Set Implicit Arguments. Set Asymmetric Patterns.From Coq Require Import Morphisms RelationClasses Setoid. Require Import Cpdt.CpdtTactics. From stdpp Require Import base options fin gmap.Require Import theorems.utils.Notation RegisterBank size := (gmap (fin size) nat). Module AbstractMachine. Parameter size: nat. Record MachineState := machine_state { program_counter: RegisterBank 1; registers: RegisterBank size }. Global Instance state_empty: Empty MachineState := machine_state empty empty. Global Instance state_union: Union MachineState := fun s1 s2 => (machine_state (union s1.(program_counter) s2.(program_counter)) (union s1.(registers) s2.(registers)) ). Theorem state_equality c1 c2 r1 r2: c1 = c2 /\ r1 = r2 <-> (machine_state c1 r1) = (machine_state c2 r2). Proof. naive_solver. Qed. Definition state_disjoint s1 s2 := map_disjoint s1.(program_counter) s2.(program_counter) /\ map_disjoint s1.(registers) s2.(registers). Global Instance state_disjoint_symmetric: Symmetric state_disjoint. Proof. intros ??; unfold state_disjoint; rewrite !map_disjoint_spec; naive_solver. Qed. Theorem state_union_commutative s1 s2: state_disjoint s1 s2 -> union s1 s2 = union s2 s1. Proof. intros [C R]; unfold union, state_union; rewrite (map_union_comm _ _ C); rewrite (map_union_comm _ _ R); reflexivity. Qed. Theorem state_disjoint_union_distributive s1 s2 s3: state_disjoint s1 (union s2 s3) <-> state_disjoint s1 s2 /\ state_disjoint s1 s3. Proof. split; unfold state_disjoint. - intros [?%map_disjoint_union_r ?%map_disjoint_union_r]; naive_solver. - intros [[] []]; split; apply map_disjoint_union_r_2; assumption. Qed. Theorem state_union_associative (s1 s2 s3: MachineState): union s1 (union s2 s3) = union (union s1 s2) s3. Proof. unfold union, state_union; simpl; apply state_equality; apply map_union_assoc. Qed. Theorem state_union_empty_l: forall state: MachineState, union empty state = state. Proof. unfold union, state_union; intros []; simpl; do 2 rewrite map_empty_union; reflexivity. Qed. Theorem state_union_empty_r: forall state: MachineState, union state empty = state. Proof. unfold union, state_union; intros []; simpl; do 2 rewrite map_union_empty; reflexivity. Qed. Theorem state_separate_counter_registers_disjoint: forall registers program_counter, state_disjoint (machine_state empty registers) (machine_state program_counter empty). Proof. intros; hnf; simpl; auto with map_disjoint. Qed. Theorem state_empty_disjoint: forall state, state_disjoint empty state. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. 
with real. apply Rlt_pow_R1; auto with real. intros p p0 H' H'0; apply Rinv_1_lt_contravar; auto with real. apply Rlt_pow; auto with real. apply Pnat.nat_of_P_lt_Lt_compare_morphism; rewrite BinPos.ZC4; auto. Qed. Hint Resolve Rlt_powerRZ: real. Theorem Rpow_R1 : forall (r : R) (z : BinInt.Z), r <> 0%R -> powerRZ r z = 1%R -> Rabs r = 1%R \/ z = 0%Z. intros r z; case z; simpl in |- *; auto; intros p H' H'1; left. case (pow_R1 _ _ H'1); auto. intros H'0; Contradict H'0; auto with zarith; apply convert_not_O. rewrite Rinv_pow in H'1; auto. case (pow_R1 _ _ H'1); auto. intros H'0. rewrite <- H'0. apply Rmult_eq_reg_l with (r := 1%R); auto with real. pattern 1%R at 1 in |- *; rewrite <- H'0; auto with real. pattern (Rabs (/ r)) at 1 in |- *; rewrite Rabs_Rinv; try rewrite Rinv_l; auto with real. rewrite H'0; auto with real. apply Rabs_no_R0; auto. intros H'0; Contradict H'0; auto with zarith; apply convert_not_O. Qed. Theorem Rpow_eq_inv : forall (r : R) (p q : BinInt.Z), r <> 0%R -> Rabs r <> 1%R -> powerRZ r p = powerRZ r q -> p = q. intros r p q H' H'0 H'1. cut (powerRZ r (p - q) = 1%R); [ intros Eq0 | idtac ]. case (Rpow_R1 _ _ H' Eq0); auto with zarith. intros H'2; case H'0; auto. apply Rmult_eq_reg_l with (r := powerRZ r q); auto with real. rewrite <- powerRZ_add; auto. replace (q + (p - q))%Z with p; auto with zarith. rewrite <- H'1; rewrite Rmult_1_r; auto with arith. Qed. Theorem Zpower_nat_powerRZ_absolu : forall n m : BinInt.Z, (0 <= m)%Z -> IZR (Zpower_nat n (Zabs_nat m)) = powerRZ (IZR n) m. intros n m; case m; simpl in |- *; auto with zarith. intros p H'; elim (BinPos.nat_of_P p); simpl in |- *; auto with zarith. intros n0 H'0; rewrite <- H'0; simpl in |- *; auto with zarith. rewrite <- Rmult_IZR; auto. intros p H'; Contradict H'; auto with zarith. Qed. Theorem powerRZ_R1 : forall n : BinInt.Z, powerRZ 1 n = 1%R. intros n; case n; simpl in |- *; auto. intros p; elim (BinPos.nat_of_P p); simpl in |- *; auto; intros n0 H'; rewrite H'; ring. intros p; elim (BinPos.nat_of_P p); simpl in |- *. exact Rinv_1. intros n1 H'; rewrite Rinv_mult_distr; try rewrite Rinv_1; try rewrite H'; auto with real. Qed. Theorem Rle_powerRZ : forall (e : R) (n m : BinInt.Z), (1 <= e)%R -> (n <= m)%Z -> (powerRZ e n <= powerRZ e m)%R. 
apply eqp_imp_canonical with (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a q) p0) (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Hint Resolve CombLinear_pluspf. Theorem CombLinear_mults1 : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)), ~ zeroP (A:=A) A0 eqA (n:=n) a -> CombLinear Q p -> CombLinear Q (mults (A:=A) multA (n:=n) a p). intros Q a p H' H'0; elim H'0; auto. intros a0 p0 q s H'1 H'2 H'3 H'4 H'5. cut (canonical A0 eqA ltM q); [ intros C0 | apply inPolySet_imp_canonical with (L := Q); auto ]. cut (canonical A0 eqA ltM p0); [ intros Op1 | apply CombLinear_canonical with (Q := Q); auto ]. apply CombLinear_1 with (a := multTerm (A:=A) multA (n:=n) a a0) (p := mults (A:=A) multA (n:=n) a p0) (q := q); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) a (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p0)); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a (mults (A:=A) multA (n:=n) a0 q)) (mults (A:=A) multA (n:=n) a p0)); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Hint Resolve CombLinear_mults1. Theorem CombLinear_minuspf : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), CombLinear Q p -> forall q : list (Term A n), CombLinear Q q -> CombLinear Q (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q). intros Q p H' q H'0; try assumption. cut (canonical A0 eqA ltM p); [ intros Op1 | apply CombLinear_canonical with (Q := Q); auto ]. cut (canonical A0 eqA ltM q); [ intros Op2 | apply CombLinear_canonical with (Q := Q); auto ]. apply CombLinear_comp with (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Hint Resolve CombLinear_minuspf. Theorem CombLinear_id : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), inPolySet A A0 eqA n ltM p Q -> CombLinear Q p. 
t (p : W), p = 0 -> [| s %= empty /\ t = Leaf |] ===> bst' s t p. Axiom cons_fwd : forall s t (p : W), p <> 0 -> bst' s t p ===> Ex t1, Ex t2, Ex p1, Ex v, Ex p2, (p ==*> p1, v, p2) * bst' (s %< v) t1 p1 * bst' (s %> v) t2 p2 * [| freeable p 3 /\ t = Node t1 t2 /\ v %in s |]. Axiom cons_bwd : forall s t (p : W), p <> 0 -> (Ex t1, Ex t2, Ex p1, Ex v, Ex p2, (p ==*> p1, v, p2) * bst' (s %< v) t1 p1 * bst' (s %> v) t2 p2 * [| freeable p 3 /\ t = Node t1 t2 /\ v %in s |]) ===> bst' s t p. End BST.Module Bst : BST. Open Scope Sep_scope. Fixpoint bst' (s : set) (t : tree) (p : W) : HProp := match t with | Leaf => [| p = 0 /\ s %= empty |] | Node t1 t2 => [| p <> 0 /\ freeable p 3 |] * Ex p1, Ex v, Ex p2, (p ==*> p1, v, p2) * bst' (s %< v) t1 p1 * bst' (s %> v) t2 p2 * [| v %in s |] end. Definition bst (s : set) (p : W) := [| freeable p 2 |] * Ex t, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * bst' s t r. Theorem bst'_extensional : forall s t p, HProp_extensional (bst' s t p). destruct t; reflexivity. Qed. Theorem bst_extensional : forall s p, HProp_extensional (bst s p). reflexivity. Qed. Theorem bst'_set_extensional : forall t s s' p, s %= s' -> bst' s t p ===> bst' s' t p. induction t; sepLemma. Qed. Theorem bst_fwd : forall s p, bst s p ===> [| freeable p 2 |] * Ex t, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * bst' s t r. unfold bst; sepLemma. Qed. Theorem bst_bwd : forall s p, ([| freeable p 2 |] * Ex t, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * bst' s t r) ===> bst s p. unfold bst; sepLemma. Qed. Theorem nil_fwd : forall s t (p : W), p = 0 -> bst' s t p ===> [| s %= empty /\ t = Leaf |]. 
Import VerdiRaft.CroniesCorrectInterface. Require Import VerdiRaft.VotesCorrectInterface.Require Import VerdiRaft.RefinementCommonTheorems.Require Import VerdiRaft.LeaderLogsSublogInterface.Section LeaderLogsSublog. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lsi : leader_sublog_interface}. Context {lltsi : leaderLogs_term_sanity_interface}. Context {eewci : every_entry_was_created_interface}. Context {llcei : leaderLogs_candidate_entries_interface}. Context {cci : cronies_correct_interface}. Context {vci : votes_correct_interface}. Theorem leaderLogs_sublog_init : refined_raft_net_invariant_init leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_init, leaderLogs_sublog. simpl. intuition. Qed. Ltac start := repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end; rewrite update_fun_comm with (f := snd); simpl in *; match goal with | [ H : context [ type ] |- _ ] => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by auto end; match goal with | [ H : context [ currentTerm ] |- _ ] => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by auto end. Theorem leaderLogs_sublog_client_request : refined_raft_net_invariant_client_request leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_client_request, leaderLogs_sublog. intuition. simpl in *. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleClientRequest_type. intuition. start. find_rewrite_lem update_elections_data_client_request_leaderLogs. find_erewrite_lem update_nop_ext' . update_destruct_max_simplify. - destruct (log d) using (handleClientRequest_log_ind ltac:(eauto)). + eauto. + simpl. right. eauto. - eauto. Qed. Theorem leaderLogs_sublog_timeout : refined_raft_net_invariant_timeout leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_timeout, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleTimeout_type. intuition. - start. find_rewrite_lem update_elections_data_timeout_leaderLogs. find_erewrite_lem update_nop_ext' . update_destruct_max_simplify; eauto. erewrite handleTimeout_log_same by eauto; eauto. - repeat update_destruct_max_simplify; try congruence. + find_rewrite_lem update_elections_data_timeout_leaderLogs. eauto. + eauto. Qed. Lemma handleAppendEntries_leader : forall h st t n pli plt es ci st' m, handleAppendEntries h st t n pli plt es ci = (st', m) -> type st' = Leader -> log st' = log st. Proof using. unfold handleAppendEntries. intros. repeat break_match; repeat find_inversion; simpl in *; auto; discriminate. Qed. Theorem leaderLogs_sublog_append_entries : refined_raft_net_invariant_append_entries leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_append_entries, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleAppendEntries_type. intuition. - start. find_rewrite_lem update_elections_data_appendEntries_leaderLogs. find_erewrite_lem update_nop_ext'. update_destruct_max_simplify; eauto. erewrite handleAppendEntries_leader by (eauto; congruence). eauto. - repeat update_destruct_max_simplify; try congruence. + find_rewrite_lem update_elections_data_appendEntries_leaderLogs. eauto. + eauto. Qed. Theorem leaderLogs_sublog_append_entries_reply : refined_raft_net_invariant_append_entries_reply leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_append_entries_reply, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleAppendEntriesReply_type. intuition. - start. find_erewrite_lem update_nop_ext'. update_destruct_max_simplify; eauto. erewrite handleAppendEntriesReply_same_log by eauto. eauto. - repeat update_destruct_max_simplify; try congruence; eauto. Qed. Theorem leaderLogs_sublog_request_vote : refined_raft_net_invariant_request_vote leaderLogs_sublog. 
Qed. Theorem RoundedModeP_inv2 : forall P, RoundedModeP P -> CompatibleP P. intros P H; Casec H; intros H H1; Casec H1; auto. Qed. Theorem RoundedModeP_inv3 : forall P, RoundedModeP P -> MinOrMaxP P. intros P H; Casec H; intros H H1; Casec H1; intros H1 H2; Casec H2; auto. Qed. Theorem RoundedModeP_inv4 : forall P, RoundedModeP P -> MonotoneP radix P. intros P H; Casec H; intros H H1; Casec H1; intros H1 H2; Casec H2; auto. Qed. Hint Resolve RoundedModeP_inv1 RoundedModeP_inv2 RoundedModeP_inv3 RoundedModeP_inv4: inv. Theorem RoundedProjector : forall P, RoundedModeP P -> ProjectorP b radix P. intros P H'; red in |- *; simpl in |- *. intros p q H'0 H'1. red in H'. elim H'; intros H'2 H'3; elim H'3; intros H'4 H'5; elim H'5; intros H'6 H'7; case (H'6 p q); clear H'5 H'3 H'; auto. intros H'; apply (ProjectMin b radix p); auto. intros H'; apply (ProjectMax b radix p); auto. Qed. Theorem MinCompatible : CompatibleP (isMin b radix). red in |- *. intros r1 r2 p q H' H'0 H'1 H'2; split; auto. rewrite <- H'0; unfold FtoRradix in H'1; rewrite <- H'1; case H'; auto. Qed. Theorem MinRoundedModeP : RoundedModeP (isMin b radix). split; try red in |- *. intros r; apply MinEx with (precision := precision); auto with arith. split; try exact MinCompatible. split; try apply MonotoneMin; red in |- *; auto. Qed. Theorem MaxCompatible : CompatibleP (isMax b radix). red in |- *. intros r1 r2 p q H' H'0 H'1 H'2; split; auto. rewrite <- H'0; unfold FtoRradix in H'1; rewrite <- H'1; case H'; auto. Qed. Theorem MaxRoundedModeP : RoundedModeP (isMax b radix). split; try red in |- *. intros r; apply MaxEx with (precision := precision); auto with arith. split; try exact MaxCompatible. split; try apply MonotoneMax; red in |- *; auto. Qed. Definition ToZeroP (r : R) (p : float) := (0 <= r)%R /\ isMin b radix r p \/ (r <= 0)%R /\ isMax b radix r p. Theorem ToZeroTotal : TotalP ToZeroP. red in |- *; intros r; case (Rle_or_lt r 0); intros H1. case MaxEx with (r := r) (3 := pGivesBound); auto with arith. intros x H'; exists x; red in |- *; auto. case MinEx with (r := r) (3 := pGivesBound); auto with arith. intros x H'; exists x; red in |- *; left; split; auto. apply Rlt_le; auto. Qed. Theorem ToZeroCompatible : CompatibleP ToZeroP. 
x \/ In x l' end.Lemma In_map : forall (A B : Type) (f : A -> B) (l : list A) (x : A), In x l -> In (f x) (map f l). Admitted. Lemma In_map_iff : forall (A B : Type) (f : A -> B) (l : list A) (y : B), In y (map f l) <-> exists x, f x = y /\ In x l. Admitted. Lemma in_app_iff : forall A l l' (a:A), In a (app l l') <-> In a l \/ In a l'. Admitted. Lemma plus_comm3 : forall n m p, n + (m + p) = (p + m) + n. Admitted. Lemma plus_comm3_take2 : forall n m p, n + (m + p) = (p + m) + n. Admitted. Lemma plus_comm3_take3 : forall n m p, n + (m + p) = (p + m) + n. Admitted. Fixpoint rev_append {X} (l1 l2 : list X) : list X := match l1 with | [] => l2 | x :: l1' => rev_append l1' (x :: l2) end.Definition tr_rev {X} (l : list X) : list X := rev_append l [].Lemma tr_rev_correct : forall X, @tr_rev X = @rev X. Admitted. Theorem evenb_double : forall k, evenb (double k) = true. Admitted. Theorem evenb_double_conv : forall n, exists k, n = if evenb n then double k else S (double k). Admitted. Theorem even_bool_prop : forall n, evenb n = true <-> exists k, n = double k. Admitted. Lemma andb_true_iff : forall b1 b2:bool, b1 && b2 = true <-> b1 = true /\ b2 = true. Admitted. Lemma orb_true_iff : forall b1 b2, b1 || b2 = true <-> b1 = true \/ b2 = true. Admitted. Theorem beq_nat_false_iff : forall x y : nat, beq_nat x y = false <-> x <> y. Admitted. Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool := match l with | [] => true | x :: l' => andb (test x) (forallb test l') end.Definition excluded_middle := forall P : Prop, P \/ ~ P.Theorem restricted_excluded_middle : forall P b, (P <-> b = true) -> P \/ ~ P. Admitted. Theorem restricted_excluded_middle_eq : forall (n m : nat), n = m \/ n <> m. Admitted. Theorem excluded_middle_irrefutable: forall (P:Prop), ~ ~ (P \/ ~ P). Admitted. Theorem not_exists_dist : excluded_middle -> forall (X:Type) (P : X -> Prop), ~ (exists x, ~ P x) -> (forall x, P x). 
in Hred. inversion Hred. Qed. Lemma fill_item_impl_inv' se' sK ie sσ sg : reducible se' sσ sg → expr_impl (fill_item sK se') ie → ∃ iK ie', ie = fill_item iK ie' ∧ ectx_item_impl sK iK ∧ expr_impl se' ie'. Proof. intros Hred. induction sK; simpl; intros Himpl; inv_expr_impl; try (do 2 eexists; split_and!; eauto; simpl; done). - assert (irreducible (Var x) sσ sg) as Hirred. { apply stuck_Var. } apply not_reducible in Hirred; intuition eauto. - apply reducible_not_val in Hred. inversion Hred. Qed. Definition ectx_impl sK iK := Forall2 ectx_item_impl sK iK. Lemma fill_impl_inv se iK ie' iσ ig : reducible ie' iσ ig → expr_impl se (fill iK ie') → ∃ sK se', se = fill sK se' ∧ ectx_impl sK iK ∧ expr_impl se' ie'. Proof. revert se ie' iσ ig. induction iK => se ie' iσ ig. - rewrite //=. intros. eexists [], _. split_and!; eauto. econstructor. - intros Hred Himpl. simpl in Himpl. eapply IHiK in Himpl as (sK&se'1&Heq&HKimpl'&Himpl'); last first. { apply reducible_fill; eauto. } subst. eapply fill_item_impl_inv in Himpl' as (a'&?&?&?&?); eauto. eexists (a' :: sK), _. split_and!; eauto. { subst. rewrite //=. } { econstructor; eauto. } Qed. Lemma fill_impl_inv' se' sK ie sσ sg : reducible se' sσ sg → expr_impl (fill sK se') ie → ∃ iK ie', ie = fill iK ie' ∧ ectx_impl sK iK ∧ expr_impl se' ie'. Proof. revert se' ie sσ sg. induction sK => se' ie sσ sg. - rewrite //=. intros. eexists [], _. split_and!; eauto. econstructor. - intros Hred Himpl. simpl in Himpl. eapply IHsK in Himpl as (iK&ie'1&Heq&HKimpl'&Himpl'); last first. { apply reducible_fill; eauto. } subst. eapply fill_item_impl_inv' in Himpl' as (a'&?&?&?&?); eauto. eexists (a' :: iK), _. split_and!; eauto. { subst. rewrite //=. } { econstructor; eauto. } Qed. Lemma fill_item_impl se sK ie iK : ectx_item_impl sK iK → expr_impl se ie → expr_impl (fill_item sK se) (fill_item iK ie). Proof. induction 1; rewrite //=; eauto. Qed. Lemma fill_impl se sK ie iK : ectx_impl sK iK → expr_impl se ie → expr_impl (fill sK se) (fill iK ie). Proof. intros Hectx. revert se ie. induction Hectx => se ie ?; rewrite //=; eauto. apply IHHectx. apply fill_item_impl; eauto. Qed. Lemma fo_prim_sub K se sσ sg: fo_prim (fill K se) sσ sg → fo_head se sσ sg. Proof. rewrite /fo_prim/fo_head. intros Hprim Hhead. intros. eapply Hprim. econstructor; eauto. Qed. Theorem prim_step_simulation ie1 iσ1 ig1 κ ie2 iσ2 ig2 iefs se1 sσ1 sg1 : in_wf_ctxt se1 sσ1 sg1 → fo_prim se1 sσ1 sg1 → prim_step ie1 iσ1 ig1 κ ie2 iσ2 ig2 iefs → expr_impl se1 ie1 → abstraction sσ1 sg1 iσ1 ig1 → (∃ se2 sσ2 sg2 sκ sefs, prim_step se1 sσ1 sg1 sκ se2 sσ2 sg2 sefs ∧ expr_impl se2 ie2 ∧ abstraction sσ2 sg2 iσ2 ig2 ∧ Forall2 expr_impl sefs iefs). 
Require Import Setoid Program. Require Import VST.concurrency.paco.src.paco. CoInductive stream := | cons : nat -> stream -> stream. Definition sunf s := match s with cons n s' => cons n s' end.Lemma sunf_eq : forall s, s = sunf s. Proof. destruct s; auto. Qed. CoFixpoint enumerate n : stream := cons n (enumerate (S n)).CoFixpoint map f s : stream := match s with cons n s' => cons (f n) (map f s') end. Inductive seq_gen seq : stream -> stream -> Prop := | _seq_gen : forall n s1 s2 (R : seq s1 s2 : Prop), seq_gen seq (cons n s1) (cons n s2). Hint Constructors seq_gen.CoInductive seq : stream -> stream -> Prop := | seq_fold : forall s1 s2, seq_gen seq s1 s2 -> seq s1 s2. Theorem example : forall n, seq (enumerate n) (cons n (map S (enumerate n))). 
pcT stT funcs (preds : SE.predicates ts pcT stT) cs s vars uvars stn m, SE.ST.satisfies cs (SE.sexprD funcs preds uvars vars s) stn m -> SE.WellTyped_sexpr (typeof_funcs funcs) (SE.typeof_preds preds) (typeof_env uvars) (typeof_env vars) s = true. Proof. induction s; simpl; intros; auto. { consider (exprD funcs uvars vars e tvProp); intros. eapply is_well_typed_correct_only in H; eauto using typeof_env_WellTyped_env, typeof_funcs_WellTyped_funcs. eapply SE.ST.satisfies_pure in H0. unfold BadInj. intuition. PropXTac.propxFo. } { eapply SE.ST.satisfies_star in H. repeat match goal with | [ H : exists x, _ |- _ ] => destruct H | [ H : _ /\ _ |- _ ] => destruct H end. erewrite IHs1; eauto. erewrite IHs2; eauto. } { eapply SE.ST.satisfies_ex in H. destruct H. eapply IHs in H. simpl in *. auto. } { unfold SE.typeof_preds. rewrite map_nth_error_full. destruct (nth_error preds f). { destruct p; simpl in *. generalize dependent SDomain. clear. induction l; destruct SDomain; simpl; intros; auto. eapply SE.ST.satisfies_pure in H. unfold BadPredApply. intuition. PropXTac.propxFo. eapply SE.ST.satisfies_pure in H. unfold BadPredApply. intuition. PropXTac.propxFo. consider (exprD funcs uvars vars a t); intros. erewrite is_well_typed_correct_only; eauto using typeof_env_WellTyped_env, typeof_funcs_WellTyped_funcs. eapply SE.ST.satisfies_pure in H0. unfold BadPredApply. intuition. PropXTac.propxFo. } { eapply SE.ST.satisfies_pure in H. unfold BadPred. intuition. PropXTac.propxFo. } } Qed. Theorem himp_not_WellTyped_sexpr : forall ts pcT stT funcs (preds : SE.predicates ts pcT stT) cs s vars uvars, SE.WellTyped_sexpr (typeof_funcs funcs) (SE.typeof_preds preds) (typeof_env uvars) (typeof_env vars) s = false -> SE.ST.himp cs (SE.sexprD funcs preds uvars vars s) (SE.ST.inj [| False |]). Proof. induction s; simpl; intros; auto; try congruence. { consider (exprD funcs uvars vars e tvProp); intros; try reflexivity. eapply is_well_typed_correct_only in H0; eauto using typeof_env_WellTyped_env, typeof_funcs_WellTyped_funcs. congruence. } { apply andb_false_iff in H. destruct H. rewrite IHs1 by auto. eapply SE.ST.himp_star_pure_c; contradiction. rewrite SE.ST.heq_star_comm. rewrite IHs2 by auto. eapply SE.ST.himp_star_pure_c; contradiction. } { eapply SE.ST.himp_ex_p. intros. rewrite IHs. reflexivity. auto. } { unfold SE.typeof_preds in H. rewrite map_nth_error_full in H. destruct (nth_error preds f); try reflexivity. destruct p; simpl in *. generalize dependent SDomain. induction l; destruct SDomain; simpl in *; intros; auto; try (congruence || reflexivity). consider (is_well_typed (typeof_funcs funcs) (typeof_env uvars) (typeof_env vars) a t); intros. eapply is_well_typed_correct in H. destruct H. rewrite H. rewrite IHl. reflexivity. auto. eauto using typeof_env_WellTyped_env. eauto using typeof_env_WellTyped_env. eauto using typeof_funcs_WellTyped_funcs. consider (exprD funcs uvars vars a t); intros; try reflexivity. eapply is_well_typed_correct_only in H1; eauto using typeof_env_WellTyped_env, typeof_funcs_WellTyped_funcs. congruence. } Qed. Theorem himp_WellTyped_sexpr : forall ts pcT stT funcs (preds : SE.predicates ts pcT stT) cs s vars uvars Q, (SE.WellTyped_sexpr (typeof_funcs funcs) (SE.typeof_preds preds) (typeof_env uvars) (typeof_env vars) s = true -> SE.ST.himp cs (SE.sexprD funcs preds uvars vars s) Q) -> SE.ST.himp cs (SE.sexprD funcs preds uvars vars s) Q. 
Require Import Undecidability.Synthetic.Undecidability.Require Import Undecidability.HilbertCalculi.HSC.Require Undecidability.HilbertCalculi.Reductions.MPCPb_to_HSC_PRV. Require Undecidability.HilbertCalculi.Reductions.MPCPb_to_HSC_AX.Require Import Undecidability.PCP.PCP_undec. Definition ΓPCP := MPCPb_to_HSC_PRV.Argument.ΓPCP. Theorem HSC_PRV_undec : undecidable (HSC_PRV ΓPCP). 
simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. apply fold1_xelements with (l := @nil (positive * A)). Qed.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. unfold init. unfold get. simpl. rewrite PTree.gempty. auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. 
simpl in |- *; intros; rewrite Qpositive_mult_minus_distr; auto with *. intros H H0 H1 n q; elim H. apply Qpositive_le_antisym; auto. apply Qpositive_le_mult; auto with *. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q H H0 H1; elim H. apply Qpositive_mult_simpl with z'; auto. intros n q H H0 H1; elim H. apply Qpositive_mult_simpl with z'; apply Qpositive_le_antisym; auto with *. apply Qpositive_le_mult; auto. intros H H0 H3 H1 H2 H4. simpl in |- *. rewrite Qpositive_mult_minus_distr; auto. intros y'; case x.simpl in |- *; repeat rewrite Qplus_zero_left; auto.intros x'; simpl in |- *. Case' (Qpositive_le_dec x' y'). case (Qpositive_eq_dec x' y'). Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). auto. intros n q e q0; elim n; rewrite e; auto. intros n H0 H1 e q; elim n; rewrite e; auto. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q n; elim n; apply Qpositive_mult_simpl with z'; auto. simpl in |- *. intros; rewrite Qpositive_mult_minus_distr; auto with *. intros H H0 H1 n q; elim H1; apply Qpositive_le_mult; auto with *. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q n; elim n; apply Qpositive_mult_simpl with z'; auto. intros n q H H0 H1; elim n. apply Qpositive_le_antisym; auto. apply Qpositive_le_mult; auto with *. simpl in |- *. intros; rewrite Qpositive_mult_minus_distr; auto.intros x'; simpl in |- *; rewrite Qpositive_mult_distr; auto with *. Qed. Theorem Qmult_zero : forall x : Q, Qmult Zero x = Zero. intros x; case x; simpl in |- *; auto. Qed. Theorem Qmult_neg : forall (x : Q) (y' : Qpositive), Qopp (Qmult x (Qneg y')) = Qmult x (Qpos y'). intros x; case x; auto. Qed. Theorem Qopp_plus : forall x y : Q, Qopp (Qplus x y) = Qplus (Qopp x) (Qopp y). intros x y. rewrite <- (Qplus_zero_left (Qplus (Qopp x) (Qopp y))). rewrite <- (Q_opp_def (Qplus x y)). rewrite (Qplus_sym (Qplus x y)). pattern (Qplus x y) at 3 in |- *; rewrite Qplus_sym. rewrite Qplus_assoc. rewrite Qplus_assoc. rewrite <- (fun a b : Q => Qplus_assoc a b (Qopp x)). rewrite Q_opp_def. rewrite <- (Qplus_sym Zero); rewrite Qplus_zero_left. rewrite <- Qplus_assoc; rewrite Q_opp_def. rewrite <- (Qplus_sym Zero); rewrite Qplus_zero_left. auto. Qed. Theorem Q_distr_left : forall x y z : Q, Qmult (Qplus x y) z = Qplus (Qmult x z) (Qmult y z). 
: @mem addr (@weq addrlen) valuset) hm : @pred addr (@weq addrlen) valuset := (exists hv, [[ (block1 |-> (a, nil) * block2 |-> (b, nil) * hash_block |-> (hash_to_valu hv, nil))%pred d ]] * [[ hash_list_rep (b' :: a' :: nil) hv hm ]])%pred. Definition rep a b (d : @mem addr (@weq addrlen) valuset) hm : @pred addr (@weq addrlen) valuset := any_hash_rep a b a b d hm. Definition crep (a b a' b' : valu) hm : @pred addr (@weq addrlen) valuset := (exists hv hv', block1 |->? * block2 |->? * ( hash_block |-> (hash_to_valu hv, nil) * [[ hash_list_rep (b :: a :: nil) hv hm ]] \/ hash_block |-> (hash_to_valu hv', hash_to_valu hv :: nil) * [[ hash_list_rep (b :: a :: nil) hv hm /\ hash_list_rep (b' :: a' :: nil) hv' hm ]] \/ hash_block |-> (hash_to_valu hv', nil) * [[ hash_list_rep (b' :: a' :: nil) hv' hm ]]))%pred.Definition put T cs d1 d2 rx : prog T := cs <- BUFCACHE.write block1 d1 cs; cs <- BUFCACHE.write block2 d2 cs; h <- hash_list (d1 :: d2 :: nil); cs <- BUFCACHE.write hash_block (hash_to_valu h) cs; cs <- BUFCACHE.sync block1 cs; cs <- BUFCACHE.sync block2 cs; cs <- BUFCACHE.sync hash_block cs; rx cs.Definition get T cs rx : prog T := let^ (cs, d1) <- BUFCACHE.read block1 cs; let^ (cs, d2) <- BUFCACHE.read block2 cs; rx ^(d1, d2).Definition recover T cs rx : prog T := let^ (cs, d1) <- BUFCACHE.read block1 cs; let^ (cs, d2) <- BUFCACHE.read block2 cs; let^ (cs, diskh) <- BUFCACHE.read hash_block cs; h <- hash_list (d1 :: d2 :: nil); If (weq diskh (hash_to_valu h)) { rx cs } else { cs <- put cs default_valu default_valu; rx cs }. Theorem put_ok : forall cs d1 d2, {< d d1_old d2_old d1_old' d2_old', PRE:hm BUFCACHE.rep cs d * any_hash_rep d1_old d2_old d1_old' d2_old' d hm POST:hm' RET:cs' exists d', BUFCACHE.rep cs' d' * rep d1 d2 d' hm' CRASH:hm_crash exists cs' d', BUFCACHE.rep cs' d' * [[ (crep d1_old' d2_old' d1 d2 hm_crash)%pred d' ]] >} put cs d1 d2. Proof. unfold put, rep, any_hash_rep, crep. step. step. step. apply goodSize_bound with (bound := 2); auto. step. step. step. step. step. solve_hash_list_rep. all: cancel_with solve_hash_list_rep. Grab Existential Variables. all: eauto. Qed.Hint Extern 1 ({{_}} progseq (put _ _ _) _) => apply put_ok : prog. Theorem get_ok : forall cs, {< d d1 d2, PRE:hm BUFCACHE.rep cs d * rep d1 d2 d hm POST:hm' RET:^(d1', d2') exists cs', BUFCACHE.rep cs' d * rep d1 d2 d hm' * [[ d1 = d1' /\ d2 = d2' ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d * rep d1 d2 d hm' >} get cs. 
in *. unfold eqbPair in *. simpl in *. rewrite H1 in H. case_eq (eqb a0 a); intuition. rewrite H2 in H. simpl in *. eapply IHx1; eauto. rewrite H2 in H. simpl in *. eapply IHx1; eauto. Qed. Theorem in_impl_collidesWith : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B), In (a, b) ls -> a <> a' -> collidesWith _ _ ls a' b = true. unfold collidesWith in *. induction ls; intuition; simpl in *. intuition. pairInv. case_eq (eqb a' a); intuition. rewrite eqb_leibniz in H. subst. intuition. rewrite eqb_refl. simpl in *. trivial. case_eq (eqb b1 b0); intuition. case_eq (eqb a' a0); intuition. simpl. eapply IHls; intuition. eauto. subst; intuition. simpl. eapply IHls; eauto. Qed. Theorem funcCollision_false_impl_collidesWith_false : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B), funcCollision _ _ ls = false -> In (a, b) ls -> collidesWith _ _ ls a b = false. induction ls; intuition; simpl in *. intuition. pairInv. unfold collidesWith, funcCollision in *. simpl in *. repeat rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b1); intuition. rewrite H0 in H. discriminate. unfold collidesWith, funcCollision in *. simpl in *. case_eq (eqb a0 a); intuition. rewrite eqb_leibniz in H0. subst. rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b0); intuition; rewrite H0 in H. discriminate. case_eq (eqb b1 b0); intuition. simpl. eapply IHls; intuition. simpl. eapply IHls; intuition. assert (a <> a0). intuition. subst. rewrite eqb_refl in H0. discriminate. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H3. subst. intuition. simpl. case_eq (eqb b1 b0); intuition. simpl. rewrite eqb_leibniz in H4. subst. specialize (in_impl_collidesWith _ _ ls _ H1 H2); intuition. unfold collidesWith in H4. destruct (findCollision_1 eqda eqdb ls a0 b0); discriminate. simpl. case_eq (findCollision_1 eqda eqdb ls a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). induction arr; intuition; simpl in *. discriminate. remember (split arr) as z. destruct z. simpl. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H0. intuition. rewrite H0 in H. right. eapply IHarr; intuition. eauto. Qed. Theorem arrayLookup_noCollision_eq_f : forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. 
:= d2g f x xe'). simpl in d3. assert (is1 : isofhlevelf n (d2g f x xe')). assert (h : ∏ ee : x' = x, paths (maponpaths f (pathsinv0 ee)) (d2g f x xe' ee)). { intro. unfold d2g. simpl. apply (pathsinv0 (pathscomp0rid _)). } assert (is2 : isofhlevelf n (λ ee: x' = x, maponpaths f (pathsinv0 ee))) by apply (isofhlevelfgtogw n ( make_weq _ (isweqpathsinv0 _ _)) (@maponpaths _ _ f x x') (X0 x x')). apply (isofhlevelfhomot n _ _ h is2). apply (isofhlevelweqb n (ezweq3g f x xe' e) (is1 e)). Defined. Theorem isofhlevelfssn (n : nat) {X Y : UU} (f : X -> Y) : (∏ x : X, isofhlevelf (S n) (@maponpaths _ _ f x x)) -> isofhlevelf (S (S n)) f. Proof. intros X0. unfold isofhlevelf. intro y. assert (∏ xe0 : hfiber f y, isofhlevel (S n) (xe0 = xe0)). { intro. induction xe0 as [ x e ]. induction e. set (e':= idpath (f x)). set (xe':= make_hfiber f x e'). set (xe:= make_hfiber f x e'). set (d3:= d2g f x xe'). simpl in d3. assert (is1: isofhlevelf (S n) (d2g f x xe')). { assert (h : ∏ ee: x = x, paths (maponpaths f (pathsinv0 ee)) (d2g f x xe' ee)). { intro. unfold d2g. simpl. apply (pathsinv0 (pathscomp0rid _)). } assert (is2 : isofhlevelf (S n) (fun ee : x = x => maponpaths f (pathsinv0 ee))) by apply (isofhlevelfgtogw (S n) (make_weq _ (isweqpathsinv0 _ _)) (@maponpaths _ _ f x x) (X0 x)). apply (isofhlevelfhomot (S n) _ _ h is2). } apply (isofhlevelweqb (S n) (ezweq3g f x xe' e') (is1 e')). } apply (isofhlevelssn). assumption. Defined.Theorem isofhlevelfpr1 (n : nat) {X : UU} (P : X -> UU) (is : ∏ x : X, isofhlevel n (P x)) : isofhlevelf n (@pr1 X P). Proof. intros. unfold isofhlevelf. intro x. apply (isofhlevelweqf n (ezweqpr1 _ x) (is x)). Defined.Lemma isweqpr1 {Z : UU} (P : Z -> UU) (is1 : ∏ z : Z, iscontr (P z)) : isweq (@pr1 Z P). Proof. intros. unfold isweq. intro y. set (isy := is1 y). apply (iscontrweqf (ezweqpr1 P y)). assumption. Defined.Definition weqpr1 {Z : UU} (P : Z -> UU) (is : ∏ z : Z , iscontr (P z)) : weq (total2 P) Z := make_weq _ (isweqpr1 P is). Theorem isofhleveltotal2 (n : nat) {X : UU} (P : X -> UU) (is1 : isofhlevel n X) (is2 : ∏ x : X, isofhlevel n (P x)) : isofhlevel n (total2 P). 
Require Import Omega.Section Group.Variable G : Set. Variable e : G. Variable m : G. Variable z : G. Variable f : G -> G -> G. Variable q : G -> G -> G. Infix "<+>" := f (at level 50). Infix "<o>" := q (at level 50). Variable id_r : forall a, a <+> m = a. Variable id_l : forall a, e <+> a = a. Variable id_r_o: forall a, z <o> a = a.Lemma foobar: (forall b, b <+> m = b) -> (forall b, e <+> b = b) -> (e <+> m) <+> (e <+> m) = m <+> m. Proof. intros. assert ((e <+> m) <+> (e <+> m) = m <+> (e <+> m)) as H1. { rewrite H0. reflexivity. } rewrite H1. clear H1. Theorem iden_eq_short: (forall b, b <+> m = b) -> (forall b, e <+> b = b) -> forall b, b <+> (e <+> m) = b. intros. assert ((e <+> m) <+> (e <+> m) = m <+> m) as H3. rewrite H0. reflexivity. rewrite H3. clear H3. rewrite -> H0. rewrite -> H. reflexivity. Qed. Print iden_eq_short.Hint Rewrite id_r id_l : ids. Theorem iden_eq_short_auto: (forall b, b <+> m = b) -> (forall b, e <+> b = b) -> forall b, b <+> (e <+> m) = b. intros. autorewrite with ids in *. reflexivity. Qed.Print iden_eq_short_auto. Theorem iden_eq_long_plus: (forall a, a <+> m = a) -> (forall a, e <+> a = a) -> forall a, a <+> (e <+> m) = a. 
apply RoundedModeMultAbs with (b := b) (precision := precision) (P := P) (r := (p * q)%R); auto. unfold pPred in |- *; apply maxFbounded; auto with zarith. rewrite Rabs_mult; auto. apply Rle_trans with (FtoR radix (Fmult (Float (pPred (vNum b)) (Fexp p)) (Float (pPred (vNum b)) (Fexp q)))). rewrite Fmult_correct; auto with arith. apply Rmult_le_compat; auto with real. rewrite <- (Fabs_correct radix); try apply maxMax1; auto with zarith. rewrite <- (Fabs_correct radix); try apply maxMax1; auto with zarith. unfold Fmult, FtoR in |- *; simpl in |- *; auto. rewrite powerRZ_add with (n := Z_of_nat (pred precision)); auto with real arith. repeat rewrite <- Rmult_assoc. repeat rewrite (fun (z : Z) (x : R) => Rmult_comm x (powerRZ radix z)); auto. apply Rmult_le_compat_l; auto with real arith. rewrite <- Rmult_assoc. rewrite (fun x : R => Rmult_comm x radix). rewrite <- powerRZ_Zs; auto with real arith. replace (Zsucc (pred precision)) with (Z_of_nat precision). rewrite Rmult_IZR; auto. apply Rmult_le_compat; auto with real arith. replace 0%R with (IZR 0); unfold pPred in |- *; try apply Rle_IZR; auto with real zarith. replace 0%R with (IZR 0); unfold pPred in |- *; try apply Rle_IZR; auto with real zarith. unfold pPred in |- *; rewrite pGivesBound; rewrite <- Zpower_nat_Z_powerRZ; auto with real zarith. rewrite inj_pred; auto with arith zarith. auto with real zarith. auto with real zarith. unfold FtoRradix, FtoR in |- *; simpl in |- *. repeat rewrite (Rmult_comm (pPred (vNum b))). rewrite <- Rmult_assoc. rewrite <- powerRZ_Zs; auto with real zarith. rewrite inj_pred; auto with arith zarith. replace (Zsucc (Zpred precision + (Fexp p + Fexp q))) with (precision + (Fexp p + Fexp q))%Z; auto; unfold Zsucc, Zpred in |- *; ring. Qed. Theorem errorBoundedMultPos : forall P, RoundedModeP b radix P -> forall p q f : float, Fbounded b p -> Fbounded b q -> (0 <= p)%R -> (0 <= q)%R -> (- dExp b <= Fexp p + Fexp q)%Z -> P (p * q)%R f -> exists r : float, r = (p * q - f)%R :>R /\ Fbounded b r /\ Fexp r = (Fexp p + Fexp q)%Z. intros P H p q f H0 H1 H2 H3 H4 H5. generalize errorBoundedMultMin errorBoundedMultMax; intros H6 H7. cut (MinOrMaxP b radix P); [ intros | case H; intros H'1 (H'2, (H'3, H'4)); auto ]. case (H8 (p * q)%R f); auto. Qed. Theorem errorBoundedMultNeg : forall P, RoundedModeP b radix P -> forall p q f : float, Fbounded b p -> Fbounded b q -> (p <= 0)%R -> (0 <= q)%R -> (- dExp b <= Fexp p + Fexp q)%Z -> P (p * q)%R f -> exists r : float, r = (p * q - f)%R :>R /\ Fbounded b r /\ Fexp r = (Fexp p + Fexp q)%Z. 
"[[%Huaddr Hb] Hblocks]"; eauto. iSpecialize ("Hblocks" with "[$Hb //]"). iFrame "Hblocks". rewrite Huaddr. erewrite take_S_r; eauto. erewrite memLogMap_append; eauto; len. } rewrite -> take_ge by len. iIntros "(HI&Hs)"; iNamed "HI". wp_pures. wp_apply wp_slice_len. rewrite -wp_fupd. wp_apply wp_allocStruct; first val_ty. iIntros (l) "Hl". iDestruct (struct_fields_split with "Hl") as "(Hf1&Hf2&Hf3&HfneedFlush&Hf4&%)". iAssert (updates_slice_frag s q log) with "[Hs Hblocks]" as "Hlog". { iExists _; iFrame. } iDestruct (updates_slice_frag_split _ _ _ (U64 $ length log) with "Hlog") as "[Hmut Hreadonly]". { word. } rewrite -> drop_ge by word. rewrite -> take_ge by word. iMod (readonly_alloc (updates_slice_frag (slice_take s (length log)) 1 log) q with "[$Hreadonly]") as "#Hreadonly". iModIntro. iApply "HΦ". iSplitL "". { iPureIntro. rewrite /slidingM.wf//=; split; word. } iExists _, _. iFrame; simpl. iSplitL "Hf3". { rewrite /named. iExactEq "Hf3". do 3 f_equal. word. } iSplitL "HfneedFlush"; first by auto. iDestruct (is_slice_cap_wf with "Hcap") as %Hcap. iSplitR. - rewrite /readonly_log /slidingM.numMutable /=. rewrite -> take_ge by word. replace (word.sub (int.Z start + length log) start) with (U64 (length log)) by word. iFrame "Hreadonly". - rewrite /mutable_log /slidingM.numMutable /=. iSplit. + iPureIntro. word. + rewrite -> drop_ge by word. replace (word.sub (int.Z start + length log) start) with (U64 (length log)) by word. iExists []; simpl. rewrite right_id. iApply is_slice_split. iDestruct (is_slice_cap_skip _ _ (U64 (length log)) with "Hcap") as "Hcap"; first by word. iFrame. iApply is_slice_small_nil. simpl; word. Qed.Hint Unfold slidingM.wf : word. Hint Unfold slidingM.numMutable : word.Theorem memLog_combine s σ : slidingM.wf σ -> readonly_log s σ -∗ mutable_log s 1 σ -∗ |={⊤}=> ∃ q, updates_slice_frag s q (slidingM.log σ) ∗ (updates_slice_frag s q (slidingM.log σ) -∗ mutable_log s 1 σ). Proof. rewrite /mutable_log. iIntros (Hwf) "Hread Hmut". iDestruct "Hmut" as "(%logSlice_wf&Hmut)"; rewrite /named. iMod (readonly_load_lt with "Hread") as (q) "[%Hqlt HreadLog]". iModIntro. destruct (Qextra.Qp_split_1 _ Hqlt) as [q' Hqq']. iDestruct (updates_slice_frag_acc with "Hmut") as "[Hmut Hmut_full]". iEval (rewrite -Hqq') in "Hmut". iDestruct (fractional.fractional_split_1 with "Hmut") as "[Hmut Hq']". iDestruct (updates_slice_frag_len with "HreadLog") as %Hlen1. iDestruct (updates_slice_frag_len with "Hmut") as %Hlen2. autorewrite with len in Hlen1, Hlen2. simpl in Hlen1, Hlen2. iDestruct (updates_slice_frag_combine with "[$Hmut $HreadLog]") as "Hlog". { destruct Hwf as (?&?&?). revert Hlen1 Hlen2; word. } iExists q; iFrame. iIntros "Hupds". rewrite -Hqq'. iDestruct (updates_slice_frag_split _ _ _ (slidingM.numMutable σ) with "Hupds") as "[Hupds2 Hupds1]". { revert Hlen1 Hlen2; word. } iSplit; auto. iCombine "Hupds2 Hq'" as "Hmut". iSpecialize ("Hmut_full" with "Hmut"). iFrame. Qed.Hint Unfold slidingM.endPos : word. Theorem slidingM_endPos_val σ : slidingM.wf σ -> int.Z (slidingM.endPos σ) = int.Z σ.(slidingM.start) + length σ.(slidingM.log). 
Require Export Fop. Section Fbounded_Def. Variable radix : Z. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith.Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Coercion Z_of_N: N >-> Z. Record Fbound : Set := Bound {vNum : positive; dExp : N}. Definition Fbounded (b : Fbound) (d : float) := (Zabs (Fnum d) < Zpos (vNum b))%Z /\ (- dExp b <= Fexp d)%Z. Theorem FboundedNum : forall (b : Fbound) (p : float), Fbounded b p -> (Zabs (Fnum p) < Zpos (vNum b))%Z. intros b p H; case H; intros H1 H2; case H1; auto. Qed. Theorem FboundedExp : forall (b : Fbound) (p : float), Fbounded b p -> (- dExp b <= Fexp p)%Z. 
(pPred (vNum b))); auto. intros H'1; absurd (0%nat <= pPred (vNum b))%Z; auto with zarith arith. rewrite <- H'1. unfold nNormMin in |- *; simpl in |- *; auto with zarith. replace 0%Z with (- (0))%Z; auto with zarith. unfold pPred in |- *; apply Zle_Zpred; auto with zarith. intros H'; generalize (Z_eq_bool_correct (- nNormMin radix precision) (- nNormMin radix precision)); case (Z_eq_bool (- nNormMin radix precision) (- nNormMin radix precision)). intros H'0; generalize (Z_eq_bool_correct (- dExp b) (- dExp b)); case (Z_eq_bool (- dExp b) (- dExp b)); auto. intros H'1; Contradict H'1; auto. intros H'1; Contradict H'1; auto. Qed. Theorem FSuccSimpl4 : forall x : float, Fnum x <> pPred (vNum b) -> Fnum x <> (- nNormMin radix precision)%Z -> FSucc x = Float (Zsucc (Fnum x)) (Fexp x). intros x H' H'0; unfold FSucc in |- *. generalize (Z_eq_bool_correct (Fnum x) (pPred (vNum b))); case (Z_eq_bool (Fnum x) (pPred (vNum b))); auto. intros H'1; Contradict H'; auto. intros H'1; generalize (Z_eq_bool_correct (Fnum x) (- nNormMin radix precision)); case (Z_eq_bool (Fnum x) (- nNormMin radix precision)); auto. intros H'2; Contradict H'0; auto. Qed. Theorem FSuccDiff1 : forall x : float, Fnum x <> (- nNormMin radix precision)%Z -> Fminus radix (FSucc x) x = Float 1%nat (Fexp x) :>R. intros x H'. generalize (Z_eq_bool_correct (Fnum x) (pPred (vNum b))); case (Z_eq_bool (Fnum x) (pPred (vNum b))); intros H'1. rewrite FSuccSimpl1; auto. unfold FtoRradix, FtoR, Fminus, Fopp, Fplus in |- *; simpl in |- *; auto. repeat rewrite Zmin_le2; auto with zarith. rewrite <- Zminus_succ_l; repeat rewrite <- Zminus_diag_reverse. rewrite absolu_Zs; auto with zarith; simpl in |- *. rewrite H'1; unfold pPred in |- *; rewrite pGivesBound; unfold nNormMin in |- *. replace (Zpower_nat radix (pred precision) * (radix * 1))%Z with (Zpower_nat radix precision). f_equal. unfold Zpred. rewrite Z.opp_add_distr. rewrite Z.mul_1_r. rewrite Z.add_assoc. now rewrite Z.add_opp_diag_r. rewrite Z.mul_1_r. pattern precision at 1 in |- *; replace precision with (pred precision + 1). rewrite Zpower_nat_is_exp; rewrite Zpower_nat_1; auto. generalize precisionNotZero; case precision; simpl in |- *; auto with zarith arith. rewrite FSuccSimpl4; auto. unfold FtoRradix, FtoR, Fminus, Fopp, Fplus in |- *; simpl in |- *; auto. repeat rewrite Zmin_n_n; repeat rewrite <- Zminus_diag_reverse; simpl in |- *. repeat rewrite Zmult_1_r. replace (Zsucc (Fnum x) + - Fnum x)%Z with (Z_of_nat 1). simpl in |- *; auto. simpl in |- *; unfold Zsucc in |- *; ring. Qed. Theorem FSuccDiff2 : forall x : float, Fnum x = (- nNormMin radix precision)%Z -> Fexp x = (- dExp b)%Z -> Fminus radix (FSucc x) x = Float 1%nat (Fexp x) :>R. 
Lock_in_network_eventually_MsgLock, lb_step_execution_invar, weak_fairness_invar. Qed. Lemma Nth_snoc : forall A (l : list A) x, Nth (l ++ [x]) (length l) x. Proof using. intros. induction l; simpl in *; constructor; auto. Qed. Lemma MsgLock_in_queue_or_Locked : forall c s, lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (MsgLock c)) s -> next (fun s => In (mkPacket Server (Client c) Locked) (nwPackets (evt_a (hd s)))) s \/ exists n, next (fun s => Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c) s. Proof using. intros. invcs H. invcs H2. - monad_unfold. unfold NetHandler in *. break_match_hyp. + unfold occurred in *. find_apply_lem_hyp ClientNetHandler_lbcases; intuition; congruence. + unfold occurred in *. find_apply_lem_hyp ServerNetHandler_lbcases; intuition; break_exists; intuition; try congruence; [left|right]; fold LockServ_MultiParams in *; repeat find_rewrite; simpl. * left. congruence. * update_destruct_max_simplify; try congruence. find_inversion. repeat find_rewrite. destruct (queue (nwState (evt_a e) Server)) eqn:?; try congruence. exists (length l). simpl. constructor. apply Nth_snoc. - monad_unfold. find_apply_lem_hyp InputHandler_lbcases. intuition; try congruence. break_exists. intuition; congruence. - unfold occurred in *. congruence. Qed. Lemma MsgLock_Locked : forall c s, event_step_star step_async step_async_init (hd s) -> lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (MsgLock c)) s -> eventually (fun s => In (mkPacket Server (Client c) Locked) (nwPackets (evt_a (hd s)))) s. Proof using. intros. find_apply_lem_hyp MsgLock_in_queue_or_Locked; auto. intuition. - destruct s; simpl in *; eauto using E_next, E0. - break_exists. destruct s; simpl in *. apply E_next. eapply clients_get_lock_messages; eauto using lb_step_execution_invar, weak_fairness_invar. find_apply_lem_hyp step_async_star_lb_step_execution; auto. destruct s. simpl. do 2 (find_apply_lem_hyp always_Cons; intuition). Qed. Lemma MsgLock_eventually_MsgLocked : forall c s, event_step_star step_async step_async_init (hd s) -> lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (MsgLock c)) s -> eventually (now (occurred (MsgLocked c))) s. Proof using. intros c s Hss Hlbs Hfair. match goal with | H : _ (hd s) |- _ => pattern s in H end. match goal with | H1 : ?J1 s, H2 : ?J2 s, H3 : ?J3 s |- _ => assert ((J1 /\_ J2 /\_ J3) s) as Hand by (now unfold and_tl); clear H1; clear H2; clear H3 end; simpl in *. intros. eapply eventually_trans. 4:eapply MsgLock_Locked; eauto; unfold and_tl in *; intuition. 3:apply Hand. all:unfold and_tl in *. all:intuition eauto using lb_step_execution_invar, weak_fairness_invar. - find_apply_lem_hyp step_async_star_lb_step_execution; auto. destruct s0. simpl in *. find_apply_lem_hyp always_Cons. intuition. find_apply_lem_hyp always_Cons. intuition. - eauto using Locked_in_network_eventually_MsgLocked. Qed. Theorem locking_clients_eventually_receive_lock_lb : forall c s, event_step_star step_async step_async_init (hd s) -> lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (InputLock c)) s -> eventually (now (occurred (MsgLocked c))) s. 
: forall b p, (Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba) ===> queue b p. unfold queue; sepLemma. Qed. Theorem llist_empty_fwd : forall b n (fr : W) ba, fr = 0 -> llist b n fr ba ===> [| b %= empty |] * [| n = O |]. destruct n; sepLemma. Qed. Theorem llist_empty_bwd : forall b n (fr : W) ba, fr = 0 -> [| b %= empty |] * [| n = O |] ===> llist b n fr ba. destruct n; sepLemma. Qed. Theorem llist_nonempty_fwd : forall ba n (fr : W) b, fr <> 0 -> focusOnFront -> llist b n fr ba ===> Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * [| freeable fr 3 |] * (fr ==*> v1, v2, p) * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba. destruct n; sepLemma. Qed. Theorem llist_end_fwd : forall ba n (fr : W) b, fr <> 0 -> focusOnBack -> llist b n fr ba ===> Ex n', Ex v1, Ex v2, [| n = S n' |] * [| (v1, v2) %in b |] * lseg (b %- (v1, v2)) n' fr ba * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1, v2, $0). induction n. sepLemma. sepLemmaLhsOnly. destruct n. specialize (H4 (refl_equal _)); subst. sepLemma. sepLemma. clear H4. transitivity ([| x <> 0 |] * llist (b %- (x1, x0)) (S n) x ba * SEP.ST.star (fr =*> x1) (SEP.ST.star ((fr ^+ $4) =*> x0) ((fr ^+ $8) =*> x))). sepLemma. remember (S n). sepLemmaLhsOnly. etransitivity. eapply himp_star_frame; [ auto | reflexivity ]. sepLemma. sepLemma. injection H4; clear H4; intros; subst. apply lseg_extensional'; bags. Qed. Theorem llist_nonempty_fwd_b : forall b n (fr : W) ba, ~(b %= empty) -> focusOnFront -> llist b n fr ba ===> [| fr <> 0 |] * Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba. destruct n; sepLemma. Qed. Theorem llist_nonempty_bwd : forall b n (fr ba : W), fr <> 0 -> focusOnFront -> (Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba) ===> llist b n fr ba. 
H); congruence. Qed. Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive) {struct m} : t B := match m with | Leaf => Leaf | Node l o r => Node (xmap f l (xO i)) (match o with None => None | Some x => Some (f (prev i) x) end) (xmap f r (xI i)) end. Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH. Lemma xgmap: forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A), get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Theorem gmap: forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A), get i (map f m) = option_map (f i) (get i m). Proof. intros A B f i m. unfold map. rewrite xgmap. repeat f_equal. exact (prev_involutive i). Qed. Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B := match m with | Leaf => Leaf | Node l o r => Node (map1 f l) (option_map f o) (map1 f r) end. Theorem gmap1: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map1 f m) = option_map f (get i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A := match l, x, r with | Leaf, None, Leaf => Leaf | _, _, _ => Node l x r end. Lemma gnode': forall (A: Type) (l r: t A) (x: option A) (i: positive), get i (Node' l x r) = get i (Node l x r). Proof. intros. unfold Node'. destruct l; destruct x; destruct r; auto. destruct i; simpl; auto; rewrite gleaf; auto. Qed. Fixpoint filter1 (A: Type) (pred: A -> bool) (m: t A) {struct m} : t A := match m with | Leaf => Leaf | Node l o r => let o' := match o with None => None | Some x => if pred x then o else None end in Node' (filter1 pred l) o' (filter1 pred r) end. Theorem gfilter1: forall (A: Type) (pred: A -> bool) (i: elt) (m: t A), get i (filter1 pred m) = match get i m with None => None | Some x => if pred x then Some x else None end. 
all: eassumption. - repeat rewrite !forallb_map. epose proof (declared_constructor_closed_indices decli). eapply forallb_impl ; tea. intros. rewrite (wf_branch_length wfb). apply on_free_vars_subst. 1: by rewrite forallb_rev. rewrite List.rev_length /expand_lets_k -shiftnP_add. assert (#|pparams p| = (context_assumptions (subst_instance (puinst p) (ind_params mdecl)))) as ->. { erewrite context_assumptions_subst_instance, onNpars, wf_predicate_length_pars ; eauto. eapply PCUICInductives.oi ; eauto. } apply on_free_vars_subst. + eapply foron_free_vars_extended_subst. rewrite on_free_vars_ctx_subst_instance. eapply closed_ctx_on_free_vars, declared_inductive_closed_params. by eapply decli. + rewrite extended_subst_length subst_instance_length context_assumptions_subst_instance. rewrite shiftnP_add Nat.add_comm. apply on_free_vars_lift_impl. rewrite Nat.add_comm. apply on_free_vars_subst. 1:{ eapply forallb_impl ; [|eapply closed_inds]. intros ; by apply closed_on_free_vars. } len. rewrite on_free_vars_subst_instance. apply closedn_on_free_vars. by rewrite Nat.add_comm Nat.add_assoc. - rewrite /= andb_true_r on_free_vars_mkApps. apply /andP ; split => //. rewrite forallb_app. apply /andP ; split. + rewrite forallb_map. eapply forallb_impl ; tea. intros. by rewrite on_free_vars_lift0 // (wf_branch_length wfb) addnP_shiftnP. + rewrite (wf_branch_length wfb). by apply on_free_vars_to_extended_list.Qed.Definition unlift_renaming n k i := if i <? k then i else i - n. Definition unlift n k := rename (unlift_renaming n k).Lemma lift_unlift n k : (unlift_renaming n k) ∘ (lift_renaming n k) =1 ren_id. Proof. intros i. rewrite /unlift_renaming /lift_renaming /ren_id. repeat case_inequalities. all: lia. Qed.Corollary lift_unlift_term {n k} t : unlift n k (lift n k t) = t. Proof. by rewrite lift_rename /unlift (rename_compose _ _ _) lift_unlift rename_ren_id. Qed.Corollary lift_unlift_context {n k} Γ : rename_context (unlift_renaming n k) (rename_context (lift_renaming n k) Γ) = Γ. Proof. etransitivity. 2: by apply fold_context_k_id. rewrite /rename_context fold_context_k_compose. apply fold_context_k_proper => //. intros ? ?. etransitivity. 2: by apply rename_ren_id. rewrite rename_compose. apply rename_proper => //. intros ?. rewrite shiftn_lift_renaming. rewrite /shiftn /unlift_renaming /lift_renaming /ren_id. repeat case_inequalities => //. all: lia. Qed.Section OnFreeVars. Context `{cf : checker_flags} (Σ : global_env_ext) (wfΣ : wf Σ). Let Pinfer Γ t T := forall P, on_ctx_free_vars P Γ -> on_free_vars P t -> on_free_vars P T. Let Psort (Γ : context) (t : term) (u : Universe.t) := True. Let Pprod Γ t (na : aname) A B := forall P, on_ctx_free_vars P Γ -> on_free_vars P t -> on_free_vars P A × on_free_vars (shiftnP 1 P) B. Let Pind Γ (ind : inductive) t (u : Instance.t) args := forall P, on_ctx_free_vars P Γ -> on_free_vars P t -> All (on_free_vars P) args. Let Pcheck (Γ : context) (t : term) (T : term) := True. Let PΓ (Γ : context) := True. Let PΓ_rel (Γ Γ' : context) := True. Theorem bidirectional_on_free_vars : env_prop_bd Σ Pcheck Pinfer Psort Pprod Pind PΓ PΓ_rel. 
y : float, Flt_bool x y = true -> Flt x y. intros x y H'; red in |- *. apply Rplus_lt_reg_r with (r := (- y)%R). repeat rewrite (Rplus_comm (- y)). rewrite Rplus_opp_r. change (x - y < 0)%R in |- *. rewrite <- Fdiff_correct. replace 0%R with (powerRZ radix (Zmin (Fexp x) (Fexp y)) * 0)%R; auto with real arith. rewrite (Rmult_comm (Fdiff x y)). apply Rmult_lt_compat_l; auto with real zarith. replace 0%R with (IZR 0); auto with real arith. apply Rlt_IZR; red in |- *. generalize H'; unfold Flt_bool, Fcompare in |- *. case (Fdiff x y ?= 0)%Z; auto; intros; try discriminate. Qed. Theorem Flt_bool_correct_r : forall x y : float, Flt x y -> Flt_bool x y = true. intros x y H'. cut (0 < y - x)%R; auto with arith. 2: apply Rplus_lt_reg_l with (r := FtoRradix x); rewrite Rplus_0_r; rewrite Rplus_minus; auto with real. intros H'0. cut (Fdiff x y < 0)%R; auto with arith. intros H'1. cut (Fdiff x y < 0)%Z; auto with zarith. intros H'2; generalize (Zlt_compare _ _ H'2); unfold Flt_bool, Fcompare, Zcompare in |- *; case (Fdiff x y); auto with arith; intros; contradiction. apply lt_IZR; auto with arith. apply (Rlt_monotony_contra_exp radix) with (z := Zmin (Fexp x) (Fexp y)); auto with arith real; rewrite Rmult_0_l. rewrite Fdiff_correct; auto with real. Qed. Theorem Flt_bool_correct_f : forall x y : float, Flt_bool x y = false -> Fle y x. intros x y H'. case (Rtotal_order (FtoRradix y) (FtoRradix x)); auto with real. intros H'0; red in |- *; apply Rlt_le; auto with real. intros H'0; elim H'0; clear H'0; intros H'1. red in |- *; rewrite H'1; auto with real. Contradict H'; rewrite Flt_bool_correct_r; auto with real. red in |- *; intros H'; discriminate. Qed. Definition Fle_bool (x y : float) := match Fcompare x y with | Lt => true | Eq => true | _ => false end. Theorem Fle_bool_correct_t : forall x y : float, Fle_bool x y = true -> Fle x y. intros x y H'. cut (Feq x y \/ Flt x y). intros H; case H; intros H1; auto with real. red in |- *; apply Req_le; auto with real. red in |- *; apply Rlt_le; auto with real. generalize H' (Feq_bool_correct_t x y) (Flt_bool_correct_t x y). unfold Fle_bool, Feq_bool, Flt_bool in |- *; case (Fcompare x y); auto. Qed. Theorem Fle_bool_correct_r : forall x y : float, Fle x y -> Fle_bool x y = true. 
: Type}, A -> m A) (bind : forall {A B : Type}, m A -> (A -> m B) -> m B) : Prop := { left_id : forall (A B : Type) (x : A) (f : A -> m B), mequiv (bind (ret x) f) (f x); right_id : forall (A : Type) (x : m A), mequiv (bind x ret) x; bind_assoc : forall (A B C : Type) (n : m A) (f : A -> m B) (g : B -> m C), mequiv (bind (bind n f) g) (bind n (fun x => bind (f x) g)); equivalence : forall T, Equivalence (@mequiv T); congruence : forall {A B : Type} n (f g : A -> m B), (forall x, mequiv (f x) (g x)) -> mequiv (bind n f) (bind n g); }.Section MonadProperties. Generalizable All Variables. Context `{Monad m mequiv ret bind}. Infix "=~" := mequiv (at level 60, no associativity). Infix ">>=" := bind (at level 50, left associativity). Instance mequivEquivlence : forall T, Equivalence (@mequiv T). Proof. apply equivalence. Qed. Definition fmap {A B : Type} (f : A -> B) (n : m A) : m B := n >>= (@ret B) ∘ f. Definition join {A : Type} (n : m (m A)) : m A := n >>= id. Ltac revealer := unfold join, fmap, compose, id; intros. Ltac f_equal := apply congruence; intros. Theorem fmap_compose_join_eq_bind : forall (A B : Type) (n : m A) (f : A -> m B), n >>= f =~ join (fmap f n). Proof. revealer. rewrite bind_assoc. f_equal. rewrite left_id. reflexivity. Qed. Theorem fmap_id : forall (A : Type) (n : m A), fmap id n =~ n. Proof. revealer. rewrite right_id. reflexivity. Qed. Theorem fmap_associativity : forall (A B C : Type) (f : A -> B) (g : B -> C) (n : m A), fmap (g ∘ f) n =~ fmap g (fmap f n). Proof. revealer. rewrite bind_assoc. f_equal. rewrite left_id. reflexivity. Qed. Theorem return_property : forall (A B : Type) (f : A -> B) (x : A), ret (f x) =~ fmap f (ret x). Proof. revealer. rewrite left_id. reflexivity. Qed. Theorem join_property1 : forall (A : Type) (x : m (m (m A))), join (fmap join x) =~ join (join x). Proof. intros. rewrite <- fmap_compose_join_eq_bind. revealer. rewrite bind_assoc. reflexivity. Qed. Theorem join_property2 : forall (A : Type) (x : m A), join (fmap (@ret A) x) =~ x. 
let (a1, b1) := v in (a1, b :: b1)) l) = map (fst (B:=_)) l); [ intros HH | idtac ]. intros t; elim t; simpl in |- *; auto. intros p H; rewrite HH; auto. intros p H; rewrite HH; auto. intros p H p0 H0; rewrite map_app; apply permutation_app_comp; auto. repeat rewrite HH; auto. repeat rewrite HH; auto. intros b l; elim l; simpl in |- *; auto. intros a l0 H1; apply f_equal2 with (f := cons (A:=A)); auto. case a; simpl in |- *; auto. Qed. Theorem pbbuild_compute_perm : forall c, c <> nil -> unique_prefix c -> permutation (compute_pbcode (pbbuild c)) c. Proof using. intros c; elim c; simpl in |- *; auto. intros H; case H; auto. intros (a1, l1) l. case l. unfold pbbuild in |- *; simpl in |- *; auto. intros H H0 H1; rewrite pbadd_prop1; auto. intros (a2, l2) l3; simpl in |- *. intros H H0 H1; apply permutation_trans with ((a1, l1) :: compute_pbcode (pbadd a2 (pbbuild l3) l2)). unfold pbbuild in |- *; simpl in |- *; apply pbadd_prop2. cut (~ is_prefix l1 l2); [ intros Ip1 | idtac ]. cut (~ is_prefix l2 l1); [ intros Ip2 | idtac ]. generalize H1; case l3; auto. intros H2; apply pbfree_pbadd_prop1; auto. intros p l0 H2. apply pbfree_pbadd_prop2; auto. change (pbfree l1 (pbbuild (p :: l0))) in |- *. apply pbfree_pbbuild_prop1 with (a := a1); auto. red in |- *; intros; discriminate. apply unique_prefix_inv with (a := a2) (l := l2). apply unique_prefix_permutation with (2 := H2); auto. red in |- *; intros HH2; absurd (a1 = a2). red in |- *; intros H3; case unique_key_in with (a := a1) (b1 := l1) (b2 := l2) (1 := unique_prefix2 _ _ H1); simpl in |- *; auto. rewrite H3; auto. apply sym_equal; apply unique_prefix1 with (1 := H1) (lb1 := l2) (lb2 := l1); simpl in |- *; auto. red in |- *; intros HH2; absurd (a1 = a2). red in |- *; intros H3; case unique_key_in with (a := a1) (b1 := l1) (b2 := l2) (1 := unique_prefix2 _ _ H1); simpl in |- *; auto. rewrite H3; auto. apply unique_prefix1 with (1 := H1) (lb1 := l1) (lb2 := l2); simpl in |- *; auto. apply permutation_skip. apply H; auto. red in |- *; intros Hj; discriminate. apply unique_prefix_inv with (1 := H1); auto. Qed. Theorem all_pbleaves_pbbuild : forall c, c <> nil -> unique_prefix c -> permutation (map (fst (B:=_)) c) (all_pbleaves (pbbuild c)). 
ZleLe; auto. idtac; rewrite H'; auto with zarith. apply ZleLe; auto. idtac; rewrite H'; auto with zarith. Qed. Theorem Zcompare_EGAL : forall p q : Z, (p ?= q)%Z = Datatypes.Eq -> p = q. intros p q; case p; case q; simpl in |- *; auto with arith; try (intros; discriminate); intros q1 p1. intros H1; rewrite (Pcompare_Eq_eq p1 q1); auto. unfold Pos.compare. generalize (Pcompare_Eq_eq p1 q1); case (Pcompare p1 q1 Datatypes.Eq); simpl in |- *; intros H H1; try discriminate; rewrite H; auto. Qed. Theorem Zlt_Zopp : forall x y : Z, (x < y)%Z -> (- y < - x)%Z. intros x y; case x; case y; simpl in |- *; auto with zarith; intros p p0; unfold Zlt in |- *; simpl in |- *; unfold Pos.compare; rewrite <- ZC4; auto. Qed. Hint Resolve Zlt_Zopp: zarith. Theorem Zle_Zopp : forall x y : Z, (x <= y)%Z -> (- y <= - x)%Z. intros x y H'; case (Zle_lt_or_eq _ _ H'); auto with zarith. Qed. Hint Resolve Zle_Zopp: zarith. Theorem absolu_INR : forall n : nat, Zabs_nat (Z_of_nat n) = n. intros n; case n; simpl in |- *; auto with arith. intros n0; rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith. Qed. Theorem absolu_Zopp : forall p : Z, Zabs_nat (- p) = Zabs_nat p. intros p; case p; simpl in |- *; auto. Qed. Theorem Zabs_absolu : forall z : Z, Zabs z = Z_of_nat (Zabs_nat z). intros z; case z; simpl in |- *; auto; intros p; apply sym_equal; apply inject_nat_convert; auto. Qed. Theorem absolu_comp_mult : forall p q : Z, Zabs_nat (p * q) = Zabs_nat p * Zabs_nat q. intros p q; case p; case q; simpl in |- *; auto; intros p0 p1; apply ((fun (x y : positive) (_ : positive -> positive) => nat_of_P_mult_morphism x y) p1 p0 (fun x => x)). Qed. Theorem Zmin_sym : forall m n : Z, Zmin n m = Zmin m n. intros m n; unfold Zmin in |- *. case n; case m; simpl in |- *; auto; unfold Pos.compare. intros p p0; rewrite (ZC4 p p0). generalize (Pcompare_Eq_eq p0 p). case (Pcompare p0 p Datatypes.Eq); simpl in |- *; auto. intros H'; rewrite H'; auto. intros p p0; rewrite (ZC4 p p0). generalize (Pcompare_Eq_eq p0 p). case (Pcompare p0 p Datatypes.Eq); simpl in |- *; auto. intros H'; rewrite H'; auto. Qed. Theorem Zpower_nat_O : forall z : Z, Zpower_nat z 0 = Z_of_nat 1. 
Hl0 end) (fun size0 IHs x (input0_ : A) hin => match hin with | or_introl Hr1 => _ | or_intror Hl1 => False_ind _ Hl1 end) s x input0_ Hin end end) _). - inversion Hr0; auto. - inversion Hr1; auto. - intros H; symmetry in H; move: H. apply eq_ind. eapply (ex_intro input0_). Defined. Defined. admit. Admitted. refine ((fun x' => ex_intro _ _) _). refine (ex_intro _). refine (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) _ x input0_). (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_). Definition s A (input0_ : A) := (fun x => conj (fun Hin => match Hin with | ex_intro s Hc => match Hc with | conj Hl Hin => nat_ind (fun n => forall x (input0_ : A), Basics.impl ((let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) x) ((@eq A) x input0_)) (fun x (input0_ : A) hin => match hin with | or_introl Hr0 => eq_ind _ _ (eq_refl _) _ Hr0 | or_intror Hl0 => False_ind _ Hl0 end) (fun size0 IHs x (input0_ : A) hin => match hin with | or_introl Hr1 => eq_ind _ _ (eq_refl _) _ Hr1 | or_intror Hl1 => False_ind _ Hl1 end) s x input0_ Hin end end) (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_)). *) Theorem plus_id_exercise : forall n m o : nat, n = m -> m = o -> n + m = m + o. Admitted. QuickChick plus_id_exercise.Theorem mult_0_plus : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem mult_S_1 : forall n m : nat, m = S n -> m * (1 + n) = m * m. Admitted. Theorem plus_1_neq_0_firsttry : forall n : nat, beq_nat (n + 1) 0 = false. 
= 0%R). 2: rewrite Hx, Rabs_R0; easy. apply Rgt_not_eq. apply Rlt_le_trans with (bpow (mag beta x - 1)). apply bpow_gt_0. apply abs_round_ge_generic; try assumption. apply generic_format_bpow. case negligible_exp_spec'; [intros (K1,K2)|idtac]. ring_simplify (mag beta x-1+1)%Z. specialize (K2 (mag beta x)); now auto with zarith. intros (n,(Hn1,Hn2)). rewrite Hn1 in H; discriminate. now apply bpow_mag_le. Qed.Definition pred_pos x := if Req_bool x (bpow (mag beta x - 1)) then (x - bpow (fexp (mag beta x - 1)))%R else (x - ulp x)%R.Definition succ x := if (Rle_bool 0 x) then (x+ulp x)%R else (- pred_pos (-x))%R.Definition pred x := (- succ (-x))%R.Theorem pred_eq_pos : forall x, (0 <= x)%R -> pred x = pred_pos x. Proof. intros x Hx; unfold pred, succ. case Rle_bool_spec; intros Hx'. assert (K:(x = 0)%R). apply Rle_antisym; try assumption. apply Ropp_le_cancel. now rewrite Ropp_0. rewrite K; unfold pred_pos. rewrite Req_bool_false. 2: apply Rlt_not_eq, bpow_gt_0. rewrite Ropp_0; ring. now rewrite 2!Ropp_involutive. Qed.Theorem succ_eq_pos : forall x, (0 <= x)%R -> succ x = (x + ulp x)%R. Proof. intros x Hx; unfold succ. now rewrite Rle_bool_true. Qed.Theorem succ_opp : forall x, succ (-x) = (- pred x)%R. Proof. intros x. now apply sym_eq, Ropp_involutive. Qed.Theorem pred_opp : forall x, pred (-x) = (- succ x)%R. Proof. intros x. unfold pred. now rewrite Ropp_involutive. Qed.Theorem pred_bpow : forall e, pred (bpow e) = (bpow e - bpow (fexp e))%R. Proof. intros e. rewrite pred_eq_pos by apply bpow_ge_0. unfold pred_pos. rewrite mag_bpow. replace (e + 1 - 1)%Z with e by ring. now rewrite Req_bool_true. Qed.Theorem id_m_ulp_ge_bpow : forall x e, F x -> x <> ulp x -> (bpow e < x)%R -> (bpow e <= x - ulp x)%R. Proof. intros x e Fx Hx' Hx.assert (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z. assert (0 < Ztrunc (scaled_mantissa beta fexp x))%Z. apply gt_0_F2R with beta (cexp beta fexp x). rewrite <- Fx. apply Rle_lt_trans with (2:=Hx). apply bpow_ge_0. lia. case (Zle_lt_or_eq _ _ H); intros Hm.pattern x at 1 ; rewrite Fx. rewrite ulp_neq_0. unfold F2R. simpl. pattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l. rewrite <- Rmult_minus_distr_r. rewrite <- minus_IZR. apply bpow_le_F2R_m1. easy. now rewrite <- Fx. apply Rgt_not_eq, Rlt_gt. apply Rlt_trans with (2:=Hx), bpow_gt_0.contradict Hx'. pattern x at 1; rewrite Fx. rewrite <- Hm. rewrite ulp_neq_0. unfold F2R; simpl. now rewrite Rmult_1_l. apply Rgt_not_eq, Rlt_gt. apply Rlt_trans with (2:=Hx), bpow_gt_0. Qed. Theorem id_p_ulp_le_bpow : forall x e, (0 < x)%R -> F x -> (x < bpow e)%R -> (x + ulp x <= bpow e)%R. 
+ rewrite vec_map_list_zero; simpl; tauto. + rewrite vec_map_list_one; simpl. exists (vec_one p), vec_zero; rew vec; repeat split; auto. + apply ill_tps_perm with (1 := Permutation_sym (vec_map_list_plus _ _ _)). apply ill_tps_app. exists v, w; repeat split; auto. Qed. Fact ill_tps_vec_map_list : (forall (p : pos n) (v : vec nat n), s (rx p) v <-> v = vec_one p) -> forall v w, ill_tps_list s (map £ (vec_map_list v rx)) w <-> v = w. Proof. intros H v; rewrite map_vec_map_list. induction v as [ | p | v w Hv Hw ] using (@vec_nat_induction n); intros z. + rewrite vec_map_list_zero; simpl; tauto. + rewrite vec_map_list_one; simpl. split. * intros (a & b & H1 & H2 & H3). apply H in H2; subst; rew vec. * intros []. exists (vec_one p), vec_zero; rew vec; repeat split; auto. apply H; auto. + split. * intros Hz. apply ill_tps_perm with (1 := vec_map_list_plus _ _ _) in Hz. apply ill_tps_app in Hz. destruct Hz as (a & b & H1 & H2 & H3). apply Hv in H2. apply Hw in H3. subst; auto. * intros []. apply ill_tps_perm with (1 := Permutation_sym (vec_map_list_plus _ _ _)). apply ill_tps_app. exists v, w; repeat split; auto. - apply Hv; auto. - apply Hw; auto. Qed.End TPS.Section g_eill_complete_bound. Variable (Σ : list eill_cmd) (Γ : list eill_vars) (n : nat). Notation vars := (flat_map eill_cmd_vars Σ ++ Γ). Hypothesis (w : vec eill_vars n) (w_surj : forall u, In u vars -> exists p, u = vec_pos w p). Let rx p := vec_pos w p. Let Hrx l : incl l (flat_map eill_cmd_vars Σ ++ Γ) -> exists v, l ~p vec_map_list v rx. Proof. induction l as [ | x l IHl ]; intros H. + exists vec_zero; rewrite vec_map_list_zero; auto. + destruct IHl as (v & Hv). { intros ? ?; apply H; right; auto. } assert (In x vars) as Hx. { apply H; left; auto. } destruct w_surj with (u := x) as (p & ?); subst; auto. exists (vec_plus (vec_one p) v). apply Permutation_sym. apply Permutation_trans with (1 := vec_map_list_plus _ _ _). rewrite vec_map_list_one. apply perm_skip, Permutation_sym; auto. Qed. Let s x v := Σ; vec_map_list v rx ⊦ x. Notation "⟦ A ⟧" := (ill_tps s A) (at level 65). Notation "'[<' Γ '|-' A '>]'" := (ill_sequent_tps s Γ A) (at level 65). Theorem G_eill_complete_bound x : [< map (fun c => !⦑c⦒) Σ ++ map £ Γ |- £ x >] vec_zero -> Σ; Γ ⊦ x. 
Type := | pair : X -> Y -> prod X Y.Arguments pair {X} {Y} _ _.Notation "( x , y )" := (pair x y).Notation "X * Y" := (prod X Y) : type_scope.Instance dec_prod' {A} {B} (p q : prod A B) (DA : forall (x y : A), Dec (x = y)) (DB : forall (x y : B), Dec (x = y)) : Dec (p = q). Proof. constructor; unfold decidable. decide equality; try solve [apply DA]; try solve [apply DB]. Defined.Derive Arbitrary for prod. Derive Show for prod. Derive Sized for prod. Derive CanonicalSized for prod. Derive SizeMonotonic for prod using genSprod. Derive SizedMonotonic for prod.Definition fst {X Y : Type} (p : X * Y) : X := match p with | (x, y) => x end.Definition snd {X Y : Type} (p : X * Y) : Y := match p with | (x, y) => y end.Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y) : list (X*Y) := match lx, ly with | [], _ => [] | _, [] => [] | x :: tx, y :: ty => (x, y) :: (combine tx ty) end.. Admitted. *)Inductive option (X:Type) : Type := | Some : X -> option X | None : option X.Arguments Some {X} _. Arguments None {X}.Instance dec_option' {A} (p q : option A) (D : forall (x y : A), Dec (x = y)) : Dec (p = q). Proof. constructor; unfold decidable. decide equality. apply D. Defined.Derive Arbitrary for option. Derive Show for option. Derive Sized for option. Derive CanonicalSized for option. Derive SizeMonotonic for option using genSoption. Derive SizedMonotonic for option. Derive SizedCorrect for option using genSoption and SizeMonotonicoption.Fixpoint nth_error {X : Type} (l : list X) (n : nat) : option X := match l with | [] => None | a :: l' => if beq_nat n O then Some a else nth_error l' (pred n) end.Fixpoint filter {X:Type} (test: X->bool) (l:list X) : (list X) := match l with | [] => [] | h :: t => if test h then h :: (filter test t) else filter test t end.Fixpoint map {X Y:Type} (f:X->Y) (l:list X) : (list Y) := match l with | [] => [] | h :: t => (f h) :: (map f t) end.From QuickChick Require Import CoArbitrary. Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X), map f (rev l) = rev (map f l). 
From iris.proofmode Require Import tactics. From iris Require Import base_logic.lib.invariants. Theorem inv_dup_acc {Σ} `{!invGS Σ} (Q: iProp Σ) N E (P: iProp Σ) : ↑N ⊆ E → inv N P -∗ (P -∗ P ∗ Q) -∗ |={E}=> ▷ Q. 
inv H. specialize (IHSearchTree'1 _ H5). clear H5. specialize (IHSearchTree'2 _ H6). clear H6. unfold slow_elements; fold slow_elements. subst. extensionality i. destruct (In_decidable (slow_elements l) i) as [[w H] | Hleft]. rewrite list2map_app_left with (v:=w); auto. pose proof (slow_elements_range _ _ _ _ _ H0_ H). unfold combine, t_update. bdestruct (k=?i); [ omega | ]. bdestruct (i<?k); [ | omega]. auto. Admitted. Theorem empty_tree_SearchTree: SearchTree empty_tree. Proof. clear default. Admitted. Remark omega_on_keys: forall i j : key, ~ (i > j) -> ~ (i < j) -> i=j. Proof. intros. try omega. Qed. Theorem insert_SearchTree: forall k v t, SearchTree t -> SearchTree (insert k v t). Proof. clear default. Admitted.Check lookup_relate. Check elements_relate. Lemma lookup_relate': forall (k : key) (t : tree) (cts : total_map V), SearchTree t -> Abs t cts -> lookup k t = cts k.Proof. intros. apply lookup_relate. apply H0. Qed.Theorem insert_relate': forall k v t cts, SearchTree t -> Abs t cts -> Abs (insert k v t) (t_update cts k v). Proof. intros. apply insert_relate; auto. Qed.Print Abs.Remark abstraction_of_bogus_tree: forall v2 v3, Abs (T (T E 3 v3 E) 2 v2 E) (t_update (t_empty default) 2 v2). Proof. intros. evar (m: total_map V). replace (t_update (t_empty default) 2 v2) with m; subst m. repeat constructor. extensionality x. unfold t_update, combine, t_empty. bdestruct (2 =? x). auto. bdestruct (x <? 2). bdestruct (3 =? x).omega. bdestruct (x <? 3). auto. auto. auto. Qed.Lemma can_relate: forall t, SearchTree t -> exists cts, Abs t cts. Proof. Admitted.Lemma unrealistically_strong_can_relate: forall t, exists cts, Abs t cts. Proof. Admitted.Definition AbsX (t: tree) (m: total_map V) : Prop := list2map (elements t) = m.Theorem elements_relateX: forall t cts, SearchTree t -> AbsX t cts -> list2map (elements t) = cts. Proof. intros. apply H0. Qed.Theorem naive_lookup_relateX: forall k t cts , AbsX t cts -> lookup k t = cts k. Abort. Theorem not_naive_lookup_relateX: forall v, default <> v -> ~ (forall k t cts , AbsX t cts -> lookup k t = cts k). Proof. unfold AbsX. intros v H. intros H0. pose (bogus := T (T E 3 v E) 2 v E). pose (m := t_update (t_update (t_empty default) 2 v) 3 v). assert (list2map (elements bogus) = m). reflexivity. assert (~ lookup 3 bogus = m 3). { unfold bogus, m, t_update, t_empty. simpl. apply H. }apply H2. apply H0. apply H1. Qed. Theorem lookup_relateX: forall k t cts , SearchTree t -> AbsX t cts -> lookup k t = cts k. 
-> 0 < p -> (exists q:nat, m = q*p) ->(Z_of_nat m mod Z_of_nat p = 0)%Z )%nat.Axiom Z_to_nat_and_back : forall x:Z, (0 <= x)%Z -> (Z_of_nat (Z.abs_nat x))=x.Theorem test_odds_correct2 : forall n x:nat, (1 < x)%nat -> forall p:Z, test_odds n p (Z_of_nat x) = true -> ~(exists y:nat, x = y*2)%nat. Proof. intros n; elim n. - unfold test_odds, divides_bool; intros x H1ltx _ Heq Hex. assert (Heq' : Z_of_nat x mod Z_of_nat 2 = 0). + apply verif_divide; auto with zarith. + simpl (Z_of_nat 2) in Heq'; rewrite Heq' in Heq; simpl in Heq; discriminate. - clear n; intros n IHn x H1ltx p; simpl. case_eq (test_odds n (p - 2) (Z_of_nat x)). + intros Htest' _ ; apply (IHn x H1ltx (p -2)); auto. + intros; discriminate. Qed.Theorem Z_of_nat_le : forall x y, Z_of_nat x <= Z_of_nat y -> (x <= y)%nat. Proof. intros; lia. Qed. Theorem test_odds_correct : forall (n x:nat)(p:Z), p = 2*(Z_of_nat n)+1 -> (1 < x)%nat -> test_odds n p (Z_of_nat x) = true -> forall q:nat, (1 < q <= 2*n+1)%nat -> ~(exists y:nat, x = q*y)%nat. Proof. induction n. - intros x p Hp1 H1ltx Hn q Hint. elimtype False; lia. - intros x p Hp H1ltx; simpl (test_odds (S n) p (Z_of_nat x)); intros Htest q (H1ltq, Hqle). case_eq (test_odds n (p -2) (Z_of_nat x)). + intros Htest'true. rewrite Htest'true in Htest. unfold divides_bool in Htest. elim (le_lt_or_eq q (2*S n + 1)%nat Hqle). * intros Hqlt. assert (Hqle': (q <= (2* S n))%nat) by lia. elim (le_lt_or_eq q (2 * S n)%nat Hqle'). replace (2*S n)%nat with (2*n +2)%nat. intros Hqlt'. assert (Hqle'' : (q <= 2*n +1)%nat) by lia. apply (IHn x (p - 2)); auto with zarith arith; try (rewrite Hp; rewrite inj_S; unfold Z.succ); ring. ring. intros Hq (y, Hdiv); elim (test_odds_correct2 n x H1ltx (p - 2)); auto. exists (S n * y)%nat; rewrite Hdiv; rewrite Hq; ring. * intros Hq Hex; assert (Hp' : p = Z_of_nat q). rewrite Hp; rewrite Hq; rewrite inj_plus; rewrite inj_mult; auto. rewrite Hp' in Htest; rewrite (verif_divide x q) in Htest. simpl in Htest; discriminate. lia. lia. elim Hex; intros y Hdiv; exists y; rewrite Hdiv; ring. + intros Htest'; rewrite Htest' in Htest; simpl in Htest; discriminate. Qed.Axiom divisor_smaller : (forall m p:nat, 0 < m -> forall q:nat, m = q*p -> q <= m)%nat. Theorem lt_Zpos : forall p:positive, 0 < Zpos p. 
zeroP b -> eqTerm a (plusTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1 H2; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1 H2; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. Qed. Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. Qed. Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x). intros a b; case a; case b; simpl in |- *; auto. Qed. Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1. intros a b; case a; case b; simpl in |- *; auto. Qed. Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2. intros a b; case a; case b; simpl in |- *; auto. Qed. Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs). apply plusA_assoc with (1 := cs). Qed. Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d). 
t -> build l1 t. Theorem build_cover : forall l t, build l t -> cover l t. Proof using. intros l t H; elim H; clear H l t; auto. intros t l1 l2 (l3, (t1, (t2, (HH, (HH1, HH2))))) H0 H1; try assumption. apply cover_node with (1 := HH1); auto. apply cover_permutation with (2 := HH2); auto. Qed. Theorem build_comp : forall (l1 l2 : list (btree A)) (t1 t2 : btree A), build l1 t1 -> build l2 t2 -> weight_tree_list f l1 = weight_tree_list f l2 -> same_sum_leaves f l1 l2 -> weight_tree f t1 = weight_tree f t2. Proof using. intros l1 l2 t1 t2 H; generalize l2 t2; elim H; clear H l1 t1 l2 t2. intros t l2 t2 H H0 (l3, (l4, (H1, (H2, H3)))). generalize H0; inversion H; clear H0. simpl in |- *; repeat rewrite <- plus_n_O; auto. case H4. intros l5 (t3, (t4, (H8, (H9, H10)))). absurd (length l2 = length (t3 :: t4 :: l5)). rewrite permutation_length with (1 := H2). rewrite <- length_map with (f := sum_leaves f) (l := l4). rewrite <- H3. rewrite length_map with (f := sum_leaves f). rewrite permutation_length with (1 := permutation_sym _ _ _ H1). simpl in |- *; red in |- *; intros; discriminate. apply permutation_length with (1 := H9). intros t l1 l2 H H0 H1 l0 t2 H2 H3 H4. inversion H2. case H. intros l5 (t3, (t4, (H8, (H9, H10)))). case H4. intros l6 (l7, (H11, (H12, H13))). absurd (length l1 = length (t3 :: t4 :: l5)). rewrite permutation_length with (1 := H11). rewrite <- length_map with (f := sum_leaves f) (l := l6). rewrite H13. rewrite length_map with (f := sum_leaves f). rewrite permutation_length with (1 := permutation_sym _ _ _ H12). rewrite <- H5; simpl in |- *; red in |- *; intros; discriminate. apply permutation_length with (1 := H9). apply H1 with (1 := H6). case one_step_comp with (3 := H) (4 := H5); auto. case one_step_comp with (3 := H) (4 := H5); auto. Qed. Theorem build_same_weight_tree : forall (l : list (btree A)) (t1 t2 : btree A), build l t1 -> build l t2 -> weight_tree f t1 = weight_tree f t2. Proof using. intros l t1 t2 H H0; apply build_comp with (l1 := l) (l2 := l); auto. exists l; exists l; simpl in |- *; auto. Qed. Theorem build_permutation : forall (l1 l2 : list (btree A)) (t : btree A), build l1 t -> permutation l1 l2 -> build l2 t. 
( is : iscontr Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqfromcontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqtoprop ( X Y : UU ) ( is : isaprop Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ is ) . Defined . Theorem isapropweqfromprop ( X Y : UU )( is : isaprop Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ is ) . Defined . Theorem isasetweqtoset ( X Y : UU ) ( is : isaset Y ) : isaset ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 1 _ _ is ) . Defined . Theorem isasetweqfromset ( X Y : UU )( is : isaset Y ) : isaset ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 1 X _ is ) . Defined . Theorem isapropweqtoempty ( X : UU ) : isaprop ( weq X empty ) . Proof . intro . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropempty ) ) . Defined . Theorem isapropweqtoempty2 ( X : UU ) { Y : UU } ( is : neg Y ) : isaprop ( weq X Y ) . Proof. intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropifnegtrue is ) ) . Defined . Theorem isapropweqfromempty ( X : UU ) : isaprop ( weq empty X ) . Proof . intro . apply ( isofhlevelsnweqfromhlevelsn 0 X _ ( isapropempty ) ) . Defined . Theorem isapropweqfromempty2 ( X : UU ) { Y : UU } ( is : neg Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ ( isapropifnegtrue is ) ) . Defined .Theorem isapropweqtounit ( X : UU ) : isaprop ( weq X unit ) . Proof . intro . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropunit ) ) . Defined . Theorem isapropweqfromunit ( X : UU ) : isaprop ( weq unit X ) . 
using. intros. find_apply_lem_hyp handleClientRequest_type. intuition. Qed. Lemma handleTimeout_type : forall h st out st' l, handleTimeout h st = (out, st', l) -> (type st' = type st /\ currentTerm st' = currentTerm st) \/ type st' = Candidate. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; find_inversion; auto. Qed. Lemma handleTimeout_type_strong : forall h st out st' l, handleTimeout h st = (out, st', l) -> (type st' = type st /\ currentTerm st' = currentTerm st) \/ (type st' = Candidate /\ currentTerm st' = S (currentTerm st)). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; find_inversion; simpl; intuition. Qed. Lemma doGenericServer_type : forall h st os st' ms, doGenericServer h st = (os, st', ms) -> type st' = type st /\ currentTerm st' = currentTerm st. Proof using. unfold doGenericServer. intros. repeat break_match; repeat find_inversion; use_applyEntries_spec; subst; simpl in *; auto. Qed. Lemma doLeader_type : forall st h os st' ms, doLeader st h = (os, st', ms) -> type st' = type st /\ currentTerm st' = currentTerm st. Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; auto. Qed. Lemma doLeader_log : forall st h os st' ms, doLeader st h = (os, st', ms) -> log st' = log st. Proof using. unfold doLeader. intros. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleAppendEntriesReply_log : forall h st h' t es r st' ms, handleAppendEntriesReply h st h' t es r = (st', ms) -> log st' = log st. Proof using. unfold handleAppendEntriesReply, advanceCurrentTerm. intros. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleRequestVoteReply_log : forall h st h' t r st', handleRequestVoteReply h st h' t r = st' -> log st' = log st. Proof using. intros. eapply handleRequestVoteReply_spec; eauto. Qed. Lemma handleRequestVoteReply_log_rewrite : forall h st h' t r, log (handleRequestVoteReply h st h' t r) = log st. Proof using. intros. erewrite handleRequestVoteReply_log; eauto. Qed. Lemma handleAppendEntriesReply_packets : forall h st from t es s st' ps, handleAppendEntriesReply h st from t es s = (st', ps) -> ps = []. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; subst; auto. Qed. Lemma doGenericServer_packets : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> ps = []. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; simpl in *; subst; auto. Qed. Theorem handleAppendEntries_not_append_entries : forall h st t n pli plt es ci st' m, handleAppendEntries h st t n pli plt es ci = (st', m) -> ~ is_append_entries m. 
h k_Out (F k_In m). Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Hypothesis A_wf : well_formed_oc A. Definition G0 := k_in <-$ {0, 1}^k; k_out <-$ {0, 1}^c; [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Definition G1 := k_in <-$ {0, 1}^k; [b, _] <-$2 A _ _ (fun (s : list (Bvector b * Bvector c)) m => randomFunc ({0, 1}^c) _ s (F k_in m)) nil; ret b. Definition G2 := [b, _] <-$2 A _ _ (fun (s : list (list (Bvector b) * Bvector c)) m => randomFunc ({0, 1}^c) _ s m) nil; ret b. Definition G0_1 := [k_out, k_in] <-$2 ( key <-$ {0, 1}^(c + k); ret splitVector c k key); [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Theorem G0_1_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1]. unfold PRF_G_A, G0_1. inline_first. comp_skip. unfold f_oracle, hF. remember (splitVector c k x) as z. comp_simp. reflexivity. Qed. Require Import FCF.DetSem FCF.SemEquiv. Theorem G0_1_G0_equiv : Pr[G0_1] == Pr[G0]. unfold G0_1, G0. eapply eqRat_trans. eapply evalDist_seq_eq. eapply Rnd_split_equiv. intros. eapply eqRat_refl. inline_first. comp_swap_r. comp_skip. inline_first. comp_skip. Qed. Theorem G0_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0]. rewrite G0_1_equiv. apply G0_1_G0_equiv. Qed. Definition hF_oracle k_in (s : unit) m : OracleComp (Bvector b) (Bvector c) (Bvector c * unit) := r <--$ OC_Query _ (F k_in m); $ ret (r, tt). Definition PRF_h_A : OracleComp (Bvector b) (Bvector c) bool := k_in <--$$ {0, 1}^k; [r, _] <--$2 OC_Run _ _ _ A (hF_oracle k_in) tt; $ ret r. Definition G1_1 := k_out <-$ { 0 , 1 }^c; [b, _] <-$2 PRF_h_A _ _ (f_oracle h _ k_out) tt; ret b. Definition G1_2 := [b, _] <-$2 PRF_h_A _ _ (randomFunc ({0, 1}^c) _) nil; ret b. Local Opaque evalDist. Theorem G0_G1_1_equiv : Pr[G0] == Pr[G1_1]. unfold G0, G1_1. comp_swap_l. comp_skip. unfold PRF_h_A. simpl. inline_first. comp_skip. comp_simp. inline_first. unfold f_oracle. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => True)). trivial. intuition. inline_first. comp_simp. inline_first. comp_simp. simpl. eapply comp_spec_ret; intuition. simpl in *. intuition; subst. comp_simp. simpl. inline_first. comp_simp. eapply comp_spec_eq_refl. Qed. Theorem G1_1_2_close : | Pr[G1_1] - Pr[G1_2] | <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A. 
Require Import Setoid.Section Group. Variable G : Set. Variable f : G -> G -> G. Infix "*" := f (at level 40, left associativity). Variable e : G. Variable i : G -> G. Variable assoc : forall (a b c : G), (a * b) * c = a * (b * c). Variable id_l : forall (a : G), e * a = a. Variable inv_l : forall (a : G), i a * a = e. Theorem e_unique : forall (a : G), a * a = a -> a = e. Proof. intros. rewrite <- (id_l a) at 1. rewrite <- (inv_l a). rewrite assoc. rewrite H. auto. Qed. Theorem inv_r : forall (a : G), a * i a = e. Proof. intros. apply e_unique. rewrite assoc. rewrite <- (assoc (i a) a (i a)). rewrite inv_l. rewrite id_l. auto. Qed. Theorem id_r : forall (a : G), a * e = a. Proof. intros. rewrite <- (inv_l a). rewrite <- assoc. rewrite inv_r, id_l. auto. Qed. Theorem cancel_l : forall (a b x : G), x * a = x * b -> a = b. Proof. intros. rewrite <- (id_l a), <- (id_l b). rewrite <- (inv_l x). rewrite assoc, assoc. rewrite H. auto. Qed. Theorem cancel_r : forall (a b x : G), a * x = b * x -> a = b. Proof. intros. rewrite <- (id_r a), <- (id_r b). rewrite <- (inv_r x). rewrite <- assoc, <- assoc. rewrite H. auto. Qed. Theorem e_uniq_l : forall (a x : G), x * a = a -> x = e. 
Qed.Lemma sizeof_struct_stable: forall m pos, complete_members env m = true -> sizeof_struct env' pos m = sizeof_struct env pos m. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. rewrite alignof_stable by auto. rewrite sizeof_stable by auto. rewrite IHm by auto. auto. Qed.Lemma sizeof_union_stable: forall m, complete_members env m = true -> sizeof_union env' m = sizeof_union env m. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. rewrite sizeof_stable by auto. rewrite IHm by auto. auto. Qed.Lemma sizeof_composite_stable: forall su m, complete_members env m = true -> sizeof_composite env' su m = sizeof_composite env su m. Proof. intros. destruct su; simpl. apply sizeof_struct_stable; auto. apply sizeof_union_stable; auto. Qed.Lemma complete_members_stable: forall m, complete_members env m = true -> complete_members env' m = true. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. rewrite complete_type_stable by auto. rewrite IHm by auto. auto. Qed.Lemma rank_members_stable: forall m, complete_members env m = true -> rank_members env' m = rank_members env m. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. f_equal; auto. apply rank_type_stable; auto. Qed.End STABILITY.Lemma add_composite_definitions_incr: forall id co defs env1 env2, add_composite_definitions env1 defs = OK env2 -> env1!id = Some co -> env2!id = Some co. Proof. induction defs; simpl; intros. - inv H; auto. - destruct a; monadInv H. eapply IHdefs; eauto. rewrite PTree.gso; auto. red; intros; subst id0. unfold composite_of_def in EQ. rewrite H0 in EQ; discriminate. Qed.Record composite_consistent (env: composite_env) (co: composite) : Prop := { co_consistent_complete: complete_members env (co_members co) = true; co_consistent_alignof: co_alignof co = align_attr (co_attr co) (alignof_composite env (co_members co)); co_consistent_sizeof: co_sizeof co = align (sizeof_composite env (co_su co) (co_members co)) (co_alignof co); co_consistent_rank: co_rank co = rank_members env (co_members co) }.Definition composite_env_consistent (env: composite_env) : Prop := forall id co, env!id = Some co -> composite_consistent env co.Lemma composite_consistent_stable: forall (env env': composite_env) (EXTENDS: forall id co, env!id = Some co -> env'!id = Some co) co, composite_consistent env co -> composite_consistent env' co. Proof. intros. destruct H as [A B C D]. constructor. eapply complete_members_stable; eauto. symmetry; rewrite B. f_equal. apply alignof_composite_stable; auto. symmetry; rewrite C. f_equal. apply sizeof_composite_stable; auto. symmetry; rewrite D. apply rank_members_stable; auto. Qed.Lemma composite_of_def_consistent: forall env id su m a co, composite_of_def env id su m a = OK co -> composite_consistent env co. Proof. unfold composite_of_def; intros. destruct (env!id); try discriminate. destruct (complete_members env m) eqn:C; inv H. constructor; auto. Qed. Theorem build_composite_env_consistent: forall defs env, build_composite_env defs = OK env -> composite_env_consistent env. 
_, _, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). rewrite decide_False //. repeat (monad_simpl; cbn). } iNext; iIntros (v2 σ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod "Hclo". iIntros. destruct (decide (all_synced _)) as [Ha|Hna]. - monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iAssert (⌜ (∀ k bs, m !! k = Some bs → fst bs = snd bs) ⌝)%I with "[-]" as "%Hsynced". { iIntros (k bs Hin). iDestruct (big_sepM_lookup_acc with "[$]") as "(Hk&_)"; eauto. iDestruct (gen_heap_valid with "[$] [$]") as %Hlook. iPureIntro. eapply Ha in Hlook. eauto. } iFrame. rewrite big_sepL_nil right_id. iApply wp_value. iFrame. iApply ("Hϕ" with "[-]"). simpl. iFrame. eauto. - monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iFrame. rewrite big_sepL_nil right_id. iApply ("IH" with "[$] [$]"). Qed. Lemma wp_WriteOp s E (a: u64) bc b0 b q l : {{{ ▷ (int.Z a d↦{#1}[bc] b0 ∗ mapsto_block l q b) }}} ExternalOp WriteOp (Val $ PairV (LitV $ LitInt a) (LitV $ LitLoc l)) @ s; E {{{ RET LitV LitUnit; ∃ b', ⌜ b' = bc ∨ b' = b ⌝ ∗ int.Z a d↦{#1}[b'] b ∗ mapsto_block l q b}}}. Proof. iIntros (Φ) ">H Hϕ". iDestruct "H" as "(Ha&Hl)". iApply wp_lift_atomic_head_step_no_fork; first by auto. iIntros (σ1 g1 ns mj D κ κs nt) "(Hσ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iDestruct (@gen_heap_valid with "Hd Ha") as %?. iDestruct (heap_valid_block with "Hσ Hl") as %?. iSplit. { iPureIntro. eexists _, _, _, _, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). unshelve (econstructor; eauto; [ econstructor; eauto| monad_simpl ]; econstructor; econstructor; eauto; econstructor; econstructor; eauto). exact true. } iNext; iIntros (v2 σ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (@gen_heap_update with "Hd Ha") as "[$ Ha]". assert (b = b1); [ | subst b1 ]. { apply Block_to_vals_ext_eq; intros. specialize (H0 i); specialize (H2 i); intuition. simpl in H4. destruct_with_eqn (σ1.(heap) !! (l +ₗ i)); try contradiction. destruct p as (n0&?); destruct n0; try contradiction. congruence. } iModIntro; iSplit; first done. iFrame. iApply ("Hϕ" with "[-]"). iExists _. iFrame. destruct x0; eauto. Qed. Definition disk_array (l: Z) (q: dfrac) (vs: list Block): iProp Σ := ([∗ list] i ↦ b ∈ vs, (l + i) d↦{q}[b] b)%I. Theorem disk_array_cons l q b vs : disk_array l q (b::vs) ⊣⊢ l d↦{q}[b] b ∗ disk_array (l + 1) q vs. 
- ex)) ex) as (mxy, Hxy'). rewrite Hxy'. assert (H: (F2R (Float beta mxy ex) - F2R (Float beta (mx + my * beta ^ (ey - ex)) ex))%R = F2R (Float beta (mxy - (mx + my * beta ^ (ey - ex))) ex)). now rewrite <- F2R_minus, Fminus_same_exp. rewrite H. apply generic_format_F2R. intros _. apply monotone_exp. rewrite <- H, <- Hxy', <- Hxy. apply mag_le_abs. exact H0. pattern x at 3 ; replace x with (-(y - (x + y)))%R by ring. rewrite Rabs_Ropp. now apply (round_N_pt beta _ choice (x + y)). Qed. Theorem plus_error : forall x y, format x -> format y -> format (round beta fexp (Znearest choice) (x + y) - (x + y))%R. Proof. intros x y Hx Hy. destruct (Zle_or_lt (cexp beta fexp x) (cexp beta fexp y)). now apply plus_error_aux. rewrite Rplus_comm. apply plus_error_aux ; try easy. now apply Zlt_le_weak. Qed.End Fprop_plus_error.Section Fprop_plus_zero.Variable beta : radix. Notation bpow e := (bpow beta e).Variable fexp : Z -> Z. Context { valid_exp : Valid_exp fexp }. Context { exp_not_FTZ : Exp_not_FTZ fexp }. Notation format := (generic_format beta fexp).Section round_plus_eq_zero_aux.Variable rnd : R -> Z. Context { valid_rnd : Valid_rnd rnd }.Lemma round_plus_neq_0_aux : forall x y, (cexp beta fexp x <= cexp beta fexp y)%Z -> format x -> format y -> (0 < x + y)%R -> round beta fexp rnd (x + y) <> 0%R. Proof with auto with typeclass_instances. intros x y He Hx Hy Hxy. destruct (mag beta (x + y)) as (exy, Hexy). simpl. specialize (Hexy (Rgt_not_eq _ _ Hxy)). destruct (Zle_or_lt exy (fexp exy)) as [He'|He'].assert (H: (x + y)%R = F2R (Float beta (Ztrunc (x * bpow (- fexp exy)) + Ztrunc (y * bpow (- fexp exy))) (fexp exy))). rewrite (subnormal_exponent beta fexp exy x He' Hx) at 1. rewrite (subnormal_exponent beta fexp exy y He' Hy) at 1. now rewrite <- F2R_plus, Fplus_same_exp. rewrite H. rewrite round_generic... rewrite <- H. now apply Rgt_not_eq. apply generic_format_F2R. intros _. rewrite <- H. unfold cexp. rewrite mag_unique with (1 := Hexy). apply Z.le_refl.intros H. elim Rle_not_lt with (1 := round_le beta _ rnd _ _ (proj1 Hexy)). rewrite (Rabs_pos_eq _ (Rlt_le _ _ Hxy)). rewrite H. rewrite round_generic... apply bpow_gt_0. apply generic_format_bpow. apply Zlt_succ_le. now rewrite (Zsucc_pred exy) in He'. Qed.End round_plus_eq_zero_aux.Variable rnd : R -> Z. Context { valid_rnd : Valid_rnd rnd }. Theorem round_plus_neq_0 : forall x y, format x -> format y -> (x + y <> 0)%R -> round beta fexp rnd (x + y) <> 0%R. 
From Coq Require Import Arith.Arith PArith.BinPos micromega.Lia Program.Program micromega.Lia Sets.Ensembles Sorting.Permutation Relations.Relations Setoids.Setoid Classes.Morphisms funind.Recdef.Import RelationClasses.Require compcert.lib.Maps.Require Import ExtLib.Data.Bool.Import Nnat. Require Import ExtLib.Data.String ExtLib.Data.List. Require Import Libraries.maps_util. Require Import L6.cps. Require Import L6.ctx L6.rename L6.state. Require Import L6.cps_util L6.List_util L6.identifiers L6.inline_letapp. Require Import Common.exceptionMonad. Inductive svalue : Type := | SVconstr: ctor_tag -> list var -> svalue | SVfun : fun_tag -> list var -> exp -> svalue. Definition ctx_map := M.t svalue. Definition r_map := M.t var.Definition c_map := M.t nat.Definition b_map := M.t bool. Definition getd {A:Type} (d:A) := fun v sub => match M.get v sub with | None => d | Some e => e end.Definition seto {A:Type} (x:var)(oa:option A) (map:M.t A):= match oa with | Some a => M.set x a map | None => map end.Notation get_c := (getd 0%nat). Notation get_b := (getd false). Section MEASURECONTRACT. Create HintDb mtss. Fixpoint term_size (e: exp) : nat := match e with | Econstr _ _ _ e => 1 + term_size e | Ecase _ cl => 1 + (List.fold_right (fun (p:(ctor_tag * exp)) => fun (n:nat) => let (k, e) := p in (n + (term_size e))%nat) 0%nat cl) | Eproj _ _ _ _ e => 1 + term_size e | Eletapp _ _ _ _ e => 1 + term_size e | Eapp _ _ _ => 1 | Eprim _ _ _ e => 1 + term_size e | Efun fds e => 1 + funs_size fds + term_size e | Ehalt _ => 1 end with funs_size fds : nat := match fds with | Fcons _ _ _ e fds' => 1 + funs_size fds' + term_size e | Fnil => 1 end. Definition svalue_size (v: svalue) : nat := match v with | SVconstr t lv => 0 | SVfun t lv e => term_size e end. Definition svalue_inl_size (f:(positive*svalue)) (inl:b_map): nat := (if (get_b (fst f) inl) then 0 else svalue_size (snd f)). Theorem svalue_inl_le: forall i v im, svalue_inl_size (i,v) im <= svalue_size v. 
apply chasles. Geometry. assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q). rewrite <- H11. ring. rewrite H12 in H10. clear H12. NormalizeRing H10.assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P). assert (A ** Q + Q ** P = A ** P). apply chasles. Geometry.rewrite <- H12. assert (P ** Q = - Q ** P); Geometry. rewrite H13. assert (Q ** R = - R ** Q); Geometry. rewrite H14. ring.assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P). replace (P ** Q * A ** R) with (A ** R * P ** Q) by ring. rewrite H10. rewrite <- H12. ring.clear H9 H10 H11 H12. IsoleVar (A ** R) H13. rewrite H13. field; Geometry. Geometry.rewrite H9. ring. Qed.Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B. Proof. intros. cases_col Q A P. cases_col Q P B. assert (Col Q P A); Geometry. clear H1. assert (Col Q A B). eauto with Geom. assert (Col P A B). eauto with Geom. rewrite H1. rewrite H4. ring_simplify. change (Col R A B) in |- *. assert (Col Q R B). eauto with Geom. assert (Col Q R A). eauto with Geom. assert (Col R Q B); Geometry. assert (Col R Q A); Geometry. cases_equality R Q. rewrite H9; trivial. eauto with Geom.apply l2_9aux; auto. cases_col Q P B. assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A). apply l2_9aux; Geometry.assert (S R A B = - S R B A); Geometry. assert (S Q A B = - S Q B A); Geometry. assert (S P A B = - S P B A); Geometry. rewrite H4. rewrite H5. rewrite H6. rewrite H3. ring.apply l2_9_weak; auto. Qed. Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'. 
Require Import List Arith Lia Permutation Extraction.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat gcd prime binomial.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.Set Implicit Arguments.Section Informative_Chinese_Remainder_theorems. Hint Resolve divides_refl divides_mult divides_mult_r : core. Section Binary. Variable (u v a b : nat) (Hu : u <> 0) (Hv : v <> 0) (Huv : is_gcd u v 1). Theorem CRT_bin_informative : { w | rem w u = rem a u /\ rem w v = rem b v /\ 2 < w }. 
with (p := q). apply div_rem_spec1. } destruct H6 as (z & H6); exists z; split. + apply IHn. exists q, c; msplit 2; auto. intros i Hi; apply H2; omega. + destruct (H2 n) as (u & v & G1 & G2 & G3); auto. rewrite is_digit_fun with (1 := H4) (2 := G2), is_digit_fun with (1 := H6) (2 := G1); auto. Qed. Notation power := (mscal mult 1). Notation "∑" := (msum plus 0). Lemma rel_iter_iter_seq n x y : rel_iter R n x y -> rel_iter_seq n x y. Proof. intros H. apply rel_iter_sequence in H. destruct H as (f & H1 & H2 & H3). assert (exists q, forall i, i <= n -> f i < q) as Hq. { clear H1 H2 H3. revert f; induction n as [ | n IHn ]; intros f. + exists (S (f 0)); intros [ | ] ?; omega. + destruct IHn with (f := fun i => (f (S i))) as (q & Hq). exists (1+f 0+q); intros [ | i ] Hi; try omega. generalize (Hq i); intros; omega. } destruct Hq as (q & Hfq). assert (q <> 0) as Hq. { generalize (Hfq 0); intros; omega. } set (c := ∑ (S n) (fun i => f i * power i q)). assert (forall i, i <= n -> is_digit c q i (f i)) as Hc. { intros i Hi; split; auto. + exists (∑ (n-i) (fun j => f (1+i+j) * power j q)), (∑ i (fun i => f i * power i q)); split. 2: apply sum_power_lt; auto; intros; apply Hfq; omega. unfold c; replace (S n) with (i+S (n - i)) by omega. rewrite msum_plus, plus_comm; f_equal; auto. rewrite msum_ext with (g := fun k => power i q*(f (i+k)*power k q)). * rewrite sum_0n_scal_l, mult_comm; f_equal. rewrite msum_S, plus_comm; f_equal. 2: simpl; rewrite Nat.mul_1_r; f_equal; omega. rewrite (mult_comm _ q), <- sum_0n_scal_l. apply msum_ext. intros j _. replace (i+S j) with (1+i+j) by omega. rewrite power_S; ring. * intros j _; rewrite power_plus; ring. } exists q, c; msplit 2. + intros i Hi; exists (f i), (f (S i)). split; [ | split ]. * apply Hc; omega. * apply Hc; omega. * apply H3; auto. + rewrite <- H1; apply Hc; omega. + rewrite <- H2; apply Hc; omega. Qed. Hint Resolve rel_iter_seq_iter rel_iter_iter_seq. Theorem rel_iter_seq_equiv n x y : rel_iter R n x y <-> rel_iter_seq n x y. 
H; left; auto with float. apply FnormalFabs; auto. intros H; right; auto with float. apply FsubnormFabs; auto. Qed. Theorem NormalNotSubNormal : forall p : float, ~ (Fnormal p /\ Fsubnormal p). intros p; red in |- *; intros H; elim H; intros H0 H1; clear H. absurd (Zabs (radix * Fnum p) < Zpos (vNum b))%Z; auto with float zarith. Qed. Theorem MaxFloat : forall x : float, Fbounded b x -> (Rabs x < Float (Zpos (vNum b)) (Fexp x))%R. intros. replace (Rabs x) with (FtoR radix (Fabs x)). unfold FtoRradix in |- *. apply maxMax with (b := b); auto with *. unfold FtoRradix in |- *. apply Fabs_correct; auto with *. Qed.Variable precision : nat. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Theorem FboundNext : forall p : float, Fbounded b p -> exists q : float, Fbounded b q /\ q = Float (Zsucc (Fnum p)) (Fexp p) :>R. intros p H'. case (Zle_lt_or_eq (Zsucc (Fnum p)) (Zpos (vNum b))); auto with float. case (Zle_or_lt 0 (Fnum p)); intros H1. rewrite <- (Zabs_eq (Fnum p)); auto with float zarith. apply Zle_trans with 0%Z; auto with zarith. intros H'0; exists (Float (Zsucc (Fnum p)) (Fexp p)); split; auto with float. repeat split; simpl in |- *; auto with float. case (Zle_or_lt 0 (Fnum p)); intros H1; auto with zarith. rewrite Zabs_eq; auto with zarith. apply Zlt_trans with (Zabs (Fnum p)); auto with float zarith. repeat rewrite Zabs_eq_opp; auto with zarith. intros H'0; exists (Float (Zpower_nat radix (pred precision)) (Zsucc (Fexp p))); split; auto. repeat split; simpl in |- *; auto with zarith arith float. rewrite pGivesBound. rewrite Zabs_eq; auto with zarith. rewrite H'0; rewrite pGivesBound. pattern precision at 2 in |- *; replace precision with (1 + pred precision). rewrite Zpower_nat_is_exp. rewrite Zpower_nat_1. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite powerRZ_Zs; auto with real zarith. rewrite Rmult_IZR; ring. generalize precisionNotZero; case precision; simpl in |- *; auto with arith. intros H'1; case H'1; auto. Qed. Theorem digitPredVNumiSPrecision : digit radix (Zpred (Zpos (vNum b))) = precision. apply digitInv; auto. rewrite pGivesBound. rewrite Zabs_eq; auto with zarith. rewrite Zabs_eq; auto with zarith. Qed. Theorem digitVNumiSPrecision : digit radix (Zpos (vNum b)) = S precision. apply digitInv; auto. rewrite pGivesBound. rewrite Zabs_eq; auto with zarith. rewrite Zabs_eq; auto with zarith. rewrite pGivesBound; auto with zarith. Qed. Theorem vNumPrecision : forall n : Z, digit radix n <= precision -> (Zabs n < Zpos (vNum b))%Z. 
: assertion := fun h => exists h1 h2, hdsj h1 h2 /\ hspt h h1 h2 /\ p h1 /\ q h2.Definition hand (p q : assertion) : assertion := fun h => p h /\ q h. Definition himp (p q : assertion) : Prop := forall h, p h -> q h. Definition heq (p q : assertion) : Prop := forall h, p h <-> q h. Definition hlift (p : Prop) : assertion := fun h => p.Infix "|->" := hpto (at level 30) : sep_scope. Infix "/~\" := hand (at level 40) : sep_scope. Infix "**" := hstar (at level 40) : sep_scope. Delimit Scope sep_scope with sep. Notation "p ==> q" := (himp p%sep q%sep) (no associativity, at level 70). Notation "p <==> q" := (heq p%sep q%sep) (no associativity, at level 70).Open Scope sep_scope.Ltac hsimpl := unfold hemp, empty_heap, hpto, hstar, hdsj, hspt, huni, hand, himp, heq, hlift, add, lookup in *. Ltac hsolver := match goal with | [ |- context[ if ?c then _ else _ ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ if ?c then _ else _ ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ |- context[ match ?c with Some _ => _ | None => _ end ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ match ?c with Some _ => _ | None => _ end ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ H : (?x <? ?y) = true |- _ ] => rewrite Nat.ltb_lt in H | [ H : (?x <? ?y) = false |- _ ] => rewrite Nat.ltb_nlt in H end; subst; auto.Lemma heap_extensionality : forall (h1 h2 : heap), h1 = h2 -> forall (x : nat), h1 x = h2 x. Proof. crush. Qed.Module SeparationProperty. Theorem pt2same_sep : forall (p x y : nat), p |-> x ** p |-> y ==> hlift False. Proof. hsimpl; intros; firstorder; subst. specialize (H p). hsolver; crush. Qed. Theorem pt2same_sep' : forall (p q x y : nat), p |-> x ** q |-> y ==> hlift (p <> q). Proof. hsimpl; intros; firstorder; subst. intros contra; subst. specialize (H q); repeat hsolver; crush. Qed. Theorem pt2same_and : forall (p x y : nat), p |-> x /~\ p |-> y ==> hlift (x = y). 
==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. End QUEUE.Module Queue : QUEUE. Open Scope Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). destruct n; reflexivity. Qed. Theorem queue_extensional : forall b p, HProp_extensional (queue b p). reflexivity. Qed. Theorem lseg_extensional' : forall ba n b b' fr, b %= b' -> lseg b n fr ba ===> lseg b' n fr ba. induction n; sepLemma. Qed. Theorem llist_extensional' : forall ba n b b' fr, b %= b' -> llist b n fr ba ===> llist b' n fr ba. induction n; sepLemma. Qed. Theorem queue_fwd : forall b p, queue b p ===> Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. unfold queue; sepLemma. Qed. Theorem queue_bwd : forall b p, (Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba) ===> queue b p. unfold queue; sepLemma. Qed. Theorem llist_empty_fwd : forall b n (fr : W) ba, fr = 0 -> llist b n fr ba ===> [| b %= empty |] * [| n = O |]. 
H3. eapply tree_rep_find_subtree_root with (Ftree := Ftree); eauto. pred_apply; cancel. unfold tree_with_dst in *. destruct H3. eapply tree_rep_find_subtree_root with (Ftree := Ftree); eauto. pred_apply; cancel. Qed. Lemma treeseq_in_ds_crash_single: forall Fm Ftop fsxp d x t sm ms, BFILE.MSinitial ms -> (crash_xform Fm ✶ rep fsxp Ftop x (TSilist t) (TSfree t) (BFILE.ms_empty (MSLL ms)) sm)%pred (list2nmem d) -> treeseq_in_ds (crash_xform Fm) Ftop fsxp sm ms ({| TStree := x; TSilist := TSilist t; TSfree := TSfree t |}, []) (d, []). Proof. intros. unfold treeseq_in_ds. constructor; simpl. split. unfold TREESEQ.tree_rep. intuition; simpl. pred_apply; safecancel. unfold treeseq_one_safe; simpl. eapply dirtree_safe_refl. constructor. unfold tree_rep_latest; simpl. pred_apply; cancel. replace ms with (BFILE.ms_empty (MSLL ms)). cancel. destruct ms. unfold ATOMICCP.MSLL. unfold BFILE.MSinitial in *. intuition. simpl in *. subst. unfold BFILE.ms_empty; simpl. reflexivity. Qed. Lemma treeseq_pred_tree_rep_dir2flatmem2_single : forall t Ftree srcpath tmppath srcinum file tinum dstbase dstname dstfile, tree_rep Ftree srcpath tmppath srcinum file tinum dstbase dstname dstfile t -> ((exists tfile', tree_with_tmp Ftree srcpath tmppath srcinum file tinum tfile' dstbase dstname dstfile) \/ (tree_with_src Ftree srcpath tmppath srcinum file dstbase dstname dstfile) \/ (tree_with_dst Ftree srcpath tmppath srcinum file dstbase dstname))%pred (dir2flatmem2 (TStree t)). Proof. unfold treeseq_pred, tree_rep; intros. intuition. - deex. pred_apply. cancel. - pred_apply; cancel. - pred_apply; cancel. Qed.Lemma add_to_list_not_in: forall d s t, ~In s (map fst d) -> add_to_list s t d = (d ++ [(s,t)])%list. Proof. induction d; intros; simpl; auto. destruct a; simpl in *. destruct (string_dec s0 s). exfalso; auto. rewrite IHd; auto. Qed. Lemma tree_names_distinct_add_to_dir: forall ents tfn a df inum, ~In tfn (map fst ents) -> tree_names_distinct (TreeDir inum ents) -> tree_names_distinct (add_to_dir tfn (TreeFile a df) (TreeDir inum ents)). Proof. induction ents; intros; simpl; auto. apply TND_dir. simpl. apply Forall_forall; intros x Hf; destruct Hf; subst. apply TND_file. inversion H1. simpl. econstructor; auto. apply NoDup_nil. destruct a. destruct (string_dec s tfn); simpl in *; auto. exfalso; auto. inversion H0; subst; simpl in *. inversion H3; subst. inversion H4; subst. assert (A: tree_names_distinct (TreeDir inum ents)). apply TND_dir; eauto. assert (A0: ~In tfn (map fst ents)). auto. apply TND_dir; simpl. constructor; auto. specialize (IHents tfn a0 df inum). specialize (IHents A0 A). inversion IHents; subst; auto. specialize (IHents tfn a0 df inum). specialize (IHents A0 A). inversion IHents; subst; auto. constructor; auto. rewrite add_to_list_not_in. rewrite map_app; simpl. unfold not; intros . apply in_app_iff in H1. destruct H1; auto. inversion H1; subst; auto. auto. Qed. Theorem atomic_cp_recover_ok_2 : {< Fm Ftop Ftree fsxp cs mscs ds sm srcpath file srcinum tinum tinum' dfile dstfile (dstbase: list string) (dstname:string) t ts', PRE:hm LOG.after_crash (FSXPLog fsxp) (SB.rep fsxp) ds cs hm * [[ treeseq_in_ds Fm Ftop fsxp sm mscs (pushd t ts') ds ]] * [[ tree_rep Ftree srcpath [temp_fn] srcinum file tinum' dstbase dstname dfile t ]] * [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dstfile) ts' ]] POST:hm' RET:r [[ isError r ]] * any \/ exists d sm' t mscs', [[ r = OK (mscs', fsxp) ]] * LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn (d, nil)) (MSLL mscs') sm' hm' * [[ treeseq_in_ds (crash_xform Fm) (BFileCrash.flist_crash_xform Ftop) fsxp sm' mscs' (t, nil) (d, nil) ]] * ([[ treeseq_pred (tree_rep_recover (flatmem_crash_xform Ftree) srcpath [temp_fn] srcinum file dstbase dstname dstfile) (t, nil) ]] \/ [[ treeseq_pred (tree_rep_recover (flatmem_crash_xform Ftree) srcpath [temp_fn] srcinum file dstbase dstname dfile) (t, nil) ]]) XCRASH:hm' (LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' * [[ treeseq_in_ds Fm Ftop fsxp sm mscs (pushd t ts') ds ]] * [[ tree_rep Ftree srcpath [temp_fn] srcinum file tinum' dstbase dstname dfile t ]] * [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dstfile) ts' ]]) \/ exists ts' ds' sm' mscs' dstfile' tinum', LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds' hm' * [[ treeseq_in_ds (crash_xform Fm) (BFileCrash.flist_crash_xform Ftop) fsxp sm' mscs' ts' ds' ]] * [[ treeseq_pred (tree_rep (flatmem_crash_xform Ftree) srcpath [temp_fn] srcinum file tinum' dstbase dstname dstfile') ts' ]] * ([[ file_crash dstfile dstfile' ]] \/ [[ file_crash dfile dstfile' ]]) >} atomic_cp_recover. 
elt) (m: t A), get i (map f m) = f(get i m). End MAP.Module PTree <: TREE. Definition elt := positive. Definition elt_eq := peq. Inductive tree (A : Type) : Type := | Leaf : tree A | Node : tree A -> option A -> tree A -> tree A. Arguments Leaf [A]. Arguments Node [A]. Scheme tree_ind := Induction for tree Sort Prop. Definition t := tree. Definition empty (A : Type) := (Leaf : t A). Fixpoint get (A : Type) (i : positive) (m : t A) {struct i} : option A := match m with | Leaf => None | Node l o r => match i with | xH => o | xO ii => get ii l | xI ii => get ii r end end. Fixpoint set (A : Type) (i : positive) (v : A) (m : t A) {struct i} : t A := match m with | Leaf => match i with | xH => Node Leaf (Some v) Leaf | xO ii => Node (set ii v Leaf) None Leaf | xI ii => Node Leaf None (set ii v Leaf) end | Node l o r => match i with | xH => Node l (Some v) r | xO ii => Node (set ii v l) o r | xI ii => Node l o (set ii v r) end end. Fixpoint remove (A : Type) (i : positive) (m : t A) {struct i} : t A := match i with | xH => match m with | Leaf => Leaf | Node Leaf o Leaf => Leaf | Node l o r => Node l None r end | xO ii => match m with | Leaf => Leaf | Node l None Leaf => match remove ii l with | Leaf => Leaf | mm => Node mm None Leaf end | Node l o r => Node (remove ii l) o r end | xI ii => match m with | Leaf => Leaf | Node Leaf None r => match remove ii r with | Leaf => Leaf | mm => Node Leaf None mm end | Node l o r => Node l o (remove ii r) end end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. induction i; simpl; auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x. 
Require Setoid. Require Import PeanoNat Le Gt Minus Bool Lt.Set Implicit Arguments. Open Scope list_scope. Module ListNotations. Notation "[ ]" := nil (format "[ ]") : list_scope. Notation "[ x ]" := (cons x nil) : list_scope. Notation "[ x ; y ; .. ; z ]" := (cons x (cons y .. (cons z nil) ..)) : list_scope. End ListNotations.Import ListNotations.Section Lists. Variable A : Type. Definition hd (default:A) (l:list A) := match l with | [] => default | x :: _ => x end. Definition hd_error (l:list A) := match l with | [] => None | x :: _ => Some x end. Definition tl (l:list A) := match l with | [] => nil | a :: m => m end. Fixpoint In (a:A) (l:list A) : Prop := match l with | [] => False | b :: m => b = a \/ In a m end.End Lists.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), [] <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = []}. Proof. induction l as [|a tail]. right; reflexivity. left; exists a, tail; reflexivity. Qed. Lemma hd_error_tl_repr : forall l (a:A) r, hd_error l = Some a /\ tl l = r <-> l = a :: r. Proof. destruct l as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). 
Require Import FunctionalExtensionality.Require Import Verdi.GhostSimulations. Require Import VerdiRaft.Raft.Require Import VerdiRaft.RaftRefinementInterface.Set Bullet Behavior "Strict Subproofs".Section RaftRefinementProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Lemma refined_raft_invariant_handle_message P : forall xs p ys net st' ps' gd d l, refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> handleMessage (pSrc p) (pDst p) (pBody p) (snd (nwState net (pDst p))) = (d, l) -> update_elections_data_net (pDst p) (pSrc p) (pBody p) (nwState net (pDst p)) = gd -> P net -> refined_raft_intermediate_reachable net -> nwPackets net = xs ++ p :: ys -> (forall h, st' h = update name_eq_dec (nwState net) (pDst p) (gd, d) h) -> (forall p', In p' ps' -> In p' (xs ++ ys) \/ In p' (send_packets (pDst p) l)) -> P (mkNetwork ps' st'). Proof using. intros. unfold handleMessage, update_elections_data_net in *. break_match; repeat break_let; repeat find_inversion; [eapply_prop refined_raft_net_invariant_request_vote| eapply_prop refined_raft_net_invariant_request_vote_reply| eapply_prop refined_raft_net_invariant_append_entries| eapply_prop refined_raft_net_invariant_append_entries_reply]; eauto; unfold send_packets in *; simpl in *; intros; subst; auto; find_apply_hyp_hyp; intuition. Qed. Lemma refined_raft_invariant_handle_input P : forall h inp net st' ps' gd out d l, refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_client_request P -> handleInput h inp (snd (nwState net h)) = (out, d, l) -> update_elections_data_input h inp (nwState net h) = gd -> P net -> refined_raft_intermediate_reachable net -> (forall h', st' h' = update name_eq_dec (nwState net) h (gd, d) h') -> (forall p', In p' ps' -> In p' (nwPackets net) \/ In p' (send_packets h l)) -> P (mkNetwork ps' st'). Proof using. intros. unfold handleInput, update_elections_data_input in *. break_match; repeat break_let; repeat find_inversion; [eapply_prop refined_raft_net_invariant_timeout| eapply_prop refined_raft_net_invariant_client_request]; eauto; subst; auto. Qed. Theorem refined_raft_net_invariant : forall P net, refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net. 
x ∹ v ⋲ F -> x ∉ G -> x ∹ v ⋲ (F & G). Proof. intros A x v F G Hbind Hnotin. induction G as [ | G y w IHG ] using env_ind. rewrite concat_empty_r; auto. apply notin_concat_inv in Hnotin. destruct Hnotin as [ HnotinG Hnotin_y ]. apply IHG in HnotinG. apply notin_single_inv in Hnotin_y. unfold binds in *. rewrite concat_assoc. assert (get x (F & G & y ∶ w) = get x (F & G)) as Heq. apply get_concat_l; auto. rewrite Heq; auto. Qed.Theorem binds_concat_inv : forall A x (v : A) (F G : gen_env A), x ∹ v ⋲ (F & G) -> x ∹ v ⋲ G ∨ (x ∉ G ∧ x ∹ v ⋲ F). Proof. induction G as [ | G y w IHG ] using env_ind; intro Hbind. rewrite concat_empty_r in *. right; split; [ apply notin_empty | ]; auto. unfold binds in *. rewrite concat_assoc in *. apply get_concat_inv in Hbind. destruct Hbind as [ [ Heq_xy Heq_wv ] | [ Hneq_xy Hget ] ]. subst. left. apply get_concat_r; auto. apply IHG in Hget. destruct Hget as [ Hget | [ Hnotin Hget ] ]. left. assert (get x (G & y ∶ w) = get x G) as Heq. apply get_concat_l; auto. rewrite Heq; auto. right. split; auto. apply notin_concat; auto. apply notin_single; auto. Qed. Theorem binds_belongs : forall A x (v : A) (F : gen_env A), x ∹ v ⋲ F -> x ∈ F. Proof. induction F using env_ind; intro Hbind. apply binds_empty in Hbind; inversion Hbind. apply binds_concat_inv in Hbind. destruct Hbind as [ Hbind | [ Hnotin Hbind ] ]. apply belongs_concat_r. unfold binds in Hbind. apply get_single_eq_inv in Hbind. destruct Hbind. apply belongs_single; auto. apply IHF in Hbind. apply belongs_concat_l; auto. Qed.Theorem belongs_binds : forall A x (F : gen_env A), x ∈ F -> exists v, x ∹ v ⋲ F. Proof. induction F as [ | F y w IHF ] using env_ind; intro Hbelong. apply belongs_empty in Hbelong. inversion Hbelong. destruct (eq_keys_dec x y) as [ Heq | Hneq ]. subst. exists w. apply binds_concat_r. apply binds_single; auto. apply belongs_concat_inv in Hbelong. destruct Hbelong as [ HinF | Hiny ]. apply IHF in HinF. destruct HinF as [ w' Hbind ]. exists w'. apply binds_concat_l; auto. apply notin_single; auto. apply belongs_single_inv in Hiny. contradiction. Qed. Theorem binds_map : forall A B x (v : A) (E : gen_env A) (f : A -> B), x ∹ v ⋲ E -> x ∹ (f v) ⋲ (map f E). 
in P. exploit prev_append_inj; eauto. intros; congruence. Qed. Definition xkeys (A: Type) (m: t A) (i: positive) := List.map (@fst positive A) (xelements m i nil). Remark xkeys_leaf: forall A i, xkeys (@Leaf A) i = nil. Proof. intros; reflexivity. Qed. Remark xkeys_node: forall A (m1: t A) o (m2: t A) i, xkeys (Node m1 o m2) i = xkeys m1 (xO i) ++ match o with None => nil | Some v => prev i :: nil end ++ xkeys m2 (xI i). Proof. intros. unfold xkeys. rewrite xelements_node. rewrite ! map_app. destruct o; auto. Qed. Lemma in_xkeys: forall (A: Type) (m: t A) (i k: positive), In k (xkeys m i) -> (exists j, k = prev (prev_append j i)). Proof. unfold xkeys; intros. apply (list_in_map_inv) in H. destruct H as ((j, v) & -> & H). exploit in_xelements; eauto. intros (k & P & Q). exists k; auto. Qed. Lemma xelements_keys_norepet: forall (A: Type) (m: t A) (i: positive), list_norepet (xkeys m i). Proof. induction m; intros. - rewrite xkeys_leaf; constructor. - assert (NOTIN1: ~ In (prev i) (xkeys m1 (xO i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (NOTIN2: ~ In (prev i) (xkeys m2 (xI i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (DISJ: forall x, In x (xkeys m1 (xO i)) -> In x (xkeys m2 (xI i)) -> False). { intros. exploit in_xkeys. eexact H. intros (j1 & EQ1). exploit in_xkeys. eexact H0. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H0. destruct H0. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall (A: Type) (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil. Proof. induction m; intros. auto. rewrite xelements_node. rewrite IHm1, IHm2. destruct o; auto. generalize (H xH); simpl; congruence. intros. apply (H (xI i0)). intros. apply (H (xO i0)). Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). 
Permutation.Permutation_app_comm with (l' := B). rewrite app_ass. apply Permutation.Permutation_app_head. etransitivity. 2: eapply IHl. apply Permutation.Permutation_app_tail. etransitivity. 2: apply fold_left_insert_perm. rewrite app_nil_r; auto. Qed. Lemma WellTyped_empty : forall tf tp tU tG, SH.WellTyped_impures tf tp tU tG (MM.empty (exprs types)) = true. Proof. clear. intros. rewrite SH.WellTyped_impures_spec_eq. rewrite MF.PROPS.fold_Empty; auto with typeclass_instances. apply FM.empty_1. Qed. Lemma order_impures_WellTyped : forall tf tp tU tG imp, SH.WellTyped_impures tf tp tU tG imp = true -> allb (fun v : list (expr types) * func => WellTyped_sexpr tf tp tU tG (Func (pcType := pcType) (stateType := stateType) (snd v) (fst v))) (order_impures imp) = true. Proof. clear. intros. unfold order_impures. rewrite SH.WellTyped_impures_spec_eq in H. rewrite FM.fold_1 in *. revert H. unfold exprs in *. generalize true at 2 4. induction (FM.elements (elt:=list (list (expr types))) imp); auto; intros. simpl in *. assert (fold_left (fun (a : bool) (p : FM.key * list (list (expr types))) => (a && match snd p with | nil => true | _ :: _ => match nth_error tp (fst p) with | Some ts => allb (fun args : list (expr types) => all2 (is_well_typed tf tU tG) args ts) (snd p) | None => false end end)%bool) l false = false). { clear. induction l; simpl; auto. } destruct b; simpl in H; try congruence. destruct a. destruct l0; simpl in *. eauto. consider (nth_error tp k); intros; try congruence. consider (all2 (is_well_typed tf tU tG) l0 t); intros; try congruence. consider (allb (fun args : list (expr types) => all2 (is_well_typed tf tU tG) args t) l1); intros; try congruence. rewrite <- IHl by assumption. erewrite allb_permutation. 2: symmetry; apply fold_left_fold_left_insert_perm. rewrite allb_app. erewrite <- allb_permutation. 2: eapply fold_left_insert_perm. rewrite allb_app. rewrite allb_map. simpl. unfold exprs in *. think. simpl. auto. Qed. Lemma map_sort_WellTyped : forall C tf tp tU tG imp, SH.WellTyped_impures tf tp tU tG imp = true -> SH.WellTyped_impures tf tp tU tG (FM.map (fun v : list (exprs types) => Ordering.sort (exprs types) C v) imp) = true. Proof. clear. intros. eapply SH.WellTyped_impures_eq; intros. rewrite MF.FACTS.map_o in H0. consider (FM.find (elt:=list (exprs types)) k imp); simpl in *; try congruence; intros. inversion H1; clear H1; subst. eapply SH.WellTyped_impures_eq in H0. 2: eassumption. destruct l; auto. destruct (nth_error tp k); try contradiction. erewrite allb_permutation in H0. 2: symmetry; eapply Ordering.sort_permutation. rewrite H0. destruct (Ordering.sort (exprs types) C (e :: l)); auto. Qed. Theorem sepCancel_PureFacts : forall tU tG bound summ l r l' r' s s' b, let tf := typeof_funcs funcs in let tp := typeof_preds preds in sepCancel bound summ l r s b = Some (l', r', s') -> U.Subst_WellTyped tf tU tG s -> SH.WellTyped_sheap tf tp tU tG l = true -> SH.WellTyped_sheap tf tp tU tG r = true -> U.Subst_WellTyped tf tU tG s' /\ SH.WellTyped_sheap tf tp tU tG l' = true /\ SH.WellTyped_sheap tf tp tU tG r' = true. 
Require Export UniMath.Foundations.PartB. Require Export UniMath.Foundations.UnivalenceAxiom. Theorem isapropneg (X : UU) : isaprop (neg X). 
intros k Hk. destruct (eq_nat_dec k n); subst. - rewrite (flat_right p), flat_right; omega. - rewrite (flat_left p); try omega. rewrite flat_left, <- H4; try omega. ++ apply H3; omega. ++ destruct H1 as [ G1 G2 G3 G4 G5 ]. destruct (eq_nat_dec k i). { subst; auto. } destruct (eq_nat_dec k j). { subst k; omega. } rewrite G5; omega. Qed. Fact composed_permutation_S n g : g n = n -> composed_permutation n g -> composed_permutation (S n) g. Proof. intro; apply composed_permutation_extends; auto. Qed. Inductive bounded_injective n f : Prop := | in_bounded_inj : (forall i, i < n -> f i < n) -> (forall i j, i < n -> j < n -> f i = f j -> i = j) -> bounded_injective n f. Fact injective_composed_permutation n f : bounded_injective n f -> composed_permutation n f. Proof. intros [ H1 H2 ]. revert f H1 H2; induction n as [ | n IHn ]; intros f H1 H2. + constructor 1; intros; omega. + destruct (find_max_fun n f) as (i & H3 & H4). destruct (le_lt_dec n (f i)) as [ C | C ]. - assert (f i = n) as Hf1. { apply le_antisym; auto; apply le_S_n, H1; omega. } assert (forall j, j <= n -> j <> i -> f j < n) as Hf2. { intros j G1 G2. destruct (eq_nat_dec (f j) n). + contradict G2; apply H2; omega. + specialize (H1 j); omega. } specialize (IHn (fun x => f (swap i n x))). spec in IHn. { intros j Hj. destruct (eq_nat_dec j i). + subst j; rewrite swap_spec_i; apply Hf2; omega. + rewrite swap_spec; try omega; apply Hf2; omega. } spec in IHn. { intros u v G1 G2 G3. apply H2 in G3. + revert G3; apply swap_inj. + destruct (eq_nat_dec u i). - subst; rewrite swap_spec_i; omega. - rewrite swap_spec; omega. + destruct (eq_nat_dec v i). - subst; rewrite swap_spec_i; omega. - rewrite swap_spec; omega. } apply composed_permutation_S in IHn. 2: rewrite swap_spec_j, Hf1; auto. generalize (@swap_bounded_permut (S n) i n); intros G. do 2 (spec in G; try omega). constructor 2 with (1 := G) (2 := IHn). intros; rewrite swap_involutive; auto. - destruct (@php_fun n f) as (u & v & G1 & G2). { intros; apply le_lt_trans with (2 := C); auto. } apply H2 in G2; omega. Qed. Theorem sum_bounded_permutation n i j g f : bounded_permut n i j g -> ∑ n f = ∑ n (fun i => f (g i)). 
using. unfold advanceCurrentTerm. intros. break_if; auto. Qed. Theorem handleTimeout_clientCache : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> clientCache st' = clientCache st. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; auto. Qed. Theorem handleClientRequest_clientCache: forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> clientCache st' = clientCache st. Proof using. intros. unfold handleClientRequest in *. break_match; find_inversion; subst; auto. Qed. Lemma tryToBecomeLeader_clientCache : forall n st out st' ms, tryToBecomeLeader n st = (out, st', ms) -> clientCache st' = clientCache st. Proof using. unfold tryToBecomeLeader. intros. find_inversion. auto. Qed. Lemma handleRequestVote_clientCache : forall n st t c li lt st' ms, handleRequestVote n st t c li lt = (st', ms) -> clientCache st' = clientCache st. Proof using. unfold handleRequestVote. intros. repeat (break_match; try discriminate; repeat (find_inversion; simpl in *)); auto using advanceCurrentTerm_clientCache. Qed. Lemma handleRequestVoteReply_clientCache : forall n st src t v, clientCache (handleRequestVoteReply n st src t v) = clientCache st. Proof using. unfold handleRequestVoteReply. intros. repeat break_match; simpl; auto using advanceCurrentTerm_clientCache. Qed. Lemma doLeader_clientCache : forall st h os st' ms, doLeader st h = (os, st', ms) -> clientCache st' = clientCache st. Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; auto. Qed. Lemma handleAppendEntries_stateMachine: forall h st (d : raft_data) (m : msg) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex), handleAppendEntries h st t n pli plt es ci = (d, m) -> stateMachine d = stateMachine st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleAppendEntriesReply_stateMachine: forall h st (d : raft_data) (m : list (name * msg)) (t : nat) (es : list entry) (res : bool) h', handleAppendEntriesReply h st h' t es res = (d, m) -> stateMachine d = stateMachine st. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat (break_match; try find_inversion; simpl in *; auto). Qed. Lemma advanceCurrentTerm_stateMachine : forall st t, stateMachine (advanceCurrentTerm st t) = stateMachine st. Proof using. unfold advanceCurrentTerm. intros. break_if; auto. Qed. Theorem handleTimeout_stateMachine : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> stateMachine st' = stateMachine st. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; auto. Qed. Theorem handleClientRequest_stateMachine: forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> stateMachine st' = stateMachine st. 
:= ?m |} = _ |- _] => assert (m <> M.empty _) end. { intro Hx. apply M.union_empty in Hx; dest. eapply M.add_empty_neq; eauto. } remember (M.union _ _) as m; clear Heqm. inv H4; auto. Qed. Lemma getExtDefs_nil_step_empty: forall o u a cs, Step m o u {| annot := a; defs := []%fmap; calls := cs |} -> (a = Some None \/ a = None) -> u = M.empty _ /\ cs = M.empty _. Proof. intros. apply step_consistent in H. remember {| annot := a; defs := M.empty _; calls := cs |} as l. inv H. destruct l0 as [a0 ds0 cs0]. unfold hide in H2; simpl in H2; inv H2. pose proof (getExtDefs_nil_substepsInd_cs HSubSteps eq_refl H0); subst. rewrite M.subtractKV_empty_2 in H3; subst. split; auto. eapply substepsInd_update_empty; eauto. Qed. Lemma substepMeths_pull_hd: forall o ms1 ms2 m u, SubstepMeths o (m :: (ms1 ++ ms2)) u -> SubstepMeths o (ms1 ++ m :: ms2) u. Proof. induction ms1; simpl; intros; auto. inv H. inv H3. assert (SubstepMeths o ((mn, mar) :: (ms1 ++ ms2)) (M.union u0 pu0)) by (econstructor; eauto). specialize (IHms1 _ _ _ H). replace (M.union u0 (M.union u pu0)) with (M.union u (M.union u0 pu0)) by meq. econstructor; eauto. Qed. Lemma substepsInd_implies_substepMeths: forall o u l, SubstepsInd m o u l -> forall ds, l = {| annot := None; defs := ds; calls := M.empty _ |} -> SubstepMeths o (M.elements ds) u. Proof. induction 1; simpl; intros; subst; [inv H; constructor|]. destruct l as [pann pds pcs]; simpl in *. destruct pann; [inv H4; destruct sul; discriminate|]. destruct sul as [|om]; [inv H4|]. eapply dmNoCalls_SubstepsInd in H; eauto; subst. specialize (IHSubstepsInd _ eq_refl). destruct om as [[mn mar]|]; [|inv H4; inv H0; mred]. inv H4; mred; subst. replace (M.union (M.add mn mar (M.empty _)) pds) with (M.add mn mar pds) by meq. assert (SubstepMeths o ((mn, mar) :: (M.elements pds)) (M.union su u)). { econstructor; eauto. inv H1; auto. } assert (M.F.P.Add mn mar pds (M.add mn mar pds)) by (unfold M.F.P.Add; auto). apply M.F.elements_Add in H2; [|inv H1; simpl in *; dest; auto]. replace (M.Map.elements (M.add mn mar pds)) with ((M.F.elements_lt (mn, mar) pds) ++ (mn, mar) :: M.F.elements_ge (mn, mar) pds). - apply substepMeths_pull_hd. rewrite <-M.F.elements_split. replace (M.union u su) with (M.union su u) by (inv H1; dest; meq). auto. - apply eq_sym, M.eq_leibniz_list. apply eqlistA_eqke_eq_compat; auto. Qed. Theorem step_implies_stepDet: forall o u l , Step m o u l -> StepDet o u l. 
Require Export Pcomb. Require Export Pcrit. Require Export Fred. Require Import moreCoefStructure. Section BuchAux. Load "hCoefStructure". Load "hOrderStructure". Load "hComb". Definition red (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)) := reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec P (s2p A A0 eqA n ltM a) (pO A n). Definition addEnd : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM). intros a H'0; elim H'0. exact (a :: nil). intros b L1 Rec; exact (b :: Rec). Defined. Theorem addEnd_cons : forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), In a (addEnd b aL) -> a = b \/ In a aL. intros a b aL; elim aL; simpl in |- *; auto. intros H'; case H'; [ intros H'0; rewrite <- H'0 | intros H'0; clear H' ]; auto. intros a0 l H' H'0; case H'0; [ intros H'1; rewrite <- H'1; clear H'0 | intros H'1; clear H'0 ]; auto. case (H' H'1); auto. Qed. Theorem addEnd_id1 : forall (a : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), In a (addEnd a aL). intros a aL; elim aL; simpl in |- *; auto. Qed. Theorem addEnd_id2 : forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), In a aL -> In a (addEnd b aL). intros a b aL; elim aL; simpl in |- *; auto. intros a0 l H' H'0; case H'0; auto. Qed. Lemma addEnd_app : forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), addEnd a P = P ++ a :: nil. intros a P; elim P; simpl in |- *; auto. intros a0 l H'; elim H'; auto. Qed. Definition spolyp : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM. intros p q; case p; case q. intros x Cpx x0 Cpx0; exists (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cpx Cpx0); auto. apply spolyf_canonical with (1 := cs); auto. Defined. Theorem red_com : forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), red (spolyp a b) aL -> red (spolyp b a) aL. 
eapply map_filter_lookup_Some. eauto. } eapply map_filter_lookup_Some in H3. intuition eauto. - edestruct H1. { eexists. eapply map_filter_lookup_Some. eauto. } eapply map_filter_lookup_Some in H3. intuition eauto. Qed. End filter.Lemma filter_same_keys_0 `{Countable K} `(m1 : gmap K A) `(m2 : gmap K B) (P : K -> Prop) `{Hdka : ∀ (ka : K * A), Decision (P ka.1)} `{Hdkb : ∀ (kb : K * B), Decision (P kb.1)} : (∀ k, is_Some (m1 !! k) <-> is_Some (m2 !! k)) -> ∀ k, is_Some (filter (λ x, P x.1) m1 !! k) <-> is_Some (filter (λ x, P x.1) m2 !! k). Proof. split. - apply filter_same_keys_0'. intros. eapply H0. eauto. - apply filter_same_keys_0'. intros. eapply H0. eauto. Qed.Lemma filter_same_keys_1 `{Countable K} `(m1 : gmap K A) `(m2 : gmap K B) (P : K -> Prop) `{Hdk : ∀ k, Decision (P k)} `{Hdka : ∀ (ka : K * A), Decision (P ka.1)} `{Hdkb : ∀ (kb : K * B), Decision (P kb.1)} : (∀ k, is_Some (filter (λ x, P x.1) m1 !! k) <-> is_Some (filter (λ x, P x.1) m2 !! k)) -> (∀ k, is_Some (filter (λ x, ¬ P x.1) m1 !! k) <-> is_Some (filter (λ x, ¬ P x.1) m2 !! k)) -> ∀ k, is_Some (m1 !! k) <-> is_Some (m2 !! k). Proof. split. - eapply filter_same_keys_1'; eauto. + intros; eapply H0; eauto. + intros; eapply H1; eauto. - eapply filter_same_keys_1'; eauto. + intros; eapply H0; eauto. + intros; eapply H1; eauto. Qed.Lemma dom_filter_eq `{Countable K} `(m1 : gmap K A) `(m2 : gmap K B) (P : K -> Prop) `{Hdk : ∀ k, Decision (P k)} : dom m1 = dom m2 -> dom (filter (λ x, P x.1) m1) = dom (filter (λ x, P x.1) m2). Proof. intros. apply set_eq. setoid_rewrite elem_of_dom. eapply filter_same_keys_0. setoid_rewrite <- elem_of_dom. rewrite H0. eauto. Qed. Section map_zip. Context `{Countable K}. Context {A B: Type}. Theorem map_zip_empty_l (m2 : gmap K B) : map_zip ( : gmap K A) m2 =  . Proof. apply map_eq; intros. rewrite /map_zip. erewrite lookup_merge by reflexivity. rewrite !lookup_empty /=. destruct (m2 !! i); done. Qed. Theorem map_zip_empty_r (m1 : gmap K A) : map_zip m1 ( : gmap K B) =  . Proof. apply map_eq; intros. rewrite /map_zip. erewrite lookup_merge by reflexivity. rewrite !lookup_empty /=. destruct (m1 !! i); done. Qed. Theorem map_zip_insert (m1 : gmap K A) (m2 : gmap K B) i v1 v2 : map_zip (<[i:=v1]> m1) (<[i:=v2]> m2) = <[i:=(v1, v2)]> (map_zip m1 m2). 
intros. repeat deex. unfold mem_union in *. destruct (m1 name) eqn:?. denote (Some _ = Some _) as Hs; inversion Hs; subst; clear Hs. eauto using dmatch_no_0_inum. eauto. Unshelve. all: eauto. Qed. Notation MSLL := BFILE.MSLL. Notation MSAlloc := BFILE.MSAlloc. Notation MSCache := BFILE.MSCache. Notation MSAllocC := BFILE.MSAllocC. Notation MSIAllocC := BFILE.MSIAllocC. Notation MSDBlocks := BFILE.MSDBlocks. Theorem lookup_ok : forall lxp bxp ixp dnum name ms, {< F Fm Fi m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms',r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms' sm * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * ( [[ r = None /\ notindomain name dmap ]] \/ exists inum isdir Fd, [[ r = Some (inum, isdir) /\ inum <> 0 /\ (Fd * name |-> (inum, isdir))%pred dmap ]]) CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} lookup lxp ixp dnum name ms. Proof. unfold lookup, ifind_lookup_f, rep_macro, rep. safestep. safestep. or_r; cancel. eapply listpred_dmatch_no_0_inum; eauto. eapply ptsto_valid'. denote DEInum as Hd. erewrite selN_inb in Hd by auto. rewrite <- Hd. eapply lookup_ptsto; eauto. eapply lookup_ptsto; eauto. or_l; cancel. apply lookup_notindomain; auto. Unshelve. all: try (exact false || exact emp). all: eauto. Qed. Theorem readdir_ok : forall lxp bxp ixp dnum ms, {< F Fm Fi m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms',r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms' sm * [[ listpred readmatch r dmap ]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} readdir lxp ixp dnum ms. Proof. unfold readdir, rep_macro, rep. safestep. step. apply readmatch_ok. Qed. Local Hint Resolve mem_except_notindomain. Theorem unlink_ok : forall lxp bxp ixp dnum name ms, {< F Fm Fi m0 sm m dmap ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * exists f, rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms', hint, r) exists m' dmap', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * exists f', rep_macro Fm Fi m' bxp ixp dnum dmap' ilist frees f' ms' sm * [[ dmap' = mem_except dmap name ]] * [[ notindomain name dmap' ]] * [[ r = OK tt -> indomain name dmap ]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} unlink lxp ixp dnum name ms. 
precision); auto. repeat split. simpl in |- *; auto with zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. simpl in |- *; auto with zarith. intros H'11; absurd (Float (- 1%nat) (- dExp b) = max :>R). rewrite H'8; auto. apply Rlt_dichotomy_converse; left; auto. apply (MaxUniqueP b radix r); auto. rewrite H'11. apply (RoundedModeProjectorIdem (isMax b radix)); auto. apply MaxRoundedModeP with (precision := precision); auto. repeat split. simpl in |- *; auto with zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. simpl in |- *; auto with zarith. case Hmax. intros H'8 H'11; elim H'11; intros H'12 H'13; apply H'13; clear H'11; auto. apply Rlt_le; auto. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite powerRZ_Zs; auto with real zarith; ring. cut (Fbounded b max); [ unfold Fbounded in |- *; intros Fb0 | case Hmax; auto ]. elim Fb0; intros H H0; repeat (split; simpl in |- *); auto. apply Zle_trans with (Fexp max); auto with zarith. apply Rle_trans with r; auto with real. pattern r at 2 in |- *; replace r with (- (- r * 1%nat))%R; [ idtac | simpl; ring ]. replace (radix * r)%R with (- (- r * radix))%R; [ idtac | ring ]. apply Ropp_le_contravar; apply Rmult_le_compat_l; auto with real arith. replace 0%R with (-0)%R; auto with real arith. apply isMax_inv1 with (1 := H'6). Qed. Theorem roundedModeAbsMult : forall (P : R -> float -> Prop) (p : float) (r : R), RoundedModeP b radix P -> P r p -> (Float 1%nat (- dExp b) <= Rabs r)%R -> (Rabs p <= radix * Rabs r)%R. intros P p r H' H'0 H'1; case (Rle_or_lt 0 r); intros H'2. repeat rewrite Rabs_right; auto with real. apply roundedModeLessMult with (P := P); auto. rewrite <- (Rabs_right r); auto with real. apply Rle_ge; apply (RleRoundedR0 P) with (r := r); auto. repeat rewrite Faux.Rabsolu_left1; auto. replace (radix * - r)%R with (- (radix * r))%R; [ apply Ropp_le_contravar | ring ]. apply roundedModeMoreMult with (P := P); auto. rewrite <- (Ropp_involutive r); rewrite <- (Faux.Rabsolu_left1 r); auto. replace (Float (- 1%nat) (- dExp b)) with (Fopp (Float 1%nat (- dExp b))). unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. simpl in |- *; auto. apply Rlt_le; auto. apply Rlt_le; auto. apply (RleRoundedLessR0 P) with (r := r); auto. apply Rlt_le; auto. Qed. Theorem RleBoundRoundl : forall P, RoundedModeP b radix P -> forall (p q : float) (r : R), Fbounded b p -> (p <= r)%R -> P r q -> (p <= q)%R. 
- split; [apply F1_correct | apply F1_proper]. - split; [apply F3_correct | apply F3_proper]. - generalize (exact_log2_spec _ _ e2);intro; subst i; split; [apply Fexp2_correct | apply Fexp2_proper]. - destruct IHc, IHc0. generalize (N_pos_div_eucl_divides _ _ _ e3); intro eq_i. split. + cbn. rewrite <- eq_i at 1 ; apply Fcompose_correct;auto. + pattern i at 1 ; rewrite <- eq_i at 1; apply Fcompose_proper;auto. - pattern i at 1; replace i with (gamma i * (N2pos q) + N2pos r). + destruct IHc, IHc0;split. * apply KFF_correct;auto. simpl; simpl in H. replace (gamma i) with (N2pos r + (gamma i - N2pos r)) at 1. apply H. rewrite Pplus_minus;auto with chains. apply Pos.lt_gt; rewrite N2pos_lt_switch2. generalize (N.pos_div_eucl_remainder i (N.pos (gamma i) )); rewrite e3; simpl;auto with chains. destruct r; [ contradiction | auto with chains]. * apply KFF_proper;auto with chains. + apply N_pos_div_eucl_rest; auto with chains. destruct r;try contradiction; auto with chains. apply (div_gamma_pos _ _ _ e3); auto with chains. apply pos_gt_3;auto with chains. destruct (exact_log2 i); [contradiction | reflexivity]. - destruct IHc; split. + apply FK_correct; auto with chains. + apply FK_proper; auto with chains. - destruct IHc, IHc0;split. + red; replace (p + d)%positive with (p * N2pos q)%positive. * apply FFK_correct; auto with chains. * generalize (N.pos_div_eucl_spec (p + d) (N.pos p)); rewrite e1; rewrite N.add_0_r ; intro H3; case_eq (q * N.pos p)%N. intro H4; rewrite H4 in H3 ; discriminate. intros p0 H4; rewrite H4 in H3; injection H3; intro H5; rewrite H5. N2pos_destruct q q. injection H4;auto with chains. rewrite Pos.mul_comm; auto with chains. + apply FFK_proper;auto with chains. - destruct IHc, IHc0; split. + red; replace (p+d) with (p * N2pos q + N2pos r). * apply KFK_correct;auto with chains. red in H; replace (N2pos r + (p - N2pos r))%positive with p in H. apply H. rewrite Pplus_minus; auto. generalize (N.pos_div_eucl_remainder (p + d) (N.pos p)); rewrite e1; cbn; intro H3. apply Pos.lt_gt; rewrite N2pos_lt_switch2;auto with chains. destruct r; [contradiction | auto with chains]. * generalize (N.pos_div_eucl_spec (p + d) (N.pos p)); rewrite e1; intros H3; clear H H0 H1 H2. case_eq q. {intro; generalize (pos_div_eucl_quotient_pos _ _ _ _ e1). destruct 1;auto with chains. rewrite pos2N_inj_add; apply N.le_add_r. } { intros p0 Hp0;subst q; cbn; destruct r; [ contradiction | ]. simpl; simpl in H3; injection H3. rewrite Pos.mul_comm; auto with chains. } + apply KFK_proper; auto with chains. Qed. Theorem make_chain_correct : forall p, chain_correct p (make_chain p). 
= map (@tot_map_name _ _ _ _ multi_params_orig_name_tot_map) failed' by rewrite /tot_map_name /= map_id. rewrite {1}H_eq_n'. left. rewrite -2!pt_map_onet_deserialize_onet. have ->: tr = filterMap (@pt_map_trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr. rewrite /pt_map_trace_ev /= /id. clear. elim: tr => //=. case => a; case => b l IH; first by rewrite -IH. by rewrite -IH. exact: H_st. right. break_and. split; first by rewrite -2!pt_map_onet_deserialize_onet. split => //. move: H1. rewrite /pt_map_trace_ev /= /id /=. set f := fun _ => _. clear. elim => //=. elim: tr => //=. case => n; case => /= [i|o] l IH. * by rewrite -IH. * by rewrite -IH. Qed. Lemma step_ordered_failure_serialized_simulation_star : forall net failed tr, @step_ordered_failure_star _ _ serialized_name_overlay_params serialized_fail_msg_params step_ordered_failure_init (failed, net) tr -> @step_ordered_failure_star _ _ orig_name_overlay_params orig_fail_msg_params step_ordered_failure_init (failed, deserialize_onet net) tr. Proof using. move => onet failed tr H_st. apply step_ordered_failure_pt_mapped_simulation_star_1 in H_st. rewrite -pt_map_onet_deserialize_onet. have ->: tr = filterMap (@pt_map_trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr. rewrite /pt_map_trace_ev /= /id. clear. elim: tr => //=. case => a; case => b l IH; first by rewrite -IH. by rewrite -IH. by rewrite map_id in H_st. Qed. Lemma step_ordered_dynamic_failure_deserialized_simulation : forall net net' failed failed' tr, NoDup (odnwNodes net) -> @step_ordered_dynamic_failure _ _ serialized_name_overlay_params serialized_new_msg_params serialized_fail_msg_params (failed, net) (failed', net') tr -> @step_ordered_dynamic_failure _ _ orig_name_overlay_params orig_new_msg_params orig_fail_msg_params (failed, deserialize_odnet net) (failed', deserialize_odnet net') tr \/ deserialize_odnet net = deserialize_odnet net' /\ failed = failed' /\ tr = []. Proof using. move => net net' failed failed' tr H_nd H_st. eapply step_ordered_dynamic_failure_pt_mapped_simulation_1 in H_st; last by []. case: H_st => H_st. have H_eq_n: failed = map (@tot_map_name _ _ _ _ multi_params_orig_name_tot_map) failed by rewrite /tot_map_name /= map_id. rewrite {1}H_eq_n. have H_eq_n': failed' = map (@tot_map_name _ _ _ _ multi_params_orig_name_tot_map) failed' by rewrite /tot_map_name /= map_id. rewrite {1}H_eq_n'. left. rewrite -2!pt_map_odnet_deserialize_odnet. have ->: tr = filterMap (@pt_map_trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr. rewrite /pt_map_trace_ev /= /id. clear. elim: tr => //=. case => a; case => b l IH; first by rewrite -IH. by rewrite -IH. exact: H_st. right. move: H_st => [H_eq_net [H_eq_f H_eq_tr]]. split; first by rewrite -2!pt_map_odnet_deserialize_odnet. split => //. move: H_eq_tr. rewrite /pt_map_trace_ev /= /id. set f := fun _ => _. clear. elim => //=. elim: tr => //=. case => n; case => /= [i|o] l IH. * by rewrite -IH. * by rewrite -IH. Qed. Theorem step_ordered_dynamic_failure_deserialized_simulation_star : forall net failed tr, @step_ordered_dynamic_failure_star _ _ serialized_name_overlay_params serialized_new_msg_params serialized_fail_msg_params step_ordered_dynamic_failure_init (failed, net) tr -> @step_ordered_dynamic_failure_star _ _ orig_name_overlay_params orig_new_msg_params orig_fail_msg_params step_ordered_dynamic_failure_init (failed, deserialize_odnet net) tr. 
auto). rewrite mult_comm; auto. intros k (u & ?) (v & ?); subst. rewrite (mult_comm u). apply divides_mult_compat; auto. apply is_gcd_sym in H. apply is_rel_prime_div with (1 := H) (k := u). rewrite mult_comm, H1; auto. Qed. Hint Resolve divides_1 divides_mult_compat is_gcd_refl. Fact is_gcd_0 p q : is_gcd p q 0 -> p = 0 /\ q = 0. Proof. intros ((a & Ha) & (b & Hb) & H). subst; do 2 rewrite mult_0_r; auto. Qed. Fact is_gcd_rel_prime p q g : is_gcd p q g -> exists a b, p = a*g /\ q = b*g /\ is_gcd a b 1. Proof. destruct (eq_nat_dec g 0) as [ H0 | H0 ]. * intros H; subst. apply is_gcd_0 in H; destruct H; subst. exists 1, 1 ; simpl; auto. * intros ((a & Ha) & (b & Hb) & H). exists a, b; repeat (split; auto). intros k H1 H2. destruct (H (k*g)) as (d & Hd); subst. + do 2 rewrite (mult_comm _ g); auto. + do 2 rewrite (mult_comm _ g); auto. + rewrite mult_assoc in Hd. replace g with (1*g) in Hd at 1 by (simpl; omega). apply Nat.mul_cancel_r in Hd; auto. symmetry in Hd. apply mult_is_one in Hd. destruct Hd; subst; auto. Qed. Fact is_lcm_mult p q l k : is_lcm p q l -> is_lcm (k*p) (k*q) (k*l). Proof. intros (H1 & H2 & H3); repeat (split; auto). intros r (a & Ha) (b & Hb). destruct (eq_nat_dec k 0) as [ Hk | Hk ]. + subst; simpl; auto. + assert (a*p = b*q) as H4. { rewrite <- Nat.mul_cancel_r with (1 := Hk). do 2 rewrite <- mult_assoc, (mult_comm _ k). rewrite <- Hb; auto. } rewrite Ha, mult_assoc, (mult_comm _ k), <- mult_assoc. apply divides_mult_compat; auto. apply H3; auto. rewrite H4; auto. Qed. Theorem is_gcd_lcm_mult p q g l : is_gcd p q g -> is_lcm p q l -> p*q = g*l. Proof. destruct (eq_nat_dec g 0) as [ H0 | H0 ]; intros H1. * subst; apply is_gcd_0 in H1. destruct H1; subst; simpl; auto. * destruct is_gcd_rel_prime with (1 := H1) as (u & v & Hu & Hv & H2). intros H3. rewrite Hu, Hv, (mult_comm u), <- mult_assoc; f_equal. rewrite (mult_comm u), (mult_comm v), <- mult_assoc, (mult_comm v). apply is_lcm_fun with (2 := H3). subst; rewrite (mult_comm u), (mult_comm v). apply is_lcm_mult, is_rel_prime_lcm; auto. Qed. Theorem is_gcd_mult_lcm p q g l : g <> 0 -> is_gcd p q g -> g*l = p*q -> is_lcm p q l. 
: action_circuit CR CSigma REnv sz) (cGamma : ccontext sig) t, interp_circuit (retVal a) = t -> circuit_gamma_equiv vGamma cGamma -> circuit_gamma_equiv (creplace m t vGamma) (creplace m (retVal a) cGamma). Proof. unfold circuit_gamma_equiv; induction sig; intros. - destruct (mdestruct m). - destruct (eq_dec sz0 sz); subst; try destruct (eq_dec m m0); subst. all: rewrite ?cassoc_creplace_eq, ?cassoc_creplace_neq_k, ?cassoc_creplace_neq_members by congruence; eauto. Qed. Definition ccontext_equiv {sig} (c0 c1 : ccontext sig) := forall (sz: nat) (m: member sz sig), interp_circuit (cassoc m c0) = interp_circuit (cassoc m c1). Lemma ccontext_equiv_sym {sig}: forall (c0 c1: ccontext sig), ccontext_equiv c0 c1 <-> ccontext_equiv c1 c0. Proof. firstorder. Qed. Lemma ccontext_equiv_refl {sig}: forall (c: ccontext sig), ccontext_equiv c c. Proof. firstorder. Qed. Lemma ccontext_equiv_cons {sig}: forall sz (c0 c1: circuit _) (ctx0 ctx1: ccontext sig), ccontext_equiv ctx0 ctx1 -> interp_circuit c0 = interp_circuit c1 -> ccontext_equiv (CtxCons sz c0 ctx0) (CtxCons sz c1 ctx1). Proof. unfold ccontext_equiv; intros. destruct (mdestruct m) as [(Heq & ->) | (m' & ->)]; cbn. inversion Heq; subst; rewrite <- Eqdep_dec.eq_rect_eq_dec by apply eq_dec; cbn. all: eauto. Qed. Lemma circuit_gamma_equiv_ccontext_equiv {sig}: forall (c0 c1: ccontext sig) (v: lcontext sig), ccontext_equiv c0 c1 -> circuit_gamma_equiv v c0 -> circuit_gamma_equiv v c1. Proof. unfold circuit_gamma_equiv, ccontext_equiv; intros * Hcceq Hgammaeq **. rewrite <- Hcceq, <- Hgammaeq; reflexivity. Qed. Notation mux_ccontext := (mux_ccontext lco). Lemma ccontext_equiv_mux_ccontext {sig}: forall (cond: circuit 1) (c0 c1: ccontext sig), ccontext_equiv (if Bits.single (interp_circuit cond) then c0 else c1) (mux_ccontext cond c0 c1). Proof. induction sig as [ | sz sig ]; cbn; intros; rewrite (ceqn c0), (ceqn c1). - destruct Bits.single; apply ccontext_equiv_refl. - specialize (IHsig cond (ctl c0) (ctl c1)). destruct Bits.single eqn:Heq; cbn; apply ccontext_equiv_cons; cbn; rewrite ?lco_proof; cbn; rewrite ?Heq; eauto. Qed. Lemma mux_gamma_equiv_t: forall (sig : lsig) (cond: circuit 1), Bits.single (interp_circuit cond) = true -> forall (v0 : lcontext sig) (c0 c1 : ccontext sig), circuit_gamma_equiv v0 c0 -> circuit_gamma_equiv v0 (mux_ccontext cond c0 c1). Proof. intros * Heq **. eapply circuit_gamma_equiv_ccontext_equiv; [ apply ccontext_equiv_mux_ccontext | ]. rewrite Heq; assumption. Qed. Lemma mux_gamma_equiv_f: forall (sig : lsig) (cond: circuit 1), Bits.single (interp_circuit cond) = false -> forall (v0 : lcontext sig) (c0 c1 : ccontext sig), circuit_gamma_equiv v0 c1 -> circuit_gamma_equiv v0 (mux_ccontext cond c0 c1). Proof. intros * Heq **. eapply circuit_gamma_equiv_ccontext_equiv; [ apply ccontext_equiv_mux_ccontext | ]. rewrite Heq; assumption. Qed. Hint Extern 1 => (cbn; rewrite lco_proof) : circuits. Theorem action_compiler_correct rl {sig tau} Log cLog: forall (ex: action sig tau) (clog: rwcircuit) (Gamma: lcontext sig) (gamma: ccontext sig) log, log_rwdata_consistent log clog.(regs) -> log_rwdata_consistent Log cLog -> log_data0_consistent log Log clog.(regs) -> log_data1_consistent log Log clog.(regs) -> circuit_gamma_equiv Gamma gamma -> circuit_env_equiv -> interp_circuit (willFire_of_canFire rl clog cLog) = Ob~1 -> let (cExpr, gamma_new) := compile_action rc gamma ex clog in match interp_action cr csigma Gamma Log log ex with | Some (l', v, Gamma_new) => interp_circuit cExpr.(retVal) = v /\ log_rwdata_consistent l' cExpr.(erwc).(regs) /\ log_data0_consistent l' Log cExpr.(erwc).(regs) /\ log_data1_consistent l' Log cExpr.(erwc).(regs) /\ interp_circuit (willFire_of_canFire rl cExpr.(erwc) cLog) = Ob~1 /\ circuit_gamma_equiv Gamma_new gamma_new | None => interp_circuit (willFire_of_canFire rl cExpr.(erwc) cLog) = Ob~0 end. 
IH in Hy; try apply in_hd. subst. rewrite sat_sshift2, IH in Hz; try apply in_hd_tl. subst. apply M_ext; trivial. + intros a Ha % H. rewrite !VIEQ in Ha. now apply M_pair. + intros a Ha % M_pair; trivial. apply H. now rewrite !VIEQ. - exists (eval rho (Vector.hd v)). rewrite sat_sshift1, IH; try apply in_hd. split; trivial. exists (eval rho (Vector.hd (Vector.tl v))). rewrite sat_sshift2, IH; try apply in_hd_tl. split; trivial. intros d. rewrite !VIEQ. now apply M_pair. - intros (y & Hy & H). rewrite sat_sshift1, IH in Hy; try apply in_hd. subst. apply M_ext; trivial. + intros y Hy % H. now apply M_union. + intros y Hy % M_union; trivial. now apply H. - exists (eval rho (Vector.hd v)). rewrite sat_sshift1, IH; try apply in_hd. split; trivial. intros d. now apply M_union. - intros (y & Hy & H). rewrite sat_sshift1, IH in Hy; try apply in_hd. subst. apply M_ext; trivial. + intros y Hy. now apply M_power, H. + intros y Hy. now apply H, M_power. - exists (eval rho (Vector.hd v)). rewrite sat_sshift1, IH; try apply in_hd. split; trivial. intros d. now apply M_power. - rewrite (vec_nil_eq (Vector.map (eval rho) v)). intros [H1 H2]. apply M_ext; trivial. + apply H2. apply (inductive_sat_om rho). + apply M_om2; trivial. apply inductive_sat with rho. apply H1. - rewrite (vec_nil_eq (Vector.map (eval rho) v)). split. + apply (inductive_sat_om rho). + intros d Hd. apply M_om2; trivial. apply inductive_sat with rho. apply Hd. Qed. Lemma rm_const_sat (rho : nat -> V) (phi : form) : rho ⊨ phi <-> rho ⊨ rm_const_fm phi. Proof using VIEQ M_ZF. induction phi in rho |- *; try destruct P; try destruct b0; try destruct q; cbn. 1,4-6: firstorder easy. - rewrite (vec_inv2 t). cbn. split. + intros H. exists (eval rho (Vector.hd t)). rewrite rm_const_tm_sat. split; trivial. exists (eval rho (Vector.hd (Vector.tl t))). now rewrite sat_sshift1, rm_const_tm_sat. + intros (x & Hx & y & Hy & H). apply rm_const_tm_sat in Hx as <-. rewrite sat_sshift1, rm_const_tm_sat in Hy. now subst. - rewrite (vec_inv2 t). cbn. split. + intros H. exists (eval rho (Vector.hd t)). rewrite rm_const_tm_sat. split; trivial. exists (eval rho (Vector.hd (Vector.tl t))). now rewrite sat_sshift1, rm_const_tm_sat. + intros (x & Hx & y & Hy & H). apply rm_const_tm_sat in Hx as <-. rewrite sat_sshift1, rm_const_tm_sat in Hy. now subst. - split; intros; firstorder easy. - firstorder eauto. Qed. Theorem min_correct (rho : nat -> V) (phi : form) : sat I rho phi <-> sat min_model rho (rm_const_fm phi). 
H23 st. rewrite (H12 st). rewrite (H23 st). reflexivity. Qed.Lemma refl_bequiv : forall (b : bexp), bequiv b b. Proof. unfold bequiv. intros b st. reflexivity. Qed.Lemma sym_bequiv : forall (b1 b2 : bexp), bequiv b1 b2 -> bequiv b2 b1. Proof. unfold bequiv. intros b1 b2 H. intros st. symmetry. apply H. Qed.Lemma trans_bequiv : forall (b1 b2 b3 : bexp), bequiv b1 b2 -> bequiv b2 b3 -> bequiv b1 b3. Proof. unfold bequiv. intros b1 b2 b3 H12 H23 st. rewrite (H12 st). rewrite (H23 st). reflexivity. Qed.Lemma refl_cequiv : forall (c : com), cequiv c c. Proof. unfold cequiv. intros c st st'. apply iff_refl. Qed.Lemma sym_cequiv : forall (c1 c2 : com), cequiv c1 c2 -> cequiv c2 c1. Proof. unfold cequiv. intros c1 c2 H st st'. assert (c1 / st \\ st' <-> c2 / st \\ st') as H'. { apply H. } apply iff_sym. assumption. Qed.Lemma iff_trans : forall (P1 P2 P3 : Prop), (P1 <-> P2) -> (P2 <-> P3) -> (P1 <-> P3). Proof. intros P1 P2 P3 H12 H23. inversion H12. inversion H23. split; intros A. apply H1. apply H. apply A. apply H0. apply H2. apply A. Qed.Lemma trans_cequiv : forall (c1 c2 c3 : com), cequiv c1 c2 -> cequiv c2 c3 -> cequiv c1 c3. Proof. unfold cequiv. intros c1 c2 c3 H12 H23 st st'. apply iff_trans with (c2 / st \\ st'). apply H12. apply H23. Qed. Theorem CAss_congruence : forall i a1 a1', aequiv a1 a1' -> cequiv (CAss i a1) (CAss i a1'). Admitted. Theorem CWhile_congruence : forall b1 b1' c1 c1', bequiv b1 b1' -> cequiv c1 c1' -> cequiv (WHILE b1 DO c1 END) (WHILE b1' DO c1' END). Proof. unfold bequiv,cequiv. intros b1 b1' c1 c1' Hb1e Hc1e st st'. split; intros Hce. - remember (WHILE b1 DO c1 END) as cwhile eqn:Heqcwhile. induction Hce; inversion Heqcwhile; subst. + apply E_WhileEnd. rewrite <- Hb1e. apply H. + apply E_WhileLoop with (st' := st'). * rewrite <- Hb1e. apply H. * apply (Hc1e st st'). apply Hce1. * apply IHHce2. reflexivity. - remember (WHILE b1' DO c1' END) as c'while eqn:Heqc'while. induction Hce; inversion Heqc'while; subst. + apply E_WhileEnd. rewrite -> Hb1e. apply H. + apply E_WhileLoop with (st' := st'). * rewrite -> Hb1e. apply H. * apply (Hc1e st st'). apply Hce1. * apply IHHce2. reflexivity. Qed. Theorem CSeq_congruence : forall c1 c1' c2 c2', cequiv c1 c1' -> cequiv c2 c2' -> cequiv (c1;;c2) (c1';;c2'). 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs". Require Import Coq.Bool.Bool. Require Import Coq.Arith.Arith. Require Import Coq.Arith.EqNat. Require Import Coq.omega.Omega. Require Import Coq.Lists.List. Require Import Coq.Logic.FunctionalExtensionality. Import ListNotations. Require Import Maps. Require Import Imp. Definition aequiv (a1 a2 : aexp) : Prop := forall (st:state), aeval st a1 = aeval st a2.Definition bequiv (b1 b2 : bexp) : Prop := forall (st:state), beval st b1 = beval st b2.Definition cequiv (c1 c2 : com) : Prop := forall (st st' : state), (c1 / st \\ st') <-> (c2 / st \\ st').Theorem skip_left: forall c, cequiv (SKIP;; c) c. Proof. intros c st st'. split; intros H. - inversion H. subst. inversion H2. subst. assumption. - apply E_Seq with st. apply E_Skip. assumption. Qed. Theorem skip_right: forall c, cequiv (c ;; SKIP) c. Proof. Admitted. Theorem IFB_true_simple: forall c1 c2, cequiv (IFB BTrue THEN c1 ELSE c2 FI) c1. Proof. intros c1 c2. split; intros H. - inversion H; subst. assumption. inversion H5. - apply E_IfTrue. reflexivity. assumption. Qed.Theorem IFB_true: forall b c1 c2, bequiv b BTrue -> cequiv (IFB b THEN c1 ELSE c2 FI) c1. Proof. intros b c1 c2 Hb. split; intros H. - inversion H; subst. + assumption. + unfold bequiv in Hb. simpl in Hb. rewrite Hb in H5. inversion H5. - apply E_IfTrue; try assumption. unfold bequiv in Hb. simpl in Hb. rewrite Hb. reflexivity. Qed. Theorem IFB_false: forall b c1 c2, bequiv b BFalse -> cequiv (IFB b THEN c1 ELSE c2 FI) c2. 
Set Implicit Arguments.Require Import Coq.Bool.Bool. Require Import Bedrock.Platform.AutoSep. Require Import Bedrock.Platform.Cito.SyntaxExpr Bedrock.Platform.Cito.SemanticsExpr Bedrock.Platform.Cito.Syntax Bedrock.Platform.Cito.Semantics.Fixpoint expReads (unwritten : string -> Prop) (e : Expr) (x : string) : Prop := match e with | Var y => x = y /\ unwritten x | Const _ => False | Binop _ e1 e2 => expReads unwritten e1 x \/ expReads unwritten e2 x | TestE _ e1 e2 => expReads unwritten e1 x \/ expReads unwritten e2 x end.Import Syntax.Fixpoint writes (s : Stmt) (x : string) : Prop := match s with | Assign y _ => x = y | Label y _ => x = y | Seq s1 s2 => writes s1 x \/ writes s2 x | Skip => False | Syntax.If _ s1 s2 => writes s1 x /\ writes s2 x | Syntax.While _ _ => False | Syntax.Call yo _ _ => match yo with | None => False | Some y => x = y end end.Section ExistsR. Variable A : Type. Variable P : A -> Prop. Fixpoint ExistsR (ls : list A) : Prop := match ls with | nil => False | x :: ls => P x \/ ExistsR ls end. Theorem ExistsR_Exists : forall ls, ExistsR ls -> List.Exists P ls. induction ls; simpl; intuition. Qed. Theorem Exists_ExistsR : forall ls, List.Exists P ls -> ExistsR ls. induction 1; simpl; intuition. Qed. End ExistsR.Section ExistsR_weaken. Variable A : Type. Variables P Q : A -> Prop. Hypothesis P_Q : forall x, P x -> Q x. Theorem ExistsR_weaken : forall ls, ExistsR P ls -> ExistsR Q ls. 
inversion_clear H2; simpl in |- *. unfold isTraceFrom in |- *; split; trivial. unfold isTraceFrom in |- *; split; trivial. Qed. Lemma not_EX : forall (P : Stream S -> Prop) (x : Stream S) (s : S), ~ ExistsS P (s ^ x) -> ~ ExistsS P x. Proof. unfold not in |- *; intros. apply (H (Further s H0)). Qed. Theorem Equiv4 : forall (Sini : S) (P : Stream S -> Prop), SafePath Sini P <-> ~ Inevitable Sini (fun s : Stream S => ~ P s). Proof. unfold iff, Inevitable, not in |- *; intros; split. intro sp; inversion sp; intros. generalize H0; elim (H1 x H); intros. inversion_clear H3 in H2. apply (H2 H4). apply H3; inversion_clear H4; assumption. intro H; elim (not_all_ex_not (Stream S) (fun x : Stream S => isTraceFrom Sini x -> ExistsS (fun s : Stream S => P s -> False) x) H). intros. generalize (not_imply_elim2 (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0). generalize (not_imply_elim (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0); intros. apply safePath with (1 := H1). generalize H1; clear H1; generalize H2; clear H2. generalize x; generalize Sini; cofix u. simple destruct x0; intros; constructor. elim (classic (P (s ^ s0))); [ trivial | intro ]. elim (H2 (Here (P:=fun s : Stream S => ~ P s) H3)). apply u with (Sini := hd s0). generalize H2; clear H2; case s0; unfold not in |- *; intros. apply (not_EX H2 H3). elim H1; intros ig trace; inversion_clear trace. unfold isTraceFrom in |- *; split; trivial. unfold isTraceFrom in |- *; split; trivial. Qed. Theorem Mon_I_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ForAllS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ForAllS Pp x. Proof. cofix u; intro x; case x; intros. case H; constructor. apply (H0 (s1 ^ x0) H1). apply (u x0 Pg Pp H2 H0). Qed. Theorem Conj_S : forall (x : Stream S) (P1 P2 : Stream S -> Prop), ForAllS P1 x -> ForAllS P2 x -> ForAllS (fun s : Stream S => P1 s /\ P2 s) x. Proof. cofix u; intro x; case x; intros. inversion_clear H; inversion_clear H0. constructor; [ split | apply (u s0) ]; assumption. Qed. Theorem Mon_I_EX_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ExistsS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ExistsS Pp x. 
intros l1 s H'; rewrite (pO_plusP_inv1 l1 s); auto. intros a1 a2 l1 l2 l3 H' H'0 H'1 s H'2. rewrite (plusP_inv2 a2 a1 l2 l1 s); auto. intros a1 a2 l1 l2 l3 H' H'0 H'1 H'2 s R. rewrite (plusP_inv3a a2 a1 l2 l1 s); auto. apply (eqT_sym A n a1); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := plusTerm (A:=A) plusA (n:=n) a1 a2); auto. apply plusTerm_com with (1 := cs); auto. intros a1 a2 l1 l2 l3 H' H'0 H'1 H'2 s H'3. rewrite (plusP_inv3b a2 a1 l2 l1 s); auto. apply eqpP1; auto; apply plusTerm_com with (1 := cs); auto. apply (eqT_sym A n a1); auto. red in |- *; intros H'4; apply H'2. apply zeroP_comp_eqTerm with (1 := cs) (a := plusTerm (A:=A) plusA (n:=n) a2 a1); auto. apply plusTerm_com with (1 := cs); auto. apply (eqT_sym A n); auto. intros a1 a2 l1 l2 l3 H' H'0 H'1 s H'2. rewrite (plusP_inv1 a2 a1 l2 l1 s); auto. Qed. Theorem pluspf_com : forall p q, eqP A eqA n (pluspf p q) (pluspf q p). intros p q; apply (plusP_com p q (pluspf p q) (pluspf q p)); auto. Qed. Theorem plusP_zero_pOl : forall p q, plusP (pO A n) p q -> eqP A eqA n p q. intros p q H'; inversion H'; auto. Qed. Theorem plusP_zero_pOr : forall p q, plusP p (pO A n) q -> eqP A eqA n p q. intros p q H'; inversion H'; auto. Qed. Hint Resolve plusP_zero_pOl plusP_zero_pOr. Hint Resolve eqp_trans. Theorem plusP_uniq_eqP : forall p q r s, plusP p q r -> plusP p q s -> eqP A eqA n r s. intros p q r s H' H'0; rewrite (uniq_plusp (p, q) r s); auto. Qed. Hint Resolve plusP_uniq_eqP. Theorem pO_pluspf_inv1 : forall p, p = pluspf (pO A n) p. intros p. apply uniq_plusp with (l := (pO A n, p)); auto. Qed. Theorem pO_pluspf_inv2 : forall p, p = pluspf p (pO A n). intros p. apply uniq_plusp with (l := (p, pO A n)); auto. Qed. Theorem pluspf_inv1_eq : forall a b p q, ltT ltM b a -> pX a (pluspf p (pX b q)) = pluspf (pX a p) (pX b q). intros a b p q H'; rewrite (plusP_inv1 a b p q (pluspf (pX a p) (pX b q))); auto. Qed. Theorem pluspf_inv2_eq : forall a b p q, ltT ltM a b -> pX b (pluspf (pX a p) q) = pluspf (pX a p) (pX b q). 
v). simple induction 1; auto with coc core arith datatypes. simple destruct v; intros. inversion_clear H2.inversion_clear H3; auto with coc core arith datatypes. Qed. Lemma ins_item_lt : forall A n e f, ins_in_env A n e f -> forall v : nat, n > v -> forall t, item_lift t e v -> item_lift (lift_rec 1 t n) f v. simple induction 1. intros. inversion_clear H0.simple destruct v; intros. elim H3; intros. rewrite H4. exists (lift_rec 1 t n0); auto with coc core arith datatypes. inversion_clear H5. elim permute_lift with t n0; auto with coc core arith datatypes.elim H3; intros. rewrite H4. inversion_clear H5. elim H1 with n1 (lift (S n1) x); intros; auto with coc core arith datatypes. exists x0; auto with coc core arith datatypes. pattern (lift (S (S n1)) x0) at 1 in |- *. rewrite simpl_lift; auto with coc core arith datatypes. elim H5. change (lift_rec 1 (lift (S (S n1)) x) (S n0) = lift 1 (lift_rec 1 (lift (S n1) x) n0)) in |- *. rewrite (permute_lift (lift (S n1) x) n0). unfold lift at 2 in |- *. pattern (lift (S (S n1)) x) in |- *. rewrite simpl_lift; auto with coc core arith datatypes.exists x; auto with coc core arith datatypes. Qed. Lemma typ_weak_weak : forall A e t T, typ e t T -> forall n f, ins_in_env A n e f -> wf f -> typ f (lift_rec 1 t n) (lift_rec 1 T n). simple induction 1; simpl in |- *; intros; auto with coc core arith datatypes. elim (le_gt_dec n v); intros; apply type_var; auto with coc core arith datatypes. elim H1; intros. exists x. rewrite H4. unfold lift in |- *. rewrite simpl_lift_rec; simpl in |- *; auto with coc core arith datatypes.apply ins_item_ge with A n e0; auto with coc core arith datatypes.apply ins_item_lt with A e0; auto with coc core arith datatypes.cut (wf (lift_rec 1 T0 n :: f)). intro. apply type_abs with s1 s2; auto with coc core arith datatypes.apply wf_var with s1; auto with coc core arith datatypes.rewrite distr_lift_subst. apply type_app with (lift_rec 1 V n); auto with coc core arith datatypes.cut (wf (lift_rec 1 T0 n :: f)). intro. apply type_prod with s1; auto with coc core arith datatypes.apply wf_var with s1; auto with coc core arith datatypes.apply type_conv with (lift_rec 1 U n) s; auto with coc core arith datatypes. Qed. Theorem thinning : forall e t T, typ e t T -> forall A, wf (A :: e) -> typ (A :: e) (lift 1 t) (lift 1 T). 
Require Export FroundMult. Require Export ClosestProp. Section FRoundP. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Theorem closestLessMultPos : forall (p : float) (r : R), Closest b radix r p -> (0 <= r)%R -> (p <= 2%nat * r)%R. 
-> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; subst; simpl in *; auto; congruence. Qed. Theorem handleRequestVoteReply_votesReceived : forall h st t h' r v, In v (votesReceived (handleRequestVoteReply h st h' t r)) -> In v (votesReceived st) \/ (r = true /\ v = h' /\ currentTerm (handleRequestVoteReply h st h' t r) = t). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; subst; simpl in *; do_bool; intuition. Qed. Theorem handleTimeout_log_term_type : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ currentTerm st' = S (currentTerm st). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma handleClientRequest_candidate : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = Candidate -> st' = st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_candidate : forall st h os st' ms, doLeader st h = (os, st', ms) -> type st' = Candidate -> st' = st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_term_votedFor : forall st h os st' ms, doLeader st h = (os, st', ms) -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma doGenericServer_log_type_term_votesReceived : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> log st' = log st /\ type st' = type st /\ currentTerm st' = currentTerm st /\ votesReceived st' = votesReceived st /\ votedFor st' = votedFor st. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleClientRequest_term_votedFor : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = type st /\ currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Theorem handleAppendEntries_term_votedFor : forall h st t n pli plt es ci st' ps h', handleAppendEntries h st t n pli plt es ci = (st', ps) -> votedFor st' = Some h' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. 
Theorem t1 : forall (A : Set) (a : A) (f : A -> A), f a = a -> f (f a) = a. intros. congruence. Qed.Theorem t2 : forall (A : Set) (a b : A) (f : A -> A) (g : A -> A -> A), a = f a -> g b (f a) = f (f a) -> g a b = f (g b a) -> g a b = a. intros. congruence. Qed.Theorem t3 : forall (N : Set) (o : N) (s d : N -> N), s (s (s (s (s (s (s (s (s (s (s (s (s (s (s o)))))))))))))) = o -> s (s (s (s (s (s (s (s (s (s o))))))))) = o -> s (s (s (s (s (s o))))) = o -> o = s o. intros. congruence. Qed.Theorem dep : forall (A : Set) (P : A -> Set) (f g : forall x : A, P x) (x y : A) (e : x = y) (e0 : f y = g y), f x = g x. intros; dependent rewrite e; exact e0. Qed.Theorem dep2 : forall (A B : Set) (f : forall (A : Set) (b : bool), if b then unit else A -> unit) (e : A = B), f A true = f B true. intros; rewrite e; reflexivity. Qed. Theorem dep3 : forall (A : Set) (P : A -> Set) (f g : forall x : A, P x), f = g -> forall x : A, f x = g x. 
total = begin ++ cap -> 0 < length cap -> index < length begin -> S index < length total. Proof. intros Htotal Hcap Hindex; assert (Hlen: length total = (length begin) + (length cap)) by solve [rewrite Htotal; apply app_length]; apply (numeric_capped_incr_safe Hlen Hcap Hindex). Qed.Theorem index_pairs_lookup_forward {A B}: forall (items: list A) (f: nat -> A -> B) item index, lookup index items = Some item -> lookup index (imap f items) = Some (f index item). Proof. induction items; intros ??[]?; try solve [apply (IHitems (compose f S)); assumption]; naive_solver. Qed.Theorem index_pairs_lookup_back {A B}: forall (items: list A) (f: nat -> A -> B) item index, (forall index i1 i2, f index i1 = f index i2 -> i1 = i2) -> lookup index (imap f items) = Some (f index item) -> lookup index items = Some item. Proof. induction items; intros ??[]Hf?; try solve [injection H; intros ?%Hf; naive_solver]; try solve [apply (IHitems (compose f S)); eauto]; naive_solver. Qed.Theorem index_pair_equality {A B} (a: A) (b1 b2: B): (a, b1) = (a, b2) -> b1 = b2. Proof. naive_solver. Qed.Inductive partial (P: Prop): Type := | Proven: P -> partial P | Unknown: partial P . Notation proven := (Proven _). Notation unknown := (Unknown _). Notation provenif test := (if test then proven else unknown).Section find_obligations. Context {T: Type}. Variable P: T -> Prop. Theorem forall_done_undone items done undone: Permutation items (done ++ undone) -> Forall P done -> Forall P undone -> Forall P items. Proof. intros Hpermutation??; assert (Happ: Forall P (done ++ undone)) by solve [apply Forall_app_2; assumption]; setoid_rewrite Hpermutation; assumption. Qed. Variable compute_partial: forall t: T, partial (P t). Definition split_by_maybe: forall items: list T, { pair | Permutation items (pair.1 ++ pair.2) /\ Forall P pair.1 }. refine (fix split_by_maybe items := match items with | [] => this ([], []) | item :: items' => let (pair, H) := split_by_maybe items' in match (compute_partial item) with | Proven _ => this ((item :: pair.1), pair.2) | Unknown => this (pair.1, (item :: pair.2)) end end ); intros; split; simpl in *; try destruct H; try solve [setoid_rewrite H; apply Permutation_middle]; auto. Defined. Definition find_obligations_function: forall items, { obligations | Forall P obligations -> Forall P items }. refine (fun items => let (pair, H) := split_by_maybe items in this pair.2 ); destruct H; apply (forall_done_undone H); assumption. Defined. Theorem verify__find_obligations_function: forall items found, found = find_obligations_function items -> Forall P (use found) -> Forall P items. 
Some st') -> c / st \\ st'. Proof. intros c st st' H. inversion H as [i E]. clear H. generalize dependent st'. generalize dependent st. generalize dependent c. induction i as [| i' ]. - intros c st st' H. inversion H. - intros c st st' H. destruct c; simpl in H; inversion H; subst; clear H. + apply E_Skip. + apply E_Ass. reflexivity. + destruct (ceval_step st c1 i') eqn:Heqr1. * apply E_Seq with s. apply IHi'. rewrite Heqr1. reflexivity. apply IHi'. simpl in H1. assumption. * inversion H1. + destruct (beval st b) eqn:Heqr. * apply E_IfTrue. rewrite Heqr. reflexivity. apply IHi'. assumption. * apply E_IfFalse. rewrite Heqr. reflexivity. apply IHi'. assumption. + destruct (beval st b) eqn :Heqr. * destruct (ceval_step st c i') eqn:Heqr1. { apply E_WhileTrue with s. rewrite Heqr. reflexivity. apply IHi'. rewrite Heqr1. reflexivity. apply IHi'. simpl in H1. assumption. } { inversion H1. } * inversion H1. apply E_WhileFalse. rewrite <- Heqr. subst. reflexivity. Qed.[] *)Theorem ceval_step_more: forall i1 i2 st st' c, i1 <= i2 -> ceval_step st c i1 = Some st' -> ceval_step st c i2 = Some st'. Proof. induction i1 as [|i1']; intros i2 st st' c Hle Hceval. - simpl in Hceval. inversion Hceval. - destruct i2 as [|i2']. inversion Hle. assert (Hle': i1' <= i2') by omega. destruct c. + simpl in Hceval. inversion Hceval. reflexivity. + simpl in Hceval. inversion Hceval. reflexivity. + simpl in Hceval. simpl. destruct (ceval_step st c1 i1') eqn:Heqst1'o. * apply (IHi1' i2') in Heqst1'o; try assumption. rewrite Heqst1'o. simpl. simpl in Hceval. apply (IHi1' i2') in Hceval; try assumption. * inversion Hceval. + simpl in Hceval. simpl. destruct (beval st b); apply (IHi1' i2') in Hceval; assumption. + simpl in Hceval. simpl. destruct (beval st b); try assumption. destruct (ceval_step st c i1') eqn: Heqst1'o. * apply (IHi1' i2') in Heqst1'o; try assumption. rewrite -> Heqst1'o. simpl. simpl in Hceval. apply (IHi1' i2') in Hceval; try assumption. * simpl in Hceval. inversion Hceval. Qed. Theorem ceval__ceval_step: forall c st st', c / st \\ st' -> exists i, ceval_step st c i = Some st'. Proof. intros c st st' Hce. induction Hce. Admitted. Theorem ceval_and_ceval_step_coincide: forall c st st', c / st \\ st' <-> exists i, ceval_step st c i = Some st'. Proof. intros c st st'. split. apply ceval__ceval_step. apply ceval_step__ceval. Qed. Theorem ceval_deterministic' : forall c st st1 st2, c / st \\ st1 -> c / st \\ st2 -> st1 = st2. 
Require Import List Arith Lia Relations.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_congruence fo_sat.Import fol_notations.Set Implicit Arguments.Local Infix "∊" := In (at level 70, no associativity). Local Infix "⊑" := incl (at level 70, no associativity). Local Notation ø := vec_nil.Section remove_interpreted_symbol. Variables (Σ : fo_signature) (ls : list (syms Σ)) (lr : list (rels Σ)) (e : rels Σ) (H_ae : ar_rels _ e = 2) (He : e ∊ lr). Notation 𝕋 := (fol_term Σ). Notation 𝔽 := (fol_form Σ). Notation "x ≡ y" := (@fol_atom Σ e (cast (x##y##ø) (eq_sym H_ae))) (at level 59). Definition Σ_noeq A := fol_congruence H_ae ls lr ⟑ A. Section soundness. Variable (A : 𝔽) (X : Type). Theorem Σ_noeq_sound : fo_form_fin_dec_eq_SAT_in _ H_ae A X -> fo_form_fin_dec_SAT_in (Σ_noeq A) X. 
Require Import Mem. Require Import Pred. Require Import Prog. Require Import ListPred. Require Import List. Require Import SepAuto. Require Import Array. Require Import Omega. Require Import AsyncDisk PredCrash. Require Import FunctionalExtensionality. Set Implicit Arguments. Set Default Proof Using "Type".Section MemPred. Variable LowAT : Type. Variable LowAEQ : EqDec LowAT. Variable LowV : Type. Variable HighAT : Type. Variable HighAEQ : EqDec HighAT. Variable HighV : Type. Definition low_mem := @mem LowAT LowAEQ LowV. Definition high_mem := @mem HighAT HighAEQ HighV. Definition low_pred := @pred LowAT LowAEQ LowV. Definition high_pred := @pred HighAT HighAEQ HighV. Fixpoint avs2mem_iter (avs : list (HighAT * HighV)) (m : @mem HighAT HighAEQ HighV) := match avs with | nil => m | (a, v) :: rest => upd (avs2mem_iter rest m) a v end. Definition avs2mem avs := avs2mem_iter avs empty_mem. Fixpoint avs_except avs victim : @list (HighAT * HighV) := match avs with | nil => nil | (a, v) :: rest => if HighAEQ a victim then avs_except rest victim else (a, v) :: avs_except rest victim end. Theorem avs_except_notin_eq : forall avs a, ~ In a (map fst avs) -> avs_except avs a = avs. 
rawInst1 curPc1 nextPc1 epoch1) = evalExpr (f2dPack rawInst2 curPc2 nextPc2 epoch2)). Context {indexSize tagSize: nat}. Variables (getIndex: forall ty, fullType ty (SyntaxKind (Bit addrSize)) -> Expr ty (SyntaxKind (Bit indexSize))) (getTag: forall ty, fullType ty (SyntaxKind (Bit addrSize)) -> Expr ty (SyntaxKind (Bit tagSize))). Variables (pcInit : ConstT (Pc addrSize)). Definition fetchICacheDecode := ((fetchICache fetch f2dPack getIndex getTag pcInit) ++ (PrimFifo.fifoC PrimFifo.primPipelineFifoName f2dFifoName f2dElt) ++ (decoder dec d2ePack f2dRawInst f2dCurPc f2dNextPc f2dEpoch))%kami. Definition fetchDecode := fetchDecode fetch dec d2ePack f2dPack f2dRawInst f2dCurPc f2dNextPc f2dEpoch pcInit. Definition fetchNDecode := ProcThreeStage.fetchDecode fetch dec d2ePack pcInit. #[local] Hint Unfold fetchDecode: ModuleDefs. #[local] Hint Extern 1 (ModEquiv type typeUT fetchDecode) => unfold fetchDecode. #[local] Hint Extern 1 (ModEquiv type typeUT fetchNDecode) => unfold fetchNDecode. Definition fetchDecode_ruleMap (o: RegsT): string -> option string := "pgmInitRq" |-> "pgmInitRq"; "pgmInitRqEnd" |-> "pgmInitRqEnd"; "pgmInitRs" |-> "pgmInitRs"; "pgmInitRsEnd" |-> "pgmInitRsEnd"; "modifyPc" |-> "modifyPc"; "decodeLd" |-> "instFetchLd"; "decodeSt" |-> "instFetchSt"; "decodeTh" |-> "instFetchTh"; "decodeNm" |-> "instFetchNm"; ||. #[local] Hint Unfold fetchDecode_ruleMap: MethDefs. Definition fetchDecode_regMap (r: RegsT): RegsT := (mlet pcv : (Pc addrSize) <- r |> "pc"; mlet pinitv : Bool <- r |> "pinit"; mlet pinitRqv : Bool <- r |> "pinitRq"; mlet pinitRqOfsv : (Bit iaddrSize) <- r |> "pinitRqOfs"; mlet pinitRsOfsv : (Bit iaddrSize) <- r |> "pinitRsOfs"; mlet pgmv : (Vector (Data instBytes) iaddrSize) <- r |> "pgm"; mlet fev : Bool <- r |> "fEpoch"; mlet f2dfullv : Bool <- r |> "f2d"--"full"; mlet f2deltv : f2dElt <- r |> "f2d"--"elt"; (["fEpoch" <- existT _ _ fev] +["pgm" <- existT _ _ pgmv] +["pinitRsOfs" <- existT _ _ pinitRsOfsv] +["pinitRqOfs" <- existT _ _ pinitRqOfsv] +["pinitRq" <- existT _ _ pinitRqv] +["pinit" <- existT _ _ pinitv] +["pc" <- existT _ (SyntaxKind (Pc addrSize)) (if f2dfullv then evalExpr (f2dCurPc _ f2deltv) else pcv)])%fmap)%mapping. #[local] Hint Unfold fetchDecode_regMap: MapDefs. Definition fetchDecodeInl := ProcFDInl.fetchDecodeInl fetch dec d2ePack f2dPack f2dRawInst f2dCurPc f2dNextPc f2dEpoch pcInit. Ltac f2d_abs_tac := try rewrite Hf2dRawInst in *; try rewrite Hf2dCurPc in *; try rewrite Hf2dNextPc in *; try rewrite Hf2dEpoch in *; repeat match goal with | [H: ?pinitv = false -> true = false |- ?pinitv = true] => destruct pinitv; [reflexivity|specialize (H eq_refl); discriminate] end. Ltac fetchDecode_dest_tac := repeat match goal with | [H: context[fetchDecode_inv] |- _] => destruct H end; kinv_red. Definition fdConfig := {| inlining := ITProvided fetchDecodeInl; decomposition := DTFunctional fetchDecode_regMap fetchDecode_ruleMap; invariants := IVCons fetchDecode_inv_ok IVNil |}. Theorem fetchDecode_refines_fetchNDecode: fetchDecode <<== fetchNDecode. 
= map (@tot_map_name _ _ _ _ multi_params_orig_name_tot_map) failed' by rewrite /tot_map_name /= map_id. rewrite {1}H_eq_n'. left. rewrite -2!pt_map_onet_deserialize_onet. have ->: tr = filterMap (@pt_map_trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr. rewrite /pt_map_trace_ev /= /id. clear. elim: tr => //=. case => a; case => b l IH; first by rewrite -IH. by rewrite -IH. exact: H_st. right. break_and. split; first by rewrite -2!pt_map_onet_deserialize_onet. split => //. move: H1. rewrite /pt_map_trace_ev /= /id /=. set f := fun _ => _. clear. elim => //=. elim: tr => //=. case => n; case => /= [i|o] l IH. * by rewrite -IH. * by rewrite -IH. Qed. Lemma step_ordered_failure_serialized_simulation_star : forall net failed tr, @step_ordered_failure_star _ _ serialized_name_overlay_params serialized_fail_msg_params step_ordered_failure_init (failed, net) tr -> @step_ordered_failure_star _ _ orig_name_overlay_params orig_fail_msg_params step_ordered_failure_init (failed, deserialize_onet net) tr. Proof using. move => onet failed tr H_st. apply step_ordered_failure_pt_mapped_simulation_star_1 in H_st. rewrite -pt_map_onet_deserialize_onet. have ->: tr = filterMap (@pt_map_trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr. rewrite /pt_map_trace_ev /= /id. clear. elim: tr => //=. case => a; case => b l IH; first by rewrite -IH. by rewrite -IH. by rewrite map_id in H_st. Qed. Lemma step_ordered_dynamic_failure_deserialized_simulation : forall net net' failed failed' tr, NoDup (odnwNodes net) -> @step_ordered_dynamic_failure _ _ serialized_name_overlay_params serialized_new_msg_params serialized_fail_msg_params (failed, net) (failed', net') tr -> @step_ordered_dynamic_failure _ _ orig_name_overlay_params orig_new_msg_params orig_fail_msg_params (failed, deserialize_odnet net) (failed', deserialize_odnet net') tr \/ deserialize_odnet net = deserialize_odnet net' /\ failed = failed' /\ tr = []. Proof using. move => net net' failed failed' tr H_nd H_st. eapply step_ordered_dynamic_failure_pt_mapped_simulation_1 in H_st; last by []. case: H_st => H_st. have H_eq_n: failed = map (@tot_map_name _ _ _ _ multi_params_orig_name_tot_map) failed by rewrite /tot_map_name /= map_id. rewrite {1}H_eq_n. have H_eq_n': failed' = map (@tot_map_name _ _ _ _ multi_params_orig_name_tot_map) failed' by rewrite /tot_map_name /= map_id. rewrite {1}H_eq_n'. left. rewrite -2!pt_map_odnet_deserialize_odnet. have ->: tr = filterMap (@pt_map_trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr. rewrite /pt_map_trace_ev /= /id. clear. elim: tr => //=. case => a; case => b l IH; first by rewrite -IH. by rewrite -IH. exact: H_st. right. move: H_st => [H_eq_net [H_eq_f H_eq_tr]]. split; first by rewrite -2!pt_map_odnet_deserialize_odnet. split => //. move: H_eq_tr. rewrite /pt_map_trace_ev /= /id. set f := fun _ => _. clear. elim => //=. elim: tr => //=. case => n; case => /= [i|o] l IH. * by rewrite -IH. * by rewrite -IH. Qed. Theorem step_ordered_dynamic_failure_deserialized_simulation_star : forall net failed tr, @step_ordered_dynamic_failure_star _ _ serialized_name_overlay_params serialized_new_msg_params serialized_fail_msg_params step_ordered_dynamic_failure_init (failed, net) tr -> @step_ordered_dynamic_failure_star _ _ orig_name_overlay_params orig_new_msg_params orig_fail_msg_params step_ordered_dynamic_failure_init (failed, deserialize_odnet net) tr. 
Lemma simplify_fwd' : forall G (p : propX pc state G) s, interp specs (Substs s p) -> simplify p s. induction p; simpl; intuition; autorewrite with Substs in *. apply (Inj_sound H). apply Substs_Cptr_fwd in H0; apply (Cptr_sound H0). apply And_sound in H; intuition. apply And_sound in H; intuition. apply Or_sound in H; intuition. apply Substs_Forall_fwd in H0; specialize (Forall_sound H0); intuition. apply Substs_Exists_fwd in H0; specialize (Exists_sound H0); firstorder. assumption. auto. apply IHp; apply simplify_fwd_ForallX; auto. apply simplify_fwd_ExistsX in H; firstorder. Qed. Lemma simplify_fwd : forall p, interp specs p -> simplify p SNil. intros; apply simplify_fwd'; auto. Qed. Fixpoint simplifyH G (p : propX pc state G) : subs G -> Prop := match p with | Inj _ P => fun _ => P | Cptr _ f a => fun s => exists a', specs f = Some a' /\ forall x, a' x = Substs s (a x) | And _ p1 p2 => fun s => simplifyH p1 s /\ simplifyH p2 s | Or _ p1 p2 => fun s => simplifyH p1 s \/ simplifyH p2 s | _ => fun _ => True end. Lemma Substs_Cptr : forall G (s : subs G) f a, exists a', Substs s (Cptr f a) = Cptr f a' /\ forall x, a' x = Substs s (a x). induction s; simpl; intuition eauto. Qed. Lemma simplifyH_ok : forall G (p : propX pc state G) s PG p', In (Substs s p) PG -> (simplifyH p s -> valid specs PG (Substs s p')) -> valid specs PG (Substs s p'). induction p; simpl; intuition; autorewrite with Substs in *. eapply Inj_E; [ constructor; eauto | auto ]. destruct (Substs_Cptr s p p0) as [? [ Heq ] ]; rewrite Heq in *. eapply Cptr_E; [ constructor; eauto | eauto ]. assert (valid specs PG (Substs s p1 ---> Substs s p2 ---> Substs s p')%PropX). repeat apply Imply_I. apply IHp1. simpl; tauto. intro. apply IHp2. simpl; tauto. eauto. eapply Imply_E. eapply Imply_E. eassumption. eapply And_E1; econstructor; eauto. eapply And_E2; econstructor; eauto. eapply Or_E. constructor; eauto. intuition. intuition. Qed. Theorem simplify_Imply : forall p1 p2, (simplifyH p1 SNil -> simplify p2 SNil) -> interp specs (Imply p1 p2). intros. change (interp specs (Imply (Substs SNil p1) (Substs SNil p2))). apply Imply_I. eapply simplifyH_ok. simpl; tauto. intros. apply valid_weaken1. apply simplify_bwd. auto. Qed. Theorem Imply_easyL' : forall G (p1 p2 p : PropX pc state), (simplifyH p1 SNil -> valid specs G (Imply p2 p)) -> valid specs G (Imply (And p1 p2) p). 
Zpower_nat_Z_powerRZ; simpl in |- *; try ring. rewrite <- Zpower_nat_Z_powerRZ; auto with zarith; rewrite <- Rmult_IZR; rewrite Zmult_comm; rewrite <- (PosNormMin radix b precision); auto with real zarith. auto. red in |- *; intros H'12; absurd (- dExp b <= Fexp (Fnormalize radix b precision r'))%Z; auto with float. apply Zlt_not_le. rewrite <- H'12; rewrite <- H'10; unfold Zsucc in |- *; auto with float zarith. apply (FcanonicBound radix b); auto with arith. apply FnormalizeCanonic; auto with arith. exists (Float (Fnum (Fnormalize radix b precision r') - radix) (Fexp (Fnormalize radix b precision r'))). cut (Fbounded b (Fnormalize radix b precision r')); [ intros Fb1 | idtac ]. repeat split; simpl in |- *; auto with float. case (Zle_or_lt (Fnum (Fnormalize radix b precision r')) radix); intros Z1. apply Zle_lt_trans with radix. rewrite Zabs_eq_opp; auto with zarith. cut (0 <= Fnum (Fnormalize radix b precision r'))%Z; auto with zarith. apply (LeR0Fnum radix); auto. rewrite <- (Zpower_nat_1 radix); rewrite pGivesBound; auto with zarith. apply Zle_lt_trans with (Zabs (Fnum (Fnormalize radix b precision r'))). repeat rewrite Zabs_eq; auto with zarith. case Fb1; auto. rewrite FPredSimpl4; auto with arith. rewrite <- H'10. unfold FtoRradix, FtoR in |- *; simpl in |- *. cut (forall x : Z, Zpred x = (x - 1%nat)%Z); [ intros tmp; rewrite tmp; clear tmp | intros; unfold Zpred in |- *; simpl in |- *; ring ]. repeat rewrite <- Z_R_minus; auto. repeat rewrite (fun x y => Rmult_comm (x - y)); repeat rewrite Rmult_minus_distr_l; repeat rewrite (fun x y => Rmult_comm (powerRZ x y)). replace (Fnum (Fnormalize radix b precision r') * powerRZ radix (Fexp (Fnormalize radix b precision r')))%R with (FtoRradix (Fnormalize radix b precision r')). rewrite (FnormalizeCorrect radix); auto. unfold FtoRradix in H'14; rewrite H'14. unfold FtoR in |- *; simpl in |- *. rewrite <- H'10. repeat rewrite powerRZ_Zs; auto with real arith. ring. auto with real zarith. unfold FtoR in |- *; simpl in |- *; auto. red in |- *; intros H'12; absurd (0 <= Fnum q0)%Z; auto. apply Zlt_not_le. rewrite H'12. replace 0%Z with (- 0%nat)%Z; [ apply Zlt_Zopp | simpl in |- *; auto ]. unfold pPred in |- *; apply Zlt_succ_pred; simpl in |- *; auto with zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith. apply (LeR0Fnum radix); auto. apply Rlt_le; auto. apply (FcanonicBound radix b); auto with arith. apply FnormalizeCanonic; auto with arith. Qed. Theorem ExactMinusIntervalAux1 : forall P, RoundedModeP b radix P -> forall p q : float, (0 <= p)%R -> (p <= q)%R -> Fcanonic radix b p -> Fcanonic radix b q -> (exists r : float, Fbounded b r /\ r = (q - p)%R :>R) -> forall r : float, Fcanonic radix b r -> (p <= r)%R -> (r <= q)%R -> exists r' : float, Fbounded b r' /\ r' = (r - p)%R :>R. 
invA (n:=n) (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b))); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a nZb) b); auto. apply eqTerm_invTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply mult_invTerm_com_r with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply mult_invTerm_com with (1 := cs); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_invTerm_r; auto. Qed. Hint Resolve divTerm_nZ. Hint Resolve divP_invTerm_r. Theorem divTerm_multTerml : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) a. intros a b nZa nZb. apply divTerm_def with (nZb := nZa); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) (divTerm a nZa) b) a); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) (T1 A1 n) b) a); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) b a); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply div_is_T1; auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_multTerm_r; auto. Qed. Theorem divTerm_multTermr : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) b. intros a b nZa nZb. apply divTerm_def with (nZb := nZb); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) a (divTerm b nZb)) b); auto. apply eqTerm_multTerm_comp with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply divTerm_multTerm_l; auto. Qed. Hint Resolve divTerm_multTermr divTerm_multTerml. Theorem divP_trans : transitive (Term A n) divP. 
apply (Rle_Fexp_eq_Zle radix); auto with arith. rewrite Fabs_correct; auto with arith; rewrite FshiftCorrect; auto with arith; rewrite <- (Fabs_correct radix); auto with float arith. rewrite <- (Zabs_eq (Fnum q)); auto with float zarith. apply (LeR0Fnum radix); auto. apply Rle_trans with (2 := H'1); auto with real. rewrite (Fabs_correct radix); auto with real zarith. unfold Fshift in |- *; simpl in |- *; rewrite Eq1; auto with float. unfold FtoRradix in |- *; apply FshiftCorrect; auto. unfold Fshift in |- *; simpl in |- *. rewrite Eq1; auto with zarith. rewrite inj_abs; auto with zarith; ring. Qed. Theorem Zle_monotony_contra_abs_pow : forall x y z n : Z, (0 < z)%Z -> (Rabs (x * powerRZ z n) <= Rabs (y * powerRZ z n))%R -> (Zabs x <= Zabs y)%Z. intros x y z n Hz O1. apply le_IZR; auto. apply Rmult_le_reg_l with (r := powerRZ z n); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ z n)); auto. repeat rewrite <- Faux.Rabsolu_Zabs. replace (powerRZ z n) with (Rabs (powerRZ z n)). repeat rewrite <- Rabs_mult; auto. apply Rabs_pos_eq; auto with real zarith. Qed. Theorem LessExpBound : forall (b : Fbound) (p q : float), Fbounded b p -> Fbounded b q -> (Fexp q <= Fexp p)%Z -> (0 <= p)%R -> (p <= q)%R -> exists m : Z, Float m (Fexp q) = p :>R /\ Fbounded b (Float m (Fexp q)). intros b p q H' H'0 H'1 H'2 H'3; exists (Fnum p * Zpower_nat radix (Zabs_nat (Fexp p - Fexp q)))%Z. cut (Float (Fnum p * Zpower_nat radix (Zabs_nat (Fexp p - Fexp q))) (Fexp q) = p :>R); [ intros Eq1 | idtac ]. split; auto. repeat split; simpl in |- *; auto with float. apply Zle_lt_trans with (Zabs (Fnum q)); auto with float. apply Zle_monotony_contra_abs_pow with (z := radix) (n := Fexp q); auto with real arith. unfold FtoRradix, FtoR in Eq1; simpl in Eq1; rewrite Eq1; auto with real. change (Rabs p <= Rabs q)%R in |- *. repeat rewrite Rabs_pos_eq; auto with real. apply Rle_trans with (1 := H'2); auto. pattern (Fexp q) at 2 in |- *; replace (Fexp q) with (Fexp p - Zabs_nat (Fexp p - Fexp q))%Z. change (Fshift radix (Zabs_nat (Fexp p - Fexp q)) p = p :>R) in |- *. unfold FtoRradix in |- *; apply FshiftCorrect; auto. rewrite inj_abs; auto with zarith; ring. Qed. Theorem maxFbounded : forall (b : Fbound) (z : Z), (- dExp b <= z)%Z -> Fbounded b (Float (Zpred (Zpos (vNum b))) z). 
x1 x2 | PTree.Node011 x1 r1, PTree.Node011 x2 r2 => beqA x1 x2 && beq2' r1 r2 | PTree.Node100 l1, PTree.Node100 l2 => beq2' l1 l2 | PTree.Node101 l1 r1, PTree.Node101 l2 r2 => beq2' l1 l2 && beq2' r1 r2 | PTree.Node110 l1 x1, PTree.Node110 l2 x2 => beqA x1 x2 && beq2' l1 l2 | PTree.Node111 l1 x1 r1, PTree.Node111 l2 x2 r2 => beqA x1 x2 && beq2' l1 l2 && beq2' r1 r2 | _, _ => false end. Definition beq2 (m1: PTree.t A) (m2 : PTree.t B) : bool := match m1, m2 with | PTree.Empty, PTree.Empty => true | PTree.Nodes m1', PTree.Nodes m2' => beq2' m1' m2' | _, _ => false end. Let beq2_optA (o1: option A) (o2: option B) : bool := match o1, o2 with | None, None => true | Some a1, Some a2 => beqA a1 a2 | _, _ => false end. Lemma beq_correct_bool: forall m1 m2, beq2 m1 m2 = true <-> (forall x, beq2_optA (m1 ! x) (m2 ! x) = true). Proof. Local Transparent PTree.Node. assert (beq_NN: forall l1 o1 r1 l2 o2 r2, PTree.not_trivially_empty l1 o1 r1 -> PTree.not_trivially_empty l2 o2 r2 -> beq2 (PTree.Node l1 o1 r1) (PTree.Node l2 o2 r2) = beq2 l1 l2 && beq2_optA o1 o2 && beq2 r1 r2). { intros. destruct l1, o1, r1; try contradiction; destruct l2, o2, r2; try contradiction; simpl; rewrite ? andb_true_r, ? andb_false_r; auto. rewrite andb_comm; auto. f_equal; rewrite andb_comm; auto. } induction m1 using PTree.tree_ind; [|induction m2 using PTree.tree_ind]. - intros. simpl; split; intros. + destruct m2; try discriminate. simpl; auto. + replace m2 with (@PTree.Empty B); auto. apply PTree.extensionality; intros x. specialize (H x). destruct (m2 ! x); simpl; easy. - split; intros. + destruct (PTree.Node l o r); try discriminate. simpl; auto. + replace (PTree.Node l o r) with (@PTree.Empty A); auto. apply PTree.extensionality; intros x. specialize (H0 x). destruct ((PTree.Node l o r) ! x); simpl in *; easy. - rewrite beq_NN by auto. split; intros. + InvBooleans. rewrite ! PTree.gNode. destruct x. * apply IHm0; auto. * apply IHm1; auto. * auto. + apply andb_true_intro; split; [apply andb_true_intro; split|]. * apply IHm1. intros. specialize (H1 (xO x)); rewrite ! PTree.gNode in H1; auto. * specialize (H1 xH); rewrite ! PTree.gNode in H1; auto. * apply IHm0. intros. specialize (H1 (xI x)); rewrite ! PTree.gNode in H1; auto. Qed. Theorem beq2_correct: forall m1 m2, beq2 m1 m2 = true <-> (forall (x: PTree.elt), match m1 ! x, m2 ! x with | None, None => True | Some y1, Some y2 => beqA y1 y2 = true | _, _ => False end). 
From Huffman Require Export Cover. From Huffman Require Export WeightTree. Section CoverMin. Variable A : Type. Variable f : A -> nat. Definition cover_min (l : list (btree A)) (t1 : btree A) : Prop := cover l t1 /\ (forall t2 : btree A, cover l t2 -> weight_tree f t1 <= weight_tree f t2). Theorem cover_min_one : forall t : btree A, cover_min (t :: nil) t. Proof using. intros t; split; auto. intros t2 H; inversion H; auto. generalize (permutation_length _ _ _ H0); simpl in |- *; intros; discriminate. Qed. Hint Resolve cover_min_one : core. Theorem cover_min_permutation : forall (t : btree A) (l1 l2 : list (btree A)), cover_min l1 t -> permutation l1 l2 -> cover_min l2 t. Proof using. intros t l1 l2 H H0; split. apply cover_permutation with (2 := H0); auto. inversion H; auto. intros t2 H1. assert (cover l1 t2). inversion H; auto. apply cover_permutation with (2 := permutation_sym _ _ _ H0); auto. inversion H; auto. Qed. Theorem cover_min_ex : forall l : list (btree A), l <> nil -> exists t : btree A, cover_min l t. 
: forall (e : env) (u v : term), wf_type e u -> wf_type e v -> decide (le_type e u v)}. Variable the_algos : PTS_algos. Load "Errors". Definition infer_ppal_type (e : env) (m : term) : Set := ({t : term | ppal (typ e m) (le_type e) t} + {err : type_error | expln e err & inf_error m err})%type. Inductive wft_dec (e : env) (t : term) : Set := | Wft_ok : wf_type e t -> wft_dec e t | Wft_fail : forall err : type_error, expln e err -> decl_error (Ax t) err -> ~ (exists s : sort, t = Srt s) -> wft_dec e t. Inductive check_dec (e : env) (m t : term) : Set := | Chk_ok : typ e m t -> check_dec e m t | Chk_fail : forall err : type_error, expln e err -> chk_error m t err -> check_dec e m t. Inductive decl_dec (e : env) (d : decl) : Set := | Dcl_ok : wf (d :: e) -> decl_dec e d | Dcl_fail : forall err : type_error, expln e err -> decl_error d err -> decl_dec e d. Record PTS_TC : Set := { ptc_inf_ppal_type : forall (e : env) (t : term), wf e -> infer_ppal_type e t; ptc_chk_typ : forall (e : env) (t T : term), wf e -> check_dec e t T; ptc_add_typ : forall (e : env) (t : term), wf e -> decl_dec e (Ax t); ptc_add_def : forall (e : env) (t T : term), wf e -> decl_dec e (Def t T); ptc_chk_wk : forall (e : env) (t T : term), wf e -> wf_type e T -> check_dec e t T; ptc_chk_wft : forall (e : env) (t : term), wf e -> wft_dec e t}. Lemma not_topsort : forall t : term, {s : sort | t = Srt s & ~ typed_sort axiom s} + {(forall s : sort, t = Srt s -> typed_sort axiom s)}.simple destruct t; intros; try (right; intros s' eqs'; discriminate eqs'). case (pa_infer_axiom the_algos s); intros. right; intros. injection H; intros; subst s1. inversion_clear s0. exists x; case H0; trivial.left; exists s; trivial. red in |- *; intros. inversion_clear H. elim n with x; trivial. Qed. Section Fixpoint_Body. Hypothesis fix_inference : forall (t : term) (e : env), wf e -> infer_ppal_type e t. Theorem fix_chk_wk : forall (e : env) (t T : term), wf e -> wf_type e T -> check_dec e t T.intros. 
apply segI. apply Hoe... + apply Hsub in Hs. apply SepE2 in Hs... - apply inv_bijection in Hf as Hf'. apply bijection_is_func in Hf as [_ [Hi Hr]]. apply bijection_is_func in Hf' as [Hf' _]. apply ReplAx in Hx as [s [Hs Heq]]. subst x. apply SepE in Hs as [Hs Hlt]. eapply dom_binRel in Hs; [|apply (WoStruct.wo T)]. assert (Hsr: s ∈ ran f) by (rewrite Hr; apply Hs). apply ReplAx. exists (f⁻¹[s]). split. + apply segI. apply Hoe... * eapply ap_ran... * rewrite inv_ran_reduction... + rewrite <- (inv_ran_reduction f Hi s) in Hlt... apply Hoe in Hlt; [|eapply ap_ran|]... assert (f⁻¹[s] ∈ seg t (WoStruct.R S)). { apply SepI... eapply domI... } apply Hsub in H. apply SepE2 in H. rewrite inv_ran_reduction in H... Qed.End EpsilonImageWellDefined.Section OrdDef. Import WoStruct.EpsilonImage. Definition ord := λ S, α S.Definition is_ord := λ α, ∃ S, α = ord S. Notation 𝐎𝐍 := is_ord.Lemma ord_is_ord : ∀ S, ord S ⋵ 𝐎𝐍. Proof. intros. exists S. auto. Qed. Hint Immediate ord_is_ord : core. Lemma ord_well_defined : ∀ S T, S  T ↔ ord S = ord T. Proof with auto. split; intros. - unfold ord, α. apply epsilon_image_well_defined. rewrite <- parent_iso... - apply epsilon_image_well_defined in H. apply parent_iso... Qed.Lemma ordI : ∀ S t, ∀s ∈ A S, (E S)[s] = t → t ∈ ord S. Proof. exact α_intro. Qed.Lemma ordE : ∀ S, ∀t ∈ ord S, ∃s ∈ A S, (E S)[s] = t. Proof. exact α_elim. Qed. Lemma ord_lt_intro : ∀ S T, ∀t ∈ A T, S  Seg t T → ord S ∈ ord T. Proof with eauto. intros S T t Ht Hiso. eapply ordI... apply ord_well_defined in Hiso. rewrite seg_α in Hiso... Qed. Lemma ord_lt_elim : ∀ S T, ord S ∈ ord T → ∃t ∈ A T, S  Seg t T. Proof with eauto. intros. apply ordE in H as [t [Ht H]]. exists t. split... apply ord_well_defined. rewrite seg_α... Qed. Lemma ord_of_ord : ∀ S, ord S = ord (Epsilon S). Proof. intros. apply ord_well_defined. apply iso_epsilon. Qed. Lemma ord_empty : ∀ S, A S =  → ord S =  . Proof. intros. apply e_empty in H. unfold ord, α. rewrite H. apply ran_of_empty. Qed. Lemma ord_woset : ∀α ⋵ 𝐎𝐍, woset α (MemberRel α). Proof. intros α [S H]. subst. apply (wo (Epsilon S)). Qed. Theorem transitive_set_well_ordered_by_epsilon_is_ord : ∀ α, trans α → woset α (MemberRel α) → α ⋵ 𝐎𝐍. 
L)) in |- *. apply incons; auto. apply CombLinear_0; auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (T1 A1 n) (b:=unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0)) nZu) (mults (A:=A) multA (n:=n) (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0)) (a0 :: l))); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (T1 A1 n) (b:=unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0)) nZu) (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM (a0 :: l) c0))) (a0 :: l)); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) (T1 A1 n) (a0 :: l)); auto. rewrite H'2; auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply mults_comp with (1 := cs); auto. apply divTerm_on_eqT with (1 := cs); auto. apply (eqT_sym A n); auto. apply unit_T1; auto. apply unit_nZ with (1 := cs); auto. Qed. Theorem zerop_elim_Cb : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), zerop A A0 eqA n ltM p -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L. intros L p q H' H'0. apply Cb_comp with (L1 := p :: L); auto. simpl in |- *; auto. intros p0 H'1; case H'1; [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; auto. generalize H'; case p; simpl in |- *; auto. intros x; case x; simpl in |- *; auto. intros H'1 H'3; try assumption. change (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec L (pO A n)) in |- *. apply CombLinear_0; auto. intros a l H'1 H'3; elim H'3; auto. apply Cb_id with (1 := cs); auto. Qed. Theorem Cb_compo : forall (p : poly A0 eqA ltM) (L1 : list (poly A0 eqA ltM)), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L1 -> forall L2 : list (poly A0 eqA ltM), (forall q : poly A0 eqA ltM, In q L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2. 
match goal with | [H : exists _, _ |- _] => destruct H end. repeat des. intuition. exists (max x2 x). exists (x3 + x0). exists (x4 + x1). intuition. eapply le_trans. eapply plus_le_compat. eapply H6; trivial. eapply H7; trivial. rewrite mult_plus_distr_r. repeat rewrite plus_assoc. eapply plus_le_compat; trivial. rewrite plus_comm. rewrite plus_assoc. eapply plus_le_compat; trivial. rewrite plus_comm. eapply plus_le_compat; eapply mult_le_compat; intuition. eapply expnat_exp_le; intuition. eapply expnat_exp_le; intuition. Qed.Theorem polynomial_const : forall c, polynomial (fun n => c). intuition. unfold polynomial. exists 0. exists 0. exists c. intuition. Qed.Theorem polynomial_ident : polynomial (fun n => n). unfold polynomial. intuition. exists 1. exists 1. exists 0. intuition. simpl. omega. Qed.Theorem polynomial_mult : forall f1 f2 , polynomial f1 -> polynomial f2 -> polynomial (fun n => f1 n * f2 n). intuition. apply polynomial_nz_equiv in H. apply polynomial_nz_equiv in H0. unfold polynomial, polynomial_nz in *. repeat des. intuition. exists (x + x2). exists (3 * (x3 * x0 * x4 * x1)). exists (x4 * x1). intuition. eapply le_trans. eapply mult_le_compat. eapply H6; intuition. eapply H7; intuition. repeat rewrite mult_plus_distr_l. repeat rewrite mult_plus_distr_r. rewrite plus_assoc. eapply plus_le_compat; trivial. rewrite expnat_plus. simpl. rewrite plus_0_r. repeat rewrite mult_plus_distr_r. rewrite plus_assoc. eapply plus_le_compat. eapply plus_le_compat. rewrite (mult_comm (expnat n x)). repeat rewrite mult_assoc. eapply mult_le_compat; intuition. rewrite mult_comm. rewrite mult_assoc. eapply mult_le_compat; intuition. rewrite <- mult_1_r at 1. rewrite <- mult_1_r at 1. eapply mult_le_compat; intuition. eapply mult_le_compat; intuition. rewrite mult_comm. intuition. destruct (eq_nat_dec n 0); subst. repeat rewrite expnat_0. simpl. repeat rewrite mult_0_r. intuition. trivial. trivial. rewrite (mult_comm (expnat n x)). repeat rewrite mult_assoc. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite mult_comm. eapply mult_le_compat; trivial. rewrite <- mult_1_l at 1. eapply mult_le_compat; trivial. eapply expnat_ge_1. omega. destruct (eq_nat_dec n 0); subst. repeat rewrite expnat_0. simpl. repeat rewrite mult_0_r. intuition. trivial. trivial. rewrite (mult_comm (expnat n x)). repeat rewrite mult_assoc. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite <- mult_assoc. rewrite (mult_comm (expnat n x2)). rewrite mult_assoc. eapply mult_le_compat; trivial. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. eapply expnat_ge_1. omega. Qed. Require Import FCF.Rat. Local Open Scope rat_scope.Definition negligible(f : nat -> Rat) := forall c, exists n, forall x (pf_nz : nz x), x > n -> ~ ((1 / expnat x c) <= f x)%rat. Theorem negligible_eq : forall (f1 f2 : nat -> Rat), negligible f1 -> (forall n, f1 n == f2 n) -> negligible f2. 
Require Import VerdiRaft.Raft.Local Arguments update {_} {_} {_} _ _ _ _ : simpl never.Require Import VerdiRaft.AppendEntriesReplySublogInterface.Require Import VerdiRaft.AppendEntriesRequestReplyCorrespondenceInterface. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.AppendEntriesLeaderInterface.Section AppendEntriesReplySublog. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {aerrci : append_entries_request_reply_correspondence_interface}. Context {rri : raft_refinement_interface}. Context {aeli : append_entries_leader_interface}. Definition lowered_appendEntries_leader (net : @network _ multi_params) := forall p t leaderId prevLogIndex prevLogTerm entries leaderCommit h e, In p (nwPackets net) -> pBody p = AppendEntries t leaderId prevLogIndex prevLogTerm entries leaderCommit -> In e entries -> currentTerm (nwState net h) = t -> type (nwState net h) = Leader -> In e (log (nwState net h)). Theorem lower_appendEntries_leader : forall net, raft_intermediate_reachable net -> lowered_appendEntries_leader net. Proof using aeli rri. intros. apply (lower_prop lowered_appendEntries_leader); auto. intros. find_apply_lem_hyp append_entries_leader_invariant. unfold lowered_appendEntries_leader, appendEntries_leader in *. intros. simpl in *. repeat break_match. simpl in *. do_in_map. subst. simpl in *. match goal with | H : ?nwState ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState h)) in * by (rewrite H; reflexivity); clear H end. eapply_prop_hyp AppendEntries AppendEntries; eauto. Qed. Theorem append_entries_reply_sublog_invariant : forall net, raft_intermediate_reachable net -> append_entries_reply_sublog net. 
match is_ZCst X with true => let x := eval vm_compute in (Z.abs_nat X) in let y := context id [x] in clean_zabs y | false => term end | _ => term end.Ltac clean_zabs_N term := match term with context id [(Z.abs_N ?X)] => match is_ZCst X with true => let x := eval vm_compute in (Z.abs_N X) in let y := context id [x] in clean_zabs_N y | false => term end | _ => term end.Ltac eqterm t1 t2 := match constr:((t1,t2)) with (?X, ?X) => true | _ => false end.Theorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z. intros; apply trans_equal with y; auto. Qed.Open Scope nat_scope.Theorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c. intros; apply f_equal2 with (f := plus); auto. Qed.Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c. intros a b c H H1; case H. apply plus_reg_l with a; auto. Qed.Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m. intros n m p H; unfold ge; apply plus_le_compat_l; auto. Qed.Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c. intros a b c H H1; case H; subst; auto. Qed.Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m. intros n m p H; unfold ge; apply plus_le_reg_l with p; auto. Qed. Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem eq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). intros x y z H; rewrite H; auto. Qed. Theorem eq_le_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y). intros x y z H; rewrite H; auto. Qed. Theorem eq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z). 
(set' q x l) y r | xI q, Node001 r => Node001 (set' q x r) | xI q, Node010 y => Node011 y (set0 q x) | xI q, Node011 y r => Node011 y (set' q x r) | xI q, Node100 l => Node101 l (set0 q x) | xI q, Node101 l r => Node101 l (set' q x r) | xI q, Node110 l y => Node111 l y (set0 q x) | xI q, Node111 l y r => Node111 l y (set' q x r) end. Definition set {A} (p: positive) (x: A) (m: tree A) : tree A := match m with | Empty => Nodes (set0 p x) | Nodes m' => Nodes (set' p x m') end. Fixpoint rem' {A} (p: positive) (m: tree' A) : tree A := match p, m with | xH, Node001 r => Nodes m | xH, Node010 _ => Empty | xH, Node011 _ r => Nodes (Node001 r) | xH, Node100 l => Nodes m | xH, Node101 l r => Nodes m | xH, Node110 l _ => Nodes (Node100 l) | xH, Node111 l _ r => Nodes (Node101 l r) | xO q, Node001 r => Nodes m | xO q, Node010 y => Nodes m | xO q, Node011 y r => Nodes m | xO q, Node100 l => Node (rem' q l) None Empty | xO q, Node101 l r => Node (rem' q l) None (Nodes r) | xO q, Node110 l y => Node (rem' q l) (Some y) Empty | xO q, Node111 l y r => Node (rem' q l) (Some y) (Nodes r) | xI q, Node001 r => Node Empty None (rem' q r) | xI q, Node010 y => Nodes m | xI q, Node011 y r => Node Empty (Some y) (rem' q r) | xI q, Node100 l => Nodes m | xI q, Node101 l r => Node (Nodes l) None (rem' q r) | xI q, Node110 l y => Nodes m | xI q, Node111 l y r => Node (Nodes l) (Some y) (rem' q r) end. Definition remove' := Eval cbv [rem' Node] in @rem'. Definition remove {A} (p: positive) (m: tree A) : tree A := match m with | Empty => Empty | Nodes m' => remove' p m' end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. 
(S y0))) (oppZ y)). rewrite (opp_succZ y). rewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)). rewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)). elim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity. Qed. Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).intros; elim x.reflexivity.simple induction n.simpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).intros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0). rewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y). elim (pred_addZ_l (multZ (pos n0) (predZ y)) y). elim (addZ_commutativity y (multZ (pos n0) y)). elim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))). elim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y). rewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))). reflexivity.simple induction n.simpl in |- *. replace (pos 0) with IZ; auto. rewrite (add_IZ_succZ (oppZ y)). exact (opp_predZ y).intros n0 H; do 2 rewrite (tech_mult_negZ n0). rewrite H; rewrite (opp_predZ y). elim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)). elim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))). elim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))). rewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)). rewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))). elim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))). reflexivity. Qed. Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.simple destruct x.reflexivity.simple induction n.reflexivity.intros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.simple induction n.reflexivity.intros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity. Qed. Lemma mult_IZ : forall x : Z, multZ x IZ = x.simple destruct x.reflexivity.simple induction n.reflexivity.intros y H; rewrite (tech_mult_posZ y IZ); rewrite H. rewrite (add_IZ_succZ (pos y)); reflexivity.simple induction n.reflexivity.intros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *. rewrite (add_mIZ_predZ (neg y)); reflexivity. Qed. Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.simple destruct x.reflexivity.simple induction n.reflexivity.intros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. rewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.simple induction n.reflexivity.intros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H. elim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I). rewrite (add_mIZ_predZ (neg y)); reflexivity. Qed. Theorem multZ_commutativity : commutativity Z multZ.unfold commutativity in |- *; intros; elim x.rewrite (mult_OZ y); unfold multZ in |- *; reflexivity.simple induction n.simpl in |- *; symmetry in |- *; exact (mult_IZ y).intros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. 
left_id : forall (A B : Type) (x : A) (f : A -> m B), mequiv (bind (ret x) f) (f x); right_id : forall (A : Type) (x : m A), mequiv (bind x ret) x; bind_assoc : forall (A B C : Type) (n : m A) (f : A -> m B) (g : B -> m C), mequiv (bind (bind n f) g) (bind n (fun x => bind (f x) g)); equivalence : forall T, Equivalence (@mequiv T); congruence : forall {A B : Type} n (f g : A -> m B), (forall x, mequiv (f x) (g x)) -> mequiv (bind n f) (bind n g); }.Section MonadProperties. Generalizable All Variables. Context `{Monad m mequiv ret bind}. Infix "=~" := mequiv (at level 60, no associativity). Infix ">>=" := bind (at level 50, left associativity). Instance mequivEquivlence : forall T, Equivalence (@mequiv T). Proof. apply equivalence. Qed. Definition fmap {A B : Type} (f : A -> B) (n : m A) : m B := n >>= (@ret B) ∘ f. Definition join {A : Type} (n : m (m A)) : m A := n >>= id. Ltac revealer := unfold join, fmap, compose, id; intros. Ltac f_equal := apply congruence; intros. Theorem fmap_compose_join_eq_bind : forall (A B : Type) (n : m A) (f : A -> m B), n >>= f =~ join (fmap f n). Proof. revealer. rewrite bind_assoc. f_equal. rewrite left_id. reflexivity. Qed. Theorem fmap_id : forall (A : Type) (n : m A), fmap id n =~ n. Proof. revealer. rewrite right_id. reflexivity. Qed. Theorem fmap_associativity : forall (A B C : Type) (f : A -> B) (g : B -> C) (n : m A), fmap (g ∘ f) n =~ fmap g (fmap f n). Proof. revealer. rewrite bind_assoc. f_equal. rewrite left_id. reflexivity. Qed. Theorem return_property : forall (A B : Type) (f : A -> B) (x : A), ret (f x) =~ fmap f (ret x). Proof. revealer. rewrite left_id. reflexivity. Qed. Theorem join_property1 : forall (A : Type) (x : m (m (m A))), join (fmap join x) =~ join (join x). Proof. intros. rewrite <- fmap_compose_join_eq_bind. revealer. rewrite bind_assoc. reflexivity. Qed. Theorem join_property2 : forall (A : Type) (x : m A), join (fmap (@ret A) x) =~ x. Proof. intros. rewrite <- fmap_compose_join_eq_bind. rewrite right_id. reflexivity. Qed. Theorem join_property3 : forall (A : Type) (x : m A), join (ret x) =~ x. 
k_Out) (h iv k_In) in GHMAC_2K k ls = GNMAC k' ls. intuition. unfold GHMAC_2K, HMAC_spec.GHMAC_2K, GNMAC, HMAC_spec.GNMAC, b, HMAC_spec.b. remember (splitVector (c + p) (c + p) k) as z. destruct z. rewrite splitVector_append. unfold app_fpad, hash_words. simpl. trivial. Qed. Definition HMAC_RKA_A : OracleComp (Bvector b * Bvector c) (Bvector c) bool := k_Out <--$ OC_Query _ (opad, iv); k_In <--$ OC_Query _ (ipad, iv); [b, _] <--$2 $ A _ _ (f_oracle GNMAC _ (Vector.append k_Out k_In)) tt; $ ret b. Local Opaque evalDist. Theorem A_HMAC_RKA_equiv : Pr[A_HMAC] == Pr[RKA_G0 _ (Rnd b) (dual_f h) (BVxor b) HMAC_RKA_A]. unfold A_HMAC, RKA_G0, GHMAC, HMAC_RKA_A, GNMAC, HMAC_spec.GHMAC. comp_skip. simpl. repeat ( inline_first; comp_simp). comp_skip. eapply comp_spec_eq_impl_eq. eapply comp_spec_consequence. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => a = b)). trivial. intuition. unfold f_oracle. eapply comp_spec_ret; intuition. simpl. specialize (GHMAC_2K_GNMAC_equiv (Vector.append (x xor opad) (x xor ipad)) a0); intuition. rewrite splitVector_append in H1. unfold dual_f. eapply eq_trans. eapply H1. unfold GNMAC. f_equal. f_equal. f_equal. eapply BVxor_comm. f_equal. eapply BVxor_comm. intuition. destruct b2; simpl in *; subst; intuition. comp_simp. simpl. inline_first. comp_simp. intuition. Qed. Definition A_NMAC_G1 := x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_0 := [x1, x2] <-$2 ( x <-$ {0, 1}^(c + c); ret (splitVector c c x)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_1 := [x1, x2] <-$2 ( x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; ret (x1, x2)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Theorem A_NMAC_G1_0_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1_0]. unfold A_NMAC, A_NMAC_G1_0. inline_first. comp_skip. remember (splitVector c c x) as z. comp_simp. erewrite append_splitVector. reflexivity. trivial. Qed. Theorem A_NMAC_G1_0_1_equiv : Pr[A_NMAC_G1_0] == Pr[A_NMAC_G1_1]. unfold A_NMAC_G1_0, A_NMAC_G1_1. comp_skip. eapply Rnd_split_equiv. reflexivity. Qed. Theorem A_NMAC_G1_1_equiv : Pr[A_NMAC_G1_1] == Pr[A_NMAC_G1]. unfold A_NMAC_G1_1, A_NMAC_G1. inline_first. comp_skip. inline_first. comp_skip. Qed. Theorem A_NMAC_G1_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1]. rewrite A_NMAC_G1_0_equiv. rewrite A_NMAC_G1_0_1_equiv. apply A_NMAC_G1_1_equiv. Qed. Theorem xor_1_1 : forall (n : nat)(x y z : Bvector n), BVxor _ y x = BVxor _ z x -> y = z. intuition. rewrite <- BVxor_id_r at 1. rewrite <- (BVxor_same_id x). rewrite <- BVxor_assoc. rewrite H. rewrite BVxor_assoc. rewrite (BVxor_same_id x). rewrite BVxor_id_r. trivial. Qed. Theorem A_NMAC_RKA_equiv : Pr[A_NMAC] == Pr[RKA_G1 _ _ _ (Rnd b) (Rnd c) (BVxor b) HMAC_RKA_A]. 
auto with real. rewrite (pow_RN_plus e (BinPos.nat_of_P m1 - BinPos.nat_of_P n1) (BinPos.nat_of_P n1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. apply lt_le_weak. change (BinPos.nat_of_P m1 > BinPos.nat_of_P n1) in |- *. apply Pnat.nat_of_P_gt_Gt_compare_morphism; auto. intros n1 m1. rewrite Z.pos_sub_spec; unfold Pos.compare. CaseEq (Pcompare n1 m1 Datatypes.Eq); simpl in |- *; auto with real. intros H' H'0; rewrite BinPos.Pcompare_Eq_eq with (1 := H'); auto with real. intros H' H'0; rewrite (Pnat.nat_of_P_minus_morphism m1 n1); auto with real. rewrite (pow_RN_plus e (BinPos.nat_of_P m1 - BinPos.nat_of_P n1) (BinPos.nat_of_P n1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. rewrite Rinv_mult_distr; auto with real. apply lt_le_weak. apply Pnat.nat_of_P_lt_Lt_compare_morphism; auto. apply BinPos.ZC2; auto. intros H' H'0; rewrite (Pnat.nat_of_P_minus_morphism n1 m1); auto with real. rewrite (pow_RN_plus e (BinPos.nat_of_P n1 - BinPos.nat_of_P m1) (BinPos.nat_of_P m1)); auto with real. rewrite plus_comm; rewrite le_plus_minus_r; auto with real. apply lt_le_weak. change (BinPos.nat_of_P n1 > BinPos.nat_of_P m1) in |- *. apply Pnat.nat_of_P_gt_Gt_compare_morphism; auto. intros n1 m1; rewrite Pnat.nat_of_P_plus_morphism; auto with real. intros H'; rewrite pow_add; auto with real. apply Rinv_mult_distr; auto. apply pow_NR0; auto. apply pow_NR0; auto. Qed. Hint Resolve powerRZ_O powerRZ_1 powerRZ_NOR powerRZ_add: real. Theorem powerRZ_Zopp : forall (e : R) (z : BinInt.Z), e <> 0%R -> powerRZ e (- z) = (/ powerRZ e z)%R. intros e z H; case z; simpl in |- *; auto with real. intros p; apply sym_eq; apply Rinv_involutive. apply pow_nonzero; auto. Qed.Theorem powerRZ_Zs : forall (e : R) (n : BinInt.Z), e <> 0%R -> powerRZ e (Zsucc n) = (e * powerRZ e n)%R. intros e n H'0. replace (Zsucc n) with (n + Zsucc 0)%Z. rewrite powerRZ_add; auto. rewrite powerRZ_1. rewrite Rmult_comm; auto. auto with zarith. Qed. Theorem Zpower_nat_powerRZ : forall (n : BinInt.Z) (m : nat), IZR (Zpower_nat n m) = powerRZ (IZR n) (Z_of_nat m). intros n m; elim m; simpl in |- *; auto with real. intros m1 H'; rewrite Pnat.nat_of_P_o_P_of_succ_nat_eq_succ; simpl in |- *. replace (Zpower_nat n (S m1)) with (n * Zpower_nat n m1)%Z. rewrite Rmult_IZR; auto with real. rewrite H'; simpl in |- *. case m1; simpl in |- *; auto with real. intros m2; rewrite Pnat.nat_of_P_o_P_of_succ_nat_eq_succ; auto. unfold Zpower_nat in |- *; auto. Qed. Theorem powerRZ_lt : forall (e : R) (z : BinInt.Z), (0 < e)%R -> (0 < powerRZ e z)%R. intros e z; case z; simpl in |- *; auto with real. Qed. Hint Resolve powerRZ_lt: real. Theorem powerRZ_le : forall (e : R) (z : BinInt.Z), (0 < e)%R -> (0 <= powerRZ e z)%R. 
(set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. intros. apply PTree.gro. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply grs. apply gro; auto. Qed. Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq. Theorem beq_sound: forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A), beq eqA t1 t2 = true -> forall (x: elt), match get x t1, get x t2 with | None, None => True | Some y1, Some y2 => eqA y1 y2 = true | _, _ => False end. 
= 0) 0. Proof conj sum_0_neg (fun x H => eq_sym (sum_neg_0 x H)). Definition prod_is_id_l := Monoid.is_id_l E prod. Definition prod_is_id_r := Monoid.is_id_r E prod. Definition prod_is_id := Monoid.is_id E prod. Definition prod_monoid := Monoid.monoid E 1 {#} prod_is_assoc prod_id_l prod_id_r. Theorem prod_id : prod_is_id 1. Proof Monoid.op_id prod_monoid. Theorem prod_id_l_uniq : forall x : E, (Monoid.is_id_l E prod x) -> x = 1. Proof Monoid.op_id_l_uniq prod_monoid. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E prod x) -> x = 1. Proof Monoid.op_id_r_uniq prod_monoid. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E prod x) -> x = 1. Proof Monoid.op_id_uniq prod_monoid. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. Proof Monoid.op_intro_l prod_monoid. Theorem prod_intro_r : forall x y z : E, x = y -> x # z = y # z. Proof Monoid.op_intro_r prod_monoid. Definition prod_is_inv_l := Monoid.op_is_inv_l prod_monoid. Definition prod_is_inv_r := Monoid.op_is_inv_r prod_monoid. Definition prod_is_inv := Monoid.op_is_inv prod_monoid. Definition prod_has_inv_l := Monoid.has_inv_l prod_monoid. Definition prod_has_inv_r := Monoid.has_inv_r prod_monoid. Definition prod_has_inv := Monoid.has_inv prod_monoid. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. Proof Monoid.op_inv_l_r_eq prod_monoid. Theorem prod_inv_sym : forall x y : E, prod_is_inv x y <-> prod_is_inv y x. Proof Monoid.op_inv_sym prod_monoid. Theorem prod_cancel_l : forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y. Proof Monoid.op_cancel_l prod_monoid. Theorem prod_cancel_r : forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y. Proof Monoid.op_cancel_r prod_monoid. Theorem prod_inv_l_uniq : forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Monoid.op_inv_l_uniq prod_monoid. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Monoid.op_inv_r_uniq prod_monoid. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Monoid.op_inv_uniq prod_monoid. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Monoid.op_has_inv_l_0 prod_monoid. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Monoid.op_has_inv_r_0 prod_monoid. Theorem prod_has_inv_1 : prod_has_inv 1. 
Require Export ClosestProp. Section F2. Variable b : Fbound. Variable precision : nat. Let radix := 2%Z. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R. Theorem TwoMoreThanOne : (1 < radix)%Z. 
-> l = xs ++ y :: zs -> l = xs' ++ y' :: zs' -> f y = f y' -> xs = xs'. Proof using. induction xs; simpl; intros; destruct xs'. - auto. - subst. simpl in *. find_inversion. invc H. exfalso. rewrite map_app in *. simpl in *. repeat find_rewrite. intuition. - subst. simpl in *. find_inversion. invc H. exfalso. rewrite map_app in *. simpl in *. repeat find_rewrite. intuition. - subst. simpl in *. find_injection. intros. subst. f_equal. eapply IHxs; eauto. solve_by_inversion. Qed. Lemma filter_NoDup : forall p (l : list A), NoDup l -> NoDup (filter p l). Proof using. induction l; intros. - auto. - invc_NoDup. simpl. break_if; auto. constructor; auto. intro. apply filter_In in H. intuition. Qed. Lemma NoDup_map_filter : forall (f : A -> B) g l, NoDup (map f l) -> NoDup (map f (filter g l)). Proof using. intros. induction l; simpl in *. - constructor. - invc_NoDup. concludes. break_if; simpl in *; auto. constructor; auto. intro. do_in_map. find_apply_lem_hyp filter_In. intuition. match goal with | H : _ -> False |- False => apply H end. apply in_map_iff. eauto. Qed. Lemma filter_true_id : forall (f : A -> bool) xs, (forall x, In x xs -> f x = true) -> filter f xs = xs. Proof using. induction xs; intros. - auto. - simpl. now rewrite H, IHxs by intuition. Qed. Lemma map_of_map : forall (f : A -> B) (g : B -> C) xs, map g (map f xs) = map (fun x => g (f x)) xs. Proof using. induction xs; simpl; auto using f_equal2. Qed. Lemma filter_except_one : forall (f g : A -> bool) x xs, (forall y, In y xs -> x <> y -> f y = g y) -> g x = false -> filter f (remove A_eq_dec x xs) = filter g xs. Proof using. induction xs; intros. - auto. - simpl. break_if. + subst. repeat find_rewrite. eauto with *. + simpl. rewrite H by auto with *. break_if; eauto using f_equal2 with *. Qed. Lemma flat_map_nil : forall (f : A -> list B) l, flat_map f l = [] -> l = [] \/ (forall x, In x l -> f x = []). Proof using. induction l; intros. - intuition. - right. simpl in *. apply app_eq_nil in H. intuition; subst; simpl in *; intuition. Qed. Theorem NoDup_Permutation_NoDup : forall (l l' : list A), NoDup l -> Permutation l l' -> NoDup l'. 
inv H. specialize (IHSearchTree'1 _ H5). clear H5. specialize (IHSearchTree'2 _ H6). clear H6. unfold slow_elements; fold slow_elements. subst. extensionality i. destruct (In_decidable (slow_elements l) i) as [[w H] | Hleft]. rewrite list2map_app_left with (v:=w); auto. pose proof (slow_elements_range _ _ _ _ _ H0_ H). unfold combine, t_update. bdestruct (k=?i); [ omega | ]. bdestruct (i<?k); [ | omega]. auto. Admitted. Theorem empty_tree_SearchTree: SearchTree empty_tree. Proof. clear default. Admitted. Remark omega_on_keys: forall i j : key, ~ (i > j) -> ~ (i < j) -> i=j. Proof. intros. try omega. Qed. Theorem insert_SearchTree: forall k v t, SearchTree t -> SearchTree (insert k v t). Proof. clear default. Admitted.Check lookup_relate. Check elements_relate. Lemma lookup_relate': forall (k : key) (t : tree) (cts : total_map V), SearchTree t -> Abs t cts -> lookup k t = cts k.Proof. intros. apply lookup_relate. apply H0. Qed.Theorem insert_relate': forall k v t cts, SearchTree t -> Abs t cts -> Abs (insert k v t) (t_update cts k v). Proof. intros. apply insert_relate; auto. Qed.Print Abs.Remark abstraction_of_bogus_tree: forall v2 v3, Abs (T (T E 3 v3 E) 2 v2 E) (t_update (t_empty default) 2 v2). Proof. intros. evar (m: total_map V). replace (t_update (t_empty default) 2 v2) with m; subst m. repeat constructor. extensionality x. unfold t_update, combine, t_empty. bdestruct (2 =? x). auto. bdestruct (x <? 2). bdestruct (3 =? x).omega. bdestruct (x <? 3). auto. auto. auto. Qed.Lemma can_relate: forall t, SearchTree t -> exists cts, Abs t cts. Proof. Admitted.Lemma unrealistically_strong_can_relate: forall t, exists cts, Abs t cts. Proof. Admitted.Definition AbsX (t: tree) (m: total_map V) : Prop := list2map (elements t) = m.Theorem elements_relateX: forall t cts, SearchTree t -> AbsX t cts -> list2map (elements t) = cts. Proof. intros. apply H0. Qed.Theorem naive_lookup_relateX: forall k t cts , AbsX t cts -> lookup k t = cts k. Abort. Theorem not_naive_lookup_relateX: forall v, default <> v -> ~ (forall k t cts , AbsX t cts -> lookup k t = cts k). Proof. unfold AbsX. intros v H. intros H0. pose (bogus := T (T E 3 v E) 2 v E). pose (m := t_update (t_update (t_empty default) 2 v) 3 v). assert (list2map (elements bogus) = m). reflexivity. assert (~ lookup 3 bogus = m 3). { unfold bogus, m, t_update, t_empty. simpl. apply H. }apply H2. apply H0. apply H1. Qed. Theorem lookup_relateX: forall k t cts , SearchTree t -> AbsX t cts -> lookup k t = cts k. 
u rm cs reachO (s: Substep imp o u rm cs) := match rm return Substep imp o u rm cs -> exists uSpec, Substep spec (theta o) uSpec (xformUnitAnnotZero o rm) (liftToMap1 p cs) /\ M.union uSpec (theta o) = theta (M.union u o) with | Rle (Some rule) => fun s => substepRuleMap reachO s | Meth (Some meth) => fun s => substepMethMapZero s | Rle None => fun s => ruleMapEmptyZero s | Meth None => fun s => methMapEmptyZero s end s. Definition xformLabelZero o l := match l with | {| annot := a; defs := dfs; calls := clls |} => {| annot := match a with | Some (Some r) => Some (ruleMap o r) | Some None => Some None | None => None end; defs := liftToMap1 p dfs; calls := liftToMap1 p clls |} end. Theorem stepMapZero o (reachO: reachable o imp) u l (s: Step imp o u l): exists uSpec, Step spec (theta o) uSpec (xformLabelZero o l) /\ M.union uSpec (theta o) = theta (M.union u o). Proof. apply step_zero in s; auto; dest. destruct l; simpl in *. pose proof (substepMapZero reachO H0); dest. exists x. apply substepZero_imp_step in H1; auto. repeat (try constructor; auto). rewrite H. rewrite liftToMap1_empty. unfold xformUnitAnnotZero, getLabel; simpl in *. destruct annot; auto. destruct o0; auto. Qed. Lemma rleEmptyZero m o u cs: Substep m o u (Rle None) cs -> u = M.empty _ /\ cs = M.empty _. Proof. clear; intros. inversion H; intuition. Qed. Lemma methEmptyZero m o u cs: Substep m o u (Meth None) cs -> u = M.empty _ /\ cs = M.empty _. Proof. clear; intros. inversion H; intuition. Qed. Theorem decompositionZero': forall s sig, Behavior imp s sig -> exists sigSpec, Behavior spec (theta s) sigSpec /\ equivalentLabelSeq (liftToMap1 p) sig sigSpec. Proof. intros. dependent induction H. dependent induction HMultistepBeh; subst. - exists nil; rewrite thetaInit; repeat constructor. - specialize (IHHMultistepBeh thetaInit defsSpecZero substepRuleMap eq_refl). assert(reachO: reachable n imp) by (eexists; econstructor; eauto). pose proof (stepMapZero reachO HStep) as [uSpec [stepSpec upd]]. destruct IHHMultistepBeh as [sigSpec [behSpec eqv]]. inversion behSpec; subst. pose proof (BehaviorIntro (Multi HMultistepBeh0 stepSpec)) as sth. rewrite upd in sth. exists (xformLabelZero n l :: sigSpec). constructor. + intuition. + constructor. * unfold equivalentLabel, xformLabelZero; simpl. destruct l; destruct annot; simpl; intuition. destruct o; simpl; intuition. * intuition. Qed. Theorem decompositionZero: traceRefines (liftToMap1 p) imp spec. 
aa & bb & cc & Hm). subst m. apply list_has_dup_app_left. constructor 1; apply in_or_app; right. constructor 1; reflexivity. Qed. Definition list_has_dup_equiv := list_has_dup_eq_duplicates. Fact repeat_choice_two x m : Forall (eq x) m -> (exists m', m = x::x::m') \/ m = nil \/ m = x::nil. Proof. intros H. destruct m as [ | a [ | b m ] ]; auto. + inversion H; subst; auto. + rewrite Forall_forall in H. rewrite <- (H a), <- (H b); simpl; auto; left; exists m; auto. Qed. Fact incl_right_cons_incl_or_lhd_or_perm m x l : incl m (x::l) -> incl m l \/ list_has_dup m \/ exists m', m ~p x::m' /\ incl m' l. Proof. intros H. apply incl_cons_rinv in H. destruct H as (m1 & m2 & H1 & H2 & H3). destruct (repeat_choice_two H2) as [ (?&?) | [|] ]; subst m1; simpl in H1; clear H2. + right; left; apply perm_list_has_dup with (1 := Permutation_sym H1), in_list_hd0; left; auto. + left; revert H1 H3; apply perm_incl_left. + firstorder. Qed. Fact incl_left_right_php x l y m : incl (y::m) (x::l) -> list_has_dup (y::m) \/ x = y /\ incl m l \/ In y l /\ incl m l \/ In y l /\ exists m', m ~p x::m' /\ incl m' l. Proof. intros H; apply incl_left_right_cons in H. destruct H as [ (? & ?) | [ (? & ?) | (H1 & H2) ] ]; subst; auto. + left; apply in_list_hd0; auto. + apply incl_right_cons_incl_or_lhd_or_perm in H2; firstorder. left; apply in_list_hd1; auto. Qed. Lemma length_le_and_incl_implies_dup_or_perm l m : length l <= length m -> incl m l -> list_has_dup m \/ m ~p l. Proof. revert m; induction l as [ | x l IHl ]; intros m; simpl; intros H1 H2; auto. + destruct m as [ | y ]; auto; destruct (H2 y); simpl; auto. + destruct incl_right_cons_incl_or_lhd_or_perm with (1 := H2) as [ H3 | [ H3 | (m' & H3 & H4) ] ]; auto. * destruct IHl with (2 := H3) as [ | H ]; try lia; auto. apply Permutation_length in H; lia. * destruct IHl with (2 := H4) as [ H | H ]; try (simpl; lia). - apply Permutation_length in H3; simpl in H3; lia. - left; apply perm_list_has_dup with (1 := Permutation_sym H3). constructor 2; auto. - right; apply perm_trans with (1 := H3); auto. Qed. Theorem finite_php_dup l m : length l < length m -> incl m l -> list_has_dup m. 
(W k). pose aG := regular_repr algCF G. have [Gy | notGy] := boolP (y \in G); last first. rewrite cfun0 // mul0r big1 ?mulr0 // => x Gx. by rewrite cfun0 ?groupMl ?mul0r. transitivity (('chi_i).[e j *m aG y]%CF / 'chi_j 1%g). rewrite [e j]Wedderburn_id_expansion -scalemxAl xcfunZr -mulrA; congr (_ * _). rewrite mulmx_suml raddf_sum big_distrl; apply: eq_bigr => x Gx /=. rewrite -scalemxAl xcfunZr -repr_mxM // xcfunG ?groupM // mulrAC mulrC. by congr (_ * _); rewrite mulrC mulKf ?irr1_neq0. rewrite mulr_natl mulrb; have [<-{j} | neq_ij] := eqVneq. by congr (_ / _); rewrite xcfun_mul_id ?envelop_mx_id ?xcfunG. rewrite (xcfun_annihilate neq_ij) ?mul0r //. case/andP: (Wedderburn_ideal (W j)) => _; apply: submx_trans. by rewrite mem_mulsmx ?Wedderburn_id_mem ?envelop_mx_id. Qed. Corollary first_orthogonality_relation (i j : Iirr G) : #|G|%:R^-1 * (\sum_(x in G) 'chi_i x * 'chi_j x^-1%g) = (i == j)%:R. Proof. have:= generalized_orthogonality_relation 1 i j. rewrite mulrA mulfK ?irr1_neq0 // => <-; congr (_ * _). by apply: eq_bigr => x; rewrite mulg1. Qed.Definition irr_class i := enum_val (cast_ord (NirrE G) i). Definition class_Iirr xG := cast_ord (esym (NirrE G)) (enum_rank_in (classes1 G) xG).Local Notation c := irr_class. Local Notation g i := (repr (c i)). Local Notation iC := class_Iirr.Definition character_table := \matrix_(i, j) 'chi[G]_i (g j). Local Notation X := character_table.Lemma irr_classP i : c i \in classes G. Proof. exact: enum_valP. Qed.Lemma repr_irr_classK i : g i ^: G = c i. Proof. by case/repr_classesP: (irr_classP i). Qed.Lemma irr_classK : cancel c iC. Proof. by move=> i; rewrite /iC enum_valK_in cast_ordK. Qed.Lemma class_IirrK : {in classes G, cancel iC c}. Proof. by move=> xG GxG; rewrite /c cast_ordKV enum_rankK_in. Qed.Lemma reindex_irr_class R idx (op : @Monoid.com_law R idx) F : \big[op/idx]_(xG in classes G) F xG = \big[op/idx]_i F (c i). Proof. rewrite (reindex c); first by apply: eq_bigl => i; apply: enum_valP. by exists iC; [apply: in1W; apply: irr_classK | apply: class_IirrK]. Qed.Let X' := \matrix_(i, j) (#|'C_G[g i]|%:R^-1 * ('chi[G]_j (g i))^*). Let XX'_1: X *m X' = 1%:M. Proof. apply/matrixP=> i j; rewrite !mxE -first_orthogonality_relation mulr_sumr. rewrite sum_by_classes => [|u v Gu Gv]; last by rewrite -conjVg !cfunJ. rewrite reindex_irr_class /=; apply/esym/eq_bigr=> k _. rewrite !mxE irr_inv // -/(g k) -divg_index -indexgI /=. rewrite (char0_natf_div Cchar) ?dvdn_indexg // index_cent1 invfM invrK. by rewrite repr_irr_classK mulrCA mulrA mulrCA. Qed.Lemma character_table_unit : X \in unitmx. Proof. by case/mulmx1_unit: XX'_1. Qed. Let uX := character_table_unit. Theorem second_orthogonality_relation x y : y \in G -> \sum_i 'chi[G]_i x * ('chi_i y)^* = #|'C_G[x]|%:R *+ (x \in y ^: G). 
Set Warnings "-notation-overridden,-parsing". Require Export ProofObjects. Check nat_ind. Theorem mult_0_r' : forall n:nat, n * 0 = 0. 
exact (- ∫ g b (a_min_b))%CR. assert (b_min_a:Qpos). exists (b-a). admit. exact ( ∫ g a (b_min_a))%CR. Defined. Definition Picard_raw:=fun t:Q => integral (f, 0, t).Lemma Picard_uc: (is_UniformlyContinuousFunction Picard_raw (fun e => e)%Qpos). admit. Qed. Definition Picard:=(Cbind_slow (Build_UniformlyContinuousFunction Picard_uc)). End Picard_op.Section Banach_it. Context {X} `(F:X-->X). Fixpoint Banach_seq (n : nat) : X --> X := match n with | O => F | S m => F ∘ (Banach_seq m) end.Variable f:CR-->CR. Check Picard. Fixpoint Picard_seq (n : nat) : Q --> CR := match n with | O => f ∘ Cunit | S m => (Picard (Picard_seq m) )∘ Cunit end. End Banach_it.Section Picard. Variable L:Qpos. Variable c:Qpos. Hypothesis c_unit:1-c>0. Program Definition oneminc:=(1-c):Qpos. Next Obligation. admit. Defined. Variables a K:Q. Hypothesis aL_le_c:(a*L<c). Require Import Qabs. Require Export CRabs. Require Import Interval.Variable v: (Q*Q) -->CR.Hypothesis Lipschitz: forall x, -a<=x -> x<=a -> forall y, -K<=y -> y<=K -> forall y':Q, -K<=y' -> y <=K -> ((CRabs ((v (x, y)) - (v (x, y'))))<= 'L* 'Qabs (y-y'))%CR.Section BanachFPT. Context (X: MetricSpace). Context (d:X->X->CR). Variable metric_function: forall e x y, ball e x y <-> ((d x y) <='e)%CR. Class Contraction `(F:X-->X)`(c:Qpos):= contraction: c<1-> forall x x', ((d x x') <= 'c*(d (F x) (F x')))%CR. Context {F}`{conF: Contraction F}. Require Export CRGeometricSum.Lemma bla: forall n m:nat, forall x:X, (ball (c^m) (@Banach_seq _ F n x) (@Banach_seq _ F (n+m) x)). Admitted.Lemma bla2: forall n:nat, forall x:X, (ball (Qpos_inv oneminc) x (@Banach_seq _ F n x)). Admitted.Lemma bla3: forall n m:nat, forall x:X, forall e, (ball e x (F x)) -> (ball (c^m*(Qpos_inv oneminc)*e) (@Banach_seq _ F n x) (@Banach_seq _ F m x)). Admitted.Variable x:X. Definition DiffSeries:=fun n => d (@Banach_seq _ F n x) (@Banach_seq _ F (S n) x). Require Import StreamMemo. Definition DiffStream:=(memo_list _ DiffSeries). Require Import CoqStreams. Definition GeometricSeriesCR (c:CR):= (ForAll (fun s:Stream CR => (CRabs ((hd (tl s))) <= c*(CRabs(hd s)))%CR)).Lemma GeomDiff:GeometricSeriesCR ('c)%CR DiffStream. unfold GeometricSeriesCR. unfold DiffStream. unfold memo_list. unfold memo_make. simpl. admit. Qed.Lemma BanachCauchy: forall ϵ:Qpos, exists N, forall n m:nat , n >=N-> m>= N -> (ball ϵ (@Banach_seq _ F n x) (@Banach_seq _ F m x)). intros. set ceil:=(Qabs (approximate (d (@Banach_seq _ F 0 x) (@Banach_seq _ F 1 x)) (Qpos2QposInf (1#1))))+1:Qpos.exists ( /((ϵ*oneminc/ceil)(oneminc))). End BanachFPT.Section BanachFPT2. Context {X} (F:Complete X--> Complete X) `{conF: Contraction (Complete X) F}. Theorem BanachFPT : exists x, (F x) =x. eexists y. Admitted. Theorem PicardFPT: exists f, (Picard f) = (f ∘ Cunit). 
[Bx [By HB]]. cbn in *. transitivity ( existT (fun y : T => {x : P y | Q y x}) Bx match H in _ = u return {x : P u | Q u x} with eq_refl => (exist (Q Ax) Ay HA) end ). { destruct H; trivial. } { match goal with [|- existT _ ?A ?B = existT _ ?A ?B'] => assert (B = B') as ->;trivial end. apply sig_proof_irrelevance; trivial. } Qed. Local Hint Extern 1 => match goal with [x : {_ : _ & {_ : _ | _}} |- _] => let H := fresh "H" in let x1 := fresh x "1" in let x2 := fresh x "2" in destruct x as [x1 [x2 H]] end : core. Local Hint Extern 1 => match goal with [x : Monic_Image_of |- _] => let H := fresh "H" in let x1 := fresh x "1" in let x2 := fresh x "2" in destruct x as [x1 [x2 H]] end : core. Local Hint Extern 1 => match goal with [|- ?A = ?B] => assert (H : (projT1 A) = (projT1 B)); [| apply (sigT_sig_proof_irrelevance _ _ H); destruct H ] end : core. Program Definition Monic_PreSheaf_Image_of : PreSheaf C := {| FO := fun x => @Monic_Image_of _ _ (Trans (mono_morphism N) x); FA := fun c c' h x => existT _ (G _a h (projT1 x))%morphism (exist _ (F _a h (proj1_sig (projT2 x)))%morphism _) |}. Program Definition Monic_PreSheaf_Morph_From_Monic_PreSheaf_Image_of_forward : (Monic_PreSheaf_Image_of --> G)%nattrans := {| Trans := fun x => @Monic_From_Image_forward _ _ (Trans (mono_morphism N) x) |}. Program Definition Monic_PreSheaf_From_Monic_PreSheaf_Image_of_back : (Monic_PreSheaf_Image_of --> F)%nattrans := {| Trans := fun x => @Monic_From_Image_back _ _ (Trans (mono_morphism N) x) |}. Program Definition Monic_PreSheaf_To_Monic_PreSheaf_Image_of : (F --> Monic_PreSheaf_Image_of)%nattrans := {| Trans := fun x => @Monic_To_Image _ _ (Trans (mono_morphism N) x) |}. Definition Monic_PreSheaf_Iso_Monic_Factor_Monic : @Monic (PShCat C) Monic_PreSheaf_Image_of G. Proof. eapply (@is_Monic_Monic (PShCat C) _ _ Monic_PreSheaf_Morph_From_Monic_PreSheaf_Image_of_forward ). apply is_Monic_components_is_Monic. intros c. set (W := fun A B f H => mono_morphism_monomorphic (@Monic_Iso_Monic_Factor_Monic A B f H)). unfold is_Monic in *. cbn in *. apply W. apply PreSheaf_Monic_components_is_Monic. Defined. Program Definition Monic_PreSheaf_Iso_Monic_Factor_Monic_Iso : @Isomorphism (PShCat C) F Monic_PreSheaf_Image_of := {| iso_morphism := Monic_PreSheaf_To_Monic_PreSheaf_Image_of; inverse_morphism := Monic_PreSheaf_From_Monic_PreSheaf_Image_of_back |}. Next Obligation. Proof. apply NatTrans_eq_simplify. extensionality x. extensionality y. cbn in *. apply (equal_f Monic_To_Image_form_split_epic). Qed. Theorem split_Epic_Monic_Factorization : (mono_morphism N) = ( (mono_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic) ∘ (iso_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic_Iso) )%nattrans. 
Q R Γ'} : remove (P ∧ Q) Γ Γ' -> P :: Q :: Γ' ⇒* R -> Γ ⇒* R | LJTstar_or_introl {Γ P Q} : Γ ⇒* P -> Γ ⇒* P ∨ Q | LJTstar_or_intror {Γ P Q} : Γ ⇒* Q -> Γ ⇒* P ∨ Q | LJTstar_or_elim {Γ P Q R Γ'} : remove (P ∨ Q) Γ Γ' -> P :: Γ' ⇒* R -> Q :: Γ' ⇒* R -> Γ ⇒* R | LJTstar_impl_intro {Γ P Q} : P :: Γ ⇒* Q -> Γ ⇒* P ⊃ Q | LJTstar_impl_assump_elim {Γ P Q R Γ'} : remove (P ⊃ Q) Γ Γ' -> In P Γ' -> Q :: Γ' ⇒* R -> Γ ⇒* R | LJTstar_red_top_impl {Γ P Q Γ'} : remove (⊤ ⊃ P) Γ Γ' -> P :: Γ' ⇒* Q -> Γ ⇒* Q | LJTstar_red_and_impl {Γ P Q R S Γ'} : remove (P ∧ Q ⊃ R) Γ Γ' -> P ⊃ Q ⊃ R :: Γ' ⇒* S -> Γ ⇒* S | LJTstar_red_or_impl {Γ P Q R S Γ'} : remove (P ∨ Q ⊃ R) Γ Γ' -> P ⊃ R :: Q ⊃ R :: Γ' ⇒* S -> Γ ⇒* S | LJTstar_impl_impl_elim {Γ P Q R S Γ'} : remove ((P ⊃ Q) ⊃ R) Γ Γ' -> P :: Q ⊃ R :: Γ' ⇒* Q -> R :: Γ' ⇒* S -> Γ ⇒* S where "Γ ⇒* P" := (LJTstar_proves Γ P).Example LJTstar_no_Peirce : forall x y:atom, x <> y -> let P := atom_prop x in let Q := atom_prop y in ~ (nil ⇒* ((P ⊃ Q) ⊃ P) ⊃ P). Proof. intros; subst P Q. intro.inversion_clear H0; repeat match goal with | H0 : In _ _ |- _ => destruct H0; subst | H0 : remove _ _ _ |- _ => inversion_clear H0 end.inversion H1; subst; repeat match goal with | H0 : In _ _ |- _ => destruct H0; try discriminate; subst | H0 : remove _ _ _ |- _ => inversion H0; subst end.clear H1 H3 H0. inversion H2; subst; repeat match goal with | H0 : In _ _ |- _ => destruct H0; try discriminate; subst | H0 : remove _ _ _ |- _ => inversion H0; subst end; congruence. Qed. Theorem LJTstar_soundness {Γ P} : Γ ⇒* P -> Γ ⊢ P. 
apply subcode_sss_progress_inv with (3 := H6) (4 := G5) in H5; auto. destruct H5 as (q & H5 & G7). exists q, (i2,v2), (linker i2, w2); simpl; repeat (split; auto). apply subcode_sss_compute with (1 := HI). exists 1; apply sss_steps_1. exists i1, nil, I, nil, v1; repeat (split; auto). f_equal; simpl; omega. Qed. Theorem compiler_complete i1 v1 w1 : v1 ⋈ w1 -> Q /Y/ (linker i1,w1) ↓ -> P /X/ (i1,v1) ↓. Proof. intros H1 (st & (q & H2) & H3). revert i1 v1 w1 H1 H2 H3. induction q as [ q IHq ] using (well_founded_induction lt_wf). intros i1 v1 w1 H1 H2 H3. destruct (in_out_code_dec i1 P) as [ H4 | H4 ]. + destruct compiler_complete_step with (5 := H2) (st1 := (i1,v1)) as (p & (i2,v2) & (j2,w2) & G1 & G2 & G3 & G4 & G5); auto; simpl in *; subst j2. destruct IHq with (1 := G5) (2 := G1) (3 := G4) as ((i3 & v3) & F3 & F4); auto. exists (i3,v3); repeat (split; auto). apply sss_compute_trans with (1 := G3); auto. + exists (i1,v1); repeat (split; auto). exists 0; constructor. Qed. Corollary compiler_complete' i1 v1 w1 st : v1 ⋈ w1 /\ Q /Y/ (linker i1,w1) ~~> st -> exists i2 v2 w2, v2 ⋈ w2 /\ P /X/ (i1,v1) ~~> (i2,v2) /\ Q /Y/ (linker i2,w2) ~~> st. Proof. intros (H1 & H2). destruct compiler_complete with (1 := H1) (2 := ex_intro (fun x => Q /Y/ (linker i1, w1) ~~> x) _ H2) as ((i2,v2) & H3 & H4). exists i2, v2. destruct (compiler_sound (conj H1 H3)) as (w2 & H5 & H6). exists w2; do 2 (split; auto). split; auto. destruct H2 as (H2 & H0); split; auto. apply sss_compute_inv with (3 := H6); auto. Qed. End correctness. Variable (P : nat * list X) (iQ : nat). Let iP := fst P. Let cP := snd P. Let err := iQ+length_compiler ilen cP. Definition gen_linker := linker ilen (iP,cP) iQ err. Definition gen_compiler := compiler icomp ilen (iP,cP) iQ err. Notation cQ := gen_compiler. Notation lnk := gen_linker. Let P_eq : P = (iP,cP). Proof. unfold iP, cP; destruct P; auto. Qed. Fact gen_linker_out i : out_code i (iP,cP) -> lnk i = iQ+length cQ. Proof. intros H. unfold lnk. rewrite linker_out_err; unfold err; simpl; auto. * unfold cQ; rewrite compiler_length; auto. * omega. Qed. Theorem gen_compiler_sound i1 v1 i2 v2 w1 : v1 ⋈ w1 /\ (iP,cP) /X/ (i1,v1) ~~> (i2,v2) -> exists w2, v2 ⋈ w2 /\ (iQ,cQ) /Y/ (lnk i1,w1) ~~> (lnk i2,w2). 
Require Import Raux Defs Round_pred Float_prop.Section Generic.Variable beta : radix.Notation bpow e := (bpow beta e).Section Format.Variable fexp : Z -> Z.Class Valid_exp := valid_exp : forall k : Z, ( (fexp k < k)%Z -> (fexp (k + 1) <= k)%Z ) /\ ( (k <= fexp k)%Z -> (fexp (fexp k + 1) <= fexp k)%Z /\ forall l : Z, (l <= fexp k)%Z -> fexp l = fexp k ).Context { valid_exp_ : Valid_exp }.Theorem valid_exp_large : forall k l, (fexp k < k)%Z -> (k <= l)%Z -> (fexp l < l)%Z. Proof. intros k l Hk H. apply Znot_ge_lt. intros Hl. apply Z.ge_le in Hl. assert (H' := proj2 (proj2 (valid_exp l) Hl) k). omega. Qed.Theorem valid_exp_large' : forall k l, (fexp k < k)%Z -> (l <= k)%Z -> (fexp l < k)%Z. Proof. intros k l Hk H. apply Znot_ge_lt. intros H'. apply Z.ge_le in H'. assert (Hl := Z.le_trans _ _ _ H H'). apply valid_exp in Hl. assert (H1 := proj2 Hl k H'). omega. Qed.Definition cexp x := fexp (mag beta x).Definition canonical (f : float beta) := Fexp f = cexp (F2R f).Definition scaled_mantissa x := (x * bpow (- cexp x))%R.Definition generic_format (x : R) := x = F2R (Float beta (Ztrunc (scaled_mantissa x)) (cexp x)). Theorem generic_format_0 : generic_format 0. 
Zlt_le_trans with (- (0))%Z; auto with zarith. apply Zlt_Zopp; apply Zle_lt_trans with (2 := H); auto with zarith. rewrite <- (Zopp_involutive z1); rewrite <- (Zabs_eq_opp z1); auto with zarith. Qed. Theorem Zlt_Zabs_inv2 : forall z1 z2 : Z, (Zabs z1 < Zabs z2)%Z -> (z1 < Zabs z2)%Z. intros z1 z2; case z1; case z2; simpl in |- *; auto with zarith. Qed. Theorem Zle_Zabs_inv1 : forall z1 z2 : Z, (Zabs z1 <= z2)%Z -> (- z2 <= z1)%Z. intros z1 z2 H; case (Zle_or_lt 0 z1); intros H1. apply Zle_trans with (- (0))%Z; auto with zarith. apply Zle_Zopp; apply Zle_trans with (2 := H); auto with zarith. rewrite <- (Zopp_involutive z1); rewrite <- (Zabs_eq_opp z1); auto with zarith. Qed. Theorem Zle_Zabs_inv2 : forall z1 z2 : Z, (Zabs z1 <= z2)%Z -> (z1 <= z2)%Z. intros z1 z2 H; case (Zle_or_lt 0 z1); intros H1. rewrite <- (Zabs_eq z1); auto. apply Zle_trans with (Zabs z1); auto with zarith. Qed. Theorem Zlt_Zabs_Zpred : forall z1 z2 : Z, (Zabs z1 < z2)%Z -> z1 <> Zpred z2 -> (Zabs (Zsucc z1) < z2)%Z. intros z1 z2 H H0; case (Zle_or_lt 0 z1); intros H1. rewrite Zabs_eq; auto with zarith. rewrite Zabs_eq in H; auto with zarith. apply Zlt_trans with (2 := H). repeat rewrite Zabs_eq_opp; auto with zarith. Qed. Theorem Zle_n_Zpred : forall z1 z2 : Z, (Zpred z1 <= Zpred z2)%Z -> (z1 <= z2)%Z. intros z1 z2 H; rewrite (Zsucc_pred z1); rewrite (Zsucc_pred z2); auto with zarith. Qed. Theorem Zpred_Zopp_Zs : forall z : Z, Zpred (- z) = (- Zsucc z)%Z. intros z; unfold Zpred, Zsucc in |- *; ring. Qed. Theorem Zlt_1_O : forall z : Z, (1 <= z)%Z -> (0 < z)%Z. intros z H; apply Zsucc_lt_reg; simpl in |- *; auto with zarith. Qed. Hint Resolve Zlt_succ Zsucc_lt_compat Zle_lt_succ: zarith. Theorem Zlt_not_eq : forall p q : Z, (p < q)%Z -> p <> q. intros p q H; Contradict H; rewrite H; auto with zarith. Qed. Theorem Zlt_not_eq_rev : forall p q : Z, (q < p)%Z -> p <> q. intros p q H; Contradict H; rewrite H; auto with zarith. Qed. Hint Resolve Zlt_not_eq Zlt_not_eq_rev: zarith. Theorem Zle_Zpred_Zlt : forall z1 z2 : Z, (z1 <= z2)%Z -> (Zpred z1 < z2)%Z. intros z1 z2 H; apply Zsucc_lt_reg; rewrite <- Zsucc_pred; auto with zarith. Qed. Hint Resolve Zle_Zpred_Zlt: zarith. Theorem Zle_Zpred_inv : forall z1 z2 : Z, (z1 <= Zpred z2)%Z -> (z1 < z2)%Z. 
{ clear alpha; intros alpha IHalpha H. destruct l. - exists T1.zero; simpl; unfold nf; split; auto. - inversion_clear 1. pose (H3 := IHalpha o). assert (H0 : o < alpha). { simpl in H2; subst alpha; apply lt_le_trans with (AP._phi0 o). - apply lt_phi0; apply le_lt_trans with (AP._phi0 o). + apply le_phi0. + apply le_lt_trans with (2:= H); apply le_plus_l. - apply le_plus_l. } assert (H4 : o < epsilon0). { apply lt_trans with alpha; auto. } specialize (H3 H0 H4); destruct (cnf_exists o) as [x H5]. specialize (IHalpha (eval l)). assert (H6 : eval l < alpha). { simpl in H2; subst alpha; apply sorted_lt; auto. } assert (H7 : eval l < epsilon0). { apply lt_trans with alpha; auto. } destruct (H3 _ H5) as [x0 H8]. destruct H8 as [H8 H9]; specialize (IHalpha H6 H7). + destruct (IHalpha l). * split; trivial. eapply sorted_tail; eauto. * destruct H10 as [H10 H11]; exists (T1.phi0 x0 + x1)%t1. split. -- apply plus_nf ; eauto with T1. -- simpl eval; rewrite <- H11; rewrite inject_plus; auto with T1. simpl (inject (T1.phi0 x0)); rewrite H9; destruct H5. rewrite <- H12; rewrite alpha_plus_zero; auto. } Qed. Theorem inject_lt_epsilon0_ex (alpha : Ord) (H : alpha < epsilon0) : exists t: T1, nf t /\ inject t = alpha. Proof. destruct (cnf_exists alpha) as [l Hl]. destruct (inject_lt_epsilon0_ex_cnf alpha H l Hl) as [t [H1 H2]]. exists t; split ; [trivial | ]. destruct Hl; congruence. Qed. Theorem inject_lt_epsilon0_ex_unique (alpha : Ord) (H : alpha < epsilon0) : exists! t: T1, nf t /\ inject t = alpha. Proof. destruct (inject_lt_epsilon0_ex alpha H ) as [t [H0 H1]]. exists t; split. - now split. - intros t' [H2 H3]. rewrite <- H3 in H1; now apply inject_injective. Qed.Theorem embedding : fun_bijection (nf: Ensemble T1) (members epsilon0) inject. Proof. split. - intros x Hx; apply inject_lt_epsilon0. - intros y Hy; destruct (inject_lt_epsilon0_ex y Hy) as [x [Hx Hx1]]; exists x; auto. - intros x x' Hx Hx' H; apply inject_injective; auto. Qed.#[ global ] Instance Epsilon0_correct : ON_correct epsilon0 Epsilon0 (fun alpha => inject (cnf alpha)). Proof. split. - intro a; apply embedding; red; apply cnf_ok. - intros; destruct (inject_lt_epsilon0_ex_unique _ H) as [x [[H0 H1] H2]]. exists (mkord H0);now cbn. - intros a b; destruct (compare_correct a b). + now subst. + apply inject_mono;destruct H; tauto. + apply inject_mono; destruct H; tauto. Qed. Theorem E0_plus_correct : ON_op_ok E0add plus. 
x n -> num_occur (rename_all_ns sig e) y m -> num_occur (rename_all_ns (M.set x y sig) e) y (n+m)) /\ (forall fds n m, num_occur_fds fds x n -> num_occur_fds (rename_all_fun_ns sig fds) y m -> num_occur_fds (rename_all_fun_ns (M.set x y sig) fds) y (n+m)). Proof. intros x y sig Hxy Hdom. apply exp_def_mutual_ind; intros; simpl in *; try (inv H0; inv H1). - specialize (H _ _ H8 H7). eapply num_occur_n. constructor. eauto. rewrite num_occur_set_arl_s; auto. lia. - inv H; inv H0. inv H5; inv H4. eapply num_occur_n. constructor; eauto. constructor. assert (Hn := num_occur_set_arl_s _ _ _ Hxy Hdom [v]). simpl in Hn. simpl. unfold var in *. lia. - inv H1; inv H2. inv H7; inv H6. specialize (H _ _ H8 H7). assert (num_occur (Ecase v l) x ( num_occur_list [v] x + m)). constructor; auto. assert (num_occur (Ecase (apply_r sig v) (rename_all_case sig l)) y ( num_occur_list [apply_r sig v] y + m0)). constructor; auto. specialize (H0 _ _ H1 H2). inv H0. eapply num_occur_n. constructor. constructor; eauto. simpl. lia. - specialize (H _ _ H9 H8). eapply num_occur_n. constructor; eauto. assert (Hn := num_occur_set_arl_s _ _ _ Hxy Hdom [v0]). simpl in Hn. simpl. unfold var in *. lia. - specialize (H _ _ H9 H8). eapply num_occur_n. constructor; eauto. assert (Hn := num_occur_set_arl_s _ _ _ Hxy Hdom (f :: ys)). simpl in Hn. simpl. unfold var in *. lia. - inv H1; inv H2. specialize (H _ _ H8 H9). specialize (H0 _ _ H5 H4). eapply num_occur_n. constructor; eauto. lia. - inv H; inv H0. eapply num_occur_n. constructor; eauto. assert (Hn := num_occur_set_arl_s _ _ _ Hxy Hdom (v::l)). simpl in Hn. simpl. unfold var in *. lia. - specialize (H _ _ H8 H7). eapply num_occur_n. constructor. eauto. rewrite num_occur_set_arl_s; auto. lia. - inv H; inv H0. eapply num_occur_n. constructor. assert (Hn := num_occur_set_arl_s _ _ _ Hxy Hdom [v]). simpl in Hn. simpl. unfold var in *. lia. - inv H1; inv H2. specialize (H _ _ H10 H9). specialize (H0 _ _ H11 H12). eapply num_occur_fds_n. constructor; eauto. lia. - inv H; inv H0. constructor. Qed. Theorem sum_range_length: forall v0 e lx ly n, sum_range_n lx ly e v0 n -> List.length lx = List.length ly. Proof. induction lx; intros. inv H; auto. inv H. apply IHlx in H2. simpl; auto. apply IHlx in H2. simpl; auto. Qed. Theorem num_occur_set_list_r: forall m v0 sig e lx ly n, Disjoint _ (Dom_map sig) (FromList lx) -> Disjoint _ (FromList lx) (FromList ly) -> NoDup lx -> Included _ (FromList lx) (Union _ (Complement _ (Range_map sig)) (dead_var (rename_all_ns sig e))) -> sum_range_n lx ly (rename_all_ns sig e) v0 n -> num_occur (rename_all_ns sig e) v0 m -> ~ FromList lx v0 -> num_occur (rename_all_ns (set_list (combine lx ly) sig) e) v0 (n + m). 
(xs : list A) (x : A) : reflect (In x xs) (elem_by _==_ x xs). Proof. elim: xs => [|x' xs IH] /=; first by constructor. apply iff_reflect; split; try move=> /orP; move=> [? | ?]; try apply/orP; solve [by left; apply/Eq_eq | by right; apply/IH]. Qed.Theorem elem_app {A} `{Eq_ A} (a : A) (xs ys : list A) : elem a (xs ++ ys) = elem a xs || elem a ys. Proof. by elim: xs => [|x xs] //=; rewrite !elemC -orbA => ->. Qed.Theorem elem_by_resp_eq {A} `{EqLaws A} (xs : list A) (a b : A) : a == b -> elem_by _==_ a xs -> elem_by _==_ b xs. Proof. move=> EQab; elim: xs => [|x xs IH] //=. case EQxa: (x == a) => //=; case EQxb: (x == b) => //=. have: (x == b) by eapply Eq_trans with a. by rewrite EQxb. Qed.Theorem elem_resp_eq {A} `{EqLaws A} (xs : list A) (a b : A) : a == b -> elem a xs -> elem b xs. Proof. rewrite !elem_elem_by; apply elem_by_resp_eq. Qed.Theorem elem_Permutation {A} `{Eq_ A} (xs ys : list A) : Permutation xs ys -> forall a, elem a xs = elem a ys. Proof. elim=> {xs ys} [ | x xs ys PERM IH | x y xs | xs ys zs PERM_xs_ys IH_xs_ys PERM_ys_zs IH_ys_zs ] //= a. - by rewrite !elemC IH. - by rewrite !elemC !orbA (orbC (_ == _) (_ == _)). - eapply etrans; [apply IH_xs_ys | apply IH_ys_zs]. Qed.Theorem InP {A : eqType} (x : A) (xs : list A) : reflect (In x xs) (x \in xs). Proof. elim: xs => [|y ys IH] //=. - by rewrite seq.in_nil; constructor. - rewrite inE; case CMP: (x === y) => /=. + by constructor; left; apply/eqP; rewrite eq_sym. + apply/equivP; first exact IH. split; first by right. case=> // ?; subst. by move: CMP; rewrite eq_refl. Qed.Theorem In_split {A} (x : A) (xs : list A) : In x xs <-> exists pre post, xs = pre ++ x :: post. Proof. split. - elim: xs => [|x' xs IH] //= [? | IN]; first subst x'. + by exists [::], xs. + move: (IH IN) => [pre [post ->]]. by exists (x' :: pre), post. - move=> [pre [post ->]]. by elim: pre => [|p pre IH] //=; [left | right]. Qed. Theorem Foldable_list_all {A} : all =2 @GHC.List.all A. 
Require Import lattice lsyntax comparisons lset boolean sups. Set Implicit Arguments. Definition atom {n} (f: ord (pow2 n)): expr_ops (ord n) BL := sup (X:=dual (expr_ops _ BL)) (fun i => if set.mem f i then e_var i else ! e_var i) (seq n). Definition e_top' n: expr_ BL := \sup_(a<pow2 n) atom a. Lemma seq_double n: seq (double n) ≡ map (@set.xO _) (seq n) ++ map (@set.xI _) (seq n). Proof. induction n. reflexivity. simpl double. simpl seq. fold_cons. rewrite IHn. simpl map. rewrite 2map_app. rewrite 6map_map. rewrite set.xO_0, set.xI_0. setoid_rewrite set.xO_S. setoid_rewrite set.xI_S. simpl. refine (comm4 [_] [_] _ _). Qed.Lemma atom_xO n (f: ord (pow2 n)): @atom (S n) (set.xO f) ≡ ! e_var ord0 ⊓ eval (fun i => e_var (ordS i)) (atom f). Proof. unfold atom. simpl. rewrite set.mem_xO_0. apply cap_weq. reflexivity. setoid_rewrite eval_inf with (g := fun i => e_var (ordS i)). rewrite sup_map. apply (sup_weq (l:=BL) (L:=lattice.dual_laws _ _ _)). 2: reflexivity. intro i. rewrite set.mem_xO_S. now case set.mem. Qed.Lemma atom_xI n (f: ord (pow2 n)): @atom (S n) (set.xI f) ≡ e_var ord0 ⊓ eval (fun i => e_var (ordS i)) (atom f). Proof. unfold atom. simpl. rewrite set.mem_xI_0. apply cap_weq. reflexivity. setoid_rewrite eval_inf with (g := fun i => e_var (ordS i)). rewrite sup_map. apply (sup_weq (l:=BL) (L:=lattice.dual_laws _ _ _)). 2: reflexivity. intro i. rewrite set.mem_xI_S. now case set.mem. Qed. Theorem decomp_top n: top ≡ e_top' n. 
(swap_pair p) = snd p. Admitted. Inductive natlist : Type := | nil : natlist | cons : nat -> natlist -> natlist.Instance dec_natlist (p q : natlist) : Dec (p = q). Proof. constructor; unfold decidable; repeat decide equality. Defined. Derive Arbitrary for natlist. Derive Show for natlist. Derive Sized for natlist. Derive CanonicalSized for natlist. Derive SizeMonotonic for natlist using genSnatlist. Derive SizedMonotonic for natlist. Derive SizedCorrect for natlist using genSnatlist and SizeMonotonicnatlist.Notation "x :: l" := (cons x l) (at level 60, right associativity). Notation "[ ]" := nil. Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).Fixpoint repeat (n count : nat) : natlist := match count with | O => nil | S count' => n :: (repeat n count') end.Fixpoint length (l:natlist) : nat := match l with | nil => O | h :: t => S (length t) end.Fixpoint app (l1 l2 : natlist) : natlist := match l1 with | nil => l2 | h :: t => h :: (app t l2) end.Notation "x ++ y" := (app x y) (right associativity, at level 60).Definition hd (default:nat) (l:natlist) : nat := match l with | nil => default | h :: t => h end.Definition tl (l:natlist) : natlist := match l with | nil => nil | h :: t => t end.Theorem nil_app : forall l:natlist, [] ++ l = l. Admitted. Theorem tl_length_pred : forall l:natlist, pred (length l) = length (tl l). Admitted. Theorem app_assoc : forall l1 l2 l3 : natlist, (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3). Admitted. Fixpoint rev (l:natlist) : natlist := match l with | nil => nil | h :: t => rev t ++ [h] end.Theorem app_length : forall l1 l2 : natlist, length (l1 ++ l2) = (length l1) + (length l2). Admitted. Theorem rev_length : forall l : natlist, length (rev l) = length l. Admitted. Theorem app_nil_r : forall l : natlist, l ++ [] = l. Admitted. Theorem rev_app_distr: forall l1 l2 : natlist, rev (l1 ++ l2) = rev l2 ++ rev l1. Admitted. Theorem rev_involutive : forall l : natlist, rev (rev l) = l. Admitted. Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist, l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4. Admitted. Theorem ble_n_Sn : forall n, leb n (S n) = true. 
type (snd (nwState net leader)) = Leader -> In p (nwPackets net) -> pBody p = AppendEntries t leaderId prevLogIndex prevLogTerm entries leaderCommit -> In e entries -> eTerm e = currentTerm (snd (nwState net leader)) -> In e (log (snd (nwState net leader))). Proof using lsli rri. intros. pose proof lift_prop leader_sublog_nw_invariant. conclude_using ltac:(apply leader_sublog_invariant_invariant). find_apply_hyp_hyp. find_apply_lem_hyp exists_deghosted_packet. match goal with | H : exists _, _ |- _ => destruct H as [q] end. break_and. match goal with | H : leader_sublog_nw_invariant _ |- _ => specialize (H leader q t leaderId prevLogIndex prevLogTerm entries leaderCommit e) end. repeat find_rewrite_lem deghost_spec. subst. simpl in *. intuition. Qed. Definition append_entries_append_entries_prefix_within_term_nw net := forall p t n pli plt es ci p' t' n' pli' plt' es' ci' e e', In p (nwPackets net) -> pBody p = AppendEntries t n pli plt es ci -> In p' (nwPackets net) -> pBody p' = AppendEntries t' n' pli' plt' es' ci' -> eTerm e = eTerm e' -> eIndex e <= eIndex e' -> In e es -> In e' es' -> (In e es' \/ (eIndex e = pli' /\ eTerm e = plt') \/ (eIndex e < pli' /\ eTerm e <= plt')). Theorem log_log_prefix_within_term_invariant : forall net, refined_raft_intermediate_reachable net -> log_log_prefix_within_term net. Proof using ollpti rlmli llli. red. red. intros. match goal with | H : In ?e _, H' : In ?e' _ |- _ => copy_eapply logs_leaderLogs_invariant H; eauto; copy_eapply logs_leaderLogs_invariant H'; eauto end. break_exists; intuition. repeat find_rewrite. find_eapply_lem_hyp one_leaderLog_per_term_log_invariant; eauto. conclude_using eauto. subst. assert (exists e'', eIndex e'' = eIndex e /\ In e'' (log (snd (nwState net h')))) by (eapply entries_contiguous_invariant; eauto; intuition; [eapply entries_gt_0_invariant; eauto|]; eapply le_trans; eauto; eapply maxIndex_is_max; eauto; apply entries_sorted_invariant; auto). break_exists. intuition. match goal with | _ : removeAfterIndex ?l ?i = _ _, _ : In ?x ?l, _ : eIndex ?x = _ |- _ => assert (In x (removeAfterIndex l i)) by (apply removeAfterIndex_le_In; eauto; omega) end. repeat find_rewrite. do_in_app. intuition. - find_apply_hyp_hyp. eapply entries_match_invariant; eauto; repeat find_rewrite; auto. - cut (e = x0); intros; subst; intuition. eapply uniqueIndices_elim_eq; eauto. + apply sorted_uniqueIndices. apply entries_sorted_invariant. auto. + match goal with | H : context [ removeAfterIndex ?l ?index ] |- In _ ?l => apply removeAfterIndex_in with (i := index) end. repeat find_rewrite. apply in_app_iff; intuition. Qed. Definition locked_or x y := x \/ y. Theorem append_entries_append_entries_prefix_within_term_invariant : forall net, refined_raft_intermediate_reachable net -> append_entries_append_entries_prefix_within_term_nw net. 
n) (paths y' y)). simpl in X1. simpl. assumption. assert (is3: forall (y:Y)(x:X)(xe': hfiber f y), isofhlevelf n (d2g f x xe')). intros. apply (IHn _ _ (d2g f x xe') (is1 (pr1 xe') x) (is2 (f x) y)). assert (is4: forall (y:Y)(x:X)(xe': hfiber f y)(e: paths (f x) y), isofhlevel n (paths (hfiberpair f x e) xe')). intros. apply (isofhlevelweqb n ( ezweq3g f x xe' e) (is3 y x xe' e)). intros y xe xe' . destruct xe as [ t x ]. apply (is4 y t xe' x). Defined.Theorem isofhlevelXfromfY ( n : nat ) { X Y : UU } ( f : X -> Y ) : isofhlevelf n f -> isofhlevel n Y -> isofhlevel n X. Proof. intro. induction n as [ | n IHn ] . intros X Y f X0 X1. apply (iscontrweqb ( weqpair f X0 ) X1). intros X Y f X0 X1. simpl. assert (is1: forall (y:Y)(xe xe': hfiber f y), isofhlevel n (paths xe xe')). intros. apply (X0 y). assert (is2: forall (y:Y)(x:X)(xe': hfiber f y), isofhlevelf n (d2g f x xe')). intros. unfold isofhlevel. intro y0. apply (isofhlevelweqf n ( ezweq3g f x xe' y0 ) (is1 y (hfiberpair f x y0) xe')). assert (is3: forall (y' y : Y), isofhlevel n (paths y' y)). simpl in X1. assumption. intros x' x . set (y:= f x'). set (e':= idpath y). set (xe':= hfiberpair f x' e'). apply (IHn _ _ (d2g f x xe') (is2 y x xe') (is3 (f x) y)). Defined. Theorem isofhlevelffib ( n : nat ) { X : UU } ( P : X -> UU ) ( x : X ) ( is : forall x':X, isofhlevel n (paths x' x) ) : isofhlevelf n ( tpair P x ) . Proof . intros . unfold isofhlevelf . intro xp . apply (isofhlevelweqf n ( ezweq1pr1 P x xp) ( is ( pr1 xp ) ) ) . Defined . Theorem isofhlevelfhfiberpr1y ( n : nat ) { X Y : UU } ( f : X -> Y ) ( y : Y ) ( is : forall y':Y, isofhlevel n (paths y' y) ) : isofhlevelf n ( hfiberpr1 f y). Proof. intros . unfold isofhlevelf. intro x. apply (isofhlevelweqf n ( ezweq1g f y x ) ( is ( f x ) ) ) . Defined. Theorem isofhlevelfsnfib (n:nat) { X : UU } (P:X -> UU)(x:X) ( is : isofhlevel (S n) (paths x x) ) : isofhlevelf (S n) ( tpair P x ). 
ulp_le : forall { Hm : Monotone_exp fexp }, forall x y: R, (Rabs x <= Rabs y)%R -> (ulp x <= ulp y)%R. Proof. intros Hm x y Hxy. rewrite <- ulp_abs. rewrite <- (ulp_abs y). apply ulp_le_pos; trivial. apply Rabs_pos. Qed.Definition pred_pos x := if Req_bool x (bpow (ln_beta beta x - 1)) then (x - bpow (fexp (ln_beta beta x - 1)))%R else (x - ulp x)%R.Definition succ x := if (Rle_bool 0 x) then (x+ulp x)%R else (- pred_pos (-x))%R.Definition pred x := (- succ (-x))%R.Theorem pred_eq_pos: forall x, (0 <= x)%R -> (pred x = pred_pos x)%R. Proof. intros x Hx; unfold pred, succ. case Rle_bool_spec; intros Hx'. assert (K:(x = 0)%R). apply Rle_antisym; try assumption. apply Ropp_le_cancel. now rewrite Ropp_0. rewrite K; unfold pred_pos. rewrite Req_bool_false. 2: apply Rlt_not_eq, bpow_gt_0. rewrite Ropp_0; ring. now rewrite 2!Ropp_involutive. Qed.Theorem succ_eq_pos: forall x, (0 <= x)%R -> (succ x = x + ulp x)%R. Proof. intros x Hx; unfold succ. now rewrite Rle_bool_true. Qed.Lemma pred_eq_opp_succ_opp: forall x, pred x = (- succ (-x))%R. Proof. reflexivity. Qed.Lemma succ_eq_opp_pred_opp: forall x, succ x = (- pred (-x))%R. Proof. intros x; unfold pred. now rewrite 2!Ropp_involutive. Qed.Lemma succ_opp: forall x, (succ (-x) = - pred x)%R. Proof. intros x; rewrite succ_eq_opp_pred_opp. now rewrite Ropp_involutive. Qed.Lemma pred_opp: forall x, (pred (-x) = - succ x)%R. Proof. intros x; rewrite pred_eq_opp_succ_opp. now rewrite Ropp_involutive. Qed. Theorem id_m_ulp_ge_bpow : forall x e, F x -> x <> ulp x -> (bpow e < x)%R -> (bpow e <= x - ulp x)%R. Proof. intros x e Fx Hx' Hx.assert (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z. assert (0 < Ztrunc (scaled_mantissa beta fexp x))%Z. apply F2R_gt_0_reg with beta (canonic_exp beta fexp x). rewrite <- Fx. apply Rle_lt_trans with (2:=Hx). apply bpow_ge_0. omega. case (Zle_lt_or_eq _ _ H); intros Hm.pattern x at 1 ; rewrite Fx. rewrite ulp_neq_0. unfold F2R. simpl. pattern (bpow (canonic_exp beta fexp x)) at 2 ; rewrite <- Rmult_1_l. rewrite <- Rmult_minus_distr_r. change 1%R with (Z2R 1). rewrite <- Z2R_minus. change (bpow e <= F2R (Float beta (Ztrunc (scaled_mantissa beta fexp x) - 1) (canonic_exp beta fexp x)))%R. apply bpow_le_F2R_m1; trivial. now rewrite <- Fx. apply Rgt_not_eq, Rlt_gt. apply Rlt_trans with (2:=Hx), bpow_gt_0.contradict Hx'. pattern x at 1; rewrite Fx. rewrite <- Hm. rewrite ulp_neq_0. unfold F2R; simpl. now rewrite Rmult_1_l. apply Rgt_not_eq, Rlt_gt. apply Rlt_trans with (2:=Hx), bpow_gt_0. Qed. Theorem id_p_ulp_le_bpow : forall x e, (0 < x)%R -> F x -> (x < bpow e)%R -> (x + ulp x <= bpow e)%R. 
intro t . unfold isofhlevel in is . set (is' := is t x ). apply ( pr1 is' ). Defined. Lemma iscontraprop1inv { X : UU } ( f : X -> iscontr X ) : isaprop X . Proof. intros X X0. assert ( H : X -> isofhlevel (S O) X). intro X1. apply (hlevelntosn O _ ( X0 X1 ) ) . apply ( isofhlevelsn O H ) . Defined.Lemma proofirrelevance ( X : UU ) ( is : isaprop X ) : forall x x' : X , paths x x' . Proof. intros . unfold isaprop in is . unfold isofhlevel in is . apply ( pr1 ( is x x' ) ). Defined. Lemma invproofirrelevance ( X : UU ) ( ee : forall x x' : X , paths x x' ) : isaprop X. Proof. intros . unfold isaprop. unfold isofhlevel . intro x . assert ( is1 : iscontr X ). split with x. intro t . apply ( ee t x). assert ( is2 : isaprop X). apply isapropifcontr. assumption. unfold isaprop in is2. unfold isofhlevel in is2. apply (is2 x). Defined. Lemma isweqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) : isweq f. Proof. intros. assert (isx0: forall x:X, paths (g (f x)) x). intro. apply proofirrelevance . apply isx . assert (isy0 : forall y : Y, paths (f (g y)) y). intro. apply proofirrelevance . apply isy . apply (gradth f g isx0 isy0). Defined. Definition weqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) := weqpair _ ( isweqimplimpl f g isx isy ) .Theorem isapropempty: isaprop empty. Proof. unfold isaprop. unfold isofhlevel. intros x x' . destruct x. Defined. Theorem isapropifnegtrue { X : UU } ( a : X -> empty ) : isaprop X . Proof . intros . set ( w := weqpair _ ( isweqtoempty a ) ) . apply ( isofhlevelweqb 1 w isapropempty ) . Defined . Axiom funextempty : forall ( X : UU ) ( f g : X -> empty ) , paths f g . Theorem isapropneg (X:UU): isaprop (X -> empty). 
: forall A B C D : Point, parallelogram A B C D -> ~ Col B C D. Proof. unfold parallelogram, parallel, S4 in |- *. intros. decompose [and] H. unfold not in |- *; intro. rewrite H1 in H2. NormalizeRing H2. assert (Col B A C); Geometry. Qed.Hint Resolve para_not_col_2: Geom.Theorem para_not_col_3 : forall A B C D : Point, parallelogram A B C D -> ~ Col A C D. Proof. unfold parallelogram, parallel,S4 in |- *. intros. decompose [and] H. unfold not in |- *; intro. assert (S A C D = S A C B + S A B D + S B C D); Geometry. rewrite H1 in H4. rewrite H0 in H4. NormalizeRing H4. assert (Col B C D); Geometry. assert (parallelogram A B C D). unfold parallelogram in |- *; auto. assert (~ Col B C D); eauto with Geom. Qed.Hint Resolve para_not_col_3: Geom. Theorem para_1 : forall A B C D : Point, parallelogram A B C D -> parallelogram A D C B. Proof. unfold parallelogram in |- *. intros. decompose [and] H. repeat split; Geometry. assert (parallelogram A B C D); unfold parallelogram in |- *; auto. assert (~ Col A C D); eauto with Geom. Qed.Hint Resolve para_1: Geom. Theorem para_2 : forall A B C D : Point, parallelogram A B C D -> parallelogram B A D C. Proof. intros. assert (~Col A B D). eauto with Geom. unfold parallelogram in *. intros. decompose [and] H. repeat split; Geometry. Qed.Hint Resolve para_2: Geom.Theorem para_3 : forall A B C D : Point, parallelogram A B C D -> parallelogram D C B A. Proof. intros. assert (~Col D C B). eauto with Geom. unfold parallelogram in *. intros. decompose [and] H. repeat split; Geometry. Qed.Hint Resolve para_3: Geom.Theorem para_4 : forall A B C D : Point, parallelogram A B C D -> parallelogram C B A D. Proof. intros. assert (~Col D C B). eauto with Geom. unfold parallelogram in *. intros. decompose [and] H. repeat split; Geometry. Qed.Hint Resolve para_4: Geom. Theorem not_para_eq_1 : forall A B C, ~ parallelogram A A B C. Proof. intuition idtac. assert (~ Col A A C). eauto with Geom. intuition. Qed.Theorem not_para_eq_2 : forall A B C, ~ parallelogram A B C C. Proof. intuition idtac. assert (~ Col B C C). eauto with Geom. intuition. Qed. Theorem not_para_eq_3 : forall A B C, ~ parallelogram A B C A. 
h st client id c = (out, st', ps) -> forall (P : list entry -> Prop), P (log st) -> (forall e, eIndex e = S (maxIndex (log st)) -> eTerm e = currentTerm st -> eClient e = client -> eInput e = c -> eId e = id -> type st = Leader -> P (e :: log st)) -> P (log st'). Proof using. intros. find_apply_lem_hyp handleClientRequest_log. intuition; repeat find_rewrite; auto. break_exists. intuition. repeat find_rewrite. eauto. Qed. Lemma handleRequestVote_log : forall h st t candidate lli llt st' m, handleRequestVote h st t candidate lli llt = (st', m) -> log st' = log st. Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; find_inversion; subst; auto. Qed. Lemma handleTimeout_log_same : forall h d out d' l, handleTimeout h d = (out, d', l) -> log d' = log d. Proof using. unfold handleTimeout, tryToBecomeLeader. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma doGenericServer_log : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> log st' = log st. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleRequestVoteReply_spec : forall h st h' t r st', st' = handleRequestVoteReply h st h' t r -> log st' = log st /\ (forall v, In v (votesReceived st) -> In v (votesReceived st')) /\ ((currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' <> Candidate) /\ (type st <> Leader /\ type st' = Leader -> (type st = Candidate /\ wonElection (dedup name_eq_dec (votesReceived st')) = true)). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition; try right; congruence. Qed. Lemma handleRequestVoteReply_spec' : forall h st h' t r st', st' = handleRequestVoteReply h st h' t r -> log st' = log st /\ (forall v, In v (votesReceived st) -> In v (votesReceived st')) /\ (type st <> Leader /\ type st' = Leader -> (type st = Candidate /\ wonElection (dedup name_eq_dec (votesReceived st')) = true) /\ r = true /\ currentTerm st' = currentTerm st /\ currentTerm st = t /\ votesReceived st' = (h' :: (votesReceived st))). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition; try right; congruence. Qed. Theorem handleTimeout_not_is_append_entries : forall h st st' ms m, handleTimeout h st = (st', ms) -> In m ms -> ~ is_append_entries (snd m). 
Require Export UniMath.Foundations.PartB. Require Export UniMath.Foundations.UnivalenceAxiom. Theorem isapropneg (X : UU) : isaprop (neg X). Proof. apply invproofirrelevance. intros x x'. apply (funextempty X x x'). Defined.Lemma isaprop_isProofIrrelevant X : isaprop (isProofIrrelevant X). Proof. intros. apply invproofirrelevance. intros i j. apply funextsec; intro x; apply funextsec; intro y. generalize (i x y) as p; generalize (j x y) as q; intros. apply isProofIrrelevant_paths. assumption. Defined. Corollary isapropdneg (X : UU) : isaprop (dneg X). Proof. intro. apply (isapropneg (neg X)). Defined. Definition isaninvprop (X : UU) := isweq (todneg X).Definition invimpl (X : UU) (is : isaninvprop X) : (dneg X) -> X := invmap (make_weq (todneg X) is). Lemma isapropaninvprop (X : UU) : isaninvprop X -> isaprop X. Proof. intros X0. apply (isofhlevelweqb (S O) (make_weq (todneg X) X0) (isapropdneg X)). Defined. Theorem isaninvpropneg (X : UU) : isaninvprop (neg X). 
-> LockServ_network_network_invariant p p'. Proof using. unfold LockServ_network_network_invariant. intuition; simpl in *; congruence. Qed. Lemma LockServ_nwnw_input_handlers_old_new : forall h i sigma u st' out ms p p', InputHandler h i (sigma h) = (u, out, st', ms) -> locks_correct sigma -> LockServ_network_invariant sigma p -> In (pDst p', pBody p') ms -> pSrc p' = h -> LockServ_network_network_invariant p p'. Proof using. unfold LockServ_network_invariant. set_up_input_handlers. - auto using nwnw_sym, nwnw_lock. - destruct (pBody p) eqn:?. + auto using nwnw_lock. + now erewrite unlock_in_flight_all_clients_false in * by eauto. + now erewrite locked_in_flight_all_clients_false in * by eauto. Qed. Lemma LockServ_nwnw_input_handlers_new_new : forall h i sigma u st' out ms, InputHandler h i (sigma h) = (u, out, st', ms) -> distinct_pairs_and LockServ_network_network_invariant (map (fun m => mkPacket h (fst m) (snd m)) ms). Proof using. set_up_input_handlers. Qed. Lemma nw_empty_queue_lock : forall sigma p, LockServ_network_invariant sigma p -> queue (sigma Server) = [] -> pBody p = Lock. Proof using. unfold LockServ_network_invariant, locks_correct_unlock, locks_correct_locked, valid_unlock, valid_locked. intuition. destruct (pBody p) eqn:?; intuition; break_exists; intuition; break_exists; congruence. Qed. Lemma LockServ_nwnw_net_handlers_old_new : forall p sigma u st' out ms q p', NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) = (u, out, st', ms) -> locks_correct sigma -> LockServ_network_invariant sigma p -> LockServ_network_invariant sigma q -> LockServ_network_network_invariant p q -> In (pDst p', pBody p') ms -> LockServ_network_network_invariant p' q. Proof using. set_up_net_handlers; eauto using nwnw_sym, nwnw_lock, nw_empty_queue_lock, nwnw_unlock_lock. Qed. Lemma LockServ_nwnw_net_handlers_new_new : forall p sigma u st' out ms, NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) = (u, out, st', ms) -> locks_correct sigma -> LockServ_network_invariant sigma p -> distinct_pairs_and LockServ_network_network_invariant (map (fun m => mkPacket (pDst p) (fst m) (snd m)) ms). Proof using. set_up_net_handlers. Qed. Ltac unlabeled_unfold := unfold unlabeled_net_handlers, unlabeled_input_handlers in *. Instance LockServ_Decompositition : Decomposition _ LockServ_MultiParams. apply Build_Decomposition with (state_invariant := locks_correct) (network_invariant := LockServ_network_invariant) (network_network_invariant := LockServ_network_network_invariant); simpl; intros; monad_unfold; unlabeled_unfold; repeat break_let; repeat find_inversion. - auto using nwnw_sym. - auto using locks_correct_init. - eauto using locks_correct_input_handlers. - unfold LockServ_network_invariant in *. intuition. eauto using locks_correct_net_handlers. - unfold LockServ_network_invariant in *. intuition eauto using locks_correct_unlock_input_handlers_old, locks_correct_locked_input_handlers_old. - unfold LockServ_network_invariant in *. intuition eauto using locks_correct_unlock_input_handlers_new, locks_correct_locked_input_handlers_new. - unfold LockServ_network_invariant in *. intuition eauto using locks_correct_unlock_net_handlers_old, locks_correct_locked_net_handlers_old. - unfold LockServ_network_invariant in *. intuition eauto using locks_correct_unlock_net_handlers_new, locks_correct_locked_net_handlers_new. - eauto using LockServ_nwnw_input_handlers_old_new. - eauto using LockServ_nwnw_input_handlers_new_new. - eauto using LockServ_nwnw_net_handlers_old_new. - eauto using LockServ_nwnw_net_handlers_new_new. Defined. Theorem true_in_reachable_mutual_exclusion : true_in_reachable step_async step_async_init (fun net => mutual_exclusion (nwState net)). 
_ _ _ _ _ _ _ cs) with (plusA (plusA (multA a1 (invA a0)) (multA a1 a0)) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (plusA (invA a0) a0)) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (plusA a0 (invA a0))) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 A0) (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA A0 a1) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA A0 (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (invA (multA a1 a0)) A0); auto. Qed. Theorem eqTerm_invTerm_comp : forall a b : Term, eqTerm a b -> eqTerm (invTerm a) (invTerm b). intros a b; case a; case b; simpl in |- *; auto. intuition. Qed. Theorem invTerm_eqT : forall a : Term, eqT a (invTerm a). intros a; case a; simpl in |- *; auto. Qed. Theorem T1_eqT : forall a b : Term, eqTerm a T1 -> eqT b (multTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1; case H1; intros H2 H3; auto. rewrite H3; auto. unfold eqT in |- *; simpl in |- *; apply sym_eq; unfold M1 in |- *; apply mult_mon_zero_l. Qed. Theorem eqTerm_T1_eqT : forall a : Term, eqTerm a T1 -> eqT a T1. intros a; case a; simpl in |- *; auto. intuition. Qed. Set Implicit Arguments. Unset Strict Implicit. Definition minusTerm : Term -> Term -> Term. intros H; case H; intros b2 c2 H'; case H'; intros b3 c3; exact (minusA b2 b3, c2). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem eqTerm_minusTerm_plusTerm_invTerm : forall a b : Term, eqTerm (minusTerm a b) (plusTerm a (invTerm b)). intros a b; case a; case b; simpl in |- *; auto. split; auto. apply minusA_def with (1 := cs); auto. Qed. Theorem minusTerm_eqT : forall m1 m2 : Term, eqT m1 m2 -> eqT (minusTerm m1 m2) m1. 
:= N.@"inode". Definition P γdur γbuf (s: s_inode.t) : iProp Σ := "Hfm_dur_blocks" ∷ fmlist γdur 1 (s.(s_inode.durable_blocks)) ∗ "Hfm_all_blocks" ∷ fmlist γbuf (1/2) (s.(s_inode.durable_blocks) ++ s.(s_inode.buffered_blocks)). Local Definition Pinode δdur δbuf δused (s: inode.t): iProp Σ := "Hown_dur_blocks" ∷ ghost_var δdur (1/2) s.(inode.durable_blocks) ∗ "Hown_buf_blocks" ∷ ghost_var δbuf (1/2) s.(inode.buffered_blocks) ∗ "Hused1" ∷ ghost_var δused (1/2) s.(inode.addrs). Local Definition Pinode_cinv δdur δused (s: inode.t): iProp Σ := "Hown_dur_blocks" ∷ ghost_var δdur (1/2) s.(inode.durable_blocks) ∗ "Hused1" ∷ ghost_var δused (1/2) s.(inode.addrs). Local Definition Palloc δused (s: alloc.t): iProp Σ := "Hused2" ∷ ghost_var δused (1/2) (alloc.used s). Definition s_inode_inv δdur δbuf (σ: s_inode.t): iProp Σ := "Hδdurable_blocks" ∷ ghost_var δdur (1/2) σ.(s_inode.durable_blocks) ∗ "Hδbuffered_blocks" ∷ ghost_var δbuf (1/2) σ.(s_inode.buffered_blocks). Definition s_inode_state l (inode_ref alloc_ref: loc) : iProp Σ := "#i" ∷ readonly (l ↦[SingleInode :: "i"] #inode_ref) ∗ "#alloc" ∷ readonly (l ↦[SingleInode :: "alloc"] #alloc_ref). Local Definition allocΨ (a: u64): iProp Σ := ∃ b, int.Z a d↦ b. Definition pre_s_inode γdur γbuf l (sz: Z) σ : iProp Σ := ∃ inode_ref alloc_ref δused δdur δbuf, "#Hstate" ∷ s_inode_state l inode_ref alloc_ref ∗ "Hs_inv" ∷ s_inode_inv δdur δbuf σ ∗ "Hinode" ∷ (∃ s_inode, "Hpre_inode" ∷ pre_inode inode_ref (U64 0) s_inode ∗ "HPinode" ∷ Pinode δdur δbuf δused s_inode) ∗ "Halloc" ∷ (∃ s_alloc, "Halloc_mem" ∷ is_allocator_mem_pre alloc_ref s_alloc ∗ "%Halloc_dom" ∷ ⌜alloc.domain s_alloc = rangeSet 1 (sz-1)⌝ ∗ "Hunused" ∷ ([∗ set] k ∈ alloc.unused s_alloc, allocΨ k) ∗ "HPalloc" ∷ Palloc δused s_alloc) ∗ "HP" ∷ P γdur γbuf σ. Definition is_single_inode γdur γbuf l (sz: Z) k' : iProp Σ := ∃ (inode_ref alloc_ref: loc) δalloc δused δdur δbuf, "Hro_state" ∷ s_inode_state l inode_ref alloc_ref ∗ "#Hinode" ∷ is_inode inodeN inode_ref (S k') (Pinode δdur δbuf δused) (U64 0) ∗ "#Halloc" ∷ is_allocator (Palloc δused) allocΨ allocN alloc_ref (rangeSet 1 (sz-1)) δalloc k' ∗ "#Hinv" ∷ ncinv s_inodeN (∃ σ, s_inode_inv δdur δbuf σ ∗ P γdur γbuf σ) . Definition s_inode_cinv γdur γbuf sz σ (post_crash: bool) : iProp Σ := ∃ δdur δused, "Hinode" ∷ (∃ s_inode, "Hinode_cinv" ∷ inode_cinv (U64 0) s_inode ∗ "HPinode" ∷ Pinode_cinv δdur δused s_inode) ∗ "Halloc" ∷ alloc_crash_cond (Palloc δused) allocΨ (rangeSet 1 (sz-1)) post_crash ∗ "Hδdurable_blocks" ∷ ghost_var δdur (1/2) σ.(s_inode.durable_blocks) ∗ "HP" ∷ P γdur γbuf σ . Local Hint Extern 1 (environments.envs_entails _ (s_inode_cinv _ _ _ _ _)) => unfold s_inode_cinv : core. Theorem s_inode_cinv_post_crash γdur γbuf sz σ : s_inode_cinv γdur γbuf sz σ true -∗ s_inode_cinv γdur γbuf sz σ false. 
gvc0. destructAll. apply comp_ctx_split in H15. destruct H15. + destructAll. destruct x1; inv H15. rewrite (proj1 inlined_comp_ctx). simpl. apply bound_var_ctx_comp_ctx. right; auto. + destructAll. destruct x2; inv H18. destruct x2; inv H19. - assert (gvc0' := gvc0). apply H10 in gvc0. destructAll. apply comp_ctx_split in H15. destruct H15. + destructAll. destruct x3; inv H15. * simpl in H14. inv H14. repeat rewrite rename_all_ns_fundefs_append in H19. eapply fundefs_append_unique_bindings_l in H19. 2: reflexivity. destructAll. inv H17. exfalso. specialize (H19 v). apply H19. split. eapply fundefs_append_bound_vars. reflexivity. right. simpl. auto. eapply fundefs_append_bound_vars. reflexivity. right. simpl. auto. * rewrite (proj1 inlined_comp_ctx). apply bound_var_ctx_comp_ctx. right. simpl. rewrite inlined_fundefs_append. simpl. destruct (get_b v im) eqn:gbvim. apply H3 in gbvim. destructAll. exfalso. apply H15. apply bound_var_app_ctx. right. apply bound_var_rename_all_ns. constructor. eapply fundefs_append_bound_vars. reflexivity. left. eapply fundefs_append_bound_vars. reflexivity. right. auto. constructor. eapply fundefs_append_bound_vars. reflexivity. right. auto. + destructAll. destruct x4; inv H18. * exfalso. simpl in H14. inv H14. repeat rewrite rename_all_ns_fundefs_append in H19. eapply fundefs_append_unique_bindings_l in H19. 2: reflexivity. destructAll. inv H17. exfalso. specialize (H19 v). apply H19. split. eapply fundefs_append_bound_vars. reflexivity. right. simpl. auto. eapply fundefs_append_bound_vars. reflexivity. right. simpl. auto. * destruct x4; inv H19. } apply bound_var_rename_all_ns. constructor. eapply fundefs_append_bound_vars. reflexivity. left. eapply fundefs_append_bound_vars. reflexivity. right. auto. } { simpl in H14. inv H14. rewrite rename_all_ns_fundefs_append in H19. rewrite rename_all_ns_fundefs_append in H19. eapply fundefs_append_unique_bindings_l in H19. 2: reflexivity. destructAll. inv H17. specialize (H19 v). apply H19. split. eapply fundefs_append_bound_vars. reflexivity. right. simpl. auto. apply bound_var_rename_all_ns_fundefs. inv H16. auto. inv H23. } rewrite <- fundefs_append_assoc in H11. simpl in H11. simpl. auto. - simpl in H5. inv H5. split. eapply Refl_srw. split; auto. split; auto. split. apply cmap_view_efun1_nil. auto. auto. Qed. Theorem bound_var_fundefs_inlined: forall im1 im2, b_map_le im1 im2 -> forall fds, Included _ (bound_var_fundefs (inlined_fundefs_f fds im2)) (bound_var_fundefs (inlined_fundefs_f fds im1)). Proof. intros im1 im2 Him; induction fds; simpl; repeat normalize_bound_var; auto. - destruct (get_b v im1) eqn:gbvi. + apply Him in gbvi. rewrite gbvi. auto. + destruct (get_b v im2); repeat normalize_bound_var; eauto with Ensembles_DB. - intro. intro. inv H. Qed. Lemma bound_var_ctx_inlined_antimon_mut: forall im1 im2, b_map_le im1 im2 -> (forall c, Included _ (bound_var_ctx (inlined_ctx_f c im2)) (bound_var_ctx (inlined_ctx_f c im1))) /\ (forall fdc, Included _ (bound_var_fundefs_ctx (inlined_fundefs_ctx_f fdc im2)) (bound_var_fundefs_ctx (inlined_fundefs_ctx_f fdc im1))). Proof. intros im1 im2 Him. exp_fundefs_ctx_induction IHc1 IHfc1; simpl; repeat normalize_bound_var_ctx; eauto with Ensembles_DB. - intro. repeat normalize_bound_var_ctx. eauto with Ensembles_DB. - apply Included_Union_compat; auto. apply bound_var_fundefs_inlined; auto. Qed. Theorem bound_var_ctx_inlined_antimon: forall im1 im2 c, b_map_le im1 im2 -> Included _ (bound_var_ctx (inlined_ctx_f c im2)) (bound_var_ctx (inlined_ctx_f c im1)). 
Require Import Bool. Require Import Arith. Require Import Compare_dec. Require Import Peano_dec. Require Import General. Require Import MyList. Require Import MyRelations.Require Export Main. Require Export SortV6.Section CoqV6Beta. Definition trm_v6 := term srt_v6. Definition env_v6 := env srt_v6. Definition v6 : CTS_spec srt_v6 := Build_CTS_spec _ axiom_v6 rules_v6 univ_v6 (beta_rule _). Definition v6_pts : PTS_sub_spec srt_v6 := cts_pts_functor _ v6. Definition le_type : red_rule srt_v6 := Rule _ (Le_type _ (pts_le_type _ v6_pts)). Definition typ_v6 : env_v6 -> trm_v6 -> trm_v6 -> Prop := typ _ v6_pts. Definition wft_v6 : env_v6 -> trm_v6 -> Prop := wf_type _ v6_pts. Definition wf_v6 : env_v6 -> Prop := wf _ v6_pts. Definition v6_sn := sn srt_v6 (ctxt _ (Rule _ (head_reduct _ v6))). Hint Unfold le_type typ_v6 wft_v6 wf_v6 v6_sn: pts. Lemma whnf : forall (e : env_v6) (t : trm_v6), v6_sn e t -> {u : trm_v6 | red _ (beta _) e t u & head_normal _ (beta _) e u}. Proof beta_whnf srt_v6. Lemma beta_conv_hnf : forall (e : env_v6) (x y : trm_v6), v6_sn e x -> v6_sn e y -> decide (conv_hn_inv _ (beta_rule _) e x y). Proof CR_WHNF_convert_hn srt_v6 v6_sort_dec (beta_rule srt_v6) (church_rosser_red srt_v6) whnf. Theorem v6_is_subtype_dec : subtype_dec_CTS _ v6. apply Build_subtype_dec_CTS. exact (church_rosser_red srt_v6).exact (beta_hn_sort srt_v6).exact (beta_hn_prod srt_v6).exact whnf.exact beta_conv_hnf.exact univ_v6_dec. Qed. Axiom v6_normalise : forall (e : env_v6) (t T : trm_v6), typ_v6 e t T -> v6_sn e t. Lemma sound_v6_beta : rule_sound _ v6_pts (beta _). simpl in |- *. apply beta_sound; auto with arith pts. simpl in |- *. apply cumul_inv_prod. exact v6_is_subtype_dec. Qed. Lemma v6_is_norm_sound : norm_sound_CTS _ v6. Proof. refine (Build_norm_sound_CTS srt_v6 v6 sound_v6_beta v6_normalise _ _ _). left. apply v6_inf_axiom.exact v6_inf_rule.intros. elim v6_inf_axiom with s1; intros. split with x. apply (pp_ok p). Qed. Theorem v6_algorithms : PTS_TC _ v6_pts. 
+ term_size e | Ehalt _ => 1 end with funs_size fds : nat := match fds with | Fcons _ _ _ e fds' => 1 + funs_size fds' + term_size e | Fnil => 1 end. Definition svalue_size (v: svalue) : nat := match v with | SVconstr t lv => 0 | SVfun t lv e => term_size e end. Definition svalue_inl_size (f:(positive*svalue)) (inl:b_map): nat := (if (get_b (fst f) inl) then 0 else svalue_size (snd f)). Theorem svalue_inl_le: forall i v im, svalue_inl_size (i,v) im <= svalue_size v. Proof. intros. unfold svalue_inl_size. simpl. destruct (get_b i im). apply Peano.le_0_n. auto. Defined. Lemma term_size_inline_letapp e x C y e' : inline_letapp e x = Some (C, y) -> term_size (C |[ e' ]|) <= term_size e + term_size e'. Proof. generalize C. induction e; intros C' Heq; simpl in *; try ((destruct (inline_letapp e x) as [ [C'' z'] | ] eqn:Heq''; try congruence); inv Heq; simpl; eauto using Peano.le_n_S). congruence. eapply Peano.le_n_S. specialize (IHe C'' (eq_refl)). lia. inv Heq. simpl. reflexivity. inv Heq. simpl. eauto. Defined. Definition list_inl_size (sub:list (positive*svalue)) (inl:b_map):= fold_right plus 0 (map (fun v => svalue_inl_size v inl) sub). Theorem list_inl_size_app: forall l l' inl, list_inl_size (l++l') inl = list_inl_size l inl + list_inl_size l' inl . Proof. induction l; intros. reflexivity. unfold list_inl_size. simpl. unfold list_inl_size in IHl. rewrite IHl. rewrite <- Nat.add_assoc. reflexivity. Qed. Definition sub_inl_size (sub:ctx_map) (inl:b_map):= fold_left plus (map (fun v => svalue_inl_size v inl) (M.elements sub)) 0. Theorem sub_inl_proof: forall sub inl, sub_inl_size sub inl = list_inl_size (M.elements sub) inl. Proof. unfold sub_inl_size, list_inl_size. intros. apply fold_symmetric; intros; lia. Qed. Theorem min_term_size: forall e, 1 <= term_size e. Proof. intro. destruct e; simpl; apply lt_le_S; apply Nat.lt_0_succ. Defined. Theorem min_funs_size: forall f, 1 <= funs_size f. Proof. destruct f; simpl; apply lt_le_S; apply Nat.lt_0_succ. Defined. Theorem funs_size_append: forall f2 f1, funs_size (fundefs_append f1 f2) = funs_size f1 + funs_size f2 - 1. Proof. induction f1; simpl; intros. rewrite IHf1. assert (Hf2 := min_funs_size f2). assert (Hf1 := min_funs_size f1). lia. lia. Defined. Definition term_sub_inl_size (esi: (exp * ctx_map * b_map)): nat := term_size (fst (fst esi)) + sub_inl_size (snd (fst esi)) (snd esi). Theorem NoDup_list_norepet: forall {A} (l:list A), NoDup l <-> Coqlib.list_norepet l. Proof. intros. induction l; split; intro; auto. constructor. constructor. inv H; constructor; eauto. apply IHl. auto. inv H; constructor; auto. apply IHl. auto. Qed. Theorem fold_right_plus_init: forall l n, fold_right plus n l = fold_right plus 0 l + n. 
move/andP: H0 => [] H0 _. cbn in H0. now eapply eqb_eq in H0. - intros _. eapply IHwf_glob. Qed.Lemma wellformed_lookup_constructor_pars {Σ kn c mdecl idecl cdecl} : wf_glob Σ -> lookup_constructor Σ kn c = Some (mdecl, idecl, cdecl) -> mdecl.(ind_npars) = 0. Proof. intros wf. cbn -[lookup_minductive]. destruct lookup_minductive eqn:hl => //. do 2 destruct nth_error => //. eapply wellformed_lookup_inductive_pars in hl => //. congruence. Qed.Lemma lookup_constructor_pars_args_spec {Σ ind n mdecl idecl cdecl} : wf_glob Σ -> lookup_constructor Σ ind n = Some (mdecl, idecl, cdecl) -> lookup_constructor_pars_args Σ ind n = Some (mdecl.(ind_npars), cdecl.(cstr_nargs)). Proof. cbn -[lookup_constructor] => wfΣ. destruct lookup_constructor as [[[mdecl' idecl'] [pars args]]|] eqn:hl => //. intros [= -> -> <-]. cbn. f_equal. Qed.Lemma wellformed_lookup_constructor_pars_args {Σ ind n k args} : wf_glob Σ -> wellformed Σ k (EAst.tConstruct ind n args) -> ∑ nargs, lookup_constructor_pars_args Σ ind n = Some (0, nargs). Proof. intros wfΣ wf. cbn -[lookup_constructor] in wf. destruct lookup_constructor as [[[mdecl idecl] cdecl]|] eqn:hl => //. exists cdecl.(cstr_nargs). pose proof (wellformed_lookup_constructor_pars wfΣ hl). eapply lookup_constructor_pars_args_spec in hl => //. congruence. Qed.Lemma constructor_isprop_pars_decl_params {Σ ind c b pars cdecl} : wf_glob Σ -> constructor_isprop_pars_decl Σ ind c = Some (b, pars, cdecl) -> pars = 0. Proof. intros hwf. rewrite /constructor_isprop_pars_decl /lookup_constructor /lookup_inductive. destruct lookup_minductive as [mdecl|] eqn:hl => /= //. do 2 destruct nth_error => //. eapply wellformed_lookup_inductive_pars in hl => //. congruence. Qed.Lemma compile_mkApps_wf (P : Term -> Prop) Σ k fn args : wf_glob Σ -> ~~ EAst.isApp fn -> wellformed Σ k (mkApps fn args) -> P (TmkApps (compile fn) (list_terms (map (compile ) args))) -> P (compile (mkApps fn args)). Proof. intros wfΣ napp. rewrite wellformed_mkApps // => /andP[] wffn wfargs. rewrite compile_mkApps_nApp //. Qed.Lemma compile_decompose f : compile f = let (fn, args) := decompose_app f in TmkApps (compile fn) (compile_terms args). Proof. destruct (decompose_app f) eqn:da. rewrite (decompose_app_inv da). apply compile_mkApps_nApp. now eapply decompose_app_notApp. Qed.Inductive Forall2_terms (P : Term -> Term -> Prop) : Terms -> Terms -> Prop := | Forall2_nil_terms : Forall2_terms P tnil tnil | Forall2_cons_terms t t' l l' : P t t' -> Forall2_terms P l l' -> Forall2_terms P (tcons t l) (tcons t' l').Section Reverse_Induction. Lemma trev_list_ind : forall P:Terms -> Type, P tnil -> (forall (a:Term) (l:Terms), P (treverse l) -> P (treverse (tcons a l))) -> forall l, P (treverse l). Proof. induction l; auto. Qed. Theorem trev_ind : forall P:Terms -> Type, P tnil -> (forall x l, P l -> P (tappend l (tcons x tnil))) -> forall l, P l. 
E sigma -> FAeq ⊢I (embed_problem E)[sigma >> num]. Proof. intros [a b] sigma HE. cbn -[FAeq]. eapply transitivity; firstorder. apply prv_poly; firstorder. apply symmetry; firstorder. unfold H10p_sem in *. cbn in HE. rewrite HE. apply prv_poly; firstorder. Qed. Section FA_ext_Model. Context {D : Type}. Context {I : interp D}. Hypothesis ext_model : extensional I. Hypothesis FA_model : forall ax rho, In ax FA -> rho ⊨ ax. Notation "'iO'" := (i_func (f:=Zero) (Vector.nil D)) (at level 2) : PA_Notation. Fact eval_poly sigma p : eval (sigma >> iμ) (embed_poly p) = iμ (dp_eval_pfree sigma p). Proof using ext_model FA_model. induction p; cbn. - now rewrite eval_num. - reflexivity. - destruct d; cbn. + now rewrite IHp1, IHp2, add_hom. + now rewrite IHp1, IHp2, mult_hom. Qed. Lemma problem_to_ext_model : forall E sigma, H10p_sem E sigma -> (sigma >> iμ) ⊨ embed_problem E. Proof using ext_model FA_model. intros [a b] sigma Hs. cbn -[sat]. unfold H10p_sem in *. cbn -[FA] in *. apply ext_model. rewrite !eval_poly. congruence. Qed. End FA_ext_Model.Section FA_Model. Context {D : Type}. Context {I : interp D}. Hypothesis FA_model : forall rho ax, In ax FAeq -> rho ⊨ ax. Notation "'iO'" := (i_func (f:=Zero) (Vector.nil D)) (at level 2) : PA_Notation. Lemma problem_to_model E sigma : H10p_sem E sigma -> (sigma >> iμ) ⊨ embed_problem E. Proof using FA_model. intros HE%problem_to_prv%soundness. specialize (HE D I). setoid_rewrite sat_comp in HE. eapply sat_ext. 2: apply HE. intros x. unfold ">>". now rewrite eval_num. intros. instantiate (1 := (fun _ => iO)). now apply FA_model. Qed. End FA_Model.Fact nat_eval_poly (sigma : env nat) p : @eval _ _ _ interp_nat sigma (embed_poly p) = dp_eval_pfree sigma p. Proof. induction p; cbn. - now rewrite nat_eval_num. - reflexivity. - destruct d; cbn. + now rewrite IHp1, IHp2. + now rewrite IHp1, IHp2. Qed. Lemma nat_sat : forall E rho, sat interp_nat rho (embed_problem E) <-> H10p_sem E rho. Proof. intros E rho. split. - destruct E as [a b]. unfold H10p_sem. cbn. now rewrite !nat_eval_poly. - intros. eapply (@sat_ext _ _ _ _ _ (rho >> @iμ nat interp_nat)). intros x. change ((rho >> iμ) x) with (@iμ nat interp_nat (rho x)). induction (rho x). reflexivity. cbn. now rewrite IHn. eapply problem_to_model. apply nat_is_FA_model. assumption. Qed. Lemma nat_sat' E : (exists sigma, sat interp_nat sigma (embed_problem E)) <-> H10p E. Proof. split; intros [sigma ]; exists sigma; now apply nat_sat. Qed. Theorem H10p_to_FA_ext_sat E : H10p E <-> ext_entailment_PA (embed E). 
Require Import compcert.lib.Coqlib. Require Import compcert.lib.Maps. Require Import compcert.lib.Integers. Require Import compcert.lib.Axioms.Require Import compcert.common.Values. Require Import compcert.common.Memory. Require Import compcert.common.Events. Require Import compcert.common.AST. Require Import compcert.common.Globalenvs. Require Import VST.msl.Extensionality. Require Import Coq.micromega.Lia.Require Import VST.sepcomp.mem_lemmas. Require Import VST.sepcomp.semantics.Require Import VST.msl.Coqlib2.Lemma mem_step_refl m: mem_step m m. apply (mem_step_freelist _ _ nil); trivial. Qed.Lemma mem_step_free: forall m b lo hi m', Mem.free m b lo hi = Some m' -> mem_step m m'. Proof. intros. eapply (mem_step_freelist _ _ ((b,lo,hi)::nil)). simpl. rewrite H; reflexivity. Qed.Lemma mem_step_store: forall m ch b a v m', Mem.store ch m b a v = Some m' -> mem_step m m'. Proof. intros. eapply mem_step_storebytes. eapply Mem.store_storebytes; eassumption. Qed.Record memstep_preserve (P:mem -> mem -> Prop) := { preserve_trans: forall m1 m2 m3, P m1 m2 -> P m2 m3 -> P m1 m3; preserve_mem: forall m m', mem_step m m' -> P m m' }.Lemma preserve_refl {P} (HP: memstep_preserve P): forall m, P m m. Proof. intros. eapply (preserve_mem _ HP). apply mem_step_refl. Qed.Lemma preserve_free {P} (HP: memstep_preserve P): forall m b lo hi m', Mem.free m b lo hi = Some m' -> P m m'. Proof. intros. eapply (preserve_mem _ HP). eapply mem_step_free; eauto. Qed.Theorem preserve_conj {P Q} (HP:memstep_preserve P) (HQ: memstep_preserve Q): memstep_preserve (fun m m' => P m m' /\ Q m m'). Proof. intros. constructor. + intros. destruct H; destruct H0. split. eapply HP; eauto. eapply HQ; eauto. + intros; split. apply HP; trivial. apply HQ; trivial. Qed. Theorem preserve_impl {A} (P:A -> mem -> mem -> Prop) (Q:A->Prop): (forall a, Q a -> memstep_preserve (P a)) -> memstep_preserve (fun m m' => forall a, Q a -> P a m m'). 
-> C) -> (FunctionalRelReification -> C). Proof. intros C H FunReify. assert (DepFunReify := non_dep_dep_functional_rel_reification FunReify). pose (A0 := { A:Type & { P:A->Prop & exists! x, P x }}). pose (B0 := fun x:A0 => projT1 x). pose (R0 := fun x:A0 => fun y:B0 x => projT1 (projT2 x) y). pose (H0 := fun x:A0 => projT2 (projT2 x)). destruct (DepFunReify A0 B0 R0 H0) as (f, Hf). apply H. intros A P H'. exists (f (existT _ A (existT _ P H'))). pose (Hf' := Hf (existT _ A (existT _ P H'))). assumption. Qed.Lemma constructive_definite_descr_fun_reification : ConstructiveDefiniteDescription -> FunctionalRelReification. Proof. intros DefDescr A B R H. exists (fun x => proj1_sig (DefDescr B (R x) (H x))). intro x. apply (proj2_sig (DefDescr B (R x) (H x))). Qed. Require Import Setoid.Theorem constructive_definite_descr_excluded_middle : (forall A : Type, ConstructiveDefiniteDescription_on A) -> (forall P:Prop, P \/ ~ P) -> (forall P:Prop, {P} + {~ P}). Proof. intros Descr EM P. pose (select := fun b:bool => if b then P else ~P). assert { b:bool | select b } as ([|],HP). red in Descr. apply Descr. rewrite <- unique_existence; split. destruct (EM P). exists true; trivial. exists false; trivial. intros [|] [|] H1 H2; simpl in *; reflexivity || contradiction. left; trivial. right; trivial. Qed.Corollary fun_reification_descr_computational_excluded_middle_in_prop_context : FunctionalRelReification -> (forall P:Prop, P \/ ~ P) -> forall C:Prop, ((forall P:Prop, {P} + {~ P}) -> C) -> C. Proof. intros FunReify EM C H. intuition auto using constructive_definite_descr_excluded_middle, (relative_non_contradiction_of_definite_descr (C:=C)). Qed.Require Import Arith.Theorem functional_choice_imp_functional_dependent_choice : FunctionalChoice -> FunctionalDependentChoice. Proof. intros FunChoice A R HRfun x0. apply FunChoice in HRfun as (g,Rg). set (f:=fix f n := match n with 0 => x0 | S n' => g (f n') end). exists f; firstorder. Qed.Theorem functional_dependent_choice_imp_functional_countable_choice : FunctionalDependentChoice -> FunctionalCountableChoice. Proof. intros H A R H0. set (R' (p q:nat*A) := fst q = S (fst p) /\ R (fst p) (snd q)). destruct (H0 0) as (y0,Hy0). destruct H with (R:=R') (x0:=(0,y0)) as (f,(Hf0,HfS)). intro x; destruct (H0 (fst x)) as (y,Hy). exists (S (fst x),y). red. auto. assert (Heq:forall n, fst (f n) = n). induction n. rewrite Hf0; reflexivity. specialize HfS with n; destruct HfS as (->,_); congruence. exists (fun n => snd (f (S n))). intro n'. specialize HfS with n'. destruct HfS as (_,HR). rewrite Heq in HR. assumption. Qed. Require Import ClassicalFacts PropExtensionalityFacts. Theorem repr_fun_choice_imp_ext_prop_repr : RepresentativeFunctionalChoice -> ExtensionalPropositionRepresentative. 
limit_ofs) /\ deref_loc valPtr m' tinf_b (Int.add tinf_ofs (Int.repr (3*int_size))) (Vptr args_b args_ofs) /\ mem_same_block args_b m m' /\ (forall lenv' : temp_env, forall vsm4 vs7 vars, lenv_param_asgn (M.set argsIdent (Vptr args_b args_ofs) (M.set limitIdent (Vptr alloc_b limit_ofs) (M.set allocIdent (Vptr alloc_b alloc_ofs) (Maps.PTree.set tinfIdent (Vptr tinf_b tinf_ofs) (create_undef_temps vars))))) lenv' vsm4 vs7 -> rel_mem_L6_L7_id fenv finfo_env p rep_env e rho m' lenv' /\ correct_tinfo p (Int.unsigned finfo_maxalloc) lenv' m'). *) Inductive rel_mem_asgn {fenv finfo_env p rep_env} args_b args_ofs m L: list L6.cps.val -> list N -> list Values.val -> Prop := | rma_cons: forall i v6 v7 vs6 inf vs7, rel_mem_asgn args_b args_ofs m L vs6 inf vs7 -> Mem.loadv int_chunk m (Vptr args_b (Ptrofs.add args_ofs (Ptrofs.repr (int_size * (Z.of_N i))))) = Some v7 -> repr_val_L_L6_L7_id fenv finfo_env p rep_env v6 m L v7 -> rel_mem_asgn args_b args_ofs m L (v6::vs6) (i::inf) (v7::vs7) | rma_nil: rel_mem_asgn args_b args_ofs m L [] [] []. Theorem rel_mem_asgn_length: forall {fenv finfo_env p rep_env m L args_b args_ofs ys inf vs}, @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L ys inf vs -> length ys = length vs. Proof. induction ys; intros. inv H; auto. inv H. simpl. erewrite IHys. reflexivity. eauto. Qed. Theorem rel_mem_asgn_nthN: forall {L rep_env finfo_env fenv args_b args_ofs p m vs6 inf vs7 v6 v7 n}, @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L vs6 inf vs7 -> nthN vs6 n = Some v6 -> nthN vs7 n = Some v7 -> repr_val_L_L6_L7_id fenv finfo_env p rep_env v6 m L v7. Proof. induction vs6; intros. inv H0. destruct vs7. inv H1. inv H. destruct n. inv H0; inv H1; auto. apply nthN_pos_pred in H0. apply nthN_pos_pred in H1. eapply IHvs6; eauto. Qed. Theorem cons_get_list: forall {A y ys rho vs}, @get_list A (y::ys) rho = Some vs -> exists v vs', v::vs' = vs /\ M.get y rho = Some v /\ @get_list A ys rho = Some vs'. Proof. intros. simpl in H. destruct (M.get y rho) eqn:Hgy; destruct (get_list ys rho) eqn:Hgys. exists a, l. split. inv H; auto. split; reflexivity. inv H. inv H. inv H. Qed. Theorem rel_mem_after_asgn: forall fenv finfo_env p rep_env args_b args_ofs m L vs6 locs vs7, @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L vs6 locs vs7 -> mem_after_asgn args_b args_ofs m locs vs7. Proof. induction vs6; intros. - inv H. constructor. - inv H. constructor; eauto. Qed. Theorem rel_mem_of_asgn: forall fenv finfo_env rep_env args_b args_ofs p lenv m rho L ys inf vs7 vs6, mem_of_asgn_v args_b args_ofs p lenv m ys inf vs7 -> get_list ys rho = Some vs6 -> (forall x, List.In x ys -> exists v6, M.get x rho = Some v6 /\ repr_val_id_L_L6_L7_id fenv finfo_env p rep_env v6 m L lenv x) -> @rel_mem_asgn fenv finfo_env p rep_env args_b args_ofs m L vs6 inf vs7. 
y)); auto with sets. intro H'5; try assumption. elim H'1. exists z; auto with sets. Qed. Theorem Add_covers : forall A a:Ensemble U, Included U a A -> forall x:U, In U A x -> ~ In U a x -> covers (Ensemble U) (Power_set_PO U A) (Add U a x) a. Proof. intros A a H' x H'0 H'1; try assumption. apply setcover_intro; auto with sets. red. split; [ idtac | red; intro H'2; try exact H'2 ]; auto with sets. apply H'1. rewrite H'2; auto with sets. red; intro H'2; elim H'2; clear H'2. intros z H'2; elim H'2; intros H'3 H'4; try exact H'3; clear H'2. lapply (Strict_Included_inv U a z); auto with sets; clear H'3. intro H'2; elim H'2; intros H'3 H'5; elim H'5; clear H'2 H'5. intros x0 H'2; elim H'2. intros H'5 H'6; try assumption. generalize H'4; intro K. red in H'4. elim H'4; intros H'8 H'9; red in H'8; clear H'4. lapply (H'8 x0); auto with sets. intro H'7; try assumption. elim (Add_inv U a x x0); auto with sets. intro H'15. cut (Included U (Add U a x) z). intro H'10; try assumption. red in K. elim K; intros H'11 H'12; apply H'12; clear K; auto with sets. rewrite H'15. red. intros x1 H'10; elim H'10; auto with sets. intros x2 H'11; elim H'11; auto with sets. Qed. Theorem covers_Add : forall A a a':Ensemble U, Included U a A -> Included U a' A -> covers (Ensemble U) (Power_set_PO U A) a' a -> exists x : _, a' = Add U a x /\ In U A x /\ ~ In U a x. Proof. intros A a a' H' H'0 H'1; try assumption. elim (setcover_inv A a a'); auto with sets. intros H'6 H'7. clear H'1. elim (Strict_Included_inv U a a'); auto with sets. intros H'5 H'8; elim H'8. intros x H'1; elim H'1. intros H'2 H'3; try assumption. exists x. split; [ try assumption | idtac ]. clear H'8 H'1. elim (H'7 (Add U a x)); auto with sets. intro H'1. absurd (a = Add U a x); auto with sets. red; intro H'8; try exact H'8. apply H'3. rewrite H'8; auto with sets. auto with sets. red. intros x0 H'1; elim H'1; auto with sets. intros x1 H'8; elim H'8; auto with sets. split; [ idtac | try assumption ]. red in H'0; auto with sets. Qed. Theorem covers_is_Add : forall A a a':Ensemble U, Included U a A -> Included U a' A -> (covers (Ensemble U) (Power_set_PO U A) a' a <-> (exists x : _, a' = Add U a x /\ In U A x /\ ~ In U a x)). 
in H; lia. Qed. Definition Zp_lprod := fold_right Zp_mult Zp_one. Fact Zp_lprod_nil : Zp_lprod nil = Op. Proof. trivial. Qed. Fact Zp_lprod_cons x l : Zp_lprod (x::l) = x ⊗ Zp_lprod l. Proof. trivial. Qed. Fact Zp_lprod_app l m : Zp_lprod (l++m) = Zp_lprod l ⊗ Zp_lprod m. Proof. induction l as [ | x l IHl ]. + rewrite Zp_lprod_nil, Zp_mult_one; auto. + simpl app; do 2 rewrite Zp_lprod_cons. rewrite IHl; ring. Qed. Theorem Zp_mult_autoinv l : ~ list_has_dup l -> (forall x, In x l -> x <> Zp /\ inv x <> x /\ In (inv x) l) -> Zp_lprod l = Op. Proof. induction on l as IHl with measure (length l); intros H0 Hl. destruct l as [ | x l ]. + rewrite Zp_lprod_nil; auto. + destruct (Hl x) as (H1 & H2 & [H3 | H3]); try (simpl; auto; fail). 1: destruct H2; auto. destruct in_split with (1 := H3) as (u & v & ?); subst. rewrite Zp_lprod_cons, Zp_lprod_app, Zp_lprod_cons. rewrite (Zp_mult_assoc _ (inv x)), (Zp_mult_comm _ (inv x)). repeat rewrite Zp_mult_assoc. rewrite (Zp_mult_comm _ (inv x)), Zp_invert_spec2; auto. rewrite Zp_mult_one, <- Zp_lprod_app. apply IHl. * simpl; do 2 rewrite app_length; simpl; lia. * contradict H0. constructor 2. apply perm_list_has_dup with (inv x::u++v). - apply Permutation_cons_app; auto. - constructor 2; auto. * intros y Hy. destruct (Hl y) as (G1 & G2 & G3). - apply in_app_or in Hy; right; apply in_or_app; simpl; tauto. - repeat (split; auto). destruct G3 as [ G3 | G3 ]. ++ destruct H0; rewrite G3 at 2. rewrite Zp_invert_involutive. constructor 2. apply perm_list_has_dup with (y::u++v). ** apply Permutation_cons_app; auto. ** constructor 1; auto. ++ apply in_or_app. apply in_app_or in G3. destruct G3 as [ | [ G3 | ] ]; try tauto. exfalso. apply f_equal with (f := inv) in G3. do 2 rewrite Zp_invert_involutive in G3. destruct H0. apply perm_list_has_dup with (inv x::(x::u)++v). ** apply Permutation_cons_app with (l1 := x::u); auto. ** simpl; constructor 2; constructor 1; subst; auto. Qed. Fact Zp_lprod_fact n : 〚fact (S n)〛= Zp_lprod (map nat2Zp (list_an 2 n)). Proof using Hp'. induction n as [ | n IHn ]. + apply Zp_inj; simpl; auto. + rewrite fact_S, nat2Zp_mult. replace (S n)%nat with (n+1)%nat by lia. rewrite list_an_plus, map_app, Zp_lprod_app, <- IHn, Zp_mult_comm. f_equal. * do 2 f_equal; lia. * simpl list_an; unfold map. rewrite Zp_lprod_cons, Zp_mult_comm, Zp_mult_one. f_equal; lia. Qed. Theorem Wilson_thm_1 :〚fact (p-1)〛= ∸Op. 
& Hword1 & <-). generalize (reduce_step_subproof1 init stk prod Hv stk' (fun _ : True => Hv')). destruct goto_table as [[st' EQ]|]. - intros _. split=>//. change (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)). generalize (Non_terminal_pt prod ptl). rewrite ->EQ. intros pt. by constructor. - intros Hstk'. destruct Hword1; [|by destruct Hstk']. generalize (reduce_step_subproof0 init prod [] (fun _ : True => Hstk')). simpl in Hstk'. rewrite -Hstk' // => EQ. rewrite cast_eq. exists (Non_terminal_pt prod ptl). by split. Qed. Lemma step_invariant stk word buffer safe Hi : word_has_stack_semantics word stk -> match step safe init stk buffer Hi with | Accept_sr sem buffer_new => exists word_new (pt:parse_tree (NT (start_nt init)) word_new), (word ++ buffer = word_new ++ buffer_new)%buf /\ pt_sem pt = sem | Progress_sr stk_new buffer_new => exists word_new, (word ++ buffer = word_new ++ buffer_new)%buf /\ word_has_stack_semantics word_new stk_new | Fail_sr => True end. Proof. intros Hword_stk. unfold step. generalize (reduce_ok safe (state_of_stack init stk)). destruct action_table as [prod|awt]. - intros Hv. apply (reduce_step_invariant stk prod (fun _ => Hv) Hi word buffer) in Hword_stk. destruct reduce_step=>//. + destruct Hword_stk as (pt & <- & <-); eauto. + destruct Hword_stk as [<- ?]; eauto. - destruct buffer as [tok buffer]=>/=. move=> /(_ (token_term tok)) Hv. destruct (awt (token_term tok)) as [st EQ|prod|]=>//. + eexists _. split; [by apply app_buf_assoc with (l2 := [_])|]. change (token_sem tok) with (pt_sem (Terminal_pt tok)). generalize (Terminal_pt tok). generalize [tok]. rewrite -> EQ=>word' pt /=. by constructor. + apply (reduce_step_invariant stk prod (fun _ => Hv) Hi word (tok::buffer)) in Hword_stk. destruct reduce_step=>//. * destruct Hword_stk as (pt & <- & <-); eauto. * destruct Hword_stk as [<- ?]; eauto. Qed. Lemma parse_fix_invariant stk word buffer safe log_n_steps Hi : word_has_stack_semantics word stk -> match proj1_sig (parse_fix safe init stk buffer log_n_steps Hi) with | Accept_sr sem buffer_new => exists word_new (pt:parse_tree (NT (start_nt init)) word_new), (word ++ buffer = word_new ++ buffer_new)%buf /\ pt_sem pt = sem | Progress_sr stk_new buffer_new => exists word_new, (word ++ buffer = word_new ++ buffer_new)%buf /\ word_has_stack_semantics word_new stk_new | Fail_sr => True end. Proof. revert stk word buffer Hi. induction log_n_steps as [|log_n_steps IH]=>/= stk word buffer Hi Hstk; [by apply step_invariant|]. assert (IH1 := IH stk word buffer Hi Hstk). destruct parse_fix as [[] Hi']=>/=; try by apply IH1. destruct IH1 as (word' & -> & Hstk')=>//. by apply IH. Qed. Theorem parse_correct safe buffer log_n_steps: match parse safe init buffer log_n_steps with | Parsed_pr sem buffer_new => exists word_new (pt:parse_tree (NT (start_nt init)) word_new), buffer = (word_new ++ buffer_new)%buf /\ pt_sem pt = sem | _ => True end. 
⟦n⟧ -> nat ) ( ww : ∏ i : ⟦n⟧ , ( stn ( f i ) ) ≃ ( P i ) ) : ( ∏ x : ⟦n⟧ , P x ) ≃ stn ( stnprod f ). Proof. revert P f ww. induction n as [ | n IHn ]. - intros. simpl. apply ( weqcontrcontr ). + apply ( iscontrsecoverempty2 _ ( negstn0 ) ). + apply iscontrstn1. - intros. set ( w1 := weqdnicoprod n lastelement ). assert ( w2 := weqonsecbase P w1 ). assert ( w3 := weqsecovercoprodtoprod ( λ x : _, P ( w1 x ) ) ). assert ( w4 := weqcomp w2 w3 ) ; clear w2 w3. assert ( w5 := IHn ( λ x : ⟦n⟧, P ( w1 ( ii1 x ) ) ) ( λ x : ⟦n⟧, f ( w1 ( ii1 x ) ) ) ( λ i : ⟦n⟧, ww ( w1 ( ii1 i ) ) ) ). assert ( w6 := weqcomp w4 ( weqdirprodf w5 ( weqsecoverunit _ ) ) ) ; clear w4 w5. simpl in w6. assert ( w7 := weqcomp w6 ( weqdirprodf ( idweq _ ) ( invweq ( ww lastelement ) ) ) ). refine ( _ ∘ w7 )%weq. unfold w1. exact (weqfromprodofstn _ _ ). Defined.Theorem weqweqstnsn ( n : nat ) : (⟦S n⟧ ≃ ⟦S n⟧) ≃ ⟦S n⟧ × ( ⟦n⟧ ≃ ⟦n⟧ ). Proof. assert ( l := @lastelement n ). intermediate_weq ( isolated (⟦S n⟧) × (compl _ l ≃ compl _ l) ). { apply weqcutonweq. intro i. apply isdeceqstn. } apply weqdirprodf. - apply weqisolatedstntostn. - apply weqweq. apply invweq. intermediate_weq (compl_ne (⟦S n⟧) l (stnneq l)). + apply weqdnicompl. + apply compl_weq_compl_ne. Defined.Theorem weqfromweqstntostn ( n : nat ) : ( (⟦n⟧) ≃ (⟦n⟧) ) ≃ ⟦factorial n⟧. Proof. induction n as [ | n IHn ]. - simpl. apply ( weqcontrcontr ). + apply ( iscontraprop1 ). * apply ( isapropweqtoempty2 _ ( negstn0 ) ). * apply idweq. + apply iscontrstn1. - change ( factorial ( S n ) ) with ( ( S n ) * ( factorial n ) ). set ( w1 := weqweqstnsn n ). apply ( weqcomp w1 ( weqcomp ( weqdirprodf ( idweq _ ) IHn ) ( weqfromprodofstn _ _ ) ) ). Defined. Theorem ischoicebasestn ( n : nat ) : ischoicebase (⟦n⟧). 
v. Proof using Hb_nat. rewrite <- MZ_expo_A, mscal_plus; auto. f_equal; auto. Qed. Fact A_mult u v : A (u*v)%nat = MZ_expo u (A v). Proof using Hb_nat. rewrite <- MZ_expo_A, mscal_mult; auto. f_equal; auto. Qed. Fact A_plus_mult m n k l : (m = n + l * k)%nat -> A m = A n  MZ_expo l (A k). Proof using Hb_nat. intro; subst; rewrite A_plus, A_mult; auto. Qed. Fact MZ_det_B : MZ_det B = 1. Proof. simpl; ring. Qed. Lemma MZ_det_A n : MZ_det (A n) = 1. Proof using Hb_nat. rewrite <- MZ_expo_A. rewrite Det22_expo with (Rminus := Z.sub); auto. rewrite MZ_det_B. rewrite mscal_of_unit; auto. Qed. Definition Pell x y := x*x -b*x*y+y*y=1. Theorem alpha_Pell n : Pell (α (S n)) (α n). Proof using Hb_nat. unfold Pell. generalize (MZ_det_A n). unfold A; simpl; intros H. rewrite <- H. rewrite alpha_fix_3; ring. Qed. Fact A_iA n : A n  iA n = MZ_one. Proof using Hb_nat. generalize (alpha_Pell n); unfold Pell; intros H. apply M22_equal; try ring; simpl; rewrite alpha_fix_3, <- H; ring. Qed. Fact iA_A n : iA n  A n = MZ_one. Proof using Hb_nat. generalize (alpha_Pell n); unfold Pell; intros H. apply M22_equal; try ring; simpl; rewrite alpha_fix_3, <- H; ring. Qed. Fact A_minus u v : (v <= u)%nat -> A (u-v)%nat = A u  iA v. Proof using Hb_nat. intros H. rewrite <- (MZ_expo_A u). replace u with (u-v+v)%nat at 2 by lia. rewrite mscal_plus; auto. do 2 rewrite MZ_expo_A. rewrite <- M22mult_assoc with (1 := Zring). rewrite A_iA. rewrite M22mult_one_r with (1 := Zring). trivial. Qed. Section alpha_nat_coprime. Let A_eq_3_12 n : exists u v, u*α (S n) + v*α n = 1. Proof. generalize (alpha_Pell n); unfold Pell; intros H. exists (α (S n)-b*α n), (α n). rewrite <- H; ring. Qed. Lemma alpha_nat_coprime n : is_gcd (alpha_nat (S n)) (alpha_nat n) 1. Proof using Hb_nat. apply Z_coprime, (A_eq_3_12 (S n)). Qed. Corollary alpha_nat_odd n : (rem (alpha_nat (S n)) 2 = 1 \/ rem (alpha_nat n) 2 = 1)%nat. Proof using Hb_nat. destruct rem_2_is_0_or_1 with (x := alpha_nat (S n)) as [ H1 | ]; auto. destruct rem_2_is_0_or_1 with (x := alpha_nat n) as [ H2 | ]; auto. exfalso; generalize (alpha_nat_coprime n); intros (_ & _ & H3). destruct (H3 2%nat) as (? & ?); try lia; apply divides_rem_eq; auto. Qed. End alpha_nat_coprime. End Pell_inner. Theorem find_odd_alpha u : exists n, (u <= alpha_nat (S n) /\ rem (alpha_nat (S n)) 2 = 1)%nat. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). 
absurd (number_of_nodes (node t0 t3) <= number_of_nodes t). rewrite H1; simpl in |- *; auto with arith. apply inb_trans with (2 := H2); auto. apply number_of_nodes_inb_le; auto. intros t t0 t3 H0 H1 H2. absurd (number_of_nodes (node t0 t3) <= number_of_nodes t). rewrite H1; simpl in |- *; auto with arith. apply inb_trans with (2 := H2); auto. apply number_of_nodes_inb_le; auto. Qed. Definition btree_dec : forall a b : btree, {a = b} + {a <> b}. intros a; elim a. intros a1 b; case b. intros b1; case (eqA_dec a1 b1). intros e; left; rewrite e; auto. intros e; right; Contradict e; inversion e; auto. intros b0 b1; right; red in |- *; intros H; discriminate. intros b H b0 H0 b1; case b1. intros a0; right; red in |- *; intros H1; discriminate. intros b2 b3; case (H b2); intros H1. case (H0 b3); intros H2. left; rewrite H1; rewrite H2; auto. right; rewrite H1; Contradict H2; inversion H2; auto. right; Contradict H1; inversion H1; auto. Defined. Definition inb_dec : forall a p, {inb a p} + {~ inb a p}. intros a; elim a; simpl in |- *; auto; clear a. intros a p; elim p; simpl in |- *; auto; clear p. intros a1; case (eqA_dec a a1); intros Ha. left; rewrite Ha; simpl in |- *; auto. right; red in |- *; Contradict Ha; inversion Ha; auto. intros b [H| H]; auto. intros b0 [H1| H1]; auto. right; red in |- *; intros H2; inversion H2. case H; auto. case H1; auto. intros b H b0 H0 p; elim p; auto. intros a; right; red in |- *; intros H1; inversion H1. intros b1 H1 b2 H2. case H1; intros H3; auto. case H2; intros H4; auto. case (btree_dec (node b b0) (node b1 b2)); intros H5. left; rewrite H5; auto. right; red in |- *; intros H6; inversion H6; auto. case H5; rewrite H9; rewrite H10; auto. Defined. Fixpoint all_leaves (t : btree) : list A := match t with | leaf a => a :: nil | node t1 t2 => all_leaves t1 ++ all_leaves t2 end. Theorem all_leaves_in : forall t a, inb (leaf a) t -> In a (all_leaves t). Proof using. intros t; elim t; simpl in |- *; auto. intros a a0 H; inversion H; auto. intros b H b0 H0 a H1; apply in_or_app; inversion H1; auto. Qed. Theorem all_leaves_inb : forall t a, In a (all_leaves t) -> inb (leaf a) t. 
nat ) : isdeceq (stn n). Proof. intro. unfold isdeceq. intros x x' . apply (isisolatedinstn x x' ). Defined.Definition weqisolatedstntostn ( n : nat ) : weq ( isolated ( stn n ) ) ( stn n ) . Proof . intro . apply weqpr1 . intro x . apply iscontraprop1 . apply ( isapropisisolated ) . set ( int := isdeceqstn n x ) . assumption . Defined . Corollary isasetstn ( n : nat ) : isaset ( stn n ) . Proof. intro . apply ( isasetifdeceq _ ( isdeceqstn n ) ) . Defined . Definition stnposet ( i : nat ) : Poset . Proof. intro. unfold Poset . split with ( hSetpair ( stn i ) ( isasetstn i ) ) . unfold po. split with ( fun j1 j2 : stn i => natleh j1 j2 ) . split with ( fun j1 j2 j3 : stn i => istransnatleh j1 j2 j3 ) . exact ( fun j : stn i => isreflnatleh j ) . Defined. Definition lastelement ( n : nat ) : stn ( S n ) . Proof. intro . split with n . apply ( natgthsnn ( S n ) ) . Defined . Definition stnmtostnn ( m n : nat ) (isnatleh: natleh m n ) : stn m -> stn n := fun x : stn m => match x with tpair _ i is => stnpair _ i ( natlthlehtrans i m n is isnatleh ) end . Definition dni ( n : nat ) ( i : stn ( S n ) ) : stn n -> stn ( S n ) . Proof. intros n i x . destruct ( natlthorgeh x i ) . apply ( stnpair ( S n ) x ( natgthtogths _ _ ( pr2 x ) ) ) . apply ( stnpair ( S n ) ( S x ) ( pr2 x ) ) . Defined. Lemma dnicommsq ( n : nat ) ( i : stn ( S n ) ) : commsqstr( dni n i ) ( stntonat ( S n ) ) ( stntonat n ) ( di i ) . Proof. intros . intro x . unfold dni . unfold di . destruct ( natlthorgeh x i ) . simpl . apply idpath . simpl . apply idpath . Defined . Theorem dnihfsq ( n : nat ) ( i : stn ( S n ) ) : hfsqstr ( di i ) ( stntonat ( S n ) ) ( stntonat n ) ( dni n i ) . 
k, mb_is_opair mem k x y <-> π1 k = ⟬π1 x,π1 y⟭. Proof. intros (x & Hx) (y & Hy) (k & Hk); simpl. unfold mb_is_opair; simpl. split. + intros ((a & Ha) & (b & Hb) & H); revert H. repeat rewrite is_pair; simpl. intros (-> & -> & ->); auto. + intros ->. generalize Hx Hy Hk; revert Hx Hy Hk. do 3 rewrite <- p_bool_spec at 1. intros Hx' Hy' Hk' Hx Hy Hk. apply hfs_trans_opair_inv in Hk'; auto. do 2 rewrite p_bool_spec in Hk'. destruct Hk' as (H1 & H2). exists (exist _ (hfs_pair x x) H1). exists (exist _ (hfs_pair x y) H2). repeat rewrite is_pair; simpl; auto. Qed. Local Fact is_tuple n : forall v t, @mb_is_tuple _ mem t n v <-> π1 t = hfs_tuple (vec_map π1 v). Proof. induction n as [ | n IHn ]; intros v (t & Ht). + vec nil v; clear v; simpl; split. * intros H; apply hfs_mem_ext. intros z; split. - intros Hz. assert (Hz' : p_bool z = true). { apply p_bool_spec. apply Hp1 with (1 := Hz), p_bool_spec; auto. } destruct (H (exist _ z Hz')); auto. - rewrite hfs_empty_spec; tauto. * intros -> (z & ?); unfold mem; simpl. rewrite hfs_empty_spec; tauto. + vec split v with x; simpl; split. * intros (t' & H1 & H2). rewrite IHn in H2; try lia. rewrite <- H2. apply is_opair with (k := exist _ t Ht); auto. * intros ->. assert (H1 : p_bool (hfs_tuple (vec_map π1 v)) = true). { apply p_bool_spec. apply p_bool_spec in Ht. apply hfs_trans_opair_inv, proj2, hfs_trans_pair_inv in Ht; auto; tauto. } exists (exist _ (hfs_tuple (vec_map π1 v)) H1); split. - rewrite is_opair; simpl; auto. - rewrite IHn; simpl; auto. Qed. Local Fact has_tuples : mb_has_tuples mem yd nt. Proof. intros v Hv. set (t := hfs_tuple (vec_map (proj1_sig (P:=fun x : hfs => p_bool x = true)) v)). assert (H1 : p_bool t = true). { apply p_bool_spec, Hp6; auto; intro; rew vec; apply Hv. } exists (exist _ t H1). apply is_tuple; simpl; reflexivity. Qed. Local Definition i' x : Y := exist _ _ (p_bool_spec1 (Hp1 (Hi x) Hp2)). Local Fact Hi'' x : mem (i' x) yd. Proof. unfold i', yd, mem; simpl; auto. Qed. Hint Resolve Hi'' : core. Local Definition s' (y : Y) : X := s (π1 y). Theorem reln_hfs : { Y : Type & { _ : finite_t Y & { mem : Y -> Y -> Prop & { _ : forall u v, { mem u v } + { ~ mem u v } & { yd : Y & { yr : Y & { i : X -> Y & { s : Y -> X & (forall x, mem (i x) yd) /\ (forall y, mem y yd -> exists x, y = i x) /\ (forall v, R v <-> mb_is_tuple_in mem yr (vec_map i v)) }}}}}}}}. 
iDestruct (big_sepM_lookup_acc with "[$]") as "(Hk&_)"; eauto. iDestruct (gen_heap_valid with "[$] [$]") as %Hlook. iPureIntro. eapply Ha in Hlook. eauto. } iFrame. rewrite big_sepL_nil right_id. iApply wp_value. iFrame. iApply ("Hϕ" with "[-]"). simpl. iFrame. eauto. - monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iFrame. rewrite big_sepL_nil right_id. iApply ("IH" with "[$] [$]"). Qed. Lemma wp_WriteOp s E (a: u64) bc b0 b q l : {{{ ▷ (int.Z a d↦{#1}[bc] b0 ∗ mapsto_block l q b) }}} ExternalOp WriteOp (Val $ PairV (LitV $ LitInt a) (LitV $ LitLoc l)) @ s; E {{{ RET LitV LitUnit; ∃ b', ⌜ b' = bc ∨ b' = b ⌝ ∗ int.Z a d↦{#1}[b'] b ∗ mapsto_block l q b}}}. Proof. iIntros (Φ) ">H Hϕ". iDestruct "H" as "(Ha&Hl)". iApply wp_lift_atomic_head_step_no_fork; first by auto. iIntros (σ1 g1 ns mj D κ κs nt) "(Hσ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iDestruct (@gen_heap_valid with "Hd Ha") as %?. iDestruct (heap_valid_block with "Hσ Hl") as %?. iSplit. { iPureIntro. eexists _, _, _, _, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). unshelve (econstructor; eauto; [ econstructor; eauto| monad_simpl ]; econstructor; econstructor; eauto; econstructor; econstructor; eauto). exact true. } iNext; iIntros (v2 σ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (@gen_heap_update with "Hd Ha") as "[$ Ha]". assert (b = b1); [ | subst b1 ]. { apply Block_to_vals_ext_eq; intros. specialize (H0 i); specialize (H2 i); intuition. simpl in H4. destruct_with_eqn (σ1.(heap) !! (l +ₗ i)); try contradiction. destruct p as (n0&?); destruct n0; try contradiction. congruence. } iModIntro; iSplit; first done. iFrame. iApply ("Hϕ" with "[-]"). iExists _. iFrame. destruct x0; eauto. Qed. Definition disk_array (l: Z) (q: dfrac) (vs: list Block): iProp Σ := ([∗ list] i ↦ b ∈ vs, (l + i) d↦{q}[b] b)%I. Theorem disk_array_cons l q b vs : disk_array l q (b::vs) ⊣⊢ l d↦{q}[b] b ∗ disk_array (l + 1) q vs. Proof. rewrite /disk_array big_sepL_cons. rewrite Z.add_0_r. assert (forall l k, l + S k = l + 1 + k) by lia. setoid_rewrite H. reflexivity. Qed. Theorem disk_array_app l q vs1 vs2 : disk_array l q (vs1 ++ vs2) ⊣⊢ disk_array l q vs1 ∗ disk_array (l + length vs1) q vs2. Proof. rewrite /disk_array big_sepL_app. setoid_rewrite Nat2Z.inj_add. by setoid_rewrite Z.add_assoc. Qed. Theorem disk_array_emp l q : disk_array l q [] ⊣⊢ emp. 
Require Import Bool. Require Import Word. Require Import BFile Bytes Rec Inode. Require Import String. Require Import Pred. Require Import Arith. Require Import List ListUtils. Require Import FunctionalExtensionality. Require Import AsyncDisk. Require Import DirName. Require Import DirTreePath. Require Import DirTreeDef. Require Import DirTreePred. Require Import DirTreeRep. Require Import DirTreeNames. Require Import SepAuto. Require Import GenSepN. Import ListNotations. Fixpoint tree_inodes t := match t with | TreeFile inum f => [inum] | TreeDir inum ents => [inum] ++ (dirlist_combine tree_inodes ents) end. Definition tree_inodes_distinct t := NoDup (tree_inodes t). Hint Resolve in_or_app. Hint Resolve in_app_or. Hint Resolve NoDup_app_l. Hint Resolve NoDup_app_r. Theorem tree_inodes_distinct_child : forall n a d l, tree_inodes_distinct (TreeDir n ((a, d) :: l)) -> tree_inodes_distinct d. Proof. unfold tree_inodes_distinct; simpl; intros. rewrite cons_app in *. eauto. Qed. Theorem tree_inodes_distinct_head : forall n a d l, tree_inodes_distinct (TreeDir n ((a, d) :: l)) -> tree_inodes_distinct (TreeDir n ([(a,d)])). Proof. unfold tree_inodes_distinct; simpl; intros. rewrite cons_app in *. rewrite app_nil_r in *. rewrite app_assoc in H. eapply NoDup_app_l; eauto. Qed. Theorem dirtree_update_inode_absent : forall tree inum off v, ~ In inum (tree_inodes tree) -> dirtree_update_inode tree inum off v = tree. Proof. induction tree using dirtree_ind2; simpl in *; intros; intuition. - destruct (addr_eq_dec inum0 inum); congruence. - f_equal. induction tree_ents; simpl; auto. destruct a; simpl in *. inversion H. rewrite H4 by eauto. rewrite IHtree_ents; eauto. Qed. Theorem find_subtree_inum_present : forall pathname tree sub, find_subtree pathname tree = Some sub -> In (dirtree_inum sub) (tree_inodes tree). 
lt); intros hh ll H2. destruct (list_bool_dec hh ll) as [ H3 | H3 ]. * right. exists ln. destruct H1 as (H1 & H4). rewrite H2; auto. * left. destruct H1 as (H1 & H4). exists ln, nil. rewrite <- app_nil_end. split; auto. right. rewrite H2; auto. * left. destruct H1 as (lc & H1 & H2). exists ln, lc; split; auto. Qed. Hypothesis (Hp : out_code p (i,main_loop)). Let HP1 : forall x, pre x -> C1 x -> (i,main_loop) // (i,x) ->> (i,f x) /\ pre (f x). Proof. intros v (H1 & H2 & H3) (ln & lc & H4 & H5). split. apply main_loop_ko_spec with ln lc; auto. red; unfold f; rew vec; auto. Qed. Let HP2 : forall x, pre x -> C2 x -> exists y, (i,main_loop) // (i,x) ->> (p,y) /\ spec x y. Proof. intros v (H1 & H2 & H3) (ln & H4 & H5 & H6). apply main_loop_ok_spec with ln; auto. Qed. Let main_loop_sound_rec v : pre v -> (exists n, C2 (iter f v n)) -> exists n w, (i,main_loop) // (i,v) ->> (p,w) /\ spec (iter f v n) w. Proof. apply sss_loop_sound with (C1 := C1); auto. Qed. Let main_loop_complete_rec v w q : pre v -> out_code q (i,main_loop) -> (i,main_loop) // (i,v) ->> (q,w) -> p = q /\ exists n, C2 (iter f v n) /\ spec (iter f v n) w. Proof. apply sss_loop_complete with (C1 := C1); auto. apply bsm_sss_fun. Qed. Let iter_f_v v k : iter f v k = v[(iter list_bool_next (v#>s) k)/s]. Proof. revert v. unfold f; induction k as [ | k IHk ]; intros v; simpl; [ | rewrite IHk ]; rew vec. Qed. Let C2_eq v : v#>s = Zero::nil -> (exists n, C2 (iter f v n)) <-> tiles_solvable lt. Proof. unfold tiles_solvable. intros H1; simpl. split. intros (k & Hk). rewrite iter_f_v, H1 in Hk. destruct Hk as (ln & H2 & H3 & H4). revert H2; rew vec; intros H2. exists ln; repeat split; auto. intros E. subst ln. simpl in H2. apply iter_list_bool_next_nil in H2. destruct H2; discriminate. intros (ln & H2 & H3 & H4). destruct (@list_bool_next_total (list_nat_bool ln)) as (k & Hk). destruct ln as [ | [ | u ] ln ]; simpl; auto; discriminate. exists k. rewrite iter_f_v, H1, <- Hk. exists ln; rew vec; auto. Qed. Theorem main_loop_sound v : v#>s = Zero::nil -> v#>h = nil -> v#>l = nil -> v#>a = nil -> tiles_solvable lt -> exists w, (i,main_loop) // (i,v) ->> (p,w) /\ forall x, x <> s -> x <> a -> x <> h -> x <> l -> v#>x = w#>x. 
i n); lia. Qed.Theorem zero_ext_and: forall n x, 0 <= n -> zero_ext n x = and x (repr (two_p n - 1)). Proof. bit_solve. rewrite testbit_repr; auto. rewrite Ztestbit_two_p_m1; intuition. destruct (zlt i n). rewrite andb_true_r; auto. rewrite andb_false_r; auto. tauto. Qed.Theorem zero_ext_mod: forall n x, 0 <= n < zwordsize -> unsigned (zero_ext n x) = Z.modulo (unsigned x) (two_p n). Proof. intros. apply equal_same_bits. intros. rewrite Ztestbit_mod_two_p; auto. fold (testbit (zero_ext n x) i). destruct (zlt i zwordsize). rewrite bits_zero_ext; auto. rewrite bits_above. rewrite zlt_false; auto. lia. lia. lia. Qed.Theorem zero_ext_widen: forall x n n', 0 <= n <= n' -> zero_ext n' (zero_ext n x) = zero_ext n x. Proof. bit_solve. destruct (zlt i n). apply zlt_true. lia. destruct (zlt i n'); auto. tauto. tauto. Qed.Theorem sign_ext_widen: forall x n n', 0 < n <= n' -> sign_ext n' (sign_ext n x) = sign_ext n x. Proof. intros. destruct (zlt n' zwordsize). bit_solve. destruct (zlt i n'). auto. rewrite (zlt_false _ i n). destruct (zlt (n' - 1) n); f_equal; lia. lia. destruct (zlt i n'); lia. apply sign_ext_above; auto. Qed.Theorem sign_zero_ext_widen: forall x n n', 0 <= n < n' -> sign_ext n' (zero_ext n x) = zero_ext n x. Proof. intros. destruct (zlt n' zwordsize). bit_solve. destruct (zlt i n'). auto. rewrite !zlt_false. auto. lia. lia. lia. destruct (zlt i n'); lia. apply sign_ext_above; auto. Qed.Theorem zero_ext_narrow: forall x n n', 0 <= n <= n' -> zero_ext n (zero_ext n' x) = zero_ext n x. Proof. bit_solve. destruct (zlt i n). apply zlt_true. lia. auto. lia. lia. lia. Qed.Theorem sign_ext_narrow: forall x n n', 0 < n <= n' -> sign_ext n (sign_ext n' x) = sign_ext n x. Proof. intros. destruct (zlt n zwordsize). bit_solve. destruct (zlt i n); f_equal; apply zlt_true; lia. destruct (zlt i n); lia. rewrite (sign_ext_above n'). auto. lia. Qed.Theorem zero_sign_ext_narrow: forall x n n', 0 < n <= n' -> zero_ext n (sign_ext n' x) = zero_ext n x. Proof. intros. destruct (zlt n' zwordsize). bit_solve. destruct (zlt i n); auto. rewrite zlt_true; auto. lia. lia. lia. rewrite sign_ext_above; auto. Qed.Theorem zero_ext_idem: forall n x, 0 <= n -> zero_ext n (zero_ext n x) = zero_ext n x. Proof. intros. apply zero_ext_widen. lia. Qed.Theorem sign_ext_idem: forall n x, 0 < n -> sign_ext n (sign_ext n x) = sign_ext n x. Proof. intros. apply sign_ext_widen. lia. Qed. Theorem sign_ext_zero_ext: forall n x, 0 < n -> sign_ext n (zero_ext n x) = sign_ext n x. 
intros a1; simpl in |- *; red in |- *; intros [H1| H1]; auto. case H; injection H1; auto. case (H0 a1); simpl in |- *; auto. Qed. Hint Resolve not_null_cons : core. Theorem not_null_app : forall l1 l2 : list (A * list bool), not_null l1 -> not_null l2 -> not_null (l1 ++ l2). Proof using. intros l1; elim l1; simpl in |- *; auto. intros (a2, l2); case l2; auto. intros l H l0 H0 H1; case (H0 a2); simpl in |- *; auto. intros b l l0 H l3 H0 H1; apply not_null_cons; auto. red in |- *; intros H2; discriminate. apply H; auto. apply not_null_inv with (1 := H0). Qed. Hint Resolve not_null_app : core. Theorem not_null_map : forall (l : list (A * list bool)) b, not_null (map (fun v => match v with | (a1, b1) => (a1, b :: b1) end) l). Proof using. intros l; elim l; simpl in |- *; auto. intros b; red in |- *; intros a; red in |- *; intros H; inversion H. intros (a1, l1) l0 H b; apply not_null_cons; auto. red in |- *; intros; discriminate. Qed. Hint Resolve not_null_map : core. Inductive is_prefix : list bool -> list bool -> Prop := | prefixNull : forall l, is_prefix nil l | prefixCons : forall (b : bool) l1 l2, is_prefix l1 l2 -> is_prefix (b :: l1) (b :: l2). Hint Constructors is_prefix : core. Theorem is_prefix_refl : forall l, is_prefix l l. Proof using. intros l; elim l; simpl in |- *; auto. Qed. Hint Resolve is_prefix_refl : core. Definition unique_prefix (l : code) := (forall (a1 a2 : A) (lb1 lb2 : list bool), In (a1, lb1) l -> In (a2, lb2) l -> is_prefix lb1 lb2 -> a1 = a2) /\ unique_key l. Theorem unique_prefix_nil : unique_prefix nil. Proof using. split; auto. intros a1 a2 lb1 lb2 H; inversion H; auto. Qed. Hint Resolve unique_prefix_nil : core. Theorem unique_prefix1 : forall (c : code) (a1 a2 : A) (lb1 lb2 : list bool), unique_prefix c -> In (a1, lb1) c -> In (a2, lb2) c -> is_prefix lb1 lb2 -> a1 = a2. Proof using. intros c a1 a2 lb1 lb2 (H1, H2); apply (H1 a1 a2 lb1 lb2); auto. Qed. Theorem unique_prefix2 : forall c : code, unique_prefix c -> unique_key c. Proof using. intros c (H1, H2); auto. Qed. Theorem unique_prefix_inv : forall (c : code) (a : A) (l : list bool), unique_prefix ((a, l) :: c) -> unique_prefix c. 
:= NIndirect ^ S indlvl in {< F Fm IFs m0 sm m bxp l, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: Fm * indrep_n_tree indlvl bxp IFs ir l ]]] * [[ len <= length l ]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[ r = firstn len l ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indread_from_aligned indlvl lxp ir len ms. Proof. induction indlvl; cbn [indread_from_aligned]. + hoare. rewrite indrep_n_helper_0 in *; destruct_lifts. autorewrite with core. rewrite firstn_repeat; auto. rewrite repeat_length in *; omega. rewrite indrep_n_helper_valid by auto. cancel. f_equal. rewrite firstn_oob by indrep_n_tree_bound. auto. + step. step. erewrite indrep_n_tree_repeat_concat with (m := list2nmem m). 3: pred_apply; cancel. rewrite firstn_repeat; eauto. indrep_n_tree_bound. indrep_n_tree_bound. step. rewrite indrep_n_helper_valid by auto. cancel. rewrite firstn_oob by indrep_n_tree_bound. step. match goal with |- context [firstn ?k] => rewrite listmatch_split with (n := k) end. rewrite firstn_combine_comm. cancel. indrep_n_tree_bound. step. step. erewrite <- concat_hom_firstn by eauto. rewrite mul_div by mult_nonzero. auto. denote listmatch as Hl; pose proof Hl. prestep. norml. indrep_n_extract. erewrite indrep_n_length_pimpl in *. destruct_lifts. match goal with H: context [selN] |- _ => rename H into Hr end. cancel; hoare. - rewrite Hr; auto using mod_le_r. - erewrite <- firstn_hom_concat by eauto. auto. - indrep_n_tree_bound. denote le as He. destruct (le_lt_eq_dec _ _ He); subst. indrep_n_tree_bound. rewrite Nat.mod_mul in * by auto. congruence. - indrep_n_tree_bound. denote le as He. destruct (le_lt_eq_dec _ _ He); subst. indrep_n_tree_bound. rewrite Nat.mod_mul in * by auto. congruence. Unshelve. all: solve [eauto | exact $0]. Qed. Local Hint Extern 1 ({{_}} Bind (indread_from_aligned _ _ _ _ _ ) _) => apply indread_from_aligned_ok : prog. Definition indread_multiple_blocks indlvl lxp (indbns : list waddr) start len ms := let N := NIndirect ^ S indlvl in let^ (ms, rl) <- indread_to_aligned indlvl lxp #(selN indbns (start / N) $0) (start mod N) ms; let start' := start + (N - start mod N) in let len' := len - (N - start mod N) in let^ (ms, rm) <- indread_aligned indlvl lxp (firstn (len' / N) (skipn (start' / N) indbns)) ms; let len'' := len' mod N in let start'' := start' + (len' / N * N) in let^ (ms, rr) <- indread_from_aligned indlvl lxp #(selN indbns (start'' / N) $0) len'' ms; Ret ^(ms, rl ++ (rm ++ rr)). Theorem indread_multiple_blocks_ok : forall indlvl lxp indbns start len ms, let N := NIndirect ^ S indlvl in {< F Fm m0 sm m bxp l_part fsl, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * listmatch (fun x l => indrep_n_tree indlvl bxp (snd x) #(fst x) l) (combine indbns fsl) l_part) ]]] * [[ start < length (concat l_part) ]] * [[ (N - start mod N) < len ]] * [[ start + len < length (concat l_part) ]] * [[ length indbns = length fsl ]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[ r = firstn len (skipn start (concat l_part)) ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indread_multiple_blocks indlvl lxp indbns start len ms. 
-> list_rel RA (a1 :: tl1) (a2 :: tl2) . Hint Constructors list_rel : core. Definition function_rel {X}: relation (FMapAList.alist raw_id uvalue * @Stack.stack X * (FMapAList.alist raw_id dvalue * list (uvalue * (list uvalue -> itree L0 uvalue)))) := (Logic.eq × (Logic.eq × list_rel (refine_uvalue × (fun d1 d2 => forall x, eutt refine_uvalue (d1 x) (d2 x))))). Hint Unfold function_rel : core. Global Instance list_rel_refl {R: Type} {RR: relation R} `{Reflexive _ RR} : Reflexive (list_rel RR). Proof. intros l; induction l as [| hd tl IH]; auto. Qed. Global Instance function_rel_refl {X}: Reflexive (@function_rel X). Proof. repeat apply prod_rel_refl; auto. eapply list_rel_refl. Unshelve. apply prod_rel_refl; auto. apply refine_uvalue_Reflexive. intros ? ?. reflexivity. Qed. Lemma interp2_map_monad: forall {X} (f: X -> itree _ (uvalue * D.function_denotation)) (g: endo X) (l: list X) s1 s2, (forall x s1 s2, In x l -> eutt (Logic.eq × (Logic.eq × (refine_uvalue × (fun d1 d2 => forall x, eutt refine_uvalue (d1 x) (d2 x))))) (interp2 nil (f x) s1 s2) (interp2 nil (f (g x)) s1 s2)) -> eutt function_rel (interp2 nil (map_monad f l) s1 s2) (interp2 nil (map_monad f (map g l)) s1 s2). Proof. induction l as [| x l IH]; simpl; intros; [reflexivity |]. rewrite 2 interp2_bind. eapply eutt_clo_bind; eauto. intros (? & ? & ? & ?) (? & ? & ? & ?) EQ. repeat match goal with | h: prod_rel _ _ _ _ |- _ => inv h end. rewrite 2 interp2_bind. eapply eutt_clo_bind; eauto. intros (? & ? & ?) (? & ? & ?) EQ. inv EQ. repeat match goal with | h: prod_rel _ _ _ _ |- _ => inv h end. rewrite 2 interp2_ret. apply eqit_Ret. constructor; auto. Qed. *) Lemma swap_correct_L2: forall dt entry args intrinsics p, refine_mcfg_L2 dt entry args intrinsics p (swap_mcfg p). Proof. intros p. unfold refine_mcfg_L2. unfold model_to_L2. { admit. } Admitted. *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) *) Theorem swap_cfg_correct: transformation_correct swap_mcfg. 
:= forall n, (n < 4 * sz)%nat -> p ^+ $ (n) <> $0.Definition freeable (p : W) (sz : nat) := (sz >= 2)%nat /\ noWrapAround p sz.Lemma BigEnough : forall p sz, freeable p sz -> (sz >= 2)%nat. unfold freeable; tauto. Qed.Lemma SmallEnough : forall p sz, freeable p sz -> noWrapAround p sz. unfold freeable; tauto. Qed.Local Hint Immediate BigEnough SmallEnough. Local Hint Unfold freeable.Module Type FREE_LIST. Parameter freeList : nat -> W -> HProp. Parameter mallocHeap : W -> HProp. Axiom freeList_extensional : forall n p, HProp_extensional (freeList n p). Axiom mallocHeap_extensional : forall p, HProp_extensional (mallocHeap p). Axiom mallocHeap_fwd : forall p, mallocHeap p ===> Ex n, Ex p', p =*> p' * freeList n p'. Axiom mallocHeap_bwd : forall p, (Ex n, Ex p', p =*> p' * freeList n p') ===> mallocHeap p. Axiom nil_bwd : forall n p, p = 0 -> [| n = 0 |] ===> freeList n p. Axiom cons_bwd : forall n (p : W), p <> 0 -> (Ex n', Ex sz, Ex p', [| n = S n' |] * [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p') ===> freeList n p. Axiom cons_fwd : forall n (p : W), p <> 0 -> freeList n p ===> Ex n', Ex sz, Ex p', [| n = S n' |] * [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p'. End FREE_LIST.Module FreeList : FREE_LIST. Open Scope Sep_scope. Fixpoint freeList (n : nat) (p : W) : HProp := match n with | O => [| p = 0 |] | S n' => [| p <> 0 |] * Ex sz, Ex p', [| noWrapAround p (2 + wordToNat sz) |] * (p ==*> sz, p') * (p ^+ $8) =?> wordToNat sz * freeList n' p' end. Definition mallocHeap (p : W) := Ex n, Ex p', p =*> p' * freeList n p'. Theorem freeList_extensional : forall n p, HProp_extensional (freeList n p). destruct n; reflexivity. Qed. Theorem mallocHeap_extensional : forall p, HProp_extensional (mallocHeap p). reflexivity. Qed. Theorem mallocHeap_fwd : forall p, mallocHeap p ===> Ex n, Ex p', p =*> p' * freeList n p'. unfold mallocHeap; sepLemma. Qed. Theorem mallocHeap_bwd : forall p, (Ex n, Ex p', p =*> p' * freeList n p') ===> mallocHeap p. 
:= app (A:=btree A)); auto. apply trans_equal with (skip_n l2 (length l1 - length l1)). rewrite <- minus_n_n; simpl in |- *; auto. rewrite <- skip_n_app1; auto. rewrite H7. rewrite <- Eq2; rewrite Hp1. rewrite skip_n_app1. rewrite length_app. rewrite H6; rewrite minus_plus; simpl in |- *; auto. rewrite <- H6; rewrite length_app; simpl in |- *; auto with arith. intros [(ln4, HH)| (HH1, HH2)]. cut (ln0 = ln1 ++ ln4); [ intros E1 | apply app_inv_tail with (l1 := a :: b :: ln3); rewrite <- H3; rewrite HH; rewrite app_ass; auto ]. cut (l0 = l1 ++ skip_n l0 (length l1)). intros Eq1; rewrite Eq1; rewrite E1; repeat rewrite app_ass. apply height_pred_node; auto. apply H2 with (b := b); auto. intros n1 H8; apply H4; (rewrite E1; auto with datatypes). rewrite skip_n_length; rewrite <- Eq2; rewrite <- H6; rewrite <- skip_n_length; rewrite E1; rewrite skip_n_app2; auto; rewrite skip_n_id; simpl in |- *; auto. apply app_inv_head with (l1 := l1). rewrite <- app_ass; rewrite <- Eq1; auto. apply sym_equal; apply trans_equal with (2 := first_n_skip_n_app _ (length l1) l0). apply f_equal2 with (f := app (A:=btree A)); auto. apply trans_equal with (first_n (l1 ++ l2) (length l1)). rewrite first_n_app1; auto; rewrite <- minus_n_n; simpl in |- *; auto with datatypes. rewrite H7; rewrite first_n_app2; auto. rewrite <- H6; rewrite <- Eq2; rewrite E1; rewrite length_app; auto with arith. rewrite HH1 in H; case height_pred_disj_larger2 with (1 := H); simpl in |- *; auto. intros (n1, (HH3, HH4)); Contradict HH4; auto with arith. intros [(n1, (HH3, HH4))| ((HH3, (HH4, HH5)), HH6)]; [ case HH3 | idtac ]. case height_pred_larger_strict with (1 := H1) (n1 := b); auto. rewrite HH2; auto with datatypes. rewrite <- HH4; intros HH7; Contradict HH7; apply le_not_lt; auto with arith datatypes. intros (H8, H9); rewrite HH4; rewrite HH3; simpl in |- *. cut (l0 = nil); [ intros HM1; rewrite HM1 | idtac ]. cut (ln3 = nil); [ intros HM2; rewrite HM2 | idtac ]. replace l3 with (nil (A:=btree A)); simpl in |- *; auto. rewrite HH6 in H7; rewrite H9 in H7; rewrite HM1 in H7; simpl in H7; injection H7. intros Ht1 Ht2 Ht3; rewrite Ht2; rewrite Ht3; auto. generalize Eq4; rewrite HM2; case l3; simpl in |- *; auto; intros; discriminate. rewrite HH2 in H8; injection H8; auto. generalize H6; rewrite HH3; case l0; simpl in |- *; auto; intros; discriminate. Qed. Theorem height_pred_shrink : forall (n a b : nat) (ln1 ln2 : list nat) (t t1 t2 : btree A) (l1 l2 : list (btree A)), height_pred n (ln1 ++ a :: b :: ln2) (l1 ++ t1 :: t2 :: l2) t -> (forall n1 : nat, In n1 ln1 -> n1 < a) -> (forall n1 : nat, In n1 (b :: ln2) -> n1 <= a) -> length ln1 = length l1 -> height_pred n (ln1 ++ pred a :: ln2) (l1 ++ node t1 t2 :: l2) t. 
Some u.(u_alignment) | _ => None end. Variant Roption_leq {T} (R : T -> T -> Prop) : option T -> option T -> Prop := | Rleq_None {x} : Roption_leq R None x | Rleq_Some {x y} (_ : R x y) : Roption_leq R (Some x) (Some y). #[global] Instance proper_GlobDecl_size_of: Proper (GlobDecl_ler ==> Roption_leq eq) GlobDecl_size_of. Proof. rewrite /GlobDecl_size_of => x y Heq. repeat (case_match; try constructor); simplify_eq/= => //; apply require_eq_success in Heq; naive_solver. Qed. #[global] Instance proper_GlobDecl_align_of: Proper (GlobDecl_ler ==> Roption_leq eq) GlobDecl_align_of. Proof. rewrite /GlobDecl_align_of => x y Heq. repeat (case_match; try constructor); simplify_eq/= => //; apply require_eq_success in Heq; naive_solver. Qed.Fixpoint size_of (resolve : genv) (t : type) : option N := match t with | Tpointer _ => Some (pointer_size resolve) | Tref _ => None | Trv_ref _ => None | Tnum sz _ => Some (bytesN sz) | Tvoid => None | Tarray t n => N.mul n <$> size_of resolve t | Tnamed nm => glob_def resolve nm ≫= GlobDecl_size_of | Tfunction _ _ => None | Tbool => Some 1 | Tmember_pointer _ _ => None | Tqualified _ t => size_of resolve t | Tnullptr => Some (pointer_size resolve) | Tfloat sz => Some (bytesN sz) | Tarch sz _ => bytesN <$> sz end%N.#[global] Instance Proper_size_of : Proper (genv_leq ==> eq ==> Roption_leq eq) (@size_of). Proof. intros ?? Hle ? t ->; induction t; simpl; (try constructor) => //. all: try exact: pointer_size_proper. - by destruct IHt; constructor; subst. - move: Hle => [[ /(_ g) Hle _] _ _]. unfold glob_def. rewrite -tu_lookup_globals in Hle. destruct ((genv_tu x) !! g) as [g1| ]; last constructor. move: Hle => /(_ _ eq_refl). rewrite -tu_lookup_globals. move => [g2 [-> HH]] /=. exact: proper_GlobDecl_size_of. - by destruct o; constructor. Qed. Theorem size_of_int : forall {c : genv} s w, @size_of c (Tnum w s) = Some (bytesN w). Proof. reflexivity. Qed. Theorem size_of_char : forall {c : genv} s w, @size_of c (Tchar w s) = Some (bytesN w). Proof. reflexivity. Qed. Theorem size_of_bool : forall {c : genv}, @size_of c Tbool = Some 1%N. Proof. reflexivity. Qed. Theorem size_of_pointer : forall {c : genv} t, @size_of c (Tpointer t) = Some (pointer_size c). Proof. reflexivity. Qed. Theorem size_of_qualified : forall {c : genv} t q, @size_of c t = @size_of c (Tqualified q t). Proof. reflexivity. Qed. Theorem size_of_array_0 : forall {c : genv} t sz, @size_of c t = Some sz -> @size_of c (Tarray t 0) = Some 0%N. 
= 0 @a by <- sum_id_r x. Theorem sum_neg_0_uniq : unique (fun x => - x = 0) 0. Proof conj sum_0_neg (fun x H => eq_sym (sum_neg_0 x H)). Definition prod_is_id_l := Monoid.is_id_l E prod. Definition prod_is_id_r := Monoid.is_id_r E prod. Definition prod_is_id := Monoid.is_id E prod. Definition prod_monoid := Monoid.monoid E 1 {#} prod_is_assoc prod_id_l prod_id_r. Theorem prod_id : prod_is_id 1. Proof Monoid.op_id prod_monoid. Theorem prod_id_l_uniq : forall x : E, (Monoid.is_id_l E prod x) -> x = 1. Proof Monoid.op_id_l_uniq prod_monoid. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E prod x) -> x = 1. Proof Monoid.op_id_r_uniq prod_monoid. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E prod x) -> x = 1. Proof Monoid.op_id_uniq prod_monoid. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. Proof Monoid.op_intro_l prod_monoid. Theorem prod_intro_r : forall x y z : E, x = y -> x # z = y # z. Proof Monoid.op_intro_r prod_monoid. Definition prod_is_inv_l := Monoid.op_is_inv_l prod_monoid. Definition prod_is_inv_r := Monoid.op_is_inv_r prod_monoid. Definition prod_is_inv := Monoid.op_is_inv prod_monoid. Definition prod_has_inv_l := Monoid.has_inv_l prod_monoid. Definition prod_has_inv_r := Monoid.has_inv_r prod_monoid. Definition prod_has_inv := Monoid.has_inv prod_monoid. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. Proof Monoid.op_inv_l_r_eq prod_monoid. Theorem prod_inv_sym : forall x y : E, prod_is_inv x y <-> prod_is_inv y x. Proof Monoid.op_inv_sym prod_monoid. Theorem prod_cancel_l : forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y. Proof Monoid.op_cancel_l prod_monoid. Theorem prod_cancel_r : forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y. Proof Monoid.op_cancel_r prod_monoid. Theorem prod_inv_l_uniq : forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Monoid.op_inv_l_uniq prod_monoid. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Monoid.op_inv_r_uniq prod_monoid. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Monoid.op_inv_uniq prod_monoid. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. 
Require Export Arith. Require Export ArithRing. Require Export Lia. Require Export fib_ind. Fixpoint exp2 (n : nat) : nat := match n with 0 => 1 | S p => 2 * exp2 p end.Theorem div2_rect: forall (P : nat -> Type), P 0 -> P 1 -> (forall n, P n -> P (S (S n))) -> forall (n : nat), P n. Proof. intros P X0 X1 Xrec n; assert (P n * P (S n))%type. - elim n; intuition. - intuition. Defined. Theorem div2_spec: forall n, ({x : nat | 2 * x = n}) + ({x : nat | 2 * x + 1 = n}). Proof. intros n; induction n as [ | | n Hrec] using div2_rect. - left; now exists 0. - right; now exists 0. - destruct Hrec as [[x Heq]|[x Heq]]. + left; exists (S x); rewrite <- Heq; ring. + right; exists (S x); rewrite <- Heq; ring. Qed. Theorem half_smaller0: forall n x, 2 * x = S n -> (x < S n). Proof. intros; lia. Qed. Theorem half_smaller1: forall n x, 2 * x + 1 = n -> (x < n). 
k (List.map fst (a::x)) -> List.In k (List.map fst z) -> False). apply H. apply H2. simpl. right. apply H0. apply H1. + intros. inversion H; subst; clear H. unfold DisjKeyWeak. unfold DisjKeyWeak in H1. intros. assert (List.In k (List.map fst x) -> List.In k (List.map fst z) -> False). apply H1. simpl in H. inversion H;subst;clear H. - apply H0. apply H2. - apply H3. apply H4. apply H2. + apply W. + apply W. Qed.Theorem DisjKey_Cons2: forall T Q (a:(T*Q)) x z (W:forall (a1:T) (a2:T), {a1=a2}+{a1<>a2}), DisjKey x (a::z) <-> ((~(List.In (fst a) (List.map fst x))) /\ DisjKey x z). Proof. intros. rewrite ?DisjKeyWeak_same. split. + intros. split. - intros. unfold DisjKeyWeak in H. assert (List.In (fst a) (List.map fst x) -> List.In (fst a) (List.map fst (a::z)) -> False). apply H. intro X. apply H0. apply X. simpl. left. reflexivity. - simpl. intros. unfold DisjKeyWeak in H. unfold DisjKeyWeak. intros. assert (List.In k (List.map fst x) -> List.In k (List.map fst (a::z)) -> False). apply H. apply H2. apply H0. simpl. right. apply H1. + intros. inversion H; subst; clear H. unfold DisjKeyWeak. unfold DisjKeyWeak in H1. intros. inversion H2;subst;clear H2. - apply H0 in H. inversion H. - assert (List.In k (List.map fst x) -> List.In k (List.map fst z) -> False). apply H1. apply H2. apply H. apply H3. + apply W. + apply W. Qed.Theorem DisjKey_Append1: forall T Q (x:list (T*Q)) y z (W:forall (a1:T) (a2:T), {a1=a2}+{a1<>a2}), DisjKey (x++y) z<->(DisjKey x z /\ DisjKey y z). Proof. intros. rewrite ?DisjKeyWeak_same. induction x. + simpl. unfold DisjKeyWeak. simpl. split. - intros. * split. tauto. apply H. - intros. inversion H. subst. clear H. eapply H3. apply H0. apply H1. + simpl. repeat (rewrite <- DisjKeyWeak_same). rewrite ?DisjKey_Cons1. rewrite ?DisjKeyWeak_same. split. - intros. inversion H; subst; clear H. split. * split. ++ apply H0. ++ rewrite IHx in H1. inversion H1; subst; clear H1. apply H. * rewrite IHx in H1. inversion H1; subst; clear H1. apply H2. - simpl. intros. inversion H; subst; clear H. split. * inversion H0; subst; clear H0. apply H. * simpl. rewrite IHx. split. ++ inversion H0; subst; clear H0. apply H2. ++ simpl. apply H1. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. + apply W. + apply W. + apply W. Qed. Theorem DisjKey_Append2: forall T Q (x:list (T*Q)) y z (W:forall (a1:T) (a2:T), {a1=a2}+{a1<>a2}), DisjKey x (y++z)<->(DisjKey x y /\ DisjKey x z). 
unfold find_val in *; congruence. + assert (In x (gather_mems eqs)) as Hin by (apply Values1; congruence). clear Values1 Values2. induction eqs as [|[]]; simpl in Hin; try contradiction; inv Nodup; inversion_clear Heqs1 as [|?? Heq1]; inversion_clear Heqs2 as [|?? Heq2]; auto. destruct Hin; auto; subst. inversion_clear Heq1 as [| | |??????????? (Find1'&?)]; inversion_clear Heq2 as [| | |??????????? (Find2'&?)]; unfold find_val in *; congruence. + assert (In x (gather_mems eqs)) as Hin by (apply Values2; congruence). clear Values1 Values2. induction eqs as [|[]]; simpl in Hin; try contradiction; inv Nodup; inversion_clear Heqs1 as [|?? Heq1]; inversion_clear Heqs2 as [|?? Heq2]; auto. destruct Hin; auto; subst. inversion_clear Heq1 as [| | |??????????? (Find1'&?)]; inversion_clear Heq2 as [| | |??????????? (Find2'&?)]; unfold find_val in *; congruence. - clear Values1 Values2. constructor. + setoid_rewrite Env.Props.P.F.in_find_iff. intro i; split; intros Find. * apply Insts1 in Find. clear Insts1 Insts2. induction eqs as [|[]]; simpl in Find; try contradiction; inv Nodup; inversion_clear Heqs1 as [|?? Heq1]; inversion_clear Heqs2 as [|?? Heq2]; auto. apply InMembers_app in Find; destruct Find as [Find|]; auto. cases; inv Find; try contradiction. inversion_clear Heq2 as [|??????????? Hd|??????????????? Hd|]; inv Hd; unfold sub_inst_n, find_inst in *; congruence. * apply Insts2 in Find. clear Insts1 Insts2. induction eqs as [|[]]; simpl in Find; try contradiction; inv Nodup; inversion_clear Heqs1 as [|?? Heq1]; inversion_clear Heqs2 as [|?? Heq2]; auto. apply InMembers_app in Find; destruct Find as [Find|]; auto. cases; inv Find; try contradiction. inversion_clear Heq1 as [|??????????? Hd|??????????????? Hd|]; inv Hd; unfold sub_inst_n, find_inst in *; congruence. + setoid_rewrite Env.Props.P.F.find_mapsto_iff. intros i e e' Find1 Find2. assert (InMembers i (gather_insts eqs)) as Hin by (apply Insts1; congruence). clear Insts1 Insts2. induction eqs as [|[]]; simpl in Hin; try contradiction; inv Nodup; inversion_clear Heqs1 as [|?? Heq1]; inversion_clear Heqs2 as [|?? Heq2]; auto. apply InMembers_app in Hin; destruct Hin as [Hin|]; auto. cases; inv Hin; try contradiction. inversion Heq1 as [|??????????? Hd1 Find1'|??????????????? Hd1 Find1' ????? Reset1|]; subst; inversion_clear Heq2 as [|??????????? Hd2 Find2'|??????????????? Hd2 Find2' ????? Reset2|]; inv Hd1; inv Hd2; unfold sub_inst_n, find_inst in *; rewrite Find1' in Find1; inv Find1; rewrite Find2' in Find2; inv Find2; eauto. destruct (Reset1 (if rs 0 then pred (count rs 0) else count rs 0)) as (M01 & Node1 & MemMask1), (Reset2 (if rs0 0 then pred (count rs0 0) else count rs0 0)) as (M02 &?& MemMask2). rewrite MemMask1, MemMask2; eauto; simpl; cases. Qed. Theorem same_initial_memory: forall G f xss1 xss2 M1 M2 yss1 yss2, Ordered_nodes G -> msem_node G f xss1 M1 yss1 -> msem_node G f xss2 M2 yss2 -> M1 0 ≋ M2 0. 
rG = 'chi_i -> (A \in 'Z(R_G))%MS -> gring_op rG A = 'omega_i[A]%:M. Proof. move=> def_rG Z_A; rewrite unlock xcfunZl -{2}def_rG xcfun_repr. have irr_rG: mx_irreducible rG. have sim_rG: mx_rsim 'Chi_i rG by apply: cfRepr_inj; rewrite irrRepr. exact: mx_rsim_irr sim_rG (socle_irr _). have /is_scalar_mxP[e ->] := mx_irr_gring_op_center_scalar irr_rG Z_A. congr _%:M; apply: (canRL (mulKf (irr1_neq0 i))). by rewrite mulrC -def_rG cfunE repr_mx1 group1 -mxtraceZ scalemx1. Qed.Lemma irr_gring_center A : (A \in 'Z(R_G))%MS -> gring_op 'Chi_i A = 'omega_i[A]%:M. Proof. exact: cfRepr_gring_center (irrRepr i). Qed.Lemma gring_irr_modeM A B : (A \in 'Z(R_G))%MS -> (B \in 'Z(R_G))%MS -> 'omega_i[A *m B] = 'omega_i[A] * 'omega_i[B]. Proof. move=> Z_A Z_B; have [[R_A cRA] [R_B cRB]] := (center_mxP Z_A, center_mxP Z_B). apply: mxZn_inj; rewrite scalar_mxM -!irr_gring_center ?gring_opM //. apply/center_mxP; split=> [|C R_C]; first exact: envelop_mxM. by rewrite mulmxA cRA // -!mulmxA cRB. Qed.Lemma gring_mode_class_sum_eq (k : 'I_#|classes G|) g : g \in enum_val k -> 'omega_i['K_k] = #|g ^: G|%:R * 'chi_i g / 'chi_i 1%g. Proof. have /imsetP[x Gx DxG] := enum_valP k; rewrite DxG => /imsetP[u Gu ->{g}]. rewrite unlock classGidl ?cfunJ {u Gu}// mulrC mulr_natl. rewrite xcfunZl raddf_sum DxG -sumr_const /=; congr (_ * _). by apply: eq_bigr => _ /imsetP[u Gu ->]; rewrite xcfunG ?groupJ ?cfunJ. Qed. Lemma Aint_gring_mode_class_sum k : 'omega_i['K_k] \in Aint. Proof. move: k; pose X := [tuple 'omega_i['K_k] | k < #|classes G| ]. have memX k: 'omega_i['K_k] \in X by apply: image_f. have S_P := Cint_spanP X; set S := Cint_span X in S_P. have S_X: {subset X <= S} by apply: mem_Cint_span. have S_1: 1 \in S. apply: S_X; apply/codomP; exists (enum_rank_in (classes1 G) 1%g). rewrite (@gring_mode_class_sum_eq _ 1%g) ?enum_rankK_in ?classes1 //. by rewrite mulfK ?irr1_neq0 // class1G cards1. suffices Smul: mulr_closed S. by move=> k; apply: fin_Csubring_Aint S_P _ _; rewrite ?S_X. split=> // _ _ /S_P[x ->] /S_P[y ->]. rewrite mulr_sumr rpred_sum // => j _. rewrite mulrzAr mulr_suml rpredMz ?rpred_sum // => k _. rewrite mulrzAl rpredMz {x y}// !nth_mktuple. rewrite -gring_irr_modeM ?gring_class_sum_central //. rewrite gring_classM_expansion raddf_sum rpred_sum // => jk _. by rewrite scaler_nat raddfMn rpredMn ?S_X ?memX. Qed. Corollary Aint_class_div_irr1 x : x \in G -> #|x ^: G|%:R * 'chi_i x / 'chi_i 1%g \in Aint. Proof. move=> Gx; have clGxG := mem_classes Gx; pose k := enum_rank_in clGxG (x ^: G). have k_x: x \in enum_val k by rewrite enum_rankK_in // class_refl. by rewrite -(gring_mode_class_sum_eq k_x) Aint_gring_mode_class_sum. Qed. Theorem coprime_degree_support_cfcenter g : coprime (truncC ('chi_i 1%g)) #|g ^: G| -> g \notin ('Z('chi_i))%CF -> 'chi_i g = 0. 
Require Import ZArith. Require Import Omega Ring InitialRing. Require Import Recdef. Require Import Tactics.CpdtTactics.Set Implicit Arguments. Section Matrix2. Variable A : Type. Variable zero one : A. Variable add mul sub : A -> A -> A. Variable opp : A -> A. Variable rt : ring_theory zero one add mul sub opp (@eq A). Add Ring Aring : rt. Notation "0" := (zero). Notation "1" := (one). Notation "x + y" := (add x y). Notation "x - y" := (sub x y). Notation "x * y" := (mul x y). Record Matrix : Type := { c00 : A; c01 : A; c10 : A; c11 : A; }. Definition Matrix2 := Matrix. Definition Unit2 : Matrix2 := {| c00 := 1; c01 := 0; c10 := 0; c11 := 1; |}. Definition Matrix2_mul (m n : Matrix2) : Matrix2 := {| c00 := c00 m * c00 n + c01 m * c10 n; c01 := c00 m * c01 n + c01 m * c11 n; c10 := c10 m * c00 n + c11 m * c10 n; c11 := c10 m * c01 n + c11 m * c11 n; |}. Theorem Matrix2_mul_assoc : forall (m n p : Matrix2), Matrix2_mul m (Matrix2_mul n p) = Matrix2_mul (Matrix2_mul m n) p. Proof. intros; destruct m, n, p. unfold Matrix2_mul; simpl; f_equal; ring. Qed. Theorem Matrix2_left_Unit : forall (m : Matrix2), Matrix2_mul Unit2 m = m. Proof. intros; destruct m. unfold Unit2, Matrix2_mul; simpl; f_equal; ring. Qed. Theorem Matrix2_right_Unit : forall (m : Matrix2), Matrix2_mul m Unit2 = m. 
Heq]]. subst. apply IH... Qed.Lemma operation_monotone : ∀ y₀ G, y₀ ⋵ 𝐎𝐍 → G:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → ascending (Operation y₀ G) → monotone (Operation y₀ G). Proof with eauto. intros * Hoy₀ Hop Hasc. apply continuous_ascending_operation_monotone... apply operation_operative... apply operation_limit. Qed.Theorem operation_normal : ∀ y₀ G, y₀ ⋵ 𝐎𝐍 → G:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍 → ascending (Operation y₀ G) → normal (Operation y₀ G). Proof. intros. split. apply operation_monotone; auto. apply operation_limit. Qed.End 𝐎𝐍Operation.Module AlternativeAleph. Import 𝐎𝐍Operation.Definition ℵ' := Operation ℵ₀ (λ α, α₊). Fact alternative_aleph_correct : AC_III → ∀α ⋵ 𝐎𝐍, ℵ' α = ℵ α. Proof with auto. intros AC3. ord_induction. intros α Hoα IH. unfold ℵ'. ord_destruct α. - subst. rewrite operation_0, aleph_0... - destruct Hsuc as [β [Hoβ Heq]]. subst. rewrite operation_suc, aleph_suc... f_equal. apply IH... - rewrite operation_limit, aleph_limit... f_equal. apply repl_ext. intros ξ Hξ. apply IH... Qed.End AlternativeAleph. Section Beth. Import 𝐎𝐍Operation.Definition ℶ := Operation ℵ₀ (λ α, 2 ^ α).Theorem beth_0 : ℶ 0 = ℵ₀. Proof. apply operation_0. Qed.Theorem beth_suc : ∀α ⋵ 𝐎𝐍, ℶ α⁺ = 2 ^ ℶ α. Proof. apply operation_suc. Qed.Theorem beth_limit : continuous ℶ. Proof. apply operation_limit. Qed. Lemma beth_is_card : ℶ:ᶜ 𝐎𝐍 ⇒ 𝐂𝐃. Proof with eauto. intros α Hoα. ord_destruct α. - subst. rewrite beth_0... - destruct Hsuc as [β [Hoβ Heq]]. subst. rewrite beth_suc... - generalize dependent α. ord_induction. intros α Hoα IH Hne Hlim. rewrite beth_limit... apply union_of_cards_is_card. intros x Hx. apply ReplAx in Hx as [β [Hβ Hx]]. subst x. assert (Hoβ: β ⋵ 𝐎𝐍). eapply ord_is_ords... ord_destruct β. + subst. rewrite beth_0... + destruct Hsuc as [δ [Hoδ Heq]]. subst. rewrite beth_suc... + apply IH... Qed. Lemma beth_is_ord : ℶ:ᶜ 𝐎𝐍 ⇒ 𝐎𝐍. Proof. intros α Ho. apply card_is_ord. apply beth_is_card. apply Ho. Qed. Lemma beth_infinite : ℶ:ᶜ 𝐎𝐍 ⇒ infinite. Proof with nauto. ord_induction. intros α Hoα IH. ord_destruct α. - subst. rewrite beth_0... - destruct Hsuc as [β [Hoβ Heq]]. subst. rewrite beth_suc... assert (Hinf: infinite (ℶ β)). apply IH... apply cardExp_infinite_iff... apply beth_is_card... apply ord_le_to_cardLe... apply EmptyNI. apply infinite_set_nonempty... - rewrite beth_limit... intros Hfin. apply finite_union in Hfin as [_ Hfin]. assert (ℶ 0 ∈ {ℶ ξ | ξ ∊ α}). { eapply ReplI. apply ord_neq_0_gt_0... } apply Hfin in H. rewrite beth_0 in H. apply aleph0_infinite... Qed. Lemma beth_is_infcard : ℶ:ᶜ 𝐎𝐍 ⇒ 𝐂𝐃ⁱⁿ . Proof with auto. intros. split... apply beth_is_card... apply beth_infinite... Qed. Theorem beth_normal : normal ℶ. 
RegisterBank size := (gmap (fin size) nat). Module AbstractMachine. Parameter size: nat. Record MachineState := machine_state { program_counter: RegisterBank 1; registers: RegisterBank size }. Global Instance state_empty: Empty MachineState := machine_state empty empty. Global Instance state_union: Union MachineState := fun s1 s2 => (machine_state (union s1.(program_counter) s2.(program_counter)) (union s1.(registers) s2.(registers)) ). Theorem state_equality c1 c2 r1 r2: c1 = c2 /\ r1 = r2 <-> (machine_state c1 r1) = (machine_state c2 r2). Proof. naive_solver. Qed. Definition state_disjoint s1 s2 := map_disjoint s1.(program_counter) s2.(program_counter) /\ map_disjoint s1.(registers) s2.(registers). Global Instance state_disjoint_symmetric: Symmetric state_disjoint. Proof. intros ??; unfold state_disjoint; rewrite !map_disjoint_spec; naive_solver. Qed. Theorem state_union_commutative s1 s2: state_disjoint s1 s2 -> union s1 s2 = union s2 s1. Proof. intros [C R]; unfold union, state_union; rewrite (map_union_comm _ _ C); rewrite (map_union_comm _ _ R); reflexivity. Qed. Theorem state_disjoint_union_distributive s1 s2 s3: state_disjoint s1 (union s2 s3) <-> state_disjoint s1 s2 /\ state_disjoint s1 s3. Proof. split; unfold state_disjoint. - intros [?%map_disjoint_union_r ?%map_disjoint_union_r]; naive_solver. - intros [[] []]; split; apply map_disjoint_union_r_2; assumption. Qed. Theorem state_union_associative (s1 s2 s3: MachineState): union s1 (union s2 s3) = union (union s1 s2) s3. Proof. unfold union, state_union; simpl; apply state_equality; apply map_union_assoc. Qed. Theorem state_union_empty_l: forall state: MachineState, union empty state = state. Proof. unfold union, state_union; intros []; simpl; do 2 rewrite map_empty_union; reflexivity. Qed. Theorem state_union_empty_r: forall state: MachineState, union state empty = state. Proof. unfold union, state_union; intros []; simpl; do 2 rewrite map_union_empty; reflexivity. Qed. Theorem state_separate_counter_registers_disjoint: forall registers program_counter, state_disjoint (machine_state empty registers) (machine_state program_counter empty). Proof. intros; hnf; simpl; auto with map_disjoint. Qed. Theorem state_empty_disjoint: forall state, state_disjoint empty state. Proof. intros; hnf; simpl; auto with map_disjoint. Qed. Global Hint Extern 0 (state_disjoint _ _) => (split; assumption): core. Notation Assertion := (MachineState -> Prop) (only parsing). Declare Scope assertion_scope. Open Scope assertion_scope. Definition state_implies (H1 H2: Assertion): Prop := forall state, H1 state -> H2 state. Notation "H1 **> H2" := (state_implies H1 H2) (at level 55). Definition state_equivalent (H1 H2: Assertion): Prop := forall state, H1 state <-> H2 state. Notation "H1 <*> H2" := (state_equivalent H1 H2) (at level 60). Theorem state_implies_reflexive: forall H, H **> H. Proof. intros; hnf; trivial. Qed. Hint Resolve state_implies_reflexive: core. Theorem state_implies_transitive: forall H2 H1 H3, (H1 **> H2) -> (H2 **> H3) -> (H1 **> H3). Proof. intros ??? M1 M2 state H1state; auto. Qed. Hint Resolve state_implies_transitive: core. Theorem state_implies_antisymmetric: forall H1 H2, (H1 **> H2) -> (H2 **> H1) -> H1 <*> H2. 
else tree' ?b ?t1 p1) * tree' ?b ?t2 p2)%Sep] ] => let G := context C[(Ex i : W, Ex c : W, Ex p1 : W, Ex p2 : W, p =*> i * ((p ^+ $4) =*> c * ((p ^+ $8) =*> p1 * (p ^+ $12) =*> p2)) * tree'' b t1 p1 c * tree' b t2 p2)%Sep] in change G end. Theorem tree'_nil_fwd : forall b t (p : W), p = 0 -> tree' b t p ===> [| t = Leaf |]. destruct t; simpl; intros; try normalize; sepLemma. Qed. Theorem tree'_nil_bwd : forall b t (p : W), p = 0 -> [| t = Leaf |] ===> tree' b t p. destruct t; simpl; intros; try normalize; sepLemma. Qed. Theorem tree'_cons_fwd : forall b t (p : W), p <> 0 -> tree' b t p ===> Ex t1, Ex t2, Ex i, Ex c, Ex p1, Ex p2, [| t = Node t1 t2 |] * (p ==*> i, c, p1, p2) * tree'' b t1 p1 c * tree' b t2 p2. destruct t; simpl; intros; try normalize; sepLemma. Qed. Theorem tree'_cons_bwd : forall b t (p : W), p <> 0 -> (Ex t1, Ex t2, Ex i, Ex c, Ex p1, Ex p2, [| t = Node t1 t2 |] * (p ==*> i, c, p1, p2) * tree'' b t1 p1 c * tree' b t2 p2) ===> tree' b t p. destruct t; simpl; intros; try normalize; sepLemma; match goal with | [ H : Node _ _ = Node _ _ |- _ ] => injection H0; intros; subst; sepLemma end. Qed. Theorem tree'_weaken : forall b b', b %<= b' -> forall t p, tree' b t p ===> tree' b' t p. induction t; simpl; intros; repeat normalize; sepLemma; apply himp_star_frame; auto; unfold tree''; destruct (weq x1 $0); auto; sepLemma; eauto using incl_mem. Qed. Transparent natToWord. Theorem tree''_zero_fwd : forall b t p (c : W), c = 0 -> tree'' b t p c ===> [| p %in b |] * [| t = Leaf |]. unfold tree''; intros; subst; sepLemma. Qed. Theorem tree''_zero_bwd : forall b t p (c : W), c = 0 -> [| p %in b |] * [| t = Leaf |] ===> tree'' b t p c. unfold tree''; intros; subst; sepLemma. Qed. Theorem tree''_nonzero_fwd : forall b t p (c : W), c <> 0 -> tree'' b t p c ===> tree' b t p. 
ndata_log new), h)) * rep_contents_unmatched xp old synced_addr synced_valu * [[ loglen_valid xp (ndesc_log old + ndesc_log new) (ndata_log old + ndata_log new) ]] * [[ length synced_addr = (ndesc * DescSig.items_per_val)%nat ]] * [[ ndesc = ndesc_log new ]] * [[ length synced_valu = ndata_log new ]] * [[ checksums_match (padded_log old ++ new) h hm ]] * [[ Forall entry_valid new ]] | Rollback old => exists synced_addr synced_valu h new, Hdr.rep xp (Hdr.Synced ((ndesc_log old, ndata_log old), (ndesc_log old + ndesc_log new, ndata_log old + ndata_log new), h)) * rep_contents_unmatched xp old synced_addr synced_valu * [[ loglen_valid xp (ndesc_log old + ndesc_log new) (ndata_log old + ndata_log new) ]] * [[ length synced_addr = ((ndesc_log new) * DescSig.items_per_val)%nat ]] * [[ length synced_valu = ndata_log new ]] * [[ checksums_match (padded_log old ++ new) h hm ]] * [[ hide_or (DescDefs.ipack (map ent_addr (padded_log new)) <> DescDefs.ipack synced_addr \/ vals_nonzero new <> synced_valu) ]] * [[ Forall entry_valid new ]] | RollbackUnsync old => exists synced_addr synced_valu h h' new prev_len, Hdr.rep xp (Hdr.Unsync (prev_len, (ndesc_log old, ndata_log old), h') ((ndesc_log old, ndata_log old), (ndesc_log old + ndesc_log new, ndata_log old + ndata_log new), h)) * rep_contents_unmatched xp old synced_addr synced_valu * [[ loglen_valid xp (ndesc_log old + ndesc_log new) (ndata_log old + ndata_log new) ]] * [[ length synced_addr = ((ndesc_log new) * DescSig.items_per_val)%nat ]] * [[ length synced_valu = ndata_log new ]] * [[ checksums_match old h' hm ]] * [[ checksums_match (padded_log old ++ new) h hm ]] * [[ hide_or (DescDefs.ipack (map ent_addr (padded_log new)) <> DescDefs.ipack synced_addr \/ vals_nonzero new <> synced_valu) ]] * [[ Forall entry_valid new ]] end)%pred. Definition xparams_ok xp := DescSig.xparams_ok xp /\ DataSig.xparams_ok xp /\ (LogLen xp) = DescSig.items_per_val * (LogDescLen xp). Definition rep xp st hm:= ([[ xparams_ok xp ]] * rep_inner xp st hm)%pred. Definition would_recover' xp l hm := (rep xp (Synced l) hm \/ rep xp (Rollback l) hm \/ rep xp (RollbackUnsync l) hm)%pred. Definition would_recover xp F l hm := (exists cs d, BUFCACHE.rep cs d * [[ (F * would_recover' xp l hm)%pred d ]])%pred. Theorem sync_invariant_rep : forall xp st hm, sync_invariant (rep xp st hm). Proof. unfold rep, rep_inner, rep_contents, rep_contents_unmatched. destruct st; intros; eauto 50. Qed. Hint Resolve sync_invariant_rep. Theorem sync_invariant_would_recover' : forall xp l hm, sync_invariant (would_recover' xp l hm). Proof. unfold would_recover'; intros; eauto. Qed. Theorem sync_invariant_would_recover : forall xp F l hm, sync_invariant (would_recover xp F l hm). 
rewrite F2R_Zabs, canonic_exp_abs. Qed.Theorem canonic_0: canonic (Float beta 0 (fexp (ln_beta beta 0%R))). Proof. unfold canonic; simpl; unfold canonic_exp. replace (F2R {| Fnum := 0; Fexp := fexp (ln_beta beta 0) |}) with 0%R. reflexivity. unfold F2R; simpl; ring. Qed.Theorem canonic_unicity : forall f1 f2, canonic f1 -> canonic f2 -> F2R f1 = F2R f2 -> f1 = f2. Proof. intros (m1, e1) (m2, e2). unfold canonic. simpl. intros H1 H2 H. rewrite H in H1. rewrite <- H2 in H1. clear H2. rewrite H1 in H |- *. apply (f_equal (fun m => Float beta m e2)). apply F2R_eq_reg with (1 := H). Qed.Theorem scaled_mantissa_generic : forall x, generic_format x -> scaled_mantissa x = Z2R (Ztrunc (scaled_mantissa x)). Proof. intros x Hx. unfold scaled_mantissa. pattern x at 1 3 ; rewrite Hx. unfold F2R. simpl. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r. now rewrite Ztrunc_Z2R. Qed.Theorem scaled_mantissa_mult_bpow : forall x, (scaled_mantissa x * bpow (canonic_exp x))%R = x. Proof. intros x. unfold scaled_mantissa. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l. apply Rmult_1_r. Qed.Theorem scaled_mantissa_0 : scaled_mantissa 0 = 0%R. Proof. apply Rmult_0_l. Qed.Theorem scaled_mantissa_opp : forall x, scaled_mantissa (-x) = (-scaled_mantissa x)%R. Proof. intros x. unfold scaled_mantissa. rewrite canonic_exp_opp. now rewrite Ropp_mult_distr_l_reverse. Qed.Theorem scaled_mantissa_abs : forall x, scaled_mantissa (Rabs x) = Rabs (scaled_mantissa x). Proof. intros x. unfold scaled_mantissa. rewrite canonic_exp_abs, Rabs_mult. apply f_equal. apply sym_eq. apply Rabs_pos_eq. apply bpow_ge_0. Qed.Theorem generic_format_opp : forall x, generic_format x -> generic_format (-x). Proof. intros x Hx. unfold generic_format. rewrite scaled_mantissa_opp, canonic_exp_opp. rewrite Ztrunc_opp. rewrite F2R_Zopp. now apply f_equal. Qed.Theorem generic_format_abs : forall x, generic_format x -> generic_format (Rabs x). Proof. intros x Hx. unfold generic_format. rewrite scaled_mantissa_abs, canonic_exp_abs. rewrite Ztrunc_abs. rewrite F2R_Zabs. now apply f_equal. Qed.Theorem generic_format_abs_inv : forall x, generic_format (Rabs x) -> generic_format x. Proof. intros x. unfold generic_format, Rabs. case Rcase_abs ; intros _. rewrite scaled_mantissa_opp, canonic_exp_opp, Ztrunc_opp. intros H. rewrite <- (Ropp_involutive x) at 1. rewrite H, F2R_Zopp. apply Ropp_involutive. easy. Qed.Theorem canonic_exp_fexp : forall x ex, (bpow (ex - 1) <= Rabs x < bpow ex)%R -> canonic_exp x = fexp ex. Proof. intros x ex Hx. unfold canonic_exp. now rewrite ln_beta_unique with (1 := Hx). Qed.Theorem canonic_exp_fexp_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> canonic_exp x = fexp ex. Proof. intros x ex Hx. apply canonic_exp_fexp. rewrite Rabs_pos_eq. exact Hx. apply Rle_trans with (2 := proj1 Hx). apply bpow_ge_0. Qed. Theorem mantissa_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> (0 < x * bpow (- fexp ex) < 1)%R. 
as [(n,Hn)|Hn]. right; simpl; exists n; now split. left; split; trivial. intros n; specialize (Hn n); omega. Qed.Context { valid_exp : Valid_exp fexp }.Lemma fexp_negligible_exp_eq: forall n m, (n <= fexp n)%Z -> (m <= fexp m)%Z -> fexp n = fexp m. Proof. intros n m Hn Hm. case (Zle_or_lt n m); intros H. apply valid_exp; omega. apply sym_eq, valid_exp; omega. Qed.Definition ulp x := match Req_bool x 0 with | true => match negligible_exp with | Some n => bpow (fexp n) | None => 0%R end | false => bpow (canonic_exp beta fexp x) end.Lemma ulp_neq_0 : forall x:R, (x <> 0)%R -> ulp x = bpow (canonic_exp beta fexp x). Proof. intros x Hx. unfold ulp; case (Req_bool_spec x); trivial. intros H; now contradict H. Qed.Notation F := (generic_format beta fexp).Theorem ulp_opp : forall x, ulp (- x) = ulp x. Proof. intros x. unfold ulp. case Req_bool_spec; intros H1. rewrite Req_bool_true; trivial. rewrite <- (Ropp_involutive x), H1; ring. rewrite Req_bool_false. now rewrite canonic_exp_opp. intros H2; apply H1; rewrite H2; ring. Qed.Theorem ulp_abs : forall x, ulp (Rabs x) = ulp x. Proof. intros x. unfold ulp; case (Req_bool_spec x 0); intros H1. rewrite Req_bool_true; trivial. now rewrite H1, Rabs_R0. rewrite Req_bool_false. now rewrite canonic_exp_abs. now apply Rabs_no_R0. Qed.Theorem ulp_ge_0: forall x, (0 <= ulp x)%R. Proof. intros x; unfold ulp; case Req_bool_spec; intros. case negligible_exp; intros. apply bpow_ge_0. apply Rle_refl. apply bpow_ge_0. Qed. Theorem ulp_le_id: forall x, (0 < x)%R -> F x -> (ulp x <= x)%R. Proof. intros x Zx Fx. rewrite <- (Rmult_1_l (ulp x)). pattern x at 2; rewrite Fx. rewrite ulp_neq_0. 2: now apply Rgt_not_eq. unfold F2R; simpl. apply Rmult_le_compat_r. apply bpow_ge_0. apply (Z2R_le (Zsucc 0)). apply Zlt_le_succ. apply F2R_gt_0_reg with beta (canonic_exp beta fexp x). now rewrite <- Fx. Qed.Theorem ulp_le_abs: forall x, (x <> 0)%R -> F x -> (ulp x <= Rabs x)%R. Proof. intros x Zx Fx. rewrite <- ulp_abs. apply ulp_le_id. now apply Rabs_pos_lt. now apply generic_format_abs. Qed.Theorem round_UP_DN_ulp : forall x, ~ F x -> round beta fexp Zceil x = (round beta fexp Zfloor x + ulp x)%R. Proof. intros x Fx. rewrite ulp_neq_0. unfold round. simpl. unfold F2R. simpl. rewrite Zceil_floor_neq. rewrite Z2R_plus. simpl. ring. intros H. apply Fx. unfold generic_format, F2R. simpl. rewrite <- H. rewrite Ztrunc_Z2R. rewrite H. now rewrite scaled_mantissa_mult_bpow. intros V; apply Fx. rewrite V. apply generic_format_0. Qed. Theorem ulp_bpow : forall e, ulp (bpow e) = bpow (fexp (e + 1)). 
: float, is_Fzero x \/ ~ is_Fzero x. unfold is_Fzero in |- *; intro; CaseEq (Fnum x); intros; (right; discriminate) || (left; auto). Qed. Coercion IZR : Z >-> R. Coercion INR : nat >-> R. Coercion Z_of_nat : nat >-> Z. Definition FtoR (x : float) := (Fnum x * powerRZ (IZR radix) (Fexp x))%R. Local Coercion FtoR : float >-> R. Theorem FzeroisReallyZero : forall z : Z, Fzero z = 0%R :>R. intros z; unfold FtoR in |- *; simpl in |- *; auto with real. Qed. Theorem is_Fzero_rep1 : forall x : float, is_Fzero x -> x = 0%R :>R. intros x H; unfold FtoR in |- *. red in H; rewrite H; simpl in |- *; auto with real. Qed. Theorem LtFnumZERO : forall x : float, (0 < Fnum x)%Z -> (0 < x)%R. intros x; case x; unfold FtoR in |- *; simpl in |- *. intros Fnum1 Fexp1 H'; replace 0%R with (Fnum1 * 0)%R; [ apply Rmult_lt_compat_l | ring ]; auto with real zarith. Qed. Theorem is_Fzero_rep2 : forall x : float, x = 0%R :>R -> is_Fzero x. intros x H'. case (Rmult_integral _ _ H'); simpl in |- *; auto. case x; simpl in |- *. intros Fnum1 Fexp1 H'0; red in |- *; simpl in |- *; auto with real zarith. apply eq_IZR_R0; auto. intros H'0; Contradict H'0; apply powerRZ_NOR; auto with real zarith. Qed. Theorem NisFzeroComp : forall x y : float, ~ is_Fzero x -> x = y :>R -> ~ is_Fzero y. intros x y H' H'0; Contradict H'. apply is_Fzero_rep2; auto. rewrite H'0. apply is_Fzero_rep1; auto. Qed. Theorem Rlt_monotony_exp : forall (x y : R) (z : Z), (x < y)%R -> (x * powerRZ radix z < y * powerRZ radix z)%R. intros x y z H'; apply Rmult_lt_compat_r; auto with real zarith. Qed. Theorem Rle_monotone_exp : forall (x y : R) (z : Z), (x <= y)%R -> (x * powerRZ radix z <= y * powerRZ radix z)%R. intros x y z H'; apply Rmult_le_compat_r; auto with real zarith. Qed. Theorem Rlt_monotony_contra_exp : forall (x y : R) (z : Z), (x * powerRZ radix z < y * powerRZ radix z)%R -> (x < y)%R. intros x y z H'; apply Rmult_lt_reg_l with (r := powerRZ radix z); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix z)); auto. Qed. Theorem Rle_monotony_contra_exp : forall (x y : R) (z : Z), (x * powerRZ radix z <= y * powerRZ radix z)%R -> (x <= y)%R. 
auto with real arith. apply Rlt_IZR; red in |- *. generalize H'; unfold Flt_bool, Fcompare in |- *. case (Fdiff x y ?= 0)%Z; auto; intros; try discriminate. Qed. Theorem Flt_bool_correct_r : forall x y : float, Flt x y -> Flt_bool x y = true. intros x y H'. cut (0 < y - x)%R; auto with arith. 2: apply Rplus_lt_reg_l with (r := FtoRradix x); rewrite Rplus_0_r; rewrite Rplus_minus; auto with real. intros H'0. cut (Fdiff x y < 0)%R; auto with arith. intros H'1. cut (Fdiff x y < 0)%Z; auto with zarith. intros H'2; generalize (Zlt_compare _ _ H'2); unfold Flt_bool, Fcompare, Zcompare in |- *; case (Fdiff x y); auto with arith; intros; contradiction. apply lt_IZR; auto with arith. apply (Rlt_monotony_contra_exp radix) with (z := Zmin (Fexp x) (Fexp y)); auto with arith real; rewrite Rmult_0_l. rewrite Fdiff_correct; auto with real. Qed. Theorem Flt_bool_correct_f : forall x y : float, Flt_bool x y = false -> Fle y x. intros x y H'. case (Rtotal_order (FtoRradix y) (FtoRradix x)); auto with real. intros H'0; red in |- *; apply Rlt_le; auto with real. intros H'0; elim H'0; clear H'0; intros H'1. red in |- *; rewrite H'1; auto with real. Contradict H'; rewrite Flt_bool_correct_r; auto with real. red in |- *; intros H'; discriminate. Qed. Definition Fle_bool (x y : float) := match Fcompare x y with | Lt => true | Eq => true | _ => false end. Theorem Fle_bool_correct_t : forall x y : float, Fle_bool x y = true -> Fle x y. intros x y H'. cut (Feq x y \/ Flt x y). intros H; case H; intros H1; auto with real. red in |- *; apply Req_le; auto with real. red in |- *; apply Rlt_le; auto with real. generalize H' (Feq_bool_correct_t x y) (Flt_bool_correct_t x y). unfold Fle_bool, Feq_bool, Flt_bool in |- *; case (Fcompare x y); auto. Qed. Theorem Fle_bool_correct_r : forall x y : float, Fle x y -> Fle_bool x y = true. intros x y H'. cut (Feq x y \/ Flt x y). intros H; case H; intros H1; auto with real. generalize (Feq_bool_correct_r x y). unfold Fle_bool, Feq_bool, Flt_bool in |- *; case (Fcompare x y); auto. generalize (Flt_bool_correct_r x y); unfold Fle_bool, Feq_bool, Flt_bool in |- *; case (Fcompare x y); auto with arith. case H'; auto with arith. Qed. Theorem Fle_bool_correct_f : forall x y : float, Fle_bool x y = false -> Flt y x. 
(int.nat i)) by word. erewrite take_S_r; last first. { rewrite list_lookup_fmap. rewrite Hs_inode_lookup //. } rewrite union_list_app_L /= right_id_L //. } iSplit. { iLeft in "HΦ". eauto. } iIntros "!> (Hinv&Hinode_s)"; iNamed "Hinv". wpc_pures. iDestruct (big_sepL2_length with "Hpre_inodes") as %Hlens. iApply "HΦ"; iFrame. rewrite -> take_ge by len; eauto. Qed. Fixpoint delete_below `(m : gmap nat T) (off : nat) := match off with | O => m | S off' => delete off' (delete_below m off') end. Lemma delete_below_insert : forall (off : nat) (pos : nat) `(m : gmap nat T) v, off <= pos -> delete_below (<[pos:=v]> m) off = <[pos:=v]> (delete_below m off). Proof. induction off; intros; simpl; eauto. rewrite IHoff; last by lia. rewrite delete_insert_ne //. lia. Qed. Lemma delete_below_delete : forall (off : nat) (pos : nat) `(m : gmap nat T), off <= pos -> delete_below (delete pos m) off = delete pos (delete_below m off). Proof. induction off; intros; simpl; eauto. rewrite IHoff; last by lia. rewrite delete_commute //. Qed. Lemma unify_alloc_inodes_used_helper γused γblocks allocs s_inodes off : ([∗ list] i↦s_inode ∈ s_inodes, Pinode γblocks γused (off + i) s_inode) -∗ inode_allused γused allocs -∗ ⌜length s_inodes = length (map_to_list (delete_below allocs off)) -> ⋃ (map_to_list (delete_below allocs off)).*2 = ⋃ (inode.addrs <$> s_inodes)⌝. Proof. rewrite /Pinode. iIntros "Hinodes Hall". iInduction s_inodes as [|] "IH" forall (off). { iPureIntro. intros. generalize dependent (map_to_list (delete_below allocs off)). intros. destruct l; simpl in *; congruence. } iDestruct "Hinodes" as "[Ha Hinodes]". iNamed "Ha". iDestruct (inode_used_lookup with "Hused1 Hall") as "%". replace (allocs) with (<[off := a.(inode.addrs)]> (delete off allocs)) at 2 3. 2: { rewrite insert_delete //. replace (off) with (off + 0) by lia. done. } rewrite delete_below_insert; last by lia. rewrite map_to_list_insert. 2: { rewrite delete_below_delete; last by lia. rewrite lookup_delete //. } rewrite ?fmap_cons ?union_list_cons /=. iDestruct ("IH" $! (S off) with "[Hinodes] Hall") as "%IH". { setoid_rewrite plus_n_Sm. iFrame. } rewrite delete_below_delete; last by lia. iPureIntro. intros. rewrite -IH /=; last by lia. done. Qed. Lemma unify_alloc_inodes_used γused γblocks s_alloc s_inodes : length s_inodes = num_inodes → ([∗ list] i↦s_inode ∈ s_inodes, Pinode γblocks γused i s_inode) -∗ Palloc γused s_alloc -∗ ⌜alloc.used s_alloc = ⋃ (inode.addrs <$> s_inodes)⌝. Proof. rewrite /Palloc. iIntros (Hlen) "Hinodes". iNamed 1. rewrite Hused_global. iDestruct (unify_alloc_inodes_used_helper _ _ _ _ 0 with "Hinodes Hused2") as "%Hhelper". iPureIntro. rewrite -Hhelper /=; eauto. rewrite length_gmap_to_list. congruence. Qed. Theorem wpc_Open d (sz: u64) σ0 : (5 ≤ int.Z sz)%Z → {{{ dir_cinv (int.Z sz) σ0 true }}} Open (disk_val d) #sz @ ⊤ {{{ l, RET #l; pre_dir l (int.Z sz) σ0 }}} {{{ dir_cinv (int.Z sz) σ0 false }}}. 
(ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a x) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults (A:=A) multA (n:=n) a x))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults (A:=A) multA (n:=n) a x)) (mults (A:=A) multA (n:=n) a x)); auto. apply pluspf_minuspf_id with (1 := cs); auto. Qed. Theorem CombLinear_reduceplus : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p. intros Q p q H'0; elim H'0; auto. intros x y H' H'1 H'2. apply CombLinear_comp with (p := y); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. intros x y z H' H'1 H'2 H'3 H'4. apply CombLinear_reduce with (q := y); auto. apply H'2; auto. apply canonical_reduce with (1 := cs) (3 := H'); auto. Qed. Theorem CombLinear_reducestar : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p. intros Q p q H'; elim H'; auto. intros p0 q0 H'0 H'1 H'2 H'3. apply CombLinear_reduceplus with (q := q0); auto. Qed. Theorem Reducestar_pO_imp_CombLinear : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n q (pO A n) -> CombLinear Q p. intros Q p q H' H'0 H'1; inversion H'1; auto. apply CombLinear_reducestar with (q := q); auto. rewrite <- H; auto. Qed. Inductive Grobner (Q : list (poly A0 eqA ltM)) : Prop := Grobner0 : (forall p q : list (Term A n), CombLinear Q p -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> eqP A eqA n q (pO A n)) -> Grobner Q. Theorem Grobner_imp_SpolyQ : forall Q : list (poly A0 eqA ltM), Grobner Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q. 
exists x : T, satisfies (p x) stn m. Proof. unfold satisfies, ex; simpl; intros; propxFo; eauto. Qed. | [ H : _ -> _ |- _ ] => apply H; clear H | [ H : forall x, _ -> _ , H' : _ |- _ ] => apply H in H' | [ H : ?X -> _ , H' : ?X |- _ ] => apply H in H'; clear H end; propxFo; repeat match goal with | [ |- exists x, _ ] => eexists | [ |- _ /\ _ ] => split | [ |- simplify _ _ _ ] => eassumption || apply simplify_fwd | [ H : interp ?X (?Y _) |- interp ?X (?Y _) ] => eapply H end. unfold himp, heq; simpl; intros; repeat match goal with | [ H : _ -> _ |- _ ] => apply H; clear H | [ H : forall x, _ -> _ , H' : _ |- _ ] => apply H in H' | [ H : ?X -> _ , H' : ?X |- _ ] => apply H in H'; clear H end; propxFo; repeat match goal with | [ |- exists x, _ ] => eexists | [ |- _ /\ _ ] => split | [ |- simplify _ _ _ ] => eassumption || apply simplify_fwd | [ H : interp ?X (?Y _) |- interp ?X (?Y _) ] => eapply H end. *) Import PropXRel. Hint Immediate HT.split_comm : heaps. Hint Resolve HT.split_assoc HT.disjoint_split_join HT.split_split_disjoint : heaps. Lemma himp_star_comm : forall P Q, himp (star P Q) (star Q P). Proof. unfold star, himp, interp; intros; propxIntuition; eauto with heaps. Qed. Theorem heq_star_comm : forall P Q, heq (star P Q) (star Q P). Proof. intros. unfold heq. generalize himp_star_comm. intuition. Qed. Theorem himp_star_assoc : forall P Q R, himp (star (star P Q) R) (star P (star Q R)). Proof. unfold star, himp, interp; intros; propxIntuition. eapply HT.split_comm. eapply HT.split_assoc. eapply HT.split_comm. eassumption. eapply HT.split_comm. eassumption. eapply HT.disjoint_split_join. eapply HT.disjoint_comm. eauto with heaps. Qed. Theorem heq_star_assoc : forall P Q R, heq (star (star P Q) R) (star P (star Q R)). Proof. split. eapply himp_star_assoc. unfold star, himp, interp; intros; propxIntuition. eapply HT.split_assoc. eassumption. eassumption. eapply HT.split_comm. eapply HT.disjoint_split_join. eapply HT.disjoint_comm. eapply HT.split_split_disjoint. 2: eassumption. eauto with heaps. Qed. Theorem himp_star_frame : forall P Q R S, himp P Q -> himp R S -> himp (star P R) (star Q S). 
exact (vec_pos v (nat2pos H)). Defined. Fact vec_fill_tail_lt p (Hp : pos2nat p < k) : vec_pos vec_fill_tail p = vec_pos v (nat2pos Hp). Proof. unfold vec_fill_tail; rew vec. destruct (le_lt_dec k (pos2nat p)). + exfalso; lia. + do 2 f_equal; apply lt_pirr. Qed. Fact vec_fill_tail_ge p : k <= pos2nat p -> vec_pos vec_fill_tail p = e. Proof. intros H; unfold vec_fill_tail; rew vec. destruct (le_lt_dec k (pos2nat p)); auto; exfalso; lia. Qed.End vec_fill_tail.Opaque vec_fill_tail.Fact vec_map_fill_tail X Y (f : X -> Y) n k v e : vec_map f (@vec_fill_tail X n k v e) = vec_fill_tail n (vec_map f v) (f e). Proof. apply vec_pos_ext; intros p; rew vec. destruct (le_lt_dec k (pos2nat p)) as [ | Hp ]. + do 2 (rewrite vec_fill_tail_ge; auto). + do 2 rewrite vec_fill_tail_lt with (Hp := Hp); rew vec. Qed.Section vec_first_half. Variable (X : Type) (n : nat) (k : nat) (Hk : k <= n). Definition vec_first_half (v : vec X n) : vec X k. Proof using Hk. apply vec_set_pos; intros p. refine (vec_pos v (@nat2pos _ (pos2nat p) _)). apply lt_le_trans with (2 := Hk), pos2nat_prop. Defined. Fact vec_first_half_fill_tail v e : vec_first_half (vec_fill_tail _ v e) = v. Proof. apply vec_pos_ext; intros p. unfold vec_first_half; rew vec. match goal with | |- vec_pos _ ?p = _ => assert (H : pos2nat p < k) end. { rewrite pos2nat_nat2pos; apply pos2nat_prop. } rewrite vec_fill_tail_lt with (Hp := H). revert H. rewrite pos2nat_nat2pos. intros; f_equal; apply nat2pos_pos2nat. Qed.End vec_first_half.Section Sig_uniformize_rels. Variable (Σ : fo_signature) (n : nat) (Hn : forall r, ar_rels Σ r <= n). Definition Σunif : fo_signature. Proof using Σ n. exists (syms Σ) (rels Σ). + exact (ar_syms Σ). + exact (fun _ => n). Defined. Notation Σ' := Σunif. Fixpoint fol_uniformize (A : fol_form Σ) : fol_form Σ' := match A with | ⊥ => ⊥ | @fol_atom _ r v => @fol_atom Σ' r (vec_fill_tail _ v (£0)) | fol_bin c A B => fol_bin c (fol_uniformize A) (fol_uniformize B) | fol_quant q A => fol_quant q (fol_uniformize A) end. Variable (X : Type) (e : X). Section soundness. Variables (M : fo_model Σ X). Local Definition fom_uniformize : fo_model Σ' X. Proof using M Hn. split. + intros s; apply (fom_syms M s). + intros r v; exact (fom_rels M r (vec_first_half (Hn r) v)). Defined. Notation M' := fom_uniformize. Theorem fol_uniformize_sound A φ : fol_sem M φ A <-> fol_sem M' φ (fol_uniformize A). 
in |- *; auto. intros p H H0. apply unique_key_map; auto. apply H; apply distinct_pbleaves_pr; auto. intros (a1, b1) (a2, b2); simpl in |- *; auto. intros p H p0 H0 H1. apply unique_key_app; auto. apply unique_key_map; auto. apply H; apply distinct_pbleaves_l with (1 := H1); auto. intros (a1, b1) (a2, b2); simpl in |- *; auto. apply unique_key_map; auto. apply H0; apply distinct_pbleaves_r with (1 := H1); auto. intros (a1, b1) (a2, b2); simpl in |- *; auto. intros a b1 c H2 H3. case in_map_inv with (1 := H2); auto; case in_map_inv with (1 := H3); auto. intros (a1, l1) (Ha1, Hl1) (a2, l2) (Ha2, Hl2). apply (H1 (pbleaf a) p p0); auto. injection Hl2; intros HH1 HH2; rewrite HH2. apply in_pbcompute_inpb with (1 := Ha2). injection Hl1; intros HH1 HH2; rewrite HH2. apply in_pbcompute_inpb with (1 := Ha1). Qed. Theorem pb_unique_prefix : forall t : pbtree, distinct_pbleaves t -> unique_prefix (compute_pbcode t). Proof using. intros t H1; split; try exact (pb_unique_prefix1 t); apply pb_unique_key; auto. Qed. Inductive pbfree : list bool -> pbtree -> Prop := | pbfree_left1 : forall b l, pbfree (true :: l) (pbleft b) | pbfree_left2 : forall b l, pbfree l b -> pbfree (false :: l) (pbleft b) | pbfree_right1 : forall b l, pbfree (false :: l) (pbright b) | pbfree_right2 : forall b l, pbfree l b -> pbfree (true :: l) (pbright b) | pbfree_node1 : forall b c l, pbfree l b -> pbfree (false :: l) (pbnode b c) | pbfree_node2 : forall b c l, pbfree l b -> pbfree (true :: l) (pbnode c b). Hint Constructors pbfree : core. Fixpoint pbadd (a : A) (t : pbtree) (l : list bool) {struct l} : pbtree := match l with | nil => pbleaf a | false :: l1 => match t with | pbnode t1 t2 => pbnode (pbadd a t1 l1) t2 | pbleft t1 => pbleft (pbadd a t1 l1) | pbright t2 => pbnode (pbadd a (pbleaf empty) l1) t2 | _ => pbleft (pbadd a (pbleaf empty) l1) end | true :: l1 => match t with | pbnode t1 t2 => pbnode t1 (pbadd a t2 l1) | pbright t2 => pbright (pbadd a t2 l1) | pbleft t1 => pbnode t1 (pbadd a (pbleaf empty) l1) | _ => pbright (pbadd a (pbleaf empty) l1) end end. Theorem pbadd_prop1 : forall a1 a2 l1, compute_pbcode (pbadd a1 (pbleaf a2) l1) = (a1, l1) :: nil. 
Require Import Coq.Logic.FunctionalExtensionality. Require Import Coq.Program.Basics.Set Implicit Arguments.Module Type Monad. Parameter m : Type -> Type. Parameter ret : forall {A : Type}, A -> m A. Parameter bind : forall {A B : Type}, m A -> (A -> m B) -> m B. Infix ">>=" := bind (at level 50, left associativity). Axiom left_id : forall (A B : Type) (x : A) (f : A -> m B), ret x >>= f = f x. Axiom right_id : forall (A : Type) (x : m A), x >>= ret = x. Axiom bind_assoc : forall (A B C : Type) (n : m A) (f : A -> m B) (g : B -> m C), (n >>= f) >>= g = n >>= (fun x => f x >>= g). End Monad.Local Open Scope program_scope. Module MonadExt (M : Monad). Import M. Definition fmap {A B : Type} (f : A -> B) (n : m A) : m B := n >>= ret ∘ f. Definition join {A : Type} (n : m (m A)) : m A := n >>= id. Theorem fmap_compose_join_eq_bind : forall (A B : Type) (n : m A) (f : A -> m B), n >>= f = join (fmap f n). Proof. unfold join, fmap; intros. rewrite bind_assoc. f_equal; apply functional_extensionality; intros. unfold compose; rewrite left_id. auto. Qed. Theorem fmap_id : forall (A : Type), fmap (@id A) = @id (m A). Proof. unfold fmap, compose; intros. apply functional_extensionality; intros; unfold id. rewrite right_id. auto. Qed. Theorem fmap_associativity : forall (A B C : Type) (f : A -> B) (g : B -> C), fmap (g ∘ f) = fmap g ∘ fmap f. Proof. unfold fmap, compose; intros. apply functional_extensionality; intros. rewrite bind_assoc; f_equal. apply functional_extensionality; intros. rewrite left_id. auto. Qed. Theorem return_property : forall (A B : Type) (f : A -> B) (x : A), ret (f x) = fmap f (ret x). Proof. unfold fmap, compose; intros. rewrite left_id. auto. Qed. Theorem join_property1 : forall (A : Type) (x : m (m (m A))), join (fmap join x) = join (join x). Proof. intros. rewrite <- fmap_compose_join_eq_bind. unfold join, id. rewrite bind_assoc. auto. Qed. Theorem join_property2 : forall (A : Type) (x : m A), join (fmap ret x) = x. Proof. intros. rewrite <- fmap_compose_join_eq_bind. rewrite right_id. auto. Qed. Theorem join_property3 : forall (A : Type) (x : m A), join (ret x) = x. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Representable.Hom_Func. From Categories Require Import Functor.Functor_Extender. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations Ext_Cons.Prod_Cat.Nat_Facts. From Categories Require Import Adjunction.Adjunction. From Categories Require Import KanExt.Local. From Categories Require Import Basic_Cons.Terminal.Local Open Scope functor_scope. Section Hom_Local_Right_KanExt_to_Local_Right_KanExt. Context {C C' : Category} {p : C –≻ C'} {D : Category} {F : C –≻ D} (hlrke : Hom_Local_Right_KanExt p F). Definition Hom_Local_Right_KanExt_to_Local_Right_KanExt_Terminal_Cone : LoKan_Cone p F := {| cone_apex := hlrke; cone_edge := Trans (inverse_morphism (HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke) |}. Local Notation TCONE := Hom_Local_Right_KanExt_to_Local_Right_KanExt_Terminal_Cone (only parsing). Section Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone. Context (Cn : LoKan_Cone p F). Program Definition Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone : LoKan_Cone_Morph Cn TCONE := {| cone_morph := Trans (iso_morphism (HLRKE_Iso hlrke)) Cn Cn |}. Next Obligation. Proof. set (W := f_equal ( fun w : (((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ F (Hom_Func _)) ∘ (Left_Functor_Extender p D)^op) –≻ ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ F (Hom_Func _)) ∘ (Left_Functor_Extender p D)^op ))%nattrans => Trans w Cn ) (left_inverse (HLRKE_Iso hlrke))). cbn in W. match goal with [|- ?A = ?B] => match type of W with ?X = _ => cut (X A = X B); simpl; [rewrite (equal_f W A); rewrite (equal_f W B); trivial|clear W] end end. apply f_equal. set (M := equal_f (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn (Trans (iso_morphism (HLRKE_Iso hlrke)) Cn Cn) ) (Trans (inverse_morphism (HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke))). cbn in M. repeat rewrite NatTrans_id_unit_left in M. rewrite M; clear M. apply NatTrans_eq_simplify; extensionality x; cbn. cbn_rewrite ( f_equal (fun w : ((@Fix_Bi_Func_2 _ (Func_Cat _ _) _ hlrke (Hom_Func _)) –≻ (@Fix_Bi_Func_2 _ (Func_Cat _ _) _ hlrke (Hom_Func _)) )%nattrans => Trans w hlrke (NatTrans_id _) ) (right_inverse (HLRKE_Iso hlrke)) ). cbn; auto. Qed. End Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone. Section Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique. Context {Cn : LoKan_Cone p F} (h h' : LoKan_Cone_Morph Cn TCONE). Theorem Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique : h = h' :> (_ –≻ _)%nattrans. 
-> In (f_inv x) (getSupport c)) -> (forall x, In x (getSupport c) -> (evalDist d (f x)) == (evalDist c x)) -> (forall x, In x (getSupport c) -> (evalDist (f1 (f x)) b) == (evalDist (f2 x) a)) -> (evalDist (Bind d f1) b == evalDist (Bind c f2) a). intuition. simpl. eapply eqRat_trans. eapply fold_add_rat_perm. eapply Permutation_sym. eapply evalDist_getSupport_perm; eauto. intuition. symmetry. eauto. intuition. rewrite <- (H a0) at 1. eapply H2. eauto. trivial. eapply eqRat_refl. intuition. eapply ratMult_eqRat_compat. rewrite <- H at 1. eauto. trivial. rewrite <- H at 1. eapply H3. eauto. trivial. eapply eqRat_trans. 2:{ eapply fold_add_f_inverse; eauto. eapply eqRat_refl. } simpl. eapply eqRat_refl.Qed. Lemma evalDist_seq_eq : forall (A1 A2 B : Set)(c1 c2 : Comp B)(f1 : B -> Comp A1)(f2 : B -> Comp A2) y z, (forall x : B, evalDist c1 x == evalDist c2 x) -> (forall x : B, In x (getSupport c1) -> evalDist (f1 x) y == evalDist (f2 x) z) -> evalDist (x <-$ c1; f1 x) y == evalDist (x <-$ c2; f2 x) z. intuition. eapply (distro_iso_eq (fun b => b)(fun b => b)); intuition. eapply getSupport_In_evalDist. intuition. eapply getSupport_In_evalDist. eauto. rewrite H. trivial. eapply H0. eapply getSupport_In_evalDist. intuition. eapply getSupport_In_evalDist. eauto. rewrite <- H. trivial. Qed. Theorem distro_irr_eq : forall (A B : Set)(b : Comp B)(a : B -> Comp A)(y : A) v, well_formed_comp b -> (forall x, In x (getSupport b) -> (evalDist (a x) y) == v) -> evalDist (Bind b a) y == v. intuition. simpl. rewrite sumList_body_eq. 2:{ intuition. rewrite H0 at 1. eapply eqRat_refl. trivial. } rewrite sumList_factor_constant_r. rewrite evalDist_lossless. eapply ratMult_1_l. trivial. Qed. Lemma sumList_filter : forall (A : Set)(ls : list A)(f : A -> Rat)(P : A -> bool) init, fold_left (fun r a => r + if (P a) then (f a) else 0) ls init == fold_left (fun r a => r + (f a)) (filter P ls) init. induction ls; simpl in *; intuition. destruct (P a); simpl. eapply IHls. rewrite fold_add_body_eq. eapply IHls. symmetry. eapply ratAdd_0_r. intuition. Qed. Theorem evalDist_left_ident_eq : forall (B : Set)(eqd : EqDec B)(b : B)(A : Set)(c2 : B -> Comp A) a, (evalDist (x <-$ ret b; (c2 x)) a) == (evalDist (c2 b) a). intuition. simpl. unfold sumList. simpl. destruct (EqDec_dec eqd b b). rewrite <- ratAdd_0_l. rewrite ratMult_1_l. intuition. congruence.Qed. Theorem evalDist_assoc_eq : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C), dist_sem_eq (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))). 
Require Import Coq.Logic.FunctionalExtensionality. Require Import Coq.Program.Basics.Set Implicit Arguments.Module Type Monad. Parameter m : Type -> Type. Parameter ret : forall {A : Type}, A -> m A. Parameter bind : forall {A B : Type}, m A -> (A -> m B) -> m B. Infix ">>=" := bind (at level 50, left associativity). Axiom left_id : forall (A B : Type) (x : A) (f : A -> m B), ret x >>= f = f x. Axiom right_id : forall (A : Type) (x : m A), x >>= ret = x. Axiom bind_assoc : forall (A B C : Type) (n : m A) (f : A -> m B) (g : B -> m C), (n >>= f) >>= g = n >>= (fun x => f x >>= g). End Monad.Local Open Scope program_scope. Module MonadExt (M : Monad). Import M. Definition fmap {A B : Type} (f : A -> B) (n : m A) : m B := n >>= ret ∘ f. Definition join {A : Type} (n : m (m A)) : m A := n >>= id. Theorem fmap_compose_join_eq_bind : forall (A B : Type) (n : m A) (f : A -> m B), n >>= f = join (fmap f n). Proof. unfold join, fmap; intros. rewrite bind_assoc. f_equal; apply functional_extensionality; intros. unfold compose; rewrite left_id. auto. Qed. Theorem fmap_id : forall (A : Type), fmap (@id A) = @id (m A). Proof. unfold fmap, compose; intros. apply functional_extensionality; intros; unfold id. rewrite right_id. auto. Qed. Theorem fmap_associativity : forall (A B C : Type) (f : A -> B) (g : B -> C), fmap (g ∘ f) = fmap g ∘ fmap f. Proof. unfold fmap, compose; intros. apply functional_extensionality; intros. rewrite bind_assoc; f_equal. apply functional_extensionality; intros. rewrite left_id. auto. Qed. Theorem return_property : forall (A B : Type) (f : A -> B) (x : A), ret (f x) = fmap f (ret x). Proof. unfold fmap, compose; intros. rewrite left_id. auto. Qed. Theorem join_property1 : forall (A : Type) (x : m (m (m A))), join (fmap join x) = join (join x). 
l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. apply fold1_xelements with (l := @nil (positive * A)). Qed.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. unfold init. unfold get. simpl. rewrite PTree.gempty. auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. 
permutation_sym : forall l m : list A, permutation l m -> permutation m l. Proof using. intros l1 l2 H'; elim H'. apply permutation_nil. intros a l1' l2' H1 H2. apply permutation_skip with (1 := H2). intros a b l1'. apply permutation_swap. intros l1' l2' l3' H1 H2 H3 H4. apply permutation_trans with (1 := H4) (2 := H2). Qed. Theorem permutation_length : forall l m : list A, permutation l m -> length l = length m. Proof using. intros l m H'; elim H'; simpl in |- *; auto. intros l1 l2 l3 H'0 H'1 H'2 H'3. rewrite <- H'3; auto. Qed. Theorem permutation_nil_inv : forall l : list A, permutation l nil -> l = nil. Proof using. intros l H; generalize (permutation_length _ _ H); case l; simpl in |- *; auto. intros; discriminate. Qed. Lemma permutation_one_inv_aux : forall l1 l2 : list A, permutation l1 l2 -> forall a : A, l1 = a :: nil -> l2 = a :: nil. Proof using. intros l1 l2 H; elim H; clear H l1 l2; auto. intros a l3 l4 H0 H1 b H2. apply f_equal2 with (f := cons (A:=A)). injection H2; auto. apply permutation_nil_inv; auto. injection H2; intros H3 H4; rewrite <- H3; auto. apply permutation_sym; auto. intros; discriminate. Qed. Theorem permutation_one_inv : forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil. Proof using. intros a l H; apply permutation_one_inv_aux with (l1 := a :: nil); auto. Qed. Theorem permutation_in : forall (a : A) (l m : list A), permutation l m -> In a l -> In a m. Proof using. intros a l m H; elim H; simpl in |- *; auto; intuition. Qed. Theorem permutation_app_comp : forall l1 l2 l3 l4, permutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4). Proof using. intros l1 l2 l3 l4 H1; generalize l3 l4; elim H1; clear H1 l1 l2 l3 l4; simpl in |- *; auto. intros a b l l3 l4 H. cut (permutation (l ++ l3) (l ++ l4)); auto. intros; apply permutation_trans with (a :: b :: l ++ l4); auto. elim l; simpl in |- *; auto. intros l1 l2 l3 H H0 H1 H2 l4 l5 H3. apply permutation_trans with (l2 ++ l4); auto. Qed. Hint Resolve permutation_app_comp : core. Theorem permutation_app_swap : forall l1 l2, permutation (l1 ++ l2) (l2 ++ l1). 
Qed. Theorem substitution : forall (e : env) (d t u U : term), typ (Ax t :: e) u U -> typ e d t -> typ e (subst d u) (subst d U). intros. unfold subst in |- *. apply typ_sub with e (Ax t) (Ax t :: e); auto with arith pts. apply typ_wf with d t; auto with arith pts. Qed. Theorem subtype_in_env : forall (e : env) (t T : term), typ e t T -> forall f : env, R_in_env ge_type e f -> wf f -> typ f t T. simple induction 1; auto with arith pts; intros. inversion_clear H1. rewrite H4. elim red_item with ge_type v x e0 f; intros; auto with arith pts. apply type_var; auto with arith pts. exists x; auto with arith pts.elim item_trunc with decl v e0 x; auto with arith pts; intros. elim H1 with x0; auto with arith pts; intros. inversion_clear H7. elim wf_sort with (1 := H5) (3 := H6); auto with arith pts; intros. apply type_conv with (lift (S v) (typ_of_decl x1)) x2; auto with arith pts. apply type_var; auto with arith pts. exists x1; auto with arith pts.apply iter_R_lift with x0; auto with arith pts. elim H9; auto with arith pts.replace (Srt x2) with (lift (S v) (Srt x2)); auto with arith pts. apply thinning_n with x0; auto with arith pts.apply type_abs with s; auto with arith pts. apply H3; auto with arith pts. Inversion_typ (H1 _ H4 H5). apply wf_var with s1; auto with arith pts.apply type_app with V; auto with arith pts.apply type_prod with s1 s2; auto with arith pts. apply H3; auto with arith pts. apply wf_var with s1; auto with arith pts.apply type_conv with U s; auto with arith pts. apply (le_type_stable ge_type e0); auto with arith pts.apply type_conv_srt with U; auto with arith pts. apply le_type_stable with ge_type e0; auto with arith pts. Qed. Theorem typ_conv_wf : forall (e : env) (t T U : term), typ e t T -> wf_type e U -> le_type e T U -> typ e t U. simple induction 2; intros. apply type_conv with T s; auto with arith pts.apply type_conv_srt with T; auto with arith pts. Qed. Theorem wf_type_prod_l : forall (e : env) (A B : term), wf_type e (Prod A B) -> wf_type e A. intros. inversion_clear H. Inversion_typ H0. left with s1; trivial with arith pts. Qed. Theorem wf_type_prod_r : forall (e : env) (A B : term), wf_type e (Prod A B) -> wf_type (Ax A :: e) B. 
apply bijection_is_func, inv_bijection... 2: apply i. apply BUnionI2... + apply injectiveE in Heq... 2: rewrite Hd; apply ω_inductive... exfalso. rewrite <- Heq in i. apply n. eapply nat_trans. eapply ap_ran... apply bijection_is_func, inv_bijection... 2: apply i. apply BUnionI2... + apply injectiveE in Heq... 2-3: rewrite Hd; apply ω_inductive... apply suc_injective in Heq... - intros y Hy. apply SepE in Hy as [Hy Hy']. apply SingNE in Hy'. assert (Hyw: (f⁻¹)[y] ∈ ω). { eapply ap_ran... apply bijection_is_func, inv_bijection... } assert (Haw: (f⁻¹)[a] ∈ ω). { eapply ap_ran... apply bijection_is_func, inv_bijection... } destruct (classic (f⁻¹[y] ∈ f⁻¹[a])). + exists (f⁻¹[y]). split... destruct (ixm (f⁻¹[y] ∈ f⁻¹[a]))... rewrite inv_ran_reduction... + set (f⁻¹[y]) as n. assert (Hn: n ∈ ω)... ω_destruct n. { apply le_iff_not_gt in H0 as []... - rewrite H1 in H0. exfalso0. - apply injectiveE in H0... apply inv_injective. apply Hbi. 1-2: rewrite inv_dom... } exists n. split... destruct (ixm (n ∈ f⁻¹[a])). * apply le_iff_not_gt in H0 as []... rewrite Heq in H0. exfalso. apply (ω_not_dense n)... apply injectiveE in H0... apply inv_injective. apply Hbi. 1-2: rewrite inv_dom... * rewrite <- Heq. rewrite inv_ran_reduction... Qed. Lemma add_one_member_to_funion : ∀ a F A, countable (F a) → |⋃ {F x | x ∊ A - {a,}}| = ℵ₀ → |⋃ {F x | x ∊ A}| = ℵ₀. Proof with auto. intros * Hcnt Heq. destruct (classic (a ∈ A)) as [|Ha']. 2: rewrite <- (remove_no_member A a)... rewrite <- (remove_one_member_then_return A a)... rewrite repl_bunion_distr, union_bunion_distr. rewrite repl_single, union_single. apply add_countably_many_members_to_cntinf... Qed. Lemma repl_of_cnt_cnt : AC_II → ∀ F A, countable A → countable {F x | x ∊ A}. Proof with auto. intros AC2 F A Hcnt. eapply dominate_trans. 2: apply Hcnt. set (Func A {F x | x ∊ A} F) as f. apply AC_II_to_IV, AC_IV_to_III, AC_III_to_I in AC2. apply (domain_of_surjection_dominate_range AC2 _ _ f). apply meta_surjection. - intros x Hx. eapply ReplI... - intros y Hy. apply ReplAx... Qed. Lemma cntinf_ord_neq_0 : ∀α ⋵ 𝐎𝐍, |α| = ℵ₀ → α  0. Proof. intros α Hα Hcinf H0. subst. symmetry in Hcinf. rewrite pred, card_of_empty, card_eq_0 in Hcinf; nauto. Qed. Local Hint Resolve cntinf_ord_neq_0 : core. Lemma ord_lt_cnt_cnt : ∀α ⋵ 𝐎𝐍, countable α → ∀β ∈ α, countable β. Proof with eauto. intros α Hoα Hcnt β Hβ. assert (Hoβ: β ⋵ 𝐎𝐍). apply (ord_is_ords α)... eapply dominate_trans. apply dominate_sub. apply ord_lt_iff_psub; revgoals... apply Hcnt. Qed. Theorem ord_suc_cntinf : AC_II → ∀α ⋵ 𝐎𝐍, |α| = ℵ₀ → |α⁺| = ℵ₀. 
-> correct_cenv_of_val cenv v. Definition correct_envs: ctor_env -> n_ind_env -> M.t ctor_rep -> cps.M.t cps.val -> exp -> Prop := fun cenv ienv crep_env rho e => correct_ienv_of_cenv cenv ienv /\ correct_cenv_of_env cenv rho /\ correct_cenv_of_exp cenv e /\ correct_crep_of_env cenv crep_env. Theorem correct_envs_subterm: forall cenv ienv crep rho e, correct_envs cenv ienv crep rho e -> forall e', subterm_e e' e -> correct_envs cenv ienv crep rho e'. Proof. intros. inv H. inv H2. inv H3. split; auto. split; auto. split; auto. eapply Forall_constructors_subterm; eauto. Qed. Theorem correct_envs_set: forall cenv ienv crep rho x v e, correct_envs cenv ienv crep rho e -> correct_cenv_of_val cenv v -> correct_envs cenv ienv crep (M.set x v rho) e. Proof. intros. inv H. inv H2. inv H3. split; auto. split; auto. intro; intros. destruct (var_dec x0 x). - subst. rewrite M.gss in H3. inv H3. auto. - rewrite M.gso in H3 by auto. eapply H; eauto. Qed. Definition correct_tinfo: program -> Z -> temp_env -> mem -> Prop := fun p max_alloc lenv m => exists alloc_b alloc_ofs limit_ofs args_b args_ofs tinf_b tinf_ofs, M.get allocIdent lenv = Some (Vptr alloc_b alloc_ofs) /\ (align_chunk int_chunk | Ptrofs.unsigned alloc_ofs)%Z /\ Mem.range_perm m alloc_b (Ptrofs.unsigned alloc_ofs) (Ptrofs.unsigned limit_ofs) Cur Writable /\ M.get limitIdent lenv = Some (Vptr alloc_b limit_ofs) /\ (int_size*max_alloc <= (Ptrofs.unsigned limit_ofs - Ptrofs.unsigned alloc_ofs) <= gc_size)%Z /\ M.get argsIdent lenv = Some (Vptr args_b args_ofs) /\ args_b <> alloc_b /\ ((Ptrofs.unsigned args_ofs)+ int_size * max_args <= Ptrofs.max_unsigned)%Z /\ (forall i, 0 <= i < max_args -> Mem.valid_access m int_chunk args_b (Ptrofs.unsigned (Ptrofs.add args_ofs (Ptrofs.mul (Ptrofs.repr int_size) (Ptrofs.repr i)))) Writable)%Z /\ M.get tinfIdent lenv = Some (Vptr tinf_b tinf_ofs) /\ tinf_b <> args_b /\ tinf_b <> alloc_b /\ (forall i, 0 <= i < 4 -> Mem.valid_access m int_chunk tinf_b (Ptrofs.unsigned (Ptrofs.add tinf_ofs (Ptrofs.repr (int_size*i)))) Writable)%Z /\ deref_loc (Tarray uval maxArgs noattr) m tinf_b (Ptrofs.add tinf_ofs (Ptrofs.repr (int_size*3))) (Vptr args_b args_ofs) /\ (forall x b, Genv.find_symbol (globalenv p) x = Some b -> b <> args_b /\ b <> alloc_b /\ b <> tinf_b /\ (exists chunk, Mem.valid_access m chunk b 0%Z Nonempty)). Theorem range_perm_to_valid_access: forall alloc_b alloc_ofs limit_ofs size m, Mem.range_perm m alloc_b alloc_ofs limit_ofs Cur Writable -> forall ofs, (align_chunk size | ofs)%Z -> (alloc_ofs <= ofs)%Z -> (ofs + size_chunk size <= limit_ofs)%Z -> Mem.valid_access m size alloc_b ofs Writable. Proof. intros. constructor; auto. intro. intro. eapply H. omega. Qed. Theorem correct_tinfo_mono: forall p z lenv m, correct_tinfo p z lenv m -> forall z', (0 <= z' <= z)%Z -> correct_tinfo p z' lenv m. 
tr -> network_invariant net -> network_invariant net'. Proof using. intros. invc H; simpl in *. - unfold network_invariant in *. simpl. find_apply_lem_hyp PB_net_defn'. workhorse; auto; intuition eauto. - unfold network_invariant in *. simpl. find_apply_lem_hyp PB_input_handler_defn. workhorse; auto; intuition eauto. Qed. Lemma network_invariant_init : network_invariant step_async_init. Proof using. unfold network_invariant. simpl. auto. Qed. Lemma correspond_Prefix : forall st net tr_1 tr_m, correspond st (nwState net) tr_1 tr_m -> Prefix (outputs_m tr_m) (outputs_1 tr_1). Proof using. unfold correspond. intros. break_let. intuition. subst. eauto using app_Prefix. Qed. Fixpoint revert_trace (tr : list (name * ((@input PB_base_params) + list (@output PB_base_params)))) : list (@input base_params * (@output base_params)) := match tr with | [] => [] | (h, t) :: tr' => match t with | inr l => filterMap (fun x => match x with | RequestResponse i os => Some (i, os) | _ => None end) l | _ => [] end ++ revert_trace tr' end. Definition revert_state (net : network) : @data base_params := state (nwState net Primary). Lemma revert_state_defn : forall net, revert_state net = state (nwState net Primary). Proof using. unfold revert_state. auto. Qed. Lemma inductive_simulation : forall net net' tr, step_async net net' tr -> step_1_star (revert_state net) (revert_state net') (revert_trace tr). Proof using. intros. invc H. - repeat rewrite revert_state_defn. simpl. rewrite app_nil_r. simpl in *. find_apply_lem_hyp PB_net_defn. intuition; subst. + rewrite update_nop. constructor. + rewrite update_nop. constructor. + break_exists. intuition; break_let. * intuition. subst. rewrite <- app_nil_r. econstructor; constructor. repeat find_rewrite. rewrite update_eq by auto. auto. * break_exists. intuition. subst. simpl in *. rewrite <- app_nil_r. econstructor; constructor. repeat find_rewrite. rewrite update_eq by auto. auto. + repeat find_rewrite. rewrite update_diff by auto. constructor. - repeat rewrite revert_state_defn. simpl in *. find_apply_lem_hyp PB_input_handler_defn. intuition; subst. + rewrite update_eq by auto. repeat find_rewrite. constructor. + rewrite update_nop. constructor. + rewrite update_diff by auto. constructor. Qed. Lemma revert_trace_app : forall tr1 tr2, revert_trace (tr1 ++ tr2) = revert_trace tr1 ++ revert_trace tr2. Proof using. induction tr1; intros; simpl. - auto. - rewrite IHtr1. repeat break_match; subst. + auto. + rewrite app_ass. auto. Qed. Lemma simulation : forall net tr, step_async_star step_async_init net tr -> step_1_star init (revert_state net) (revert_trace tr). Proof using. intros. apply refl_trans_1n_n1_trace in H. prep_induction H. induction H; intros; subst. - unfold step_async_init, revert_state. constructor. - repeat concludes. rewrite revert_trace_app. unfold step_1_star. find_apply_lem_hyp inductive_simulation. simpl in *. unfold step_1_star in *. eauto using refl_trans_1n_trace_trans. Qed. Theorem transformer : forall (P : list (input * output) -> Prop), (forall st tr, step_1_star init st tr -> P tr) -> (forall net tr, step_async_star step_async_init net tr -> P (revert_trace tr)). 
(w := w). erewrite wnot_word_mask_l_gt_0 by omega. unfold wand. unfold eq_rec. erewrite <- eq_rect_bitwp'; f_equal. repeat erewrite <- combine_bitwp; f_equal. - rewrite wand_comm, wand_wones. reflexivity. - rewrite wand_comm, wand_wzero. rewrite wand_comm, wand_wones. reflexivity. Qed. Theorem word_updN_shift_abs : forall off idx n w v, let H := word_shift_helper3 idx off n in let H1 := word_shift_helper4 idx off n in let w' := eq_rec _ word w _ (eq_sym H) in let w'' := eq_rec _ word w _ H1 in @word_updN_shift (idx + 1 + off) n idx w v = eq_rec _ word ( combine (split1 (idx * n) (n + off * n) w') (combine v (split2 (idx * n + n) (off * n) w''))) _ H. Proof. intros. assert ((idx + 1 + off) * n = idx * n + n + off * n) as Hc by lia. erewrite eq_rect_combine_dist3 with (w := w). erewrite word_updN_shift_l_gt_0. erewrite wand_wnot_word_mask_w. unfold wlshift, zext. eq_rect_simpl. rewrite split1_combine. rewrite eq_rect_combine_assoc'. rewrite split2_combine. unfold wor. rewrite eq_rect_bitwp_1. f_equal. replace (eq_rect ((idx + 1 + off) *n) word (split1 _ (idx * n) _) _ _) with (combine (wzero (idx * n)) (combine v (wzero (off * n)))). - repeat rewrite <- combine_bitwp. repeat rewrite wor_wzero. repeat try (rewrite wor_comm, wor_wzero). reflexivity. - erewrite split1_eq_rect_eq1. repeat (eq_rect_simpl; erewrite split1_eq_rect_combine_partial; f_equal). erewrite wzero_dist, wzero_rev, <- combine_wzero. eq_rect_simpl. symmetry; apply split1_combine. Grab Existential Variables. all : lia. Qed. Fact word_updN_abs_helper : forall idx off, idx < idx + 1 + off. Proof. intros. omega. Qed. Theorem word_updN_abs : forall idx off ft w v, let H := word_shift_helper3 idx off (len ft) in let H1 := word_shift_helper4 idx off (len ft) in let w' := eq_rec _ word w _ (eq_sym H) in let w'' := eq_rec _ word w _ H1 in @word_updN ft (idx + 1 + off) idx w v = eq_rec _ word ( combine (split1 (idx * len ft) (len ft + off * len ft) w') (combine v (split2 (idx * len ft + len ft) (off * len ft) w''))) _ H. Proof. unfold word_updN; simpl. intros. destruct lt_dec; try omega. repeat eexists. eq_rect_simpl; apply eq_rect_both. rewrite eq_rect_word_offset; eq_rect_simpl. rewrite eq_rect_combine; f_equal. + erewrite eq_rect_split1_eq2. eq_rect_simpl; f_equal. apply eq_rect_both. eq_rect_simpl; reflexivity. + apply eq_rect_both. rewrite eq_rect_combine. rewrite eq_rect_split2. eq_rect_simpl. repeat (try reflexivity; f_equal; eq_rect_simpl; try apply eq_rect_both). Grab Existential Variables. all : simpl; lia. Qed. Theorem word_updN_shift_equiv : forall l idx ft w v, idx < l -> @word_updN_shift l (len ft) idx w v = @word_updN ft l idx w v. 
Set Implicit Arguments.Definition ifdec (A B:Prop) (C:Type) (H:{A} + {B}) (x y:C) : C := if H then x else y. Theorem ifdec_left : forall (A B:Prop) (C:Set) (H:{A} + {B}), ~ B -> forall x y:C, ifdec H x y = x. 
Require Export Qpositive. Definition Qpositive_plus (w w' : Qpositive) : Qpositive := let (p, q) := Qpositive_i w in let (p', q') := Qpositive_i w' in Qpositive_c (p * q' + p' * q) (q * q') (p * q' + p' * q + q * q'). Theorem Qpositive_plus_1 : forall w : Qpositive, Qpositive_plus One w = nR w. 
Definition pred_partial: forall (n : nat), n <> 0 -> nat. Proof. refine (fun n:nat => match n return n <> 0 -> nat with 0 => fun h => False_rec _ _ | S p => fun h => p end). - now destruct h. Defined. Scheme le_ind_max := Induction for le Sort Prop. Theorem le_2_n_not_zero: forall (n : nat), 2 <= n -> n <> 0. Proof. intros n Hle; elim Hle; intros; discriminate. Qed. Theorem le_2_n_pred: forall (n : nat) (h : 2 <= n), pred_partial n (le_2_n_not_zero n h) <> 0. 
In X a -> exists a0:M, least_member X a0 }. Section About_WO. Context (Wo : WO). Lemma Lt_connect : forall a b, Lt a b \/ a = b \/ Lt b a. Proof. intros a b ; generalize (well_order (Couple _ a b) a ). destruct 1 as [ c H1]. - left. - destruct H1 as [H2 H3]. destruct H2. + destruct (H3 b);auto; now right. + destruct (H3 a);auto; now left. Qed. Lemma Le_refl : forall x:M, Le x x. Proof. red;unfold Le;auto. Qed. Lemma Le_antisym : forall a b, Le a b -> Le b a -> a = b. Proof. intros a b H H'; case H; case H' ; try tauto. - symmetry; tauto. - intros;case (Lt_irreflexive (a:=a)); eapply (Lt_trans );eauto. Qed. #[global] Instance Le_trans : Transitive Le. Proof. unfold Transitive, Le;intros. case H;case H0. - intros; left ; congruence. - intros H1 H2; right;subst x;auto. - intros H1 H3; right ; subst y; auto. - right;apply Lt_trans with y;eauto. Qed. Lemma Le_Lt_trans : forall x y z, Le x y -> Lt y z -> Lt x z. Proof. intros x y z Hxy Hyz; case Hxy;intros. - now subst y. - eapply Lt_trans; eauto. Qed. Lemma Lt_Le_trans : forall x y z, Lt x y -> Le y z -> Lt x z. Proof. intros x y z Hxy Hyz; destruct Hyz as [H0 | H]. - now subst. - eapply Lt_trans; eauto. Qed. Lemma Lt_not_Gt : forall x y, Lt x y -> ~ Lt y x. Proof. intros x y H H'; case (Lt_irreflexive (a:=x)). eapply Lt_trans; eauto. Qed. Lemma least_member_lower_bound : forall X a, least_member X a -> forall b, In X b -> Le a b. Proof. intros X a H; case H. unfold In; intuition. Qed. Lemma least_member_glb : forall X a, least_member X a -> forall b, (forall c, In X c -> Le b c) -> Le b a. Proof. intros X a H b H0; case H;intros H1 H2; apply H0; auto. Qed. Theorem least_member_unicity : forall X a b, least_member X a -> least_member X b -> a = b. Proof. intros X a b H H0; case H;case H0;intros. - apply Le_antisym;auto. Qed. Theorem least_member_ex_unique : forall X x (inhX: In X x), exists! a, least_member X a. Proof. intros;destruct (well_order X x); auto. exists x0; split; auto. intros; eapply least_member_unicity;eauto. Qed. Theorem least_member_of_eq : forall (X Y : Ensemble M) a b , Included X Y -> Included Y X -> least_member X a -> least_member Y b -> a = b. 
| auto with zarith ]. replace precision with (S (pred precision)); [ auto with zarith | inversion precisionGreaterThanOne; auto ]. apply OddOpp; apply EvenSOddInv; rewrite <- Zsucc_pred; auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem FoddSuc : forall p : float, Fodd p -> Feven (FSucc b radix precision p). intros p H'; case (FevenSucProp p); auto. Qed. Theorem FevenSuc : forall p : float, Feven p -> Fodd (FSucc b radix precision p). intros p H'; case (FevenSucProp p); auto. Qed. Theorem FevenFop : forall p : float, Feven p -> Feven (Fopp p). intros p; unfold Feven, Fopp in |- *; simpl in |- *; auto with zarith. Qed. Theorem FoddFop : forall p : float, Fodd p -> Fodd (Fopp p). intros p; unfold Fodd, Fopp in |- *; simpl in |- *; auto with zarith. Qed. Theorem FevenPred : forall p : float, Fodd p -> Feven (FPred b radix precision p). intros p H'; rewrite FPredFopFSucc; auto with arith. apply FevenFop; auto. apply FoddSuc; auto. apply FoddFop; auto with arith. Qed. Theorem FoddPred : forall p : float, Feven p -> Fodd (FPred b radix precision p). intros p H'; rewrite FPredFopFSucc; auto with arith. apply FoddFop; auto. apply FevenSuc; auto. apply FevenFop; auto. Qed. Definition FNodd (p : float) := Fodd (Fnormalize radix b precision p). Definition FNeven (p : float) := Feven (Fnormalize radix b precision p). Theorem FNoddEq : forall f1 f2 : float, Fbounded b f1 -> Fbounded b f2 -> f1 = f2 :>R -> FNodd f1 -> FNodd f2. intros f1 f2 H' H'0 H'1 H'2; red in |- *. rewrite FcanonicUnique with (3 := pGivesBound) (p := Fnormalize radix b precision f2) (q := Fnormalize radix b precision f1); auto with float arith. repeat rewrite FnormalizeCorrect; auto. Qed. Theorem FNevenEq : forall f1 f2 : float, Fbounded b f1 -> Fbounded b f2 -> f1 = f2 :>R -> FNeven f1 -> FNeven f2. intros f1 f2 H' H'0 H'1 H'2; red in |- *. rewrite FcanonicUnique with (3 := pGivesBound) (p := Fnormalize radix b precision f2) (q := Fnormalize radix b precision f1); auto with float arith. repeat rewrite FnormalizeCorrect; auto. Qed. Theorem FNevenFop : forall p : float, FNeven p -> FNeven (Fopp p). intros p; unfold FNeven in |- *. rewrite Fnormalize_Fopp; auto with arith. intros; apply FevenFop; auto. Qed. Theorem FNoddFop : forall p : float, FNodd p -> FNodd (Fopp p). 
round, Ztrunc. case Rlt_bool_spec. easy. intros [H|H]. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- canonic_exp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. rewrite <- H. change 0%R with (Z2R 0). now rewrite Zfloor_Z2R, Zceil_Z2R. Qed.Theorem round_AW_pos : forall x, (0 <= x)%R -> round Zaway x = round Zceil x. Proof. intros x Hx. unfold round, Zaway. case Rlt_bool_spec. intros H. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- canonic_exp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. easy. Qed.Theorem round_AW_neg : forall x, (x <= 0)%R -> round Zaway x = round Zfloor x. Proof. intros x Hx. unfold round, Zaway. case Rlt_bool_spec. easy. intros [H|H]. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- canonic_exp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. rewrite <- H. change 0%R with (Z2R 0). now rewrite Zfloor_Z2R, Zceil_Z2R. Qed.Theorem generic_format_round : forall rnd { Hr : Valid_rnd rnd } x, generic_format (round rnd x). Proof with auto with typeclass_instances. intros rnd Zrnd x. destruct (total_order_T x 0) as [[Hx|Hx]|Hx]. rewrite <- (Ropp_involutive x). destruct (round_DN_or_UP rnd (- - x)) as [Hr|Hr] ; rewrite Hr. rewrite round_DN_opp. apply generic_format_opp. apply generic_format_round_pos... now apply Ropp_0_gt_lt_contravar. rewrite round_UP_opp. apply generic_format_opp. apply generic_format_round_pos... now apply Ropp_0_gt_lt_contravar. rewrite Hx. rewrite round_0... apply generic_format_0. now apply generic_format_round_pos. Qed.Theorem round_DN_pt : forall x, Rnd_DN_pt generic_format x (round Zfloor x). Proof with auto with typeclass_instances. intros x. split. apply generic_format_round... split. pattern x at 2 ; rewrite <- scaled_mantissa_mult_bpow. unfold round, F2R. simpl. apply Rmult_le_compat_r. apply bpow_ge_0. apply Zfloor_lb. intros g Hg Hgx. apply round_ge_generic... Qed.Theorem generic_format_satisfies_any : satisfies_any generic_format. Proof. split.exact generic_format_0. exact generic_format_opp.intros x. eexists. apply round_DN_pt. Qed.Theorem round_UP_pt : forall x, Rnd_UP_pt generic_format x (round Zceil x). Proof. intros x. rewrite <- (Ropp_involutive x). rewrite round_UP_opp. apply Rnd_DN_UP_pt_sym. apply generic_format_opp. apply round_DN_pt. Qed.Theorem round_ZR_pt : forall x, Rnd_ZR_pt generic_format x (round Ztrunc x). Proof. intros x. split ; intros Hx. rewrite round_ZR_pos with (1 := Hx). apply round_DN_pt. rewrite round_ZR_neg with (1 := Hx). apply round_UP_pt. Qed.Theorem round_DN_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> round Zfloor x = 0%R. Proof. intros x ex Hx He. rewrite <- (F2R_0 beta (canonic_exp x)). rewrite <- mantissa_DN_small_pos with (1 := Hx) (2 := He). now rewrite <- canonic_exp_fexp_pos with (1 := Hx). Qed. Theorem round_DN_UP_lt : forall x, ~ generic_format x -> (round Zfloor x < x < round Zceil x)%R. 
apply Rle_Fexp_eq_Zle with (radix := radix); auto with arith. repeat rewrite FshiftCorrect; auto. replace (Zsucc (Fnum (Fshift radix 1 p))) with (Fnum (FSucc p)); auto. apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with arith. repeat rewrite FshiftCorrect; auto. rewrite FSuccSimpl2; auto with arith. rewrite FSuccSimpl2; auto with arith. rewrite FSuccSimpl2; auto with arith. unfold Fshift in |- *; simpl in |- *. rewrite Z.mul_1_r; auto. unfold pPred in |- *; rewrite (PosNormMin radix) with (precision := precision); auto with zarith; rewrite H'1. rewrite Zopp_mult_distr_l_reverse. rewrite (Zmult_comm radix). apply Zopp_Zpred_Zs. unfold Fshift in |- *; simpl in |- *. replace (Zpos (P_of_succ_nat (Zabs_nat (Fexp q - Fexp p)))) with (Zsucc (Fexp q - Fexp p)). unfold Zsucc, Zpred in |- *; ring. rewrite <- (inj_abs (Fexp q - Fexp p)); auto with zarith. rewrite <- inj_S; simpl in |- *; auto. rewrite inj_abs; auto with zarith. rewrite FSuccSimpl4; auto. intros H'2 H'3. replace p with (Fshift radix (Zabs_nat (Fexp q - Fexp p)) q). unfold FtoRradix in |- *; rewrite FshiftCorrect; auto with real. cut (Fexp (Fshift radix (Zabs_nat (Fexp q - Fexp p)) q) = Fexp p); [ intros Eq0 | idtac ]. apply floatEq; auto. apply sym_equal; apply Zeq_Zs; auto. apply Rle_Fexp_eq_Zle with (radix := radix); auto with arith. rewrite FshiftCorrect; auto. replace (Zsucc (Fnum p)) with (Fnum (FSucc p)); auto. rewrite FSuccSimpl4; auto. apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with arith. repeat rewrite FshiftCorrect; auto. rewrite FSuccSimpl4; auto. unfold Fshift in |- *; simpl in |- *. rewrite inj_abs; auto with zarith. Qed. Definition FNSucc x := FSucc (Fnormalize radix b precision x). Theorem FNSuccCanonic : forall a : float, Fbounded b a -> Fcanonic radix b (FNSucc a). intros a H'; unfold FNSucc in |- *. apply FSuccCanonic; auto with float. Qed. Theorem FNSuccLt : forall a : float, (a < FNSucc a)%R. intros a; unfold FNSucc in |- *. unfold FtoRradix in |- *; rewrite <- (FnormalizeCorrect _ radixMoreThanOne b precision a). apply FSuccLt; auto. Qed. Theorem FNSuccProp : forall x y : float, Fbounded b x -> Fbounded b y -> (x < y)%R -> (FNSucc x <= y)%R. intros x y H' H'0 H'1; unfold FNSucc in |- *. replace (FtoRradix y) with (FtoRradix (Fnormalize radix b precision y)). apply FSuccProp; auto with float. unfold FtoRradix in |- *; repeat rewrite FnormalizeCorrect; auto. unfold FtoRradix in |- *; repeat rewrite FnormalizeCorrect; auto. Qed. Theorem FNSuccEq : forall p q : float, Fbounded b p -> Fbounded b q -> p = q :>R -> FNSucc p = FNSucc q. 
ord_trans... + apply enum_into_class... } exists α. split... pose proof (recursion_spec (γ C) α) as [_ [Hout Hmin]]... fold (Enumerate C) in *. rewrite ran_of_op_repl in *. assert (Hle: Enumerate C α ⋸ ξ). { apply Hmin... intros Hξ. apply ReplAx in Hξ as [β [Hβ Heq]]. apply ϕ_ReplAx in Hβ as [μ [Hμ [Hoβ Heqμ]]]... apply SepE1 in Hμ. subst. eapply ord_irrefl; revgoals... } destruct Hle... destruct (classic (ξ = Enumerate C α)) as [|Hnq]... exfalso. apply ord_connected in Hnq as []; [..|apply enum_operative]... - eapply ord_not_lt_gt; revgoals... apply enum_operative... - apply Hout. eapply ReplI. apply ϕ_ReplAx... exists (Enumerate C α). repeat split... apply SepI... apply enum_into_class... Qed. Corollary enum_onto_class : ∀ C, C ⫃ 𝐎𝐍 → unbounded C → Enumerate C :ᶜ 𝐎𝐍 ⟹ C. Proof with auto. intros C Hsub Hund. split. apply enum_into_class... apply enum_surjective... Qed. Theorem enum_iff_class : ∀ C, C ⫃ 𝐎𝐍 → unbounded C → ∀ ξ, ξ ⋵ C ↔ ∃ α, α ⋵ 𝐎𝐍 ∧ Enumerate C α = ξ. Proof with auto. split. apply enum_surjective... intros [α [Hoα Heq]]. subst. apply enum_into_class... Qed.End 𝐎𝐍Separation. Section Aleph. Import 𝐎𝐍Separation.Definition ℵ := Enumerate 𝐂𝐃ⁱⁿ .Lemma infcard_is_sub : 𝐂𝐃ⁱⁿ ⫃ 𝐎𝐍. Proof. exact infcard_is_ord. Qed. Local Hint Resolve infcard_is_sub : core.Open Scope Card_scope.Lemma infcard_unbounded : unbounded 𝐂𝐃ⁱⁿ . Proof with eauto. intros α Hoα. apply all_ord_ex_larger_card in Hoα as [ [H Hα]]. assert (Hcs:  + ℵ₀ ⋵ 𝐂𝐃)... assert (Hos:  + ℵ₀ ⋵ 𝐎𝐍)... apply all_ord_ex_larger_card in Hos as [𝜆 [H𝜆 Hlt]]. exists 𝜆. split. - split... apply (parent_set_of_infinite_is_infinite ( + ℵ₀)). apply ord_le_iff_sub... apply cardAdd_infinite_iff... - eapply ord_trans... cut ( <𝐜 𝜆). apply cardLt_iff_ord_lt. eapply cardLe_lt_trans; revgoals. apply cardLt_iff_ord_lt... apply cardAdd_enlarge... Qed. Local Hint Resolve infcard_unbounded : core. Lemma aleph_spec : ∀α ⋵ 𝐎𝐍, ∀ξ ⋵ 𝐂𝐃ⁱⁿ , ξ ∉ {ℵ x | x ∊ α} → ℵ α ⋸ ξ. Proof. intros α Hα ξ Hξ. apply (enum_spec 𝐂𝐃ⁱⁿ ); auto. Qed. Lemma aleph_is_infcard : ℵ :ᶜ 𝐎𝐍 ⇒ 𝐂𝐃ⁱⁿ . Proof. apply enum_into_class; auto. Qed. Lemma aleph_operative : ℵ :ᶜ 𝐎𝐍 ⇒ 𝐎𝐍. Proof. intros. apply enum_operative; auto. Qed. Lemma aleph_is_card : ∀ α, α ⋵ 𝐎𝐍 → ℵ α ⋵ 𝐂𝐃. Proof. intros. apply aleph_is_infcard; auto. Qed. Local Hint Resolve aleph_is_card : core. Lemma aleph_infinite : ∀ α, α ⋵ 𝐎𝐍 → infinite (ℵ α). Proof. intros. apply aleph_is_infcard; auto. Qed. Local Hint Resolve aleph_infinite : core. Theorem aleph_monotone : monotone ℵ. 
pickinSetp a (pX b p) (exist (fun l0 : list (Term A n) => canonical A0 eqA ltM l0) (pX b p) H :: P) | pickinSetskip : forall (a b : Term A n) (p : list (Term A n)) (q : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), pickinSetp a p P -> pickinSetp a p (q :: P). Hint Resolve pickinSeteqp pickinSetskip. Lemma pickin_is_pX : forall (a : Term A n) (p : list (Term A n)) (Q : list (poly A0 eqA ltM)), pickinSetp a p Q -> exists b : Term A n, (exists q : list (Term A n), p = pX b q). intros a p Q H'; elim H'; auto. intros a0 b p0 H'0 H'1 H'2; exists b; exists p0; auto. Qed. Inductive reducehead (Q : list (poly A0 eqA ltM)) : list (Term A n) -> list (Term A n) -> Prop := reduceheadO : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q : list (Term A n)), pickinSetp a (pX b q) Q -> reducehead Q (pX a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q). Hint Resolve reduceheadO. Lemma pick_inv_in : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)), pickinSetp a p Q -> inPolySet p Q. intros Q a p H'; elim H'; auto. Qed. Lemma pick_inv_eqT_lem : forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p : list (Term A n)), pickinSetp a p Q -> forall (b : Term A n) (q : list (Term A n)), p = pX b q -> divP A A0 eqA multA divA n a b. intros Q a p H'; elim H'; auto. intros a0 b p0 H'0 H'1 H'2 b0 q H'3; injection H'3; auto. intros H'4 H'5; rewrite <- H'5; auto. Qed. Lemma pick_inv_eqT : forall (Q : list (poly A0 eqA ltM)) (a b : Term A n) (p q : list (Term A n)), pickinSetp a (pX b q) Q -> divP A A0 eqA multA divA n a b. intros Q a b H' q H'0. apply pick_inv_eqT_lem with (Q := Q) (p := pX b q) (q := q); auto. Qed. Theorem reducehead_imp_reduce : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reducehead Q p q -> reduce Q p q. 
v) (elements m) -> get i m = Some v. Proof. intros A m i v H. exploit in_xelements; eauto. intros (j & P & Q). rewrite prev_append_prev in P. change i with (prev_append 1 i) in P. exploit prev_append_inj; eauto. intros; congruence. Qed. Definition xkeys {A} (m: t A) (i: positive) := List.map fst (xelements m i). Lemma xkeys_Node: forall A (m1: t A) o (m2: t A) i, xkeys (Node m1 o m2) i = xkeys m1 (xO i) ++ match o with None => nil | Some v => prev i :: nil end ++ xkeys m2 (xI i). Proof. intros. unfold xkeys. rewrite xelements_Node, ! map_app. destruct o; auto. Qed. Lemma in_xkeys: forall (A: Type) (m: t A) (i k: positive), In k (xkeys m i) -> (exists j, k = prev (prev_append j i)). Proof. unfold xkeys; intros. apply (list_in_map_inv) in H. destruct H as ((j, v) & -> & H). exploit in_xelements; eauto. intros (k & P & Q). exists k; auto. Qed. Lemma xelements_keys_norepet: forall (A: Type) (m: t A) (i: positive), list_norepet (xkeys m i). Proof. intros A; induction m using tree_ind; intros. - constructor. - assert (NOTIN1: ~ In (prev i) (xkeys l (xO i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (NOTIN2: ~ In (prev i) (xkeys r (xI i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (DISJ: forall x, In x (xkeys l (xO i)) -> In x (xkeys r (xI i)) -> False). { intros. exploit in_xkeys. eexact H0. intros (j1 & EQ1). exploit in_xkeys. eexact H1. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_Node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H1. destruct H1. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall A (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall A (m: t A) i, (forall i, get i m = None) -> xelements m i = nil. Proof. intros. replace m with (@Empty A). auto. apply extensionality; intros. symmetry; auto. Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). 
Require Import Coq.Logic.FunctionalExtensionality. Require Import Main.CategoryTheory.Category. Require Import Main.CategoryTheory.Examples.Set. Require Import Main.CategoryTheory.Functor. Require Import Main.CategoryTheory.Monad. Require Import Main.CategoryTheory.NaturalTransformation. Require Import Main.Tactics.Inductive maybe x : Type := | nothing : maybe x | just : x -> maybe x.Arguments nothing {_}. Arguments just {_}.#[local] Theorem maybeFIdent (x : object setCategory) : ( fun e : maybe x => match e with | nothing => nothing | just e0 => just (@id setCategory x e0) end ) = @id setCategory (maybe x). Proof. clean. apply functional_extensionality. destruct x0; magic. Qed.#[local] Theorem maybeFComp (x y z : object setCategory) (f : arrow x y) (g : arrow y z) : @compose setCategory _ _ _ ( fun e : maybe y => match e with | nothing => nothing | just e0 => just (g e0) end ) ( fun e : maybe x => match e with | nothing => nothing | just e0 => just (f e0) end ) = ( fun e : maybe x => match e with | nothing => nothing | just e0 => just (compose g f e0) end ). Proof. clean. apply functional_extensionality. destruct x0; magic. Qed.Definition maybeFunctor : functor setCategory setCategory := newFunctor setCategory setCategory maybe (fun _ _ f e => match e with | nothing => nothing | just e => just (f e) end ) maybeFIdent maybeFComp.#[local] Theorem maybeEtaNaturality (x y : object setCategory) (f : arrow x y) : @compose setCategory _ _ _ just (fMap idFunctor f) = @compose setCategory _ _ _ (fMap maybeFunctor f) just. 
: S -> Prop), ForAll Sini Pg -> (forall s : S, Pg s -> Pp s) -> ForAll Sini Pp. Proof. unfold ForAll in |- *; intros. apply H0. apply H; assumption. Qed. Theorem Mon_I_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> ForAll_T Sini Pp bound. Proof. unfold ForAll_T in |- *; intros. apply H0. apply (H s t); assumption. Qed. Theorem Conj : forall (Sini : S) (P1 P2 : S -> Prop), ForAll Sini P1 -> ForAll Sini P2 -> ForAll Sini (fun s : S => P1 s /\ P2 s). Proof. unfold ForAll in |- *; intros. split; [ apply H | apply H0 ]; assumption. Qed. Theorem Conj_T : forall (Sini : S) (P1 P2 : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P1 bound -> ForAll_T Sini P2 bound -> ForAll_T Sini (fun s : S => P1 s /\ P2 s) bound. Proof. unfold ForAll_T in |- *; intros. split; [ apply (H s t) | apply (H0 s t) ]; assumption. Qed. Theorem Mon_I_EX : forall (Sini : S) (Pg Pp : S -> Prop), Exists Sini Pg -> (forall s : S, Pg s -> Pp s) -> Exists Sini Pp. Proof. intros. inversion_clear H. apply (exists_ H1 (H0 s H2)). Qed. Theorem Mon_I_EX_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), Exists_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> Exists_T Sini Pp bound. Proof. intros. inversion_clear H. apply (exists_T H1 H2 (H0 s H3)). Qed. Lemma RState_Trans : forall s1 s2 s3 : S, RState s1 s2 -> RState s2 s3 -> RState s1 s3. Proof. intros. elim H0; [ assumption | intros ]. apply (rsNext H2 H3). Qed. Lemma RState_Trans_T : forall (s1 s2 s3 : S) (t1 t2 : Instant), RState_T s1 s2 t1 -> RState_T s2 s3 t2 -> RState_T s1 s3 (plus_Ck t1 t2). Proof. simple induction 2; unfold plus_Ck in |- *; intros. rewrite (plus_comm t1 time0); unfold time0 in |- *; simpl in |- *; assumption. unfold Inc in |- *; unfold plus_Ck in |- *; rewrite (plus_assoc t1 t tick). apply (rsTime_T H2 H3). apply (rsNoTime_T H2 H3 H4). Qed. Theorem StepsEX : forall (s1 s2 : S) (P : S -> Prop), RState s1 s2 -> Exists s2 P -> Exists s1 P. 
: Monoid.is_id_l E sum E_0; sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0; prod_is_assoc : Monoid.is_assoc E prod; prod_is_comm : Abelian_Group.is_comm E prod; prod_id_l : Monoid.is_id_l E prod E_1; prod_sum_distrib_l : Ring.is_distrib_l E prod sum }. Arguments E_0 {c}.Arguments E_1 {c}.Arguments sum {c} x y.Arguments prod {c} x y.Arguments distinct_0_1 {c} _.Arguments sum_is_assoc {c} x y z.Arguments sum_is_comm {c} x y.Arguments sum_id_l {c} x.Arguments sum_inv_l_ex {c} x.Arguments prod_is_assoc {c} x y z.Arguments prod_id_l {c} x.Arguments prod_sum_distrib_l {c} x y z.Arguments prod_is_comm {c} x y.Notation "0" := E_0 : commutative_ring_scope.Notation "1" := E_1 : commutative_ring_scope.Notation "x + y" := (sum x y) (at level 50, left associativity) : commutative_ring_scope.Notation "{+}" := sum : commutative_ring_scope.Notation "x # y" := (prod x y) (at level 50, left associativity) : commutative_ring_scope.Notation "{#}" := prod : commutative_ring_scope.Open Scope commutative_ring_scope.Section Theorems. Variable r : Commutative_Ring. Let E := E r. Definition sum_is_id_l := Monoid.is_id_l E {+}. Definition sum_is_id_r := Monoid.is_id_r E {+}. Definition sum_is_id := Monoid.is_id E {+}. Definition prod_is_id_l := Monoid.is_id_l E {#}. Definition prod_is_id_r := Monoid.is_id_r E {#}. Definition prod_is_id := Monoid.is_id E {#}. Theorem prod_id_r : prod_is_id_r 1. Proof fun x : E => eq_ind_r (fun a => a = x) (prod_id_l x) (prod_is_comm x 1). Theorem prod_sum_distrib_r : Ring.is_distrib_r E {#} {+}. Proof fun x y z : E => prod_sum_distrib_l x y z || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z || a = (y # x) + (z # x) @a by <- prod_is_comm x (y + z). Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r. Definition sum_abelian_group := Ring.sum_abelian_group ring. Definition sum_group := Ring.sum_group ring. Definition sum_monoid := Ring.sum_monoid ring. Definition prod_monoid := Ring.prod_monoid ring. Theorem distinct_1_0 : E_1 (c := r) <> E_0 (c := r). Proof fun H : E_1 = E_0 => distinct_0_1 (eq_sym H). Definition nonzero : E -> Prop := Ring.nonzero ring. Theorem sum_id_r : sum_is_id_r 0. Proof Ring.sum_id_r ring. Theorem sum_id : sum_is_id 0. Proof Ring.sum_id ring. Definition sum_is_inv_l := Ring.sum_is_inv_l ring. Definition sum_is_inv_r := Ring.sum_is_inv_r ring. Definition sum_is_inv := Ring.sum_is_inv ring. Definition sum_has_inv_l := Ring.sum_has_inv_l ring. Definition sum_has_inv_r := Ring.sum_has_inv_r ring. Definition sum_has_inv := Ring.sum_has_inv ring. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. 
: float) := (0 <= r)%R /\ isMin b radix r p \/ (r <= 0)%R /\ isMax b radix r p. Theorem ToZeroTotal : TotalP ToZeroP. red in |- *; intros r; case (Rle_or_lt r 0); intros H1. case MaxEx with (r := r) (3 := pGivesBound); auto with arith. intros x H'; exists x; red in |- *; auto. case MinEx with (r := r) (3 := pGivesBound); auto with arith. intros x H'; exists x; red in |- *; left; split; auto. apply Rlt_le; auto. Qed. Theorem ToZeroCompatible : CompatibleP ToZeroP. red in |- *. intros r1 r2 p q H'; case H'. intros H'0 H'1 H'2; left; split; try apply MinCompatible with (p := p) (r1 := r1); try rewrite <- H'1; auto; case H'0; auto. intros H'0 H'1 H'2; right; split; try apply MaxCompatible with (p := p) (r1 := r1); try rewrite <- H'1; auto; case H'0; auto. Qed. Theorem ToZeroMinOrMax : MinOrMaxP ToZeroP. red in |- *. intros r p H'; case H'; clear H'; intros H'; case H'; auto. Qed. Theorem ToZeroMonotone : MonotoneP radix ToZeroP. red in |- *. cut (FtoR radix (Fzero (- dExp b)) = 0%R); [ intros Eq0 | unfold FtoR in |- *; simpl in |- * ]; auto with real. simpl in |- *; intros p q p' q' H' H'0; case H'0; clear H'0. intros H'0; elim H'0; intros H'1 H'2; clear H'0; intros H'0. case H'0; intros H'3; elim H'3; clear H'3; auto. intros H'3 H'4. apply (MonotoneMin b radix) with (p := p) (q := q); auto. intros H'3 H'4. apply Rle_trans with p; [ apply isMin_inv1 with (1 := H'2); auto | idtac ]. apply Rle_trans with q; [ idtac | apply isMax_inv1 with (1 := H'4) ]; auto. apply Rlt_le; auto. intros H'0; elim H'0; intros H'1 H'2; clear H'0. intros H'0; case H'0; clear H'0; intros H'0; case H'0; intros H'3 H'4; clear H'0. apply Rle_trans with (FtoRradix (Fzero (- dExp b))); auto. elim H'2. intros H'0 H'5; elim H'5; intros H'6 H'7; apply H'7; clear H'5; auto. repeat split; simpl in |- *; auto with zarith. rewrite Eq0; auto. elim H'4. intros H'0 H'5; elim H'5; intros H'6 H'7; apply H'7; clear H'5; auto. repeat split; simpl in |- *; auto with zarith. rewrite Eq0; auto. apply (MonotoneMax b radix) with (p := p) (q := q); auto. Qed. Theorem ToZeroRoundedModeP : RoundedModeP ToZeroP. 
f). Proof. set (mon_prog_maps := (fun f : arrow_Poset P P => isaposetmorphism_hProp f ∧ isprogressive f) : hsubtype _). cut (carrier (is_greatest_suchthat mon_prog_maps)). { intros f. exact (make_greatest_suchthat (pr1 f) (pr2 f)). } cut (carrier (mon_prog_maps ∩ is_least_upper_bound_subtype mon_prog_maps)). { use subtype_inc. intros ? [? ?]. apply greatest_if_contains_sup; assumption. } cut (carrier (is_least_upper_bound_pointwise (@pr1carrier _ mon_prog_maps))). { use subtype_inc. intros f f_pw_lub; split; [ split | ]. - eapply isaposetmorphism_pointwise_lub; try eassumption. intros [g [g_mon g_prog]]; exact g_mon. - eapply progressive_pointwise_lub; try eassumption. { intros [g [g_mon g_prog]]; exact g_prog. } apply hinhpr. exists (idfun _); split. + apply isaposetmorphism_idfun. + apply isprogressive_idfun. - apply is_least_upper_bound_if_pointwise; assumption. } use (foralltototal _ (fun _ y => is_least_upper_bound _ y)). intros x. cut (least_upper_bound (fun g : mon_prog_maps => pr1 g x)). { intros p. exists p. apply least_upper_bound_property. } apply isdirected_lub; try assumption. split. - apply hinhpr. exists (idfun _); split. + apply isaposetmorphism_idfun. + apply isprogressive_idfun. - intros [f [f_mon f_prog]] [g [g_mon g_prog]]. apply hinhpr. use tpair. { exists (f ∘ g); split. + apply isaposetmorphism_compose; assumption. + apply isprogressive_compose; assumption. } split; simpl. + use f_mon; use g_prog. + use f_prog. Defined. Theorem fixpoint_for_monotone_on_dcpo {P : Poset} (P_dir: is_directed_complete P) (f : posetmorphism P P) (x : Postfixedpoint f) : ∑ y : Fixedpoint f, x ≤ y. Proof. revert x. set (postfix_f := (fun x => x ≤ f x) : Subposet P). assert (postfix_dc : is_directed_complete postfix_f). { intros [A A_dir]. use least_upper_bound_in_subposet. { use (isdirected_lub P_dir). assumption. } apply least_upper_bound_univ. intros [[x x_postfix] x_A]. eapply istrans_posetRelation. { apply x_postfix. } apply posetmorphism_property. refine (least_upper_bound_is_upper_bound _ (_,,_)). simple refine (value_in_image _ ((_,,_),,_)); assumption. } set (max_monprog_map := maximal_progressive_endomorphism_on_dcpo postfix_dc). destruct max_monprog_map as [[max_map [max_is_mon max_is_prog]] max_is_max]. transparent assert (f_restr_postfix : (arrow_Poset postfix_f postfix_f)). { intros x. exists (f (pr1 x)). apply posetmorphism_property, postfixedpoint_property. } assert (max_map_gives_fixedpoints : f_restr_postfix ∘ max_map ~ max_map). { intros x; apply isantisymm_posetRelation. 2: { apply postfixedpoint_property. } revert x. refine (max_is_max (_,,_)); split. - refine (@isaposetmorphism_compose _ _ _ max_map _ f_restr_postfix _). { assumption. } intros ? ?; apply (posetmorphism_property f). - refine (@isprogressive_compose _ f_restr_postfix max_map _ _). 2: { assumption. } intro; apply postfixedpoint_property. } intros x. simple refine ((pr1 (max_map x),,_),,_); simpl. - exact (maponpaths _ (max_map_gives_fixedpoints x)). - use max_is_prog. Defined.End Bourbaki_Witt.Section Check_Overview. Local Theorem fulfil_Tarski_fixpoint_theorem : Tarski_fixpoint_theorem_statement (is_complete) (@isfixedpoint). Proof. use @Tarski_fixpoint_theorem. Defined. Local Theorem fulfil_fixpoint_for_monotone_on_dcpo : fixpoint_for_monotone_on_dcpo_statement (is_directed_complete) (@ispostfixedpoint) (@isfixedpoint). 
grp b else if in_seq grp b then groupWith ls' grp a else grp :: addEquality ls' a b end. Fixpoint inSameGroup (grps : list (list A)) (a : A) (b : A) := match grps with | nil => false | g :: grps' => if in_seq g a then if in_seq g b then true else inSameGroup grps' a b else inSameGroup grps' a b end. Variable R : A -> A -> Prop. Hypothesis Rsym : forall x y, R x y -> R y x. Hypothesis Rtrans : forall x y z, R x y -> R y z -> R x z. Hypothesis A_seq_correct : forall x y, A_seq x y = true -> R x y. Fixpoint InR (x : A) (ls : list A) : Prop := match ls with | nil => False | y :: ls' => R y x \/ InR x ls' end. Definition groupEqualTo (a : A) := Forall (R a). Definition groupEqual (g : list A) := match g with | nil => True | a' :: g' => groupEqualTo a' g' end. Definition groupsEqual := Forall groupEqual. Hint Extern 1 (groupEqual _) => hnf. Hint Resolve Rsym Rtrans. Lemma Rweaken : forall x y l, Forall (R x) l -> R x y -> Forall (R y) l. induction 1; t. Qed. Hint Resolve Rweaken. Lemma groupEqualTo_groupEqual : forall x xs, Forall (R x) xs -> groupEqual xs. induction 1; t. Qed. Hint Resolve groupEqualTo_groupEqual. Hint Resolve Folds.Forall_app. Lemma groupEqualTo_In : forall x y g, InR y g -> Forall (R x) g -> R x y. induction 2; t. Qed. Hint Immediate groupEqualTo_In. Hint Extern 1 (Forall _ _) => progress hnf. Lemma in_seq_correct : forall (a : A) (ls : list A), in_seq ls a = true -> InR a ls. Proof. induction ls; t. Qed. Hint Resolve in_seq_correct A_seq_correct. Lemma groupWith_sound : forall x xs grps, Forall groupEqual grps -> Forall (R x) xs -> Forall groupEqual (groupWith grps xs x). induction 1; t. eauto 10. apply in_seq_correct in H3. eauto 7. Qed. Hint Resolve groupWith_sound. Theorem addEquality_sound : forall x y grps, groupsEqual grps -> R x y -> groupsEqual (addEquality grps x y). induction 1; t; match goal with | [ H : _ |- _ ] => apply A_seq_correct in H || apply in_seq_correct in H end; eauto 7. Qed. Theorem inSameGroup_sound : forall grps, groupsEqual grps -> forall x y, inSameGroup grps x y = true -> R x y. 
(sp a p) | IfEx e t f => vc t (p /\ is_true e) ++ vc f (p /\ is_false e) | WhileEx inv e body => (p --> inv) :: (sp body (inv /\ is_true e) --> inv) :: vc body (inv /\ is_true e) | AssertEx a => (p --> a) :: nil | SkipEx => nil | AssignEx _ _ => nil | _ => (p --> (fun env _ v => Safe env stmt v)) :: nil end. Definition and_all : list entailment -> entailment := fold_right (fun a b env => a env /\ b env)%type (fun _ => True). Require Import Bedrock.Platform.Cito.GeneralTactics. Lemma and_all_app : forall ls1 ls2 env, and_all (ls1 ++ ls2) env -> and_all ls1 env /\ and_all ls2 env. induction ls1; simpl; intuition. eapply IHls1 in H1; openhyp; eauto. eapply IHls1 in H1; openhyp; eauto. Qed. Lemma is_true_intro : forall e env v v', wneb (eval (fst v') e) $0 = true -> (is_true e) env v v'. intros. unfold is_true. unfold wneb in *. destruct (weq _ _) in *; intuition. Qed. Hint Resolve is_true_intro. Lemma is_false_intro : forall e env v v', wneb (eval (fst v') e) $0 = false -> (is_false e) env v v'. intros. unfold is_false. unfold wneb in *. destruct (weq _ _) in *; intuition. Qed. Hint Resolve is_false_intro. Hint Unfold RunsTo. Hint Constructors Semantics.RunsTo. Hint Unfold Safe. Hint Constructors Semantics.Safe. Ltac unfold_all := repeat match goal with | H := _ |- _ => unfold H in *; clear H end. Ltac inject := match goal with | H : _ = _ |- _ => unfold_all; injection H; intros; subst end. Lemma sound_runsto' : forall env (s : Stmt) v v', RunsTo env s v v' -> forall s' : StmtEx, s = s' -> forall p, and_all (vc s' p) env -> forall v0, p env v0 v -> (sp s' p) env v0 v'. induction 1; simpl; intros; destruct s'; try discriminate; simpl in *; try inject. eauto. openhyp. eauto. eapply and_all_app in H2; openhyp. eauto. eapply and_all_app in H2; openhyp. left. eapply IHRunsTo; eauto. split; eauto. eapply and_all_app in H2; openhyp. right. eapply IHRunsTo; eauto. split; eauto. openhyp. eapply (IHRunsTo2 (WhileEx _ e s')); simpl in *; eauto. eapply IHRunsTo1; simpl in *; eauto. split; eauto. openhyp. split; eauto. Focus 4. eauto. Focus 3. eauto. eauto. eauto. Qed. Theorem sound_runsto : forall env (s : StmtEx) v v' p v0, RunsTo env s v v' -> and_all (vc s p) env -> p env v0 v -> (sp s p) env v0 v'. 
Require Export ZArith. Require Export List. Require Export Arith Lia.Section bad_proof_example_for_Induction1. Theorem le_plus_minus' : forall n m:nat, m <= n -> n = m+(n-m). Proof. intros n m H; induction n. - rewrite <- le_n_O_eq with (1 := H); simpl; trivial. - Abort.End bad_proof_example_for_Induction1. Theorem lazy_example : forall n:nat, (S n) + 0 = S n. 
: Prop := forall t0 t1 t2 : btree, inb (node t1 t2) t -> inb t0 t1 -> inb t0 t2 -> False. Theorem distinct_leaves_leaf : forall a : A, distinct_leaves (leaf a). Proof using. intros a; red in |- *. intros a0 t1 t2 H; inversion H. Qed. Hint Resolve distinct_leaves_leaf : core. Theorem distinct_leaves_l : forall t1 t2 : btree, distinct_leaves (node t1 t2) -> distinct_leaves t1. Proof using. intros t1 t2 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem distinct_leaves_r : forall t1 t2 : btree, distinct_leaves (node t1 t2) -> distinct_leaves t2. Proof using. intros t1 t2 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem all_leaves_unique : forall t, ulist (all_leaves t) -> distinct_leaves t. Proof using. intros t; elim t; simpl in |- *; auto. intros b H b0 H0 H1; red in |- *. intros t0 t1 t2 H2; inversion H2. intros H4 H7; case (inb_ex t0); intros a HH. apply ulist_app_inv with (a := a) (1 := H1); auto; apply all_leaves_in; apply inb_trans with (1 := HH); auto. apply H; auto; try apply ulist_app_inv_l with (1 := H1). apply H0; auto; try apply ulist_app_inv_r with (1 := H1). Qed. Theorem all_leaves_ulist : forall t, distinct_leaves t -> ulist (all_leaves t). Proof using. intros t; elim t; simpl in |- *; auto. intros b H b0 H0 H1; apply ulist_app; auto. apply H; apply distinct_leaves_l with (1 := H1). apply H0; apply distinct_leaves_r with (1 := H1). intros a H2 H3; case (H1 (leaf a) b b0); auto. apply all_leaves_inb with (1 := H2). apply all_leaves_inb with (1 := H3). Qed. Definition distinct_leaves_dec : forall a, {distinct_leaves a} + {~ distinct_leaves a}. intros a; case (ulist_dec A eqA_dec (all_leaves a)); intros H. left; apply all_leaves_unique; auto. right; Contradict H; apply all_leaves_ulist; auto. Defined. Fixpoint compute_code (a : btree) : list (A * list bool) := match a with | leaf b => (b, nil) :: nil | node l1 l2 => map (fun v : A * list bool => match v with | (a1, b1) => (a1, false :: b1) end) (compute_code l1) ++ map (fun v : A * list bool => match v with | (a1, b1) => (a1, true :: b1) end) (compute_code l2) end. Theorem length_compute_lt_O : forall t, 0 < length (compute_code t). 
Wrap WrapC CompileEqualities SimpleSeq]. Definition dinvar := Al bs, Al a : A, PRE[V] array8 bs (V "buf") * [| length bs = wordToNat (V "len") |] * [| inputOk V (exps cond) |] * table sch tptr * mallocHeap 0 * invPre a V POST[R] array8 bs (V "buf") * invPost a V R. Notation svars := (rw :: data :: nil). Definition noOverlapExp (e : exp) := match e with | Const _ => True | Input pos len => pos <> rw /\ pos <> data /\ len <> rw /\ len <> data /\ pos <> "res" /\ len <> "res" end. Definition noOverlapExps := List.Forall noOverlapExp. Notation DeleteVcs := (fun im ns res => (~In "rp" ns) :: incl svars ns :: (rw <> "rp")%type :: (data <> "rp")%type :: incl baseVars ns :: In "res" ns :: (rw <> data)%type :: (forall a V V', (forall x, x <> rw -> x <> data -> x <> "ibuf" -> x <> "ilen" -> x <> "tmp" -> x <> "ipos" -> x <> "overflowed" -> x <> "matched" -> x <> "res" -> sel V x = sel V' x) -> invPre a V ===> invPre a V') :: (forall a V V' R, (forall x, x <> rw -> x <> data -> x <> "ibuf" -> x <> "ilen" -> x <> "tmp" -> x <> "ipos" -> x <> "overflowed" -> x <> "matched" -> x <> "res" -> sel V x = sel V' x) -> invPost a V R = invPost a V' R) :: "array8"!"equal" ~~ im ~~> ArrayOps.equalS :: "numops"!"div4" ~~ im ~~> div4S :: "malloc"!"free" ~~ im ~~> freeS :: "buffers"!"bfree" ~~ im ~~> bfreeS :: (res >= 10)%nat :: wfEqualities ns sch cond :: ("matched" <> rw)%type :: ("matched" <> data)%type :: (data <> "ibuf")%type :: (data <> "overflowed")%type :: (data <> "ipos")%type :: (data <> "ilen")%type :: (data <> "tmp")%type :: (data <> "len")%type :: (data <> "buf")%type :: (data <> "res")%type :: In data ns :: (rw <> "rp")%type :: (rw <> "ibuf")%type :: (rw <> "ipos")%type :: (rw <> "ilen")%type :: (rw <> "tmp")%type :: (rw <> "len")%type :: (rw <> "buf")%type :: (rw <> "overflowed")%type :: (rw <> "res")%type :: goodSize (length sch) :: goodSize (2 + length sch + length sch) :: noOverlapExps (exps cond) :: nil). Hint Immediate incl_refl. Theorem Forall_impl3 : forall A (P Q R S : A -> Prop) ls, List.Forall P ls -> List.Forall Q ls -> List.Forall R ls -> (forall x : A, P x -> Q x -> R x -> S x) -> List.Forall S ls. 
-> x = y); trivial with sets. destruct 1 as [x C]; exists x. cut (exists y : _, ~ (f x = f y -> x = y)). 2: apply not_all_ex_not with (P := fun y:U => f x = f y -> x = y); trivial with sets. destruct 1 as [y D]; exists y. apply imply_to_and; trivial with sets. Qed. Lemma cardinal_Im_intro : forall (A:Ensemble U) (f:U -> V) (n:nat), cardinal _ A n -> exists p : nat, cardinal _ (Im A f) p. Proof. intros. apply finite_cardinal; apply finite_image. apply cardinal_finite with n; trivial with sets. Qed. Lemma In_Image_elim : forall (A:Ensemble U) (f:U -> V), injective f -> forall x:U, In _ (Im A f) (f x) -> In _ A x. Proof. intros. elim Im_inv with A f (f x); trivial with sets. intros z C; elim C; intros InAz E. elim (H z x E); trivial with sets. Qed. Lemma injective_preserves_cardinal : forall (A:Ensemble U) (f:U -> V) (n:nat), injective f -> cardinal _ A n -> forall n':nat, cardinal _ (Im A f) n' -> n' = n. Proof. induction 2 as [| A n H'0 H'1 x H'2]; auto with sets. rewrite (image_empty f). intros n' CE. apply cardinal_unicity with V (Empty_set V); auto with sets. intro n'. rewrite (Im_add A x f). intro H'3. elim cardinal_Im_intro with A f n; trivial with sets. intros i CI. lapply (H'1 i); trivial with sets. cut (~ In _ (Im A f) (f x)). intros H0 H1. apply cardinal_unicity with V (Add _ (Im A f) (f x)); trivial with sets. apply card_add; auto with sets. rewrite <- H1; trivial with sets. red; intro; apply H'2. apply In_Image_elim with f; trivial with sets. Qed. Lemma cardinal_decreases : forall (A:Ensemble U) (f:U -> V) (n:nat), cardinal U A n -> forall n':nat, cardinal V (Im A f) n' -> n' <= n. Proof. induction 1 as [| A n H'0 H'1 x H'2]; auto with sets. rewrite (image_empty f); intros. cut (n' = 0). intro E; rewrite E; trivial with sets. apply cardinal_unicity with V (Empty_set V); auto with sets. intro n'. rewrite (Im_add A x f). elim cardinal_Im_intro with A f n; trivial with sets. intros p C H'3. apply le_trans with (S p). apply card_Add_gen with V (Im A f) (f x); trivial with sets. apply le_n_S; auto with sets. Qed. Theorem Pigeonhole : forall (A:Ensemble U) (f:U -> V) (n:nat), cardinal U A n -> forall n':nat, cardinal V (Im A f) n' -> n' < n -> ~ injective f. 
Require Import List. From Huffman Require Import Permutation. From Huffman Require Import Ordered. From Huffman Require Import sTactic. Section ISortExample. Variable A : Type. Variable order : A -> A -> Prop. Variable order_fun : A -> A -> bool. Hypothesis order_fun_true : forall a b : A, order_fun a b = true -> order a b. Hypothesis order_fun_false : forall a b : A, order_fun a b = false -> order b a. Fixpoint insert (a : A) (l : list A) {struct l} : list A := match l with | nil => a :: nil | b :: l1 => match order_fun a b with | true => a :: l | false => b :: insert a l1 end end. Theorem insert_ordered : forall l : list A, ordered order l -> forall a : A, ordered order (insert a l). Proof using order_fun_false order_fun_true. intros l H'; elim H'; clear H' l; auto. simpl in |- *; auto. intros a b; simpl in |- *. generalize (refl_equal (order_fun b a)); pattern (order_fun b a) at -1 in |- *; case (order_fun b a); intros Eq0; auto. intros a b l H'0 H'1 H'2 a0. simpl in |- *. generalize (refl_equal (order_fun a0 a)); pattern (order_fun a0 a) at -1 in |- *; case (order_fun a0 a); intros Eq0; auto. generalize (H'2 a0); simpl in |- *. generalize (refl_equal (order_fun a0 b)); pattern (order_fun a0 b) at -1 in |- *; case (order_fun a0 b); intros Eq1; auto. Qed. Theorem insert_permutation : forall (L : list A) (a : A), permutation (a :: L) (insert a L). 
yx : _, (f (g yx)) = yx). intro. induction yx. apply idpath. split with f. apply (isweq_iso _ _ egf efg). Defined.Definition weqtotal2dirprodcomm {X Y : UU} (P : X × Y -> UU) : (∑ xy : X × Y, P xy) ≃ (∑ xy : Y × X, P (weqdirprodcomm _ _ xy)). Proof. intros. use weq_iso. - intros xyp. exact ((pr2 (pr1 xyp),, pr1 (pr1 xyp)),,pr2 xyp). - intros yxp. exact (((pr2 (pr1 yxp)),, (pr1 (pr1 yxp))),, pr2 yxp). - intros xyp. apply idpath. - intros yxp. apply idpath. Defined.Definition weqtotal2dirprodassoc {X Y : UU} (P : X × Y -> UU) : (∑ xy : X × Y, P xy) ≃ (∑ (x : X) (y : Y), P (x,,y)). intros. use weq_iso. - intros xyp. exact (pr1 (pr1 xyp),,pr2 (pr1 xyp),, pr2 xyp). - intros xyp. exact (((pr1 xyp),, pr1 (pr2 xyp)),, pr2 (pr2 xyp)). - intros xyp. apply idpath. - intros xyp. apply idpath. Defined.Definition weqtotal2dirprodassoc' {X Y : UU} (P : X × Y -> UU) : (∑ xy : X × Y, P xy) ≃ (∑ (y : Y) (x : X), P (x,,y)). Proof. intros. use weq_iso. - intros xyp. exact (pr2 (pr1 xyp),,pr1 (pr1 xyp),,pr2 xyp). - intros yxp. exact ((pr1 (pr2 yxp),,pr1 yxp),,pr2 (pr2 yxp)). - intros xyp. apply idpath. - intros yxp. apply idpath. Defined.Definition weqtotal2comm12 {X} (P Q : X -> UU) : (∑ (w : ∑ x, P x), Q (pr1 w)) ≃ (∑ (w : ∑ x, Q x), P (pr1 w)). Proof. intros. use weq_iso. - intro xpq. exact ((pr1 (pr1 xpq),,pr2 xpq),, pr2 (pr1 xpq)). - intro xqp. exact ((pr1 (pr1 xqp),, pr2 xqp),, pr2 (pr1 xqp)). - intro. apply idpath. - intro. apply idpath. Defined.Definition rdistrtocoprod (X Y Z : UU) : X × (Y ⨿ Z) -> (X × Y) ⨿ (X × Z). Proof. intros X0. induction X0 as [ t x ]. induction x as [ y | z ]. apply (ii1 (make_dirprod t y)). apply (ii2 (make_dirprod t z)). Defined. Definition rdistrtoprod (X Y Z : UU) : (X × Y) ⨿ (X × Z) -> X × (Y ⨿ Z). Proof. intros X0. induction X0 as [ d | d ]. induction d as [ t x ]. apply (make_dirprod t (ii1 x)). induction d as [ t x ]. apply (make_dirprod t (ii2 x)). Defined. Theorem isweqrdistrtoprod (X Y Z : UU) : isweq (rdistrtoprod X Y Z). 
x y : Term A n, eqT x y -> ~ ltT x y. unfold eqT, ltT in |- *; simpl in |- *; intros x y H; rewrite H; auto. apply ltM_nonrefl with (1 := os). Qed. Lemma eqT_not_ltT : forall x y : Term A n, ltT x y -> ~ eqT x y. unfold eqT, ltT, not in |- *; simpl in |- *; intros x y H Q; absurd (ltM (T2M x) (T2M y)); auto; rewrite Q; auto. apply ltM_nonrefl with (1 := os). Qed. Theorem ltT_not_refl : forall x : Term A n, ~ ltT x x. intros x; unfold ltT in |- *; apply ltM_nonrefl with (1 := os). Qed. Hint Resolve ltT_not_eqT eqT_not_ltT ltT_not_refl. Lemma ltT_not_ltT : forall x y : Term A n, ltT x y -> ~ ltT y x. intros x y H'; red in |- *; intros H'0; absurd (ltT x x); auto. apply ltT_trans with (y := y); auto. Qed. Hint Resolve ltT_not_ltT. Lemma ltT_eqT : forall a b c d : Term A n, eqT a b -> eqT c d -> ltT a c -> ltT b d. unfold eqT, ltT in |- *; intros a b c d R1 R2; rewrite R1; rewrite R2; auto. Qed. Let eqT_refl := eqT_refl A n. Lemma ltT_eqTr : forall a b c : Term A n, eqT a b -> ltT a c -> ltT b c. intros a b c H' H'0; apply ltT_eqT with (a := a) (c := c); auto. Qed. Lemma ltT_eqTl : forall a b c : Term A n, eqT a b -> ltT c a -> ltT c b. intros a b c H' H'0; apply ltT_eqT with (a := c) (c := a); auto. Qed. Theorem multTerm_ltT_l : forall m1 m2 m3, ltT m1 m2 -> ltT (multTerm multA m3 m1) (multTerm multA m3 m2). intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto. intros a0 m a1 m0 a2 m1 H. apply ltM_plusl with (1 := os); auto. Qed. Theorem multTerm_ltT_r : forall m1 m2 m3, ltT m1 m2 -> ltT (multTerm multA m1 m3) (multTerm multA m2 m3). intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto. intros; apply ltM_plusr with (1 := os); auto. Qed. Theorem T1_is_min_ltT : forall a, ~ ltT a (T1 A1 n). 
m)%R with (-(-p * m))%R; auto with real; try ring. Qed. Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R. intros n m p H H1; case (Rle_or_lt n m); auto; intros H2. absurd (p * n <= p * m)%R; auto with real. apply Rlt_not_le; apply Rmult_lt_compat_l; auto. Qed.Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R. intros n m p H H1; case (Rle_or_lt m n); auto; intros H2. absurd (p * n <= p * m)%R; auto with real. apply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto. Qed.Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R. intros n m p H H1; case (Rle_or_lt m n); auto; intros H2. absurd (p * n < p * m)%R; auto with real. apply Rle_not_lt; apply Rmult_le_compat_l; auto with real. Qed.Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R. intros n m p H H1; case (Rle_or_lt n m); auto; intros H2. absurd (p * n < p * m)%R; auto with real. apply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real. Qed.Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real. Qed.Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R. intros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R. intros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real. Qed.Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). 
Theorem FoddFop : forall p : float, Fodd p -> Fodd (Fopp p). intros p; unfold Fodd, Fopp in |- *; simpl in |- *; auto with zarith. Qed. Theorem FevenPred : forall p : float, Fodd p -> Feven (FPred b radix precision p). intros p H'; rewrite FPredFopFSucc; auto with arith. apply FevenFop; auto. apply FoddSuc; auto. apply FoddFop; auto with arith. Qed. Theorem FoddPred : forall p : float, Feven p -> Fodd (FPred b radix precision p). intros p H'; rewrite FPredFopFSucc; auto with arith. apply FoddFop; auto. apply FevenSuc; auto. apply FevenFop; auto. Qed. Definition FNodd (p : float) := Fodd (Fnormalize radix b precision p). Definition FNeven (p : float) := Feven (Fnormalize radix b precision p). Theorem FNoddEq : forall f1 f2 : float, Fbounded b f1 -> Fbounded b f2 -> f1 = f2 :>R -> FNodd f1 -> FNodd f2. intros f1 f2 H' H'0 H'1 H'2; red in |- *. rewrite FcanonicUnique with (3 := pGivesBound) (p := Fnormalize radix b precision f2) (q := Fnormalize radix b precision f1); auto with float arith. repeat rewrite FnormalizeCorrect; auto. Qed. Theorem FNevenEq : forall f1 f2 : float, Fbounded b f1 -> Fbounded b f2 -> f1 = f2 :>R -> FNeven f1 -> FNeven f2. intros f1 f2 H' H'0 H'1 H'2; red in |- *. rewrite FcanonicUnique with (3 := pGivesBound) (p := Fnormalize radix b precision f2) (q := Fnormalize radix b precision f1); auto with float arith. repeat rewrite FnormalizeCorrect; auto. Qed. Theorem FNevenFop : forall p : float, FNeven p -> FNeven (Fopp p). intros p; unfold FNeven in |- *. rewrite Fnormalize_Fopp; auto with arith. intros; apply FevenFop; auto. Qed. Theorem FNoddFop : forall p : float, FNodd p -> FNodd (Fopp p). intros p; unfold FNodd in |- *. rewrite Fnormalize_Fopp; auto with arith. intros; apply FoddFop; auto. Qed. Theorem FNoddSuc : forall p : float, Fbounded b p -> FNodd p -> FNeven (FNSucc b radix precision p). unfold FNodd, FNeven, FNSucc in |- *. intros p H' H'0. rewrite FcanonicFnormalizeEq; auto with float arith. apply FoddSuc; auto with float arith. Qed. Theorem FNevenSuc : forall p : float, Fbounded b p -> FNeven p -> FNodd (FNSucc b radix precision p). unfold FNodd, FNeven, FNSucc in |- *. intros p H' H'0. rewrite FcanonicFnormalizeEq; auto with float arith. apply FevenSuc; auto. Qed. Theorem FNevenPred : forall p : float, Fbounded b p -> FNodd p -> FNeven (FNPred b radix precision p). 
|}.Next Obligation. intros; cbn; repeat rewrite F_id; trivial. Qed.Next Obligation. intros; cbn; repeat rewrite F_compose; trivial. Qed.Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1) (F' : (C1 × C1') –≻ Cy) : (Cx × C1') –≻ Cy := F' ∘ (Prod_Functor F (@Functor_id C1')).Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx –≻ C1') (F' : (C1 × C1') –≻ Cy) : (C1 × Cx) –≻ Cy := Functor_compose (Prod_Functor (@Functor_id C1) F) F'.Local Hint Extern 2 => cbn.Local Obligation Tactic := basic_simpl; do 2 auto.Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1) (F : (C1 × C1') –≻ Cy) : C1' –≻ Cy := {| FO := fun a => (F _o (x, a))%object; FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism |}.Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1') (F : (C1 × C1') –≻ Cy) : C1 –≻ Cy := {| FO := fun a => (F _o (a, x))%object; FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism |}.Program Definition Diag_Func (C : Category) : C –≻ (C × C) := {| FO := fun a => (a, a); FA := fun _ _ f => (f, f); F_id := fun _ => eq_refl; F_compose := fun _ _ _ _ _ => eq_refl |}.Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C –≻ (D × D')) : ((Prod_Functor ((Cat_Proj1 _ _) ∘ F) ((Cat_Proj2 _ _) ∘ F)) ∘ (Diag_Func C))%functor = F. Proof. Func_eq_simpl; trivial. Qed. Program Definition Twist_Func (C C' : Category) : (C × C') –≻ (C' × C) := {| FO := fun a => (snd a, fst a); FA := fun _ _ f => (snd f, fst f); F_id := fun _ => eq_refl; F_compose := fun _ _ _ _ _ => eq_refl |}.Section Twist_Prod_Func_Twist. Context {C C' : Category} (F : C –≻ C') {D D' : Category} (G : D –≻ D'). Theorem Twist_Prod_Func_Twist : (((Twist_Func _ _) ∘ (Prod_Functor F G)) ∘ (Twist_Func _ _))%functor = Prod_Functor G F. Proof. Func_eq_simpl; trivial. Qed.End Twist_Prod_Func_Twist.Section Prod_Functor_compose. Context {C D E: Category} (F : C –≻ D) (G : D –≻ E) {C' D' E': Category} (F' : C' –≻ D') (G' : D' –≻ E'). Theorem Prod_Functor_compose : ((Prod_Functor G G') ∘ (Prod_Functor F F') = Prod_Functor (G ∘ F) (G' ∘ F'))%functor. 
From Huffman Require Export Aux. From Huffman Require Export Code. From Huffman Require Export Build. From Huffman Require Export ISort. Require Export Compare_dec. From Huffman Require Export Permutation. From Huffman Require Export UniqueKey. From Huffman Require Export PBTree. From Huffman Require Export BTree. Section PBTREE2BTREE. Variable A : Type. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Variable empty : A. Fixpoint to_btree (a : pbtree A) : btree A := match a with | pbleaf b => leaf b | pbleft l1 => to_btree l1 | pbright l1 => to_btree l1 | pbnode l1 l2 => node (to_btree l1) (to_btree l2) end. Theorem to_btree_inb : forall a b, inpb (pbleaf a) b -> inb (leaf a) (to_btree b). Proof using. intros a b; generalize a; elim b; clear a b; simpl in |- *; auto. intros a a0 H; inversion H; auto. intros p H a H0; apply H; auto; inversion H0; auto. intros p H a H0; apply H; auto; inversion H0; auto. intros p H p0 H0 a H1; inversion H1; auto. Qed. Theorem to_btree_inpb : forall a b, inb (leaf a) (to_btree b) -> inpb (pbleaf a) b. Proof using. intros a b; generalize a; elim b; clear a b; simpl in |- *; auto. intros a a0 H; inversion H; auto. intros p H p0 H0 a H1. inversion H1; auto. Qed. Theorem to_btree_all_leaves : forall t, all_leaves (to_btree t) = all_pbleaves t. 
destruct n; auto. Qed.Lemma mod2_S_not : forall n, mod2 (S n) = if (mod2 n) then false else true. Proof. intros. induction n; auto. rewrite mod2_S_S. destruct (mod2 n); replace (mod2 (S n)); auto. Qed.Lemma mod2_S_eq : forall n k, mod2 n = mod2 k -> mod2 (S n) = mod2 (S k). Proof. intros. do 2 rewrite mod2_S_not. rewrite H. auto. Qed.Theorem drop_mod2_add : forall n k, mod2 (n + 2 * k) = mod2 n. Proof. intros. induction n. simpl. rewrite Nat.add_0_r. replace (k + k) with (2 * k) by omega. apply mod2_double. replace (S n + 2 * k) with (S (n + 2 * k)) by omega. apply mod2_S_eq; auto. Qed.Lemma mod2sub: forall a b, b <= a -> mod2 (a - b) = xorb (mod2 a) (mod2 b). Proof. intros. remember (a - b) as c. revert dependent b. revert a. revert c. change (forall c, (fun c => forall a b, b <= a -> c = a - b -> mod2 c = xorb (mod2 a) (mod2 b)) c). apply strong. intros c IH a b AB N. destruct c. - assert (a=b) by omega. subst. rewrite Bool.xorb_nilpotent. reflexivity. - destruct c. + assert (a = S b) by omega. subst a. simpl (mod2 1). rewrite mod2_S_not. destruct (mod2 b); reflexivity. + destruct a; [omega|]. destruct a; [omega|]. simpl. apply IH; omega. Qed.Theorem mod2_pow2_twice: forall n, mod2 (Nat.pow 2 n + (Nat.pow 2 n + 0)) = false. Proof. intros. replace (Nat.pow 2 n + (Nat.pow 2 n + 0)) with (2 * Nat.pow 2 n) by omega. apply mod2_double. Qed.Theorem div2_plus_2 : forall n k, Nat.div2 (n + 2 * k) = Nat.div2 n + k. Proof. induction n; intros. simpl. rewrite Nat.add_0_r. replace (k + k) with (2 * k) by omega. apply div2_double. replace (S n + 2 * k) with (S (n + 2 * k)) by omega. destruct (Even.even_or_odd n). - rewrite <- even_div2. rewrite <- even_div2 by auto. apply IHn. apply Even.even_even_plus; auto. apply Even.even_mult_l; repeat constructor. - rewrite <- odd_div2. rewrite <- odd_div2 by auto. rewrite IHn. omega. apply Even.odd_plus_l; auto. apply Even.even_mult_l; repeat constructor. Qed.Lemma pred_add: forall n, n <> 0 -> pred n + 1 = n. Proof. intros; rewrite pred_of_minus; omega. Qed.Lemma pow2_zero: forall sz, (Nat.pow 2 sz > 0)%nat. Proof. induction sz; simpl; auto; omega. Qed.Section omega_compat. Ltac omega ::= lia. Theorem Npow2_nat : forall n, nat_of_N (Npow2 n) = Nat.pow 2 n. 
lia. Qed. Theorem constr_sub_size: forall e v t lv sub im, (term_sub_inl_size (e, M.set v (SVconstr t lv) sub, im) < term_sub_inl_size (Econstr v t lv e, sub, im))%nat. Proof. intros. unfold term_sub_inl_size. simpl. assert ((sub_inl_size (M.set v (SVconstr t lv) sub) im <= svalue_size (SVconstr t lv) + sub_inl_size sub im))%nat. apply sub_set_size. simpl in H. lia. Defined. Theorem subfds_fds_size: forall fds' fds, subfds_fds fds fds' -> (funs_size fds < funs_size fds')%nat. Proof. induction fds'; intros. - inversion H; subst. apply IHfds' in H2. simpl. lia. simpl. lia. - inversion H. Defined. Theorem case_size: forall g v k cl, List.In (g, k) cl -> (term_size k < term_size (Ecase v cl))%nat. Proof. induction cl; intro; simpl in H. - inversion H. - destruct a. inv H. + inv H0. simpl. lia. + apply IHcl in H0. simpl. simpl in H0. lia. Defined. Theorem dsubterm_fds_size: forall e fds, dsubterm_fds_e e fds -> (term_size e < funs_size fds)%nat. Proof. induction fds; intros. inv H. simpl. lia. apply IHfds in H2. simpl; lia. inv H. Defined. Theorem dsubterm_size: forall e e', dsubterm_e e' e -> term_size e' < term_size e. Proof. intros. inv H; auto. - eapply case_size; eauto. - apply dsubterm_fds_size in H0. simpl. lia. - simpl. lia. Defined. Theorem subterm_size : forall e e', subterm_e e' e -> (term_size e' < term_size e)%nat. Proof. intros. induction H. - apply dsubterm_size; auto. - eapply transitivity; eauto. Defined. Theorem subterm_fds_size: forall e fds, subterm_fds_e e fds -> (term_size e < funs_size fds)%nat. Proof. intros. induction H. - apply subterm_size in H. simpl. lia. - simpl. lia. Defined. Theorem subterm_or_eq_size: forall e e', subterm_or_eq e e' -> (term_size e <= term_size e')%nat. Proof. intros. induction H. apply dsubterm_size in H; lia. reflexivity. etransitivity; eauto. Defined. Theorem subfds_or_eq_size: forall fds fds', subfds_or_eq fds fds' -> (funs_size fds <= funs_size fds')%nat. Proof. destruct fds; intros; inversion H; try (subst; reflexivity). - apply subfds_fds_size in H0. lia. - inversion H0; subst. simpl; lia. simpl; lia. Defined. Corollary subfds_e_size: forall fds e, subfds_e fds e -> (funs_size fds < term_size e)%nat. Proof. intros. inversion H. destructAll. apply subfds_or_eq_size in H1. apply subterm_or_eq_size in H0. simpl in H0. lia. Defined. Definition b_map_le: b_map -> b_map -> Prop := fun inl inl_r => forall v, get_b v inl = true -> get_b v inl_r = true. Theorem b_map_le_refl: forall i, b_map_le i i. Proof. intros; intro; intros. assumption. Defined. Theorem b_map_le_trans: forall i i' i'', b_map_le i i' -> b_map_le i' i'' -> b_map_le i i''. 
bind_id' {T} (r: t T) : bind r (fun x => ret x) ≡ r. Proof. intros s1 s2 v. split; intros. - inv H. inv H1. auto. - econstructor; eauto. econstructor; eauto. Qed. Theorem bind_bind {T1 T2 T3} (r1: t T1) (r2: T1 -> t T2) (r3: T2 -> t T3) : forall s1 s2 v, bind (bind r1 r2) r3 s1 s2 v -> bind r1 (fun x => bind (r2 x) r3) s1 s2 v. Proof. intros s1 s2 v H. inv H. inv H0. eauto using bind_runs. Qed. Theorem bind_assoc {T1 T2 T3} (r1: t T1) (r2: T1 -> t T2) (r3: T2 -> t T3) : bind (bind r1 r2) r3 ≡ bind r1 (fun x => bind (r2 x) r3). Proof. intros s1 s2 v. split; intros. - eauto using bind_bind. - inv H. inv H1. eauto using bind_runs. Qed. Theorem fmap_ret T1 T2 (f: T1 -> T2) x : fmap f (ret x) ≡ ret (f x). Proof. intros s1 s2 v. split; intros. - inv H. inv H0. inv H1. econstructor; eauto. - inv H. econstructor; eauto. { econstructor; eauto. } { econstructor; eauto. } Qed. Global Instance bind_respects_equiv {T1 T2} : Proper (requiv ==> pointwise_relation _ requiv ==> requiv) (@bind T1 T2). Proof. unfold Proper, respectful, pointwise_relation. intros r1 r1' Heq1 r2 r2' Heq2. intros s1 s2 v. split; intros. - inv H. econstructor; eauto. { eapply Heq1; eauto. } { eapply Heq2; eauto. } - inv H. econstructor; eauto. { eapply Heq1; eauto. } { eapply Heq2; eauto. } Qed. Theorem bind_runF T1 T2 (f: Σ -> Σ * T1) (r: T1 -> t T2) : forall s1 s2 v, r (f s1).2 (f s1).1 s2 v -> bind (runF f) r s1 s2 v. Proof. intros. destruct_with_eqn (f s1); simpl in H. eapply bind_runs; eauto. econstructor; eauto. Qed. Theorem inv_bind_runF T1 T2 (f: Σ -> Σ * T1) (r: T1 -> t T2) : forall s1 s2 v, bind (runF f) r s1 s2 v -> r (f s1).2 (f s1).1 s2 v. Proof. intros. inv H. inv H0. replace (f s1); auto. Qed. Theorem bind_suchThat T1 T2 (pred: Σ -> T1 -> Prop) (r: T1 -> t T2) : forall s1 s2 v x, pred s1 x -> r x s1 s2 v -> bind (suchThat pred) r s1 s2 v. Proof. intros. econstructor; eauto using suchThat_runs. Qed. Theorem inv_bind_suchThat T1 T2 (pred: Σ -> T1 -> Prop) (r: T1 -> t T2) : forall s1 s2 v, bind (suchThat pred) r s1 s2 v -> exists x, pred s1 x /\ r x s1 s2 v. 
rewrite Hd. replace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra]. unfold Rdiv; rewrite Rabs_mult, Rabs_Ropp. rewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra]. apply (Rmult_le_reg_r (1 + d)); [lra|]. rewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra]. apply (Rle_trans _ _ _ Bd). unfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|]. apply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra. } now exists d'; split; [|unfold d'; field]. Qed.Theorem relative_error_N_FLX_round_ex : forall x, exists eps, (Rabs eps <= u_ro)%R /\ x = (round beta (FLX_exp prec) (Znearest choice) x * (1 + eps))%R. Proof. intro x; apply relative_error_N_round_ex_derive, relative_error_N_FLX'_ex. Qed.Theorem relative_error_N_FLX_round : forall x, (Rabs (round beta (FLX_exp prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs(round beta (FLX_exp prec) (Znearest choice) x))%R. Proof. intro x. apply relative_error_le_conversion_round_inv, relative_error_N_FLX_round_ex. Qed.End Fprop_relative_FLX.Section Fprop_relative_FLT.Variable emin prec : Z. Variable Hp : Z.lt 0 prec.Lemma relative_error_FLT_aux : forall k, (emin + prec - 1 < k)%Z -> (prec <= k - FLT_exp emin prec k)%Z. Proof. intros k Hk. unfold FLT_exp. generalize (Zmax_spec (k - prec) emin). lia. Qed.Variable rnd : R -> Z. Context { valid_rnd : Valid_rnd rnd }.Theorem relative_error_FLT : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> (Rabs (round beta (FLT_exp emin prec) rnd x - x) < bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error with (emin + prec - 1)%Z... apply relative_error_FLT_aux. Qed.Theorem relative_error_FLT_F2R_emin : forall m, let x := F2R (Float beta m emin) in (x <> 0)%R -> (Rabs (round beta (FLT_exp emin prec) rnd x - x) < bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros m x Zx. destruct (Rlt_or_le (Rabs x) (bpow (emin + prec - 1))) as [Hx|Hx]. rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. apply Rmult_lt_0_compat. apply bpow_gt_0. now apply Rabs_pos_lt. apply generic_format_FLT_FIX... apply Rlt_le. apply Rlt_le_trans with (1 := Hx). apply bpow_le. apply Zle_pred. apply generic_format_FIX. now exists (Float beta m emin). now apply relative_error_FLT. Qed.Theorem relative_error_FLT_F2R_emin_ex : forall m, let x := F2R (Float beta m emin) in exists eps, (Rabs eps < bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) rnd x = (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros m x. apply relative_error_lt_conversion... apply bpow_gt_0. now apply relative_error_FLT_F2R_emin. Qed. Theorem relative_error_FLT_ex : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> exists eps, (Rabs eps < bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) rnd x = (x * (1 + eps))%R. 
l2} + {~ permutation l1 l2}. intros H l1 l2. case (In_dec (list_eq_dec H) l1 (all_permutations l2)). intros i; left; apply all_permutations_permutation; auto. intros i; right; Contradict i; apply permutation_all_permutations; auto. Defined. End permutation. Hint Constructors permutation : core. Hint Resolve permutation_refl : core. Hint Resolve permutation_app_comp : core. Hint Resolve permutation_app_swap : core. Arguments permutation [A]. Arguments split_one [A]. Arguments all_permutations [A]. Arguments permutation_dec [A]. Theorem permutation_map : forall (A B : Type) (f : A -> B) l1 l2, permutation l1 l2 -> permutation (map f l1) (map f l2). Proof using. intros A B f l1 l2 H; elim H; simpl in |- *; auto. intros l0 l3 l4 H0 H1 H2 H3; apply permutation_trans with (2 := H3); auto. Qed. Hint Resolve permutation_map : core. Lemma permutation_map_ex_aux : forall (A B : Type) (f : A -> B) l1 l2 l3, permutation l1 l2 -> l1 = map f l3 -> exists l4 : _, permutation l4 l3 /\ l2 = map f l4. Proof using. intros A1 B1 f l1 l2 l3 H; generalize l3; elim H; clear H l1 l2 l3. intros l3; case l3; simpl in |- *; auto. intros H; exists (nil (A:=A1)); auto. intros; discriminate. intros a0 l1 l2 H H0 l3; case l3; simpl in |- *; auto. intros; discriminate. intros a1 l H1; case (H0 l); auto. injection H1; auto. intros l5 (H2, H3); exists (a1 :: l5); split; simpl in |- *; auto. apply f_equal2 with (f := cons (A:=B1)); auto; injection H1; auto. intros a0 b l l3; case l3. intros; discriminate. intros a1 l0; case l0; simpl in |- *. intros; discriminate. intros a2 l1 H; exists (a2 :: a1 :: l1); split; simpl in |- *; auto. repeat apply f_equal2 with (f := cons (A:=B1)); injection H; auto. intros l1 l2 l3 H H0 H1 H2 l0 H3. case H0 with (1 := H3); auto. intros l4 (HH1, HH2). case H2 with (1 := HH2); auto. intros l5 (HH3, HH4); exists l5; split; auto. apply permutation_trans with (1 := HH3); auto. Qed. Theorem permutation_map_ex : forall (A B : Type) (f : A -> B) l1 l2, permutation (map f l1) l2 -> exists l3 : _, permutation l3 l1 /\ l2 = map f l3. Proof using. intros A0 B f l1 l2 H; apply permutation_map_ex_aux with (l1 := map f l1); auto. Qed. Theorem permutation_flat_map : forall (A B : Type) (f : A -> list B) l1 l2, permutation l1 l2 -> permutation (flat_map f l1) (flat_map f l2). 
: Type@{max(i,j)} := | Acc_intro : (forall y, R y x -> Acc y) -> Acc x. Definition Acc_inv {x} (H : Acc x) : forall y, R y x -> Acc y. Proof. intros y Hy. destruct H. exact (a _ Hy). Defined. Lemma Acc_prop i (x y : Acc i) : x = y. Proof. revert y. induction x as [y Accy IHy]. intros [Accy']. apply ap. apply funext. intros H. apply funext. intros H'. apply IHy. Qed. Definition well_founded := forall x, Acc x. Context (P : A -> Type). Context (step : forall x : A, (forall y : A, R y x -> P y) -> P x). Fixpoint Fix_F (x : A) (a : Acc x) : P x := step x (fun y r => Fix_F y (Acc_inv a y r)).End Acc.Section FixWf. Context {A R} (WF : @well_founded A R). Context (P : A -> Type). Context (step : forall x : A, (forall y : A, R y x -> P y) -> P x). Definition Fix (x : A) : P x := Fix_F R P step x (WF x). End FixWf.Lemma well_founded_irreflexive {A} {R : relation A} {wfR : well_founded R} : forall x y : A, R x y -> x = y -> Empty. Proof. intros x y Ryy. intros e. destruct e. red in wfR. induction (wfR x) as [y accy IHy]. apply (IHy _ Ryy Ryy). Qed.Lemma well_founded_antisym@{i j} {A : Type@{i}} {R : relation@{i j} A}{wfR : well_founded R} : forall x y : A, R x y -> R y x -> Empty. Proof. intros x y Rxy Ryx. red in wfR. induction (wfR y) as [y accy IHy] in x, Rxy, Ryx. specialize (IHy _ Rxy). apply (IHy _ Ryx Rxy). Qed.Section Wf_Transitive_Closure. Context {A : Type} (R : relation A). Notation trans_clos := (trans_clos R). Lemma incl_trans_clos : inclusion R trans_clos. red; auto with relations. Defined. Lemma Acc_trans_clos : forall x:A, Acc R x -> Acc trans_clos x. induction 1 as [x0 _ H1]. apply Acc_intro. intros y H2. induction H2; auto with relations. apply Acc_inv with y; auto with relations. Defined. Hint Resolve Acc_trans_clos : core. Lemma Acc_inv_trans : forall x y:A, trans_clos y x -> Acc R x -> Acc R y. Proof. induction 1 as [| x y]; auto with relations. intro; apply Acc_inv with y; assumption. Defined. Theorem wf_trans_clos : well_founded R -> well_founded trans_clos. 
a (pDst p0)))); auto. rewrite <- e. intuition. * intuition. * intuition. - unfold seq_num_input_handlers in *. simpl in *. do_in_app. intuition. + do_in_map. subst; simpl in *. repeat break_match; try find_inversion; simpl in *; intuition. eapply processPackets_correct; eauto. + simpl in *. repeat break_match; try find_inversion; simpl in *; find_apply_lem_hyp processPackets_num_monotonic; find_apply_hyp_hyp; try lia. - in_crush; eauto with *. Qed. Definition sequence_seen (net : seq_num_network) := forall h h' n, In n (assoc_default name_eq_dec (tdSeen (nwState net h')) h []) -> n < (tdNum (nwState net h)). Lemma reachable_seen : true_in_reachable step_dup step_async_init sequence_seen. Proof using. apply true_in_reachable_reqs; unfold sequence_seen; simpl in *; intuition. find_apply_lem_hyp reachable_sane. unfold sequence_sane in *. match goal with H : step_dup _ _ _ |- _ => invcs H end. - unfold seq_num_net_handlers in *. repeat (break_match; try find_inversion; simpl in *; eauto); match goal with | [ H : processPackets _ _ = _ |- _ ] => apply processPackets_num_monotonic in H end; try break_if; simpl in *; intuition; subst; eauto; repeat find_rewrite; (eapply lt_le_trans; [|eauto]; eauto). * case (name_eq_dec (pSrc p) (pDst p)); intro. + rewrite <- e in H2. rewrite get_set_same_default in H2. rewrite e in H2. case H2; intro. -- rewrite <- H. rewrite <- e. eapply H0. apply in_or_app. right; left. auto. -- eapply H1; eauto. + match goal with | [H: In _ (assoc_default _ (assoc_set _ _ _ _) _ _) |- _ ] => rewrite get_set_diff_default in H end; eauto. * case (name_eq_dec (pSrc p) h); intro. + rewrite <- e in H2. rewrite get_set_same_default in H2. rewrite e in H2. case H2; intro. -- rewrite <- H. rewrite <- e. eapply H0. apply in_or_app. right; left. auto. -- eapply H1; eauto. + match goal with | [H: In _ (assoc_default _ (assoc_set _ _ _ _) _ _) |- _ ] => rewrite get_set_diff_default in H end; eauto. - unfold seq_num_input_handlers in *. repeat (break_match; try find_inversion; simpl in *; eauto); match goal with | [ H : processPackets _ _ = _ |- _ ] => apply processPackets_num_monotonic in H end; try break_if; simpl in *; intuition; subst; eauto; repeat find_rewrite; (eapply lt_le_trans; [|eauto]; eauto). - eauto. Qed. Definition sequence_equality (net : seq_num_network) := forall p p', In p (nwPackets net) -> In p' (nwPackets net) -> (tmNum (pBody p)) = (tmNum (pBody p')) -> pSrc p = pSrc p' -> p = p'. Theorem reachable_equality : true_in_reachable step_dup step_async_init sequence_equality. 
?Z)%morphism = _] => transitivity (((F _a Y) ∘ (F _a X)) Z)%morphism; trivial end. auto. Qed.Next Obligation. Proof. symmetry; simpl. apply Y_right_to_left_NT_obligation_1. Qed. Program Definition Y_right_to_left (C : Category) : (Y_right C) –≻ (Y_left C) := {| Trans := fun c_F => fun h => Y_right_to_left_NT C (fst c_F) (snd c_F) h |}.Next Obligation. Proof. intros C [c f] [c' f'] [h N]. cbn in *. extensionality g; cbn. apply NatTrans_eq_simplify. extensionality d; extensionality g'; cbn. simpl_ids. match goal with [|- ?W = _] => match W with (?F _a ?X (?F _a ?Y ?Z))%morphism => change W with (((F _a X) ∘ (F _a Y)) Z)%morphism end end. rewrite <- F_compose; cbn. match goal with [|- ?W = _] => match W with ?X (?Y ?Z) => change W with ((X ∘ Y) Z)%morphism end end. rewrite <- Trans_com; cbn; trivial. Qed.Next Obligation. Proof. symmetry; simpl. apply Y_right_to_left_obligation_1. Qed. Program Definition Yoneda_Lemma (C : Category) : ((Y_left C) ≃ (Y_right C))%natiso := NatIso _ _ (Y_left_to_right C) (Y_right_to_left C) _ _.Next Obligation. Proof. intros C [c F]; FunExt; cbn in *. rewrite (F_id F). trivial. Qed.Next Obligation. simpl; intros C [c F]; FunExt. apply NatTrans_eq_simplify. FunExt. cbn in *. match goal with [|- ?W = _] => match W with ?X (?Y ?Z) => change W with ((X ∘ Y) Z)%morphism end end. rewrite <- Trans_com; cbn. auto. Qed. Lemma Yoneda_Faithful (C : Category) : Faithful_Func (Yoneda C). Proof. intros c c' f f' H. cbn in *. match type of H with ?X = ?Y => assert(H' : Trans X c id= Trans Y c id) end. + rewrite H; trivial. + cbn in H'. simpl_ids in H'. trivial. Qed. Lemma Yoneda_Full (C : Category) : Full_Func (Yoneda C). Proof. intros c c' N. exists (Trans (Y_left_to_right C) (c, (((Yoneda C) _o)%object c')) N). apply NatTrans_eq_simplify. extensionality x; extensionality h. transitivity ((((Yoneda C) _o c')%object _a h ∘ (Trans N c)) id)%morphism. + cbn; auto. + rewrite <- Trans_com. cbn; auto. Qed. Definition Yoneda_Emb (C : Category) : Embedding C (Func_Cat (C^op) Type_Cat) := {| Emb_Func := Yoneda C; Emb_Faithful := Yoneda_Faithful C; Emb_Full := Yoneda_Full C |}. Theorem Yoneda_Iso (C : Category) : forall (c c' : Obj), ((Yoneda C) _o c ≃ (Yoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism. Proof. intros. apply (Emb_Conservative _ _ (Yoneda_Emb C) _); trivial. Qed.Ltac Yoneda := apply Yoneda_Iso. Theorem CoYoneda_Iso (C : Category) : forall (c c' : Obj), ((CoYoneda C) _o c ≃ (CoYoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism. 
[[ Forall entry_valid new /\ sync_invariant F ]] POST:hm' RET: ^(cs, r) exists d', BUFCACHE.rep cs d' * ( [[ r = true /\ (F * rep xp (Synced ((padded_log old) ++ new)) hm')%pred d' ]] \/ [[ r = false /\ length ((padded_log old) ++ new) > LogLen xp /\ (F * rep xp (Synced old) hm')%pred d' ]]) XCRASH:hm_crash exists cs' d', BUFCACHE.rep cs' d' * ( [[ (F * rep xp (Synced old) hm_crash)%pred d' ]] \/ [[ (F * rep xp (Extended old new) hm_crash)%pred d' ]]) >} extend xp new cs. Proof. unfold extend. step. step. - rewrite <- DescDefs.ipack_nopad_ipack_eq. step. unfold checksums_match in *; intuition. solve_hash_list_rep. step. unfold checksums_match in *; intuition. solve_hash_list_rep. safestep. rewrite Desc.avail_rep_split. cancel. autorewrite with lists; apply helper_loglen_desc_valid_extend; auto. safestep. rewrite Data.avail_rep_split. cancel. autorewrite with lists. rewrite divup_1; rewrite <- entry_valid_ndata by auto. apply helper_loglen_data_valid_extend; auto. safestep. denote Hdr.rep as Hx; unfold Hdr.rep in Hx. destruct_lift Hx. unfold Hdr.hdr_goodSize in *; intuition. eapply loglen_valid_goodSize_l; eauto. eapply loglen_valid_goodSize_r; eauto. step. eauto 10. prestep. norm. cancel. intuition simpl. instantiate ( 1 := map ent_addr (padded_log new) ). rewrite desc_padding_unsync_piff. pred_apply; cancel. rewrite map_length, padded_log_length; auto. apply padded_desc_valid. apply loglen_valid_desc_valid; auto. eauto 10. safestep. autorewrite with lists. rewrite entry_valid_ndata, Nat.mul_1_r; auto. eauto 10. safestep. eauto 10. step. safestep. or_l; cancel. cancel_by extend_ok_helper; auto. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm. cancel. xform_normr. cancel. or_r. cancel. extend_crash. solve_checksums. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_r. cancel. extend_crash. solve_checksums. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_r. cancel. extend_crash. solve_checksums. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_r. cancel. extend_crash. solve_checksums. solve_checksums. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_r. cancel. extend_crash. solve_checksums. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_r. cancel. extend_crash. solve_checksums. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_l; cancel. extend_crash. solve_checksums. cancel. repeat xcrash_rewrite. xform_norm; cancel. xform_normr; cancel. or_l; cancel. rewrite Desc.avail_rep_merge. cancel. rewrite map_length. apply helper_loglen_desc_valid_extend; auto. solve_checksums. xcrash. or_l; cancel. solve_checksums. xcrash. or_l; cancel. solve_checksums. - safestep. or_r; cancel. apply loglen_invalid_overflow; auto. solve_checksums. - xcrash. or_l; cancel. solve_checksums. Qed. Hint Extern 1 ({{_}} Bind (avail _ _) _) => apply avail_ok : prog. Hint Extern 1 ({{_}} Bind (read _ _) _) => apply read_ok : prog. Hint Extern 1 ({{_}} Bind (trunc _ _) _) => apply trunc_ok : prog. Hint Extern 1 ({{_}} Bind (extend _ _ _) _) => apply extend_ok : prog. Theorem entry_valid_dec : forall ent, {entry_valid ent} + {~ entry_valid ent}. 
intuition]. find_inversion. simpl. do_in_map. subst. simpl in *. find_inversion. intuition. match goal with | |- context [pred ?x] => remember (pred x) as index end. break_match; simpl in *. - right. eauto. - destruct index; intuition. Qed. Lemma doLeader_message_entries : forall st h os st' ms m t n pli plt es ci e, doLeader st h = (os, st', ms) -> In m ms -> snd m = AppendEntries t n pli plt es ci -> In e es -> In e (log st). Proof using. intros. unfold doLeader, advanceCommitIndex in *. break_match; try solve [find_inversion; simpl in *; intuition]. break_if; try solve [find_inversion; simpl in *; intuition]. find_inversion. simpl. do_in_map. subst. simpl in *. find_inversion. eauto using findGtIndex_in. Qed. Theorem handleAppendEntries_log_term_type : forall h st t n pli plt es ci st' ps, handleAppendEntries h st t n pli plt es ci = (st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' = Follower. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleAppendEntries_votesReceived : forall h st t n pli plt es ci st' ps, handleAppendEntries h st t n pli plt es ci = (st', ps) -> votesReceived st' = votesReceived st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleAppendEntriesReply_log_term_type : forall h st n t es r st' ps, handleAppendEntriesReply h st n t es r = (st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' = Follower. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleAppendEntriesReply_votesReceived : forall h st n t es r st' ps, handleAppendEntriesReply h st n t es r = (st', ps) -> votesReceived st' = votesReceived st. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleRequestVote_log_term_type : forall h st t c li lt st' m, handleRequestVote h st t c li lt = (st', m) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ type st' = Follower. Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Theorem handleRequestVote_votesReceived : forall h st t c li lt st' m, handleRequestVote h st t c li lt = (st', m) -> votesReceived st' = votesReceived st. 
Qed.Theorem error_le_half_ulp : forall choice x, (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp x)%R. Proof with auto with typeclass_instances. intros choice x. destruct (generic_format_EM beta fexp x) as [Hx|Hx].rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. apply Rmult_le_pos. apply Rlt_le. apply Rinv_0_lt_compat. now apply IZR_lt. apply ulp_ge_0.set (d := round beta fexp Zfloor x). destruct (round_N_pt beta fexp choice x) as (Hr1, Hr2). destruct (Rle_or_lt (x - d) (d + ulp x - x)) as [H|H].apply Rle_trans with (Rabs (d - x)). apply Hr2. apply (round_DN_pt beta fexp x). rewrite Rabs_left1. rewrite Ropp_minus_distr. apply Rmult_le_reg_r with 2%R. now apply IZR_lt. apply Rplus_le_reg_r with (d - x)%R. ring_simplify. apply Rle_trans with (1 := H). right. field. apply Rle_minus. apply (round_DN_pt beta fexp x).assert (Hu: (d + ulp x)%R = round beta fexp Zceil x). unfold d. now rewrite <- round_UP_DN_ulp. apply Rle_trans with (Rabs (d + ulp x - x)). apply Hr2. rewrite Hu. apply (round_UP_pt beta fexp x). rewrite Rabs_pos_eq. apply Rmult_le_reg_r with 2%R. now apply IZR_lt. apply Rplus_le_reg_r with (- (d + ulp x - x))%R. ring_simplify. apply Rlt_le. apply Rlt_le_trans with (1 := H). right. field. apply Rle_0_minus. rewrite Hu. apply (round_UP_pt beta fexp x). Qed.Theorem ulp_DN : forall x, (0 <= x)%R -> ulp (round beta fexp Zfloor x) = ulp x. Proof with auto with typeclass_instances. intros x [Hx|Hx]. - rewrite (ulp_neq_0 x) by now apply Rgt_not_eq. destruct (round_ge_generic beta fexp Zfloor 0 x) as [Hd|Hd]. apply generic_format_0. now apply Rlt_le. + rewrite ulp_neq_0 by now apply Rgt_not_eq. now rewrite cexp_DN with (2 := Hd). + rewrite <- Hd. unfold cexp. destruct (mag beta x) as [e He]. simpl. specialize (He (Rgt_not_eq _ _ Hx)). apply sym_eq in Hd. assert (H := exp_small_round_0 _ _ _ _ _ He Hd). unfold ulp. rewrite Req_bool_true by easy. destruct negligible_exp_spec as [H0|k Hk]. now elim Zlt_not_le with (1 := H0 e). now apply f_equal, fexp_negligible_exp_eq. - rewrite <- Hx, round_0... Qed.Theorem round_neq_0_negligible_exp : negligible_exp = None -> forall rnd { Zrnd : Valid_rnd rnd } x, (x <> 0)%R -> (round beta fexp rnd x <> 0)%R. Proof with auto with typeclass_instances. intros H rndn Hrnd x Hx K. case negligible_exp_spec'. intros (_,Hn). destruct (mag beta x) as (e,He). absurd (fexp e < e)%Z. apply Zle_not_lt. apply exp_small_round_0 with beta rndn x... apply (Hn e). intros (n,(H1,_)). rewrite H in H1; discriminate. Qed. Theorem error_lt_ulp_round : forall { Hm : Monotone_exp fexp } rnd { Zrnd : Valid_rnd rnd } x, (x <> 0)%R -> (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R. 
-> (bpow e2 < F2R (Float beta m e1))%R -> (bpow e2 <= F2R (Float beta (m - 1) e1))%R. Proof. intros m e1 e2 Hm. case (Zle_or_lt e1 e2); intros He. replace e2 with (e2 - e1 + e1)%Z by ring. rewrite bpow_plus. unfold F2R. simpl. rewrite <- (Z2R_Zpower beta (e2 - e1)). intros H. apply Rmult_le_compat_r. apply bpow_ge_0. apply Rmult_lt_reg_r in H. apply Z2R_le. rewrite (Zpred_succ (Zpower _ _)). apply Zplus_le_compat_r. apply Zlt_le_succ. now apply lt_Z2R. apply bpow_gt_0. now apply Zle_minus_le_0. intros H. apply Rle_trans with (1*bpow e1)%R. rewrite Rmult_1_l. apply bpow_le. now apply Zlt_le_weak. unfold F2R. simpl. apply Rmult_le_compat_r. apply bpow_ge_0. replace 1%R with (Z2R 1) by reflexivity. apply Z2R_le. omega. Qed.Theorem F2R_lt_bpow : forall f : float beta, forall e', (Zabs (Fnum f) < Zpower beta (e' - Fexp f))%Z -> (Rabs (F2R f) < bpow e')%R. Proof. intros (m, e) e' Hm. rewrite <- F2R_Zabs. destruct (Zle_or_lt e e') as [He|He]. unfold F2R. simpl. apply Rmult_lt_reg_r with (bpow (-e)). apply bpow_gt_0. rewrite Rmult_assoc, <- 2!bpow_plus, Zplus_opp_r, Rmult_1_r. rewrite <-Z2R_Zpower. 2: now apply Zle_left. now apply Z2R_lt. elim Zlt_not_le with (1 := Hm). simpl. cut (e' - e < 0)%Z. 2: omega. clear. case (e' - e)%Z ; try easy. intros p _. apply Zabs_pos. Qed.Theorem F2R_change_exp : forall e' m e : Z, (e' <= e)%Z -> F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e')) e'). Proof. intros e' m e He. unfold F2R. simpl. rewrite Z2R_mult, Z2R_Zpower, Rmult_assoc. apply f_equal. pattern e at 1 ; replace e with (e - e' + e')%Z by ring. apply bpow_plus. now apply Zle_minus_le_0. Qed.Theorem F2R_prec_normalize : forall m e e' p : Z, (Zabs m < Zpower beta p)%Z -> (bpow (e' - 1)%Z <= Rabs (F2R (Float beta m e)))%R -> F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e' + p)) (e' - p)). Proof. intros m e e' p Hm Hf. assert (Hp: (0 <= p)%Z). destruct p ; try easy. now elim (Zle_not_lt _ _ (Zabs_pos m)).replace (e - e' + p)%Z with (e - (e' - p))%Z by ring. apply F2R_change_exp. cut (e' - 1 < e + p)%Z. omega. apply (lt_bpow beta). apply Rle_lt_trans with (1 := Hf). rewrite <- F2R_Zabs, Zplus_comm, bpow_plus. apply Rmult_lt_compat_r. apply bpow_gt_0. rewrite <- Z2R_Zpower. now apply Z2R_lt. exact Hp. Qed. Theorem ln_beta_F2R_bounds : forall x m e, (0 < m)%Z -> (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R -> ln_beta beta x = ln_beta beta (F2R (Float beta m e)) :> Z. 
Add a l l' -> (NoDup l' <-> NoDup l /\ ~In a l). Proof. induction 1 as [l|x l l' AD IH]. - split; [ inversion_clear 1; now split | now constructor ]. - split. + inversion_clear 1. rewrite IH in *. rewrite (Add_in AD) in *. simpl in *; split; try constructor; intuition. + intros (N,IN). inversion_clear N. constructor. * rewrite (Add_in AD); simpl in *; intuition. * apply IH. split; trivial. simpl in *; intuition. Qed. Lemma NoDup_remove l l' a : NoDup (l++a::l') -> NoDup (l++l') /\ ~In a (l++l'). Proof. apply NoDup_Add. apply Add_app. Qed. Lemma NoDup_remove_1 l l' a : NoDup (l++a::l') -> NoDup (l++l'). Proof. intros. now apply NoDup_remove with a. Qed. Lemma NoDup_remove_2 l l' a : NoDup (l++a::l') -> ~In a (l++l'). Proof. intros. now apply NoDup_remove. Qed. Theorem NoDup_cons_iff a l: NoDup (a::l) <-> ~ In a l /\ NoDup l. Proof. split. + inversion_clear 1. now split. + now constructor. Qed. Hypothesis decA: forall x y : A, {x = y} + {x <> y}. Fixpoint nodup (l : list A) : list A := match l with | [] => [] | x::xs => if in_dec decA x xs then nodup xs else x::(nodup xs) end. Lemma nodup_In l x : In x (nodup l) <-> In x l. Proof. induction l as [|a l' Hrec]; simpl. - reflexivity. - destruct (in_dec decA a l'); simpl; rewrite Hrec. * intuition; now subst. * reflexivity. Qed. Lemma NoDup_nodup l: NoDup (nodup l). Proof. induction l as [|a l' Hrec]; simpl. - constructor. - destruct (in_dec decA a l'); simpl. * assumption. * constructor; [ now rewrite nodup_In | assumption]. Qed. Lemma nodup_inv k l a : nodup k = a :: l -> ~ In a l. Proof. intros H. assert (H' : NoDup (a::l)). { rewrite <- H. apply NoDup_nodup. } now inversion_clear H'. Qed. Theorem NoDup_count_occ l: NoDup l <-> (forall x:A, count_occ decA l x <= 1). Proof. induction l as [| a l' Hrec]. - simpl; split; auto. constructor. - rewrite NoDup_cons_iff, Hrec, (count_occ_not_In decA). clear Hrec. split. + intros (Ha, H) x. simpl. destruct (decA a x); auto. subst; now rewrite Ha. + split. * specialize (H a). rewrite count_occ_cons_eq in H; trivial. now inversion H. * intros x. specialize (H x). simpl in *. destruct (decA a x); auto. now apply Nat.lt_le_incl. Qed. Theorem NoDup_count_occ' l: NoDup l <-> (forall x:A, In x l -> count_occ decA l x = 1). 
-> sorted l2 -> sorted (merge l1 l2). Proof. unfold merge in |- *; intros l1 l2 H1 H2; elim (merge_aux_sorted (length l1 + length l2) l1 l2); auto. Qed.Theorem list_ind2 : forall (B:Type) (P:list B -> Prop), P nil -> (forall x:B, P (x :: nil)) -> (forall (x1 x2:B) (l:list B), P l -> P (x1 :: x2 :: l)) -> forall l:list B, P l. Proof. intros B P P0 P1 Pr l;assert (H: P l /\ forall x:B, P (x :: l)) by (elim l; intuition). now destruct H. Qed.Theorem sort_aux1_all_sorted : forall l:list (list A), all_sorted l -> all_sorted (sort_aux1 l). Proof. intros l; elim l using list_ind2. - simpl in |- *; trivial. - simpl in |- *; trivial. - intros x1 x2 tl Hrec Has; inversion Has; clear Has. match goal with | id:(all_sorted _) |- _ => inversion id end. simpl in |- *; constructor. + apply merge_sorted; auto. + auto. Qed.Theorem sort_aux1_shorter : forall l:list (list A), length (sort_aux1 l) <= length l. Proof. intros l; elim l using list_ind2; simpl in |- *; auto with arith. Qed.Theorem sort_aux2_sorted : forall (b:nat) (l:list (list A)), length l <= b -> all_sorted l -> sorted (sort_aux2 l b). Proof. induction b as [ | b IHb]. - intros l; case l. + intros; constructor. + simpl in |- *; intros a l' Hle; inversion Hle. - intro l; case l. + simpl in |- *; intros; constructor. + intros l1 tl; case tl. * intros Hle Has; inversion Has; assumption. * simpl in |- *; intros l2 tl' Hle Has; apply IHb. simpl in |- *. generalize (sort_aux1_shorter tl'); intros; lia. inversion Has; clear Has. match goal with | id:(all_sorted _) |- _ => inversion id end. constructor. apply merge_sorted; assumption. apply sort_aux1_all_sorted; assumption. Qed.Theorem sort_sorted : forall l:list A, sorted (sort l). Proof. intros l; unfold sort in |- *. apply sort_aux2_sorted. rewrite mk_singletons_length; auto. apply mk_singletons_all_sorted. Qed.Inductive permutation : list A -> list A -> Prop := | transpose_first : forall (a b:A) (l:list A), permutation (a :: b :: l) (b :: a :: l) | permutation_same_head : forall (a:A) (l1 l2:list A), permutation l1 l2 -> permutation (a :: l1) (a :: l2) | permutation_empty : permutation nil nil | permutation_transitive : forall l1 l2 l3:list A, permutation l1 l2 -> permutation l2 l3 -> permutation l1 l3. Theorem permutation_reflexive : forall l:list A, permutation l l. 
V Y f = X). Proof. intros A f X H'; elim H'. intro H'0; exists 0. exists (Empty_set U); auto with sets. intros A0 H'0 H'1 x H'2 H'3; try assumption. lapply H'1; [ intro H'4; elim H'4; intros n E; elim E; clear H'4 H'1 | clear H'1 ]; auto with sets. intros x0 H'1; try assumption. exists (S n); try assumption. elim H'1; intros H'4 H'5; elim H'4; intros H'6 H'7; try exact H'6; clear H'4 H'1. clear E. generalize H'2. rewrite <- H'5. intro H'1; try assumption. red in H'3. generalize (H'3 x). intro H'4; lapply H'4; [ intro H'8; try exact H'8; clear H'4 | clear H'4 ]; auto with sets. specialize Im_inv with (U := U) (V := V) (X := A) (f := f) (y := x); intro H'11; lapply H'11; [ intro H'13; elim H'11; clear H'11 | clear H'11 ]; auto with sets. intros x1 H'4; try assumption. apply ex_intro with (x := Add U x0 x1). split; [ split; [ try assumption | idtac ] | idtac ]. apply card_add; auto with sets. red; intro H'9; try exact H'9. apply H'1. elim H'4; intros H'10 H'11; rewrite <- H'11; clear H'4; auto with sets. elim H'4; intros H'9 H'10; try exact H'9; clear H'4; auto with sets. red; auto with sets. intros x2 H'4; elim H'4; auto with sets. intros x3 H'11; elim H'11; auto with sets. elim H'4; intros H'9 H'10; rewrite <- H'10; clear H'4; auto with sets. apply Im_add; auto with sets. Qed. Theorem Image_set_continuous' : forall (A:Ensemble U) (f:U -> V) (X:Ensemble V), Approximant V (Im U V A f) X -> exists Y : _, Approximant U A Y /\ Im U V Y f = X. Proof. intros A f X H'; try assumption. cut (exists n : _, (exists Y : _, (cardinal U Y n /\ Included U Y A) /\ Im U V Y f = X)). intro H'0; elim H'0; intros n E; elim E; clear H'0. intros x H'0; try assumption. elim H'0; intros H'1 H'2; elim H'1; intros H'3 H'4; try exact H'3; clear H'1 H'0; auto with sets. exists x. split; [ idtac | try assumption ]. apply Defn_of_Approximant; auto with sets. apply cardinal_finite with (n := n); auto with sets. apply Image_set_continuous; auto with sets. elim H'; auto with sets. elim H'; auto with sets. Qed. Theorem Pigeonhole_bis : forall (A:Ensemble U) (f:U -> V), ~ Finite U A -> Finite V (Im U V A f) -> ~ injective U V f. 
0. Admitted. Instance testSuchThat_Conj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, Q b -> prop a b)} : Checkable (forall a b, P a /\ Q b -> prop a b) := {| checker f := checker (fun a P b Q => f a b _ ) |}. Proof. split; auto. Defined.Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Admitted. Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Admitted. Instance testSuchThat_Disj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, prop a b)} `{Checkable (forall b, Q b -> forall a, prop a b)} : Checkable (forall a b, P a \/ Q b -> prop a b) := {| checker f := disjoin (Datatypes.cons (checker (fun a P b => f a b _ )) (Datatypes.cons (checker (fun b Q a => f a b _)) Datatypes.nil)) |}. Proof. - left; auto. - right; auto. Defined. Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Admitted. Lemma or_intro : forall A B : Prop, A -> A \/ B. Admitted. Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Admitted. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Admitted. Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Admitted. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Admitted. Theorem contradiction_implies_anything : forall P Q : Prop, (P /\ ~P) -> Q. Admitted. Theorem contrapositive : forall (P Q : Prop), (P -> Q) -> (~Q -> ~P). Admitted. Theorem not_both_true_and_false : forall P : Prop, ~ (P /\ ~P). 
h = SE.WellTyped_sexpr tf tp tU tG (sheapD h). Proof. clear. intros. destruct h. unfold WellTyped_sheap, WellTyped_impures, sheapD; simpl. eapply MF.PROPS.fold_rec with (m := impures0); intros; simpl. { rewrite NatMap.IntMapProperties.fold_Empty; eauto with typeclass_instances. rewrite starred_pures_well_typed. rewrite starred_const_well_typed. simpl. symmetry; apply andb_true_r. } { rewrite NatMap.IntMapProperties.fold_Add with (eqA := fun x y => WellTyped_sexpr tf tp tU tG x = WellTyped_sexpr tf tp tU tG y). 5: eauto. 5: eauto. destruct e. simpl. rewrite andb_true_r. eauto. rewrite starred_funcs_well_typed. rewrite <- H2. rewrite andb_comm. rewrite andb_assoc. rewrite andb_assoc. rewrite andb_comm. repeat rewrite <- andb_assoc. f_equal. apply andb_comm. { clear; econstructor; auto. red. intros; think. auto. } { clear. repeat red; intros; subst. induction y0; simpl; intros; auto. consider (starred (Func y) y0 x1); consider (starred (Func y) y0 y1); intros; simpl in *; think; repeat match goal with | [ |- context [ nth_error ?X ?Y ] ] => destruct (nth_error X Y) | [ H : true = _ |- _ ] => rewrite <- H | [ H : false = _ |- _ ] => rewrite <- H end; auto using andb_true_r. } { clear. repeat (red; intros; subst). repeat rewrite starred_funcs_well_typed. destruct e; destruct e'; auto. generalize (l :: e); generalize (l0 :: e'). intros. destruct (nth_error tp k); destruct (nth_error tp k'); auto. rewrite andb_comm. rewrite <- andb_assoc. f_equal. apply andb_comm. rewrite andb_false_r. auto. rewrite andb_false_r; auto. } } Qed. Definition sheapD' (h : SHeap) : sexpr types pcType stateType := Star (FM.fold (fun k => starred (Func k)) (impures h) Emp) (Star (starred (@Inj _ _ _) (pures h) Emp) (starred (@Const _ _ _) (other h) Emp)). Definition impuresD (imp : MM.mmap (exprs types)) : sexpr types pcType stateType := FM.fold (fun k ls acc => Star (starred (Func k) ls Emp) acc) imp Emp. Section with_envs. Variables U G : env types. Variable cs : codeSpec (tvarD types pcType) (tvarD types stateType). Local Notation "a '<===>' b" := (heq funcs preds U G cs a b) (at level 60, only parsing). Theorem starred_def : forall (T : Type) (F : T -> SE.sexpr _ _ _) (ls : list T) (base : SE.sexpr _ _ _), (starred F ls base) <===> (fold_right (fun x a => SE.Star (F x) a) base ls). Proof. induction ls; simpl; intros. reflexivity. specialize (IHls base). revert IHls. case_eq (starred F ls base); intros; rewrite <- IHls; heq_canceler. Qed. Theorem starred_base : forall T F ls base, (@starred T F ls base) <===> (SE.Star base (@starred T F ls Emp)). 
(x-n = S(x-S n)) as Hxn3. 1:lia. rewrite Hxn3. cbn. easy. + easy. Qed. Lemma prove_constraints : (zero .: cr2 .: cr1 .: rho) ⊨ translate_constraints h10. Proof using φ Hφ. pose (S (highest_var_list h10)) as h10vars. unfold translate_constraints. fold h10vars. pose (highest_num φ h10vars) as h10max. pose (@constr_nums h10max) as Hcons. intros HH. cbn. pose proof (prove_emplace_forall HH) as H. clear HH. apply Hcons. intros f Hrepr. specialize (H (fun t => f (φ t))). pose ((fun v : nat => if v <? h10vars then (fun t : nat => f (φ t)) v else (zero .: cr2 .: cr1 .: rho) (v - h10vars))) as newenv. assert (newenv (S h10vars) = cr2) as Hne1. 1: {unfold newenv. assert (S h10vars <? h10vars = false) as ->. 1: apply Nat.leb_gt; now lia. assert (S h10vars - h10vars = 1) as ->. 1:now lia. easy. } assert (newenv (S (S h10vars)) = cr1) as Hne2. 1: {unfold newenv. assert (S (S h10vars) <? h10vars = false) as ->. 1: apply Nat.leb_gt;lia. assert (S (S h10vars) - h10vars = 2) as ->. 1:now lia. easy. } fold newenv in H. assert (forall c:h10upc, In c h10 -> newenv ⊨ translate_single c (S h10vars)) as Hmain. - intros [[a b][c d]] Hin. pose (@highest_var_list_descr h10 ((a,b),(c,d)) Hin) as Habcdmax. cbn in Habcdmax. intros HH. cbn. rewrite Hne1, Hne2. apply (@constr_rel (φ a) (φ b) (φ c) (φ d) f h10max). 1:easy. 1-4: eapply highest_num_descr; lia. 1: apply (@Hφ ((a,b),(c,d)) Hin). intros pab pcd [Ha [Hb [Hab [Haab Hbab]]]] [Hc [Hd [Hcd [Hccd Hdcd]]]] Hpp. assert (forall k:nat, k < h10vars -> newenv k = f (φ k)) as Hvars. 1:{ unfold newenv, h10vars. intros k Hk. destruct (Nat.ltb_lt k h10vars) as [_ Hr]. fold h10vars. now rewrite Hr. } cbn in HH. rewrite Hne1, Hne2, (Hvars a), (Hvars b), (Hvars c), (Hvars d) in HH. 2-5: unfold h10vars;lia. now apply (@HH pcd pab). - induction h10 as [|hx hr IH] in H,Hmain|-*. + cbn in H. rewrite Hne1,Hne2 in H. apply H. + apply IH. * cbn in H. apply H. apply Hmain. now left. * intros c Hhr. apply Hmain. now right. Qed. End Transport. Lemma transport_direct : H10UPC_SAT h10 -> valid F. Proof. intros [φ Hφ]. intros D I rho. intros cr1 cr2 zero. intros H_zero H_succ_left H_succ_right. eapply (@prove_constraints φ Hφ (Build_model H_zero H_succ_left H_succ_right)). Qed. End validity. Theorem directValidReduction : reduces (H10UPC_SAT) (@valid sig_empty sig_binary falsity_off). 
y -> prod_is_inv_r x z -> z = y. Proof Ring.prod_inv_r_uniq ring. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Ring.prod_inv_uniq ring. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Ring.prod_inv_1 ring. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Ring.prod_has_inv_l_1 ring. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Ring.prod_has_inv_r_1 ring. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof Ring.prod_0_inv_r ring. Theorem prod_0_inv : ~ prod_has_inv 0. Proof Ring.prod_0_inv ring. Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof Ring.prod_inv_0 ring. Definition E_n1_strong : { x : E | sum_is_inv 1 x } := Ring.E_n1_strong ring. Definition E_n1 : E := Ring.E_n1 ring. Notation "{-1}" := E_n1 : commutative_ring_scope. Definition E_n1_def : sum_is_inv 1 {-1} := Ring.E_n1_def ring. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof Ring.E_n1_inv_l ring. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof Ring.E_n1_inv_r ring. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof Ring.E_n1_uniq ring. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). Proof Ring.prod_n1_x_inv_l ring. Theorem prod_x_n1_inv_l : forall x : E, sum_is_inv_l x (x # {-1}). Proof Ring.prod_x_n1_inv_l ring. Theorem prod_n1_x_inv_r : forall x : E, sum_is_inv_r x ({-1} # x). Proof Ring.prod_n1_x_inv_r ring. Theorem prod_x_n1_inv_r : forall x : E, sum_is_inv_r x (x # {-1}). Proof Ring.prod_x_n1_inv_r ring. Theorem prod_n1_x_inv : forall x : E, sum_is_inv x ({-1} # x). Proof Ring.prod_n1_x_inv ring. Theorem prod_x_n1_inv : forall x : E, sum_is_inv x (x # {-1}). Proof Ring.prod_x_n1_inv ring. Theorem prod_n1_neg : {#} {-1} = sum_neg. Proof Ring.prod_n1_neg ring. Theorem prod_x_n1_neg : forall x : E, x # {-1} = - x. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat. From Categories Require Import Cat.Cat. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso.Local Open Scope isomorphism_scope. Local Open Scope morphism_scope. Local Open Scope object_scope. Section Opposite_Cat_Iso. Context {C D : Category} (I : C ≃≃ D ::> Cat). Program Definition Opposite_Cat_Iso : (C^op)%category ≃≃ (D^op)%category ::> Cat := {| iso_morphism := ((iso_morphism I)^op)%functor; inverse_morphism := ((inverse_morphism I)^op)%functor |}. Next Obligation. change (I ⁻¹ ^op ∘ (iso_morphism I) ^op)%functor with (((inverse_morphism I) ∘ (iso_morphism I))^op)%functor. cbn_rewrite (left_inverse I). trivial. Qed. Next Obligation. change ((iso_morphism I) ^op ∘ I ⁻¹ ^op)%functor with (((iso_morphism I) ∘ (inverse_morphism I))^op)%functor. cbn_rewrite (right_inverse I). trivial. Qed.End Opposite_Cat_Iso. Section Cat_IConv. Context {C D : Category} (I : C ≃≃ D ::> Cat). Definition Cat_Iso_Obj_conv (c : C) : c = (((inverse_morphism I) _o) (((iso_morphism I) _o) c))%object. Proof. change (I ⁻¹ _o ((iso_morphism I) _o c)) with ((I ⁻¹ ∘ I)%morphism _o c)%object; rewrite (left_inverse I); trivial. Qed. Definition Cat_Iso_Hom_conv (c c' : C) : ((((inverse_morphism I) _o) (((iso_morphism I) _o) c)) –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))%morphism = (c –≻ c'). Proof. do 2 rewrite <- Cat_Iso_Obj_conv; trivial. Defined. Definition Cat_Iso_conv_inv {c c' : C} (h : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))) : c –≻ c' := match Cat_Iso_Hom_conv c c' in _ = Y return Y with eq_refl => h end. Theorem Cat_Iso_conv_inv_JMeq {c c' : C} (h : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))) : Cat_Iso_conv_inv h ~= h. Proof. unfold Cat_Iso_conv_inv. destruct Cat_Iso_Hom_conv. trivial. Qed. Definition Cat_Iso_conv {c c' : C} (h : c –≻ c') : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) –≻ (((inverse_morphism I) _o) (((iso_morphism I) _o) c')) := match eq_sym (Cat_Iso_Hom_conv c c') in _ = Y return Y with eq_refl => h end. Theorem Cat_Iso_conv_JMeq {c c' : C} (h : c –≻ c') : Cat_Iso_conv h ~= h. 
=> Ret ^(ms, r) end. Definition get_dcache lxp ixp dnum ms := let^ (ms, ocache) <- BFILE.cache_get dnum ms; match ocache with | None => let^ (ms, r0) <- init_cache lxp ixp dnum ms; Ret ^(ms, r0) | Some r => Ret ^(ms, r) end. Definition lookup lxp ixp dnum name ms := let^ (ms, cache) <- get_dcache lxp ixp dnum ms; let r := Dcache.find name (fst cache) in Ret ^(ms, r). Definition unlink lxp ixp dnum name ms := let^ (ms, cache) <- get_dcache lxp ixp dnum ms; match (Dcache.find name (fst cache)) with | None => Ret ^(ms, Err ENOENT) | Some _ => let^ (ms, ix, r) <- SDIR.unlink lxp ixp dnum name ms; ms <- BFILE.cache_put dnum (Dcache.remove name (fst cache), ix) ms; Ret ^(ms, r) end. Definition link' lxp bxp ixp dnum name inum isdir ms := let^ (ms, cache) <- get_dcache lxp ixp dnum ms; let^ (ms, ix, r) <- SDIR.link lxp bxp ixp dnum name inum isdir (snd cache) ms; match r with | Err _ => Ret ^(ms, r) | OK _ => ms <- BFILE.cache_put dnum (Dcache.add name (inum, isdir) (fst cache), ix) ms; Ret ^(ms, r) end. Definition link lxp bxp ixp dnum name inum isdir ms := let^ (ms, lookup_res) <- lookup lxp ixp dnum name ms; match lookup_res with | Some _ => Ret ^(ms, Err EEXIST) | None => let^ (ms, r) <- link' lxp bxp ixp dnum name inum isdir ms; Ret ^(ms, r) end. Definition readdir lxp ixp dnum ms := let^ (ms, r) <- SDIR.readdir lxp ixp dnum ms; Ret ^(ms, r). Definition rep f (dsmap : @mem string string_dec (addr * bool)) : Prop := SDIR.rep f dsmap /\ (forall cache hint, BFILE.BFCache f = Some (cache, hint) -> forall name, Dcache.find name cache = dsmap name). Definition rep_macro Fi Fm m bxp ixp (inum : addr) dsmap ilist frees f ms sm : @pred _ addr_eq_dec valuset := (exists flist, [[[ m ::: Fm * BFILE.rep bxp sm ixp flist ilist frees (BFILE.MSAllocC ms) (BFILE.MSCache ms) (BFILE.MSICache ms) (BFILE.MSDBlocks ms) ]]] * [[[ flist ::: Fi * inum |-> f ]]] * [[ rep f dsmap ]])%pred. Local Hint Unfold rep rep_macro SDIR.rep_macro : hoare_unfold. Lemma rep_mem_eq : forall f m1 m2, rep f m1 -> rep f m2 -> m1 = m2. Proof. unfold rep. intuition eauto using SDIR.rep_mem_eq. Qed. Theorem bfile0_empty : rep BFILE.bfile0 empty_mem. 
Require Import Lexicographic_Exponentiation. Require Import Relation_Definitions. Require Import Inverse_Image. Require Import Inclusion. Require Import List. Require Import Relation_Operators. Require Import Relation_Operators_compat. Require Import Monomials. Require Import Term. Require Import CoefStructure. Require Import OrderStructure. Section Porder. Load "hCoefStructure". Load "hOrderStructure". Load "hTerm".Set Implicit Arguments. Unset Strict Implicit. Definition ltT (a b : Term A n) : Prop := ltM (T2M a) (T2M b). Hint Unfold ltT. Set Strict Implicit. Unset Implicit Arguments. Theorem ltT_trans : transitive (Term A n) ltT. unfold transitive, ltT in |- *; auto. intros x y z H' H'0; apply (ltM_trans _ _ _ _ os) with (y := T2M y); auto. Qed. Lemma eqT_compat_ltTr : forall a b c : Term A n, eqT b c -> ltT a b -> ltT a c. unfold eqT in |- *; unfold ltT in |- *; intros a b c H; rewrite H; auto. Qed. Lemma eqT_compat_ltTl : forall a b c : Term A n, eqT b c -> ltT b a -> ltT c a. unfold eqT in |- *; unfold ltT in |- *; intros a b c H; rewrite H; auto. Qed. Theorem eqT_dec : forall x y : Term A n, {eqT x y} + {~ eqT x y}. intros x y; unfold eqT in |- *; simpl in |- *; auto. apply eqmon_dec. Qed. Theorem ltT_dec : forall x y : Term A n, {ltT x y} + {ltT y x} + {eqT x y}. intros x y; exact (ltM_dec (T2M x) (T2M y)). Qed. Lemma ltT_not_eqT : forall x y : Term A n, eqT x y -> ~ ltT x y. unfold eqT, ltT in |- *; simpl in |- *; intros x y H; rewrite H; auto. apply ltM_nonrefl with (1 := os). Qed. Lemma eqT_not_ltT : forall x y : Term A n, ltT x y -> ~ eqT x y. unfold eqT, ltT, not in |- *; simpl in |- *; intros x y H Q; absurd (ltM (T2M x) (T2M y)); auto; rewrite Q; auto. apply ltM_nonrefl with (1 := os). Qed. Theorem ltT_not_refl : forall x : Term A n, ~ ltT x x. 
do 2?case: ifP. have [[x y] genG _] := generators_2dihedral n_gt1 isoG. have [_ _ _ [_ _ maxG]] := dihedral2_structure n_gt1 genG isoG. rewrite 2!ltn_neqAle n_gt1 !(eq_sym _ n). case: eqP => [_ abelG| _]; first by rewrite (abelem_abelian abelG) in not_cGG. case: eqP => // -> [_ _ isoY _ _]; set Y := <<_>> in isoY. have nxYG: Y <| G by rewrite (p_maximal_normal pG) // maxG !inE eqxx orbT. have [// | [u v] genY _] := generators_2dihedral _ isoY. case/dihedral2_structure: (genY) => //= _ _ _ _ abelY. have:= dn_G_1 _ nxYG (abelem_abelian abelY). by rewrite (abelem_cyclic abelY); case: genY => ->. Qed. Lemma odd_pgroup_rank1_cyclic gT p (G : {group gT}) : p.-group G -> odd #|G| -> cyclic G = ('r_p(G) <= 1). Proof. move=> pG oddG; rewrite -rank_pgroup //; apply/idP/idP=> [cycG | dimG1]. by rewrite -abelian_rank1_cyclic ?cyclic_abelian. have [X nsXG cXX|//|] := normal_rank1_structure pG; last first. by rewrite (negPf (odd_not_extremal2 oddG)) andbF. by rewrite abelian_rank1_cyclic // (leq_trans (rankS (normal_sub nsXG))). Qed. Lemma prime_Ohm1P gT p (G : {group gT}) : p.-group G -> G :!=: 1 -> reflect (#|'Ohm_1(G)| = p) (cyclic G || (p == 2) && (extremal_class G == Quaternion)). Proof. move=> pG ntG; have [p_pr p_dvd_G _] := pgroup_pdiv pG ntG. apply: (iffP idP) => [|oG1p]. case/orP=> [cycG|]; first exact: Ohm1_cyclic_pgroup_prime. case/andP=> /eqP p2 /eqP/quaternion_classP[n n_gt2 isoG]. rewrite p2; have [[x y]] := generators_quaternion n_gt2 isoG. by case/quaternion_structure=> // _ _ [<- oZ _ [->]]. have [X nsXG cXX|-> //|]:= normal_rank1_structure pG. have [sXG _] := andP nsXG; have pX := pgroupS sXG pG. rewrite abelian_rank1_cyclic // (rank_pgroup pX) p_rank_abelian //. rewrite -{2}(pfactorK 1 p_pr) -{3}oG1p dvdn_leq_log ?cardG_gt0 //. by rewrite cardSg ?OhmS. case/and3P=> /eqP p2; rewrite p2 (orbC (cyclic G)) /extremal2. case cG: (extremal_class G) => //; case: notF. case/dihedral_classP: cG => n n_gt1 isoG. have [[x y] genG _] := generators_2dihedral n_gt1 isoG. have [oG _ _ _] := genG; case/dihedral2_structure: genG => // _ _ [defG1 _] _. by case/idPn: n_gt1; rewrite -(@ltn_exp2l 2) // -oG -defG1 oG1p p2. case/semidihedral_classP: cG => n n_gt3 isoG. have [[x y] genG [oy _]] := generators_semidihedral n_gt3 isoG. case/semidihedral_structure: genG => // _ _ [_ _ [defG1 _] _] _ [isoG1 _ _]. case/idPn: (n_gt3); rewrite -(ltn_predK n_gt3) ltnS -leqNgt -(@leq_exp2l 2) //. rewrite -card_2dihedral //; last by rewrite -(subnKC n_gt3). by rewrite -(card_isog isoG1) /= -defG1 oG1p p2. Qed. Theorem symplectic_type_group_structure gT p (G : {group gT}) : p.-group G -> (forall X : {group gT}, X \char G -> abelian X -> cyclic X) -> exists2 E : {group gT}, E :=: 1 \/ extraspecial E & exists R : {group gT}, [/\ cyclic R \/ [/\ p = 2, extremal2 R & #|R| >= 16], E \* R = G & E :&: R = 'Z(E)]. 
Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Malloc Bedrock.Platform.Bootstrap Bedrock.Platform.Cito.examples.CountUnique. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 0. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 0. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "top"!"top" @ [topS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREonly[_] 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREonly[_] mallocHeap 0];; Call "top"!"top"() [PREonly[_] [| False |] ] end }}. Theorem ok : moduleOk boot. 
Require Import Relations. Section leibniz. Variable A : Type. Definition leibniz (a b:A) : Prop := forall P:A -> Prop, P a -> P b. Theorem leibniz_sym : symmetric A leibniz. Proof. intros a b H Q; apply H; trivial. Qed. Theorem leibniz_refl : reflexive A leibniz. Proof. intros a P; trivial. Qed. Theorem leibniz_trans : transitive A leibniz. Proof. intros x y z Hxy Hyz; unfold leibniz; intros P H. apply Hyz; apply Hxy; assumption. Qed. #[local] Hint Resolve leibniz_trans leibniz_sym leibniz_refl : core. Theorem leibniz_equiv : equiv A leibniz. Proof. now repeat split. Qed. Theorem leibniz_least : forall R:relation A, reflexive A R -> inclusion A leibniz R. Proof. intros R H x y H0; apply H0; apply H. Qed. Theorem leibniz_eq : forall a b:A, leibniz a b -> a = b. Proof. intros a b H; now apply H. Qed. Theorem eq_leibniz : forall a b:A, a = b -> leibniz a b. 
Coqlib.two_power_nat_pos (if Archi.ptr64 then 64%nat else 32%nat)). omega. } rewrite Z2Nat.inj_lt; try omega. rewrite Z2Nat.inj_lt in H0; try omega. rewrite Z2Nat.inj_add in * by omega. rewrite Z2Nat.inj_mul in * by omega. rewrite <- Z.div2_div in H0. rewrite Div2_Z_to_nat in H0. rewrite Nat.div2_div in H0. eapply nat_shiftl_p1. chunk_red; simpl; rewrite <- Pos2Nat.inj_1; apply nat_of_P_lt_Lt_compare_morphism; auto. auto. auto. Qed. Theorem repr_unboxed_shiftr: forall t h, repr_unboxed_L7 t h -> Z.shiftr h 1 = Z.of_N t. Proof. intros. inv H. rewrite Ptrofs.Zshiftl_mul_two_p by omega. unfold Z.shiftr. simpl Z.shiftl. unfold Zpower.two_power_pos. simpl. rewrite Zdiv.Zdiv2_div. replace (Z.of_N t * 2 + 1)%Z with (OrdersEx.Z_as_OT.b2z true + 2 * (Z.of_N t))%Z by (simpl OrdersEx.Z_as_OT.b2z; omega). apply OrdersEx.Z_as_OT.add_b2z_double_div2. Qed. Definition boxed_header: N -> N -> Z -> Prop := fun t => fun a => fun h => (h = (Z.shiftl (Z.of_N a) 10) + (Z.of_N t))%Z /\ (0 <= Z.of_N t < Zpower.two_power_pos 8)%Z /\ (0 <= Z.of_N a < Zpower.two_power_nat (Ptrofs.wordsize - 10))%Z.Theorem repr_boxed_header_range: forall t a h, boxed_header t a h -> (0 <= h <= Ptrofs.max_unsigned)%Z. Proof. intros. inv H. rewrite OrdersEx.Z_as_DT.shiftl_mul_pow2. destruct H1. rewrite Zpower.two_power_pos_correct in *. rewrite Zpower.two_power_nat_correct in *. simpl in *. unfold Z.pow_pos in *. 2: omega. split. - apply Z.add_nonneg_nonneg. apply Z.mul_nonneg_nonneg. omega. simpl; omega. omega. - unfold Ptrofs.max_unsigned. unfold Ptrofs.modulus. unfold Ptrofs.wordsize in *. unfold Wordsize_Ptrofs.wordsize in *. chunk_red; simpl in *. omega. omega. Qed. Theorem div2_iter_pos: forall p0 a, (0 <= a -> 0 <= Pos.iter Z.div2 a p0)%Z. Proof. induction p0; intros. - simpl. rewrite OrdersEx.Z_as_OT.div2_nonneg. apply IHp0. apply IHp0. auto. - simpl. apply IHp0. apply IHp0. auto. - simpl; rewrite OrdersEx.Z_as_OT.div2_nonneg; auto. Qed. Theorem mul2_iter_pos: forall p0 a, (0 <= a -> 0 <= Pos.iter (Z.mul 2) a p0)%Z. Proof. induction p0; intros. - simpl. destruct (Pos.iter (Z.mul 2) (Pos.iter (Z.mul 2) a p0) p0) eqn:Hp. * reflexivity. * apply Pos2Z.is_nonneg. * exfalso. assert (0 <= Pos.iter (Z.mul 2) (Pos.iter (Z.mul 2) a p0) p0)%Z. apply IHp0. apply IHp0. auto. rewrite Hp in H0. assert (Hneg := Pos2Z.neg_is_neg p1). omega. - simpl. apply IHp0. apply IHp0. auto. - simpl. destruct a; try omega. apply Pos2Z.is_nonneg. exfalso. assert (Hneg := Pos2Z.neg_is_neg p0). omega. Qed. Theorem pos_iter_xI: forall A f (a:A) p, Pos.iter f (a)%Z p~1 = f (Pos.iter f (Pos.iter f a p)%Z p). Proof. intros. simpl. reflexivity. Qed.Theorem pos_iter_xH: forall A f (a:A), Pos.iter f (a)%Z 1 = f a. Proof. intros. simpl. reflexivity. Qed. Theorem pos_iter_xO: forall A f (a:A) p, Pos.iter f (a)%Z p~0 = (Pos.iter f (Pos.iter f a p)%Z p). 
goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. eapply term_was_created_preserved; [eapply_prop in_any_log_term_was_created|]; [|intros; simpl in *; repeat find_higher_order_rewrite; destruct_update; simpl in *; eauto]. iae_case. - repeat find_higher_order_rewrite. destruct_update; simpl in *; eauto. find_eapply_lem_hyp doLeader_log; eauto. repeat find_rewrite. eauto. - find_apply_hyp_hyp. intuition; eauto. do_in_map. subst. simpl in *. unfold mEntries in *. break_match; try congruence. find_inversion. find_eapply_lem_hyp doLeader_message_entries; eauto. - repeat find_higher_order_rewrite. destruct_update; simpl in *; eauto. Qed. Lemma in_any_log_term_was_created_do_generic_server : refined_raft_net_invariant_do_generic_server in_any_log_term_was_created. Proof using. red. intros. unfold in_any_log_term_was_created. intros. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. eapply term_was_created_preserved; [eapply_prop in_any_log_term_was_created|]; [|intros; simpl in *; repeat find_higher_order_rewrite; destruct_update; simpl in *; eauto]. iae_case. - repeat find_higher_order_rewrite. destruct_update; simpl in *; eauto. find_eapply_lem_hyp doGenericServer_log; eauto. repeat find_rewrite. eauto. - find_apply_hyp_hyp. intuition; eauto. do_in_map. subst. simpl in *. find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. intuition. - repeat find_higher_order_rewrite. destruct_update; simpl in *; eauto. Qed. Lemma in_any_log_term_was_created_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset in_any_log_term_was_created. Proof using. red. intros. unfold in_any_log_term_was_created. intros. unfold in_any_log_term_was_created, term_was_created in *. iae_case. - repeat find_reverse_higher_order_rewrite. find_eapply_lem_hyp in_log. eapply_prop_hyp in_any_log in_any_log. break_exists_exists; repeat find_higher_order_rewrite; eauto. - find_apply_hyp_hyp. find_eapply_lem_hyp in_aer; eauto. eapply_prop_hyp in_any_log in_any_log. break_exists_exists; repeat find_higher_order_rewrite; eauto. - repeat find_reverse_higher_order_rewrite. find_eapply_lem_hyp in_ll; eauto. eapply_prop_hyp in_any_log in_any_log. break_exists_exists; repeat find_higher_order_rewrite; eauto. Qed. Lemma in_any_log_term_was_created_reboot : refined_raft_net_invariant_reboot in_any_log_term_was_created. Proof using. red. unfold in_any_log_term_was_created, term_was_created. intros. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. iae_case; eauto. - repeat find_higher_order_rewrite. destruct_update; simpl in *; find_apply_lem_hyp in_log; eapply_prop_hyp in_any_log in_any_log; break_exists_exists; repeat find_higher_order_rewrite; destruct_update; simpl in *; eauto. - repeat find_reverse_rewrite. find_eapply_lem_hyp in_aer; eauto. eapply_prop_hyp in_any_log in_any_log; break_exists_exists; repeat find_higher_order_rewrite; destruct_update; simpl in *; eauto. - repeat find_higher_order_rewrite. destruct_update; simpl in *; find_eapply_lem_hyp in_ll; eauto; eapply_prop_hyp in_any_log in_any_log; break_exists_exists; repeat find_higher_order_rewrite; destruct_update; simpl in *; eauto. Qed. Lemma in_any_log_term_was_created_init : refined_raft_net_invariant_init in_any_log_term_was_created. Proof using. red. unfold in_any_log_term_was_created. intros. iae_case; intuition. Qed. Theorem in_any_log_term_was_created_invariant : forall net, refined_raft_intermediate_reachable net -> in_any_log_term_was_created net. 
, ∀a ∈ A, rank a ∈ rank A. Proof with eauto; try congruence. intros A Hgnd a Ha. apply grounded_in_rank in Hgnd as HA. apply HA in Ha. apply V_elim in Ha as [β [Hβ Ha]]... apply PowerAx in Ha. assert (Hoβ: β ⋵ 𝐎𝐍). eapply ord_is_ords; revgoals... assert (Hgnda: a ⋵ 𝐖 ). exists β. split... pose proof (rank_spec_intro a Hgnda) as [_ [_ H]]. pose proof (H β Hoβ Ha) as []... eapply ord_trans... Qed.Section RankRecurrence.Let Ω := λ A, {(rank a)⁺ | a ∊ A}. Let α := λ A, ⋃ (Ω A).Local Lemma Ω_is_ords : ∀ A, A ⪽ 𝐖 → Ω A ⪽ 𝐎𝐍. Proof. intros A Hgnd x Hx. apply ReplAx in Hx as [a [Ha Hx]]. subst x. apply ord_suc_is_ord. apply rank_is_ord. apply Hgnd. apply Ha. Qed.Local Lemma α_is_ord : ∀ A, A ⪽ 𝐖 → α A ⋵ 𝐎𝐍. Proof. intros A Hgnd. apply union_of_ords_is_ord. apply Ω_is_ords. apply Hgnd. Qed.Local Lemma grounded_in_α : ∀ A, A ⪽ 𝐖 → A ⊆ V (α A). Proof with eauto; try congruence. intros A Hgnd a Ha. apply Hgnd in Ha as Hgnda. apply grounded_under_rank in Hgnda. assert ((rank a)⁺ ⋸ (α A)). { apply ord_sup_is_ub. apply Ω_is_ords... apply ReplAx. exists a. split... } destruct H as []... eapply V_sub... apply α_is_ord... Qed. Theorem grounded_intro : ∀ A, A ⪽ 𝐖 → A ⋵ 𝐖 . Proof with auto. intros A Hgnd. exists (α A). split. apply α_is_ord... apply grounded_in_α... Qed. Theorem rank_recurrence : ∀A ⋵ 𝐖 , rank A = α A. Proof with eauto. intros A Hgnd. assert (Hoα: α A ⋵ 𝐎𝐍). { apply α_is_ord. apply member_grounded... } apply sub_antisym. - apply ord_le_iff_sub... apply rank_spec_intro... apply grounded_in_α. apply member_grounded... - intros x Hx. apply FUnionE in Hx as [a [Ha Hx]]. apply rank_of_member in Ha... apply BUnionE in Hx as []. eapply ord_trans... apply SingE in H. subst... Qed.End RankRecurrence. Fact ord_grounded : 𝐎𝐍 ⫃ 𝐖 . Proof. ord_induction. intros α Hα. now apply grounded_intro. Qed. Fact rank_of_ord : ∀α ⋵ 𝐎𝐍, rank α = α. Proof with eauto; try congruence. ord_induction. intros α Hα IH. rewrite rank_recurrence; [|apply ord_grounded]... ext Hx. - apply FUnionE in Hx as [β [Hβ Hx]]. rewrite IH in Hx... apply BUnionE in Hx as []. eapply ord_trans... apply SingE in H... - apply IH in Hx as Heq. eapply FUnionI... rewrite Heq. apply suc_has_n. Qed. Theorem all_grounded_iff_regularity : (∀ A, A ⋵ 𝐖 ) ↔ Regularity. 
: irec -> addr. Parameter IRIndPtr : irec -> addr. Parameter IRDindPtr: irec -> addr. Parameter IRTindPtr: irec -> addr. Parameter IRBlocks : irec -> list waddr. Parameter IRAttrs : irec -> iattr. Parameter upd_len : irec -> addr -> irec. Parameter upd_irec : forall (r : irec) (len : addr) (ibptr : addr) (dibptr : addr) (tibptr : addr) (dbns : list waddr), irec. Parameter upd_irec_eq_upd_len : forall ir len, goodSize addrlen len -> upd_len ir len = upd_irec ir len (IRIndPtr ir) (IRDindPtr ir) (IRTindPtr ir) (IRBlocks ir). Parameter upd_len_get_len : forall ir n, goodSize addrlen n -> IRLen (upd_len ir n) = n. Parameter upd_len_get_ind : forall ir n, IRIndPtr (upd_len ir n) = IRIndPtr ir. Parameter upd_len_get_dind : forall ir n, IRDindPtr (upd_len ir n) = IRDindPtr ir. Parameter upd_len_get_tind : forall ir n, IRTindPtr (upd_len ir n) = IRTindPtr ir. Parameter upd_len_get_blk : forall ir n, IRBlocks (upd_len ir n) = IRBlocks ir. Parameter upd_len_get_iattr : forall ir n, IRAttrs (upd_len ir n) = IRAttrs ir. Parameter upd_irec_get_len : forall ir len ibptr dibptr tibptr dbns, goodSize addrlen len -> IRLen (upd_irec ir len ibptr dibptr tibptr dbns) = len. Parameter upd_irec_get_ind : forall ir len ibptr dibptr tibptr dbns, goodSize addrlen ibptr -> IRIndPtr (upd_irec ir len ibptr dibptr tibptr dbns) = ibptr. Parameter upd_irec_get_dind : forall ir len ibptr dibptr tibptr dbns, goodSize addrlen dibptr -> IRDindPtr (upd_irec ir len ibptr dibptr tibptr dbns) = dibptr. Parameter upd_irec_get_tind : forall ir len ibptr dibptr tibptr dbns, goodSize addrlen tibptr -> IRTindPtr (upd_irec ir len ibptr dibptr tibptr dbns) = tibptr. Parameter upd_irec_get_blk : forall ir len ibptr dibptr tibptr dbns, IRBlocks (upd_irec ir len ibptr dibptr tibptr dbns) = dbns. Parameter upd_irec_get_iattr : forall ir len ibptr dibptr tibptr dbns, IRAttrs (upd_irec ir len ibptr dibptr tibptr dbns) = IRAttrs ir. Parameter get_len_goodSize : forall ir, goodSize addrlen (IRLen ir). Parameter get_ind_goodSize : forall ir, goodSize addrlen (IRIndPtr ir). Parameter get_dind_goodSize : forall ir, goodSize addrlen (IRDindPtr ir). Parameter get_tind_goodSize : forall ir, goodSize addrlen (IRTindPtr ir).End BlockPtrSig.Module BlockPtr (BPtr : BlockPtrSig). Import BPtr. Definition indrectype := Rec.WordF addrlen. Module IndSig <: RASig. Definition xparams := addr. Definition RAStart := fun (x : xparams) => x. Definition RALen := fun (_ : xparams) => 1. Definition xparams_ok (_ : xparams) := True. Definition itemtype := indrectype. Definition items_per_val := valulen / (Rec.len itemtype). Theorem blocksz_ok : valulen = Rec.len (Rec.ArrayF itemtype items_per_val). 
?Z)%morphism = _] => transitivity (((F _a Y) ∘ (F _a X)) Z)%morphism; trivial end. auto. Qed.Next Obligation. Proof. symmetry; simpl. apply Y_right_to_left_NT_obligation_1. Qed. Program Definition Y_right_to_left (C : Category) : (Y_right C) --> (Y_left C) := {| Trans := fun c_F => fun h => Y_right_to_left_NT C (fst c_F) (snd c_F) h |}.Next Obligation. Proof. intros C [c f] [c' f'] [h N]. cbn in *. extensionality g; cbn. apply NatTrans_eq_simplify. extensionality d; extensionality g'; cbn. simpl_ids. match goal with [|- ?W = _] => match W with (?F _a ?X (?F _a ?Y ?Z))%morphism => change W with (((F _a X) ∘ (F _a Y)) Z)%morphism end end. rewrite <- F_compose; cbn. match goal with [|- ?W = _] => match W with ?X (?Y ?Z) => change W with ((X ∘ Y) Z)%morphism end end. rewrite <- Trans_com; cbn; trivial. Qed.Next Obligation. Proof. symmetry; simpl. apply Y_right_to_left_obligation_1. Qed. Program Definition Yoneda_Lemma (C : Category) : ((Y_left C) ≃ (Y_right C))%natiso := NatIso _ _ (Y_left_to_right C) (Y_right_to_left C) _ _.Next Obligation. Proof. intros C [c F]; FunExt; cbn in *. rewrite (F_id F). trivial. Qed.Next Obligation. simpl; intros C [c F]; FunExt. apply NatTrans_eq_simplify. FunExt. cbn in *. match goal with [|- ?W = _] => match W with ?X (?Y ?Z) => change W with ((X ∘ Y) Z)%morphism end end. rewrite <- Trans_com; cbn. auto. Qed. Lemma Yoneda_Faithful (C : Category) : Faithful_Func (Yoneda C). Proof. intros c c' f f' H. cbn in *. match type of H with ?X = ?Y => assert(H' : Trans X c id= Trans Y c id) end. + rewrite H; trivial. + cbn in H'. simpl_ids in H'. trivial. Qed. Lemma Yoneda_Full (C : Category) : Full_Func (Yoneda C). Proof. intros c c' N. exists (Trans (Y_left_to_right C) (c, (((Yoneda C) _o)%object c')) N). apply NatTrans_eq_simplify. extensionality x; extensionality h. transitivity ((((Yoneda C) _o c')%object _a h ∘ (Trans N c)) id)%morphism. + cbn; auto. + rewrite <- Trans_com. cbn; auto. Qed. Definition Yoneda_Emb (C : Category) : Embedding C (Func_Cat (C^op) Type_Cat) := {| Emb_Func := Yoneda C; Emb_Faithful := Yoneda_Faithful C; Emb_Full := Yoneda_Full C |}. Theorem Yoneda_Iso (C : Category) : forall (c c' : Obj), ((Yoneda C) _o c ≃ (Yoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism. Proof. intros. apply (Emb_Conservative _ _ (Yoneda_Emb C) _); trivial. Qed.Ltac Yoneda := apply Yoneda_Iso. Theorem CoYoneda_Iso (C : Category) : forall (c c' : Obj), ((CoYoneda C) _o c ≃ (CoYoneda C) _o c')%isomorphism → (c ≃ c')%isomorphism. 
Ltac ackerman m n := match m with | O => constr:(S n) | S ?m' => match n with | O => let res := ackerman m' 1 in constr:(res) | S ?n' => let tmp1 := ackerman m n' in let tmp2 := ackerman m' tmp1 in constr:(tmp2) end end. Theorem t : False. 
OK tt) | false => Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)), Err ELOGOVERFLOW) end | Err e => ms <- LOG.abort (FSXPLog fsxp) (MSLL ams'); Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)), Err e) end; t2 <- Rdtsc; Debug "delete" (t2-t1);; Ret res. Definition lookup fsxp dnum names ams := t1 <- Rdtsc ; ms <- LOG.begin (FSXPLog fsxp) (MSLL ams); let^ (ams, r) <- DIRTREE.namei fsxp dnum names (BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)); ms <- LOG.commit_ro (FSXPLog fsxp) (MSLL ams); r <- Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)), r); t2 <- Rdtsc ; Debug "lookup" (t2-t1) ;; Ret r. Definition rename fsxp dnum srcpath srcname dstpath dstname ams := t1 <- Rdtsc; ms <- LOG.begin (FSXPLog fsxp) (MSLL ams); let^ (ams', r) <- DIRTREE.rename fsxp dnum srcpath srcname dstpath dstname (BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)); res <- match r with | OK _ => let^ (ms, ok) <- LOG.commit (FSXPLog fsxp) (MSLL ams'); match ok with | true => Ret ^((BFILE.mk_memstate (MSAlloc ams') ms (MSAllocC ams') (MSIAllocC ams') (MSICache ams') (MSCache ams') (MSDBlocks ams')), OK tt) | false => Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)), Err ELOGOVERFLOW) end | Err e => ms <- LOG.abort (FSXPLog fsxp) (MSLL ams'); Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)), Err e) end; t2 <- Rdtsc; Debug "rename" (t2-t1);; Ret res. Definition tree_sync fsxp ams := t1 <- Rdtsc ; ams <- DIRTREE.sync fsxp ams; t2 <- Rdtsc ; Debug "tree_sync" (t2-t1) ;; Ret ^(ams). Definition tree_sync_noop fsxp ams := ams <- DIRTREE.sync_noop fsxp ams; Ret ^(ams). Definition umount fsxp ams := ams <- DIRTREE.sync fsxp ams; ms <- LOG.sync_cache (FSXPLog fsxp) (MSLL ams); Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams))). Definition statfs fsxp ams := ms <- LOG.begin (FSXPLog fsxp) (MSLL ams); ms <- LOG.commit_ro (FSXPLog fsxp) ms; Ret ^((BFILE.mk_memstate (MSAlloc ams) ms (MSAllocC ams) (MSIAllocC ams) (MSICache ams) (MSCache ams) (MSDBlocks ams)), 0, 0). Hint Extern 0 (okToUnify (LOG.rep_inner _ _ _ _) (LOG.rep_inner _ _ _ _)) => constructor : okToUnify. Theorem recover_ok : forall cachesize, {< fsxp cs ds, PRE:hm LOG.after_crash (FSXPLog fsxp) (SB.rep fsxp) ds cs hm * [[ cachesize <> 0 ]] POST:hm' RET:r exists ms fsxp', [[ fsxp' = fsxp ]] * [[ r = OK (ms, fsxp') ]] * exists d n sm, [[ n <= length (snd ds) ]] * LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn (d, nil)) (MSLL ms) sm hm' * [[ sm = sm_synced ]] * [[[ d ::: crash_xform (diskIs (list2nmem (nthd n ds))) ]]] * [[ BFILE.MSinitial ms ]] XCRASH:hm' LOG.before_crash (FSXPLog fsxp) (SB.rep fsxp) ds hm' >} recover cachesize. 
in "HΦ". iIntros. iModIntro. by iApply "HΦ". } iApply (wpc_Inode__Append inodeN allocN); [solve_ndisj|..]. iFrame "Hinode Hb Halloc". iSplit; [ | iSplit; [ | iSplit ] ]. - iApply reserve_fupd_Palloc. - iApply free_fupd_Palloc. - eauto. - iSplit. { iNext. iExists _; iSplit; eauto. } iIntros "!>" (σ σ' addr' -> Hwf s Hreserved) "(HPinode&>HPalloc)". iEval (rewrite /Palloc) in "HPalloc". iNamed "HPalloc". iNamed "HPinode". iDestruct (inode_used_lookup with "Hused1 Hused2") as %Heq. iInv "Hinv" as ([σ0]) "[>Hinner HP]" "Hclose". iNamed "Hinner". iMod (inode_used_update _ (union {[addr']} σ.(inode.addrs)) with "Hused1 Hused2") as "[Hγused Hused]". iDestruct (inode_blocks_lookup with "Hownblocks Hγblocks") as %Heq2. simplify_eq/=. iMod (inode_blocks_update _ (σ.(inode.blocks) ++ [b0]) with "Hownblocks Hγblocks") as "[Hownblocks Hγblocks]". iSpecialize ("Hfupd" $! {| dir.inodes := σ0 |}). rewrite Heq2. iMod fupd_mask_subseteq as "HcloseM"; last iMod ("Hfupd" with "[% //] [$HP]") as "[HP HQ]". { solve_ndisj. } iMod "HcloseM" as "_". simpl. iMod ("Hclose" with "[Hγblocks HP]") as "_". { iNext. iExists _. iFrame "HP". rewrite /dir_inv /=. iFrame. iPureIntro. intros idx' Hidx'. destruct (decide ((int.nat idx) = idx')) as [->|Hne]. - rewrite lookup_insert. eauto. - rewrite lookup_insert_ne //. apply Hdom. done. } iModIntro. iFrame. rewrite /Palloc. iSplitR "HQ". { iNext. iExists _. iFrame "Hused". iPureIntro. split. - rewrite map_size_insert_Some //. - rewrite alloc_used_insert. apply alloc_insert_dom; auto. } iSplit; eauto. Qed.End goose.From Perennial.goose_lang Require Import crash_modality recovery_lifting.Section crash_stable. Context `{!heapGS Σ}. Context `{!stagedG Σ}. Context `{!inG Σ blocksR}. Context `{!inG Σ allocsR}. Instance allocΨ_crash_stable k: IntoCrash (allocΨ k) (λ _, allocΨ k). Proof. rewrite /IntoCrash. iNamed 1. iCrash. iExists _; eauto. Qed. Instance Palloc_crash_stable γ σ: IntoCrash (Palloc γ σ) (λ _, Palloc γ σ). Proof. rewrite /IntoCrash. iApply post_crash_nodep. Qed. Instance Pinode_crash_stable γblocks γused i s_inode: IntoCrash (Pinode γblocks γused i s_inode) (λ _, Pinode γblocks γused i s_inode). Proof. rewrite /IntoCrash. iApply post_crash_nodep. Qed. Existing Instance inode_cinv_pre_post. Global Instance dir_cinv_crash sz σ0 : IntoCrash (dir_cinv sz σ0 false) (λ _, (|={⊤}=> dir_cinv sz σ0 true)%I). Proof. rewrite /IntoCrash /dir_cinv. iNamed 1. iNamed "Hinodes". rewrite (allocator_crash_cond_no_later_stable (λ _, Palloc γused)). rewrite /dir_inv. iNamed "Hs_inode". rewrite /inode_allblocks. iPoseProof (post_crash_nodep with "Hγblocks") as "Hγblocks". iCrash. iExists _, _. iMod (alloc_crash_cond_no_later_crash_true with "[] Halloc"). { iIntros (σ0'). rewrite /Palloc/named. rewrite used_revert_reserved. iIntros "H". eauto. } iModIntro. iFrame. iSplitL "Hinodes". { iExists _. iSplit; first eauto. iFrame. } eauto. Qed.End crash_stable.Section recov. Context `{!heapGS Σ}. Context `{!allocG Σ}. Context `{!stagedG Σ}. Context `{!inG Σ blocksR}. Context `{!inG Σ allocsR}. Set Nested Proofs Allowed. Theorem wpr_Open (d: ()) (sz: u64) σ0: (5 ≤ int.Z sz)%Z → dir_cinv (int.Z sz) σ0 true -∗ wpr NotStuck ⊤ (Open (disk_val d) #sz) (Open (disk_val d) #sz) (λ _, True%I) (λ _, True%I) (λ _ _, True%I). 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Import Ascii String.Derive (Arbitrary, Show) for ascii. Derive (Sized, CanonicalSized) for ascii. Derive SizeMonotonic for ascii using genSascii. Derive SizedMonotonic for ascii using genSascii. Derive SizedCorrect for ascii using genSascii and SizeMonotonicascii.Derive (Arbitrary, Show) for string. Derive (Sized, CanonicalSized) for string. Derive SizeMonotonic for string using genSstring. Derive SizedMonotonic for string. Derive SizedCorrect for string using genSstring and SizeMonotonicstring. Inductive id : Type := | Id : string -> id.Derive (Arbitrary, Show) for id. Derive (Sized, CanonicalSized) for id. Derive SizeMonotonic for id using genSid. Derive SizedMonotonic for id. Derive SizedCorrect for id using genSid and SizeMonotonicid.Instance eq_dec_id (x y : id) : Dec (x = y). constructor; unfold decidable. repeat decide equality. Defined.Definition beq_id x y := match x,y with | Id n1, Id n2 => if string_dec n1 n2 then true else false end.Theorem beq_id_refl : forall id, true = beq_id id id. Admitted. Theorem beq_id_true_iff : forall x y : id, beq_id x y = true <-> x = y. 
bufBit b => ∃ b0, data = [b0] ∧ get_bit b0 (word.modu (addrOff a) 8) = b | bufInode i => vec_to_list i = data | bufBlock b => vec_to_list b = data end. Theorem data_has_obj_to_buf_data s a obj data : data_has_obj data a obj → is_slice_small s u8T 1 data -∗ is_buf_data s (objData obj) a. Proof. rewrite /data_has_obj /is_buf_data. iIntros (?) "Hs". destruct (objData obj); subst. - destruct H as (b' & -> & <-). iExists b'; iFrame. auto. - iFrame. - iFrame. Qed. Theorem is_buf_data_has_obj s a obj : is_buf_data s (objData obj) a ⊣⊢ ∃ data, is_slice_small s u8T 1 data ∗ ⌜data_has_obj data a obj⌝. Proof. iSplit; intros. - rewrite /data_has_obj /is_buf_data. destruct (objData obj); subst; eauto. iDestruct 1 as (b') "[Hs %]". iExists [b']; iFrame. eauto. - iDestruct 1 as (data) "[Hs %]". iApply (data_has_obj_to_buf_data with "Hs"); auto. Qed. Lemma is_buf_data_rew K s a obj (H: objKind obj = K) : is_buf_data s (objData obj) a -∗ is_buf_data s (rew [bufDataT] H in objData obj) a. Proof. subst. reflexivity. Qed. Theorem wp_Op__OverWrite l γ dinit γtxn γdurable (a: addr) (sz: u64) (data_s: Slice.t) (data: list byte) obj0 obj : bufSz (objKind obj) = int.nat sz → data_has_obj data a obj → objKind obj = objKind obj0 → {{{ is_jrnl_mem N l γ dinit γtxn γdurable ∗ jrnl_maps_to γtxn a obj0 ∗ is_slice_small data_s byteT 1 data }}} Op__OverWrite #l (addr2val a) #sz (slice_val data_s) {{{ RET #(); is_jrnl_mem N l γ dinit γtxn γdurable ∗ jrnl_maps_to γtxn a obj }}}. Proof. iIntros (??? Φ) "Hpre HΦ". iDestruct "Hpre" as "(Hjrnl & Ha & Hdata)". iNamed "Hjrnl". iApply wp_fupd. iDestruct (map_valid with "Htxn_ctx Ha") as %Hlookup. fmap_Some in Hlookup as vo0. wp_apply (mspec.wp_Op__OverWrite _ _ _ _ _ _ (mspec.mkVersioned (objData (mspec.committed vo0)) (rew H1 in objData obj)) with "[$Hjrnl Hdata]"). { iSplit; eauto. iSplitL. - iApply data_has_obj_to_buf_data in "Hdata"; eauto. simpl. iApply (is_buf_data_rew with "Hdata"). - iPureIntro. simpl. destruct vo0 as [K0 [c0 m0]]; simpl in *; subst. split; [rewrite H; word|done]. } iIntros "Hjrnl". iMod (map_update _ _ obj with "Htxn_ctx Ha") as "[Htxn_ctx Ha]". iModIntro. iApply "HΦ". iFrame "Ha". iExists _, true; iFrame "Htxn_system Hjrnl". rewrite !fmap_insert !mspec.committed_mkVersioned !mspec.modified_mkVersioned /=. rewrite (insert_id (mspec.committed <$> mT)); last first. { rewrite lookup_fmap Hlookup //. } iFrame "#∗". iSplit. 2: eauto. iExactEq "Htxn_ctx". rewrite /named. f_equal. f_equal. destruct obj; simpl in *; subst; reflexivity. Qed. Theorem wp_Op__NDirty l γ dinit γtxn γdurable : {{{ is_jrnl_mem N l γ dinit γtxn γdurable }}} Op__NDirty #l {{{ (n:u64), RET #n; is_jrnl_mem N l γ dinit γtxn γdurable }}}. 
(imap pair program) -> WellFormed program. Proof. intros H ?? HStep; rewrite Forall_lookup in H; specialize (Step_implies_instr HStep) as [instr]; specialize (H cur.(counter) (cur.(counter), instr)); eapply H; eauto; apply index_pairs_lookup_forward; assumption. Qed. Definition check_instruction_well_formed len_program: forall index_instr, partial (InstWellFormed len_program index_instr.1 index_instr.2) . refine (fun index_instr => if (is_stopping index_instr.2) then proven else if (lt_dec (S index_instr.1) len_program) then proven else unknown ); destruct index_instr as [index instr]; simpl in *; intros ???? Hsome Hcounter HStep; subst; try apply (stopping_stuck s Hsome) in HStep; destruct instr; inversion HStep; try contradiction; simpl in *; subst; lia. Defined. Definition execute_program_unknown_termination (program: list Instruction) (well_formed: WellFormed program) : nat -> forall cur, Within program cur -> option MachineState . refine (fix go steps cur _ := let (instr, _) := (get_instr cur program) in if (is_stopping instr) then Some cur else match steps with | 0 => None | S steps' => let (next, _) := (@execute_instruction instr cur _) in go steps' next _ end ); eauto. Defined. Section execute_program. Variable program: list Instruction. Variable well_formed: WellFormed program. Variable progression: MachineState -> MachineState -> Prop. Variable progression_wf: well_founded progression. Variable progress: forall cur next, Step program cur next -> progression next cur. Program Fixpoint execute_program cur (H: Within program cur) {wf progression cur} : MachineState := let (instr, _) := (get_instr cur program) in if (is_stopping instr) then cur else let (next, _) := (@execute_instruction instr cur _) in execute_program next _ . Solve All Obligations with eauto. End execute_program.End Sized.Notation Within program cur := (cur.(counter) < (length program)) (only parsing).Notation WellFormed program := (forall cur next, Step program cur next -> Within program next) (only parsing).Notation InstWellFormed len_program := (fun index instr => forall program cur next, len_program <= (length program) -> lookup (index%nat) program = Some instr -> cur.(counter) = (index%nat) -> Step program cur next -> Within program next ) (only parsing).Notation IndexPairsWellFormed program := (fun index_instr => InstWellFormed (length program) index_instr.1 index_instr.2) (only parsing).Ltac program_well_formed := match goal with | |- WellFormed ?program => let program_type := type of program in match program_type with | list (@Instruction ?size) => apply index_pairs_InstWellFormed_implies_WellFormed; find_obligations__helper (IndexPairsWellFormed program) (@check_instruction_well_formed size (length program)) (imap pair program) end end. Module redundant_additions. Definition program: list (@Instruction 1) := [ InstMov (Literal 0) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstExit ]. Theorem well_formed: WellFormed program. 
apply Ptrofs.eqm_unsigned_repr_r. apply Ptrofs.eqm_mult. apply Ptrofs.eqm_unsigned_repr_r. apply Ptrofs.eqm_refl. apply Ptrofs.eqm_unsigned_repr_r. apply Ptrofs.eqm_refl. apply Ptrofs.eqm_unsigned_repr_r. apply Ptrofs.eqm_refl. } rewrite Z.mul_pred_l. apply Ptrofs.eqm_refl2. omega. Qed.Theorem repr_val_L_unchanged: forall v6 m L v7, repr_val_L_L6_L7 v6 m L v7 -> forall m', Mem.unchanged_on L m m' -> repr_val_L_L6_L7 v6 m' L v7. Proof. apply (repr_val_ind' (fun v m L v7 => forall m', Mem.unchanged_on L m m' -> repr_val_L_L6_L7 v m' L v7) (fun vs m L b i => forall m', Mem.unchanged_on L m m' -> repr_val_ptr_list_L_L6_L7 vs m' L b i)); intros; try (now econstructor; eauto). - specialize (H4 _ H5). econstructor; eauto. eapply Mem.load_unchanged_on; eauto. - econstructor; eauto. eapply Mem.load_unchanged_on; eauto. Qed.Theorem repr_val_id_L_unchanged: forall v6 m lenv L x, repr_val_id_L_L6_L7 v6 m L lenv x -> forall m', Mem.unchanged_on L m m' -> repr_val_id_L_L6_L7 v6 m' L lenv x. Proof. intros. inv H. - econstructor; eauto. eapply repr_val_L_unchanged; eauto. - econstructor 2; eauto. eapply repr_val_L_unchanged; eauto. Qed.Theorem repr_val_ptr_list_L_unchanged: forall vs m L b i, repr_val_ptr_list_L_L6_L7 vs m L b i -> forall m', Mem.unchanged_on L m m' -> repr_val_ptr_list_L_L6_L7 vs m' L b i. Proof. apply (repr_val_list_ind' (fun v m L v7 => forall m', Mem.unchanged_on L m m' -> repr_val_L_L6_L7 v m' L v7) (fun vs m L b i => forall m', Mem.unchanged_on L m m' -> repr_val_ptr_list_L_L6_L7 vs m' L b i)); intros; try (now econstructor; eauto). - specialize (H4 _ H5). econstructor; eauto. eapply Mem.load_unchanged_on; eauto. - econstructor; eauto. eapply Mem.load_unchanged_on; eauto. Qed.Corollary repr_val_ptr_list_L_Z_unchanged: forall vs m L b i, repr_val_ptr_list_L_L6_L7_Z vs m L b i -> forall m', Mem.unchanged_on L m m' -> repr_val_ptr_list_L_L6_L7_Z vs m' L b i. Proof. induction vs; intros. constructor. inv H. econstructor; eauto. eapply Mem.load_unchanged_on; eauto. eapply repr_val_L_unchanged; eauto. Qed.Theorem repr_val_L_sub_locProp: forall v6 m L v7, repr_val_L_L6_L7 v6 m L v7 -> forall L', sub_locProp L L' -> repr_val_L_L6_L7 v6 m L' v7. Proof. apply (repr_val_ind' (fun v6 m L v7 => forall L', sub_locProp L L' -> repr_val_L_L6_L7 v6 m L' v7) (fun vs m L b i => forall L', sub_locProp L L' -> repr_val_ptr_list_L_L6_L7 vs m L' b i)); intros; try (now econstructor; eauto). Qed.Theorem repr_val_id_L_sub_locProp: forall v6 m L x lenv, repr_val_id_L_L6_L7 v6 m L lenv x -> forall L', sub_locProp L L' -> repr_val_id_L_L6_L7 v6 m L' lenv x. Proof. intros. inv H. - econstructor; eauto. eapply repr_val_L_sub_locProp; eauto. - econstructor 2; eauto. eapply repr_val_L_sub_locProp; eauto. Qed. Theorem repr_val_ptr_list_L_sub_locProp: forall vs m L b i, repr_val_ptr_list_L_L6_L7 vs m L b i -> forall L', sub_locProp L L' -> repr_val_ptr_list_L_L6_L7 vs m L' b i. 
) ( forall x : X , P x -> Y ) := weqsecovertotal2 P _ .Definition weqfunfromdirprod ( X X' Y : UU ) : weq ( dirprod X X' -> Y ) ( forall x : X , X' -> Y ) := weqsecovertotal2 _ _ . Theorem impred (n:nat) { T : UU } (P:T -> UU): (forall t:T, isofhlevel n (P t)) -> (isofhlevel n (forall t:T, P t)). Proof. intro. induction n as [ | n IHn ] . intros T P X. apply (funcontr P X). intros T P X. unfold isofhlevel in X. unfold isofhlevel. intros x x' . assert (is: forall t:T, isofhlevel n (paths (x t) (x' t))). intro. apply (X t (x t) (x' t)). assert (is2: isofhlevel n (forall t:T, paths (x t) (x' t))). apply (IHn _ (fun t0:T => paths (x t0) (x' t0)) is). set (u:=toforallpaths P x x'). assert (is3:isweq u). apply isweqtoforallpaths. set (v:= invmap ( weqpair u is3) ). assert (is4: isweq v). apply isweqinvmap. apply (isofhlevelweqf n ( weqpair v is4 )). assumption. Defined.Corollary impredtwice (n:nat) { T T' : UU } (P:T -> T' -> UU): (forall (t:T)(t':T'), isofhlevel n (P t t')) -> (isofhlevel n (forall (t:T)(t':T'), P t t')). Proof. intros n T T' P X. assert (is1: forall t:T, isofhlevel n (forall t':T', P t t')). intro. apply (impred n _ (X t)). apply (impred n _ is1). Defined. Corollary impredfun (n:nat)(X Y:UU)(is: isofhlevel n Y) : isofhlevel n (X -> Y). Proof. intros. apply (impred n (fun x:_ => Y) (fun x:X => is)). Defined. Theorem impredtech1 (n:nat)(X Y: UU) : (X -> isofhlevel n Y) -> isofhlevel n (X -> Y). Proof. intro. induction n as [ | n IHn ] . intros X Y X0. simpl. split with (fun x:X => pr1 (X0 x)). intro t . assert (s1: forall x:X, paths (t x) (pr1 (X0 x))). intro. apply proofirrelevancecontr. apply (X0 x). apply funextsec. assumption. intros X Y X0. simpl. assert (X1: X -> isofhlevel (S n) (X -> Y)). intro X1 . apply impred. assumption. intros x x' . assert (s1: isofhlevel n (forall xx:X, paths (x xx) (x' xx))). apply impred. intro t . apply (X0 t). assert (w: weq (forall xx:X, paths (x xx) (x' xx)) (paths x x')). apply (weqfunextsec _ x x' ). apply (isofhlevelweqf n w s1). Defined. Theorem iscontrfuntounit ( X : UU ) : iscontr ( X -> unit ) . 
eauto using inj_pair2_eq_dec, eq_nat_dec). abstract (rewrite (shatter_word y); simpl; intro; injection H; auto). Defined.Fixpoint weqb sz (x : word sz) : word sz -> bool := match x in word sz return word sz -> bool with | WO => fun _ => true | WS b _ x' => fun y => if eqb b (whd y) then if @weqb _ x' (wtl y) then true else false else false end.Theorem weqb_true_iff : forall sz x y, @weqb sz x y = true <-> x = y. Proof. induction x; simpl; intros. { split; auto. } { rewrite (shatter_word y) in *. simpl in *. case_eq (eqb b (whd y)); intros. case_eq (weqb x (wtl y)); intros. split; auto; intros. rewrite eqb_true_iff in H. f_equal; eauto. eapply IHx; eauto. split; intros; try congruence. inversion H1; clear H1; subst. eapply inj_pair2_eq_dec in H4. eapply IHx in H4. congruence. eapply Peano_dec.eq_nat_dec. split; intros; try congruence. inversion H0. apply eqb_false_iff in H. congruence. } Qed.Fixpoint combine (sz1 : nat) (w : word sz1) : forall sz2, word sz2 -> word (sz1 + sz2) := match w in word sz1 return forall sz2, word sz2 -> word (sz1 + sz2) with | WO => fun _ w' => w' | WS b _ w' => fun _ w'' => WS b (combine w' w'') end.Fixpoint split1 (sz1 sz2 : nat) : word (sz1 + sz2) -> word sz1 := match sz1 with | O => fun _ => WO | S sz1' => fun w => WS (whd w) (split1 sz1' sz2 (wtl w)) end.Fixpoint split2 (sz1 sz2 : nat) : word (sz1 + sz2) -> word sz2 := match sz1 with | O => fun w => w | S sz1' => fun w => split2 sz1' sz2 (wtl w) end.Ltac shatterer := simpl; intuition; match goal with | [ w : _ |- _ ] => rewrite (shatter_word w); simpl end; f_equal; auto.Theorem combine_split : forall sz1 sz2 (w : word (sz1 + sz2)), combine (split1 sz1 sz2 w) (split2 sz1 sz2 w) = w. induction sz1; shatterer. Qed.Theorem split1_combine : forall sz1 sz2 (w : word sz1) (z : word sz2), split1 sz1 sz2 (combine w z) = w. induction sz1; shatterer. Qed.Theorem split2_combine : forall sz1 sz2 (w : word sz1) (z : word sz2), split2 sz1 sz2 (combine w z) = z. induction sz1; shatterer. Qed.Require Import Coq.Logic.Eqdep_dec. Theorem combine_assoc : forall n1 (w1 : word n1) n2 n3 (w2 : word n2) (w3 : word n3) Heq, combine (combine w1 w2) w3 = match Heq in _ = N return word N with | refl_equal => combine w1 (combine w2 w3) end. 
rewrite length_R1; auto with arith. exact H1. apply le_minus_minus. auto with arith. exact H0. exact H1. rewrite length_R1. auto with arith. exact H1. rewrite length_R1; auto with arith. exact H1. rewrite length_R2; auto with arith. exact H0. simpl in |- *. rewrite minus_Sn_m. auto with arith. auto with arith. exact H1. rewrite length_BV_full_adder_sum; auto with arith. unfold lt in |- *. rewrite length_R2. auto with arith. exact H1. transitivity size; auto with arith. rewrite length_BV_full_adder_sum; auto with arith. rewrite length_R2; auto with arith. rewrite length_R2; auto with arith. rewrite length_R1; auto with arith. rewrite (length_app bool). rewrite (length_strip bool). rewrite length_R1; auto with arith. rewrite length_abit. rewrite plus_comm. simpl in |- *. rewrite minus_Sn_m. simpl in |- *. elim minus_n_O. apply minus_le_lem2. auto with arith. rewrite length_BV_full_adder_sum; auto with arith. rewrite length_R2; auto with arith. rewrite length_R2; auto with arith. rewrite length_R1; auto with arith. replace (length V1) with (lengthbv V1); auto with arith. rewrite length_V1_size. exact H1. exact H1. Qed. Lemma Invariant : forall t : nat, t <= size -> BV_to_nat (appbv (stripbv (R1 t) (size - t)) (R2 t)) = BV_to_nat V2 * BV_to_nat (truncbv V1 t).simple induction t. intros. elim minus_n_O. apply Invariant_t_O. intros. rewrite <- (app_trunc_elemlist bool). replace (elemlist bool V1 n) with (abit V1 n). rewrite <- (R1_lem3 n). rewrite R1_eq2. rewrite R2_eq2. rewrite <- lowbit_is_abit. case (lowbit (R1 n)). replace (consbv (lowbit (BV_full_adder_sum (R2 n) V2 false)) nilbv) with (abit (BV_full_adder_sum (R2 n) V2 false) 0). apply inv_ind_true. auto with arith. intros. apply H. exact H1. exact H0. apply le_Sn_le; exact H0. unfold abit in |- *. rewrite lowbit_is_trunc. unfold elemlist in |- *. rewrite (strip_O bool). trivial with arith. apply (not_nil bool). rewrite length_BV_full_adder_sum. rewrite length_R2. exact size_not_O. apply le_Sn_le; exact H0. rewrite length_R2. rewrite length_V2_size. trivial with arith. apply le_Sn_le; exact H0. replace (consbv (lowbit (BV_full_adder_sum (R2 n) V2 false)) nilbv) with (abit (BV_full_adder_sum (R2 n) V2 false) 0). apply inv_ind_false. trivial with arith. exact H. exact H0. apply le_Sn_le; exact H0. rewrite lowbit_is_trunc. unfold abit in |- *. unfold elemlist in |- *. rewrite (strip_O bool). trivial with arith. apply (not_nil bool). rewrite length_BV_full_adder_sum. rewrite length_R2; auto with arith. transitivity size. rewrite length_R2; trivial with arith. apply le_Sn_le; exact H0. auto with arith. apply (not_nil bool). rewrite length_R1; auto with arith. auto with arith. auto with arith. replace (length V1) with (lengthbv V1). rewrite length_V1_size. exact H0. auto with arith.Qed. Theorem Correct : BV_to_nat (appbv (R1 size) (R2 size)) = BV_to_nat V2 * BV_to_nat V1.intros. 
(snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros. apply elements_canonical_order'. intros. destruct (get i m) as [x|] eqn:GM. exploit H; eauto. intros (y & P & Q). rewrite P; constructor; auto. destruct (get i n) as [y|] eqn:GN. exploit H0; eauto. intros (x & P & Q). congruence. constructor. Qed. Theorem elements_extensional: forall (A: Type) (m n: t A), (forall i, get i m = get i n) -> elements m = elements n. Proof. intros. exploit (@elements_canonical_order' _ _ (fun (x y: A) => x = y) m n). intros. rewrite H. destruct (get i n); constructor; auto. induction 1. auto. destruct a1 as [a2 a3]; destruct b1 as [b2 b3]; simpl in *. destruct H0. congruence. Qed. Lemma xelements_remove: forall (A: Type) v (m: t A) i j, get i m = Some v -> exists l1 l2, xelements m j nil = l1 ++ (prev (prev_append i j), v) :: l2 /\ xelements (remove i m) j nil = l1 ++ l2. Proof. induction m; intros. - rewrite gleaf in H; discriminate. - assert (REMOVE: xelements (remove i (Node m1 o m2)) j nil = xelements (match i with | xH => Node m1 None m2 | xO ii => Node (remove ii m1) o m2 | xI ii => Node m1 o (remove ii m2) end) j nil). { destruct i; simpl remove. destruct m1; auto. destruct o; auto. destruct (remove i m2); auto. destruct o; auto. destruct m2; auto. destruct (remove i m1); auto. destruct m1; auto. destruct m2; auto. } rewrite REMOVE. destruct i; simpl in H. + destruct (IHm2 i (xI j) H) as (l1 & l2 & EQ & EQ'). exists (xelements m1 (xO j) nil ++ match o with None => nil | Some x => (prev j, x) :: nil end ++ l1); exists l2; split. rewrite xelements_node, EQ, ! app_ass. auto. rewrite xelements_node, EQ', ! app_ass. auto. + destruct (IHm1 i (xO j) H) as (l1 & l2 & EQ & EQ'). exists l1; exists (l2 ++ match o with None => nil | Some x => (prev j, x) :: nil end ++ xelements m2 (xI j) nil); split. rewrite xelements_node, EQ, ! app_ass. auto. rewrite xelements_node, EQ', ! app_ass. auto. + subst o. exists (xelements m1 (xO j) nil); exists (xelements m2 (xI j) nil); split. rewrite xelements_node. rewrite prev_append_prev. auto. rewrite xelements_node; auto. Qed. Theorem elements_remove: forall (A: Type) i v (m: t A), get i m = Some v -> exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2. 
Require Import Coq.Classes.RelationClasses.Set Implicit Arguments. Set Strict Implicit.Fixpoint guard A (R : A -> A -> Prop) (n : nat) (wfR : well_founded R) {struct n}: well_founded R := match n with | 0 => wfR | S n => fun x => Acc_intro x (fun y _ => guard n (guard n wfR) y) end.Section setoid_fix. Variables (A : Type) (R : A -> A -> Prop) (Rwf : well_founded R). Variables (P : A -> Type) (F : forall x : A, (forall y : A, R y x -> P y) -> P x). Variable r : forall x : A, P x -> P x -> Prop. Hypothesis Hstep : forall (x : A) (f g : forall y : A, R y x -> P y), (forall (y : A) (p : R y x), r (f y p) (g y p)) -> r (@F x f) (@F x g). Lemma Fix_F_equiv_inv : forall (x : A) (r' s' : Acc R x), r (Fix_F _ F r') (Fix_F _ F s'). Proof. intro x; induction (Rwf x); intros. rewrite <- (Fix_F_eq _ F r'); rewrite <- (Fix_F_eq _ F s'); intros. eapply Hstep. eauto. Qed. Theorem Fix_equiv : forall x : A, r (Fix Rwf P F x) (@F x (fun (y : A) (_ : R y x) => Fix Rwf P F y)). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.Crypto. Require Import FCF.Asymptotic.Theorem evalDist_bool_support : forall (c : Comp bool)(ls : list bool), well_formed_comp c -> ls = getSupport c -> sumList ls (evalDist c) == evalDist c false + evalDist c true. intuition. specialize (support_NoDup c); intuition. rewrite <- H0 in H1. destruct ls; intuition. specialize (getSupport_length_nz H); intuition. rewrite <- H0 in H2. simpl in *. omega. destruct b. destruct ls. unfold sumList; simpl. eapply ratAdd_eqRat_compat. symmetry. eapply getSupport_not_In_evalDist. intuition. rewrite <- H0 in H2. simpl in *. intuition. intuition. destruct b. inversion H1; clear H1; subst. simpl in *. intuition. destruct ls. unfold sumList. simpl. rewrite <- ratAdd_0_l. eapply ratAdd_comm. destruct b. inversion H1; clear H1; subst. simpl in *. intuition. inversion H1; clear H1; subst. simpl in *. intuition. inversion H5; clear H5; subst. simpl in *; intuition. destruct ls. unfold sumList; simpl. rewrite ratAdd_comm. eapply ratAdd_eqRat_compat. intuition. symmetry. eapply getSupport_not_In_evalDist. intuition. rewrite <- H0 in H2. simpl in *. intuition. destruct b. destruct ls. unfold sumList. simpl. rewrite <- ratAdd_0_l. intuition. destruct b. inversion H1; clear H1; subst. simpl in *. intuition. inversion H5; clear H5; subst. simpl in *; intuition. inversion H1; clear H1; subst. simpl in *; intuition. inversion H1; clear H1; subst. simpl in *; intuition. Qed. Theorem evalDist_bool_complement : forall (c : Comp bool), well_formed_comp c -> evalDist c false == ratSubtract 1 (evalDist c true). 
^(ms, None) | Some ifs => Ret ^(ms, Some ifs) end } Rof ^(ms, None); Ret ^(ms, ret). Local Hint Resolve items_per_val_not_0 items_per_val_gt_0 items_per_val_gt_0'. Lemma items_valid_updN : forall xp items a v, items_valid xp items -> Rec.well_formed v -> items_valid xp (updN items a v). Proof. unfold items_valid; intuition. rewrite length_updN; auto. apply Forall_wellformed_updN; auto. Qed. Lemma items_valid_upd_range : forall xp items len a v, items_valid xp items -> Rec.well_formed v -> items_valid xp (upd_range items a len v). Proof. induction len; simpl; intros; auto using items_valid_updN. Qed. Lemma ifind_length_ok : forall xp i items, i < RALen xp -> items_valid xp items -> i < length (synced_list (ipack items)). Proof. unfold items_valid; intuition. eapply synced_list_ipack_length_ok; eauto. Qed. Lemma items_valid_length_eq : forall xp a b, items_valid xp a -> items_valid xp b -> length (ipack a) = length (ipack b). Proof. unfold items_valid; intuition. eapply ipack_length_eq; eauto. Qed. Theorem get_ok : forall lxp xp ix ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ ix < length items ]] * [[[ m ::: Fm * rep xp items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[ r = selN items ix item0 ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} get lxp xp ix ms. Proof. unfold get, rep. safestep. rewrite synced_list_length, ipack_length. apply div_lt_divup; auto. safestep. subst; rewrite synced_list_selN; simpl. erewrite selN_val2block_equiv. apply ipack_selN_divmod; auto. apply list_chunk_wellformed; auto. unfold items_valid in *; intuition; auto. apply Nat.mod_upper_bound; auto. Qed. Theorem put_ok : forall lxp xp ix e ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ ix < length items /\ Rec.well_formed e ]] * [[[ m ::: Fm * rep xp items ]]] POST:hm' RET:ms' exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms' sm hm' * [[[ m' ::: Fm * rep xp (updN items ix e) ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} put lxp xp ix e ms. Proof. unfold put, rep. hoare; subst. rewrite synced_list_length, ipack_length; apply div_lt_divup; auto. rewrite synced_list_length, ipack_length; apply div_lt_divup; auto. unfold items_valid in *; intuition auto. apply arrayN_unify. rewrite synced_list_selN, synced_list_updN; f_equal; simpl. rewrite block2val_updN_val2block_equiv. apply ipack_updN_divmod; auto. apply list_chunk_wellformed. unfold items_valid in *; intuition; auto. apply Nat.mod_upper_bound; auto. apply items_valid_updN; auto. Qed. Theorem read_ok : forall lxp xp nblocks ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ nblocks <= RALen xp ]] * [[[ m ::: Fm * rep xp items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[ r = firstn (nblocks * items_per_val) items ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} read lxp xp nblocks ms. 
(Hx vec_zero); rew vec. intros H; apply H, sem_k; auto. Qed. Let Sig0_zero A : In A Sig0 -> [[ [iA] ]] vec_zero. Proof. unfold Sig0. intros [ H | H ]; subst. apply sem_k_k_k. apply in_app_or in H. destruct H as [ H | H ]; apply in_map_iff in H. destruct H as ((i & j) & H1 & H2); subst. apply sem_x_y_y; simpl. apply pos_not_diag_spec in H2; auto. destruct H as (y & H1 & _); subst. apply sem_y_y_y. Qed. Let SigI_zero A : In A SigI -> [[ [iA] ]] vec_zero. Proof. unfold SigI. destruct P as (i & lP). intros H. apply mm_linstr_enc_spec in H. destruct H as [ (j & x & H1 & H2) | (j & x & p & H1 & [ H2 | H2 ]) ]; subst A. simpl; unfold ll_tps_imp. intros v Hv. rewrite vec_plus_comm, vec_zero_plus. apply H_s_q. apply mm_compute_INC with (1 := H1). specialize (Hv (vec_one x)). replace (vec_change v x (S (vec_pos v x))) with (vec_plus (vec_one x) v). apply H_s_q. apply Hv. apply H_s_rx; split. apply vec_pos_ext. intros p; rewrite vec_pos_plus. destruct (pos_eq_dec x p). subst; rewrite vec_one_spec_eq, vec_change_eq; auto. rewrite vec_one_spec_neq, vec_change_neq; auto. simpl; unfold ll_tps_imp. intros v (Hv1 & Hv2). rewrite vec_plus_comm, vec_zero_plus. apply H_s_q. rewrite H_s_ry in Hv1. apply mm_compute_DEC_0 with (1 := H1); auto. apply H_s_q; auto. simpl; unfold ll_tps_imp. intros v Hv w Hw. rewrite (vec_plus_comm v), vec_zero_plus. apply H_s_q. apply H_s_rx in Hv. rewrite vec_plus_comm. assert (exists u, vec_pos (vec_plus v w) x = S u) as Hu. exists (vec_pos w x). rewrite vec_pos_plus; subst. rewrite vec_one_spec_eq; auto. destruct Hu as (u & Hu). apply mm_compute_DEC_S with (1 := H1) (u := vec_pos w x); auto. rewrite vec_pos_plus; subst. rewrite vec_one_spec_eq; auto. apply H_s_q. eq goal Hw; f_equal. apply vec_pos_ext. intros r. destruct (pos_eq_dec x r). subst; rewrite vec_change_eq; auto. rewrite vec_change_neq, vec_pos_plus; auto. subst; rewrite vec_one_spec_neq; auto. Qed. Lemma Sig_zero A : In A Sig -> [[ [i A] ]] vec_zero. Proof. intros H; apply in_app_or in H; destruct H. apply Sig0_zero; auto. apply SigI_zero; auto. Qed. Corollary ll_tps_Sig_zero : ll_tps_list s (map (fun c => ❗[i c]) Sig) vec_zero. Proof. generalize Sig Sig_zero; intros S. induction S as [ | A S IHS ]; intros HS. simpl; auto. simpl; exists vec_zero, vec_zero; repeat split; auto. rew vec. apply HS; left; auto. apply IHS; intros; apply HS; right; auto. Qed. Theorem lemma_5_5 v i : Sig; vec_map_list v rx ⊦ q i -> P // (i,v) ->> (k,vec_zero). 
1 - 1)%Z. apply Rle_refl. apply bpow_lt. apply Zlt_succ. apply bpow_ge_0. apply Rgt_not_eq, Rlt_gt, bpow_gt_0. Qed. Lemma generic_format_ulp_0: F (ulp 0). Proof. unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros _; apply generic_format_0. intros n H1. apply generic_format_bpow. now apply valid_exp. Qed.Lemma generic_format_bpow_ge_ulp_0: forall e, (ulp 0 <= bpow e)%R -> F (bpow e). Proof. intros e; unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros H1 _. apply generic_format_bpow. specialize (H1 (e+1)%Z); omega. intros n H1 H2. apply generic_format_bpow. case (Zle_or_lt (e+1) (fexp (e+1))); intros H4. absurd (e+1 <= e)%Z. omega. apply Zle_trans with (1:=H4). replace (fexp (e+1)) with (fexp n). now apply le_bpow with beta. now apply fexp_negligible_exp_eq. omega. Qed.Lemma generic_format_ulp: Exp_not_FTZ fexp -> forall x, F (ulp x). Proof. unfold Exp_not_FTZ; intros H x. case (Req_dec x 0); intros Hx. rewrite Hx; apply generic_format_ulp_0. rewrite (ulp_neq_0 _ Hx). apply generic_format_bpow; unfold canonic_exp. apply H. Qed.Lemma not_FTZ_generic_format_ulp: (forall x, F (ulp x)) -> Exp_not_FTZ fexp. intros H e. specialize (H (bpow (e-1))). rewrite ulp_neq_0 in H. 2: apply Rgt_not_eq, bpow_gt_0. unfold canonic_exp in H. rewrite ln_beta_bpow in H. apply generic_format_bpow_inv' in H... now replace (e-1+1)%Z with e in H by ring. Qed. Lemma ulp_ge_ulp_0: Exp_not_FTZ fexp -> forall x, (ulp 0 <= ulp x)%R. Proof. unfold Exp_not_FTZ; intros H x. case (Req_dec x 0); intros Hx. rewrite Hx; now right. unfold ulp at 1. rewrite Req_bool_true; trivial. case negligible_exp_spec'. intros (H1,H2); rewrite H1; apply ulp_ge_0. intros (n,(H1,H2)); rewrite H1. rewrite ulp_neq_0; trivial. apply bpow_le; unfold canonic_exp. generalize (ln_beta beta x); intros l. case (Zle_or_lt l (fexp l)); intros Hl. rewrite (fexp_negligible_exp_eq n l); trivial; apply Zle_refl. case (Zle_or_lt (fexp n) (fexp l)); trivial; intros K. absurd (fexp n <= fexp l)%Z. omega. apply Zle_trans with (2:= H _). apply Zeq_le, sym_eq, valid_exp; trivial. omega. Qed.Lemma not_FTZ_ulp_ge_ulp_0: (forall x, (ulp 0 <= ulp x)%R) -> Exp_not_FTZ fexp. Proof. intros H e. apply generic_format_bpow_inv' with beta. apply generic_format_bpow_ge_ulp_0. replace e with ((e-1)+1)%Z by ring. rewrite <- ulp_bpow. apply H. Qed.Theorem ulp_le_pos : forall { Hm : Monotone_exp fexp }, forall x y: R, (0 <= x)%R -> (x <= y)%R -> (ulp x <= ulp y)%R. Proof with auto with typeclass_instances. intros Hm x y Hx Hxy. destruct Hx as [Hx|Hx]. rewrite ulp_neq_0. rewrite ulp_neq_0. apply bpow_le. apply Hm. now apply ln_beta_le. apply Rgt_not_eq, Rlt_gt. now apply Rlt_le_trans with (1:=Hx). now apply Rgt_not_eq. rewrite <- Hx. apply ulp_ge_ulp_0. apply monotone_exp_not_FTZ... Qed. Theorem ulp_le : forall { Hm : Monotone_exp fexp }, forall x y: R, (Rabs x <= Rabs y)%R -> (ulp x <= ulp y)%R. 
Require Import Arith.From Undecidability.Shared.Libs.DLW Require Import utils_tac utils_nat utils_decidable pos vec.From Undecidability.MuRec.Util Require Import recalg ra_utils.Set Implicit Arguments.Local Notation "'⟦' f '⟧'" := (@ra_rel _ f) (at level 0).Section ra_min_extra. Variable (n : nat) (f : recalg (S n)) (v : vec nat n). Hypothesis Hf : forall x, ex (⟦f⟧ (x##v)). Theorem ra_min_extra : ex (⟦ra_min f⟧ v) <-> exists x, ⟦f⟧ (x##v) 0. Proof using Hf. split. + intros (x & H1 & H2); exists x; auto. + intros (x & Hx). destruct bounded_min_d with (P := fun x => ⟦f⟧ (x##v) 0) (Q := fun x => exists k, ⟦f⟧ (x##v) (S k)) (n := S x) as [ (m & H1 & H2 & H3) | H1 ]; auto. * intros y _; destruct (Hf y) as ([ | k ] & Hk); auto. right; exists k; auto. * exists m; split; auto. * destruct (H1 _ (le_refl _)) as (k & Hk). generalize (ra_rel_fun _ _ _ _ Hx Hk); discriminate. Qed.End ra_min_extra.Section ra_min_extra'. Variable (n : nat) (f : recalg (S n)) (v : vec nat n). Hypothesis Hf : forall x, ⟦f⟧ (x##v) 0 \/ ⟦f⟧ (x##v) 1. Theorem ra_min_ex : ex (⟦ra_min f⟧ v) <-> exists x, ⟦f⟧ (x##v) 0. 
Hab Hba bang_le_refl bang_U_clos : core. Notation "£ A" := (@imsell_var _ _ A) (at level 1). Notation "‼ l" := (@imsell_lban nat sig l). Notation "‼∞" := (map (fun A => ![∞]A)). Local Definition formA : imsell_form nat sig := ![a](£0). Local Definition formB : imsell_form nat sig := ![b](£1). Local Definition var2pc p : imsell_form nat sig := £ (2+p). Notation α := formA. Notation β := formB. Notation "⌊ p ⌋" := (var2pc p) (format "⌊ p ⌋"). Local Definition bool2form (x : bool) := if x then α else β. Local Definition bool2bang_op (x : bool) := if x then b else a. Notation STOPₙ := (@ndmm2_stop _). Notation INCₙ := (@ndmm2_inc _). Notation DECₙ := (@ndmm2_dec _). Notation ZEROₙ := (@ndmm2_zero _). Definition ndmm2_imsell_form c := match c with | STOPₙ p => (⌊p⌋ ⊸ ⌊p⌋) ⊸ ⌊p⌋ | INCₙ x p q => (bool2form x ⊸ ⌊q⌋) ⊸ ⌊p⌋ | DECₙ x p q => bool2form x ⊸ ⌊q⌋ ⊸ ⌊p⌋ | ZEROₙ x p q => (![bool2bang_op x]⌊q⌋) ⊸ ⌊p⌋ end. Notation "⟬ c ⟭" := (ndmm2_imsell_form c) (at level 1, format "⟬ c ⟭"). Definition ndmm2_imsell_ctx Σ x y := ‼∞ (map (fun c => ⟬c⟭) Σ) ++ repeat α x ++ repeat β y. Notation "⟬ Σ , x , y ⟭" := (ndmm2_imsell_ctx Σ x y) (at level 1, format "⟬ Σ , x , y ⟭"). Fact ndmm2_imsell_eq1 Σ : map (fun c => ![∞]⟬c⟭) Σ = ‼(map (fun c => (∞,⟬c⟭)) Σ). Proof. unfold imsell_lban; rewrite map_map; auto. Qed. Fact ndmm2_imsell_eq2 Σ x y : ⟬Σ,x,y⟭ = ‼(map (fun c => (∞,⟬c⟭)) Σ ++ repeat (a,£0) x ++ repeat (b,£1) y). Proof. unfold ndmm2_imsell_ctx. rewrite map_map, ndmm2_imsell_eq1. unfold imsell_lban; rewrite !map_app, !map_map; f_equal. induction x; simpl; f_equal; auto. induction y; simpl; f_equal; auto. Qed. Fact ndmm2_imsell_perm1 Σ x y : ⟬Σ,1+x,y⟭ ~p α::⟬Σ,x,y⟭ . Proof. unfold ndmm2_imsell_ctx. apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _). rewrite !app_ass; apply Permutation_app; auto. simpl; apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _). now rewrite app_ass. Qed. Fact ndmm2_imsell_perm2 Σ x y : ⟬Σ,x,1+y⟭ ~p β::⟬Σ,x,y⟭ . Proof. unfold ndmm2_imsell_ctx. apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _). rewrite !app_ass; repeat apply Permutation_app; auto. simpl; apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _); auto. Qed. Notation "Γ ⊢ A" := (S_imsell bang_le U Γ A) (at level 70). Theorem ndmm2_imsell_weak c Σ x y A : c ∊ Σ -> ⟬Σ,x,y⟭ ⊢ A <-> ![∞]⟬c⟭ :: ⟬Σ,x,y⟭ ++ nil ⊢ A. 
Require Export Ensembles. Require Export Constructive_sets. Require Export Relations_1. Require Export Relations_1_facts. Require Export Partial_Order. Require Export Cpo. Require Export Powerset.Section Sets_as_an_algebra. Variable U : Type. Theorem Empty_set_zero : forall X:Ensemble U, Union U (Empty_set U) X = X. Proof. auto 6 with sets. Qed. Theorem Empty_set_zero_right : forall X:Ensemble U, Union U X (Empty_set U) = X. Proof. auto 6 with sets. Qed. Theorem Empty_set_zero' : forall x:U, Add U (Empty_set U) x = Singleton U x. Proof. unfold Add at 1; auto using Empty_set_zero with sets. Qed. Lemma less_than_empty : forall X:Ensemble U, Included U X (Empty_set U) -> X = Empty_set U. Proof. auto with sets. Qed. Theorem Union_commutative : forall A B:Ensemble U, Union U A B = Union U B A. Proof. auto with sets. Qed. Theorem Union_associative : forall A B C:Ensemble U, Union U (Union U A B) C = Union U A (Union U B C). Proof. auto 9 with sets. Qed. Theorem Union_idempotent : forall A:Ensemble U, Union U A A = A. Proof. auto 7 with sets. Qed. Lemma Union_absorbs : forall A B:Ensemble U, Included U B A -> Union U A B = A. Proof. auto 7 with sets. Qed. Theorem Couple_as_union : forall x y:U, Union U (Singleton U x) (Singleton U y) = Couple U x y. Proof. intros x y; apply Extensionality_Ensembles; split; red. intros x0 H'; elim H'; (intros x1 H'0; elim H'0; auto with sets). intros x0 H'; elim H'; auto with sets. Qed. Theorem Triple_as_union : forall x y z:U, Union U (Union U (Singleton U x) (Singleton U y)) (Singleton U z) = Triple U x y z. Proof. intros x y z; apply Extensionality_Ensembles; split; red. intros x0 H'; elim H'. intros x1 H'0; elim H'0; (intros x2 H'1; elim H'1; auto with sets). intros x1 H'0; elim H'0; auto with sets. intros x0 H'; elim H'; auto with sets. Qed. Theorem Triple_as_Couple : forall x y:U, Couple U x y = Triple U x x y. Proof. intros x y. rewrite <- (Couple_as_union x y). rewrite <- (Union_idempotent (Singleton U x)). apply Triple_as_union. Qed. Theorem Triple_as_Couple_Singleton : forall x y z:U, Triple U x y z = Union U (Couple U x y) (Singleton U z). Proof. intros x y z. rewrite <- (Triple_as_union x y z). rewrite <- (Couple_as_union x y); auto with sets. Qed. Theorem Intersection_commutative : forall A B:Ensemble U, Intersection U A B = Intersection U B A. 
intro X1 . apply impred. assumption. intros x x' . assert (s1: isofhlevel n (forall xx:X, paths (x xx) (x' xx))). apply impred. intro t . apply (X0 t). assert (w: weq (forall xx:X, paths (x xx) (x' xx)) (paths x x')). apply (weqfunextsec _ x x' ). apply (isofhlevelweqf n w s1). Defined. Theorem iscontrfuntounit ( X : UU ) : iscontr ( X -> unit ) . Proof . intro . split with ( fun x : X => tt ) . intro f . apply funextfun . intro x . destruct ( f x ) . apply idpath . Defined .Theorem iscontrfuntocontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : iscontr ( X -> Y ) . Proof . intros . set ( w := weqcontrtounit is ) . set ( w' := weqffun X w ) . apply ( iscontrweqb w' ( iscontrfuntounit X ) ) . Defined . Lemma isapropimpl ( X Y : UU ) ( isy : isaprop Y ) : isaprop ( X -> Y ) . Proof. intros. apply impred. intro. assumption. Defined. Theorem isapropneg2 ( X : UU ) { Y : UU } ( is : neg Y ) : isaprop ( X -> Y ) . Proof . intros . apply impred . intro . apply ( isapropifnegtrue is ) . Defined . Theorem iscontriscontr { X : UU } ( is : iscontr X ) : iscontr ( iscontr X ). Proof. intros X X0 . assert (is0: forall (x x':X), paths x x'). apply proofirrelevancecontr. assumption.assert (is1: forall cntr:X, iscontr (forall x:X, paths x cntr)). intro. assert (is2: forall x:X, iscontr (paths x cntr)). assert (is2: isaprop X). apply isapropifcontr. assumption. unfold isaprop in is2. unfold isofhlevel in is2. intro x . apply (is2 x cntr). apply funcontr. assumption. set (f:= @pr1 X (fun cntr:X => forall x:X, paths x cntr)). assert (X1:isweq f). apply isweqpr1. assumption. change (total2 (fun cntr : X => forall x : X, paths x cntr)) with (iscontr X) in X1. apply (iscontrweqb ( weqpair f X1 ) ) . assumption. Defined. Theorem isapropiscontr (T:UU): isaprop (iscontr T). Proof. intros. unfold isaprop. unfold isofhlevel. intros x x' . assert (is: iscontr(iscontr T)). apply iscontriscontr. apply x. assert (is2: isaprop (iscontr T)). apply ( isapropifcontr is ) . apply (is2 x x'). Defined. Theorem isapropisweq { X Y : UU } (f:X-> Y) : isaprop (isweq f). 
a (pluspf p (pX b q)). unfold pX in |- *; intros a b p q s H'; inversion_clear H'; intros. change (pX a l3 = pX a (pluspf p (pX b q))) in |- *; apply pX_inj; auto. apply uniq_plusp with (l := (p, pX b q)); simpl in |- *; auto. absurd (eqT b a); auto. apply eqT_sym; auto. absurd (eqT b a); auto. apply eqT_sym; auto. absurd (ltT ltM b a); auto. Qed. Theorem plusP_inv2 : forall a b p q s, plusP (pX a p) (pX b q) s -> ltT ltM a b -> s = pX b (pluspf (pX a p) q). intros a b p q s H'; inversion_clear H'; intros. absurd (ltT ltM a b); auto. absurd (ltT ltM a b); auto. absurd (ltT ltM a b); auto. apply pX_inj; auto. apply uniq_plusp with (l := (pX a p, q)); simpl in |- *; auto. Qed. Theorem plusP_inv3a : forall a b p q s, eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> plusP (pX a p) (pX b q) s -> s = pluspf p q. intros a b p q s Eqd Z0 H'; inversion_clear H'; intros. absurd (eqT b a); auto. apply eqT_sym; auto. apply uniq_plusp with (l := (p, q)); auto. elim H1; auto. absurd (eqT a b); auto. Qed. Theorem plusP_inv3b : forall a b p q s, eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> plusP (pX a p) (pX b q) s -> s = pX (plusTerm (A:=A) plusA (n:=n) a b) (pluspf p q). unfold pX in |- *; intros a b p q s Eqd Z0 H'; inversion_clear H'; intros. absurd (eqT b a); auto. apply eqT_sym; auto. elim Z0; try assumption. change (pX (plusTerm (A:=A) plusA (n:=n) a b) l3 = pX (plusTerm (A:=A) plusA (n:=n) a b) (pluspf p q)) in |- *. apply pX_inj; auto. apply uniq_plusp with (l := (p, q)); auto. absurd (eqT a b); auto. Qed. Theorem pluspf_inv1 : forall a b p q, ltT ltM b a -> eqP A eqA n (pX a (pluspf p (pX b q))) (pluspf (pX a p) (pX b q)). intros a b p q H'; try assumption. rewrite (plusP_inv1 a b p q (pluspf (pX a p) (pX b q))); auto. Qed. Theorem pluspf_inv2 : forall a b p q, ltT ltM a b -> eqP A eqA n (pX b (pluspf (pX a p) q)) (pluspf (pX a p) (pX b q)). 
ω, m ⋸ n → n ∈ m → False. Proof with eauto. intros m Hm n Hn Hle Hgt. destruct Hle. - eapply nat_not_lt_gt; revgoals... - eapply nat_not_lt_self; revgoals... Qed.Lemma ω_not_dense : ∀m ∈ ω, ¬∃n ∈ ω, m ∈ n ∧ n ∈ m⁺. Proof with eauto. intros m Hm [n [Hn [Hmn Hnm]]]. apply BUnionE in Hnm as [Hnm|Heq]. - eapply nat_not_lt_gt; revgoals... - apply SingE in Heq. eapply nat_not_lt_self; revgoals... Qed.Lemma suc_has_0 : ∀n ∈ ω, 0 ∈ n⁺. Proof with nauto. intros n Hn. ω_induction n... apply le_iff_lt_suc... apply ω_inductive... Qed. Lemma nat_neq_suc : ∀n ∈ ω, n  n⁺. Proof. intros n Hn. pose proof (suc_has_n n). intros Heq. rewrite <- Heq in H at 1. apply (nat_irrefl n); auto. Qed. Corollary nat_and_its_single_disjoint : ∀n ∈ ω, disjoint n {n,}. Proof. intros n Hn. apply disjointI. intros [m [Hm Heq]]. apply SingE in Heq; subst. eapply nat_irrefl; eauto. Qed. Definition Lt := MemberRel ω.Lemma fld_Lt : fld Lt = ω. Proof with neauto. ext n Hn. - apply BUnionE in Hn as []. + eapply dom_binRel in H... apply binRel_is_binRel. + eapply ran_binRel in H... apply binRel_is_binRel. - apply BUnionI1. eapply domI. apply (binRelI _ _ _ Hn n⁺)... apply ω_inductive... Qed.Lemma Lt_trans : tranr Lt. Proof with eauto. intros m n p H1 H2. apply binRelE2 in H1 as [Hm [Hn Hmn]]. apply binRelE2 in H2 as [_ [Hp Hnp]]. apply SepI. apply CPrdI... zfc_simple. eapply nat_trans... Qed.Lemma Lt_irrefl : irrefl Lt. Proof with eauto. intros k Hp. apply SepE in Hp as [Hp Hlt]. apply CPrdE2 in Hp as [Hk _]. zfc_simple. eapply nat_irrefl... Qed.Lemma Lt_connected : connected Lt ω. Proof with nauto. intros n Hn. ω_induction n; intros k Hk Hnq. + assert (k   ) by congruence. apply pred_exists in H as [p [Hp Heq]]... left. subst. apply SepI; zfc_simple. apply CPrdI... apply suc_has_0... + ω_destruct k. * right. apply SepI; zfc_simple. apply CPrdI... apply ω_inductive... apply suc_has_0... * assert (m  k) by congruence. apply IH in H as []... left. apply binRelE3 in H. apply SepI; zfc_simple. apply CPrdI... apply ω_inductive... rewrite <- (suc_preserve_lt m Hm k)... right. apply binRelE3 in H. apply SepI; zfc_simple. apply CPrdI... apply ω_inductive... rewrite <- (suc_preserve_lt k Hp m Hm)... Qed.Lemma Lt_trich : trich Lt ω. Proof with auto. eapply trich_iff. apply memberRel_is_binRel. apply Lt_trans. split. apply Lt_irrefl. apply Lt_connected. Qed. Theorem Lt_linearOrder : linearOrder Lt ω. 
subst. apply functional_extensionality; intro s. destruct (sname_valid_dec s). replace s with (wname2sname (sname2wname s)). rewrite <- H7. rewrite <- H4. auto. eapply cond_inv_domain_right with (f' := sname2wname); eauto. eapply cond_inv_domain_right with (f' := sname2wname); eauto. eapply cond_inv_rewrite_right; eauto. assert (notindomain s m1). destruct (indomain_dec s m1); eauto. apply H5 in i; congruence. assert (notindomain s m2). destruct (indomain_dec s m2); eauto. apply H2 in i; congruence. congruence. Qed. Local Hint Unfold rep rep_macro DIR.rep_macro: hoare_unfold. Notation MSLL := BFILE.MSLL. Notation MSAlloc := BFILE.MSAlloc. Notation MSCache := BFILE.MSCache. Notation MSAllocC := BFILE.MSAllocC. Notation MSICache := BFILE.MSICache. Notation MSIAllocC := BFILE.MSIAllocC. Notation MSDBlocks := BFILE.MSDBlocks. Theorem lookup_ok : forall lxp bxp ixp dnum name ms, {< F Fm Fi m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms',r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms' sm * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * ( [[ r = None /\ notindomain name dmap ]] \/ exists inum isdir Fd, [[ r = Some (inum, isdir) /\ inum <> 0 /\ (Fd * name |-> (inum, isdir))%pred dmap ]]) CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} lookup lxp ixp dnum name ms. Proof. unfold lookup. hoare. or_l; cancel. resolve_valid_preds. eapply mem_atrans_inv_notindomain; eauto. or_r; cancel. resolve_valid_preds. eapply mem_atrans_inv_ptsto; eauto. or_l; cancel. resolve_valid_preds; auto. apply notindomain_not_indomain; auto. Qed. Definition readent := (string * (addr * bool))%type. Definition readmatch (de: readent) : @pred _ (string_dec) _ := fst de |-> snd de. Lemma readdir_trans_addr_ok : forall l m1 m2 (LP : listpred DIR.readmatch l m1) (MT : mem_atrans wname2sname m1 m2 wname_valid) (OK : forall w, indomain w m1 -> wname_valid w) (OK2 : forall s, indomain s m2 -> sname_valid s), listpred readmatch (List.map readdir_trans l) m2. Proof. induction l; simpl; intros. eapply mem_atrans_emp; eauto. unfold readmatch at 1, readdir_trans at 1; simpl. apply mem_except_ptsto; auto. eapply mem_atrans_indomain; eauto. eapply sep_star_ptsto_indomain; eauto. eapply ptsto_valid; eauto. apply sep_star_ptsto_indomain in LP as Hx. eapply ptsto_mem_except in LP. eapply IHl; eauto. apply OK in Hx. eapply mem_atrans_mem_except; eauto. intros; apply OK. eapply indomain_mem_except_indomain; eauto. intros; apply OK2. eapply indomain_mem_except_indomain; eauto. Qed. Theorem readdir_ok : forall lxp bxp ixp dnum ms, {< F Fm Fi m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms' sm * [[ listpred readmatch r dmap ]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} readdir lxp ixp dnum ms. 
nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Admitted. Instance testSuchThat_Disj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, prop a b)} `{Checkable (forall b, Q b -> forall a, prop a b)} : Checkable (forall a b, P a \/ Q b -> prop a b) := {| checker f := disjoin (Datatypes.cons (checker (fun a P b => f a b _ )) (Datatypes.cons (checker (fun b Q a => f a b _)) Datatypes.nil)) |}. Proof. - left; auto. - right; auto. Defined. Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Admitted. Lemma or_intro : forall A B : Prop, A -> A \/ B. Admitted. Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Admitted. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Admitted. Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Admitted. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Admitted. Theorem contradiction_implies_anything : forall P Q : Prop, (P /\ ~P) -> Q. Admitted. Theorem contrapositive : forall (P Q : Prop), (P -> Q) -> (~Q -> ~P). Admitted. Theorem not_both_true_and_false : forall P : Prop, ~ (P /\ ~P). Admitted. Theorem not_true_is_false : forall b : bool, b <> true -> b = false. Admitted. Theorem not_true_is_false' : forall b : bool, b <> true -> b = false. Admitted. Theorem iff_sym : forall P Q : Prop, (P <-> Q) -> (Q <-> P). Admitted. Lemma not_true_iff_false : forall b, b <> true <-> b = false. Admitted. Theorem iff_refl : forall P : Prop, P <-> P. Admitted. Theorem iff_trans : forall P Q R : Prop, (P <-> Q) -> (Q <-> R) -> (P <-> R). Admitted. Theorem or_distributes_over_and : forall P Q R : Prop, P \/ (Q /\ R) <-> (P \/ Q) /\ (P \/ R). 
x l0 d). break_match; subst; simpl in *. rewrite app_nil_r. break_match. * specialize (H0 o o0 d0). repeat concludes. apply exported_snoc_IO; congruence. * apply exported_snoc_IU; auto. + intros. apply H. intuition. + intros. subst. eapply (H0 _ (ys ++ [x])). rewrite app_ass. simpl. eauto. eauto. eauto. eauto. Qed. Lemma exported_execute_log : forall env_i env_o l, (forall e, In e l -> env_i (eClient e, eId e) = Some (eInput e)) -> (forall xs ys e tr' st' o o0 st'', l = xs ++ e :: ys -> execute_log xs = (tr', st') -> handler (eInput e) st' = (o, st'') -> env_o (eClient e, eId e) = Some o0 -> o = o0) -> exported env_i env_o (log_to_IR env_o l) (fst (execute_log l)). Proof using. intros. unfold execute_log. change (log_to_IR env_o l) with (log_to_IR env_o ([] ++ l)). eapply exported_execute_log'; eauto. Qed. Definition input_correct (tr : list (name * (raft_input + list raft_output))) : Prop := (forall client id i i' h h', In (h, inl (ClientRequest client id i)) tr -> In (h', inl (ClientRequest client id i')) tr -> i = i'). Lemma in_input_trace_get_input : forall tr e, input_correct tr -> in_input_trace (eClient e) (eId e) (eInput e) tr -> get_input tr (eClient e, eId e) = Some (eInput e). Proof using. unfold in_input_trace, input_correct. induction tr; intros; break_exists; simpl in *; intuition; subst; repeat break_match; intuition; subst; eauto 10 using f_equal. Qed. Lemma get_output_in_output_trace : forall tr client id o, get_output tr (client, id) = Some o -> in_output_trace client id o tr. Proof using. intros. induction tr; simpl in *; try congruence. repeat break_let. subst. repeat break_match; simpl in *; intuition; subst; try solve [unfold in_output_trace in *;break_exists_exists; intuition]. find_inversion. find_apply_lem_hyp get_output'_In. repeat eexists; eauto; in_crush. Qed. Lemma deduplicate_partition : forall l xs e ys xs' e' ys', deduplicate_log l = xs ++ e :: ys -> deduplicate_log l = xs' ++ e' :: ys' -> eClient e = eClient e' -> eId e = eId e' -> xs = xs'. Proof using. intros. eapply NoDup_map_partition. - apply NoDup_deduplicate_log. - eauto. - eauto. - simpl. congruence. Qed. Lemma applied_entries_applied_implies_input_state : forall net e, In e (applied_entries (nwState net)) -> applied_implies_input_state (eClient e) (eId e) (eInput e) net. Proof using. intros. red. exists e. intuition. - red. auto. - unfold applied_entries in *. break_match. + find_apply_lem_hyp in_rev. find_apply_lem_hyp removeAfterIndex_in. eauto. + simpl in *. intuition. Qed. Theorem raft_linearizable' : forall failed net tr, input_correct tr -> step_failure_star step_failure_init (failed, net) tr -> exists l tr1 st, equivalent _ (import tr) l /\ exported (get_input tr) (get_output tr) l tr1 /\ step_1_star init st tr1. 
possible_crash_list_cons : forall vsl vl v vs, possible_crash_list vsl vl -> In v (vsmerge vs) -> possible_crash_list (vs :: vsl) (v :: vl). Proof. unfold possible_crash_list; intuition. simpl; omega. destruct i, vs, vsl; firstorder. Qed.Theorem possible_crash_list_vssync : forall l l' a, possible_crash_list (vssync l a) l' -> possible_crash_list l l'. Proof. unfold possible_crash_list, vssync; intuition; rewrite length_updN in *; auto. specialize (H1 _ H). destruct (addr_eq_dec i a); subst. erewrite selN_updN_eq in H1 by auto; simpl in *. intuition. erewrite selN_updN_ne in H1 by auto; eauto. Qed.Section ArrayCrashXform. Notation pts := (@ptsto addr addr_eq_dec valuset). Lemma crash_xform_arrayN: forall l st, crash_xform (arrayN pts st l) =p=> exists l', [[ possible_crash_list l l' ]] * arrayN pts st (synced_list l'). Proof. unfold possible_crash_list. induction l; simpl; intros. cancel. instantiate (1 := nil). simpl; auto. auto. xform. rewrite IHl. cancel; [ instantiate (1 := v' :: l') | .. ]; simpl; auto; try cancel; destruct i; simpl; auto; destruct (H4 i); try omega; simpl; auto. Qed. Lemma crash_xform_arrayN_r: forall l l' st, possible_crash_list l' l -> arrayN pts st (synced_list l) =p=> crash_xform (arrayN pts st l'). Proof. unfold possible_crash_list. induction l; simpl; intros; auto. - intuition; destruct l'; simpl in *; try congruence. apply crash_invariant_emp_r. - intuition; destruct l'; simpl in *; try congruence. pose proof (H1 0) as H1'. simpl in H1'. rewrite IHl. rewrite crash_xform_sep_star_dist. rewrite <- crash_xform_ptsto_r with (v := a) by (apply H1'; omega). apply pimpl_refl. intuition. specialize (H1 (S i)). simpl in H1. apply H1. omega. Qed. Lemma crash_xform_synced_arrayN: forall l st, Forall (fun x => snd x = nil) l -> crash_xform (arrayN pts st l) =p=> arrayN pts st l. Proof. induction l; simpl; auto; intros. xform. rewrite IHl. cancel; subst. inversion H; simpl in *; subst; auto. inversion H; simpl in *; subst. inversion H1. eapply Forall_cons2; eauto. Qed. Lemma crash_xform_arrayN_combine_nils: forall (l : list valu) st, crash_xform (arrayN pts st (List.combine l (repeat nil (length l)))) =p=> arrayN pts st (List.combine l (repeat nil (length l))). Proof. intros. apply crash_xform_synced_arrayN. rewrite Forall_forall; intros. induction l; simpl in *. inversion H. inversion H; subst; simpl; auto. Qed. Lemma crash_xform_arrayN_synced: forall (l : list valu) st, crash_xform (arrayN pts st (synced_list l)) =p=> arrayN pts st (List.combine l (repeat nil (length l))). Proof. intros. apply crash_xform_synced_arrayN. rewrite Forall_forall; intros. induction l; simpl in *. inversion H. inversion H; subst; simpl; auto. Qed.End ArrayCrashXform.Section SubsetArray. Theorem sync_invariant_arrayN_subset : forall vs a, sync_invariant (arrayN ptsto_subset a vs). 
Require Import Coq.Logic.Classical_Prop. Require Import Coq.Relations.Operators_Properties. Require Import Coq.Relations.Relation_Operators. Require Import Main.Experiments.Overtree.Overtree. Require Import Main.Tactics.Module OvertreeTheorems (Graph : Overtree). Import Graph. #[local] Arguments clos_refl_trans {A} _ _ _. #[local] Arguments clos_refl_trans_1n {A} _ _ _. #[local] Arguments clos_refl_trans_n1 {A} _ _ _. #[local] Hint Constructors clos_refl_trans : main. #[local] Hint Constructors clos_refl_trans_1n : main. #[local] Hint Constructors clos_refl_trans_n1 : main. #[local] Hint Resolve clos_rt1n_rt : main. #[local] Hint Resolve clos_rt_rt1n : main. #[local] Hint Resolve clos_rtn1_rt : main. #[local] Hint Resolve clos_rt_rtn1 : main. Theorem rootUniquelyReachable : forall n, verticallyReachable n root -> n = root. Proof. clean. assert (clos_refl_trans_n1 proxies n root); magic. pose proof rootProxy. induction H0; magic. assert (y = z); magic. Qed. #[export] Hint Resolve rootUniquelyReachable : main. Theorem rootProxyUniqueness : forall n, proxy n = n -> n = root. Proof. clean. induction (rootReach n); magic. Qed. #[export] Hint Resolve rootProxyUniqueness : main. Theorem rootReachUniqueness : forall n1, (forall n2, verticallyReachable n1 n2) -> n1 = root. Proof. magic. Qed. #[export] Hint Resolve rootReachUniqueness : main. Definition reachable := clos_refl_trans edge. #[export] Hint Unfold reachable : main. Theorem horizontalSoundness : forall n1 n2, horizontallyReachable n1 n2 -> reachable n1 n2. Proof. clean. induction H; magic. apply rt_trans with (y := y); magic. Qed. #[export] Hint Resolve horizontalSoundness : main. Theorem horizontalCovalency : forall n1 n2, horizontallyReachable n1 n2 -> proxy n1 = proxy n2. Proof. clean. induction H; magic. Qed. #[export] Hint Resolve horizontalCovalency : main. Theorem proxyUniqueness : forall n1 n2 n3, proxies n1 n3 -> proxies n2 n3 -> n1 = n2. 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.PRF. Require Import hmacfcf.splitVector. Require Import hmacfcf.cAU. Require Import FCF.CompFold. Require Import FCF.DetSem FCF.SemEquiv.Local Open Scope list_scope.Section hF. Variable b k c : nat. Variable h : Bvector c -> Bvector b -> Bvector c. Variable F : Bvector k -> list (Bvector b) -> Bvector b. Definition hF key m := [k_Out, k_In] <-2 splitVector c k key; h k_Out (F k_In m). Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Hypothesis A_wf : well_formed_oc A. Definition G0 := k_in <-$ {0, 1}^k; k_out <-$ {0, 1}^c; [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Definition G1 := k_in <-$ {0, 1}^k; [b, _] <-$2 A _ _ (fun (s : list (Bvector b * Bvector c)) m => randomFunc ({0, 1}^c) _ s (F k_in m)) nil; ret b. Definition G2 := [b, _] <-$2 A _ _ (fun (s : list (list (Bvector b) * Bvector c)) m => randomFunc ({0, 1}^c) _ s m) nil; ret b. Definition G0_1 := [k_out, k_in] <-$2 ( key <-$ {0, 1}^(c + k); ret splitVector c k key); [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Theorem G0_1_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1]. unfold PRF_G_A, G0_1. inline_first. comp_skip. unfold f_oracle, hF. remember (splitVector c k x) as z. comp_simp. reflexivity. Qed. Theorem G0_1_G0_equiv : Pr[G0_1] == Pr[G0]. unfold G0_1, G0. eapply eqRat_trans. eapply evalDist_seq_eq. eapply Rnd_split_equiv. intros. eapply eqRat_refl. inline_first. comp_swap_r. comp_skip. inline_first. comp_skip. Qed. Theorem G0_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0]. 
List.In (xO i, v) (xelements (Node m1 o m2) xH) -> List.In (i, v) (xelements m1 xH). Proof. destruct o; simpl; intros; destruct (in_app_or _ _ _ H). apply xelements_oo; auto. destruct (in_inv H0). congruence. absurd (List.In (xO i, v) (xelements m2 3)); auto; apply xelements_oi; auto. apply xelements_oo; auto. absurd (List.In (xO i, v) (xelements m2 3)); auto; apply xelements_oi; auto. Qed. Lemma xelements_hi : forall (m: t A) (i : key) (v: A), ~List.In (xH, v) (xelements m (xI i)). Proof. induction m; intros. simpl; auto. destruct o; simpl; intro H; destruct (in_app_or _ _ _ H). generalize H0; apply IHm1; auto. destruct (in_inv H0). congruence. generalize H1; apply IHm2; auto. generalize H0; apply IHm1; auto. generalize H0; apply IHm2; auto. Qed. Lemma xelements_ho : forall (m: t A) (i : key) (v: A), ~List.In (xH, v) (xelements m (xO i)). Proof. induction m; intros. simpl; auto. destruct o; simpl; intro H; destruct (in_app_or _ _ _ H). generalize H0; apply IHm1; auto. destruct (in_inv H0). congruence. generalize H1; apply IHm2; auto. generalize H0; apply IHm1; auto. generalize H0; apply IHm2; auto. Qed. Lemma find_xfind_h : forall (m: t A) (i: key), find i m = xfind i xH m. Proof. destruct i; simpl; auto. Qed. Lemma xelements_complete: forall (i j : key) (m: t A) (v: A), List.In (i, v) (xelements m j) -> xfind i j m = Some v. Proof. induction i; simpl; intros; destruct j; simpl. apply IHi; apply xelements_ii; auto. absurd (List.In (xI i, v) (xelements m (xO j))); auto; apply xelements_io. destruct m. simpl in H; tauto. rewrite find_xfind_h. apply IHi. apply (xelements_ih _ _ _ _ _ H). absurd (List.In (xO i, v) (xelements m (xI j))); auto; apply xelements_oi. apply IHi; apply xelements_oo; auto. destruct m. simpl in H; tauto. rewrite find_xfind_h. apply IHi. apply (xelements_oh _ _ _ _ _ H). absurd (List.In (xH, v) (xelements m (xI j))); auto; apply xelements_hi. absurd (List.In (xH, v) (xelements m (xO j))); auto; apply xelements_ho. destruct m. simpl in H; tauto. destruct o; simpl in H; destruct (in_app_or _ _ _ H). absurd (List.In (xH, v) (xelements m1 (xO xH))); auto; apply xelements_ho. destruct (in_inv H0). congruence. absurd (List.In (xH, v) (xelements m2 (xI xH))); auto; apply xelements_hi. absurd (List.In (xH, v) (xelements m1 (xO xH))); auto; apply xelements_ho. absurd (List.In (xH, v) (xelements m2 (xI xH))); auto; apply xelements_hi. Qed. Theorem elements_complete: forall (m: t A) (i: key) (v: A), List.In (i, v) (elements m) -> find i m = Some v. 
Require Import Mem. Require Import Prog. Require Import List. Require Import Array. Require Import Pred. Require Import FunctionalExtensionality. Require Import Word. Require Import WordAuto. Require Import Omega. Require Import Ring. Require Import SepAuto. Require Import ListPred. Require Import AsyncDisk. Require Import ListUtils.Set Implicit Arguments. Definition list2mem (A: Type) (l: list A) : @mem addr addr_eq_dec A := fun a => selN (map (@Some A) l) a None.Theorem list2mem_ptsto_bounds: forall A F (l: list A) i x, (F * i |-> x)%pred (list2mem l) -> wordToNat i < length l. Proof. intros. unfold list2mem in H. apply ptsto_valid' in H. destruct (lt_dec (wordToNat i) (length l)); auto. unfold sel in H. rewrite nth_selN_eq in H. rewrite nth_overflow in H by (rewrite map_length; omega); discriminate. Qed. Theorem list2mem_oob : forall A (l : list A) i, wordToNat i >= length l -> (list2mem l) i = None. Proof. unfold list2mem; intros. unfold sel; rewrite selN_oob; auto. rewrite map_length; auto. Qed. Theorem list2mem_inbound: forall A F (l : list A) i x, (F * i |-> x)%pred (list2mem l) -> wordToNat i < length l. Proof. intros. destruct (lt_dec (wordToNat i) (length l)); auto; exfalso. apply not_lt in n. apply list2mem_oob in n. apply ptsto_valid' in H. rewrite H in n. inversion n. Qed. Theorem list2mem_sel: forall A F (l: list A) i x def, (F * i |-> x)%pred (list2mem l) -> x = sel l i def. Proof. intros. assert (wordToNat i < length l). eapply list2mem_inbound; eauto. unfold list2mem in H. apply ptsto_valid' in H. erewrite sel_map in H by auto. inversion H; eauto. Qed. Lemma listupd_memupd: forall A l i (v : A), wordToNat i < length l -> list2mem (upd l i v) = Mem.upd (list2mem l) i v. Proof. intros. apply functional_extensionality; intro. unfold list2mem, sel, upd, Mem.upd. autorewrite with core. destruct (weq x i). subst; erewrite selN_updN_eq; auto. rewrite map_length; auto. erewrite selN_updN_ne; auto. word2nat_simpl; omega. Qed.Theorem list2mem_upd: forall A F (l: list A) i x y, (F * i |-> x)%pred (list2mem l) -> (F * i |-> y)%pred (list2mem (upd l i y)). Proof. intros. rewrite listupd_memupd; auto. apply sep_star_comm. apply sep_star_comm in H. eapply ptsto_upd; eauto. eapply list2mem_inbound; eauto. Qed. Theorem listapp_memupd: forall A l (a : A) (b : addr), length l <= wordToNat b -> list2mem (l ++ a :: nil) = Mem.upd (list2mem l) $ (length l) a. 
in |- *; auto with arith. intros; elim H0; auto with arith. Qed. Hint Resolve lexfg_env_t.Theorem lexfg_env_s : forall (a : terms) (s s' : sub_explicits), e_lexfg _ (e_P1 ws) (e_P2 ws) s s' -> e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a s'). Proof. unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith. intros; elim H0; auto with arith. Qed. Hint Resolve lexfg_env_s.Theorem lexfg_cons_t : forall (a a' : terms) (s : sub_explicits), e_lexfg _ (e_P1 wt) (e_P2 wt) a a' -> e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a' s). Proof. unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith. intros; elim H0; auto with arith. Qed. Hint Resolve lexfg_cons_t.Theorem lexfg_cons_s : forall (a : terms) (s s' : sub_explicits), e_lexfg _ (e_P1 ws) (e_P2 ws) s s' -> e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a s'). Proof. unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith. intros; elim H0; auto with arith. Qed. Hint Resolve lexfg_cons_s.Theorem lexfg_comp_l : forall s s' t : sub_explicits, e_lexfg _ (e_P1 ws) (e_P2 ws) s s' -> e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s' t). Proof. unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith. intros; elim H0; auto with arith. Qed. Hint Resolve lexfg_comp_l.Theorem lexfg_comp_r : forall s t t' : sub_explicits, e_lexfg _ (e_P1 ws) (e_P2 ws) t t' -> e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s t'). Proof. unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith. intros; elim H0; auto with arith. Qed. Hint Resolve lexfg_comp_r.Theorem lexfg_lift : forall s s' : sub_explicits, e_lexfg _ (e_P1 ws) (e_P2 ws) s s' -> e_lexfg _ (e_P1 ws) (e_P2 ws) (lift s) (lift s'). Proof. unfold e_lexfg in |- *; simple induction 1; simpl in |- *; intros. auto with arith. elim H0; intros; right; split. assumption. change (4 * e_P2 _ s > 4 * e_P2 _ s') in |- *. auto with arith. Qed. Hint Resolve lexfg_lift.Theorem lexfg_relSL : forall (b : wsort) (M N : TS b), e_relSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N. Proof. simple induction 1; auto with arith. Qed. Theorem relSL_noetherian : forall b : wsort, explicit_noetherian _ (e_relSL b). 
unfold ForAll in |- *; intros. split; [ apply H | apply H0 ]; assumption. Qed. Theorem Conj_T : forall (Sini : S) (P1 P2 : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P1 bound -> ForAll_T Sini P2 bound -> ForAll_T Sini (fun s : S => P1 s /\ P2 s) bound. Proof. unfold ForAll_T in |- *; intros. split; [ apply (H s t) | apply (H0 s t) ]; assumption. Qed. Theorem Mon_I_EX : forall (Sini : S) (Pg Pp : S -> Prop), Exists Sini Pg -> (forall s : S, Pg s -> Pp s) -> Exists Sini Pp. Proof. intros. inversion_clear H. apply (exists_ H1 (H0 s H2)). Qed. Theorem Mon_I_EX_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), Exists_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> Exists_T Sini Pp bound. Proof. intros. inversion_clear H. apply (exists_T H1 H2 (H0 s H3)). Qed. Lemma RState_Trans : forall s1 s2 s3 : S, RState s1 s2 -> RState s2 s3 -> RState s1 s3. Proof. intros. elim H0; [ assumption | intros ]. apply (rsNext H2 H3). Qed. Lemma RState_Trans_T : forall (s1 s2 s3 : S) (t1 t2 : Instant), RState_T s1 s2 t1 -> RState_T s2 s3 t2 -> RState_T s1 s3 (plus_Ck t1 t2). Proof. simple induction 2; unfold plus_Ck in |- *; intros. rewrite (plus_comm t1 time0); unfold time0 in |- *; simpl in |- *; assumption. unfold Inc in |- *; unfold plus_Ck in |- *; rewrite (plus_assoc t1 t tick). apply (rsTime_T H2 H3). apply (rsNoTime_T H2 H3 H4). Qed. Theorem StepsEX : forall (s1 s2 : S) (P : S -> Prop), RState s1 s2 -> Exists s2 P -> Exists s1 P. Proof. intros. inversion H0. apply (exists_ (RState_Trans H H1) H2). Qed. Require Import Classical. Theorem ForAll_EX : forall (Sini : S) (P : S -> Prop), ForAll Sini P <-> ~ Exists Sini (fun s : S => ~ P s). Proof. unfold not in |- *; unfold ForAll in |- *; red in |- *; intros; split; intros. inversion H0. apply (H2 (H s H1)). elim (classic (P s)); [ trivial | intro; absurd (Exists Sini (fun s : S => P s -> False)) ]. assumption. apply exists_ with (1 := H0); assumption. Qed. Theorem ForAll_EX_T : forall (Sini : S) (P : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P bound <-> ~ Exists_T Sini (fun s : S => ~ P s) bound. 
com . Admitted.Theorem pup_to_2_ceval : pup_to_n / (t_update empty_state X 2) \\ t_update (t_update (t_update (t_update (t_update (t_update empty_state X 2) Y 0) Y 2) X 1) Y 3) X 0. Proof. Admitted.Theorem ceval_deterministic: forall c st st1 st2, c / st \\ st1 -> c / st \\ st2 -> st1 = st2. Proof. intros c st st1 st2 E1 E2. generalize dependent st2. induction E1; intros st2 E2; inversion E2; subst. - reflexivity. - reflexivity. - assert (st' = st'0) as EQ1. { apply IHE1_1; assumption. } subst st'0. apply IHE1_2. assumption. - apply IHE1. assumption. - rewrite H in H5. inversion H5. - rewrite H in H5. inversion H5. - apply IHE1. assumption. - reflexivity. - rewrite H in H2. inversion H2. - rewrite H in H4. inversion H4. - assert (st' = st'0) as EQ1. { apply IHE1_1; assumption. } subst st'0. apply IHE1_2. assumption. Qed. Theorem plus2_spec : forall st n st', st X = n -> plus2 / st \\ st' -> st' X = n + 2. Proof. intros st n st' HX Heval. inversion Heval. subst. clear Heval. simpl. apply t_update_eq. Qed. Theorem loop_never_stops : forall st st', ~(loop / st \\ st'). Proof. intros st st' contra. unfold loop in contra. remember (WHILE BTrue DO SKIP END) as loopdef eqn:Heqloopdef. Admitted.Fixpoint no_whiles (c : com) : bool := match c with | SKIP => true | _ ::= _ => true | c1 ;; c2 => andb (no_whiles c1) (no_whiles c2) | IFB _ THEN ct ELSE cf FI => andb (no_whiles ct) (no_whiles cf) | WHILE _ DO _ END => false end.Inductive no_whilesR: com -> Prop := .Theorem no_whiles_eqv: forall c, no_whiles c = true <-> no_whilesR c. Proof. Admitted.Inductive sinstr : Type := | SPush : nat -> sinstr | SLoad : id -> sinstr | SPlus : sinstr | SMinus : sinstr | SMult : sinstr.Fixpoint s_execute (st : state) (stack : list nat) (prog : list sinstr) : list nat . Admitted.Example s_execute1 : s_execute empty_state [] [SPush 5; SPush 3; SPush 1; SMinus] = [2; 5]. Admitted.Example s_execute2 : s_execute (t_update empty_state X 3) [3;4] [SPush 4; SLoad X; SMult; SPlus] = [15; 4]. Admitted.Fixpoint s_compile (e : aexp) : list sinstr . Admitted.Example s_compile1 : s_compile (AMinus (AId X) (AMult (ANum 2) (AId Y))) = [SLoad X; SPush 2; SLoad Y; SMult; SMinus]. Admitted. Theorem s_compile_correct : forall (st : state) (e : aexp), s_execute st [] (s_compile e) = [ aeval st e ]. 
x y -> rB (f x) (f y)) -> proper (fun x => f x). Proof. intros. split; auto; eapply H. Qed. Ltac prove_proper x k := match x with | _ => match goal with | [ H : proper x |- _ ] => k H end | bind ?A ?B => prove_proper A ltac:(fun a => prove_proper B ltac:(fun b => let H := fresh in assert (H : proper x); [ eapply bind_proper; eauto with typeclass_instances | k H ])) | ret ?A => prove_proper A ltac:(fun a => let H := fresh in assert (H : proper x); [ eapply ret_proper; eauto with typeclass_instances | k H ]) | (fun x => _) => let H := fresh in assert (H : proper x); [ eapply fun_abs; intros; [ propers | repeat red; intros; prove_mleq ] | k H ] | _ => let H := fresh in assert (H : proper x); [ eauto with typeclass_instances | k H ] end with prove_mleq := try match goal with | |- proper (fun x => _) => eapply fun_abs; intros; [ propers | repeat red; intros; prove_mleq ] | [ R : _ , H' : pfun_ext ?R _ ?F ?G |- ?R (?F _) (?G _) ] => eapply H'; [ propers | propers | prove_mleq ] | [ H' : proper ?F |- ?R (?F _) (?F _) ] => eapply H'; [ propers | propers | try assumption; prove_mleq ] | [ |- mleq _ (bind _ _) (bind _ _) ] => eapply bind_respectful_leq; [ eauto with typeclass_instances | eauto with typeclass_instances | prove_mleq | intros; prove_mleq ] | [ |- mleq _ (ret _) (ret _) ] => eapply ret_respectful_leq; [ eauto with typeclass_instances | eauto with typeclass_instances | prove_mleq ] | [ H : proper ?f |- pfun_ext _ _ ?f ?f ] => apply H | [ H : proper ?f |- pfun_ext _ _ (fun x => _) (fun y => _) ] => red; intros; prove_mleq | _ => eassumption end with propers := match goal with | |- proper ?X => prove_proper X ltac:(fun x => eapply x) | |- mleq _ ?X ?Y => prove_proper X ltac:(fun x => prove_proper Y ltac:(fun x => idtac)) end. Instance PReflexive_stuff : PReflexive (pfun_ext (pfun_ext (pfun_ext rC pA) (Proper_pfun pB pC)) (Proper_pfun pA pB)). Proof. intuition. Qed. Theorem bind_law : forall (f : A -> B) (g : B -> C), proper f -> proper g -> mleq (pfun_ext rC pA) (fapply (fapply (pure (@compose A B C)) (pure f)) (pure g)) (pure (compose f g)). 
(Fin.L k (Fin.L m n)) (only parsing). Notation auxm n := (Fin.L k (Fin.R 6 n)) (only parsing). Notation auxk n := (Fin.R (6 + m) n) (only parsing). Fixpoint M_init' k' : (Vector.t (Fin.t k) k') -> pTM (Σ) ^+ unit ((6 + m)+ k). Proof using m s retr_bools sim retr_pro. simple notypeclasses refine (match k' with 0 => fun _ => MK_isVoid_multi _ @ [|aux Fin1;aux Fin2;aux Fin3;aux Fin4; aux Fin5|];; WriteValue ( (compile sim)) ⇑ retr_pro @ [|aux Fin1|] | S k' => fun ren => _;;M_init_one s retr_pro retr_bools @ [|auxk (ren[@Fin0]);aux Fin1;aux Fin2;aux Fin3;aux Fin4;aux Fin5|] end). all:try exact _. 2:{apply (M_init' _ (Vector.tl ren)). } Defined. Theorem M_init'_SpecT k' (ren :Vector.t (Fin.t k) k') (v:Vector.t (list bool) k): { k & TripleT ≃≃([],Vector.const (Custom (eq niltape)) (6+m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v) k (M_init' ren) (fun _ => ≃≃([], ([|Custom (eq niltape); Contains retr_pro (compile (Vector.fold_right (fun l_i s => L.app s (encBoolsL l_i)) (select ren v) sim)) ;Void;Void;Void;Void|]++Vector.const (Custom (eq niltape)) m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v))}. Proof using All. induction ren. all:cbn [compile Vector.fold_left M_init' Vector.tl Vector.caseS]. { eexists. cbn. hstep. hsteps_cbn;cbn. exact (MK_isVoid_multi_SpecT 5). cbn;cleanupParamTM. 2:reflexivity. hsteps_cbn. reflexivity. cleanupParamTM. apply EntailsI. intros t H. eapply tspec_ext. eassumption. easy. intros i. clear - i. repeat (destruct (fin_destruct_S i) as [(i'&->) | ->];[rename i' into i;cbn| ]);try (intros H;exact H). } { eexists. cbn. hstep. 3:reflexivity. now apply (projT2 (IHren)). clear IHren. cbn. intros _. hstep. { cbn. rewrite Vector_nth_R,nth_map'. cbn. eapply (projT2 (M_init_one_Spec H_disj _ _)). } cbn;fold Nat.add;rewrite Nat.eqb_refl;cbn. intros _. apply EntailsI. intros t H. eapply tspec_ext. eassumption. easy. intros i. clear - i. repeat (destruct (fin_destruct_S i) as [(i'&->) | ->];[rename i' into i;cbn| ]);try (intros H;exact H). rewrite nth_tabulate. destruct (Fin.eqb _ _) eqn:H'. 2:tauto. cbn. eapply Fin.eqb_eq in H' as ->. rewrite Vector_nth_R,nth_map'. cbn. tauto. } Qed. Program Definition startRen := Vectors.tabulate (n:=k) (fun i => Fin.of_nat_lt (n:=k) (p:=k - 1 -proj1_sig (Fin.to_nat i)) _). Next Obligation. destruct Fin.to_nat;cbn. nia. Defined. Lemma startRen_spec A (v:Vector.t A _): select startRen v = Vector.rev v. Proof. unfold select. apply eq_nth_iff'. intros i. rewrite nth_map'. unfold startRen. unshelve erewrite nth_tabulate, vector_nth_rev. 1:abstract (inv i;nia). f_equal. eapply Fin.of_nat_ext. Qed. Import CasePair Code.CaseList. Definition M_init : pTM (Σ) ^+ unit ((6 + m)+ k) := M_init' startRen. Theorem M_init_SpecT (v:Vector.t (list bool) k): { k & TripleT ≃≃([],Vector.const (Custom (eq niltape)) (6+m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v) k M_init (fun _ => ≃≃([], ([|Custom (eq niltape); Contains retr_pro (compile (Vector.fold_left (fun s l_i => L.app s (encBoolsL l_i)) sim v)); Void;Void;Void;Void|] ++Vector.const (Custom (eq niltape)) m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v))}. 
simpl tree_rep. Intros pa pb. clear H0. forward. forward_if; [ | forward_if ]. - forward. unfold delete_inv. Exists (field_address t_struct_tree [StructField _left] p1) t1_1. entailer!. simpl. simpl_compb. apply RAMIF_PLAIN.trans'. apply bst_left_entail; auto. - forward. unfold delete_inv. Exists (field_address t_struct_tree [StructField _right] p1) t1_2. entailer!. simpl. simpl_compb; simpl_compb. apply RAMIF_PLAIN.trans'. apply bst_right_entail; auto. - assert (x=k) by lia. subst x. unfold_data_at (data_at _ _ _ p1). gather_SEP (field_at _ _ [StructField _left] _ _) (tree_rep _ pa). replace_SEP 0 (treebox_rep t1_1 (field_address t_struct_tree [StructField _left] p1)). { unfold treebox_rep; entailer!. Exists pa. rewrite field_at_data_at. simpl. entailer!. } gather_SEP (field_at _ _ [StructField _right] _ _) (tree_rep _ pb). replace_SEP 0 (treebox_rep t1_2 (field_address t_struct_tree [StructField _right] p1)). { unfold treebox_rep; entailer!. Exists pb. rewrite field_at_data_at. entailer!. } Time forward_call (t1_1, k, v, t1_2, b1, p1); [entailer! .. | ]. forward. simpl. simpl_compb. simpl_compb. apply modus_ponens_wand'. auto. * forward. apply andp_left2; auto. Qed.Lemma body_treebox_new: semax_body Vprog Gprog f_treebox_new treebox_new_spec. Proof. start_function. Time forward_call (sizeof (tptr t_struct_tree)). Intros p. rewrite memory_block_data_at_ by auto. forward. forward. Exists p. entailer!. Qed.Lemma body_tree_free: semax_body Vprog Gprog f_tree_free tree_free_spec. Proof. start_function. forward_if (PROP()LOCAL()SEP()). + destruct t; simpl tree_rep. 1: Intros. contradiction. Intros pa pb. forward. forward. Time forward_call (p, sizeof t_struct_tree). { entailer!. rewrite memory_block_data_at_ by auto. cancel. } Time forward_call (t1,pa). Time forward_call (t2,pb). entailer!. + forward. subst. entailer!. simpl. entailer!. + forward. Qed.Lemma body_treebox_free: semax_body Vprog Gprog f_treebox_free treebox_free_spec. Proof. start_function. unfold treebox_rep. Intros p. forward. Time forward_call (t,p). Time forward_call (b, sizeof (tptr t_struct_tree)). entailer!. rewrite memory_block_data_at_ by auto. cancel. forward. Qed.Module Abstractions. Section TREE_ABS.Definition total_map (A:Type) := key -> A. Definition t_empty {A:Type} (v : A) : total_map A := (fun _ => v). Definition t_update {A:Type} (m : total_map A) (x : key) (v : A) := fun x' => if x =? x' then v else m x'. Definition combine {A} (pivot: key) (m1 m2: total_map A) : total_map A := fun x : key => if zlt x pivot then m1 x else m2 x.Inductive Abs: tree val -> total_map val -> Prop := | Abs_E: Abs E (t_empty nullval) | Abs_T: forall a b l k v r, Abs l a -> Abs r b -> Abs (T l k v r) (t_update (combine k a b) k v).Theorem insert_relate: forall k v t cts, Abs t cts -> Abs (insert k v t) (t_update cts k v). Admitted. Theorem lookup_relate: forall k t cts , Abs t cts -> lookup nullval k t = cts k. 
]] * LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm') \/ ([[ r = OK tt ]] * exists dmap' Fd ilist' frees' f', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * rep_macro Fm Fi m' bxp ixp dnum dmap' ilist' frees' f' ms' sm * [[ dmap' = Mem.upd dmap name (inum, isdir) ]] * [[ (Fd * name |-> (inum, isdir))%pred dmap' ]] * [[ (Fd dmap /\ notindomain name dmap) ]] * [[ BFILE.ilist_safe ilist (BFILE.pick_balloc frees (MSAlloc ms')) ilist' (BFILE.pick_balloc frees' (MSAlloc ms')) ]] * [[ BFILE.treeseq_ilist_safe dnum ilist ilist' ]] )) CRASH:hm' LOG.intact lxp F m0 sm hm' >} link lxp bxp ixp dnum name inum isdir ix0 ms. Proof. unfold link. hoare. eauto using link_dir_rep_pimpl_notindomain. or_r; resolve_valid_preds; cancel. subst; eexists. split; [ eauto | split ]; [ intros ? Hx | split; [ intros ? Hx | ] ]. destruct (weq w (sname2wname name)); subst. eapply cond_inv_domain_right with (PA := wname_valid); eauto. apply indomain_upd_ne in Hx; auto. destruct (string_dec s name); subst; auto. apply indomain_upd_ne in Hx; auto. eapply mem_ainv_mem_upd; eauto. apply ptsto_upd_disjoint; auto. Qed. Hint Extern 1 ({{_}} Bind (lookup _ _ _ _ _) _) => apply lookup_ok : prog. Hint Extern 1 ({{_}} Bind (unlink _ _ _ _ _) _) => apply unlink_ok : prog. Hint Extern 1 ({{_}} Bind (link _ _ _ _ _ _ _ _ _) _) => apply link_ok : prog. Hint Extern 1 ({{_}} Bind (readdir _ _ _ _) _) => apply readdir_ok : prog. Hint Extern 0 (okToUnify (rep ?f _) (rep ?f _)) => constructor : okToUnify. Theorem bfile0_empty : rep BFILE.bfile0 empty_mem. Proof. unfold rep. exists empty_mem. intuition. apply DIR.bfile0_empty. inversion H; discriminate. inversion H; discriminate. firstorder. Qed. Theorem rep_no_0_inum: forall f m, rep f m -> forall name isdir, m name = Some (0, isdir) -> False. Proof. unfold rep. intros. repeat deex. unfold indomain in *. assert (sname_valid name) by eauto. erewrite <- wname2sname_sname2wname with (name := name) in H0 by eauto. rewrite <- H4 in *. eauto using DIR.rep_no_0_inum. eauto using sname_valid_wname_valid. Qed. Theorem crash_eq : forall f f' m1 m2, BFILE.file_crash f f' -> rep f m1 -> rep f' m2 -> m1 = m2. Proof. intros. apply eq_sym. eapply rep_mem_eq; eauto. unfold rep in *; intros. repeat deex. assert (dmap0 = dmap). eapply DIR.crash_eq; eauto. subst. eexists; intuition; eauto. Qed. Theorem crash_rep : forall f f' m, BFILE.file_crash f f' -> rep f m -> rep f' m. 
Require Import Verdi.GhostSimulations. Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.LeaderLogsContiguousInterface. Require Import VerdiRaft.LogMatchingInterface.Section LeaderLogsContiguous. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lmi : log_matching_interface}. Lemma update_elections_data_client_request_leaderLogs : forall h st client id c, leaderLogs (update_elections_data_client_request h st client id c) = leaderLogs (fst st). Proof using. unfold update_elections_data_client_request in *. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma update_elections_data_timeout_leaderLogs : forall h st, leaderLogs (update_elections_data_timeout h st) = leaderLogs (fst st). Proof using. unfold update_elections_data_timeout. intros. repeat break_match; simpl in *; auto. Qed. Lemma update_elections_data_appendEntries_leaderLogs : forall h st t h' pli plt es ci, leaderLogs (update_elections_data_appendEntries h st t h' pli plt es ci) = leaderLogs (fst st). Proof using. intros. unfold update_elections_data_appendEntries. repeat break_match; subst; simpl in *; auto. Qed. Lemma update_elections_data_requestVote_leaderLogs : forall h h' t lli llt st, leaderLogs (update_elections_data_requestVote h h' t h' lli llt st) = leaderLogs (fst st). Proof using. unfold update_elections_data_requestVote. intros. repeat break_match; auto. Qed. Lemma handleRequestVoteReply_spec : forall h st h' t v st', st' = handleRequestVoteReply h st h' t v -> log st' = log st /\ (currentTerm st' = currentTerm st \/ (currentTerm st <= currentTerm st' /\ type st' = Follower)). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition. Qed. Lemma update_elections_data_requestVoteReply_leaderLogs : forall h h' t r st, leaderLogs (update_elections_data_requestVoteReply h h' t r st) = leaderLogs (fst st) \/ leaderLogs (update_elections_data_requestVoteReply h h' t r st) = (currentTerm (snd st), log (snd st)) :: leaderLogs (fst st). Proof using. intros. unfold update_elections_data_requestVoteReply in *. repeat break_match; intuition. simpl in *. match goal with | |- context [handleRequestVoteReply ?h ?s ?h' ?t ?r] => pose proof handleRequestVoteReply_spec h s h' t r (handleRequestVoteReply h s h' t r) end. intuition; repeat find_rewrite; intuition. congruence. Qed. Theorem lift_log_matching : forall net, refined_raft_intermediate_reachable net -> log_matching (deghost net). Proof using lmi rri. intros. eapply lift_prop; eauto using log_matching_invariant. Qed. Theorem logs_contiguous : forall net h, refined_raft_intermediate_reachable net -> contiguous_range_exact_lo (log (snd (nwState net h))) 0. 
unfold A_HMAC, RKA_G0, GHMAC, HMAC_RKA_A, GNMAC, HMAC_spec.GHMAC. comp_skip. simpl. repeat ( inline_first; comp_simp). comp_skip. eapply comp_spec_eq_impl_eq. eapply comp_spec_consequence. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => a = b)). trivial. intuition. unfold f_oracle. eapply comp_spec_ret; intuition. simpl. specialize (GHMAC_2K_GNMAC_equiv (Vector.append (x xor opad) (x xor ipad)) a0); intuition. rewrite splitVector_append in H1. unfold dual_f. eapply eq_trans. eapply H1. unfold GNMAC. f_equal. f_equal. f_equal. eapply BVxor_comm. f_equal. eapply BVxor_comm. intuition. destruct b2; simpl in *; subst; intuition. comp_simp. simpl. inline_first. comp_simp. intuition. Qed. Definition A_NMAC_G1 := x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_0 := [x1, x2] <-$2 ( x <-$ {0, 1}^(c + c); ret (splitVector c c x)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Definition A_NMAC_G1_1 := [x1, x2] <-$2 ( x1 <-$ {0, 1}^c; x2 <-$ {0, 1}^c; ret (x1, x2)); [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt; ret b. Theorem A_NMAC_G1_0_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1_0]. unfold A_NMAC, A_NMAC_G1_0. inline_first. comp_skip. remember (splitVector c c x) as z. comp_simp. erewrite append_splitVector. reflexivity. trivial. Qed. Theorem A_NMAC_G1_0_1_equiv : Pr[A_NMAC_G1_0] == Pr[A_NMAC_G1_1]. unfold A_NMAC_G1_0, A_NMAC_G1_1. comp_skip. eapply Rnd_split_equiv. reflexivity. Qed. Theorem A_NMAC_G1_1_equiv : Pr[A_NMAC_G1_1] == Pr[A_NMAC_G1]. unfold A_NMAC_G1_1, A_NMAC_G1. inline_first. comp_skip. inline_first. comp_skip. Qed. Theorem A_NMAC_G1_equiv : Pr[A_NMAC] == Pr[A_NMAC_G1]. rewrite A_NMAC_G1_0_equiv. rewrite A_NMAC_G1_0_1_equiv. apply A_NMAC_G1_1_equiv. Qed. Theorem xor_1_1 : forall (n : nat)(x y z : Bvector n), BVxor _ y x = BVxor _ z x -> y = z. intuition. rewrite <- BVxor_id_r at 1. rewrite <- (BVxor_same_id x). rewrite <- BVxor_assoc. rewrite H. rewrite BVxor_assoc. rewrite (BVxor_same_id x). rewrite BVxor_id_r. trivial. Qed. Theorem A_NMAC_RKA_equiv : Pr[A_NMAC] == Pr[RKA_G1 _ _ _ (Rnd b) (Rnd c) (BVxor b) HMAC_RKA_A]. rewrite A_NMAC_G1_equiv . unfold A_NMAC_G1, RKA_G1, HMAC_RKA_A. comp_irr_r. wftac. simpl. inline_first. comp_skip. comp_simp. inline_first. unfold RKA_randomFunc, randomFunc. simpl. case_eq ( @eqbPair (Bvector b) (Bvector c) (Bvector_EqDec b) (Bvector_EqDec c) (@pair (Bvector b) (Bvector c) (BVxor b ipad x) iv) (@pair (Bvector b) (Bvector c) (BVxor b opad x) iv) ); intuition. unfold eqbPair in *. simpl in *. apply andb_true_iff in H1. intuition. apply eqbBvector_sound in H2. exfalso. eapply opad_ne_ipad. eapply xor_1_1. eauto. inline_first. comp_skip. comp_simp. inline_first. comp_skip. comp_simp. simpl. inline_first. comp_simp. intuition. Qed. Theorem A_HMAC_NMAC_close : | Pr[A_HMAC] - Pr[A_NMAC] | <= RKA_Advantage _ _ _ (Rnd b) (Rnd c) (dual_f h) (BVxor b) HMAC_RKA_A. 
trie) : trie := match t with | Leaf => Node Leaf Leaf None | _ => t end.Fixpoint insert (bs : bits) (v : A) (t : trie) : trie := match t with | Leaf => Leaf | Node l r v' => match bs with | nil => Node l r (Some v) | true :: bs' => Node (insert bs' v (new l)) r v' | false :: bs' => Node l (insert bs' v (new r)) v' end end.Fixpoint search (bs : bits) (t : trie) : option A := match t with | Leaf => None | Node l r v => match bs with | nil => v | true :: bs' => search bs' l | false :: bs' => search bs' r end end.Lemma new_is_node : forall (t : trie), exists l r v, new t = Node l r v. Proof. intro t. unfold new. destruct t; eauto. Qed.Lemma search_leaf : forall (bs : bits), search bs Leaf = None. Proof. intros. induction bs; unfold search; auto. Qed.Hint Resolve search_leaf.Inductive BitsEq : bits -> bits -> Prop := | eq_nil : BitsEq nil nil | eq_cons : forall (b : bool) (b1 b2 : bits), BitsEq b1 b2 -> BitsEq (b :: b1) (b :: b2).Ltac invert H := inversion H; clear H; subst.Ltac invert_new t := let H := fresh in assert (H: exists l r v, new t = Node l r v) by apply new_is_node; destruct H; destruct H; destruct H; rewrite H. Lemma bool_decidable : forall (a b : bool), Decidable.decidable (a = b). Proof. intros. unfold Decidable.decidable. assert ( {a = b} + {a <> b} ). { apply bool_dec. } destruct H; tauto. Qed.Lemma bool_neq_is_neg : forall (a b : bool), a <> b -> a = negb b. Proof. intros. destruct a; destruct b; auto. exfalso. apply H. auto. Qed. Lemma bits_neq_cons : forall a b bs1 bs2, ~ BitsEq (a :: bs1) (b :: bs2) -> a <> b \/ ~ BitsEq bs1 bs2. Proof. intros. apply Decidable.not_and. apply bool_decidable. intros [H1 H2]. subst. apply H. apply eq_cons. apply H2. Qed.Lemma bits_neq_nil : forall bs, ~ BitsEq nil bs -> exists b bs', bs = b :: bs'. Proof. intros. assert (bs <> nil). { intros contra. apply H. subst. constructor. } destruct bs. - exfalso. apply H0. auto. - eauto. Qed. Theorem insert_affact_eq_search : forall (bs1 bs2 : bits) (v : A) (t : trie), BitsEq bs1 bs2 -> search bs2 (insert bs1 v (new t)) = Some v. 
: forall A B C:Ensemble U, Union U (Union U A B) C = Union U A (Union U B C). Proof. auto 9 with sets. Qed. Theorem Union_idempotent : forall A:Ensemble U, Union U A A = A. Proof. auto 7 with sets. Qed. Lemma Union_absorbs : forall A B:Ensemble U, Included U B A -> Union U A B = A. Proof. auto 7 with sets. Qed. Theorem Couple_as_union : forall x y:U, Union U (Singleton U x) (Singleton U y) = Couple U x y. Proof. intros x y; apply Extensionality_Ensembles; split; red. intros x0 H'; elim H'; (intros x1 H'0; elim H'0; auto with sets). intros x0 H'; elim H'; auto with sets. Qed. Theorem Triple_as_union : forall x y z:U, Union U (Union U (Singleton U x) (Singleton U y)) (Singleton U z) = Triple U x y z. Proof. intros x y z; apply Extensionality_Ensembles; split; red. intros x0 H'; elim H'. intros x1 H'0; elim H'0; (intros x2 H'1; elim H'1; auto with sets). intros x1 H'0; elim H'0; auto with sets. intros x0 H'; elim H'; auto with sets. Qed. Theorem Triple_as_Couple : forall x y:U, Couple U x y = Triple U x x y. Proof. intros x y. rewrite <- (Couple_as_union x y). rewrite <- (Union_idempotent (Singleton U x)). apply Triple_as_union. Qed. Theorem Triple_as_Couple_Singleton : forall x y z:U, Triple U x y z = Union U (Couple U x y) (Singleton U z). Proof. intros x y z. rewrite <- (Triple_as_union x y z). rewrite <- (Couple_as_union x y); auto with sets. Qed. Theorem Intersection_commutative : forall A B:Ensemble U, Intersection U A B = Intersection U B A. Proof. intros A B. apply Extensionality_Ensembles. split; red; intros x H'; elim H'; auto with sets. Qed. Theorem Distributivity : forall A B C:Ensemble U, Intersection U A (Union U B C) = Union U (Intersection U A B) (Intersection U A C). Proof. intros A B C. apply Extensionality_Ensembles. split; red; intros x H'. elim H'. intros x0 H'0 H'1; generalize H'0. elim H'1; auto with sets. elim H'; intros x0 H'0; elim H'0; auto with sets. Qed. Lemma Distributivity_l : forall (A B C : Ensemble U), Intersection U (Union U A B) C = Union U (Intersection U A C) (Intersection U B C). Proof. intros A B C. rewrite Intersection_commutative. rewrite Distributivity. f_equal; apply Intersection_commutative. Qed. Theorem Distributivity' : forall A B C:Ensemble U, Union U A (Intersection U B C) = Intersection U (Union U A B) (Union U A C). 
H. destruct H. rewrite H. rewrite Hdom //. } } exists  . split. * econstructor; split; eauto. set_solver. * split; rewrite ?dom_empty_L //. - intros d2 pd2 Hcrash. inversion Hcrash. subst. assert (@ffi_crash_step _ _ (AD.disk_semantics) m (delete i d2)). { econstructor; split. * rewrite dom_delete_L. destruct H0. rewrite dom_insert_L in H0. assert (i ∉ dom m). { apply not_elem_of_dom. eauto. } set_solver. * intros addr ab Hdel. destruct H0 as (_&Hlookup). apply (lookup_delete_Some d2) in Hdel. edestruct Hlookup. { intuition eauto. } eexists; split; intuition eauto. rewrite /AD.is_possible in H4 *. destruct H4 as (ab'&Hlookup'&Hin). rewrite lookup_insert_ne in Hlookup'; eauto. } intros Hcompat. assert (disk_compat (delete i d2) (delete i pd2)). { split. - rewrite ?dom_delete_L. destruct Hcompat as (Heq&_); eauto. rewrite Heq //. - intros addr ab Hdel. destruct Hcompat as (_&Hlook). edestruct Hlook as (b'&Hin&Hlook'). { apply (lookup_delete_Some d2) in Hdel. intuition eauto. } exists b'. split; eauto. rewrite lookup_delete_ne //. intros Heq. rewrite Heq lookup_delete in Hdel. congruence. } edestruct IH as (pd1&Hcrash'&Hcompat'); eauto. destruct Hcompat as (Hdom&Hlook). destruct H0 as (Hdom'&?). assert (is_Some (d2 !! i)) as (ab&?). { apply (elem_of_dom (D := gset Z) d2). rewrite dom_insert_L in Hdom'. rewrite -Hdom'; set_solver. } edestruct (Hlook) as (cb&?&?); eauto. exists (<[i := {| ADP.curr_val := log_heap.latest x; ADP.crash_val := cb |}]> pd1). split. { econstructor; split. * rewrite dom_insert_L. inversion Hcrash'. destruct H6 as (Heqdom&_). rewrite Heqdom. rewrite dom_delete_L. apply (elem_of_dom_2 (D := gset _) pd2) in H5. rewrite -union_difference_singleton_L //. * intros. destruct (decide (addr = i)). ** subst. rewrite lookup_insert in H6. inversion H6. rewrite //=. rewrite H5 => //=. edestruct H0; eauto. destruct H7 as (->&?). rewrite //=. rewrite /log_heap.possible/log_heap.sync//= in H4. apply elem_of_list_singleton in H4. subst. eauto. ** rewrite lookup_insert_ne // in H6. inversion Hcrash'. subst. destruct H7 as (_&Hlookup). eapply Hlookup in H6. rewrite lookup_delete_ne in H6; eauto. } { split. * rewrite ?dom_insert_L. destruct Hcompat' as (Hdomeq&_). rewrite Hdomeq; eauto. * intros. destruct (decide (addr = i)). ** subst. rewrite lookup_insert in H6. inversion H6; subst. rewrite lookup_insert. exists cb; split; eauto. inversion Hcrash. subst. destruct H7 as (?&Hlook_crash). edestruct (Hlook_crash) as (b&?&His_possible); eauto. subst. rewrite /AD.is_possible in His_possible. edestruct His_possible as (?&?&?Hin). rewrite lookup_insert in H8. inversion H8; subst. rewrite /log_heap.possible/log_heap.sync//= in H4. apply elem_of_list_singleton in H4; subst. eauto. ** rewrite lookup_insert_ne //. destruct Hcompat' as (?&Hlook_compat). rewrite lookup_insert_ne // in H6. edestruct Hlook_compat; eauto. } Qed. Theorem crash_step_simulation σ1 σ2: crash_prim_step (goose_crash_lang) σ1 σ2 → ∀ pσ2, state_compat σ2 pσ2 → ∃ pσ1, state_compat σ1 pσ1 ∧ crash_prim_step (goose_crash_lang) pσ1 pσ2. 
rewrite Bool.andb_true_r | |- context [ allb ?A ?B ] => destruct (allb A B) end; try reflexivity. rewrite MF.FACTS.empty_in_iff; auto. } Qed. Definition applySHeap (F : expr types -> expr types) (sh : SHeap) : SHeap := {| impures := MM.mmap_map (map F) (impures sh) ; pures := map F (pures sh) ; other := other sh |}. Theorem applySHeap_defn : forall F sh, applySHeap F sh = {| impures := MM.mmap_map (map F) (impures sh) ; pures := map F (pures sh) ; other := other sh |}. Proof. reflexivity. Qed. Lemma starred_nil : forall T U G cs (F : T -> _) B, heq funcs preds U G cs (starred F nil B) B. Proof. clear. reflexivity. Qed. Lemma starred_cons : forall T U G cs (F : T -> _) a A B, heq funcs preds U G cs (starred F (a :: A) B) (Star (F a) (starred F A B)). Proof. clear. intros; rewrite starred_def. simpl. rewrite <- starred_def. reflexivity. Qed. Theorem applySHeap_spec : forall cs U G U' G' s F, (forall e t, exprD funcs U G e t = exprD funcs U' G' (F e) t) -> SE.ST.heq cs (sexprD funcs preds U G (sheapD s)) (sexprD funcs preds U' G' (sheapD (applySHeap F s))). Proof. clear. intros. do 2 rewrite sheapD_def. simpl. repeat eapply SE.ST.heq_star_frame. { eapply MM.PROPS.map_induction with (m := impures s); intros. repeat rewrite impuresD_Empty by eauto using MF.map_Empty. reflexivity. rewrite impuresD_Add by eauto using MF.map_Add, MF.map_not_In. symmetry. unfold MM.mmap_map in *. rewrite impuresD_Add. 2: eapply MF.map_Add; eauto. 2: eapply MF.map_not_In; eauto. simpl. rewrite H0. apply ST.heq_star_frame; try reflexivity. clear - H. induction e; simpl. reflexivity. repeat rewrite starred_cons. simpl. rewrite IHe. apply ST.heq_star_frame; try reflexivity. destruct (nth_error preds x); try reflexivity. match goal with | |- ST.heq _ match ?X with _ => _ end match ?Y with _ => _ end => cutrewrite (X = Y); try reflexivity end. destruct p. simpl in *; clear -H. generalize dependent SDomain0. clear -H; induction a; destruct SDomain0; simpl; intros; auto; try congruence; try reflexivity. rewrite H. destruct (exprD funcs U' G' (F a) t); try reflexivity. rewrite IHa. reflexivity. } { induction (pures s); try reflexivity. simpl. repeat rewrite starred_cons. simpl. rewrite H. rewrite IHl. reflexivity. } { induction (other s). reflexivity. etransitivity. rewrite starred_cons. reflexivity. etransitivity. 2: rewrite starred_cons; reflexivity. simpl. rewrite IHl. reflexivity. } Qed. Theorem applySHeap_wt_spec : forall cs U G U' G' s F, (forall e t, is_well_typed (typeof_funcs funcs) (typeof_env U) (typeof_env G) e t = true -> exprD funcs U G e t = exprD funcs U' G' (F e) t) -> WellTyped_sheap (typeof_funcs funcs) (typeof_preds preds) (typeof_env U) (typeof_env G) s = true -> SE.ST.heq cs (sexprD funcs preds U G (sheapD s)) (sexprD funcs preds U' G' (sheapD (applySHeap F s))). 
q -> rem (alpha_nat b1 n) q = rem (alpha_nat b2 n) q. Proof. intros H1 H2 H3. destruct (eq_nat_dec q 0) as [ H4 | H4 ]. + subst; do 2 rewrite rem_0 in H3; subst; auto. + rewrite <- nat2Zp_inj with (Hp := H4) in H3. apply alpha_Z_congr with (n := S n) in H3; auto. simpl in H3. do 2 rewrite Z2Zp_of_nat in H3. rewrite nat2Zp_inj in H3. trivial. Qed.Corollary alpha_nat_congruence_1 b n : b-2 <> 0 -> rem (alpha_nat b n) (b-2) = rem n (b-2). Proof. intros Hb. rewrite <- alpha_nat_2 with (b_nat := 2) (n := n) at 2; auto. apply alpha_nat_congruence_0; try omega. replace b with ((b-2)+2) at 1 by omega. apply rem_erase with 1; omega. Qed.Check alpha_nat_congruence_0. Check alpha_nat_congruence_1.Section congruence_2. Variable (b : nat) (Hb : b - 2 <> 0). Notation "〚 x 〛" := (Z2Zp Hb x). Hint Resolve Zle_0_nat. Open Scope Z_scope. Theorem alpha_Z_b_2 n : 〚 alpha_Z b n 〛 = Zp_plus Hb 〚 Z.of_nat n 〛〚 -1 〛. Proof. rewrite <- Z2Zp_plus. replace (Z.of_nat n + -1) with (Z.of_nat n -1) by omega. rewrite <- (@alpha_2 2); auto. apply alpha_Z_congr; try omega. replace b with (2+(b-2))%nat at 3 by omega. rewrite nat2Zp_plus. rewrite nat2Zp_p, Zp_plus_comm, Zp_plus_zero; auto. Qed.End congruence_2.Lemma rem_eq_eq a b v : 2*a < v -> 2*b < v -> rem a v = rem b v -> a = b. Proof. intros H1 H2 H3. do 2 (rewrite rem_lt in H3; try omega). Qed.Lemma rem_eq_diff_eq a b v : 2*a < v -> 2*b < v -> (rem a v = rem b v) \/ (rem (a+b) v = 0) -> a = b. Proof. intros H1 H2 [ H3 | H3 ]. + do 2 (rewrite rem_lt in H3; try omega). + rewrite rem_lt in H3; omega. Qed.Section diophantine_sufficiency. Variables (a b c : nat) (u t r s v w x y : nat). Definition alpha_conditions := 3 < b /\ u*u+t*t = 1+b*(u*t) /\ s*s+r*r = 1+b*(s*r) /\ r < s /\ u*u │ s /\ v+2*r = b*s /\ rem w v = rem b v /\ rem w u = rem 2 u /\ 2 < w /\ x*x+y*y = 1+w*(x*y) /\ 2*a < u /\ 2*a < v /\ rem a v = rem x v /\ 2*c < u /\ rem c u = rem x u. Theorem alpha_sufficiency : alpha_conditions -> 3 < b /\ a = alpha_nat b c. 
apply ( fromempty ( ( negpathsii2ii1 x' ( g y0 ) ) e ) ) .apply ( weqcomp w1 w2 ) . Defined. Theorem weqhfibercoprodf2 { X Y X' Y' : UU } (f: X -> X')(g:Y -> Y')(y':Y'): weq (hfiber g y') (hfiber (coprodf f g) (ii2 y')). Proof. intros. set ( iy := @ii2 X Y ) . set ( iy' := @ii2 X' Y' ) . set ( fpg := coprodf f g ) . set ( fpgiy := fun y : Y => ( fpg ( iy y ) ) ) .assert ( w1 : weq ( hfiber g y' ) ( hfiber fpgiy ( iy' y' ) ) ) . apply ( samehfibers g iy' ( isinclii2 _ _ ) y' ) . assert ( w2 : weq ( hfiber fpgiy ( iy' y' ) ) ( hfiber fpg ( iy' y' ) ) ) . split with (hfibersgftog iy fpg ( iy' y' ) ) . unfold isweq. intro y . set (u:= invezmaphf iy fpg ( iy' y' ) y). assert (is: isweq u). apply isweqinvezmaphf. apply (iscontrweqb ( weqpair u is ) ) . destruct y as [ xy e ] . destruct xy as [ x0 | y0 ] . simpl . apply ( fromempty ( ( negpathsii1ii2 ( f x0 ) y' ) e ) ) . simpl. apply iscontrhfiberofincl . apply ( isinclii2 X Y ) . apply ( weqcomp w1 w2 ) . Defined. Theorem isofhlevelfcoprodf (n:nat) { X Y Z T : UU } (f : X -> Z ) ( g : Y -> T )( is1 : isofhlevelf n f ) ( is2 : isofhlevelf n g ) : isofhlevelf n (coprodf f g). Proof. intros. unfold isofhlevelf . intro y . destruct y as [ z | t ] . apply (isofhlevelweqf n (weqhfibercoprodf1 f g z) ). apply ( is1 z ) . apply (isofhlevelweqf n (weqhfibercoprodf2 f g t )). apply ( is2 t ) . Defined. Theorem isofhlevelsnsummand1 ( n : nat ) ( X Y : UU ) : isofhlevel ( S n ) ( coprod X Y ) -> isofhlevel ( S n ) X . Proof. intros n X Y is . apply ( isofhlevelXfromfY ( S n ) ( @ii1 X Y ) ( isofhlevelfsnincl n _ ( isinclii1 _ _ ) ) is ) . Defined. Theorem isofhlevelsnsummand2 ( n : nat ) ( X Y : UU ) : isofhlevel ( S n ) ( coprod X Y ) -> isofhlevel ( S n ) Y . 
"Hused1" ∷ inode_used γused ino s.(inode.addrs). Local Definition Palloc γused (s: alloc.t): iProp Σ := ∃ allocs: gmap nat (gset u64), "%Halloc_size" ∷ ⌜size allocs = num_inodes⌝ ∗ "%Hused_global" ∷ ⌜alloc.used s = ⋃ (snd <$> map_to_list allocs)⌝ ∗ "Hused2" ∷ inode_allused γused allocs. Definition dir_inv γblocks (dir: dir.t): iProp Σ := "%Hdom" ∷ ⌜ ∀ idx, idx < num_inodes → is_Some (dir.(dir.inodes) !! idx) ⌝ ∗ "Hγblocks" ∷ inode_allblocks γblocks dir.(dir.inodes). Definition dir_state (l alloc_l: loc) (inode_refs: list loc) : iProp Σ := ∃ d (inodes_s: Slice.t), "#d" ∷ readonly (l ↦[Dir :: "d"] (disk_val d)) ∗ "#allocator" ∷ readonly (l ↦[Dir :: "allocator"] #alloc_l) ∗ "#inodes" ∷ readonly (l ↦[Dir :: "inodes"] (slice_val inodes_s)) ∗ "#inodes_s" ∷ readonly (is_slice_small inodes_s ptrT 1 (inode_refs)) . Local Definition allocΨ (a: u64): iProp Σ := ∃ b, int.Z a d↦ b. Definition is_dir l (sz: Z) : iProp Σ := ∃ (alloc_ref: loc) (inode_refs: list loc) γalloc γused γblocks, "%Hlen" ∷ ⌜length inode_refs = num_inodes⌝ ∗ "Hro_state" ∷ dir_state l alloc_ref inode_refs ∗ "#Hinodes" ∷ ([∗ list] i ↦ inode_ref ∈ inode_refs, is_inode inodeN inode_ref (Pinode γblocks γused i) (U64 (Z.of_nat i))) ∗ "#Halloc" ∷ is_allocator (Palloc γused) allocΨ allocN alloc_ref (rangeSet num_inodes (sz-num_inodes)) γalloc ∗ "#Hinv" ∷ ncinv dirN (∃ σ, dir_inv γblocks σ ∗ P σ) . Definition dir_cinv sz σ (post_crash: bool) : iProp Σ := ∃ γblocks γused, "Hinodes" ∷ (∃ s_inodes, "%Hinode_len" ∷ ⌜length s_inodes = num_inodes⌝ ∗ "Hinodes" ∷ ([∗ list] i↦s_inode ∈ s_inodes, "Hinode_cinv" ∷ inode_cinv (U64 (Z.of_nat i)) s_inode ∗ "HPinode" ∷ Pinode γblocks γused i s_inode)) ∗ "Halloc" ∷ alloc_crash_cond_no_later (Palloc γused) allocΨ (rangeSet num_inodes (sz-num_inodes)) post_crash ∗ "Hs_inode" ∷ dir_inv γblocks σ . Lemma dir_cinv_post_crash sz σ : dir_cinv sz σ true -∗ dir_cinv sz σ false. Proof. iNamed 1. iExists _, _; iFrame. iApply alloc_crash_cond_no_later_from_post_crash; auto. Qed. Definition pre_dir l (sz: Z) dir : iProp Σ := ∃ alloc_ref inode_refs γblocks γused, "%Hlen" ∷ ⌜length inode_refs = num_inodes⌝ ∗ "Hro_state" ∷ dir_state l alloc_ref inode_refs ∗ "Hd_inv" ∷ dir_inv γblocks dir ∗ "Hinodes" ∷ (∃ s_inodes, [∗ list] i↦inode_ref;s_inode ∈ inode_refs;s_inodes, pre_inode inode_ref (U64 (Z.of_nat i)) s_inode ∗ Pinode γblocks γused i s_inode) ∗ "Halloc" ∷ (∃ s_alloc, "Halloc_mem" ∷ is_allocator_mem_pre alloc_ref s_alloc ∗ "%Halloc_dom" ∷ ⌜alloc.domain s_alloc = rangeSet num_inodes (sz-num_inodes)⌝ ∗ "Hunused" ∷ ([∗ set] k ∈ alloc.unused s_alloc, allocΨ k) ∗ "HPalloc" ∷ Palloc γused s_alloc) . Theorem big_sepM_const_seq {PROP:bi} {A} start sz (def: A) (Φ: nat → A → PROP) : ([∗ map] i↦x ∈ gset_to_gmap def (set_seq start sz), Φ i x) -∗ ([∗ list] i ∈ seq start sz, Φ i def). 
Require Import Vector. Fixpoint vector_nth {A:Type}(n:nat)(p:nat)(v:t A p){struct v} : option A := match n,v with _ , nil _ => None | 0 , cons _ b _ _ => Some b | S n', cons _ _ p' v' => vector_nth n' p' v' end.Arguments cons {A} h {n} _ . Arguments nil {A}. Arguments vector_nth {A} n {p} v.Definition v0 := cons true (cons false (cons false nil)).Lemma test0 : vector_nth 2 v0 = Some false. Proof. trivial. Qed.Lemma test1 : vector_nth 7 v0 = None. Proof. trivial. Qed. Theorem nth_size : forall {A:Type}(p:nat)(v:t A p)(n:nat), vector_nth n v = None <-> p <= n. 
specs f = Some a' /\ forall x, a' x = Substs s (a x) | And _ p1 p2 => fun s => simplifyH p1 s /\ simplifyH p2 s | Or _ p1 p2 => fun s => simplifyH p1 s \/ simplifyH p2 s | _ => fun _ => True end. Lemma Substs_Cptr : forall G (s : subs G) f a, exists a', Substs s (Cptr f a) = Cptr f a' /\ forall x, a' x = Substs s (a x). induction s; simpl; intuition eauto. Qed. Lemma simplifyH_ok : forall G (p : propX pc state G) s PG p', In (Substs s p) PG -> (simplifyH p s -> valid specs PG (Substs s p')) -> valid specs PG (Substs s p'). induction p; simpl; intuition; autorewrite with Substs in *. eapply Inj_E; [ constructor; eauto | auto ]. destruct (Substs_Cptr s p p0) as [? [ Heq ] ]; rewrite Heq in *. eapply Cptr_E; [ constructor; eauto | eauto ]. assert (valid specs PG (Substs s p1 ---> Substs s p2 ---> Substs s p')%PropX). repeat apply Imply_I. apply IHp1. simpl; tauto. intro. apply IHp2. simpl; tauto. eauto. eapply Imply_E. eapply Imply_E. eassumption. eapply And_E1; econstructor; eauto. eapply And_E2; econstructor; eauto. eapply Or_E. constructor; eauto. intuition. intuition. Qed. Theorem simplify_Imply : forall p1 p2, (simplifyH p1 SNil -> simplify p2 SNil) -> interp specs (Imply p1 p2). intros. change (interp specs (Imply (Substs SNil p1) (Substs SNil p2))). apply Imply_I. eapply simplifyH_ok. simpl; tauto. intros. apply valid_weaken1. apply simplify_bwd. auto. Qed. Theorem Imply_easyL' : forall G (p1 p2 p : PropX pc state), (simplifyH p1 SNil -> valid specs G (Imply p2 p)) -> valid specs G (Imply (And p1 p2) p). intros; apply Imply_easyL''. apply Imply_I. change (p2 ---> p)%PropX with (Substs SNil (p2 ---> p)%PropX). eapply simplifyH_ok. simpl; tauto. intro. simpl. apply valid_weaken1; auto. Qed. Theorem Imply_easyL : forall (p1 p2 p : PropX pc state), (simplifyH p1 SNil -> interp specs (Imply p2 p)) -> interp specs (Imply (And p1 p2) p). intros; apply Imply_easyL'; auto. Qed. Theorem Imply_trans' : forall G (p1 p2 p3 : PropX pc state), valid specs G (Imply p1 p2) -> valid specs G (Imply p2 p3) -> valid specs G (Imply p1 p3). intros; apply Imply_I. eapply Imply_E. apply valid_weaken1; eassumption. eapply Imply_E. apply valid_weaken1; eassumption. apply Env; simpl; tauto. Qed. Theorem Imply_trans : forall p1 p2 p3 : PropX pc state, interp specs (Imply p1 p2) -> interp specs (Imply p2 p3) -> interp specs (Imply p1 p3). 
Require Export List. Require Export Fnorm. Section suc. Variable b : Fbound. Variable radix : Z. Variable precision : nat.Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition FSucc (x : float) := match Z_eq_bool (Fnum x) (pPred (vNum b)) with | true => Float (nNormMin radix precision) (Zsucc (Fexp x)) | false => match Z_eq_bool (Fnum x) (- nNormMin radix precision) with | true => match Z_eq_bool (Fexp x) (- dExp b) with | true => Float (Zsucc (Fnum x)) (Fexp x) | false => Float (- pPred (vNum b)) (Zpred (Fexp x)) end | false => Float (Zsucc (Fnum x)) (Fexp x) end end. Theorem FSuccSimpl1 : forall x : float, Fnum x = pPred (vNum b) -> FSucc x = Float (nNormMin radix precision) (Zsucc (Fexp x)). intros x H'; unfold FSucc in |- *. generalize (Z_eq_bool_correct (Fnum x) (pPred (vNum b))); case (Z_eq_bool (Fnum x) (pPred (vNum b))); auto. intros H'0; Contradict H'0; auto. Qed. Theorem FSuccSimpl2 : forall x : float, Fnum x = (- nNormMin radix precision)%Z -> Fexp x <> (- dExp b)%Z -> FSucc x = Float (- pPred (vNum b)) (Zpred (Fexp x)). intros x H' H'0; unfold FSucc in |- *. generalize (Z_eq_bool_correct (Fnum x) (pPred (vNum b))); case (Z_eq_bool (Fnum x) (pPred (vNum b))); auto. intros H'1; absurd (0%nat <= pPred (vNum b))%Z; auto with zarith arith. rewrite <- H'1; rewrite H'. unfold nNormMin in |- *; simpl in |- *; auto with zarith. replace 0%Z with (- (0))%Z; auto with zarith. unfold pPred in |- *; apply Zle_Zpred; auto with zarith. intros H'1; generalize (Z_eq_bool_correct (Fnum x) (- nNormMin radix precision)); case (Z_eq_bool (Fnum x) (- nNormMin radix precision)). intros H'2; generalize (Z_eq_bool_correct (Fexp x) (- dExp b)); case (Z_eq_bool (Fexp x) (- dExp b)); auto. intros H'3; Contradict H'0; auto. intros H'2; Contradict H'2; auto. Qed. Theorem FSuccSimpl3 : FSucc (Float (- nNormMin radix precision) (- dExp b)) = Float (Zsucc (- nNormMin radix precision)) (- dExp b). 
in *. intros. rewrite <- (iso_to_from v). destruct to; simpl in *. apply proper_morphism. simpl. now apply X1. Qed.Class LeftKan := { Lan : [A, C] ⟶ [B, C]; lan_adjoint : Lan ⊣ Induced }.Class LocalLeftKan (X : A ⟶ C) := { LocalLan : B ⟶ C; lan_transform : X ⟹ LocalLan ◯ F; ump_lan (M : B ⟶ C) (ε : X ⟹ M ◯ F) : ∃! δ, ε ≈ δ ⊲ F ∙ lan_transform; }.#[export] Program Instance LeftKan_to_LocalLeftKan {R : LeftKan} (X : A ⟶ C) : LocalLeftKan X := {| LocalLan := Lan X; lan_transform := let adj_to := to (@adj _ _ _ _ lan_adjoint X (Lan X)) nat_id in {| transform := transform[adj_to] ; naturality := naturality[adj_to] |} |}. Next Obligation. srewrite_r (naturality[to (@adj _ _ _ _ lan_adjoint X (Lan X)) nat_id]). reflexivity. Qed. Next Obligation. exists (from (@adj _ _ _ _ (@lan_adjoint R) X M) ε). - intros. spose (@to_adj_nat_r _ _ _ _ lan_adjoint) as X0. rewrite <- X0; clear X0. spose (@iso_to_from _ _ _ (@adj _ _ _ _ lan_adjoint X M) ε x) as X0. unfold nat_compose; simpl in *. rewrites. sapply (proper_morphism (@to _ _ _ (@adj _ _ _ _ lan_adjoint X M))). simpl; intros; cat. - intros. assert (ε ≈ (to adj[lan_adjoint]) v). { intro. specialize (X0 x). rewrite X0; clear X0. srewrite_r (@to_adj_nat_r _ _ _ _ lan_adjoint). destruct (to adj[lan_adjoint]); simpl in *. apply proper_morphism; simpl. now apply nat_id_right. } clear -X1. destruct (adj[lan_adjoint]); simpl in *. intros. rewrite <- (iso_from_to v). destruct from; simpl in *. apply proper_morphism. simpl. now apply X1. Qed.End KanExtension.Arguments RightKan {_ _} F _. Arguments Ran {_ _} F {_ _}.Arguments LocalRightKan {_ _} F {_} _. Arguments LocalRan {_ _} F {_} _ {_}.Arguments LeftKan {_ _} F _. Arguments Lan {_ _} F {_ _}.Arguments LocalLeftKan {_ _} F {_} _. Arguments LocalLan {_ _} F {_} _ {_}.Definition preserves_left_Kan `(L : E ⟶ F) := ∀ C D (G : C ⟶ E) (K : C ⟶ D) `(!LeftKan K E) `(!LeftKan K F), L ◯ Lan K G ≈ Lan K (L ◯ G).Definition preserves_right_Kan `(R : E ⟶ F) := ∀ C D (G : C ⟶ E) (K : C ⟶ D) `(!RightKan K E) `(!RightKan K F), R ◯ Ran K G ≈ Ran K (R ◯ G). Theorem left_adjoint_impl `(L : C ⟶ D) : ∀ R : D ⟶ C, L ⊣ R -> ∀ {E} (G : E ⟶ C) (H : E ⟶ D), [[[E,D]]](L ◯ G, H) ≊ [[[E,C]]](G, R ◯ H). 
Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), [] <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = []}. Proof. induction l as [|a tail]. right; reflexivity. left; exists a, tail; reflexivity. Qed. Lemma hd_error_tl_repr : forall l (a:A) r, hd_error l = Some a /\ tl l = r <-> l = a :: r. Proof. destruct l as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. Proof. unfold not; intros a H; inversion_clear H. Qed. Theorem in_split : forall x (l:list A), In x l -> exists l1 l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists [], l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Qed. Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem in_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl; auto. destruct IHl; simpl; auto. right; unfold not; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), [] <> x ++ a :: y. 
rho 0)) then true else false). simpl in H3, H4 |- *. rewrite vec_map_set_pos in H3, H4. do 2 match goal with |- context[if ?c then _ else _] => destruct c end; auto; tauto. + intros (f & H1 & H2). apply discernable_rels_FSAT with f; auto. Qed.End FSAT_equiv_discernable_rels.Section FSAT_equiv_discernable_syms. Variables (Σ : fo_signature) (P : rels Σ) (HP : ar_rels Σ P = 1). Let termt (p : syms Σ) : fo_term (ar_syms Σ) := in_fot p (vec_set_pos (fun _ => in_var 0)). Local Definition testt (p : syms Σ) : fol_form Σ := fol_atom P (cast (termt p##ø) (eq_sym HP)). Variables (f g : syms Σ). Section model. Variable (δ : syms Σ -> bool) (Hp : δ f = true) (Hq : δ g = false). Let M : fo_model Σ bool. Proof. split. + intros s _; exact (δ s). + intros r; simpl; intros v. exact (match v with vec_nil => True | h##_ => h = true end). Defined. Local Fact discernable_syms_FSAT : FSAT Σ (testt f ⟑ (testt g ⤑ ⊥)). Proof using δ M Hq Hp. exists bool, M; msplit 2. + apply finite_t_bool. + intros r v; simpl. destruct v; try tauto. apply bool_dec. + exists (fun _ => true); simpl. rewrite HP; simpl. now rewrite Hp, Hq. Qed. End model. Theorem FSAT_equiv_discernable_syms : FSAT Σ (testt f ⟑ (testt g ⤑ ⊥)) <-> f ≢ g. Proof. rewrite discernable_equiv1. split. + intros (D & M & H1 & H2 & rho & H3 & H4). simpl in H3, H4 |- *. exists (fun k => if H2 P (vec_map (fo_term_sem M rho) (cast (termt k ## ø) (eq_sym HP))) then true else false). do 2 match goal with |- context[if ?c then _ else _] => destruct c end; auto; tauto. + intros (δ & H1 & H2). apply discernable_syms_FSAT with δ; auto. Qed.End FSAT_equiv_discernable_syms.Section FSAT_DEC_implies_discernable_rels. Variable Σ : fo_signature. Hypothesis HXY : forall A, decidable (FSAT Σ A). Theorem FSAT_dec_implies_discernable_rels_dec (P Q : rels Σ) : decidable (discernable P Q). Proof using HXY. destruct (HXY (test P ⟑ (test Q ⤑ ⊥))) as [ H | H ]. + left; revert H; apply FSAT_equiv_discernable_rels. + right; contradict H; revert H; apply FSAT_equiv_discernable_rels. Qed.End FSAT_DEC_implies_discernable_rels.Section FSAT_DEC_implies_discernable_syms. Variables (Σ : fo_signature) (P : rels Σ) (HP : ar_rels Σ P = 1). Hypothesis HXY : forall A, decidable (FSAT Σ A). Theorem FSAT_dec_implies_discernable_syms_dec (f g : syms Σ) : decidable (discernable f g). 
cancel. intuition ((pred_apply; cancel) || eauto). step. or_r. cancel. eauto. eapply listpred_dmatch_notindomain; eauto. cancel. step; msalloc_eq. erewrite Dent.items_length_ok with (xp := f) (m := (list2nmem (BFILE.BFData f))). unfold Dent.RA.RALen. auto. pred_apply; cancel. cbv; tauto. step. or_r; cancel. eexists; split; eauto. apply listpred_dmatch_mem_upd; auto. rewrite Bool.negb_true_iff; auto. erewrite Dent.items_length_ok with (xp := f) (m := (list2nmem (BFILE.BFData f))). unfold Dent.RA.RALen. auto. pred_apply; cancel. eapply ptsto_upd_disjoint; auto. apply BFILE.ilist_safe_refl. apply BFILE.treeseq_ilist_safe_refl. prestep. unfold rep_macro, rep. norm. cancel. intuition ((pred_apply; cancel) || eauto). step. or_r. cancel. eauto. eapply listpred_dmatch_notindomain; eauto. cancel. Unshelve. all: eauto. Qed. Hint Extern 1 ({{_}} Bind (lookup _ _ _ _ _) _) => apply lookup_ok : prog. Hint Extern 1 ({{_}} Bind (unlink _ _ _ _ _) _) => apply unlink_ok : prog. Hint Extern 1 ({{_}} Bind (link _ _ _ _ _ _ _ _ _) _) => apply link_ok : prog. Hint Extern 1 ({{_}} Bind (readdir _ _ _ _) _) => apply readdir_ok : prog. Hint Extern 0 (okToUnify (rep ?f _) (rep ?f _)) => constructor : okToUnify. Theorem dmatch_complete : forall de m1 m2, dmatch de m1 -> dmatch de m2 -> m1 = m2. Proof. unfold dmatch, is_dir; intros. destruct (bool_dec (is_valid de) false). apply emp_complete; eauto. eapply ptsto_complete; pred_apply; cancel. Qed. Lemma listpred_dmatch_eq : forall l m1 m2, listpred dmatch l m1 -> listpred dmatch l m2 -> m1 = m2. Proof. induction l; simpl; auto. apply emp_complete; auto. intros m1 m2. unfold_sep_star; intuition. repeat deex; f_equal. eapply dmatch_complete; eauto. eapply IHl; eauto. Qed. Lemma rep_mem_eq : forall f m1 m2, rep f m1 -> rep f m2 -> m1 = m2. Proof. unfold rep; intros. repeat deex. pose proof (Dent.rep_items_eq H0 H1); subst. eapply listpred_dmatch_eq; eauto. Qed. Theorem bfile0_empty : rep BFILE.bfile0 empty_mem. Proof. unfold rep, Dent.rep, Dent.items_valid. exists nil; firstorder. exists nil; simpl. setoid_rewrite Dent.Defs.ipack_nil. assert (emp (list2nmem (@nil valuset))) by firstorder. pred_apply; cancel. apply Forall_nil. Qed. Theorem rep_no_0_inum: forall f m, rep f m -> forall name isdir, m name = Some (0, isdir) -> False. Proof. unfold rep. intros. repeat deex. eauto using listpred_dmatch_no_0_inum. Qed. Theorem crash_eq : forall f f' m1 m2, BFILE.file_crash f f' -> rep f m1 -> rep f' m2 -> m1 = m2. Proof. intros. apply eq_sym. eapply rep_mem_eq; eauto. unfold rep in *. repeat deex. eexists; intuition eauto. assert (delist0 = delist). eapply Dent.file_crash_rep_eq; eauto. subst; eauto. Qed. Theorem crash_rep : forall f f' m, BFILE.file_crash f f' -> rep f m -> rep f' m. 
x - x)%R. split. rewrite Rabs_R0; apply Rmult_le_pos. apply Rlt_le, pos_half_prf. apply bpow_ge_0. split. apply Rle_trans with (/2*ulp beta (FLT_exp emin prec) x)%R. apply error_le_half_ulp. now apply FLT_exp_valid. apply Rmult_le_compat_l. apply Rlt_le, pos_half_prf. rewrite ulp_neq_0. 2: now apply Rgt_not_eq. apply bpow_le. unfold FLT_exp, canonic_exp. rewrite Zmax_right. omega. destruct (ln_beta beta x) as (e,He); simpl. assert (e-1 < emin+prec)%Z. apply (lt_bpow beta). apply Rle_lt_trans with (2:=Hx). rewrite <- (Rabs_right x). apply He; auto with real. apply Rle_ge; now left. omega. split;ring. Qed.End Fprop_relative_FLT.Lemma error_N_FLT : forall (emin prec : Z), (0 < prec)%Z -> forall (choice : Z -> bool), forall (x : R), exists eps eta : R, (Rabs eps <= /2 * bpow (-prec + 1))%R /\ (Rabs eta <= /2 * bpow emin)%R /\ (eps * eta = 0)%R /\ (round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta)%R. Proof. intros emin prec Pprec choice x. destruct (Rtotal_order x 0) as [Nx|[Zx|Px]]. { assert (Pmx : (0 < - x)%R). { now rewrite <- Ropp_0; apply Ropp_lt_contravar. } destruct (error_N_FLT_aux emin prec Pprec (fun t : Z => negb (choice (- (t + 1))%Z)) (- x)%R Pmx) as (d,(e,(Hd,(He,(Hde,Hr))))). exists d; exists (- e)%R; split; [exact Hd|split; [|split]]. { now rewrite Rabs_Ropp. } { now rewrite Ropp_mult_distr_r_reverse, <- Ropp_0; apply f_equal. } rewrite <- (Ropp_involutive x), round_N_opp. now rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal. } { assert (Ph2 : (0 <= / 2)%R). { apply (Rmult_le_reg_l 2 _ _ Rlt_0_2). rewrite Rmult_0_r, Rinv_r; [exact Rle_0_1|]. apply Rgt_not_eq, Rlt_gt, Rlt_0_2. } exists 0%R; exists 0%R; rewrite Zx; split; [|split; [|split]]. { now rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0]. } { now rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0]. } { now rewrite Rmult_0_l. } now rewrite Rmult_0_l, Rplus_0_l, round_0; [|apply valid_rnd_N]. } now apply error_N_FLT_aux. Qed.Section Fprop_relative_FLX.Variable prec : Z. Variable Hp : Zlt 0 prec.Lemma relative_error_FLX_aux : forall k, (prec <= k - FLX_exp prec k)%Z. Proof. intros k. unfold FLX_exp. omega. Qed.Variable rnd : R -> Z. Context { valid_rnd : Valid_rnd rnd }.Theorem relative_error_FLX : forall x, (x <> 0)%R -> (Rabs (round beta (FLX_exp prec) rnd x - x) < bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros x Hx. destruct (ln_beta beta x) as (ex, He). specialize (He Hx). apply relative_error with (ex - 1)%Z... intros k _. apply relative_error_FLX_aux. apply He. Qed. Theorem relative_error_FLX_ex : forall x, exists eps, (Rabs eps < bpow (-prec + 1))%R /\ round beta (FLX_exp prec) rnd x = (x * (1 + eps))%R. 
Require Export Fmin. Section FOdd. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition Even (z : Z) : Prop := exists z1 : _, z = (2 * z1)%Z. Definition Odd (z : Z) : Prop := exists z1 : _, z = (2 * z1 + 1)%Z. Theorem OddSEven : forall n : Z, Odd n -> Even (Zsucc n). intros n H'; case H'; intros m H'1; exists (Zsucc m). rewrite H'1; unfold Zsucc in |- *; ring. Qed. Theorem EvenSOdd : forall n : Z, Even n -> Odd (Zsucc n). intros n H'; case H'; intros m H'1; exists m. rewrite H'1; unfold Zsucc in |- *; ring. Qed. Hint Resolve OddSEven EvenSOdd: zarith. Theorem OddSEvenInv : forall n : Z, Odd (Zsucc n) -> Even n. intros n H'; case H'; intros m H'1; exists m. apply Zsucc_inj; rewrite H'1; (unfold Zsucc in |- *; ring). Qed. Theorem EvenSOddInv : forall n : Z, Even (Zsucc n) -> Odd n. intros n H'; case H'; intros m H'1; exists (Zpred m). apply Zsucc_inj; rewrite H'1; (unfold Zsucc, Zpred in |- *; ring). Qed. Theorem EvenO : Even 0. exists 0%Z; simpl in |- *; auto. Qed. Hint Resolve EvenO: zarith. Theorem Odd1 : Odd 1. exists 0%Z; simpl in |- *; auto. Qed. Hint Resolve Odd1: zarith. Theorem OddOpp : forall z : Z, Odd z -> Odd (- z). 
:= sc; Settings := x; Mem := y |}) * substH (globalInv w' sc) tq * mallocHeap 0 ] (stn, st') /\ [| Regs st' Sp = sp |] ---> pre (stn, st'))%PropX). cptr. propxFo; eauto. descend; eauto. rewrite <- sepFormula_eq; descend. step auto_ext. eauto. make_Himp. apply Himp_refl. Qed. Inductive mergeSusp : Prop := MS. Inductive splitSusp : Prop := SS.Hint Constructors mergeSusp splitSusp.Module Type TQ. Parameter susps : world -> bag -> W -> HProp. Parameter tq : world -> W -> HProp. Axiom tq_extensional : forall w sc, HProp_extensional (tq w sc). Axiom susps_empty_bwd : forall w sc, Emp ===> susps w empty sc. Axiom susps_add_bwd : forall w sc b pc sp, pc = pc -> mergeSusp -> susp w sc pc sp * susps w b sc ===> susps w (b %+ (pc, sp)) sc. Axiom susps_del_fwd : forall w sc b pc sp, (pc, sp) %in b -> susps w b sc ===> susp w sc pc sp * susps w (b %- (pc, sp)) sc. Axiom tq_fwd : forall w sc, tq w sc ===> Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc. Axiom tq_bwd : forall w sc, (Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc) ===> tq w sc. Axiom tq_weaken : forall w w' sc, evolve w w' -> tq w sc ===>* tq w' sc. End TQ.Module Tq : TQ. Open Scope Sep_scope. Definition susps (w : world) (b : bag) (sc : W) : HProp := starB (fun p => susp w sc (fst p) (snd p)) b. Theorem susps_empty_bwd : forall w sc, Emp ===> susps w empty sc. intros; apply starB_empty_bwd. Qed. Theorem susps_add_bwd : forall w sc b pc sp, pc = pc -> mergeSusp -> susp w sc pc sp * susps w b sc ===> susps w (b %+ (pc, sp)) sc. intros; eapply Himp_trans; [ | apply starB_add_bwd ]. unfold susps; simpl. apply Himp_star_comm. Qed. Theorem susps_del_fwd : forall w sc b pc sp, (pc, sp) %in b -> susps w b sc ===> susp w sc pc sp * susps w (b %- (pc, sp)) sc. 
x) (duplicateElt p n). Proof. induction n; simpl; intros. - intro Hx; destruct Hx; auto. apply withIndex_index_eq in H0; intuition. - intro Hx; destruct Hx. + apply withIndex_index_eq in H0; intuition. + intuition. Qed. Lemma duplicateElt_DisjList: forall p1 p2 n, p1 <> p2 -> DisjList (duplicateElt p1 n) (duplicateElt p2 n). Proof. unfold DisjList; intros. destruct (in_dec string_dec e (duplicateElt p1 n)); auto. destruct (in_dec string_dec e (duplicateElt p2 n)); auto. exfalso; apply duplicateElt_In in i; apply duplicateElt_In in i0; dest. subst; apply withIndex_index_eq in H0; intuition. Qed. Lemma dropN_dropPs: forall ds n, dropN ds n = dropPs (duplicateElt ds n). Proof. induction n; simpl; intros; auto. rewrite IHn; unfold compLabelMaps. extensionality s; extensionality v. remember (string_eq s (ds __ (S n))) as sn; destruct sn. - destruct (dropPs _ _ _); auto. apply string_eq_dec_eq in Heqsn; subst. unfold dropI; rewrite string_eq_true; auto. - destruct (dropPs _ _ _); auto. apply string_eq_dec_neq in Heqsn. unfold dropI; rewrite string_eq_dec_false; auto. Qed. Lemma dropPs_disj: forall ds1 ds2 dom1 dom2, DisjList dom1 ds2 -> DisjList dom2 ds1 -> DisjLabelMap (dropPs ds1) (dropPs ds2) dom1 dom2. Proof. unfold DisjLabelMap; intros; split; unfold EquivalentLabelMapElem, compLabelMaps; intros. - remember (dropPs ds2 s v) as dv; destruct dv. + apply eq_sym, dropPs_Some in Heqdv; dest; subst; auto. + exfalso; apply eq_sym, dropPs_None in Heqdv. specialize (H s); destruct H; auto. - remember (dropPs ds2 s v) as dv; destruct dv; auto. apply eq_sym, dropPs_Some in Heqdv; dest; subst. remember (dropPs ds1 s s0) as ds; destruct ds. + apply eq_sym, dropPs_Some in Heqds; dest; subst; auto. + exfalso; apply eq_sym, dropPs_None in Heqds. specialize (H0 s); destruct H0; auto. Qed.End LabelDrop.Section StepToRefinement. Variable imp spec: Modules. Variable p: MethsT -> MethsT. Variable ruleMap: RegsT -> string -> option string. Variable theta: RegsT -> RegsT. Variable thetaInit: theta (initRegs (getRegInits imp)) = initRegs (getRegInits spec). Definition liftPLabel o l := match l with | {| annot := a; defs := dfs; calls := clls |} => {| annot := match a with | Some (Some r) => Some (ruleMap o r) | Some None => Some None | None => None end; defs := p dfs; calls := p clls |} end. Variable stepMap: forall o u l, reachable o imp -> Step imp o u l -> exists uspec, Step spec (theta o) uspec (liftPLabel o l) /\ theta (M.union u o) = M.union uspec (theta o). Theorem stepRefinement': forall s sig, Behavior imp s sig -> exists sigSpec, Behavior spec (theta s) sigSpec /\ equivalentLabelSeq p sig sigSpec. 
precision + 1) with precision. replace (INR (nat_of_P (vNum b))) with (IZR (Zpos (vNum b))). rewrite pGivesBound; auto with real. simpl; unfold IZR; rewrite <- INR_IPR; auto. generalize precisionNotZero; case precision; simpl in |- *; auto with arith. intros H'1; Contradict H'1; auto. intros; rewrite plus_comm; simpl in |- *; auto. Qed. Theorem FnormalLtFirstNormalPos : forall p : float, Fnormal p -> (0 <= p)%R -> (firstNormalPos <= p)%R. intros p H' H'0. case (Rle_or_lt firstNormalPos p); intros Lt0; auto with real. case (FnormalLtPos p firstNormalPos); auto. apply firstNormalPosNormal. intros H'1; Contradict H'1; unfold firstNormalPos in |- *; simpl in |- *. apply Zle_not_lt; auto with float. intros H'1; elim H'1; intros H'2 H'3; Contradict H'3. unfold firstNormalPos in |- *; simpl in |- *. apply Zle_not_lt. rewrite <- (Zabs_eq (Fnum p)); auto with float zarith. apply pNormal_absolu_min; auto. apply LeR0Fnum with (radix := radix); auto with arith. Qed. Theorem FnormalLtFirstNormalNeg : forall p : float, Fnormal p -> (p <= 0)%R -> (p <= Fopp firstNormalPos)%R. intros p H' H'0. rewrite <- (Ropp_involutive p); unfold FtoRradix in |- *; repeat rewrite Fopp_correct. apply Ropp_le_contravar; rewrite <- Fopp_correct. apply FnormalLtFirstNormalPos. apply FnormalFop; auto. replace 0%R with (-0)%R; unfold FtoRradix in |- *; try rewrite Fopp_correct; auto with real. Qed. Theorem FsubnormalDigit : forall p : float, Fsubnormal p -> Fdigit radix p < precision. intros p H; unfold Fdigit in |- *. case (Z_eq_dec (Fnum p) 0); intros Z1. rewrite Z1; simpl in |- *; auto with arith. apply lt_S_n; apply le_lt_n_Sm. rewrite <- digitPredVNumiSPrecision. replace (S (digit radix (Fnum p))) with (digit radix (Fnum p) + 1). rewrite <- digitAdd; auto with zarith. apply digit_monotone; auto with float. rewrite (fun x => Zabs_eq (Zpred x)); auto with float zarith. rewrite Zmult_comm; rewrite Zpower_nat_1; auto with float zarith. rewrite plus_comm; simpl in |- *; auto. Qed. Hint Resolve FsubnormalDigit: float. Theorem pSubnormal_absolu_min : forall p : float, Fsubnormal p -> (Zabs (Fnum p) < nNormMin)%Z. intros p H'; apply Zlt_mult_simpl_l with (c := radix); auto with zarith. replace (radix * Zabs (Fnum p))%Z with (Zabs (radix * Fnum p)). replace (radix * nNormMin)%Z with (Zpos (vNum b)); auto with float. rewrite pGivesBound. replace precision with (1 + pred precision). rewrite Zpower_nat_is_exp; auto with zarith; rewrite Zpower_nat_1; auto. generalize precisionNotZero; case precision; simpl in |- *; auto. intros H; Contradict H; auto. rewrite Zabs_Zmult; rewrite (Zabs_eq radix); auto with zarith. Qed. Theorem FsubnormalLtFirstNormalPos : forall p : float, Fsubnormal p -> (0 <= p)%R -> (p < firstNormalPos)%R. 
*; injection 1. intros H3 H4; case (H0 H4). Defined. End LKey.Require Import ZArith. Module ZKey : KEY with Definition A := Z. Definition A := Z. Definition eqdec := Z_eq_dec. End ZKey. Module LZKey := LKey ZKey.Module PairKey (K1: KEY) (K2: KEY) : KEY with Definition A := (K1.A * K2.A)%type. Definition A := (K1.A * K2.A)%type. Definition eqdec : forall a b : A, {a = b} + {a <> b}. simple destruct a. intros a0 a1; simple destruct b; intros b0 b1. case (K1.eqdec a0 b0); intro H; case (K2.eqdec a1 b1); intro H0; [ left | right | right | right ]; try (rewrite H; rewrite H0; trivial); red in |- *; intro H1; injection H1; tauto. Defined. End PairKey. Module Type DEC_ORDER. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom ordered : order A le. Axiom lt_le_weak : forall a b : A, lt a b -> le a b. Axiom lt_diff : forall a b : A, lt a b -> a <> b. Axiom le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Parameter lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a}. End DEC_ORDER.Module Type MORE_DEC_ORDERS. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom le_trans : transitive A le. Axiom le_refl : reflexive A le. Axiom le_antisym : antisymmetric A le. Axiom lt_irreflexive : forall a : A, ~ lt a a. Axiom lt_trans : transitive A lt. Axiom lt_not_le : forall a b : A, lt a b -> ~ le b a. Axiom le_not_lt : forall a b : A, le a b -> ~ lt b a. Axiom lt_intro : forall a b : A, le a b -> a <> b -> lt a b. Parameter le_lt_dec : forall a b : A, {le a b} + {lt b a}. Parameter le_lt_eq_dec : forall a b : A, le a b -> {lt a b} + {a = b}. End MORE_DEC_ORDERS. Module More_Dec_Orders (D: DEC_ORDER) : MORE_DEC_ORDERS with Definition A := D.A with Definition le := D.le with Definition lt := D.lt. Definition A := D.A. Definition le := D.le. Definition lt := D.lt. Theorem le_trans : transitive A le. 
(@ipure I _ (@id X)) = id ; iapp_composition : forall {I J K L X Y Z} (u : F I J (Y -> Z)) (v : F J K (X -> Y)) (w : F K L X), ipure compose <**> u <**> v <**> w = u <**> (v <**> w) ; iapp_homomorphism : forall {I X Y} (x : X) (f : X -> Y), ipure f <**> ipure x = @ipure I _ (f x) ; iapp_interchange : forall {I J X Y} (y : X) (u : F I J (X -> Y)), u <**> ipure y = ipure (fun f => f y) <**> u; app_imap_unit : forall {I O X Y} (f : X -> Y), iap (ipure f) = @imap _ _ I O _ _ f }.Notation "ipure[ M ]" := (@ipure M _ _) (at level 9). Notation "ipure[ M N ]" := (@ipure (fun X => M (N X)) _ _) (at level 9).Notation "iap[ M ]" := (@iap M _ _ _) (at level 9). Notation "iap[ M N ]" := (@iap (fun X => M (N X)) _ _ _) (at level 9). Notation "iap[ M N O ]" := (@iap (fun X => M (N (O X))) _ _ _) (at level 9).Notation "f <**> g" := (iap f g) (at level 28, left associativity).Definition iapp_merge {X Y Z W} (f : X -> Y) (g : Z -> W) (t : X * Z) : Y * W := match t with (x, z) => (f x, g z) end.Definition iapp_prod {F : Type -> Type -> Type -> Type} `{IApplicative F} {I J K X Y} (x : F I J X) (y : F J K Y) : F I K (X * Y)%type := pair <$$> x <**> y.Notation "f *** g" := (iapp_merge f g) (at level 28, left associativity).Notation "f ** g" := (iapp_prod f g) (at level 28, left associativity).Ltac rewrite_iapp_homomorphisms := (repeat (rewrite <- app_imap_unit); rewrite iapp_homomorphism; repeat (rewrite app_imap_unit)).Section IApplicatives. Variable F : Type -> Type -> Type -> Type. Context `{IApplicative F}. Theorem app_imap_compose : forall I A B (f : A -> B), ipure \o f = @imap _ _ I I _ _ f \o @ipure _ _ I _. Proof. intros. extensionality x. unfold comp. rewrite <- iapp_homomorphism. rewrite app_imap_unit. reflexivity. Qed. Theorem app_imap_compose_x : forall I A B (f : A -> B) (x : A), ipure (f x) = imap f (@ipure _ _ I _ x). 
Require Import Coq.Lists.List. Require Import Bedrock.Expr Bedrock.Env. Require Import Bedrock.Prover. Require Import Bedrock.Reflection.Set Implicit Arguments. Set Strict Implicit.Local Notation "[ x , .. , y ]" := (cons x .. (cons y nil) ..).Section AssumptionProver. Variable types : list type. Variable fs : functions types. Definition assumption_summary : Type := list (expr types). Definition assumptionSummarize (hyps : list (expr types)) : assumption_summary := hyps. Fixpoint assumptionProve (hyps : assumption_summary) (goal : expr types) : bool := match hyps with | nil => false | exp :: b => if expr_seq_dec exp goal then true else assumptionProve b goal end. Definition assumptionLearn (sum : assumption_summary) (hyps : list (expr types)) : assumption_summary := sum ++ hyps. Definition assumptionValid (uvars vars : env types) (sum : assumption_summary) : Prop := AllProvable fs uvars vars sum. Lemma assumptionValid_extensible : forall u g f ue ge, assumptionValid u g f -> assumptionValid (u ++ ue) (g ++ ge) f. Proof. unfold assumptionValid. eauto using AllProvable_weaken. Qed. Lemma assumptionSummarizeCorrect : forall uvars vars hyps, AllProvable fs uvars vars hyps -> assumptionValid uvars vars (assumptionSummarize hyps). Proof. auto. Qed. Lemma assumptionLearnCorrect : forall uvars vars sum, assumptionValid uvars vars sum -> forall hyps, AllProvable fs uvars vars hyps -> assumptionValid uvars vars (assumptionLearn sum hyps). Proof. unfold assumptionLearn, assumptionValid. intuition. apply AllProvable_app; auto. Qed. Theorem assumptionProverCorrect : ProverCorrect fs assumptionValid assumptionProve. 
destruct (Xdiscr x x) as [ | [] ]; auto. + intros (n & Hn); revert Hn. case_eq (f n). * intros y Hy. destruct (Xdiscr x y) as [ -> | ]. - exists n; auto. - discriminate. * discriminate. Qed. Fact opt_enum_rec_enum_discrete_t P : opt_enum_t P -> rec_enum_t P. Proof using Xdiscr. intros (f & Hf). exists (fun n x => match f n with Some y => if Xdiscr x y then true else false | None => false end); intros x; rewrite Hf; split. + intros (n & Hn); exists n; rewrite <- Hn. destruct (Xdiscr x x) as [ | [] ]; auto. + intros (n & Hn); revert Hn. case_eq (f n). * intros y Hy. destruct (Xdiscr x y) as [ -> | ]. - exists n; auto. - discriminate. * discriminate. Qed. Fact rec_enum_opt_enum_type_enum P : rec_enum P -> opt_enum P. Proof using Xenum. destruct Xenum as (s & Hs). intros (Q & HQ). set (f n := let (a,b) := surj n in match s a with | Some x => if Q b x then Some x else None | None => None end). exists f; intros x; rewrite HQ; split; unfold f. + intros (n & Hn). destruct (Hs x) as (a & Ha). destruct (Hsurj a n) as (m & Hm). exists m; rewrite Hm, <- Ha, Hn; auto. + intros (n & Hn). destruct (surj n) as (a,b). destruct (s a) as [ y | ]; try discriminate. revert Hn; case_eq (Q b y). * inversion 2; exists b; auto. * discriminate. Qed. Fact rec_enum_opt_enum_type_enum_t P : rec_enum_t P -> opt_enum_t P. Proof using Xenum_t. destruct Xenum_t as (s & Hs). intros (Q & HQ). set (f n := let (a,b) := surj n in match s a with | Some x => if Q b x then Some x else None | None => None end). exists f; intros x; rewrite HQ; split; unfold f. + intros (n & Hn). destruct (Hs x) as (a & Ha). destruct (Hsurj a n) as (m & Hm). exists m; rewrite Hm, <- Ha, Hn; auto. + intros (n & Hn). destruct (surj n) as (a,b). destruct (s a) as [ y | ]; try discriminate. revert Hn; case_eq (Q b y). * inversion 2; exists b; auto. * discriminate. Qed. Hint Resolve opt_enum_rec_enum_discrete rec_enum_opt_enum_type_enum opt_enum_rec_enum_discrete_t rec_enum_opt_enum_type_enum_t : core. Theorem opt_rec_enum_equiv P : opt_enum P <-> rec_enum P. 
Proof. intros. inv H. intro. intros. assert (~ occurs_free_val (Vfun (M.empty cps.val) fl f) x). intro. apply H1 in H3. inv H3. clear H1. clear H2. assert (decidable (List.In x vs)). apply In_decidable. apply shrink_cps_correct.var_dec_eq. assert (decidable (name_in_fundefs fl x)). unfold decidable. assert (Hd := Decidable_name_in_fundefs fl). inv Hd. specialize (Dec x). inv Dec; auto. inv H1; inv H2; auto. exfalso. apply H3. constructor. SearchAbout occurs_free_fundefs find_def. eapply shrink_cps_correct.find_def_free_included. eauto. constructor. constructor. auto. auto. auto. apply M.gempty. Qed. Inductive dsubval_v: L6.cps.val -> L6.cps.val -> Prop := | dsubval_constr: forall v vs c, List.In v vs -> dsubval_v v (Vconstr c vs) | dsubval_fun : forall x fds rho f, name_in_fundefs fds x -> dsubval_v (Vfun rho fds x) (Vfun rho fds f) .Definition subval_v := clos_trans _ dsubval_v. Definition subval_or_eq := clos_refl_trans _ dsubval_v. Theorem t_then_rt: forall A R (v v':A), clos_trans _ R v v' -> clos_refl_trans _ R v v'. Proof. intros. induction H. apply rt_step. auto. eapply rt_trans; eauto. Qed. Theorem rt_then_t_or_eq: forall A R (v v':A), clos_refl_trans _ R v v' -> v = v' \/ clos_trans _ R v v'. Proof. intros. induction H. right. apply t_step; auto. left; auto. inv IHclos_refl_trans1; inv IHclos_refl_trans2. left; auto. right; auto. right; auto. right. eapply t_trans; eauto. Qed.Theorem dsubterm_case_cons: forall v l e', dsubterm_e e' (Ecase v l) -> forall a, dsubterm_e e' (Ecase v (a:: l)). Proof. intros. inv H. econstructor. right; eauto. Qed. Theorem subterm_case: forall v l e', subterm_e e' (Ecase v l) -> forall a, subterm_e e' (Ecase v (a:: l)). Proof. intros. remember (Ecase v l) as y. revert dependent v. revert l. induction H. - intros. subst. constructor. eapply dsubterm_case_cons; eauto. - intros. apply IHclos_trans2 in Heqy. eapply t_trans. apply H. eauto. Qed. Theorem subval_fun: forall v rho fl x, name_in_fundefs fl x -> subval_or_eq v (Vfun rho fl x) -> exists l, v = Vfun rho fl l /\ name_in_fundefs fl l. Proof. intros. apply rt_then_t_or_eq in H0. inv H0. exists x; auto. remember (Vfun rho fl x) as y. assert (exists x, y = Vfun rho fl x /\ name_in_fundefs fl x ) by eauto. clear H. clear Heqy. clear x. induction H1. destructAll. subst. inv H. eauto. destructAll. assert ( (exists x : var, Vfun rho fl x0 = Vfun rho fl x /\ name_in_fundefs fl x)) by eauto. apply IHclos_trans2 in H. apply IHclos_trans1 in H. auto. Qed. Theorem subval_or_eq_constr: forall v v' vs c, subval_or_eq v v' -> List.In v' vs -> subval_or_eq v (Vconstr c vs). 
eps <= ulp x)%R -> round beta fexp Zceil (x + eps) = (x + ulp x)%R. Proof with auto with typeclass_instances. intros x Zx Fx eps. case Zx; intros Zx1.intros (Heps1,[Heps2|Heps2]). assert (Heps: (0 <= eps < ulp x)%R). split. now apply Rlt_le. exact Heps2. assert (Hd := round_DN_plus_eps_pos x Zx Fx eps Heps). rewrite round_UP_DN_ulp. rewrite Hd. rewrite 2!ulp_neq_0. unfold canonic_exp. now rewrite ln_beta_plus_eps. now apply Rgt_not_eq. now apply Rgt_not_eq, Rplus_lt_0_compat. intros Fs. rewrite round_generic in Hd... apply Rgt_not_eq with (2 := Hd). pattern x at 2 ; rewrite <- Rplus_0_r. now apply Rplus_lt_compat_l. rewrite Heps2. apply round_generic... now apply generic_format_succ_aux1.rewrite <- Zx1, 2!Rplus_0_l. intros Heps. case (proj2 Heps). unfold round, scaled_mantissa, canonic_exp. unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros H2. intros J; absurd (0 < 0)%R; auto with real. apply Rlt_trans with eps; try assumption; apply Heps. intros n Hn H. assert (fexp (ln_beta beta eps) = fexp n). apply valid_exp; try assumption. assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega]. apply lt_bpow with beta. apply Rle_lt_trans with (2:=H). destruct (ln_beta beta eps) as (e,He). simpl; rewrite Rabs_pos_eq in He. now apply He, Rgt_not_eq. now left. replace (Zceil (eps * bpow (- fexp (ln_beta beta eps)))) with 1%Z. unfold F2R; simpl; rewrite H0; ring. apply sym_eq, Zceil_imp. split. simpl; apply Rmult_lt_0_compat. apply Heps. apply bpow_gt_0. apply Rmult_le_reg_r with (bpow (fexp n)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus. rewrite H0; ring_simplify (-fexp n + fexp n)%Z. simpl; rewrite Rmult_1_l, Rmult_1_r. now left. intros P; rewrite P. apply round_generic... apply generic_format_ulp_0. Qed. Theorem round_UP_pred_plus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x) )%R -> round beta fexp Zceil (pred x + eps) = x. Proof. intros x Hx Fx eps Heps. rewrite round_UP_plus_eps_pos; trivial. rewrite pred_eq_pos. apply pred_pos_plus_ulp; trivial. now left. now apply pred_ge_0. apply generic_format_pred; trivial. Qed.Theorem round_DN_minus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x))%R -> round beta fexp Zfloor (x - eps) = pred x. Proof. intros x Hpx Fx eps. rewrite pred_eq_pos;[intros Heps|now left]. replace (x-eps)%R with (pred_pos x + (ulp (pred_pos x)-eps))%R. 2: pattern x at 3; rewrite <- (pred_pos_plus_ulp x); trivial. 2: ring. rewrite round_DN_plus_eps_pos; trivial. now apply pred_pos_ge_0. now apply generic_format_pred_pos. split. apply Rle_0_minus. now apply Heps. rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. now apply Heps. Qed. Theorem round_DN_plus_eps: forall x, F x -> forall eps, (0 <= eps < if (Rle_bool 0 x) then (ulp x) else (ulp (pred (-x))))%R -> round beta fexp Zfloor (x + eps) = x. 
Require Export List. Require Import Inclusion. Require Import Inverse_Image. Require Import Wf_nat. Require Import Relation_Definitions. Require Import Relation_Operators. Require Import Relation_Operators_compat. Require Import Lexicographic_Product. Require Import LetP. Require Export WfR0. Section Buch. Load "hCoefStructure". Load "hOrderStructure". Load "hWfRO". Inductive stable : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop := stable0 : forall P Q : list (poly A0 eqA ltM), (forall a : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q) -> (forall a : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable P Q. Hint Resolve stable0. Theorem stable_refl : forall Q : list (poly A0 eqA ltM), stable Q Q. 
intros p l2 H a H0. rewrite H; auto. red in |- *; intros H1; discriminate. Qed. Definition pbbuild (l : code A) : pbtree := fold_right (fun a c => pbadd (fst a) c (snd a)) (pbleaf empty) l. Theorem pbfree_pbbuild_prop1 : forall a l1 l2, l2 <> nil -> unique_prefix ((a, l1) :: l2) -> pbfree l1 (pbbuild l2). Proof using. intros a l1 l2; generalize a l1; elim l2; clear a l1 l2; simpl in |- *; auto. intros a l1 H; elim H; auto. intros (a1, l1) l; case l. unfold pbbuild in |- *; simpl in |- *; intros H a l0 H0 H1; apply pbfree_pbadd_prop1. red in |- *; intros H2; absurd (a = a1). red in |- *; intros H3; case unique_key_in with (a := a) (b1 := l0) (b2 := l1) (1 := unique_prefix2 _ _ H1); simpl in |- *; auto. rewrite H3; auto. apply unique_prefix1 with (1 := H1) (lb1 := l0) (lb2 := l1); simpl in |- *; auto. red in |- *; intros H2; absurd (a = a1). red in |- *; intros H3; case unique_key_in with (a := a) (b1 := l0) (b2 := l1) (1 := unique_prefix2 _ _ H1); simpl in |- *; auto. rewrite H3; auto. apply sym_equal; apply unique_prefix1 with (1 := H1) (lb1 := l1) (lb2 := l0); simpl in |- *; auto. intros p l0 H a l2 H0 H1. unfold pbbuild in |- *; simpl in |- *. apply pbfree_pbadd_prop2; auto. apply H with (a := a). red in |- *; intros; discriminate. apply unique_prefix_inv with (a := a1) (l := l1). apply unique_prefix_permutation with (2 := H1); auto. red in |- *; intros H2; absurd (a = a1). red in |- *; intros H3; case unique_key_in with (a := a) (b1 := l2) (b2 := l1) (1 := unique_prefix2 _ _ H1); simpl in |- *; auto. rewrite H3; auto. apply sym_equal; apply unique_prefix1 with (1 := H1) (lb1 := l1) (lb2 := l2); simpl in |- *; auto. red in |- *; intros H2; absurd (a = a1). red in |- *; intros H3; case unique_key_in with (a := a) (b1 := l2) (b2 := l1) (1 := unique_prefix2 _ _ H1); simpl in |- *; auto. rewrite H3; auto. apply unique_prefix1 with (1 := H1) (lb1 := l2) (lb2 := l1); simpl in |- *; auto. Qed. Theorem all_pbleaves_compute_pb : forall t, permutation (map (fst (B:=_)) (compute_pbcode t)) (all_pbleaves t). 
Require Import Verdi.GhostSimulations.Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.CommonTheorems.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.LeadersHaveLeaderLogsStrongInterface. Require Import VerdiRaft.SortedInterface. Require Import VerdiRaft.LogMatchingInterface. Require Import VerdiRaft.AppendEntriesRequestLeaderLogsInterface. Require Import VerdiRaft.NextIndexSafetyInterface.Section AppendEntriesRequestLeaderLogs. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {lhllsi : leaders_have_leaderLogs_strong_interface}. Context {rri : raft_refinement_interface}. Context {si : sorted_interface}. Context {lmi : log_matching_interface}. Context {nisi : nextIndex_safety_interface}. Theorem lift_sorted : forall net, refined_raft_intermediate_reachable net -> logs_sorted (deghost net). Proof using si rri. intros. eapply lift_prop; eauto using logs_sorted_invariant. Qed. Theorem lift_logs_sorted : forall net h, refined_raft_intermediate_reachable net -> sorted (log (snd (nwState net h))). Proof using si rri. intros. find_apply_lem_hyp lift_sorted. unfold logs_sorted, logs_sorted_host in *. intuition. unfold deghost in *. simpl in *. break_match; eauto. Qed. Theorem lift_log_matching : forall net, refined_raft_intermediate_reachable net -> log_matching (deghost net). 
-> (ex <= fexp ex)%Z -> (0 < x * bpow (- fexp ex) < 1)%R. Proof. intros x ex Hx He. split. apply Rmult_lt_0_compat. apply Rlt_le_trans with (2 := proj1 Hx). apply bpow_gt_0. apply bpow_gt_0. apply Rmult_lt_reg_r with (bpow (fexp ex)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l. rewrite Rmult_1_r, Rmult_1_l. apply Rlt_le_trans with (1 := proj2 Hx). now apply bpow_le. Qed.Theorem scaled_mantissa_lt_1 : forall x ex, (Rabs x < bpow ex)%R -> (ex <= fexp ex)%Z -> (Rabs (scaled_mantissa x) < 1)%R. Proof. intros x ex Ex He. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, scaled_mantissa_0, Rabs_R0. now apply IZR_lt. rewrite <- scaled_mantissa_abs. unfold scaled_mantissa. rewrite cexp_abs. unfold cexp. destruct (mag beta x) as (ex', Ex'). simpl. specialize (Ex' Zx). apply (mantissa_small_pos _ _ Ex'). assert (ex' <= fexp ex)%Z. apply Z.le_trans with (2 := He). apply bpow_lt_bpow with beta. now apply Rle_lt_trans with (2 := Ex). now rewrite (proj2 (proj2 (valid_exp _) He)). Qed.Theorem scaled_mantissa_lt_bpow : forall x, (Rabs (scaled_mantissa x) < bpow (mag beta x - cexp x))%R. Proof. intros x. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, scaled_mantissa_0, Rabs_R0. apply bpow_gt_0. apply Rlt_le_trans with (1 := bpow_mag_gt beta _). apply bpow_le. unfold scaled_mantissa. rewrite mag_mult_bpow with (1 := Zx). apply Z.le_refl. Qed.Theorem mag_generic_gt : forall x, (x <> 0)%R -> generic_format x -> (cexp x < mag beta x)%Z. Proof. intros x Zx Gx. apply Znot_ge_lt. unfold cexp. destruct (mag beta x) as (ex,Ex) ; simpl. specialize (Ex Zx). intros H. apply Z.ge_le in H. generalize (scaled_mantissa_lt_1 x ex (proj2 Ex) H). contradict Zx. rewrite Gx. replace (Ztrunc (scaled_mantissa x)) with Z0. apply F2R_0. cut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z. clear ; lia. apply lt_IZR. rewrite abs_IZR. now rewrite <- scaled_mantissa_generic. Qed.Lemma mantissa_DN_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> Zfloor (x * bpow (- fexp ex)) = Z0. Proof. intros x ex Hx He. apply Zfloor_imp. simpl. assert (H := mantissa_small_pos x ex Hx He). split ; try apply Rlt_le ; apply H. Qed.Lemma mantissa_UP_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> Zceil (x * bpow (- fexp ex)) = 1%Z. Proof. intros x ex Hx He. apply Zceil_imp. simpl. assert (H := mantissa_small_pos x ex Hx He). split ; try apply Rlt_le ; apply H. Qed. Theorem generic_format_discrete : forall x m, let e := cexp x in (F2R (Float beta m e) < x < F2R (Float beta (m + 1) e))%R -> ~ generic_format x. 
apply powerRZ_NOR; auto with real zarith. Qed. Theorem NisFzeroComp : forall x y : float, ~ is_Fzero x -> x = y :>R -> ~ is_Fzero y. intros x y H' H'0; Contradict H'. apply is_Fzero_rep2; auto. rewrite H'0. apply is_Fzero_rep1; auto. Qed. Theorem Rlt_monotony_exp : forall (x y : R) (z : Z), (x < y)%R -> (x * powerRZ radix z < y * powerRZ radix z)%R. intros x y z H'; apply Rmult_lt_compat_r; auto with real zarith. Qed. Theorem Rle_monotone_exp : forall (x y : R) (z : Z), (x <= y)%R -> (x * powerRZ radix z <= y * powerRZ radix z)%R. intros x y z H'; apply Rmult_le_compat_r; auto with real zarith. Qed. Theorem Rlt_monotony_contra_exp : forall (x y : R) (z : Z), (x * powerRZ radix z < y * powerRZ radix z)%R -> (x < y)%R. intros x y z H'; apply Rmult_lt_reg_l with (r := powerRZ radix z); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix z)); auto. Qed. Theorem Rle_monotony_contra_exp : forall (x y : R) (z : Z), (x * powerRZ radix z <= y * powerRZ radix z)%R -> (x <= y)%R. intros x y z H'; apply Rmult_le_reg_l with (r := powerRZ radix z); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix z)); auto. Qed. Theorem FtoREqInv1 : forall p q : float, ~ is_Fzero p -> p = q :>R -> Fnum p = Fnum q -> p = q. intros p q H' H'0 H'1. apply floatEq; auto. unfold FtoR in H'0. apply Rpow_eq_inv with (r := IZR radix); auto 6 with real zarith. apply Rlt_dichotomy_converse; right; red in |- *. unfold Rabs in |- *; case (Rcase_abs radix). intros H'2; Contradict H'2; apply Rle_not_lt; apply Ropp_le_cancel; auto with real. intros H'2; replace 1%R with (IZR 1); auto with real zarith. apply Rmult_eq_reg_l with (r := IZR (Fnum p)); auto with real. pattern (Fnum p) at 2 in |- *; rewrite H'1; auto. Qed. Theorem FtoREqInv2 : forall p q : float, p = q :>R -> Fexp p = Fexp q -> p = q. intros p q H' H'0. apply floatEq; auto. apply eq_IZR; auto. apply Rmult_eq_reg_l with (r := powerRZ radix (Fexp p)); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix (Fexp p))); pattern (Fexp p) at 2 in |- *; rewrite H'0; auto with real zarith. Qed. Theorem Rlt_Float_Zlt : forall p q r : Z, (Float p r < Float q r)%R -> (p < q)%Z. 
b nZb q). intros a b p q H'; elim H'; simpl in |- *; auto. intros ma mb p0 q0 H'0 H'1 H'2 H'3 H'4 H'5 H'6 H'7. cut (canonical A0 eqA ltM p0); [ intros Op1 | apply canonical_imp_canonical with (a := ma); auto ]. cut (canonical A0 eqA ltM q0); [ intros Op2 | apply canonical_imp_canonical with (a := mb); auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) ma); [ intros Z0 | apply canonical_nzeroP with (ltM := ltM) (p := p0); auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) mb); [ intros Z1 | apply canonical_nzeroP with (ltM := ltM) (p := q0); auto ]. auto. Qed. Theorem Dmult_is_mulpf : forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqP A eqA n (Dmult a nZa (mults (A:=A) multA (n:=n) a p) q) (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q). intros a nZa p; elim p; simpl in |- *; auto. intros a0 l H'0 q H'1 H'2. cut (canonical A0 eqA ltM l); [ intros Op0 | apply canonical_imp_canonical with (a := a0); auto ]. cut (canonical A0 eqA ltM (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec l q)); [ intros Op1 | auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) a0); [ intros Z0 | apply canonical_nzeroP with (ltM := ltM) (p := l); auto ]. apply eqp_pluspf_com with (1 := cs); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (multTerm (A:=A) multA (n:=n) a a0) (b:=a) nZa) q). apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n). apply divp_is_multTerm; auto. apply mults_comp with (1 := cs); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) a0 (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=a) nZa)); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (multTerm (A:=A) multA (n:=n) a0 a) (b:=a) nZa); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem sp_Rminus : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q : list (Term A n)), canonical A0 eqA ltM (pX a p) -> canonical A0 eqA ltM (pX b q) -> eqP A eqA n (Rminus b nZb (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) b p) (mults (A:=A) multA (n:=n) a q)) (pX b q) (mults (A:=A) multA (n:=n) b p)) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec (pX a p) q)). 
hinhfun ( hfibersftogf f g z ye ) ) . apply ( isf ) . Defined . Notation issurjtwooutof3c := issurjcomp . Lemma issurjtwooutof3b { X Y Z : UU } ( f : X -> Y ) ( g : Y -> Z ) ( isgf : issurjective ( funcomp f g ) ) : issurjective g . Proof . intros . unfold issurjective . intro z . apply ( hinhfun ( hfibersgftog f g z ) ( isgf z ) ) . Defined . Lemma isweqinclandsurj { X Y : hSet } ( f : X -> Y ) ( is1 : isincl f ) ( is1 : issurjective f ) : isweq f . Proof . intros . unfold isweq . intro y . assert ( isp : isaprop ( hfiber f y ) ) . apply ( is1 y ) . apply iscontraprop1 . apply isp . apply ( @hinhuniv _ ( hProppair _ isp ) ( idfun _ ) ( is0 y ) ) . Defined . Definition setquot { X : UU } ( R : hrel X ) := total2 ( fun A : _ => iseqclass R A ) . Definition setquotpair { X : UU } ( R : hrel X ) ( A : hsubtypes X ) ( is : iseqclass R A ) := tpair _ A is . Definition pr1setquot { X : UU } ( R : hrel X ) : setquot R -> ( hsubtypes X ) := @pr1 _ ( fun A : _ => iseqclass R A ) . Coercion pr1setquot : setquot >-> hsubtypes . Lemma isinclpr1setquot { X : UU } ( R : hrel X ) : isincl ( pr1setquot R ) . Proof . intros . apply isinclpr1. intro x0. apply isapropiseqclass. Defined . Definition setquottouu0 { X : UU } ( R : hrel X ) ( a : setquot R ) := carrier ( pr1 a ). Coercion setquottouu0 : setquot >-> Sortclass. Theorem isasetsetquot { X : UU } ( R : hrel X ) : isaset ( setquot R ) . Proof. intros. apply ( isasetsubset ( @pr1 _ _ ) ( isasethsubtypes X ) ) . apply isinclpr1. intro. apply isapropiseqclass. Defined. Definition setquotinset { X : UU } ( R : hrel X ) : hSet := hSetpair _ ( isasetsetquot R ) . Theorem setquotpr { X : UU } ( R : eqrel X ) : X -> setquot R. 
_ => x end. Definition hd_error (l:list A) := match l with | [] => None | x :: _ => Some x end. Definition tl (l:list A) := match l with | [] => nil | a :: m => m end. Definition length (A : Type) : list A -> nat := fix length l := match l with | nil => O | _ :: l' => S (length l') end. Definition app (A : Type) : list A -> list A -> list A := fix app l m := match l with | nil => m | a :: l1 => a :: app l1 m end. Fixpoint In (a:A) (l:list A) : Prop := match l with | [] => False | b :: m => b = a \/ In a m end.End Lists.Infix "++" := app (right associativity, at level 60).Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), [] <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = []}. Proof. induction l as [|a tail]. right; reflexivity. left; exists a, tail; reflexivity. Qed. Lemma hd_error_tl_repr : forall l (a:A) r, hd_error l = Some a /\ tl l = r <-> l = a :: r. Proof. destruct l as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. 
p /\ path_cost g p == Some n = true. Proof. intros. split; intros. - unfold spLength in H. unfold "∘" in H. unfold RootPath.getDistance in H. destruct (RootPath.findP u (spTree v g)) eqn : R. rewrite some_none_eq in H. inversion H. destruct l. apply findP_In in R. destruct_all. simpl in H1. inversion H1; subst. apply spTree_shortest_paths in H0. exists (unlabel_path (LP ((u, n) :: l0))). destruct_all. split. assumption. rewrite H2. assumption. intro. inversion H0. - destruct (spLength v u g) eqn : V. unfold spLength in V. unfold "∘" in V. unfold RootPath.getDistance in V. destruct (RootPath.findP u (spTree v g)) eqn : R. inversion V. destruct l. inversion V; subst. apply findP_In in R. destruct_all. simpl in H1. inversion H1; subst. apply spTree_shortest_paths in H0. destruct_all. pose proof sp_distance_unique. simpl in H4. destruct (Base.EqLaws_option). eapply Eq_trans. rewrite <- H3. apply Eq_refl. eapply Eq_trans. eapply H4. assumption. assumption. apply H0. apply H. assumption. intro. inversion H0. unfold spLength in V. unfold "∘" in V. unfold RootPath.getDistance in V. destruct (RootPath.findP u (spTree v g)) eqn : R. rewrite findP_nil in R. pose proof spTree_reachable v u. assert ((exists p : LPath b, In p (spTree v g) /\ shortest_wpath g v u (unlabel_path p))). apply H0. destruct_all. exists x. unfold shortest_wpath in H. apply H. clear H0. destruct H1. destruct_all. destruct x. apply R in H0. destruct unLPath. simpl in H1. unfold shortest_wpath in H1. destruct_all. inversion H1. simpl in H1. destruct l. simpl in H0. simpl in H1. unfold shortest_wpath in H1. destruct_all. rewrite path'_WPath in H1. destruct_all. apply hd_path in H1. subst. contradiction. assumption. assumption. destruct l. inversion V. Qed.Lemma getLPathNodes_unlabel: forall l v, RootPath.getLPathNodes v l = unlabel_path (RootPath.getLPath v l). Proof. intros. unfold RootPath.getLPathNodes. unfold Tuple.fst. unfold unlabel_path. reflexivity. Qed.Theorem sp_finds_shortest_path: forall v u p, sp v u g = Some p -> shortest_wpath g v u (rev p). Proof. intros. - unfold sp in H. rewrite getLPathNodes_unlabel in H. destruct (unlabel_path (RootPath.getLPath u (spTree v g))) eqn : U. inversion H. inversion H; subst. unfold RootPath.getLPath in U. unfold "∘" in U. rewrite <- U. simpl. rewrite <- map_rev. rewrite hs_coq_reverse. rewrite rev_involutive. destruct (RootPath.findP u (spTree v g)) eqn : R. simpl in U. inversion U. apply findP_In in R. destruct_all. destruct l. apply spTree_shortest_paths in H0. destruct_all. simpl in H0. simpl. simpl in H1. inversion H1; subst. assumption. intro. inversion H0. Qed. Theorem sp_iff_shortest_path: forall v u, (exists p, sp v u g = Some p) <-> (exists p', shortest_wpath g v u p'). 
beta1 beta2 n gamma) = [alpha, (gcons beta1 beta2 n gamma)]. Proof. cbn; intros until n; case n; destruct 1; auto with T2. generalize H; case gamma; auto with T2. - destruct 1. + discriminate H0. + lt_clean. - intro t;case t. + intro t0;case t0. * destruct 1. discriminate H0. inversion H0; lt_clean; auto with T2. * auto with T2. + auto with T2. - lt_clean; auto with T2. Qed. Lemma phi_fix alpha beta : phi alpha beta = beta -> {beta1 : T2 & {beta2 : T2 | beta = [beta1, beta2] /\ alpha t2< beta1}}. Proof. destruct beta;simpl. discriminate 1. - case n. + case beta3. * case_eq (compare alpha beta1). -- intros H H0; injection H0. intro; absurd (lt beta2 [beta1, beta2]). ++ rewrite H1; apply lt_irr. ++ refine (lt_beta_psi _ _). -- exists beta1, beta2; split;auto with T2. -- intros H H0; injection H0. intro H1; absurd (beta2 t2< [beta1, beta2]). ++ rewrite H1;apply lt_irr. ++ refine (lt_beta_psi _ _). * destruct t;simpl. destruct t;simpl. destruct t;simpl. case (compare alpha beta1). all: try discriminate 1. + discriminate 1. Qed. Lemma phi_le : forall alpha beta alpha' beta', nf beta -> phi alpha beta = [alpha', beta'] -> alpha t2<= alpha'. Proof. intros a b a' b' Hb;case (phi_cases a Hb). - destruct 1. + case (phi_fix _ e); intros x (beta2,(H,H0)). rewrite e, H; injection 1; intros; subst x; right;auto with T2. + rewrite e;injection 1;left;auto with T2. - intros (b0,(H1,(H2,H3))). rewrite H2; injection 1;left;auto with T2. Qed.Lemma phi_le_ge : forall alpha beta, nf alpha -> nf beta -> {alpha':T2 & {beta':T2 | phi alpha beta = [alpha' ,beta'] /\ alpha t2<= alpha' /\ beta' t2<= beta}}. Proof. intros a b Va Vb; case (phi_cases' a Vb). - destruct 1. + case s; intros b1 (b2,(H1,(H2,H3))). rewrite H1 in H3; subst b. exists b1;exists b2;repeat split;auto with T2. + exists a, b;auto with T2. - intros (b1,(b2,(n,(H1,(H2,H3))))); exists a, (gcons b1 b2 0 (fin n));auto with T2. repeat split;auto with T2. subst b;case n;simpl; auto with T2. right;auto with T2. Qed.Theorem phi_spec1 : forall alpha beta gamma, nf alpha -> nf beta -> nf gamma -> gamma t2< alpha -> phi gamma (phi alpha beta) = phi alpha beta. Proof. intros; case (phi_le_ge H H0 ). - intros alpha' (beta', (H'1,(H'2,H'3))); rewrite H'1; cbn. rewrite (compare_rw_lt);auto with T2. apply lt_le_trans with alpha;auto with T2. Qed. Theorem phi_principalR alpha beta : nf alpha -> nf beta -> {gamma:T2 | [alpha, beta] = phi zero gamma}. 
eqA ltM)), In a (addEnd a aL). intros a aL; elim aL; simpl in |- *; auto. Qed. Theorem addEnd_id2 : forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), In a aL -> In a (addEnd b aL). intros a b aL; elim aL; simpl in |- *; auto. intros a0 l H' H'0; case H'0; auto. Qed. Lemma addEnd_app : forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), addEnd a P = P ++ a :: nil. intros a P; elim P; simpl in |- *; auto. intros a0 l H'; elim H'; auto. Qed. Definition spolyp : poly A0 eqA ltM -> poly A0 eqA ltM -> poly A0 eqA ltM. intros p q; case p; case q. intros x Cpx x0 Cpx0; exists (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cpx Cpx0); auto. apply spolyf_canonical with (1 := cs); auto. Defined. Theorem red_com : forall (a b : poly A0 eqA ltM) (aL : list (poly A0 eqA ltM)), red (spolyp a b) aL -> red (spolyp b a) aL. intros a b; case a; case b; simpl in |- *. unfold red in |- *; simpl in |- *. intros x Cx x0 Cx0 aL H'1; inversion H'1. cut (canonical A0 eqA ltM (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cx Cx0)); [ intros Op1 | apply spolyf_canonical with (1 := cs) ]; auto. cut (canonical A0 eqA ltM (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x0 x Cx0 Cx)); [ intros Op2 | apply spolyf_canonical with (1 := cs) ]; auto. apply reducestar0; auto. apply reduceplus_eqp_com with (1 := cs) (p := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cx Cx0)) (q := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (pO A n)); auto. apply reduceplus_mults with (1 := cs); auto. inversion H; auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply spolyf_com with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply spolyf_com with (1 := cs); auto. Qed. Theorem rstar_rtopO : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), canonical A0 eqA ltM p -> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (pO A n) -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (pO A n). 
auto. destruct o; auto. destruct m2; auto. destruct (remove i m1); auto. destruct m1; auto. destruct m2; auto. } rewrite REMOVE. destruct i; simpl in H. + destruct (IHm2 i (xI j) H) as (l1 & l2 & EQ & EQ'). exists (xelements m1 (xO j) nil ++ match o with None => nil | Some x => (prev j, x) :: nil end ++ l1); exists l2; split. rewrite xelements_node, EQ, ! app_ass. auto. rewrite xelements_node, EQ', ! app_ass. auto. + destruct (IHm1 i (xO j) H) as (l1 & l2 & EQ & EQ'). exists l1; exists (l2 ++ match o with None => nil | Some x => (prev j, x) :: nil end ++ xelements m2 (xI j) nil); split. rewrite xelements_node, EQ, ! app_ass. auto. rewrite xelements_node, EQ', ! app_ass. auto. + subst o. exists (xelements m1 (xO j) nil); exists (xelements m2 (xI j) nil); split. rewrite xelements_node. rewrite prev_append_prev. auto. rewrite xelements_node; auto. Qed. Theorem elements_remove: forall (A: Type) i v (m: t A), get i m = Some v -> exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2. Proof. intros. exploit xelements_remove. eauto. instantiate (1 := xH). rewrite prev_append_prev. auto. Qed. Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B) (i: positive) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := xfold f (xO i) l v in xfold f (xI i) r v1 | Node l (Some x) r => let v1 := xfold f (xO i) l v in let v2 := f v1 (prev i) x in xfold f (xI i) r v2 end. Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) := xfold f xH m v. Lemma xfold_xelements: forall (A B: Type) (f: B -> positive -> A -> B) m i v l, List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. 
with | Gstruct s => Some s.(s_size) | Gunion u => Some u.(u_size) | _ => None end. Definition GlobDecl_align_of (g : GlobDecl) : option N := match g with | Gstruct s => Some s.(s_alignment) | Gunion u => Some u.(u_alignment) | _ => None end. Variant Roption_leq {T} (R : T -> T -> Prop) : option T -> option T -> Prop := | Rleq_None {x} : Roption_leq R None x | Rleq_Some {x y} (_ : R x y) : Roption_leq R (Some x) (Some y). #[global] Instance proper_GlobDecl_size_of: Proper (GlobDecl_ler ==> Roption_leq eq) GlobDecl_size_of. Proof. rewrite /GlobDecl_size_of => x y Heq. repeat (case_match; try constructor); simplify_eq/= => //; apply require_eq_success in Heq; naive_solver. Qed. #[global] Instance proper_GlobDecl_align_of: Proper (GlobDecl_ler ==> Roption_leq eq) GlobDecl_align_of. Proof. rewrite /GlobDecl_align_of => x y Heq. repeat (case_match; try constructor); simplify_eq/= => //; apply require_eq_success in Heq; naive_solver. Qed.Fixpoint size_of (resolve : genv) (t : type) : option N := match t with | Tpointer _ => Some (pointer_size resolve) | Tref _ => None | Trv_ref _ => None | Tnum sz _ => Some (bytesN sz) | Tvoid => None | Tarray t n => N.mul n <$> size_of resolve t | Tnamed nm => glob_def resolve nm ≫= GlobDecl_size_of | Tfunction _ _ => None | Tbool => Some 1 | Tmember_pointer _ _ => None | Tqualified _ t => size_of resolve t | Tnullptr => Some (pointer_size resolve) | Tfloat sz => Some (bytesN sz) | Tarch sz _ => bytesN <$> sz end%N.#[global] Instance Proper_size_of : Proper (genv_leq ==> eq ==> Roption_leq eq) (@size_of). Proof. intros ?? Hle ? t ->; induction t; simpl; (try constructor) => //. all: try exact: pointer_size_proper. - by destruct IHt; constructor; subst. - move: Hle => [[ /(_ g) Hle _] _ _]. unfold glob_def. rewrite -tu_lookup_globals in Hle. destruct ((genv_tu x) !! g) as [g1| ]; last constructor. move: Hle => /(_ _ eq_refl). rewrite -tu_lookup_globals. move => [g2 [-> HH]] /=. exact: proper_GlobDecl_size_of. - by destruct o; constructor. Qed. Theorem size_of_int : forall {c : genv} s w, @size_of c (Tnum w s) = Some (bytesN w). Proof. reflexivity. Qed. Theorem size_of_char : forall {c : genv} s w, @size_of c (Tchar w s) = Some (bytesN w). Proof. reflexivity. Qed. Theorem size_of_bool : forall {c : genv}, @size_of c Tbool = Some 1%N. Proof. reflexivity. Qed. Theorem size_of_pointer : forall {c : genv} t, @size_of c (Tpointer t) = Some (pointer_size c). 
bk H M) eqs -> Forall (msem_equation G bk H (add_val_n x ms M)) eqs. Proof. Hint Constructors msem_equation. intros * Hnd Hsem. induction eqs as [|eq eqs IH]; [now constructor|]. apply not_Is_defined_in_cons in Hnd. destruct Hnd as [Hnd Hnds]. apply Forall_cons2 in Hsem. destruct Hsem as [Hsem Hsems]. constructor; [|now apply IH with (1:=Hnds) (2:=Hsems)]. destruct Hsem; eauto. apply not_Is_defined_in_eq_EqFby in Hnd. eapply SEqFby; eauto. Qed. Lemma msem_equation_madd_inst: forall G bk H M Mx x eqs, ~Is_defined_in x eqs -> Forall (msem_equation G bk H M) eqs -> Forall (msem_equation G bk H (add_inst_n x Mx M)) eqs. Proof. Hint Constructors msem_equation. intros * Hnd Hsem. induction eqs as [|eq eqs IH]; [now constructor|]. apply not_Is_defined_in_cons in Hnd. destruct Hnd as [Hnd Hnds]. apply Forall_cons2 in Hsem. destruct Hsem as [Hsem Hsems]. constructor; [|now apply IH with (1:=Hnds) (2:=Hsems)]. destruct Hsem as [|??? x' ??????? Hsome |??? x' ??????????? Hsome|]; eauto; assert (sub_inst_n x' (add_inst_n x Mx M) Mx0) by (apply not_Is_defined_in_eq_EqApp in Hnd; unfold add_inst_n in *; intro; rewrite find_inst_gso; auto; intro; subst x; destruct xs; inv Hsome; apply Hnd; now constructor); eauto. Qed. Lemma memory_closed_n_App: forall M eqs i Mx xs ck f es r, memory_closed_n M eqs -> hd_error xs = Some i -> memory_closed_n (add_inst_n i Mx M) (EqApp xs ck f es r :: eqs). Proof. intros * WF Hd n; specialize (WF n); destruct WF as (Insts &?). split; auto. intro y; intros * Hin. unfold add_inst_n in Hin; apply not_None_is_Some in Hin as (?& Find). destruct (ident_eq_dec y i). - subst. unfold gather_insts; simpl. destruct xs; simpl in *; inv Hd; left; auto. - rewrite find_inst_gso in Find; auto. unfold gather_insts; simpl. apply InMembers_app; right; auto. apply Insts; eauto. apply not_None_is_Some; eauto. Qed. Lemma memory_closed_n_Fby: forall M eqs x ck v0 e vs, memory_closed_n M eqs -> memory_closed_n (add_val_n x vs M) (EqFby x ck v0 e :: eqs). Proof. intros * WF n; specialize (WF n); destruct WF as (?& Vals). split; auto. intro y; intros * Hin. unfold add_val_n in Hin; apply not_None_is_Some in Hin as (?& Find). destruct (ident_eq_dec y x). - subst; simpl; auto. - rewrite find_val_gso in Find; auto. unfold gather_mems; simpl. right; apply Vals; eauto. apply not_None_is_Some; eauto. Qed. Section sem_msem_eq. Variable (G : global). Hypothesis Hnode : forall f xs ys, sem_node G f xs ys -> exists M, msem_node G f xs M ys. Theorem sem_msem_reset: forall f r xs ys, (forall k, sem_node G f (mask k r xs) (mask k r ys)) -> exists M, forall k, exists Mk, msem_node G f (mask k r xs) Mk (mask k r ys) /\ memory_masked k r M Mk. 
Require Export ZArith. Require Export ZArithRing Extraction. Require Import Lia. Open Scope Z_scope.Definition sqrt_type2 := fun v s r => (Zpos v) = s*s+r /\ 0 <= r <= 2*s.Definition sqrt_type1 := fun p s => {r:Z | sqrt_type2 p s r}.Theorem th_sqrt1 : 1=1*1+0 /\ 0<= 0 <= 2*1. Proof. simpl;auto with zarith. Qed.Theorem th_sqrt2 : 2=1*1+1 /\ 0 <= 1 <= 2*1. Proof. simpl; auto with zarith. Qed.Theorem th_sqrt3 : 3=1*1+2 /\ 0 <= 2 <= 2*1. Proof. simpl; auto with zarith. Qed.Theorem th_sqrt_4_0_le : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 <= 4*r -> Zpos(xO (xO p)) = (2*s+1)*(2*s+1)+(4*r - (4*s+1)) /\ 0<= 4*r-(4*s+1) <= 2*(2*s+1). Proof. intros p s r [Heq Hlt] Hle; rewrite Zpos_xO; rewrite (Zpos_xO p). rewrite Heq; split. - ring. - split; lia. Qed. Theorem th_sqrt_4_0_gt : forall p s r, Zpos p = s*s+r /\ 0<= r <= 2*s -> 4*s+1 > 4*r -> Zpos(xO (xO p)) = (2*s)*(2*s)+4*r /\ 0<= 4*r <= 2*(2*s). 
= y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof Group.op_neg_def op_group. Theorem op_neg_inj : is_injective E E op_neg. Proof Group.op_neg_inj op_group. Theorem op_cancel_neg : forall x : E, op_neg (- x) = x. Proof Group.op_cancel_neg op_group. Theorem op_neg_onto : is_onto E E op_neg. Proof Group.op_neg_onto op_group. Theorem op_neg_bijective : is_bijective E E op_neg. Proof Group.op_neg_bijective op_group. Theorem op_neg_rev : forall x y : E, - x = y -> - y = x. Proof Group.op_neg_rev op_group. Theorem op_neg_distrib_inv_l : forall x y : E, op_is_inv_l (x + y) (- y + - x). Proof Group.op_neg_distrib_inv_l op_group. Theorem op_neg_distrib_inv_r : forall x y : E, op_is_inv_r (x + y) (- y + - x). Proof Group.op_neg_distrib_inv_r op_group. Theorem op_neg_distrib_inv : forall x y : E, op_is_inv (x + y) (- y + - x). Proof Group.op_neg_distrib_inv op_group. Theorem op_neg_distrib : forall x y : E, - (x + y) = - y + - x. 
M. Module Defs := MapDefs OT. Section MapMemSec. Variable V : Type. Definition mem_type := @mem Map.key OT.eq_dec V. Definition mm (m : Map.t V) : mem_type := fun a => Map.find a m. Lemma find_add_eq : forall m a (v : V), Map.find a (Map.add a v m) = Some v. Proof. intros. erewrite M.find_1; eauto. apply M.add_1. reflexivity. Qed. Lemma find_add_ne : forall m a a' (v : V), a <> a' -> Map.find a (Map.add a' v m) = Map.find a m. Proof. intros. case_eq (Map.find a (Map.add a' v m)); intros. - apply M.find_2 in H0. eapply M.add_3 in H0; [| congruence ]. erewrite M.find_1 with (e := v0); auto. - case_eq (Map.find a m); intros; eauto. eapply M.find_2 in H1. eapply M.add_2 with (x := a') (e' := v) in H1. eapply M.find_1 in H1; congruence. congruence. Qed. Lemma find_remove_eq : forall m a, @Map.find V a (Map.remove a m) = None. Proof. intros. case_eq (Map.find a (Map.remove a m)); eauto; intros. apply M.find_2 in H. exfalso. eapply M.remove_1; unfold M.In; try eauto. reflexivity. Qed. Lemma find_remove_ne : forall m a a', a <> a' -> @Map.find V a (Map.remove a' m) = Map.find a m. Proof. intros. case_eq (Map.find a (Map.remove a' m)); intros. - apply M.find_2 in H0. apply M.remove_3 in H0. erewrite M.find_1; eauto. - case_eq (Map.find a m); eauto; intros. eapply M.find_2 in H1. eapply M.remove_2 with (x := a') in H1. eapply M.find_1 in H1; congruence. congruence. Qed. Theorem mm_init : @emp _ OT.eq_dec _ (mm (Map.empty _)). Proof. unfold emp, mm; intros. case_eq (Map.find a (Map.empty V)); intros; auto. apply M.find_2 in H. exfalso. eapply M.empty_1; eauto. Qed. Theorem mm_add : forall m (F : @pred Map.key OT.eq_dec V) a v, Map.find a m = None -> F (mm m) -> (F * a |-> v)%pred (mm (Map.add a v m)). Proof. unfold_sep_star; intros; repeat deex. exists (mm m). unfold mm in *. exists (fun a' => if OT.eq_dec a' a then Some v else None). split; [|split]. - apply functional_extensionality; intro. unfold mem_union; destruct (OT.eq_dec x a); unfold OT.eq in *; subst. rewrite find_add_eq; rewrite H; auto. rewrite find_add_ne by auto. destruct (Map.find x m); auto. - unfold mem_disjoint in *. intuition. repeat deex. destruct (OT.eq_dec a0 a); subst; intuition; pred. - intuition; eauto. unfold ptsto; intuition. destruct (OT.eq_dec a a); pred. destruct (OT.eq_dec a' a); pred. Qed. Theorem mm_replace : forall m (F : @pred Map.key OT.eq_dec V) a v0 v, (a |-> v0 * F)%pred (mm m) -> (a |-> v * F)%pred (mm (Map.add a v m)). 
ratMult_eqRat_compat. eauto. eapply eqRat_refl. unfold marginal_l. eapply eqRat_trans. eapply sumList_body_eq. intros. eapply ratMult_eqRat_compat. eapply evalDist_seq_step. eapply eqRat_refl. eapply eqRat_trans. eapply sumList_body_eq. intros. symmetry. eapply sumList_factor_constant_r. rewrite sumList_comm. dist_inline_first. rewrite evalDist_seq_step. eapply sumList_body_eq. intros. rewrite (@sumList_exactly_one _ (fst a)). assert (Pr [ret eqb (fst a) (fst a) ] == 1). dist_compute. rewrite H5. rewrite ratMult_1_r. eapply ratMult_eqRat_compat; intuition. specialize (H2 a). intuition. rewrite H2. unfold marginal_l. intuition. eapply getSupport_NoDup. eapply in_support_marginal_l; eauto. intuition. dist_compute. rewrite evalDist_seq_step. eapply eqRat_trans. eapply sumList_body_eq. intros. eapply ratMult_eqRat_compat. eauto. eapply eqRat_refl. unfold marginal_r. eapply eqRat_trans. eapply sumList_body_eq. intros. eapply ratMult_eqRat_compat. eapply evalDist_seq_step. eapply eqRat_refl. eapply eqRat_trans. eapply sumList_body_eq. intros. symmetry. eapply sumList_factor_constant_r. rewrite sumList_comm. dist_inline_first. rewrite evalDist_seq_step. eapply sumList_body_eq. intros. rewrite (@sumList_exactly_one _ (snd a)). assert (Pr [ret eqb (snd a) (snd a) ] == 1). dist_compute. rewrite H5. rewrite ratMult_1_r. eapply ratMult_eqRat_compat; intuition. specialize (H2 a); intuition. rewrite H6. unfold marginal_r; intuition. eapply getSupport_NoDup. eapply in_support_marginal_r; eauto. intuition. dist_compute. simp_in_support. specialize (H2 x1); intuition. unfold eq_dec; intuition. eapply (EqDec_dec _). eapply (ret (c, d)).Qed. Ltac despec := match goal with | [H : comp_spec _ _ _ |- _] => destruct H end.Theorem comp_spec_consequence : forall (A B : Set){eqda1 eqda2 : EqDec A}{eqdb1 eqdb2 : EqDec B}(p1 p2 : A -> B -> Prop) c1 c2, (@comp_spec _ _ eqda1 eqdb1 p1 c1 c2) -> (forall a b, p1 a b -> p2 a b) -> (@comp_spec _ _ eqda2 eqdb2 p2 c1 c2). intuition. despec; intuition. exists x; intuition. rewrite H1. unfold marginal_l. dist_skip. eapply evalDist_ret_eq. case_eq (eqb (fst x0) r1); intuition. rewrite eqb_leibniz in H4. subst. eapply eqb_refl. case_eq ( (@eqb A eqda1 (@fst A B x0) r1)); intuition. rewrite eqb_leibniz in H5. subst. rewrite eqb_refl in H4. intuition. rewrite H. unfold marginal_r. dist_skip. eapply evalDist_ret_eq. case_eq (eqb (snd x0) r2); intuition. rewrite eqb_leibniz in H4. subst. eapply eqb_refl. case_eq ( (@eqb B eqdb1 (@snd A B x0) r2)); intuition. rewrite eqb_leibniz in H5. subst. rewrite eqb_refl in H4. intuition.Qed.Theorem comp_spec_symm : forall (A B : Set){eqda : EqDec A}{eqdb : EqDec B}(p : A -> B -> Prop) c1 c2, comp_spec p c1 c2 -> comp_spec (fun b a => p a b) c2 c1. intuition. despec; intuition. exists (p <-$ x; ret (snd p, fst p)). intuition. eapply eqRat_trans; eauto. unfold marginal_r, marginal_l. dist_inline_first. dist_skip. dist_compute. eapply eqRat_trans; eauto. unfold marginal_r, marginal_l. dist_inline_first. dist_skip. dist_compute. repeat simp_in_support. simpl. eauto. Qed. Theorem eq_impl_comp_spec : forall (A B : Set){eqda : EqDec A}{eqdb : EqDec B}(c1 : Comp A)(c2 : Comp B) x y, well_formed_comp c1 -> well_formed_comp c2 -> evalDist c1 x == evalDist c2 y -> comp_spec (fun a b => a = x <-> b = y) c1 c2. 
deex. erewrite find_subtree_app in * by eauto. destruct suffix; simpl in *; try congruence. rewrite app_nil_r in *; eauto. ** eapply find_subtree_update_subtree_file_not_pathname_prefix_2; eauto. * eapply BFILE.ilist_safe_trans; eauto. Qed. Ltac xcrash_solve := repeat match goal with | [ H: forall _ _ _, _ =p=> (?crash _) |- _ =p=> (?crash _) ] => eapply pimpl_trans; try apply H; cancel | [ |- crash_xform (LOG.rep _ _ _ _ _) =p=> _ ] => rewrite LOG.notxn_intact; cancel | [ H: crash_xform ?rc =p=> _ |- crash_xform ?rc =p=> _ ] => rewrite H; xform_norm end. Lemma mscs_same_except_log_tree_rep_latest : forall mscs mscs' F Ftop fsxp t sm, BFILE.mscs_same_except_log mscs mscs' -> tree_rep_latest F Ftop fsxp sm t mscs =p=> tree_rep_latest F Ftop fsxp sm t mscs'. Proof. unfold tree_rep_latest; intros. rewrite mscs_same_except_log_rep by eassumption. cancel. Qed. Lemma mscs_parts_eq_tree_rep_latest : forall mscs mscs' F Ftop fsxp t sm, MSCache mscs' = MSCache mscs -> MSICache mscs' = MSICache mscs -> MSAllocC mscs' = MSAllocC mscs -> MSIAllocC mscs' = MSIAllocC mscs -> MSDBlocks mscs' = MSDBlocks mscs -> tree_rep_latest F Ftop fsxp t sm mscs =p=> tree_rep_latest F Ftop fsxp t sm mscs'. Proof. unfold tree_rep_latest; intros. unfold rep. unfold Balloc.IAlloc.rep. unfold Balloc.IAlloc.Alloc.rep; simpl. msalloc_eq. apply pimpl_refl. Qed. Lemma mscs_same_except_log_treeseq_one_safe : forall mscs mscs' t t', BFILE.mscs_same_except_log mscs mscs' -> treeseq_one_safe t t' mscs -> treeseq_one_safe t t' mscs'. Proof. unfold BFILE.mscs_same_except_log, treeseq_one_safe; intuition msalloc_eq. eauto. Qed. Lemma mscs_same_except_log_rep_treeseq_in_ds : forall F Ftop fsxp sm mscs mscs' ts ds, BFILE.mscs_same_except_log mscs mscs' -> treeseq_in_ds F Ftop fsxp sm mscs ts ds -> treeseq_in_ds F Ftop fsxp sm mscs' ts ds. Proof. unfold treeseq_in_ds. intuition eauto. eapply NEforall2_impl; eauto. intuition. intuition. intuition. eapply mscs_same_except_log_treeseq_one_safe; eauto. eapply mscs_same_except_log_tree_rep_latest; eauto. Qed. Lemma treeseq_in_ds_eq: forall Fm Ftop fsxp sm mscs a ts ds, BFILE.mscs_same_except_log a mscs -> treeseq_in_ds Fm Ftop fsxp sm mscs ts ds <-> treeseq_in_ds Fm Ftop fsxp sm a ts ds. Proof. split; eapply mscs_same_except_log_rep_treeseq_in_ds; eauto. apply BFILE.mscs_same_except_log_comm; eauto. Qed. Lemma treeseq_in_ds_mscs' : forall Fm Ftop fsxp sm mscs mscs' ts ds, treeseq_in_ds Fm Ftop fsxp sm mscs ts ds -> (Fm * rep fsxp Ftop (TStree ts !!) (TSilist ts !!) (TSfree ts !!) mscs' sm)%pred (list2nmem ds !!) -> MSAlloc mscs = MSAlloc mscs' -> treeseq_in_ds Fm Ftop fsxp sm mscs' ts ds. Proof. unfold treeseq_in_ds, tree_rep_latest; intuition. eapply NEforall2_impl; eauto. intros; intuition. intuition. unfold treeseq_one_safe in *; intuition msalloc_eq. eauto. Qed. Theorem treeseq_file_set_attr_ok : forall fsxp inum attr mscs, {< ds sm ts pathname Fm Ftop Ftree f, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[ treeseq_in_ds Fm Ftop fsxp sm mscs ts ds ]] * [[ (Ftree * pathname |-> File inum f)%pred (dir2flatmem2 (TStree ts!!)) ]] POST:hm' RET:^(mscs', ok) [[ MSAlloc mscs' = MSAlloc mscs ]] * ([[ isError ok ]] * LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[ treeseq_in_ds Fm Ftop fsxp sm mscs' ts ds ]] \/ [[ ok = OK tt ]] * exists d ds' ts' tree' ilist' f', LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds') (MSLL mscs') sm hm' * [[ treeseq_in_ds Fm Ftop fsxp sm mscs' ts' ds']] * [[ forall pathname', treeseq_pred (treeseq_safe pathname' (MSAlloc mscs) (ts !!)) ts -> treeseq_pred (treeseq_safe pathname' (MSAlloc mscs) (ts' !!)) ts' ]] * [[ ds' = pushd d ds ]] * [[[ d ::: (Fm * rep fsxp Ftop tree' ilist' (TSfree ts !!) mscs' sm) ]]] * [[ tree' = update_subtree pathname (TreeFile inum f') (TStree ts!!) ]] * [[ ts' = pushd (mk_tree tree' ilist' (TSfree ts !!)) ts ]] * [[ f' = mk_dirfile (DFData f) attr ]] * [[ (Ftree * pathname |-> File inum f')%pred (dir2flatmem2 tree') ]]) XCRASH:hm' LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' \/ exists d ds' ts' mscs' tree' ilist' f', LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds' hm' * [[ MSAlloc mscs' = MSAlloc mscs ]] * [[ treeseq_in_ds Fm Ftop fsxp sm mscs' ts' ds' ]] * [[ forall pathname', treeseq_pred (treeseq_safe pathname' (MSAlloc mscs) (ts !!)) ts -> treeseq_pred (treeseq_safe pathname' (MSAlloc mscs) (ts' !!)) ts' ]] * [[ ds' = pushd d ds ]] * [[[ d ::: (Fm * rep fsxp Ftop tree' ilist' (TSfree ts !!) mscs' sm) ]]] * [[ tree' = update_subtree pathname (TreeFile inum f') (TStree ts!!) ]] * [[ ts' = pushd (mk_tree tree' ilist' (TSfree ts !!)) ts ]] * [[ f' = mk_dirfile (DFData f) attr ]] * [[ (Ftree * pathname |-> File inum f')%pred (dir2flatmem2 tree') ]] >} AFS.file_set_attr fsxp inum attr mscs. 
Hn; apply (eq_some_none _ _ H2).apply H; clear H; intros u H H1; apply H. Qed.Lemma OMEGA_SUCC : forall n : nat, wf_nat n -> EQV (opt nat) OMEGA (some nat (S n)) (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).Proof. intros n Hn; apply extensionality; unfold SUB in |- *; intros X A a H.apply H; clear H; intros z H H1; apply H; clear H.intros n0 m H H2 Hn0 Hm H3. generalize (eq_sym _ _ _ (eq_some_some _ _ _ H)); clear H; intro H. generalize (H (lt m) H3); clear H H3 Hn0 n0; intro H3.apply (lt_n_Sm m Hm n Hn H3); clear H3; intro H3.apply SUCC_intro1; apply ELT_intro with (some nat m). exact (OMEGA_in m Hm n Hn H3). apply H2; assumption.apply ELT_compat_l with (opt nat) OMEGA (some nat n). apply H3; apply H2; assumption. apply SUCC_intro2.intros m H H2 Hm; apply (eq_some_none _ _ H).apply (SUCC_elim _ _ _ _ _ _ H); clear H; intro H.apply H; clear H; intros z H H1; apply H; clear H.intros n0 m H H2 Hn0 Hm H3. generalize (eq_sym _ _ _ (eq_some_some _ _ _ H)); clear H; intro H. generalize (H (lt m) H3); clear H H3 Hn0 n0; intro H3. apply ELT_intro with (some nat m). exact (OMEGA_in m Hm (S n) (wf_nat_S n Hn) (lt_S m n H3)). apply H2; assumption.intros m H H2 Hm; apply (eq_some_none _ _ H).apply ELT_intro with (some nat n). exact (OMEGA_in n Hn (S n) (wf_nat_S n Hn) (lt_n_Sn n)). assumption. Qed.Theorem omega_zero : ELT unit ZERO id (opt nat) OMEGA (none nat).Proof. apply ELT_intro with (some nat O). exact (OMEGA_rt O wf_nat_O). apply EQV_sym; exact OMEGA_ZERO. Qed.Theorem omega_succ : forall (X : Typ1) (A : Rel X) (a : X), ELT X A a (opt nat) OMEGA (none nat) -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat).Proof. intros X A a H; apply H; clear H; intros z H H1; apply H; clear H.intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).intros n H0 H Hn; apply ELT_intro with (some nat (S n)). exact (OMEGA_rt (S n) (wf_nat_S n Hn)). apply EQV_trans with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)). apply SUCC_compat; apply H; assumption. apply EQV_sym; apply OMEGA_SUCC; assumption. Qed.Require Import IZF_select. Theorem omega_ind : forall P : PRED, Compat P -> P unit ZERO id -> (forall (X : Typ1) (A : Rel X) (a : X), ELT X A a (opt nat) OMEGA (none nat) -> P X A a -> P (opt X) (SUCC X A a) (none X)) -> forall (X : Typ1) (A : Rel X) (a : X), ELT X A a (opt nat) OMEGA (none nat) -> P X A a.Proof. 
x y. Proof. intros x y Hhalf H. unfold shrx, shrx_alt, lt. destruct (Z_ge_lt_dec (signed x) 0); [rewrite zlt_false | rewrite zlt_true]; repeat lazymatch goal with | |- is_power2 _ = Some _ => apply is_power2_shl | |- signed (shl one _) >= 0 => apply shl_signed_positive | |- signed (neg _) >= 0 => apply neg_signed | |- divs _ _ = divu _ _ => apply div_divs_equiv | |- divs ?x (shl one ?y) = neg (shru (neg ?x) ?y) => rewrite <- neg_involutive at 1; rewrite neg_divs_distr_l; try assumption; f_equal | |- divs ?x (shl one ?y) = shru ?x ?y => let H := fresh "H" in pose proof (divu_pow2 x (shl one y) y) as H; rewrite <- H end; try assumption. Qed. Lemma shrx_shrx_alt_equiv_eq : forall x y, unsigned x = 2147483648 -> unsigned y <= 30 -> shrx x y = shrx_alt x y. Proof. intros. repeat unfold shrx, shrx_alt, signed, divs, neg. replace half_modulus with 2147483648 by auto. replace modulus with 4294967296 by auto. simplify. rewrite !Z_mod_modulus_eq. rewrite !H. simplify. assert (Hshl: Z.shiftl 1 (unsigned y) mod 4294967296 = Z.shiftl 1 (unsigned y)). { apply Z.mod_small. rewrite Z.shiftl_1_l. split. apply Z.pow_nonneg. lia. replace 4294967296 with (2^32) by auto. apply Z.le_lt_trans with (m := 2 ^ 31); try lia. apply Z.pow_le_mono_r; lia. } rewrite !Hshl. f_equal. assert ((Z.shiftl 1 (unsigned y)) < 2147483648). rewrite Z.shiftl_1_l. replace 2147483648 with (2^31) by auto. apply Z.le_lt_trans with (m := 2 ^ 30); try lia. apply Z.pow_le_mono_r; lia. destruct (zlt (Z.shiftl 1 (unsigned y)) 2147483648); try lia. replace (-2147483648 mod 4294967296) with 2147483648 by auto. assert (Hmodeq : Z.shiftr 2147483648 (unsigned y) mod 4294967296 = Z.shiftr 2147483648 (unsigned y)). { apply Z.mod_small. split. apply Z.shiftr_nonneg. lia. rewrite Z.shiftr_div_pow2. replace 4294967296 with (Z.succ 4294967295); auto. apply Zle_lt_succ. replace 4294967295 with (4294967295 * (2 ^ unsigned y) / (2 ^ unsigned y)). 2: { apply Z.div_mul. pose proof (Z.pow_pos_nonneg 2 (unsigned y)). apply not_eq_sym. apply Z.le_neq. apply H2; try lia. apply unsigned_range_2. } apply Z.div_le_mono. apply Z.pow_pos_nonneg. lia. apply unsigned_range_2. transitivity 4294967295; try lia. apply Z.le_mul_diag_r; try lia. replace 1 with (Z.succ 0) by auto. apply Z.le_succ_l. apply Z.pow_pos_nonneg; try lia. apply unsigned_range_2. apply unsigned_range_2. } rewrite !Hmodeq. replace (-2147483648) with (Z.opp 2147483648) by auto. rewrite Zquot.Zquot_opp_l. f_equal. rewrite Zquot.Zquot_Zdiv_pos. rewrite Z.shiftr_div_pow2. rewrite Z.shiftl_1_l. auto. apply unsigned_range_2. lia. rewrite Z.shiftl_1_l. apply Z.lt_le_incl. apply Z.pow_pos_nonneg; try lia. apply unsigned_range_2. Qed. Theorem shrx_shrx_alt_equiv : forall x y, unsigned y <= 30 -> shrx x y = shrx_alt x y. 
