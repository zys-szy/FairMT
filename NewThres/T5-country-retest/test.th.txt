Module M := PositiveMap. Module F := Facts M. Definition key := X.t. Definition t := M.t. Definition empty := M.empty. Definition add (A : Type) (i : key) (v : A) (m : t A) : t A := M.add (X.index i) v m. Definition find (A : Type) (i : key) (m : t A) : option A := M.find (X.index i) m. Definition remove (A : Type) (i : key) (m : t A) : t A := M.remove (X.index i) m. Lemma empty_o : forall A x, find x (empty A) = None. Proof. intros. unfold find. apply F.empty_o. Qed. Lemma add_eq_o : forall A m x y e, E.eq x y -> @find A y (add x e m) = Some e. Proof. intros. unfold find. apply F.add_eq_o. rewrite H. reflexivity. Qed. Lemma add_neq_o : forall A m x y e, ~ E.eq x y -> find y (add x e m) = @find A y m. Proof. intros. unfold find. apply F.add_neq_o. intro H_eq. contradict H. apply X.index_inj in H_eq. assumption. Qed. Lemma remove_eq_o : forall A m x y, E.eq x y -> @find A y (remove x m) = None. Proof. intros. unfold find. apply F.remove_eq_o. rewrite H. reflexivity. Qed. Lemma remove_neq_o : forall A m x y, ~ E.eq x y -> find y (remove x m) = @find A y m. Proof. intros. unfold find. apply F.remove_neq_o. intro H_eq. contradict H. apply X.index_inj in H_eq. assumption. Qed. End IndexedPositiveMap.Module IndexedString <: IndexedType. Definition t := string. Definition eq := string_dec. Fixpoint positive_of_digits (l : list bool) (p : positive) : positive := match l with | [] => p | b :: l' => if b then xI (positive_of_digits l' p) else xO (positive_of_digits l' p) end. Definition list_bool_of_ascii (a : ascii) : list bool := let (a0,a1,a2,a3,a4,a5,a6,a7) := a in [a0; a1; a2; a3; a4; a5; a6; a7]. Fixpoint index (s : string) : positive := match s with | EmptyString => 1 | String a s' => positive_of_digits (list_bool_of_ascii a) (index s') end. Lemma positive_of_digits_inj : forall l l' p p', List.length l = List.length l' -> positive_of_digits l p = positive_of_digits l' p' -> l = l' /\ p = p'. Proof. induction l; destruct l'; intros; try discriminate; auto. simpl in *. do 2 break_match; try discriminate; solve [ find_inversion; find_apply_hyp_hyp; break_and; subst; auto ]. Qed. Theorem index_inj : forall (x y : t), index x = index y -> x = y. 
Require Export ZArith List Arith Bool. Inductive month : Set := | January | February | March | April | May | June | July | August | September | October | November | December. Theorem month_equal : forall m:month, m=January \/ m=February \/ m=March \/ m=April \/ m=May \/ m=June \/ m=July \/ m=August \/ m=September \/ m=October \/ m=November \/ m=December. 
x ‚ãµ ùêñùê ). eapply member_grounded... apply rank_of_member in Hxm... apply Hle in H as []. - apply binRelE3 in H. eapply ord_not_lt_gt; revgoals... - rewrite H in Hxm. eapply ord_irrefl; revgoals... Qed.Section RegularWorld. Import RegularityConsequences.Example ex7_34 : ‚àÄ x y u v, {x, {x, y}} = {u, {u, v}} ‚Üí x = u ‚àß y = v. Proof with eauto; try congruence. intros. assert (Hx: x ‚àà {u, {u, v}}). { rewrite <- H. apply PairI1. } assert (Hp: {x, y} ‚àà {u, {u, v}}). { rewrite <- H. apply PairI2. } apply PairE in Hx as []. - subst u. split... apply PairE in Hp as []. + exfalso. eapply pair_regularity... + apply pair_eq_pair in H0 as [[]|[]]... - apply PairE in Hp as []. + exfalso. apply (no_descending_chain_2 x {x, y}). apply PairI1. rewrite H1, H0. apply PairI1. + apply pair_eq_pair in H1 as [[]|[]]... subst. exfalso. rewrite pair_ordering_agnostic in H1. eapply pair_regularity... Qed. Theorem suc_injective : ‚àÄ a b, a‚Å∫ = b‚Å∫ ‚Üí a = b. Proof with auto. intros. assert (Ha: a ‚àà b‚Å∫). rewrite <- H. apply suc_has_n. assert (Hb: b ‚àà a‚Å∫). rewrite H. apply suc_has_n. apply BUnionE in Ha as []. - apply BUnionE in Hb as []. + exfalso. apply (no_descending_chain_2 a b)... + apply SingE in H1... - apply SingE in H0... Qed. Theorem connected_trans_iff_ord : ‚àÄ Œ±, Œ± ‚ãµ ùêéùêç ‚Üî connected (MemberRel Œ±) Œ± ‚àß trans Œ±. Proof with eauto. split. { intros Ho. split. - apply lo_connected. apply ord_woset... - apply ord_trans... } intros [Hcnt Htr]. apply transitive_set_well_ordered_by_epsilon_is_ord... split. apply loset_iff_connected_poset. repeat split... - apply memberRel_is_binRel. - eapply binRel_is_rel. apply memberRel_is_binRel. - intros x y z Hxy Hyz. apply binRelE2 in Hxy as [Hx [Hy Hxy]]. apply binRelE2 in Hyz as [_ [Hz Hyz]]. apply binRelI... destruct (classic (x = z)). { subst. exfalso. eapply no_descending_chain_2... } apply Hcnt in H as []; auto; apply binRelE3 in H... exfalso. eapply no_descending_chain_3... - intros x H. apply binRelE3 in H. exfalso. eapply no_descending_chain_1... - intros B Hne Hsub. apply EmptyNI in Hne. pose proof (ex_epsilon_minimal B Hne) as [m [Hm Hmin]]. exists m. split... intros x Hx. apply Hsub in Hx as HxŒ±. apply Hsub in Hm as HmŒ±. apply Hmin in Hx as H. destruct H; [|right]... destruct (classic (x = m)) as [|Hnq]; [right|left]... apply Hcnt in Hnq as []... exfalso. apply H. eapply binRelE3... Qed. Theorem trans_of_trans_iff_ord : ‚àÄ Œ±, Œ± ‚ãµ ùêéùêç ‚Üî trans Œ± ‚àß ‚àÄŒæ ‚àà Œ±, trans Œæ. 
prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs(round beta (FLX_exp prec) (Znearest choice) x))%R. Proof. intro x. apply relative_error_le_conversion_round_inv, relative_error_N_FLX_round_ex. Qed.End Fprop_relative_FLX.Section Fprop_relative_FLT.Variable emin prec : Z. Variable Hp : Z.lt 0 prec.Lemma relative_error_FLT_aux : forall k, (emin + prec - 1 < k)%Z -> (prec <= k - FLT_exp emin prec k)%Z. Proof. intros k Hk. unfold FLT_exp. generalize (Zmax_spec (k - prec) emin). lia. Qed.Variable rnd : R -> Z. Context { valid_rnd : Valid_rnd rnd }.Theorem relative_error_FLT : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> (Rabs (round beta (FLT_exp emin prec) rnd x - x) < bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error with (emin + prec - 1)%Z... apply relative_error_FLT_aux. Qed.Theorem relative_error_FLT_F2R_emin : forall m, let x := F2R (Float beta m emin) in (x <> 0)%R -> (Rabs (round beta (FLT_exp emin prec) rnd x - x) < bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros m x Zx. destruct (Rlt_or_le (Rabs x) (bpow (emin + prec - 1))) as [Hx|Hx]. rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. apply Rmult_lt_0_compat. apply bpow_gt_0. now apply Rabs_pos_lt. apply generic_format_FLT_FIX... apply Rlt_le. apply Rlt_le_trans with (1 := Hx). apply bpow_le. apply Zle_pred. apply generic_format_FIX. now exists (Float beta m emin). now apply relative_error_FLT. Qed.Theorem relative_error_FLT_F2R_emin_ex : forall m, let x := F2R (Float beta m emin) in exists eps, (Rabs eps < bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) rnd x = (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros m x. apply relative_error_lt_conversion... apply bpow_gt_0. now apply relative_error_FLT_F2R_emin. Qed. Theorem relative_error_FLT_ex : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> exists eps, (Rabs eps < bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) rnd x = (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error_lt_conversion... apply bpow_gt_0. intros _; now apply relative_error_FLT. Qed.Variable choice : Z -> bool.Theorem relative_error_N_FLT : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error_N with (emin + prec - 1)%Z... apply relative_error_FLT_aux. Qed. Theorem relative_error_N_FLT_ex : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> exists eps, (Rabs eps <= /2 * bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + eps))%R. 
-> Ewf e. simple induction 1; auto with coc core arith datatypes. Qed. Lemma Ewf_sort : forall (n : nat) (e f : env), trunc _ (S n) e f -> Ewf e -> forall t : term, item _ t e n -> exists s : sort, Etyp f t (Srt s). simple induction n. do 3 intro. inversion_clear H. inversion_clear H0. intros. inversion_clear H0. inversion_clear H. exists s; auto with coc core arith datatypes.do 5 intro. inversion_clear H0. intros. inversion_clear H2. inversion_clear H0. elim H with e0 f t; intros; auto with coc core arith datatypes. exists x0; auto with coc core arith datatypes.apply Etyp_Ewf with x (Srt s); auto with coc core arith datatypes. Qed. Definition inv_Etype (P : Prop) (e : env) (t T : term) : Prop := match t with | Srt prop => Econv T (Srt kind) -> P | Srt set => Econv T (Srt kind) -> P | Srt kind => True | Ref n => forall x : term, item _ x e n -> Econv T (lift (S n) x) -> P | Abs A M => forall (s1 s2 : sort) (U : term), Etyp e A (Srt s1) -> Etyp (A :: e) M U -> Etyp (A :: e) U (Srt s2) -> Econv T (Prod A U) -> P | App u v => forall Ur V : term, Etyp e v V -> Etyp e u (Prod V Ur) -> Econv T (subst v Ur) -> P | Prod A B => forall s1 s2 : sort, Etyp e A (Srt s1) -> Etyp (A :: e) B (Srt s2) -> Econv T (Srt s2) -> P end. Lemma inv_Etype_Econv : forall (P : Prop) (e : env) (t U V : term), Econv U V -> inv_Etype P e t U -> inv_Etype P e t V. do 6 intro. cut (forall x : term, Econv V x -> Econv U x). intro. case t; simpl in |- *; intros. generalize H1. elim s; auto with coc ecoc core arith datatypes; intros.apply H1 with x; auto with coc core arith datatypes.apply H1 with s1 s2 U0; auto with coc core arith datatypes.apply H1 with Ur V0; auto with coc core arith datatypes.apply H1 with s1 s2; auto with coc core arith datatypes.intros; apply trans_Econv_Econv with V; auto with coc core arith datatypes. Qed. Theorem Etyp_inversion : forall (P : Prop) (e : env) (t T : term), Etyp e t T -> inv_Etype P e t T -> P. 
3 eexists. split_and!; eauto. eapply rtc_l; eauto. Qed. Theorem crash_step_simulation sœÉ1 sg1 iœÉ1 ig1 iœÉ2: abstraction sœÉ1 sg1 iœÉ1 ig1 ‚Üí crash_prim_step (impl_crash_lang) iœÉ1 iœÉ2 ‚Üí (‚àÉ sœÉ2, crash_prim_step (spec_crash_lang) sœÉ1 sœÉ2 ‚àß abstraction sœÉ2 sg1 iœÉ2 ig1). Proof using crash_ok. intros Habstr Hprim. inversion Hprim; subst. destruct Habstr as (?&?&?&?). edestruct (crash_ok) as (?&?&?); eauto. eexists. split. { econstructor; eauto. } split_and!; eauto. - simpl. split. * rewrite ?dom_empty_L //. * inversion 1. - rewrite //=. congruence. Qed. Definition config_abstraction (sœÅ : scfg) (iœÅ : icfg) := tp_impl sœÅ.1 iœÅ.1 ‚àß abstraction sœÅ.2.1 sœÅ.2.2 iœÅ.2.1 iœÅ.2.2. Theorem erased_rsteps_simulation ir iœÅ1 iœÅ2 sœÅ1 sr st : erased_rsteps (CS := impl_crash_lang) ir iœÅ1 iœÅ2 st ‚Üí wf sr sœÅ1 ‚Üí fo_rsteps sr sœÅ1 ‚Üí config_abstraction sœÅ1 iœÅ1 ‚Üí expr_impl sr ir ‚Üí (‚àÉ sœÅ2, erased_rsteps (CS := spec_crash_lang) sr sœÅ1 sœÅ2 st ‚àß config_abstraction sœÅ2 iœÅ2 ‚àß wf sr sœÅ2 ). Proof using wf_closed op_impl_succ_ok op_impl_abort_ok wf_preserved_step crash_ok. intros Hrsteps. revert sr sœÅ1. induction Hrsteps as [iœÅ1 iœÅ2 Hrtc|iœÅ1 iœÅ2 iœÅ3 iœÉ st' Hrtc Hcrash Herased]; intros sr sœÅ1 Hwf Hfo (Htp&Habstr) Himplr. - destruct iœÅ1 as (it1, (iœÉ1, ig1)). destruct iœÅ2 as (it2, (iœÉ2, ig2)). destruct sœÅ1 as (st1, (sœÉ1, sg1)). edestruct (rtc_erased_step_simulation) as (st2&sœÉ2&sg2&H); eauto. eexists. intuition eauto. { econstructor. eauto. } split; eauto. - destruct iœÅ1 as (it1, (iœÉ1, ig1)). destruct iœÅ2 as (it2, (iœÉ2, ig2)). destruct sœÅ1 as (st1, (sœÉ1, sg1)). edestruct (rtc_erased_step_simulation) as (st2&sœÉ2&sg2&H); eauto. clear Habstr. edestruct (crash_step_simulation) as (sœÉ2'&?&?); intuition eauto. edestruct (IHHerased sr ([sr], (sœÉ2', sg2))) as (sœÅ2&Hcompat'&Hrtc'); eauto. { eapply wf_preserved_crash; eauto. } { eapply fo_rsteps_preserved_crash; eauto. } { split; simpl; eauto. econstructor; eauto. } eexists; split_and!. { econstructor; eauto. } { intuition eauto. } { intuition eauto. } Qed. Lemma not_stuck_reflect sœÉ sg iœÉ ig se ie : abstraction sœÉ sg iœÉ ig ‚Üí in_wf_ctxt se sœÉ sg ‚Üí not_stuck se sœÉ sg ‚Üí expr_impl se ie ‚Üí not_stuck ie iœÉ ig. Proof using op_impl_safe_ok wf_closed. rewrite /not_stuck. intros Habstr Hwf Hnstuck Himpl. destruct Hnstuck as [Hval|Hred]. - destruct Hval as (v&Heq). left. apply language.of_to_val in Heq. subst. inv_expr_impl; eauto. - right. destruct Hred as (?&?&?&?&?&Hstep). edestruct (prim_step_simulation_rev) as (?&?&?&?&?); eauto. do 4 eexists; eauto. Qed. Lemma in_wf_ctxt_alt sr se2 sœÉ2 sg2 st2 : se2 ‚àà st2 ‚Üí wf sr (st2, (sœÉ2, sg2)) ‚Üí in_wf_ctxt se2 sœÉ2 sg2. Proof. intros (l1&l2&->)%elem_of_list_split. intros Hwf. eexists sr, _, _, []. simpl. eauto. Qed. Theorem atomic_concurrent_refinement se ie sœÉ sg iœÉ ig : expr_impl se ie ‚Üí abstraction sœÉ sg iœÉ ig ‚Üí wf se ([se], (sœÉ, sg)) ‚Üí fo_rsteps se ([se], (sœÉ, sg)) ‚Üí trace_refines ie ie iœÉ ig se se sœÉ sg. 
Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Malloc Bedrock.Platform.Bootstrap Bedrock.Platform.Cito.examples.CountUnique. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 0. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 0. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "top"!"top" @ [topS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREonly[_] 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREonly[_] mallocHeap 0];; Call "top"!"top"() [PREonly[_] [| False |] ] end }}. Theorem ok : moduleOk boot. vcgen; abstract genesis. Qed. Require Bedrock.Platform.Cito.examples.ExampleImpl. Definition m0 := link ExampleImpl.m boot. Definition m1 := link all m0. Lemma ok0 : moduleOk m0. link ExampleImpl.ok ok. Qed. Lemma ok1 : moduleOk m1. link all_ok ok0. Qed. Variable stn : settings. Variable prog : program. Hypothesis inj : forall l1 l2 w, Labels stn l1 = Some w -> Labels stn l2 = Some w -> l1 = l2. Hypothesis agree : forall l pre bl, LabelMap.MapsTo l (pre, bl) (XCAP.Blocks m1) -> exists w, Labels stn l = Some w /\ prog w = Some bl. Hypothesis agreeImp : forall l pre, LabelMap.MapsTo l pre (XCAP.Imports m1) -> exists w, Labels stn l = Some w /\ prog w = None. Hypothesis omitImp : forall l w, Labels stn ("sys", l) = Some w -> prog w = None. Variable w : W. Hypothesis at_start : Labels stn ("main", Global "main") = Some w. Variable st : state. Hypothesis mem_low : forall n, (n < size * 4)%nat -> st.(Mem) n <> None. Hypothesis mem_high : forall w, ($ (size * 4) <= w)%word -> st.(Mem) w = None. Theorem safe : sys_safe stn prog (w, st). 
in learn_hyp (prefix_length l1 l2 H) as Hnew; pose proof (list_prefix_forall l1 l2 H); clear H end.Ltac learn_feed_as H i := feed_core H using (fun p => let P := type of p in lazymatch goal with | H: P |- _ => fail 1 | _ => pose proof p as i end).Ltac use_list_hyps := repeat match goal with | H: (forall (i:nat), _), i: nat |- _ => let Hi := fresh H i in learn_feed_as (H i) Hi; [ lia .. | ] end.Ltac start_list_eq := let i := fresh "i" in first [ apply list_eq_bounded; [ lia | intros i ? ] | apply list_eq; intros i ].Definition lt_le_dec n1 n2 : {n1 < n2} + {n2 ‚â§ n1}. Proof. destruct (decide (n1 < n2)); [ left | right ]; lia. Qed. Ltac split_i l i := first [ assert_succeeds ((assert (i < length l) by lia) || (assert (length l ‚â§ i) by lia)); fail 1 "i < length l or not already" | destruct (lt_le_dec i (length l)) ].Ltac split_app_lookups := repeat match goal with | |- context[(?l1 ++ _) !! ?i] => split_i l1 i | H: context[(?l1 ++ _) !! ?i] |- _ => split_i l1 i end.Ltac solve_list_eq := find_list_hyps; start_list_eq; repeat first [ progress list_simpl | progress use_list_hyps | progress split_app_lookups ]; auto with lia list.Ltac start_list_prefix := apply list_prefix_bounded; [ list_simpl; solve [ auto with list lia ] | let i := fresh "i" in let Hle := fresh "Hle" in intros i Hle ].Ltac solve_list_prefix := find_list_hyps; start_list_prefix; list_simpl; use_list_hyps; list_simpl; auto with lia list.Ltac solve_list_general := find_list_hyps; list_simpl; auto with lia list.Ltac list_solver := autounfold with list in *; intros; lazymatch goal with | |- @eq (list _) _ _ => solve [ solve_list_eq ] | |- _ `prefix_of` _ => solve [ solve_list_prefix ] | _ => solve [ solve_list_general ] end.Section test. Context {A: Type}. Implicit Types (l: list A). Theorem test_1 l1 l2 : length l2 ‚â§ length l1 ‚Üí l1 `prefix_of` l2 ‚Üí l1 = l2. Proof. list_solver. Qed. Theorem test_2 l1 l2 n : n ‚â§ length l2 ‚Üí take n l2 `prefix_of` l1 ‚Üí take n l1 `prefix_of` take n l2. Proof. list_solver. Qed. Theorem test_3 l : [] `prefix_of` l. Proof. list_solver. Qed. Theorem test_4 l1 l2 : l1 ++ l2 `prefix_of` l2 ‚Üí l1 `prefix_of` l2. Proof. list_solver. Qed. Theorem test_5 l n : n ‚â§ length l ‚Üí take n l ++ drop n l = l. 
:= Second_uniqueness B D step7.Definition pair_uniqueness_Out : pairwise_EQ A B C D := Build_pairwise_EQ A B C D step8 step9.End pair_uniqueness_proof.Theorem PAIR_uniqueness : forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), pairwise_EQ A B C D. Proof pair_uniqueness_Out. Theorem PAIR_uni_ac : forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), EQ A C. Proof fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) => pairwise_EQ_ac A B C D (PAIR_uniqueness A B C D e). Theorem PAIR_uni_bd : forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), EQ B D. Proof fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) => pairwise_EQ_bd A B C D (PAIR_uniqueness A B C D e).Definition is_a_pair (M : Ens) := EXISTS (fun A : Ens => EXISTS (fun B : Ens => EQ M (PAIR A B))).Section a_pair_is_a_pair_proof. Variable A : Ens. Variable B : Ens.Let M := PAIR A B. Let step1 : EQ M (PAIR A B) := EQ_refl M.Let step2 : EXISTS (fun B1 : Ens => EQ M (PAIR A B1)) := EXISTS_th1 (fun B1 : Ens => EQ M (PAIR A B1)) B step1. Definition a_pair_is_a_pair_Out : is_a_pair M := EXISTS_th1 (fun A1 : Ens => EXISTS (fun B1 : Ens => EQ M (PAIR A1 B1))) A step2.End a_pair_is_a_pair_proof.Theorem a_pair_is_a_pair : forall A B : Ens, is_a_pair (PAIR A B). Proof a_pair_is_a_pair_Out.Theorem a_pair_is_a_pair_th2 : forall (A B U : Ens) (i : EQ (PAIR A B) U), is_a_pair U. Proof fun (A B U : Ens) (i : EQ (PAIR A B) U) => Big_Extensionality (fun V : Ens => is_a_pair V) (PAIR A B) U (a_pair_is_a_pair A B) i. Definition PR1 (M : Ens) := CHOICE (fun A : Ens => EXISTS (fun B : Ens => EQ M (PAIR A B))). Theorem PAIR_proj1_pr1 : forall (M : Ens) (p : is_a_pair M), EXISTS (fun B : Ens => EQ M (PAIR (PR1 M) B)). Proof fun (M : Ens) (p : is_a_pair M) => CHOICE_pr (fun A : Ens => EXISTS (fun B : Ens => EQ M (PAIR A B))) p.Definition PR2 (M : Ens) := CHOICE (fun B : Ens => EQ M (PAIR (PR1 M) B)). Theorem PAIR_proj_th1 : forall (M : Ens) (p : is_a_pair M), EQ M (PAIR (PR1 M) (PR2 M)). 
Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Malloc. Require Import Coq.Lists.List Bedrock.Platform.SinglyLinkedList.Set Implicit Arguments. Module Type LIST_SEGMENT. Parameter lseg : list W -> W -> W -> HProp. Axiom lseg_extensional : forall ls p p', HProp_extensional (lseg ls p p'). Axiom nil_bwd : forall (p p' : W), [| p = p' |] ===> lseg nil p p'. Axiom nil_bwd' : forall ls (p p' : W), p = p' -> [| ls = nil |] ===> lseg ls p p'. Axiom append_bwd : forall p' ls p, (Ex ls', Ex x, Ex p'', [| ls = ls' ++ x :: nil |] * lseg ls' p p'' * [| freeable p'' 2 |] * [| p'' <> 0 |] * (p'' ==*> x, p')) ===> lseg ls p p'. Axiom sll_fwd : forall ls (p p' : W), p' = 0 -> lseg ls p p' ===> sll ls p. End LIST_SEGMENT.Module ListSegment : LIST_SEGMENT. Open Scope Sep_scope. Fixpoint lseg (ls : list W) (p p' : W) : HProp := match ls with | nil => [| p = p' |] | x :: ls' => [| freeable p 2 |] * [| p <> 0 |] * Ex p'', (p ==*> x, p'') * lseg ls' p'' p' end. Theorem lseg_extensional : forall ls (p p' : W), HProp_extensional (lseg ls p p'). 
eapply sm_vs_valid_same_upd_synced. eapply sm_ds_valid_pushd_l; eauto. eapply sm_ds_valid_pushd_r; eauto. rewrite replay_disk_add. eapply list2nmem_updN. eauto. Qed. Set Regular Subst Tactic. Theorem dwrite_ok : forall xp ms a v, {< F Fm Fs ds sm vs, PRE:hm rep xp F (ActiveTxn ds ds!!) ms sm hm * [[[ ds!! ::: (Fm * a |-> vs) ]]] * [[ (Fs * a |->?)%pred sm ]] * [[ sync_invariant F ]] POST:hm' RET:ms' exists ds' sm', rep xp F (ActiveTxn ds' ds'!!) ms' sm' hm' * [[[ ds'!! ::: (Fm * a |-> (v, vsmerge vs)) ]]] * [[ (Fs * a |-> false)%pred sm' ]] * [[ ds' = dsupd ds a (v, vsmerge vs) ]] XCRASH:hm' recover_any xp F ds hm' \/ recover_any xp F (dsupd ds a (v, vsmerge vs)) hm' >} dwrite xp a v ms. Proof. unfold dwrite, recover_any. step. step; subst. eapply map_valid_remove; autorewrite with lists; eauto. rewrite dsupd_latest_length; auto. rewrite dsupd_latest. apply updN_replay_disk_remove_eq; eauto. rewrite dsupd_latest. eapply list2nmem_updN; eauto. xcrash. or_l; cancel; xform_normr; cancel. eauto. or_r; cancel. xform_normr; cancel. eauto. Unshelve. all: eauto. Qed. Theorem dsync_ok : forall xp ms a, {< F Fm Fs ds sm vs, PRE:hm rep xp F (ActiveTxn ds ds!!) ms sm hm * [[[ ds!! ::: (Fm * a |-> vs) ]]] * [[ (Fs * a |->?)%pred sm ]] * [[ sync_invariant F ]] POST:hm' RET:ms' exists ds' sm', rep xp F (ActiveTxn ds' ds'!!) ms' sm' hm' * [[ ds' = dssync ds a ]] * [[ (Fs * a |-> true)%pred sm' ]] CRASH:hm' recover_any xp F ds hm' >} dsync xp a ms. Proof. unfold dsync, recover_any. step. step; subst. rewrite dssync_latest; unfold vssync; apply map_valid_updN; auto. rewrite dssync_latest; substl (ds!!) at 1. apply replay_disk_vssync_comm. Unshelve. eauto. Qed. Theorem flushall_ok : forall xp ms, {< F sm ds, PRE:hm rep xp F (NoTxn ds) ms sm hm * [[ sync_invariant F ]] POST:hm' RET:ms' rep xp F (NoTxn (ds!!, nil)) ms' sm hm' XCRASH:hm' recover_any xp F ds hm' >} flushall xp ms. Proof. unfold flushall, recover_any. hoare. xcrash. eauto. Unshelve. eauto. Qed. Theorem flushsync_ok : forall xp ms, {< F sm ds, PRE:hm rep xp F (NoTxn ds) ms sm hm * [[ sync_invariant F ]] POST:hm' RET:ms' rep xp F (NoTxn (ds!!, nil)) ms' sm hm' XCRASH:hm' recover_any xp F ds hm' >} flushsync xp ms. Proof. unfold flushsync, recover_any. hoare. xcrash. eauto. Unshelve. eauto. Qed. Theorem flushall_noop_ok : forall xp ms, {< F sm ds, PRE:hm rep xp F (NoTxn ds) ms sm hm * [[ sync_invariant F ]] POST:hm' RET:ms' rep xp F (NoTxn ds) ms' sm hm' XCRASH:hm' recover_any xp F ds hm' >} flushall_noop xp ms. 
ts0 ++ ts1 ++ t1s1). apply ety_weakening. by eapply t_const_ignores_context; eauto. -- eapply et_composition'; eauto. ++ instantiate (1 := ts0 ++ ts1 ++ t3s1). repeat apply ety_weakening. by eapply IHHReduce; eauto => //. ++ repeat apply ety_weakening. assert (HCEmpty: tc_local C = [::]); first by eapply inst_t_context_local_empty; eauto. rewrite HCEmpty in H9. rewrite HCEmpty. replace (map typeof f'.(f_locs)) with (map typeof f.(f_locs)) => //. eapply store_extension_e_typing; try apply HST1 => //; try by []. eapply store_extension_reduce; eauto. by eapply t_preservation_vs_type; eauto. + inversion HLF1. inversion HLF2. subst. inversion H8. subst. clear H8. clear H6. move/lfilledP in H1. move/lfilledP in H7. apply e_composition_typing in HType. destruct HType as [ts0 [t1s0 [t2s0 [t3s0 [H2 [H3 [H4 H5]]]]]]]. subst. apply e_composition_typing in H5. destruct H5 as [ts1 [t1s1 [t2s1 [t3s1 [H10 [H11 [H12 H13]]]]]]]. subst. apply Label_typing in H12. destruct H12 as [ts2 [t2s2 [H14 [H15 [H16 H17]]]]]. subst. eapply et_composition'. -- instantiate (1 := ts0 ++ ts1 ++ t1s1). apply ety_weakening. by eapply t_const_ignores_context; eauto. -- eapply et_composition'; eauto. ++ instantiate (1 := ts0 ++ ts1 ++ t1s1 ++ t2s2). repeat apply ety_weakening. apply et_weakening_empty_1. eapply ety_label; eauto. * assert (HCEmpty: tc_local C = [::]); first by eapply inst_t_context_local_empty; eauto. rewrite HCEmpty in H15. rewrite HCEmpty. simpl in H16. rewrite upd_label_overwrite in H16. eapply lfilled_es_type_exists in H16; eauto. destruct H16 as [lab' [t1s' [t2s' H16]]]. rewrite upd_label_overwrite in H16. replace (map typeof f'.(f_locs)) with (map typeof f.(f_locs)) => //. eapply store_extension_e_typing; try apply HST1 => //; try by []. eapply store_extension_reduce; eauto. by eapply t_preservation_vs_type; eauto. * simpl. simpl in H16. by eapply IHk; eauto. ++ repeat apply ety_weakening. assert (HCEmpty: tc_local C = [::]); first by eapply inst_t_context_local_empty; eauto. rewrite HCEmpty in H13. rewrite HCEmpty. simpl in H16. rewrite upd_label_overwrite in H16. eapply lfilled_es_type_exists in H16; eauto. destruct H16 as [lab' [t1s' [t2s' H16]]]. rewrite upd_label_overwrite in H16. replace (map typeof f'.(f_locs)) with (map typeof f.(f_locs)) => //. eapply store_extension_e_typing; try apply HST1 => //; try by []. eapply store_extension_reduce; eauto. by eapply t_preservation_vs_type; eauto. - apply Local_typing in HType. destruct HType as [ts [H1 [H2 H3]]]. subst. apply et_weakening_empty_1. apply ety_local => //. inversion H2. inversion H. subst. apply upd_label_unchanged_typing in H1. eapply mk_s_typing; eauto. + eapply mk_frame_typing => //. eapply inst_typing_extension; eauto. eapply store_extension_reduce; eauto. replace (f_inst f') with (f_inst f); eauto; first by eapply reduce_inst_unchanged; eauto. + fold_upd_context. eapply IHHReduce; eauto. eapply inst_typing_extension; eauto. eapply store_extension_reduce; eauto. Qed. Theorem t_preservation: forall s f es s' f' es' ts hs hs', reduce hs s f es hs' s' f' es' -> config_typing s f es ts -> config_typing s' f' es' ts. 
h' t r = st' -> st' = st \/ (type st' = Follower /\ currentTerm st' = t /\ log st' = log st) \/ (currentTerm st' = currentTerm st /\ log st' = log st /\ ((type st = Candidate /\ type st' = Leader /\ r = true /\ currentTerm st = t /\ wonElection (dedup name_eq_dec (h' :: votesReceived st)) = true) \/ type st' = type st)). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition; try right; congruence. Qed. Lemma contradict_leaderLogs_term_sanity : forall net h t ll e, refined_raft_intermediate_reachable net -> In (t, ll) (leaderLogs (fst (nwState net h))) -> In e ll -> eTerm e = currentTerm (snd (nwState net h)) -> False. Proof using lltsi. intros. find_copy_eapply_lem_hyp leaderLogs_term_sanity_invariant; eauto. find_eapply_lem_hyp leaderLogs_currentTerm_invariant; eauto. lia. Qed. Arguments dedup : simpl never. Lemma leaderLogs_candidate_entries_rvr : forall net, leaderLogs_candidateEntries net -> votes_correct net -> cronies_correct net -> forall p h t ll e, In (t, ll) (leaderLogs (fst (nwState net h))) -> In e ll -> In p (nwPackets net) -> pBody p = RequestVoteReply (eTerm e) true -> currentTerm (snd (nwState net (pDst p))) = eTerm e -> wonElection (dedup name_eq_dec (pSrc p :: votesReceived (snd (nwState net (pDst p))))) = true -> type (snd (nwState net (pDst p))) <> Candidate. Proof using. intros. eapply_prop_hyp leaderLogs_candidateEntries In; eauto. eapply wonElection_candidateEntries_rvr; auto. eauto. auto. auto. Qed. Theorem leaderLogs_sublog_request_vote_reply : refined_raft_net_invariant_request_vote_reply leaderLogs_sublog. Proof using vci cci llcei lltsi lsi rri. unfold refined_raft_net_invariant_request_vote_reply, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleRequestVoteReply_RVR_spec. intuition. - subst. repeat find_rewrite. repeat update_destruct_max_simplify; eauto; find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition eauto; unfold raft_data in *; congruence. - repeat update_destruct_max_simplify; try congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition eauto. subst_max. repeat find_rewrite. discriminate. + eauto. - repeat update_destruct_max_simplify. + repeat find_rewrite. find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * exfalso. eauto using contradict_leaderLogs_term_sanity. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. exfalso. eapply leaderLogs_candidate_entries_rvr; eauto; eauto using leaderLogs_candidate_entries_invariant, votes_correct_invariant, cronies_correct_invariant. congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * eauto. * subst. unfold raft_data in *. repeat find_rewrite. eapply lifted_leader_sublog_host; eauto. + eauto. - repeat update_destruct_max_simplify. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. eauto. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. discriminate. + eauto. Qed. Theorem leaderLogs_sublog_do_leader : refined_raft_net_invariant_do_leader leaderLogs_sublog. 
intros A f eq1. simple induction 1; intros B g eq2. apply and. exact (forall x : A, EXType' _ (fun y : B => eq1 x (g y))). exact (forall y : B, EXType' _ (fun x : A => eq1 x (g y))). Defined. Definition inj : Ens' -> Ens. simple induction 1; intros A f fr. exact (sup A fr). Defined.Theorem inj_sound : forall E1 E2 : Ens', EQ' E1 E2 -> EQ (inj E1) (inj E2). simple induction E1; intros A1 f1 fr1; simple induction E2; intros A2 f2 r2; simpl in |- *. simple induction 1; intros HR1 HR2; split. intros a1; elim (HR1 a1); intros a2 Ha2; exists a2; auto with zfc. intros a2; elim (HR2 a2); intros a1 Ha1; exists a1; auto with zfc. Qed. Definition Power' (E : Ens') : Ens' := match E with | sup' A f => sup' _ (fun P : A -> Prop => sup' _ (fun c : depprod'' A (fun a : A => P a) => match c with | dep_i'' a p => f a end)) end. Theorem Power_sound_inj : forall E : Ens', EQ (inj (Power' E)) (Power (inj E)). simple induction E; intros A f HR. simpl in |- *; split. intros P; exists P; split. intros c; elim c; intros a p. exists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc. intros c; elim c; intros a p. exists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc. intros P; exists P; split. intros c; elim c; intros a p. exists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc. intros c; elim c; intros a p. exists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc. Qed. Definition Big := sup Ens' inj.Theorem Big_is_big : forall E : Ens', IN (inj E) Big. intros E; unfold Big in |- *; simpl in |- *; exists E; auto with zfc. Qed.Theorem IN_Big_small : forall E : Ens, IN E Big -> EXType' _ (fun E' : Ens' => EQ E (inj E')). unfold Big in |- *; simpl in |- *; simple induction 1; intros E' HE'; exists E'; auto with zfc. Qed. Theorem IN_small_small : forall (E : Ens) (E' : Ens'), IN E (inj E') -> EXType' _ (fun E1 : Ens' => EQ E (inj E1)). 
Require Export List. Require Import Inclusion. Require Import Inverse_Image. Require Import Wf_nat. Require Import Relation_Definitions. Require Import Relation_Operators. Require Import Relation_Operators_compat. Require Import Lexicographic_Product. Require Import LetP. Require Export WfR0. Section Buch. Load "hCoefStructure". Load "hOrderStructure". Load "hWfRO". Inductive stable : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop := stable0 : forall P Q : list (poly A0 eqA ltM), (forall a : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q) -> (forall a : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable P Q. Hint Resolve stable0. Theorem stable_refl : forall Q : list (poly A0 eqA ltM), stable Q Q. auto. Qed. Theorem stable_trans : forall Q y R : list (poly A0 eqA ltM), stable Q y -> stable y R -> stable Q R. 
:: lb_bots n end. Definition lb_shift n l := lb_bots n ++ l. Fact lb_shift_0 l : lb_shift 0 l = l. Proof. auto. Qed. Fact lb_shift_S n l : lb_shift (S n) l = ‚üò :: lb_shift n l. Proof. auto. Qed. Fact lb_nat_shift n l : ‚ü¶lb_shift n l‚üß = ‚ü¶l‚üß*power n 2. Proof. unfold lb_shift. induction n as [ | n IHn ]; simpl lb_bots. + rewrite power_0; simpl; ring. + simpl app; rewrite lb_nat_fix_1, IHn, power_S; ring. Qed. Fact lb_shift_meet n l m : lb_shift n (l‚Üìm) = (lb_shift n l)‚Üì(lb_shift n m). Proof. induction n as [ | n IHn ]. + repeat rewrite lb_shift_0; auto. + do 3 rewrite lb_shift_S. rewrite lb_meet_cons; f_equal; auto. Qed. Fact lb_shift_join n l m : lb_shift n (l‚Üëm) = (lb_shift n l)‚Üë(lb_shift n m). Proof. induction n as [ | n IHn ]. + repeat rewrite lb_shift_0; auto. + do 3 rewrite lb_shift_S. rewrite lb_join_cons; f_equal; auto. Qed. Fact lb_shift_ortho n l m : length l <= n -> l ‚üÇ lb_shift n m. Proof. revert n. induction l as [ | x l IHl ]; intros [ | n ]; simpl; auto; try lia. intro; rewrite lb_shift_S; constructor; auto; apply IHl; lia. Qed. Fact lb_shift_ortho_meet n l m : length l <= n -> l ‚Üì lb_shift n m ‚âÇ nil. Proof. intros; apply lb_ortho_meet_nil, lb_shift_ortho; auto. Qed. Fact nat_pow2_lb_shift n q : ‚ü¨q*power n 2‚ü≠ ‚âÇ lb_shift n ‚ü¨q‚ü≠ . Proof. apply lb_mask_equiv_equal. rewrite lb_nat_lb, lb_nat_shift, lb_nat_lb; auto. Qed. Fact nat_euclid_pow2_lb n r q : r < power n 2 -> ‚ü¨r+q*power n 2‚ü≠ ‚âÇ ‚ü¨r‚ü≠ ‚Üëlb_shift n ‚ü¨q‚ü≠ . Proof. intros H. apply lb_mask_equiv_equal. rewrite lb_nat_lb. rewrite <- lb_ortho_plus_join. 2: apply lb_shift_ortho, nat_lb_length; auto. rewrite lb_plus_spec_0; f_equal. + rewrite lb_nat_lb; auto. + rewrite lb_nat_shift, lb_nat_lb; auto. Qed. Definition nat_meet n m := ‚ü¶ ‚ü¨n‚ü≠‚Üì‚ü¨m‚ü≠ ‚üß. Local Infix "‚á£" := nat_meet (at level 40, left associativity). Fact nat_meet_comm n m : n‚á£m = m‚á£n. Proof. apply lb_mask_equiv_equal. rewrite lb_meet_comm; auto. Qed. Fact nat_meet_left n m : n‚á£m ‚â≤ n. Proof. apply binary_le_eq_lb_mask. unfold nat_meet. rewrite lb_mask_nat; auto. Qed. Fact nat_meet_right n m : n‚á£m ‚â≤ m. Proof. apply binary_le_eq_lb_mask. unfold nat_meet. rewrite lb_mask_nat; auto. Qed. #[export] Hint Resolve nat_meet_left nat_meet_right : core. Fact binary_le_nat_meet n m : n ‚â≤ m <-> n‚á£m = n. Proof. rewrite equal_lb_mask_equiv. rewrite binary_le_eq_lb_mask. unfold nat_meet. rewrite nat_lb_nat. apply lb_mask_meet. Qed. Theorem nat_meet_dio a b c : a = b‚á£c <-> exists x y, b = a+x /\ c = a+y /\ a ‚â≤ a+x /\ a ‚â≤ a+y /\ x ‚â≤ x+y. 
=> length x < length y). Defined. Theorem wf_Tl : well_founded Tl. apply (wf_inverse_image _ _ lt (length (A:=poly A0 eqA ltM))); auto. generalize lt_wf; auto. Qed. Scheme Sdep := Induction for prod Sort Prop. Require Import Arith. Theorem slice_Tl : forall (a ia : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), Tl (slicef a ia L) (a :: L). intros a b P; elim P; simpl in |- *; auto. unfold slicef in |- *; simpl in |- *; auto. case (foreigner_dec A A0 A1 eqA multA n ltM a b); unfold Tl in |- *; simpl in |- *; auto. intros c l. unfold slicef in |- *; simpl in |- *; auto. case (divp_dec _ _ _ _ _ _ _ _ _ cs n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c); auto. unfold Tl in |- *; simpl in |- *; auto. case (divp_dec _ _ _ _ _ _ _ _ _ cs n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a c) b); auto. intros H' H'0; case (slice a b l); simpl in |- *; auto. unfold Tl in |- *; simpl in |- *; auto. unfold Tl in |- *; simpl in |- *; auto. unfold Tl in |- *; intros H' H'0; case (slice a b l); simpl in |- *; auto with arith. Qed. Inductive genPcP : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop := | genPcP0 : forall (i : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), genPcP i nil L L | genPcP1 : forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM), slice i a L1 = Keep L2 -> genPcP i L2 L L3 -> genPcP i (a :: L1) L (addEnd A A0 eqA n ltM (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os i a) L3) | genPcP2 : forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM), slice i a L1 = DontKeep L2 -> genPcP i L2 L L3 -> genPcP i (a :: L1) L L3. Hint Resolve genPcP0. Theorem genPcP_spolyp1 : forall (i : poly A0 eqA ltM) (L L1 L2 : list _), genPcP i L1 L L2 -> forall a : poly A0 eqA ltM, In a L2 -> (exists b : poly A0 eqA ltM, In b L1 /\ a = spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os i b) \/ In a L. 
l i dent0)) = false) -> listpred dmatch l dmap -> goodSize addrlen inum -> inum <> 0 -> listpred dmatch (l ++ @updN (Rec.data Dent.RA.itemtype) (Dent.Defs.block0) 0 (mk_dent name inum isdir)) (Mem.upd dmap name (inum, isdir)). Proof. intros. pose proof (Dent.Defs.items_per_val_gt_0). erewrite <- Nat.sub_diag, <- updN_app2, Dent.Defs.block0_repeat by auto. apply listpred_updN; auto. rewrite app_length, repeat_length; omega. replace (length l) with (length l + 0) by omega. rewrite removeN_app_r, removeN_repeat, listpred_app by auto. rewrite listpred_dmatch_repeat_dent0. rewrite dmatch_mk_dent by auto. eapply pimpl_apply. cancel. apply ptsto_upd_disjoint; auto. Qed. Lemma listpred_dmatch_eq_mem : forall l m m', listpred dmatch l m -> listpred dmatch l m' -> m = m'. Proof. induction l; cbn; intros m m' H H'. - apply emp_empty_mem_only in H. apply emp_empty_mem_only in H'. congruence. - unfold dmatch at 1 in H. unfold dmatch at 1 in H'. destruct bool_dec. apply IHl; pred_apply; cancel. eapply pimpl_trans in H; [| cancel..]. eapply pimpl_trans in H'; [| cancel..]. revert H. revert H'. unfold_sep_star. intros. repeat deex. match goal with H1 : (ptsto _ _ ?m), H2 : (ptsto _ _ ?m') |- _ => assert (m = m') by (eapply ptsto_complete; eauto); subst end. f_equal. eauto. Qed. Lemma listpred_dmatch_notindomain: forall delist dmap name x, notindomain name dmap -> listpred dmatch delist (upd dmap name x) -> listpred dmatch delist =p=> notindomain name * name |-> x. Proof. intros. intros m ?. replace m with (upd dmap name x) in * by (eauto using listpred_dmatch_eq_mem). apply ptsto_upd_disjoint; auto. Qed. Lemma dmatch_no_0_inum: forall f m, dmatch f m -> forall name isdir, m name = Some (0, isdir) -> False. Proof. unfold dmatch. intros; destruct bool_dec; destruct_lifts. congruence. unfold ptsto in *. intuition. destruct (weq name (DEName f)); subst. congruence. denote (m name = Some _) as Hm. denote (m _ = None) as Ha. rewrite Ha in Hm by auto. congruence. Unshelve. all: auto; repeat constructor. Qed. Lemma listpred_dmatch_no_0_inum: forall dmap m, listpred dmatch dmap m -> forall name isdir, m name = Some (0, isdir) -> False. Proof. induction dmap; cbn; intros. congruence. revert H. unfold_sep_star. intros. repeat deex. unfold mem_union in *. destruct (m1 name) eqn:?. denote (Some _ = Some _) as Hs; inversion Hs; subst; clear Hs. eauto using dmatch_no_0_inum. eauto. Unshelve. all: eauto. Qed. Notation MSLL := BFILE.MSLL. Notation MSAlloc := BFILE.MSAlloc. Notation MSCache := BFILE.MSCache. Notation MSAllocC := BFILE.MSAllocC. Notation MSIAllocC := BFILE.MSIAllocC. Notation MSDBlocks := BFILE.MSDBlocks. Theorem lookup_ok : forall lxp bxp ixp dnum name ms, {< F Fm Fi m0 sm m dmap ilist frees f, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms sm POST:hm' RET:^(ms',r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * rep_macro Fm Fi m bxp ixp dnum dmap ilist frees f ms' sm * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * ( [[ r = None /\ notindomain name dmap ]] \/ exists inum isdir Fd, [[ r = Some (inum, isdir) /\ inum <> 0 /\ (Fd * name |-> (inum, isdir))%pred dmap ]]) CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} lookup lxp ixp dnum name ms. 
From Huffman Require Export Code. From Huffman Require Export Frequency. From Huffman Require Export ISort. From Huffman Require Export Permutation. From Huffman Require Export UniqueKey. From Huffman Require Export PBTree2BTree.Section Restrict. Variable A : Type. Variable empty : A. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Variable m : list A. Definition restrict_code (m : list A) (c : code A) : code A := map (fun x => (fst x, find_code eqA_dec (fst x) c)) (frequency_list eqA_dec m). Theorem restrict_code_unique_key : forall c : code A, unique_key (restrict_code m c). Proof using. intros c; apply ulist_unique_key. unfold restrict_code in |- *. replace (map (fst (B:=_)) (map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c)) (frequency_list eqA_dec m))) with (map (fst (B:=_)) (frequency_list eqA_dec m)). apply unique_key_ulist; auto. elim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes. intros a l H; apply f_equal2 with (f := cons (A:=A)); auto. Qed. Theorem restrict_code_in : forall (a : A) (c : code A), In a m -> find_code eqA_dec a c = find_code eqA_dec a (restrict_code m c). Proof using. intros a c H. apply sym_equal; apply find_code_correct2; auto. apply restrict_code_unique_key. generalize (in_frequency_map _ eqA_dec m a H). unfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes. intros a0; case a0; simpl in |- *; auto with datatypes. intros a1 n l H0 [H1| H1]; try rewrite H1; auto. Qed. Theorem restrict_code_encode_incl : forall (m1 : list A) (c : code A), incl m1 m -> encode eqA_dec c m1 = encode eqA_dec (restrict_code m c) m1. Proof using. intros m1 c; elim m1; simpl in |- *; auto. intros a l H H0. apply f_equal2 with (f := app (A:=bool)); auto with datatypes. apply restrict_code_in; auto with datatypes. apply H; apply incl_tran with (2 := H0); auto with datatypes. Qed. Theorem restrict_code_encode : forall c : code A, encode eqA_dec c m = encode eqA_dec (restrict_code m c) m. 
false = false) by (subst; rewrite <-wmsb_eq_rect; assumption). replace (wordToNat w) with (wordToNat ww) by (subst; rewrite wordToNat_eq_rect; reflexivity). clear Heqww H w. apply wmsb_false_split2_wzero in H0. rewrite <-combine_split with (w:= ww) at 1. rewrite wordToNat_combine. rewrite <-H0. cbn; omega. Qed.Lemma wordToZ_bound_weakened: forall z n, (Z.abs z < n)%Z -> (- n <= z < n)%Z. Proof. intros. apply Z.abs_lt in H. omega. Qed.Lemma zext_size: forall sz n (w: word (sz + n)), (- Z.of_nat (pow2 sz) <= wordToZ w < Z.of_nat (pow2 sz))%Z -> wmsb w false = false -> exists sw, w = zext sw n. Proof. intros. destruct n. - exists (eq_rect _ word w _ (Nat.add_comm _ _)). rewrite zext_zero. apply eq_sym, eq_rect_2. - apply word_exists_bound in H. destruct H as [ssw ?]. assert (wmsb ssw false = false). { apply wmsb_false_pos; apply wmsb_false_pos in H0. rewrite H; assumption. } eexists. apply wordToZ_inj. rewrite zext_wordToNat_equal_Z by discriminate. rewrite <-H. rewrite <-wordToZ_wordToNat_pos by assumption. rewrite wmsb_false_wordToNat_eq by assumption. reflexivity. Qed.Lemma zext_size_1: forall sz (w: word (sz + 1)), wmsb w false = false -> exists sw, w = zext sw 1. Proof. intros. apply zext_size; auto. generalize dependent w. replace (sz + 1) with (S sz) by omega. intros. unfold wordToZ. rewrite H. apply wmsb_false_bound in H. remember (wordToN w) as n; destruct n; simpl. - split. + omega. + pose proof (pow2_zero sz); omega. - rewrite <-N2Z.inj_pos. rewrite <-N_nat_Z. split; [omega|]. apply inj_lt. rewrite <-Npow2_nat. apply Nlt_out; auto. Qed.Lemma sext_wplus_exist: forall sz (w1 w2: word sz) n, exists w: word (S sz), existT word _ (sext w1 (S n) ^+ sext w2 (S n)) = existT word _ (sext w n). Proof. intros; eexists. apply wordToZ_existT; [omega|]. rewrite sext_wplus_wordToZ_distr by discriminate. do 3 rewrite sext_wordToZ. assert (- Z.of_nat (pow2 sz) <= wordToZ w1 + wordToZ w2 < Z.of_nat (pow2 sz))%Z. { clear n. dependent destruction w1. { rewrite (shatter_word w2); cbn; omega. } { remember (WS b w1) as ww1; clear Heqww1 w1 b. pose proof (wordToZ_size' ww1). pose proof (wordToZ_size' w2). destruct H, H0. split. { simpl; do 2 rewrite Nat2Z.inj_add; omega. } { simpl; do 2 rewrite Nat2Z.inj_add; omega. } } } apply wordToZ_ZToWord in H. rewrite <-H. reflexivity. Qed. Arguments natToWord : simpl never. Arguments weq : simpl never. Global Opaque wlt_dec. Definition test_wlt_f (a : nat) (b : nat) : nat := if wlt_dec (natToWord 64 a) $0 then 0 else 0. Theorem test_wlt_f_example: forall x y z, test_wlt_f x y = 0 -> test_wlt_f x z = 0. 
-> Si; Ga ‚ä¶ x. Proof. intros H. do 2 red in H. destruct (@Hrx Ga) as (v & Hv). { intros ? ?; apply in_or_app; right; auto. } apply in_eill_perm with (1 := Permutation_sym Hv). fold (s x v). rewrite <- (vec_zero_plus v), vec_plus_comm. apply H. rewrite ll_tps_app. exists vec_zero, v. repeat split; auto; try (rew vec; fail). all: cycle 1. { apply ll_tps_perm with (map ¬£ (vec_map_list v (fun p => rx p))). apply Permutation_map, Permutation_sym; auto. apply ll_tps_vec_map_list_mono; auto. intros p. red. rewrite vec_map_list_one. apply in_eill_ax. } rewrite <- map_map. apply ll_tps_list_bang_zero. intros A HA. apply in_map_iff in HA. destruct HA as (c & H1 & H2); subst. destruct c as [ a p q | a p q | p q r ]; simpl. + intros y Hy; rew vec; unfold s. apply in_eill_inc with a p; auto. destruct (@Hrx (a::nil)) as (z & Hz). intros ? [ [] | [] ]; apply in_or_app; left. * apply in_flat_map; exists (LL_INC a p q); simpl; auto. * apply in_eill_perm with (vec_map_list (vec_plus z y) rx). - apply Permutation_trans with (1 := vec_map_list_plus _ _ _). change (a::vec_map_list y rx) with ((a::nil)++vec_map_list y rx). apply Permutation_app; auto. apply Permutation_sym; auto. - apply Hy; red. apply in_eill_perm with (1 := Hz), in_eill_ax. + intros u Hu y Hy. rew vec. rewrite vec_plus_comm. apply in_eill_perm with (1 := Permutation_sym (vec_map_list_plus _ _ _)). apply in_eill_dec with a p; auto. + intros u (H3 & H4). rew vec. apply in_eill_fork with p q; auto. Qed.End g_eill_complete_bound.Section g_eill_complete. Variable (Si : list eill_cmd) (Ga : list ll_vars). Notation vars := (flat_map eill_cmd_vars Si ++ Ga). Let vv := nat_sort vars. Let Hvv1 : list_injective vv. Proof. apply nat_sorted_injective, nat_sort_sorted. Qed. Let Hvv2 : incl vv (flat_map eill_cmd_vars Si ++ Ga) /\ incl (flat_map eill_cmd_vars Si ++ Ga) vv. Proof. apply nat_sort_eq. Qed. Let n := length vv. Let w : vec ll_vars n := proj1_sig (list_vec vv). Let Hw : vec_list w = vv. Proof. apply (proj2_sig (list_vec vv)). Qed. Let w_surj : forall u, In u vars -> exists p, u = vec_pos w p. Proof. intros u Hu. apply Hvv2 in Hu; rewrite <- Hw in Hu. revert Hu; apply vec_list_inv. Qed. Variables (x : ll_vars) (Hvalid : forall n s, @ll_sequent_tps n s (map (fun c : eill_cmd => ‚ùó [ic]) Si ++ map ¬£ Ga) (¬£ x) vec_zero). Theorem G_eill_complete : Si; Ga ‚ä¶ x. 
Proof. unfold A, le, lt in |- *. exact le_lt_or_eq. Qed. Definition lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a} := lt_eq_lt_dec. End Nat_Order. Definition bool_le (b b' : bool) := if b then if b' then True else False else True. Definition bool_lt (b b' : bool) := if b then False else if b' then True else False. Module Bool_Order : DEC_ORDER with Definition A := bool with Definition le := bool_le with Definition lt := bool_lt. Definition A := bool. Definition le := bool_le. Definition lt := bool_lt. Theorem ordered : order A le. Proof. split. unfold A, le, reflexive in |- *. intro x; case x; simpl in |- *; auto. unfold A, le, transitive in |- *; simple destruct x; simple destruct y; auto; simple destruct z; auto. unfold A, le, antisymmetric in |- *; simple destruct x; simple destruct y; simpl in |- *; auto; contradiction. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. Proof. unfold A, lt, le in |- *; simple destruct a; simple destruct b; simpl in |- *; tauto. Qed. Theorem lt_diff : forall a b : A, lt a b -> a <> b. Proof. unfold A, lt, bool_lt in |- *; simple destruct a; simple destruct b; auto. Qed. Theorem le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Proof. unfold A, le, lt, bool_lt in |- *; simple destruct a; simple destruct b; auto. Qed. Definition lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a}. unfold A, le, lt, bool_lt in |- *; simple destruct a; simple destruct b; auto. Defined. End Bool_Order. Module Type DATA. Parameter data : Set. End DATA. Module TrivialDict (Key: KEY) (Val: DATA) : DICT with Definition key := Key.A with Definition data := Val.data. Definition key := Key.A. Definition data := Val.data. Definition dict := key -> option data. Definition empty (k : key) := None (A:=data). Definition find (k : key) (d : dict) := d k. Definition add (k : key) (v : data) (d : dict) : dict := fun k' : key => match Key.eqdec k' k with | left _ => Some v | right _ => d k' end. Theorem empty_def : forall k : key, find k empty = None. 
- f_equal; auto. sigma. rewrite map_map_compose; solve_all. now rewrite b up_up_assoc. Qed.#[global] Hint Rewrite inst_assoc : sigma.Lemma subst_compose_assoc s s' s'' : (s ‚àòs s') ‚àòs s'' =1 s ‚àòs (s' ‚àòs s''). Proof. intros i; unfold subst_compose at 1 3 4. now rewrite inst_assoc. Qed.#[global] Hint Rewrite subst_compose_assoc : sigma.Lemma subst_cons_0_shift : (tRel 0 ‚ã ‚Üë) =1 ids. Proof. intros i. destruct i; reflexivity. Qed.#[global] Hint Rewrite subst_cons_0_shift : sigma.Lemma subst_cons_0s_shifts œÉ : ((œÉ 0) ‚ã (‚Üë ‚àòs œÉ)) =1 œÉ. Proof. intros i. destruct i; auto. Qed.#[global] Hint Rewrite subst_cons_0s_shifts : sigma.Lemma Upn_Up œÉ n : ‚áë^(S n) œÉ =1 ‚áë^n ‚áë œÉ. Proof. intros i. unfold Upn. simpl. rewrite subst_consn_app. rewrite subst_consn_tip. unfold Up. apply subst_consn_proper; auto. rewrite shiftk_shift_l. intros i'. unfold subst_cons, subst_compose. destruct i' => //; auto; simpl. - unfold shiftk. now rewrite Nat.add_0_r. - simpl. now rewrite inst_assoc. Qed.Lemma Upn_1 œÉ : ‚áë^1 œÉ =1 ‚áë œÉ. Proof. now rewrite Upn_Up Upn_0. Qed.Lemma Upn_S œÉ n : ‚áë^(S n) œÉ =1 ‚áë ‚áë^n œÉ. Proof. rewrite Upn_Up. induction n in œÉ |- *. * rewrite !Upn_0. now eapply Up_ext. * rewrite Upn_Up. rewrite IHn. eapply Up_ext. now rewrite Upn_Up. Qed. #[global] Hint Rewrite Upn_0 Upn_S : sigma.Lemma subst_inst_aux s k t : subst s k t = inst (up k (subst_fn s)) t. Proof. revert s k. elim t using term_forall_list_ind; simpl in |- *; intros; try easy ; try (try rewrite H; try rewrite H0 ; try rewrite H1 ; easy); try solve [f_equal; solve_all]. - unfold subst_fn, up. elim (Nat.leb_spec k n) => //. intros H. destruct nth_error eqn:Heq. * apply lift_rename. * simpl. eapply nth_error_None in Heq. lia_f_equal. - f_equal; eauto. rewrite H0. apply inst_ext. intros t'; now rewrite (up_up 1 k). - f_equal; eauto. rewrite H0. apply inst_ext. intros t'; now rewrite (up_up 1 k). - f_equal; eauto. rewrite H1. apply inst_ext. intros t'; now rewrite (up_up 1 k). - f_equal; eauto. * unfold map_predicate_k, map_predicate_shift; destruct p; cbn in *; f_equal; solve_all. + now rewrite /shiftf up_up. * solve_all. unfold map_branch_k, map_branch_shift; destruct x; cbn in *; f_equal; solve_all. + now rewrite /shiftf up_up. - f_equal; eauto; solve_all; auto. rewrite b. apply inst_ext. intros t'; now rewrite (up_up #|m| k). - f_equal; eauto. solve_all; auto. rewrite b. apply inst_ext. intros t'; now rewrite (up_up #|m| k). Qed.Lemma subst_fn_subst_consn s : subst_fn s =1 subst_consn s ids. Proof. reflexivity. Qed. Theorem subst_inst s k t : subst s k t = inst (‚áë^k (subst_consn s ids)) t. 
Theorem tptsto'_nonnull {œÉ} ty q a : @tptsto' œÉ ty q nullptr a |-- False. Proof. rewrite tptsto'_nonnull_obs. iDestruct 1 as "[]". Qed. #[local] Instance tptsto'_mono : Proper (genv_leq ==> eq ==> eq ==> eq ==> eq ==> (‚ä¢)) (@tptsto'). Proof. rewrite /tptsto' /oaddr_encodes /addr_encodes. intros ?? HœÉ ??-> ??-> ??-> ??->. iIntros "(%Hnonnull & H)"; iDestruct "H" as (oa) "(Htype_ptr & Hmem_inj_own & Hoa)". iSplitR; [by iPureIntro |]; iExists oa; iFrame "Hmem_inj_own". iSplitL "Htype_ptr"; first by rewrite HœÉ. iStopProof; destruct oa; by solve_proper. Qed. #[local] Instance tptsto'_proper : Proper (genv_eq ==> eq ==> eq ==> eq ==> eq ==> (‚â°)) (@tptsto'). Proof. intros œÉ1 œÉ2 [HœÉ1 HœÉ2] ??-> ??-> ??-> ??->. by split'; apply tptsto'_mono. Qed. #[local] Instance tptsto'_fractional {œÉ} ty p v : Fractional (Œª q, @tptsto' œÉ ty q p v) := _. #[local] Instance tptsto'_timeless {œÉ} ty q p v : Timeless (@tptsto' œÉ ty q p v) := _. #[local] Instance tptsto'_nonvoid {œÉ} ty (q : Qp) p v : Observe [| ty <> Tvoid |] (@tptsto' œÉ ty q p v) := _. #[local] Instance tptsto'_frac_valid {œÉ} ty (q : Qp) p v : Observe [| q ‚â§ 1 |]%Qp (@tptsto' œÉ ty q p v) := _. #[local] Instance tptsto'_agree œÉ ty q1 q2 p v1 v2 : Observe2 [| v1 = v2 |] (@tptsto' œÉ ty q1 p v1) (@tptsto' œÉ ty q2 p v2). Proof. intros; apply: observe_2_intro_persistent. iDestruct 1 as (Hnn1 oa1) "H1". iDestruct 1 as (Hnn2 oa2) "H2". iDestruct (observe_2_elim_pure (oa1 = oa2) with "H1 H2") as %->. destruct oa2; [iApply (observe_2 with "H1 H2") |]. iDestruct (observe_2 [| v1 = v2 |] with "H1 H2") as %->. by iPureIntro. Qed. Definition tptsto {œÉ : genv} (ty : type) (q : Qp) (p : ptr) (v : val) : mpred := Exists v', [| val_related œÉ ty v v' |] ** @tptsto' œÉ ty q p v'. #[global] Instance tptsto_type_ptr : forall (œÉ : genv) ty q p v, Observe (type_ptr ty p) (tptsto ty q p v) := _. Lemma tptsto_live : forall {œÉ} ty (q : Qp) p v, @tptsto œÉ ty q p v |-- live_ptr p ** True. Proof. intros *; rewrite /tptsto. iIntros "H"; iDestruct "H" as (v') "(% & Htptsto')". iApply (tptsto'_live with "Htptsto'"). Qed. #[global] Instance tptsto_nonnull_obs {œÉ} ty q a : Observe False (@tptsto œÉ ty q nullptr a) := _. Theorem tptsto_nonnull {œÉ} ty q a : @tptsto œÉ ty q nullptr a |-- False. 
s m). firstorder. econstructor; firstorder. propxIntuition. eapply HT.split_semp in H0; eauto; subst. propxIntuition. Qed. Theorem heq_star_emp_l : forall P, heq (star emp P) P. intros. unfold heq in *; intuition. eapply himp_star_emp_p. reflexivity. eapply himp_star_emp_c. reflexivity. Qed. Theorem heq_star_emp_r : forall P, heq (star P emp) P. Proof. intros. unfold heq, himp, star, emp, inj, interp in *; intuition. propxIntuition. eapply HT.split_comm in H. eapply HT.split_semp in H; eauto; subst. propxIntuition. propxIntuition. eapply HT.split_comm. eapply HT.split_a_semp_a. auto. eapply HT.semp_smem_emp. Qed. Theorem himp_star_cancel : forall P Q R, himp Q R -> himp (star P Q) (star P R). intros. eapply himp_star_frame. reflexivity. auto. Qed. Theorem heq_star_cancel : forall P Q R, heq Q R -> heq (star P Q) (star P R). intros. eapply heq_star_frame. reflexivity. auto. Qed. Theorem himp_ex_p : forall T (P : T -> _) Q, (forall v, himp (P v) Q) -> himp (ex P) Q. intros. unfold himp, ex in *; simpl in *; intros. unfold interp in *. propxIntuition. eapply Imply_E. eapply valid_weaken; eauto. firstorder. econstructor; firstorder. Qed. Theorem himp_ex_c : forall T (P : T -> _) Q, (exists v, himp Q (P v)) -> himp Q (ex P). Proof. intros. unfold himp, ex in *; simpl in *; intros. unfold interp in *. destruct H. propxIntuition. instantiate (1 := x). eapply Imply_E. eapply valid_weaken; eauto. firstorder. eauto. Qed. Hint Resolve simplify_fwd : heaps. Theorem heq_ex : forall T (P Q : T -> _), (forall v, heq (P v) (Q v)) -> heq (ex P) (ex Q). Proof. unfold heq, himp, ex, interp; intros; intuition; propxIntuition; match goal with | [ H : forall v : ?T, _, x : ?T |- _ ] => specialize (H x) end; intuition. eapply Imply_E. eapply valid_weaken; eauto. firstorder. eauto. eapply Imply_E. eapply valid_weaken; eauto. firstorder. eauto. Qed. Theorem himp_ex : forall T (P Q : T -> _), (forall v, himp (P v) (Q v)) -> himp (ex P) (ex Q). Proof. unfold himp, ex, interp; intuition; propxIntuition; match goal with | [ H : forall v : ?T, _, x : ?T |- _ ] => specialize (H x) end. eapply Imply_E. eapply valid_weaken; eauto. firstorder. eauto. Qed. Theorem heq_ex_star : forall T (P : T -> _) Q, heq (star (ex P) Q) (ex (fun x => star (P x) Q)). Proof. unfold heq, himp, star, ex, interp; intuition; propxIntuition; eauto. Qed. Theorem himp_ex_star : forall T (P : T -> _) Q, himp (star (ex P) Q) (ex (fun x => star (P x) Q)). 
(int.nat i)) by word. erewrite take_S_r; last first. { rewrite list_lookup_fmap. rewrite Hs_inode_lookup //. } rewrite union_list_app_L /= right_id_L //. } iSplit. { iLeft in "HŒ¶". eauto. } iIntros "!> (Hinv&Hinode_s)"; iNamed "Hinv". wpc_pures. iDestruct (big_sepL2_length with "Hpre_inodes") as %Hlens. iApply "HŒ¶"; iFrame. rewrite -> take_ge by len; eauto. Qed. Fixpoint delete_below `(m : gmap nat T) (off : nat) := match off with | O => m | S off' => delete off' (delete_below m off') end. Lemma delete_below_insert : forall (off : nat) (pos : nat) `(m : gmap nat T) v, off <= pos -> delete_below (<[pos:=v]> m) off = <[pos:=v]> (delete_below m off). Proof. induction off; intros; simpl; eauto. rewrite IHoff; last by lia. rewrite delete_insert_ne //. lia. Qed. Lemma delete_below_delete : forall (off : nat) (pos : nat) `(m : gmap nat T), off <= pos -> delete_below (delete pos m) off = delete pos (delete_below m off). Proof. induction off; intros; simpl; eauto. rewrite IHoff; last by lia. rewrite delete_commute //. Qed. Lemma unify_alloc_inodes_used_helper Œ≥used Œ≥blocks allocs s_inodes off : ([‚àó list] i‚Ü¶s_inode ‚àà s_inodes, Pinode Œ≥blocks Œ≥used (off + i) s_inode) -‚àó inode_allused Œ≥used allocs -‚àó ‚åúlength s_inodes = length (map_to_list (delete_below allocs off)) -> ‚ãÉ (map_to_list (delete_below allocs off)).*2 = ‚ãÉ (inode.addrs <$> s_inodes)‚åù. Proof. rewrite /Pinode. iIntros "Hinodes Hall". iInduction s_inodes as [|] "IH" forall (off). { iPureIntro. intros. generalize dependent (map_to_list (delete_below allocs off)). intros. destruct l; simpl in *; congruence. } iDestruct "Hinodes" as "[Ha Hinodes]". iNamed "Ha". iDestruct (inode_used_lookup with "Hused1 Hall") as "%". replace (allocs) with (<[off := a.(inode.addrs)]> (delete off allocs)) at 2 3. 2: { rewrite insert_delete //. replace (off) with (off + 0) by lia. done. } rewrite delete_below_insert; last by lia. rewrite map_to_list_insert. 2: { rewrite delete_below_delete; last by lia. rewrite lookup_delete //. } rewrite ?fmap_cons ?union_list_cons /=. iDestruct ("IH" $! (S off) with "[Hinodes] Hall") as "%IH". { setoid_rewrite plus_n_Sm. iFrame. } rewrite delete_below_delete; last by lia. iPureIntro. intros. rewrite -IH /=; last by lia. done. Qed. Lemma unify_alloc_inodes_used Œ≥used Œ≥blocks s_alloc s_inodes : length s_inodes = num_inodes ‚Üí ([‚àó list] i‚Ü¶s_inode ‚àà s_inodes, Pinode Œ≥blocks Œ≥used i s_inode) -‚àó Palloc Œ≥used s_alloc -‚àó ‚åúalloc.used s_alloc = ‚ãÉ (inode.addrs <$> s_inodes)‚åù. Proof. rewrite /Palloc. iIntros (Hlen) "Hinodes". iNamed 1. rewrite Hused_global. iDestruct (unify_alloc_inodes_used_helper _ _ _ _ 0 with "Hinodes Hused2") as "%Hhelper". iPureIntro. rewrite -Hhelper /=; eauto. rewrite length_gmap_to_list. congruence. Qed. Theorem wpc_Open d (sz: u64) œÉ0 : (5 ‚â§ int.Z sz)%Z ‚Üí {{{ dir_cinv (int.Z sz) œÉ0 true }}} Open (disk_val d) #sz @ ‚ä§ {{{ l, RET #l; pre_dir l (int.Z sz) œÉ0 }}} {{{ dir_cinv (int.Z sz) œÉ0 false }}}. 
simple induction x. intros. elim (a x0). intros. elim (EQC_EXType (f x0) (f' x1) p0 p). intros. exists (dep_i A' (fun x : A' => pi1 (f' x)) x1 x2). simpl in |- *. auto with zfc.simple induction y; intros. elim (b x); intros. cut (EQC (f' x) (f x0)); auto with zfc. intros e. elim (EQC_EXType (f' x) (f x0) e p); intros. exists (dep_i A (fun x0 : A => pi1 (f x0)) x0 x1). simpl in |- *; auto with zfc. Qed.Theorem Union_monC : forall E E' : Ens, CINC E E' -> CINC (Union E) (Union E'). unfold CINC in |- *; intros. elim (Union_CIN E E0 X0); intros. apply CIN_Union with x; elim p; intros; auto with zfc. Qed.Inductive Ens' : Type := sup' : forall A : Type, (A -> Ens') -> Ens'.Inductive EXType' (P : Type) (Q : P -> Prop) : Prop := EXTypei' : forall x : P, Q x -> EXType' P Q.Inductive prod_t' (A B : Type) : Type := pair_t' : A -> B -> prod_t' A B. Inductive depprod'' (A : Type) (P : A -> Type) : Type := dep_i'' : forall x : A, P x -> depprod'' A P. Definition EQ' : Ens' -> Ens' -> Prop. simple induction 1; intros A f eq1. simple induction 1; intros B g eq2. apply and. exact (forall x : A, EXType' _ (fun y : B => eq1 x (g y))). exact (forall y : B, EXType' _ (fun x : A => eq1 x (g y))). Defined. Definition inj : Ens' -> Ens. simple induction 1; intros A f fr. exact (sup A fr). Defined.Theorem inj_sound : forall E1 E2 : Ens', EQ' E1 E2 -> EQ (inj E1) (inj E2). simple induction E1; intros A1 f1 fr1; simple induction E2; intros A2 f2 r2; simpl in |- *. simple induction 1; intros HR1 HR2; split. intros a1; elim (HR1 a1); intros a2 Ha2; exists a2; auto with zfc. intros a2; elim (HR2 a2); intros a1 Ha1; exists a1; auto with zfc. Qed. Definition Power' (E : Ens') : Ens' := match E with | sup' A f => sup' _ (fun P : A -> Prop => sup' _ (fun c : depprod'' A (fun a : A => P a) => match c with | dep_i'' a p => f a end)) end. Theorem Power_sound_inj : forall E : Ens', EQ (inj (Power' E)) (Power (inj E)). 
Heq using K_dec_on; trivial. intros. case Hneq; trivial. case H. reflexivity. Qed.End EqdepDec.Theorem eq_proofs_unicity A (eq_dec : forall x y : A, x = y \/ x <> y) (x : A) : forall (y:A) (p1 p2:x = y), p1 = p2. Proof (@eq_proofs_unicity_on A x (eq_dec x)).Theorem K_dec A (eq_dec : forall x y : A, x = y \/ x <> y) (x : A) : forall P:x = x -> Prop, P (eq_refl x) -> forall p:x = x, P p. Proof (@K_dec_on A x (eq_dec x)).Theorem inj_right_pair A (eq_dec : forall x y : A, x = y \/ x <> y) (x : A) : forall (P:A -> Prop) (y y':P x), ex_intro P x y = ex_intro P x y' -> y = y'. Proof (@inj_right_pair_on A x (eq_dec x)).Require Import EqdepFacts. Theorem K_dec_type : forall A:Type, (forall x y:A, {x = y} + {x <> y}) -> forall (x:A) (P:x = x -> Prop), P (eq_refl x) -> forall p:x = x, P p. Proof. intros A eq_dec x P H p. elim p using K_dec; intros. case (eq_dec x0 y); [left|right]; assumption. trivial. Qed.Theorem K_dec_set : forall A:Set, (forall x y:A, {x = y} + {x <> y}) -> forall (x:A) (P:x = x -> Prop), P (eq_refl x) -> forall p:x = x, P p. Proof fun A => K_dec_type (A:=A). Theorem eq_rect_eq_dec : forall A:Type, (forall x y:A, {x = y} + {x <> y}) -> forall (p:A) (Q:A -> Type) (x:Q p) (h:p = p), x = eq_rect p Q x p h. Proof. intros A eq_dec. apply (Streicher_K__eq_rect_eq A (K_dec_type eq_dec)). Qed. Theorem eq_dep_eq_dec : forall A:Type, (forall x y:A, {x = y} + {x <> y}) -> forall (P:A->Type) (p:A) (x y:P p), eq_dep A P p x p y -> x = y. Proof (fun A eq_dec => eq_rect_eq__eq_dep_eq A (eq_rect_eq_dec eq_dec)).Theorem UIP_dec : forall (A:Type), (forall x y:A, {x = y} + {x <> y}) -> forall (x y:A) (p1 p2:x = y), p1 = p2. Proof (fun A eq_dec => eq_dep_eq__UIP A (eq_dep_eq_dec eq_dec)).Unset Implicit Arguments. Module Type DecidableType. Monomorphic Parameter U:Type. Axiom eq_dec : forall x y:U, {x = y} + {x <> y}.End DecidableType.Module DecidableEqDep (M:DecidableType). Import M. Lemma eq_rect_eq : forall (p:U) (Q:U -> Type) (x:Q p) (h:p = p), x = eq_rect p Q x p h. Proof eq_rect_eq_dec eq_dec. Theorem eq_dep_eq : forall (P:U->Type) (p:U) (x y:P p), eq_dep U P p x p y -> x = y. 
set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. 
Require Import List Arith Lia Eqdep_dec.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.From Undecidability.TRAKHTENBROT Require Import notations utils decidable fol_ops fo_sig.Set Implicit Arguments.Local Hint Resolve in_vec_list in_vec_pos : core.Section first_order_terms. Variable (syms : Type) (ar_syms : syms -> nat). Unset Elimination Schemes. Inductive fo_term : Type := | in_var : nat -> fo_term | in_fot : forall s, vec fo_term (ar_syms s) -> fo_term. Set Elimination Schemes. Section fo_term_rect. Variable (P : fo_term -> Type) (HP0 : forall x, P (in_var x)) (IHP : forall s v, (forall p, P (vec_pos v p)) -> P (@in_fot s v)). Fixpoint fo_term_rect t : P t := match t with | in_var x => HP0 x | in_fot v => IHP v (fun p => fo_term_rect (vec_pos v p)) end. End fo_term_rect. Definition fo_term_rec (P : _ -> Set) := @fo_term_rect P. Definition fo_term_ind (P : _ -> Prop) := @fo_term_rect P. Fixpoint fo_term_size t : nat := match t with | in_var x => 1 | in_fot v => 1 + lsum (vec_list (vec_map fo_term_size v)) end. Fixpoint fo_term_height t : nat := match t with | in_var x => 0 | in_fot v => 1 + lmax (vec_list (vec_map fo_term_height v)) end. Fact fo_term_size_lt s v p : fo_term_size (vec_pos v p) < fo_term_size (@in_fot s v). Proof. simpl; apply le_n_S. generalize (in_vec_pos (vec_map fo_term_size v) p); rew vec. generalize (fo_term_size (vec_pos v p)) (vec_map fo_term_size v). clear v p; intros i v; rewrite in_vec_list. apply lsum_le. Qed. Fact fo_term_height_lt s v p : fo_term_height (vec_pos v p) < fo_term_height (@in_fot s v). Proof. simpl; apply le_n_S. generalize (in_vec_pos (vec_map fo_term_height v) p); rew vec. generalize (fo_term_height (vec_pos v p)) (vec_map fo_term_height v). clear v p; intros i v; rewrite in_vec_list. apply lmax_prop. Qed. Fact in_fot_inv_dep s s' v w : @in_fot s v = @in_fot s' w -> exists E : s = s', eq_rect s (fun s => vec _ (ar_syms s)) v _ E = w. Proof. inversion 1; subst; exists eq_refl; auto. Qed. Section eq_fo_term_dec. Variable eq_syms_dec : discrete syms. Fact in_fot_inv s v w : @in_fot s v = @in_fot s w -> v = w. Proof using eq_syms_dec. intros H; destruct in_fot_inv_dep with (1 := H) as (E & H1). rewrite (UIP_dec eq_syms_dec E eq_refl) in H1; auto. Qed. Theorem eq_fo_term_dec : discrete fo_term. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Import Coq.Bool.Bool. Require Import Coq.Arith.Arith. Require Import Coq.Arith.EqNat. Require Import Coq.lia.Lia. Require Import Imp. Require Import Maps. Definition Assertion := state -> Prop.Definition assert_implies (P Q : Assertion) : Prop := forall st, P st -> Q st.Notation "P ->> Q" := (assert_implies P Q) (at level 80) : hoare_spec_scope. Open Scope hoare_spec_scope.Notation "P <<->> Q" := (P ->> Q /\ Q ->> P) (at level 80) : hoare_spec_scope.Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop := forall st st', c / st \\ st' -> P st -> Q st'.Notation "{{ P }} c {{ Q }}" := (hoare_triple P c Q) (at level 90, c at next level) : hoare_spec_scope.Theorem hoare_post_true : forall (P Q : Assertion) c, (forall st, Q st) -> {{P}} c {{Q}}. Admitted. Theorem hoare_pre_false : forall (P Q : Assertion) c, (forall st, ~(P st)) -> {{P}} c {{Q}}. Admitted. Definition assn_sub X a P : Assertion := fun (st : state) => P (t_update st X (aeval st a)).Notation "P [ X |-> a ]" := (assn_sub X a P) (at level 10).Theorem hoare_asgn : forall Q X a, {{assn_sub X a Q }} (X ::= a) {{Q}}. Admitted. Theorem hoare_asgn_fwd : (forall {X Y: Type} {f g : X -> Y}, (forall (x: X), f x = g x) -> f = g) -> forall m a P, {{fun st => P st /\ t_lookup st X = m}} X ::= a {{fun st => P (t_update st X m) /\ t_lookup st X = aeval (t_update st X m) a }}. Admitted. Theorem hoare_asgn_fwd_exists : (forall {X Y: Type} {f g : X -> Y}, (forall (x: X), f x = g x) -> f = g) -> forall a P, {{fun st => P st}} X ::= a {{fun st => exists m, P (t_update st X m) /\ t_lookup st X = aeval (t_update st X m) a }}. Admitted. Theorem hoare_consequence_pre : forall (P P' Q : Assertion) c, {{P'}} c {{Q}} -> P ->> P' -> {{P}} c {{Q}}. Admitted. Theorem hoare_consequence_post : forall (P Q Q' : Assertion) c, {{P}} c {{Q'}} -> Q' ->> Q -> {{P}} c {{Q}}. 
) . Proof . intros X Y f x isf isx . assert ( is' : forall y : Y , isdecincl ( d1g f y x ) ) . intro y . intro xe . set ( w := ezweq2g f x xe ) . apply ( isdecpropweqf w ( isdecproppathstoisolated X x isx _ ) ) . assert ( is'' : forall y : Y , isdecprop ( paths ( f x ) y ) ) . intro . apply ( isdecpropfromdecincl _ ( is' y ) ( isf y ) ) . intro y' . apply ( pr1 ( is'' y' ) ) . Defined . Definition negimage { X Y : UU } ( f : X -> Y ) := total2 ( fun y : Y => neg ( hfiber f y ) ) . Definition negimagepair { X Y : UU } ( f : X -> Y ) := tpair ( fun y : Y => neg ( hfiber f y ) ) .Lemma isinclfromcoprodwithnegimage { X Y : UU } ( f : X -> Y ) ( is : isincl f ) : isincl ( sumofmaps f ( @pr1 _ ( fun y : Y => neg ( hfiber f y ) ) ) ) . Proof . intros . assert ( noi : forall ( x : X ) ( nx : negimage f ) , neg ( paths ( f x ) ( pr1 nx ) ) ) . intros x nx e . destruct nx as [ y nhf ] . simpl in e . apply ( nhf ( hfiberpair _ x e ) ) . assert ( is' : isincl ( @pr1 _ ( fun y : Y => neg ( hfiber f y ) ) ) ) . apply isinclpr1 . intro y . apply isapropneg . apply ( isofhlevelfsumofmapsnoi 1 f _ is is' noi ) . Defined . Definition iscoproj { X Y : UU } ( f : X -> Y ) := isweq ( sumofmaps f ( @pr1 _ ( fun y : Y => neg ( hfiber f y ) ) ) ) . Definition weqcoproj { X Y : UU } ( f : X -> Y ) ( is : iscoproj f ) : weq ( coprod X ( negimage f ) ) Y := weqpair _ is . Theorem iscoprojfromisdecincl { X Y : UU } ( f : X -> Y ) ( is : isdecincl f ) : iscoproj f . 
Require Export FroundPlus. Require Export ClosestProp. Section ClosestP. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Theorem errorBoundedPlusLe : forall p q pq : float, Fbounded b p -> Fbounded b q -> (Fexp p <= Fexp q)%Z -> Closest b radix (p + q) pq -> exists error : float, error = Rabs (p + q - pq) :>R /\ Fbounded b error /\ Fexp error = Zmin (Fexp p) (Fexp q). 
|- *. rewrite Rmult_1_l. apply Rle_powerRZ. replace 1%R with (INR 1); auto with real arith. apply Zle_trans with (Fexp x); auto. case H; auto. apply Fexp_le_LSB; auto. rewrite LSB_shift with (n := min (precision - Fdigit radix x) (Zabs_nat (dExp b + Fexp x))); auto. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_l. apply Rle_powerRZ; auto with arith. replace 1%R with (INR 1); auto with real arith. exact (Fexp_le_LSB radix (Fshift radix (min (precision - Fdigit radix x) (Zabs_nat (dExp b + Fexp x))) x)). Qed. Theorem MSBisMin : forall f1 f2 : float, (0 <= f1)%R -> isMin b radix f1 f2 -> ~ is_Fzero f1 -> ~ is_Fzero f2 -> MSB radix f1 = MSB radix f2. intros f1 f2 H' H'0 H'1 H'2. apply Zle_antisym. 2: apply MSB_monotone; auto. 2: repeat rewrite Fabs_correct1; auto with arith. 2: apply isMin_inv1 with (1 := H'0). 2: apply RleRoundedR0 with (P := isMin b radix) (r := FtoRradix f1); auto. 2: apply MinRoundedModeP with (precision := precision); auto. case (Zle_or_lt (MSB radix f1) (MSB radix f2)); auto. intros H'3; absurd (Float 1%nat (Zsucc (MSB radix f2)) <= f2)%R. apply Rgt_not_le. red in |- *; unfold FtoRradix in |- *; rewrite <- Fabs_correct1; auto with float arith. apply abs_lt_MSB; auto. apply RleRoundedR0 with (P := isMin b radix) (r := FtoRradix f1); auto with float. apply MinRoundedModeP with (precision := precision); auto. case H'0. intros H'4 H'5; elim H'5; intros H'6 H'7; apply H'7; clear H'5; auto. apply (FboundedOne _ radixMoreThanOne b precision); auto with arith. apply Zle_trans with (Fexp f2). case H'4; auto. apply Zle_trans with (MSB radix f2); auto with zarith. apply Fexp_le_MSB; auto. apply Rle_trans with (FtoR radix (Float 1%nat (MSB radix f1))); auto. apply oneExp_le; auto with zarith. unfold FtoRradix in |- *; rewrite <- Fabs_correct1 with (x := f1); auto with float arith. apply MSB_le_abs; auto. Qed. Theorem MSBtoZero : forall f1 f2 : float, ToZeroP b radix f1 f2 -> ~ is_Fzero f1 -> ~ is_Fzero f2 -> MSB radix f1 = MSB radix f2. intros f1 f2 H' H'0 H'1; Casec H'; intros tmp; Elimc tmp; intros H1 H2. apply MSBisMin; auto. rewrite (MSB_opp radix f1). rewrite (MSB_opp radix f2). apply MSBisMin; auto with float. unfold FtoRradix in |- *; rewrite Fopp_correct. replace 0%R with (-0)%R; auto with real. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with float. Qed. Theorem MSBBoundNotZero : forall P : R -> float -> Prop, RoundedModeP b radix P -> forall f1 f2 : float, P f1 f2 -> f1 <> 0%R :>R -> (- dExp b <= MSB radix f1)%Z -> f2 <> 0%R :>R. 
Require Export UnitaryOps.Local Open Scope nat_scope. Local Open Scope ucom_scope.Fixpoint GHZ (dim n : nat) : base_ucom dim := match n with | 0 => SKIP | 1 => H 0 | S (S n'' as n') => GHZ dim n' ; CNOT n'' n' end.Local Open Scope R_scope. Local Open Scope C_scope.Definition ghz (n : nat) : Matrix (2^n) (1^n) := match n with | 0 => I 1 | S n' => 1/ ‚àö2 .* (n ‚®Ç ‚à£0‚ü©) .+ 1/ ‚àö2 .* (n ‚®Ç ‚à£1‚ü©) end.Lemma WF_ghz : forall n : nat, WF_Matrix (ghz n). Proof. induction n; simpl; auto with wf_db. Qed.Lemma typed_GHZ : forall dim n, (0 < dim)%nat -> (n <= dim)%nat -> uc_well_typed (GHZ dim n). Proof. intros. induction n. - simpl. apply uc_well_typed_ID; assumption. - simpl. destruct n. + apply uc_well_typed_H; assumption. + apply WT_seq. apply IHn; try lia. apply uc_well_typed_CNOT; lia. Qed. Theorem GHZ_correct' : forall dim n : nat, (0 < dim)%nat -> (n <= dim)%nat -> uc_eval (GHZ dim n) √ó dim ‚®Ç ‚à£0‚ü© = ghz n ‚äó (dim - n) ‚®Ç ‚à£0‚ü©. 
synced_list_length, ipack_length. substl (length items); rewrite divup_mul; auto. assert (length (synced_list (ipack (updN block0 O e))) = 1). rewrite synced_list_length, ipack_length. rewrite block0_repeat, length_updN, repeat_length, divup_same; auto. rewrite arrayN_ptsto_selN_0; auto. rewrite synced_list_selN; unfold ipack. erewrite selN_map, list_chunk_spec; simpl. rewrite setlen_exact; eauto. rewrite length_updN, block0_repeat, repeat_length; auto. setoid_rewrite list_chunk_length. rewrite length_updN, block0_repeat, repeat_length, divup_same; auto. Unshelve. exact $0. Qed. Lemma extend_item_valid : forall f e items, Rec.well_formed e -> items_valid f items -> items_valid {| BFILE.BFData := BFILE.BFData f ++ [(block2val (updN block0 0 e), [])]; BFILE.BFAttr := BFILE.BFAttr f; BFILE.BFCache := BFILE.BFCache f |} (items ++ (updN block0 0 e)). Proof. unfold items_valid, RALen in *; intuition; simpl. repeat rewrite app_length; simpl. rewrite block0_repeat, length_updN, repeat_length. rewrite Nat.mul_add_distr_r, Nat.mul_1_l; omega. apply Forall_append; auto. apply Forall_updN; auto. rewrite block0_repeat. apply Forall_repeat. apply item0_wellformed. Qed. Theorem extend_ok : forall lxp ixp bxp inum e ms, {< F Fm Fi m0 sm m flist f items ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[ Rec.well_formed e ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] POST:hm' RET: ^(ms', r) exists m', [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * ([[ isError r ]] * LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' \/ [[ r = OK tt ]] * exists flist' f' ilist' frees', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * [[[ m' ::: (Fm * BFILE.rep bxp sm ixp flist' ilist' frees' (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[[ flist' ::: (Fi * inum |-> f') ]]] * [[[ RAData f' ::: rep f' (items ++ (updN block0 0 e)) ]]] * [[ BFILE.ilist_safe ilist (BFILE.pick_balloc frees (MSAlloc ms')) ilist' (BFILE.pick_balloc frees' (MSAlloc ms')) ]] * [[ BFILE.treeseq_ilist_safe inum ilist ilist' ]] ) CRASH:hm' LOG.intact lxp F m0 sm hm' >} extend lxp bxp ixp inum e ms. Proof. unfold extend, rep. prestep. norm. cancel. intuition. eauto. eauto. eauto. safestep. or_l; safecancel. or_r. norm; [ cancel | intuition eauto ]. simpl; pred_apply; norm; [ | intuition ]. cancel; apply extend_ok_helper; auto. apply extend_item_valid; auto. Qed. Theorem readall_ok : forall lxp ixp bxp inum ms, {< F Fm Fi m0 sm m flist f items ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * [[ r = items ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} readall lxp ixp inum ms. 
:= H'0); auto. elim H'0; intros H'1 H'2; elim H'2; intros H'3 H'4; apply H'4; clear H'2 H'0; auto. case H'; auto. apply isMax_inv1 with (1 := H'); auto. Qed. Theorem MinOppMax : forall (p : float) (r : R), isMin r p -> isMax (- r) (Fopp p). intros p r H'; split. apply oppBounded; case H'; auto. split. unfold FtoRradix in |- *; rewrite Fopp_correct. apply Ropp_le_contravar; apply isMin_inv1 with (1 := H'); auto. intros f H'0 H'1. rewrite <- (Fopp_Fopp f). unfold FtoRradix in |- *; rewrite Fopp_correct; rewrite Fopp_correct. apply Ropp_le_contravar. elim H'. intros H'2 H'3; elim H'3; intros H'4 H'5; apply H'5; clear H'3. apply oppBounded; case H'; auto. rewrite <- (Ropp_involutive r). unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. Qed. Theorem MaxOppMin : forall (p : float) (r : R), isMax r p -> isMin (- r) (Fopp p). intros p r H'; split. apply oppBounded; case H'; auto. split. unfold FtoRradix in |- *; rewrite Fopp_correct. apply Ropp_le_contravar; apply isMax_inv1 with (1 := H'); auto. intros f H'0 H'1. rewrite <- (Fopp_Fopp f). unfold FtoRradix in |- *; repeat rewrite Fopp_correct. apply Ropp_le_contravar. rewrite <- (Fopp_correct radix f). elim H'. intros H'2 H'3; elim H'3; intros H'4 H'5; apply H'5; clear H'3. apply oppBounded; auto. rewrite <- (Ropp_involutive r). unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. Qed. Theorem MinMax : forall (p : float) (r : R), isMin r p -> r <> p :>R -> isMax r (FNSucc b radix precision p). intros p r H' H'0. split. apply FcanonicBound with (radix := radix); auto with float. apply FNSuccCanonic; auto. inversion H'; auto. split. case (Rle_or_lt (FNSucc b radix precision p) r); intros H'2; auto. absurd (FNSucc b radix precision p <= p)%R. apply Rlt_not_le. unfold FtoRradix in |- *; apply FNSuccLt; auto. inversion H'; auto. elim H0; intros H'1 H'3; apply H'3; auto. apply FcanonicBound with (radix := radix); auto with float. apply Rlt_le; auto. intros f H'2 H'3. replace (FtoRradix f) with (FtoRradix (Fnormalize radix b precision f)). unfold FtoRradix in |- *; apply FNSuccProp; auto. inversion H'; auto. apply FcanonicBound with (radix := radix); auto with float. apply Rlt_le_trans with r; auto. case (Rle_or_lt r p); auto. intros H'4; Contradict H'0. apply Rle_antisym; auto; apply isMin_inv1 with (1 := H'); auto. rewrite FnormalizeCorrect; auto. unfold FtoRradix in |- *; apply FnormalizeCorrect; auto. Qed. Theorem MinExList : forall (r : R) (L : list float), (forall f : float, In f L -> (r < f)%R) \/ (exists min : float, In min L /\ (min <= r)%R /\ (forall f : float, In f L -> (f <= r)%R -> (f <= min)%R)). 
+ Z_of_nat 1)%Z with (Z_of_nat (S n)). repeat rewrite <- INR_IZR_INZ. apply INR_lt_nm; auto. rewrite Zplus_comm; rewrite <- inj_plus; simpl in |- *; auto. rewrite plus_IZR; simpl in |- *; auto with real. repeat rewrite <- INR_IZR_INZ; auto with real. Qed. Theorem Int_part_IZR : forall z : Z, Int_part (IZR z) = z. intros z; unfold Int_part in |- *. cut (up (IZR z) = (z + 1)%Z). intros Z1; rewrite Z1; rewrite Zplus_comm; apply Zminus_plus; auto with zarith. apply sym_equal; apply tech_up; simpl in |- *; auto with real zarith. replace (IZR z) with (IZR z + IZR 0)%R; try rewrite plus_IZR; auto with real zarith. Qed. Theorem Zlt_Rlt : forall z1 z2 : Z, (IZR z1 < IZR z2)%R -> (z1 < z2)%Z. intros z1 z2 H; case (Zle_or_lt z2 z1); auto. intros H1; Contradict H; auto with real zarith. apply Rle_not_lt; auto with real zarith. Qed. Theorem Zle_Rle : forall z1 z2 : Z, (IZR z1 <= IZR z2)%R -> (z1 <= z2)%Z. intros z1 z2 H; case (Zle_or_lt z1 z2); auto. intros H1; Contradict H; auto with real zarith. apply Rlt_not_le; auto with real zarith. Qed. Theorem IZR_inv : forall z1 z2 : Z, IZR z1 = IZR z2 :>R -> z1 = z2. intros z1 z2 H; apply Zle_antisym; apply Zle_Rle; rewrite H; auto with real. Qed. Theorem Zabs_eq_opp : forall x, (x <= 0)%Z -> Zabs x = (- x)%Z. intros x; case x; simpl in |- *; auto. intros p H; Contradict H; auto with zarith. Qed. Theorem Zabs_Zs : forall z : Z, (Zabs (Zsucc z) <= Zsucc (Zabs z))%Z. intros z; case z; auto. simpl in |- *; auto with zarith. repeat rewrite Zabs_eq; auto with zarith. intros p; rewrite Zabs_eq_opp; auto with zarith. 2: unfold Zsucc in |- *; replace 0%Z with (-1 + 1)%Z; auto with zarith. 2: case p; simpl in |- *; intros; red in |- *; simpl in |- *; intros; red in |- *; intros; discriminate. replace (- Zsucc (Zneg p))%Z with (Zpos p - 1)%Z. replace (Zsucc (Zabs (Zneg p))) with (Zpos p + 1)%Z; auto with zarith. unfold Zsucc in |- *; rewrite Zopp_plus_distr. auto with zarith. Qed. Hint Resolve Zabs_Zs: zarith. Theorem Zle_Zpred : forall x y : Z, (x < y)%Z -> (x <= Zpred y)%Z. intros x y H; apply Zlt_succ_le. rewrite <- Zsucc_pred; auto. Qed. Hint Resolve Zle_Zpred: zarith. Theorem Zabs_Zopp : forall z : Z, Zabs (- z) = Zabs z. 
Defined. Theorem weqhfibercoprodf1 {X Y X' Y' : UU} (f : X -> X') (g : Y -> Y') (x' : X') : weq (hfiber f x') (hfiber (coprodf f g) (ii1 x')). Proof. intros. set (ix := @ii1 X Y). set (ix' := @ii1 X' Y'). set (fpg := coprodf f g). set (fpgix := Œª x : X, (fpg (ix x))). assert (w1 : weq (hfiber f x') (hfiber fpgix (ix' x'))) by apply (samehfibers f ix' (isinclii1 _ _) x'). assert (w2 : weq (hfiber fpgix (ix' x')) (hfiber fpg (ix' x'))). { split with (hfibersgftog ix fpg (ix' x')). unfold isweq. intro y. set (u := invezmaphf ix fpg (ix' x') y). assert (is : isweq u) by apply isweqinvezmaphf. apply (iscontrweqb (make_weq u is)). induction y as [ xy e ]. induction xy as [ x0 | y0 ]. - simpl. apply iscontrhfiberofincl. apply (isinclii1 X Y). - apply (fromempty ((negpathsii2ii1 x' (g y0)) e)). } apply (weqcomp w1 w2). Defined. Theorem weqhfibercoprodf2 {X Y X' Y' : UU} (f : X -> X') (g : Y -> Y') (y' : Y') : weq (hfiber g y') (hfiber (coprodf f g) (ii2 y')). Proof. intros. set (iy := @ii2 X Y). set (iy' := @ii2 X' Y'). set (fpg := coprodf f g). set (fpgiy := Œª y : Y, (fpg (iy y))). assert (w1 : weq (hfiber g y') (hfiber fpgiy (iy' y'))) by apply (samehfibers g iy' (isinclii2 _ _) y'). assert (w2 : weq (hfiber fpgiy (iy' y')) (hfiber fpg (iy' y'))). { split with (hfibersgftog iy fpg (iy' y')). unfold isweq. intro y. set (u:= invezmaphf iy fpg (iy' y') y). assert (is : isweq u) by apply isweqinvezmaphf. apply (iscontrweqb (make_weq u is)). induction y as [ xy e ]. induction xy as [ x0 | y0 ]. simpl. apply (fromempty ((negpathsii1ii2 (f x0) y') e)). simpl. apply iscontrhfiberofincl. apply (isinclii2 X Y). } apply (weqcomp w1 w2). Defined.Theorem isofhlevelfcoprodf (n : nat) {X Y Z T : UU} (f : X -> Z) (g : Y -> T) (is1 : isofhlevelf n f) (is2 : isofhlevelf n g) : isofhlevelf n (coprodf f g). Proof. intros. unfold isofhlevelf. intro y. induction y as [ z | t ]. apply (isofhlevelweqf n (weqhfibercoprodf1 f g z)). apply (is1 z). apply (isofhlevelweqf n (weqhfibercoprodf2 f g t)). apply (is2 t). Defined. Theorem isofhlevelsnsummand1 (n : nat) (X Y : UU) : isofhlevel (S n) (coprod X Y) -> isofhlevel (S n) X. 
Require Export List. From Huffman Require Export Aux. Section permutation. Variable A : Type. Inductive permutation : list A -> list A -> Prop := | permutation_nil : permutation nil nil | permutation_skip : forall (a : A) (l1 l2 : list A), permutation l2 l1 -> permutation (a :: l2) (a :: l1) | permutation_swap : forall (a b : A) (l : list A), permutation (a :: b :: l) (b :: a :: l) | permutation_trans : forall l1 l2 l3 : list A, permutation l1 l2 -> permutation l2 l3 -> permutation l1 l3. Hint Constructors permutation : core. Theorem permutation_refl : forall l : list A, permutation l l. Proof using. simple induction l. apply permutation_nil. intros a l1 H. apply permutation_skip with (1 := H). Qed. Hint Resolve permutation_refl : core. Theorem permutation_sym : forall l m : list A, permutation l m -> permutation m l. 
Pr $1 $0 --> Pr (prep x $1) (prep y $0)) R. Definition F3 := (‚àÄ Pr $0 $0 --> Q). Definition F : form := F1 ==> F2 ==> F3 --> Q. Lemma iprep_eval domain (I : interp domain) rho x s : eval rho (prep x s) = iprep x (eval rho s). Proof. induction x; cbn; trivial. now rewrite <- IHx. Qed. Lemma iprep_app domain (I : interp domain) x y d : iprep (x ++ y) d = iprep x (iprep y d). Proof. induction x; cbn; trivial. now rewrite <- IHx. Qed. Global Instance IB : interp (string bool). Proof using R. split; intros [] v. - exact (b :: Vector.hd v). - exact nil. - exact (derivable R (Vector.hd v) (Vector.hd (Vector.tl v))). - exact (dPCPb R). Defined. Lemma IB_prep rho s t : eval rho (prep s t) = s ++ eval rho t. Proof. induction s; cbn; trivial. rewrite <- IHs. reflexivity. Qed. Lemma IB_enc rho s : eval rho (enc s) = s. Proof. unfold enc. rewrite IB_prep. cbn. apply app_nil_r. Qed. Lemma IB_drv rho t1 t2 : rho ‚ä® (Pr t1 t2) <-> derivable R (eval rho t1) (eval rho t2). Proof. cbn. reflexivity. Qed. Lemma IB_F1 rho : rho ‚ä´ F1. Proof. unfold F1. intros ? ([x y] & <- & ?) % in_map_iff. cbn. econstructor. now rewrite !IB_enc. Qed. Lemma IB_F2 rho : rho ‚ä´ F2. Proof. unfold F2. intros ? ([x y] & <- & ?) % in_map_iff u v ?. cbn. rewrite !IB_prep. cbn in *. eauto using der_sing, der_cons. Qed. Lemma IB_F3 rho : rho ‚ä® F3. Proof. cbn. unfold dPCPb, dPCP. eauto. Qed. Lemma IB_F rho : rho ‚ä® F -> dPCPb R. Proof. intros H. unfold F in H. rewrite !impl_sat in H. eapply H. - eapply IB_F1. - eapply IB_F2. - apply IB_F3. Qed. Lemma drv_val domain (I : interp domain) rho u v : derivable R u v -> rho ‚ä® (F1 ==> F2 ==> Pr (enc u) (enc v)). Proof. rewrite !impl_sat. intros. induction H. - eapply H0. eapply in_map_iff. exists (x/y). eauto. - eapply (H1 (‚àÄ ‚àÄ Pr $1 $0 --> Pr (prep x $1) (prep y $0))) in IHderivable. + cbn in *. unfold enc in *. rewrite !iprep_eval in *. cbn in *. rewrite <- !iprep_app in IHderivable. eapply IHderivable. + eapply in_map_iff. exists (x/y). eauto. Qed. Theorem BPCP_valid : PCPb R <-> valid F. 
-> canonical (Float beta (Z.abs m) e). Proof. intros m e H. unfold canonical. now rewrite F2R_Zabs, cexp_abs. Qed.Theorem canonical_0 : canonical (Float beta 0 (fexp (mag beta 0%R))). Proof. unfold canonical; simpl ; unfold cexp. now rewrite F2R_0. Qed.Theorem canonical_unique : forall f1 f2, canonical f1 -> canonical f2 -> F2R f1 = F2R f2 -> f1 = f2. Proof. intros (m1, e1) (m2, e2). unfold canonical. simpl. intros H1 H2 H. rewrite H in H1. rewrite <- H2 in H1. clear H2. rewrite H1 in H |- *. apply (f_equal (fun m => Float beta m e2)). apply eq_F2R with (1 := H). Qed.Theorem scaled_mantissa_generic : forall x, generic_format x -> scaled_mantissa x = IZR (Ztrunc (scaled_mantissa x)). Proof. intros x Hx. unfold scaled_mantissa. pattern x at 1 3 ; rewrite Hx. unfold F2R. simpl. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r. now rewrite Ztrunc_IZR. Qed.Theorem scaled_mantissa_mult_bpow : forall x, (scaled_mantissa x * bpow (cexp x))%R = x. Proof. intros x. unfold scaled_mantissa. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l. apply Rmult_1_r. Qed.Theorem scaled_mantissa_0 : scaled_mantissa 0 = 0%R. Proof. apply Rmult_0_l. Qed.Theorem scaled_mantissa_opp : forall x, scaled_mantissa (-x) = (-scaled_mantissa x)%R. Proof. intros x. unfold scaled_mantissa. rewrite cexp_opp. now rewrite Ropp_mult_distr_l_reverse. Qed.Theorem scaled_mantissa_abs : forall x, scaled_mantissa (Rabs x) = Rabs (scaled_mantissa x). Proof. intros x. unfold scaled_mantissa. rewrite cexp_abs, Rabs_mult. apply f_equal. apply sym_eq. apply Rabs_pos_eq. apply bpow_ge_0. Qed.Theorem generic_format_opp : forall x, generic_format x -> generic_format (-x). Proof. intros x Hx. unfold generic_format. rewrite scaled_mantissa_opp, cexp_opp. rewrite Ztrunc_opp. rewrite F2R_Zopp. now apply f_equal. Qed.Theorem generic_format_abs : forall x, generic_format x -> generic_format (Rabs x). Proof. intros x Hx. unfold generic_format. rewrite scaled_mantissa_abs, cexp_abs. rewrite Ztrunc_abs. rewrite F2R_Zabs. now apply f_equal. Qed.Theorem generic_format_abs_inv : forall x, generic_format (Rabs x) -> generic_format x. Proof. intros x. unfold generic_format, Rabs. case Rcase_abs ; intros _. rewrite scaled_mantissa_opp, cexp_opp, Ztrunc_opp. intros H. rewrite <- (Ropp_involutive x) at 1. rewrite H, F2R_Zopp. apply Ropp_involutive. easy. Qed.Theorem cexp_fexp : forall x ex, (bpow (ex - 1) <= Rabs x < bpow ex)%R -> cexp x = fexp ex. Proof. intros x ex Hx. unfold cexp. now rewrite mag_unique with (1 := Hx). Qed.Theorem cexp_fexp_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> cexp x = fexp ex. Proof. intros x ex Hx. apply cexp_fexp. rewrite Rabs_pos_eq. exact Hx. apply Rle_trans with (2 := proj1 Hx). apply bpow_ge_0. Qed. Theorem mantissa_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> (0 < x * bpow (- fexp ex) < 1)%R. 
defs := ds; calls := cs |} -> cs = M.empty _. Proof. induction 3; simpl; intros; subst; [inv H; reflexivity|]. destruct l as [pann pds pcs]; simpl in *; inv H4. destruct sul as [|]; destruct pann; try discriminate. specialize (IHSubstepsInd _ _ eq_refl); subst. inv H0; auto. apply dmNoCalls_Substep in HAction; subst; auto. - unfold ModEquiv in Hequiv; destruct Hequiv. eapply MethsEquiv_in in HIn; eauto. - eapply Forall_forall in Hdms; eauto. Qed.End NoCalls.Section OneDepth. Variable m : Modules. Hypotheses (Hequiv: ModEquiv type typeUT m) (Hdms: Forall (fun dm => dmNoCalls dm = true) (getDefsBodies m)) (Hedms: getExtDefs m = nil). Section GivenOldRegs. Variable o : RegsT. Inductive SubstepMeths : list (string * {x : SignatureT & SignT x}) -> UpdatesT -> Prop := | SmsNil: SubstepMeths nil (M.empty _) | SmsCons: forall mn mar u cs, Substep m o u (Meth (Some (mn :: mar)%struct)) cs -> forall pms pu, SubstepMeths pms pu -> M.Disj u pu -> SubstepMeths ((mn, mar) :: pms) (M.union u pu). Inductive StepDet : UpdatesT -> LabelT -> Prop := | SbEmptyRule: StepDet (M.empty _) {| annot := Some None; defs := M.empty _; calls := M.empty _ |} | SbEmptyMeth: StepDet (M.empty _) {| annot := None; defs := M.empty _; calls := M.empty _ |} | SbRule: forall ru rcs rn, Substep m o ru (Rle (Some rn)) rcs -> forall mu, SubstepMeths (M.elements (M.restrict rcs (getDefs m))) mu -> M.Disj ru mu -> forall u cs, u = M.union ru mu -> cs = M.complement rcs (getDefs m) -> StepDet u {| annot := Some (Some rn); defs := M.empty _; calls := cs |}. End GivenOldRegs. Section FromDet. Lemma substepMeths_implies_substepsInd: forall o mu meths, SubstepMeths o meths mu -> forall ms, M.KeysSubset ms (getDefs m) -> meths = M.elements ms -> SubstepsInd m o mu {| annot := None; defs := ms; calls := M.empty _ |}. Proof. induction 1; simpl; intros. - apply eq_sym, M.F.P.elements_Empty in H0. apply M.empty_canon in H0; subst. constructor. - assert (cs = M.empty _). { inv H; inv Hsig. eapply dmNoCalls_Substep; eauto. { unfold ModEquiv in Hequiv; destruct Hequiv. eapply MethsEquiv_in in H4; eauto. } { eapply Forall_forall in Hdms; eauto. } } subst. apply elements_cons in H3; dest; subst. econstructor. + eapply IHSubstepMeths; try reflexivity. eapply M.KeysSubset_add_1; eauto. + eassumption. + unfold CanCombineUUL; cbn; repeat split; [mdisj|mdisj|findeq]. + meq. + reflexivity. Qed. Theorem stepDet_implies_step: forall o u l, StepDet o u l -> Step m o u l. 
Limits.GenProd_GenSum. From Categories Require Import Functor.Functor. From Categories Require Import NatTrans.NatTrans. From Categories Require Import Basic_Cons.Terminal Basic_Cons.Equalizer Basic_Cons.Limits Basic_Cons.Facts.Equalizer_Monic . From Categories Require Import Archetypal.Discr.Discr.Section Complete_SSC_Initial. Context {C : Category} (CC : Complete C) (SSC : Solution_Set_Cond C) . Definition SSC_Prod : (Œ (SSC_Objs SSC))%object := (LimitOf (Discr_Func (SSC_Objs SSC))). Definition SSC_Prod_WI (c : C) : (SSC_Prod ‚Äì‚âª c)%morphism := ( (projT2 (SSC_jointly_weakly_initial SSC c)) ‚àò ( Trans (cone_edge SSC_Prod) (projT1 (SSC_jointly_weakly_initial SSC c)) ) )%morphism . Definition endomorph_const (h : (SSC_Prod ‚Äì‚âª SSC_Prod)%morphism) : C := SSC_Prod . Definition Endo_Prod : (Œ endomorph_const)%object := (LimitOf (Discr_Func endomorph_const)). Program Definition Cone_Endo_Prod_ids : Cone (Discr_Func endomorph_const) := {| cone_apex := {| FO := fun _ => SSC_Prod; FA := fun _ _ _ => id |}; cone_edge := {| Trans := fun _ => id |} |} . Definition morph_to_Endo_Prod_ids : (SSC_Prod ‚Äì‚âª Endo_Prod)%morphism := Trans (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_ids) tt. Program Definition Cone_Endo_Prod_endomorphs : Cone (Discr_Func endomorph_const) := {| cone_apex := {| FO := fun _ => SSC_Prod; FA := fun _ _ _ => id |}; cone_edge := {| Trans := fun h => h |} |} . Definition morph_to_Endo_Prod_endomorphs : (SSC_Prod ‚Äì‚âª Endo_Prod)%morphism := Trans (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_endomorphs) tt. Definition ids_endomorphs_equalizer : Equalizer morph_to_Endo_Prod_endomorphs morph_to_Endo_Prod_ids := Equalizer_as_Limit morph_to_Endo_Prod_endomorphs morph_to_Endo_Prod_ids (LimitOf (Equalizer_Producing_Func morph_to_Endo_Prod_endomorphs morph_to_Endo_Prod_ids) ) . Definition ids_endomorphs_equalizer_WI (c : C) : (ids_endomorphs_equalizer ‚Äì‚âª c)%morphism := (SSC_Prod_WI c ‚àò equalizer_morph ids_endomorphs_equalizer)%morphism . Theorem ids_endomorphs_equalizer_morph_neutralizes_endomorphs (d : (SSC_Prod ‚Äì‚âª SSC_Prod)%morphism) : (d ‚àò equalizer_morph ids_endomorphs_equalizer)%morphism = equalizer_morph ids_endomorphs_equalizer . Proof. assert (H := f_equal (fun w => ((Trans Endo_Prod d) ‚àò w)%morphism) (equalizer_morph_com ids_endomorphs_equalizer) ). cbn -[equalizer_morph ids_endomorphs_equalizer Endo_Prod] in H. unfold morph_to_Endo_Prod_endomorphs, morph_to_Endo_Prod_ids in H. repeat rewrite assoc_sym in H. assert (V := f_equal (fun w : ((Functor_Ops.Functor_compose (Functor_To_1_Cat (Discr_Cat (SSC_Prod ‚Äì‚âª SSC_Prod)%morphism)) Cone_Endo_Prod_endomorphs) ‚Äì‚âª Discr_Func endomorph_const)%nattrans => Trans w d) (cone_morph_com (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_endomorphs)) ). cbn -[LRKE_morph_ex Endo_Prod] in V. rewrite From_Term_Cat in V. simpl_ids in V. rewrite <- V in H. clear V. assert (V := f_equal (fun w : ((Functor_Ops.Functor_compose (Functor_To_1_Cat (Discr_Cat (SSC_Prod ‚Äì‚âª SSC_Prod)%morphism)) Cone_Endo_Prod_ids) ‚Äì‚âª Discr_Func endomorph_const)%nattrans => Trans w d) (cone_morph_com (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_ids)) ). cbn -[LRKE_morph_ex Endo_Prod] in V. rewrite From_Term_Cat in V. simpl_ids in V. rewrite <- V in H. clear V. auto. Qed. Section equalizer_of_morphs_from_ids_endomorphs_equalizer_iso. Context {d : C} (f g : (ids_endomorphs_equalizer ‚Äì‚âª d)%morphism) . Definition equalizer_of_morphs_from_ids_endomorphs_equalizer : Equalizer f g := Equalizer_as_Limit f g (LimitOf (Equalizer_Producing_Func f g)) . Theorem equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_RI : ((equalizer_morph (equalizer_of_morphs_from_ids_endomorphs_equalizer)) ‚àò ((SSC_Prod_WI _) ‚àò (equalizer_morph ids_endomorphs_equalizer)))%morphism = id. 
a y b) with le_lt_dec x y => { | left _ with c1 => { | Red := balance1 (ins a) y b; | Black := {<BlackNode (pr2 (ins a)) y b>} }; | right _ with c2 => { | Red := balance2 (ins b) y a; | Black := {< BlackNode a y (pr2 (ins b))>} } }. Equations insertResult (c : color) (n : nat) : Set := insertResult Red n := rbtree Black (S n); insertResult Black n := Œ£ c', rbtree c' n. Transparent insertResult. Equations makeRbtree c n (r : insResult c n) : insertResult c n := makeRbtree Red _ (RedNode' a x b) := BlackNode a x b; makeRbtree Black _ r := r. Arguments makeRbtree [c n] _. Equations insert {c n} (t : rbtree c n) : insertResult c n := insert t := makeRbtree (ins t). Section present. Variable z : nat. Lemma present_balance1 : forall n (a : rtree n) (y : nat) c2 (b : rbtree c2 n), present z (pr2 (balance1 a y b)) <-> rpresent z a \/ z = y \/ present z b. Proof. intros. funelim (balance1 a y b); subst; simpl in *; tauto. Qed. Lemma present_balance2 : forall n (a : rtree n) (y : nat) c2 (b : rbtree c2 n), present z (pr2 (balance2 a y b)) <-> rpresent z a \/ z = y \/ present z b. Proof. intros. funelim (balance2 a y b); subst; simpl in *; tauto. Qed. Equations present_insResult (c : color) (n : nat) (t : rbtree c n) (r : insResult c n): Prop := @present_insResult Red n t r := rpresent z r <-> z = x \/ present z t; @present_insResult Black n t r := present z (pr2 r) <-> z = x \/ present z t. Theorem present_ins : forall c n (t : rbtree c n), present_insResult t (ins t). Proof. intros. funelim (ins t); simp present_insResult in *; simpl in *; try match goal with [ |- context [balance1 ?A ?B ?C] ] => generalize (present_balance1 A B C) end; try match goal with [ |- context [balance2 ?A ?B ?C] ] => generalize (present_balance2 A B C) end; try tauto. Qed. Ltac present_insert t t0 := intros; funelim (insert t); generalize (present_ins t0); try rewrite present_insResult_equation_1; try rewrite present_insResult_equation_2; funelim (ins t0); intro; assumption. Theorem present_insert_Red : forall n (t : rbtree Red n), present z (insert t) <-> (z = x \/ present z t). 
- simpl. iMod (fupd_mask_subseteq E2) as "Hclo"; auto. iModIntro. iModIntro. iMod "Hclo" as "_". iModIntro. iApply ("IH" with "HP"). Qed. Lemma fupd_iter_intro E1 k P : ‚ñ∑^k P -‚àó |={E1,E1}_(k)=> P. Proof. iIntros "HP". iMod (fupd_mask_subseteq ‚à ) as "Hclo"; first by set_solver. iModIntro. iApply step_fupd_iter_intro; first by set_solver. iModIntro. iMod "Hclo" as "_". by iFrame. Qed. Lemma step_fupd_mask_weaken_iter k E1 E2 P : E1 ‚äÜ E2 ‚Üí ‚ñ∑^k P -‚àó |={E2,E1}_k=> P. Proof. iIntros (?) "HP". iApply step_fupd_iter_intro; first by set_solver. iMod (fupd_mask_subseteq ‚à ) as "Hclo"; first by set_solver. iModIntro. iModIntro. iMod "Hclo" as "_". iApply fupd_mask_intro_discard; auto. Qed. Global Instance from_modal_cfupd E1 P : FromModal True modality_id (cfupd E1 P) (cfupd E1 P) (P). Proof. rewrite /FromModal /=. iIntros (_) "HP". iIntros "_". iModIntro. by iFrame. Qed. Lemma ineq_to_diff n1 n2 : (n1 ‚â§ n2)%nat ‚Üí ‚àÉ n1' d, (n2 - n1 = d) ‚àß n1 = n1' ‚àß n2 = n1' + d. Proof. intros. exists n1, (n2-n1); lia. Qed. Theorem elim_modal_step_fupdN_subtract E1 E2 k1 k2 P Q : (k1 ‚â§ k2)%nat ‚Üí (|={E1}[E2]‚ñ∑=>^k1 P) -‚àó (P -‚àó |={E1}[E2]‚ñ∑=>^(k2-k1) Q) -‚àó |={E1}[E2]‚ñ∑=>^k2 Q. Proof. iIntros (Hle) "HP HQ". destruct (ineq_to_diff _ _ Hle) as (k&kd&->&?&?); subst. clear Hle. iInduction k as [|k] "IH"; simpl. - iApply "HQ"; auto. - iMod "HP"; iModIntro. iNext. iMod "HP"; iModIntro. iApply ("IH" with "HP HQ"). Qed. Theorem elim_modal_step_fupdN_mono E1 E2 k P Q : (|={E1}[E2]‚ñ∑=>^k P) -‚àó (P -‚àó Q) -‚àó |={E1}[E2]‚ñ∑=>^k Q. Proof. iIntros "HP HQ". iApply (elim_modal_step_fupdN_subtract with "HP"); auto. replace (k-k) with 0 by lia; simpl. auto. Qed. Theorem elim_modal_step_fupd_masks k1 k2 E1 E2 P Q : (k1 ‚â§ k2)%nat ‚Üí E1 ‚äÜ E2 ‚Üí (|={E1,E2}_k1=> P) -‚àó (P -‚àó (|={E1,E2}_(k2-k1)=> Q)) -‚àó (|={E1,E2}_k2=> Q). Proof. iIntros (Hle ?) "Hfupd HQ". destruct (ineq_to_diff _ _ Hle) as (k&kd&->&?&?); subst; clear Hle. iApply step_fupdN_inner_add. iMod "Hfupd". iModIntro. iApply (elim_modal_step_fupdN_mono with "Hfupd"). iIntros "HP". iMod "HP". iSpecialize ("HQ" with "HP"). iApply fupd_mask_intro_discard; auto. Qed. Lemma step_fupdN_fupd E1 E2 k P : E1 ‚äÜ E2 ‚Üí (|={E1}‚ñ∑=>^k |={E1,E2}=> P) ‚ä£‚ä¢ (|={E1}=> |={E1}‚ñ∑=>^k |={E1,E2}=> P). Proof. intros Hsub. destruct k; simpl. - iSplit; iIntros "H". + iMod "H". iApply fupd_mask_intro_subseteq; auto. + iMod "H"; auto. - iSplit; iIntros "H". + by iFrame. + by iMod "H". Qed. Lemma step_fupdN_fupd_empty E2 k P : (|={‚à }‚ñ∑=>^k |={‚à ,E2}=> P) ‚ä£‚ä¢ (|={‚à }=> |={‚à }‚ñ∑=>^k |={‚à ,E2}=> P). Proof. apply step_fupdN_fupd; set_solver. Qed. Theorem elim_modal_step_fupd_masks_trans k1 k2 E1 E2 E3 P Q : (k1 ‚â§ k2)%nat ‚Üí (|={E1,E2}_k1=> P) -‚àó (P -‚àó (|={E2,E3}_(k2-k1)=> Q)) -‚àó (|={E1,E3}_k2=> Q). 
WellTyped_impures. unfold MM.mmap_map. rewrite MF.fold_map_fusion. eapply fold_ext. intros. destruct a; simpl; auto. destruct (nth_error tp k); auto; try solve [ destruct v; simpl; auto ]. cutrewrite (allb (fun args : list (expr types) => all2 (is_well_typed tf U G) args t) v = allb (fun args : list (expr types) => all2 (is_well_typed tf U' G') args t) (map (map F) v)); [ destruct v; auto | ]. induction v; simpl; intros; think; auto. rewrite all2_map_1. erewrite all2_eq. 2: eapply H. auto. auto with typeclass_instances. repeat red; intros; repeat match goal with | |- context [ match ?X with _ => _ end ] => destruct X | |- _ => rewrite andb_true_l | |- _ => rewrite andb_true_r | |- context [ allb ?A ?B ] => destruct (allb A B) end; auto. repeat red; intros; repeat match goal with | |- _ => subst | |- context [ match ?X with _ => _ end ] => destruct X | |- _ => rewrite andb_true_l | |- _ => rewrite andb_true_r | |- context [ allb ?A ?B ] => destruct (allb A B) end; auto. rewrite allb_map. apply allb_ext. intros. apply H. Qed. Lemma applySHeap_typed_impl : forall tf tp U G U' G' s F, (forall e t, is_well_typed tf U G e t = true -> is_well_typed tf U' G' (F e) t = true) -> WellTyped_sheap tf tp U G s = true -> WellTyped_sheap tf tp U' G' (applySHeap F s) = true. Proof. clear. intros. rewrite WellTyped_sheap_eq in *. destruct s; unfold applySHeap; simpl in *. think. apply andb_true_iff; split. rewrite WellTyped_impures_eq in H0. apply WellTyped_impures_eq. intros. unfold MM.mmap_map in *. rewrite MM.FACTS.map_o in H2. unfold MM.FACTS.option_map in H2. consider (FM.find (elt:=list (list (expr types))) k impures0); intros. think. specialize (H0 _ _ H2). Opaque allb. destruct l; simpl in *; auto. Transparent allb. change (map F l :: map (map F) l0) with (map (map F) (l :: l0)). generalize dependent (l :: l0); intros. think. revert H3. clear - H. induction l1; simpl in *; intros; think; auto. rewrite all2_map_1. erewrite all2_impl; eauto. congruence. rewrite allb_map. eapply allb_impl; eauto. Qed. Definition sheapSubstU (a b c : nat) (s : SHeap) : SHeap := {| impures := MM.mmap_map (map (exprSubstU a b c)) (impures s) ; pures := map (exprSubstU a b c) (pures s) ; other := other s |}. *) Theorem hash_Func : forall p (args : exprs types), hash (Func p args) = (nil, {| impures := MM.mmap_add p args (MM.empty _) ; pures := nil ; other := nil |}). 
Set Implicit Arguments.Require Import FCF.FCF.Section RndListElem. Variable A : Set. Hypothesis eqd : EqDec A. Local Open Scope list_scope. Definition rndListElem(ls : list A) : Comp (option A) := match (length ls) with | O => ret None | S _ => i <-$ [0 .. (length ls)); ret (nth_option ls i) end. Theorem rndListElem_wf : forall (ls : list A), well_formed_comp (rndListElem ls). 
H' H'0 H'1 H'2. replace (MSB radix p) with (MSB radix (Float 1%nat (MSB radix p))). apply MSB_monotone; auto. unfold is_Fzero in |- *; simpl in |- *; red in |- *; intros; discriminate. red in |- *; intros H'3; absurd (q = 0%R :>R). apply MSBBoundNotZero with (P := P) (f1 := p); auto. unfold FtoRradix in |- *; apply is_Fzero_rep1; auto. replace (Fabs (Float 1%nat (MSB radix p))) with (Float 1%nat (MSB radix p)); [ idtac | unfold Fabs in |- *; simpl in |- *; auto ]. rewrite Fabs_correct; auto with arith; fold FtoRradix in |- *. apply RoundAbsMonotonel with (P := P) (p := FtoRradix p); auto. apply (FboundedOne _ radixMoreThanOne b precision); auto with zarith. unfold FtoRradix in |- *; rewrite <- (Fabs_correct radix); auto with arith; apply MSB_le_abs; auto. Contradict H'1; unfold FtoRradix in |- *; apply is_Fzero_rep1; auto. unfold MSB, Fdigit in |- *; simpl in |- *. case (Zpred (digit radix (Fnum p) + Fexp p)); simpl in |- *; auto with zarith. intros p0; case p0; simpl in |- *; auto. intros p1; elim p1; simpl in |- *; auto. intros p2 H; injection H; intros H1; rewrite <- H1; auto. intros p0; case p0; simpl in |- *; auto. intros p1; case p1; simpl in |- *; auto. intros p2; elim p2; simpl in |- *; auto. intros p3 H; injection H; intros H1; rewrite H1; auto. Qed. Theorem RoundLSBMax : forall (P : R -> float -> Prop) (p q : float), RoundedModeP b radix P -> P p q -> ~ is_Fzero q -> (LSB radix p <= LSB radix q)%Z. intros P p q H' H'0 H'2. elim (LSB_rep_min radix) with (p := p); auto; intros z E. case (RoundedModeRep b radix precision) with (P := P) (p := Float z (LSB radix p)) (q := q); auto. cut (CompatibleP b radix P); [ intros Cp | apply RoundedModeP_inv2 with (1 := H'); auto ]. apply (Cp p (Float z (LSB radix p)) q); auto. apply RoundedModeBounded with (P := P) (r := FtoRradix p); auto. intros x H'3. replace (LSB radix p) with (Fexp (Float x (LSB radix p))); [ idtac | simpl in |- *; auto ]. replace (LSB radix q) with (LSB radix (Float x (LSB radix p))). apply Fexp_le_LSB. apply LSB_comp; auto. apply NisFzeroComp with (radix := radix) (x := q); auto. Qed. Theorem InBinade : forall (P : R -> float -> Prop) (p q r : float) (e : Z), RoundedModeP b radix P -> Fbounded b p -> Fbounded b q -> P (p + q)%R r -> (- dExp b <= e)%Z -> (Float (Zpower_nat radix (pred precision)) e <= p)%R -> (p <= Float (pPred (vNum b)) e)%R -> (0%nat < q)%R -> (q < powerRZ radix e)%R -> r = p :>R \/ r = (p + powerRZ radix e)%R :>R. 
M.gso. reflexivity. assumption. assumption. assumption. assumption. Qed. Theorem inv_set: forall t e sub sub' v, map_get_r t (M.remove v sub) (M.remove v sub') -> map_get_r t (M.set v e sub) (M.set v e sub'). Proof. unfold map_get_r; intros. specialize (H v0). destruct (var_dec v0 v). - subst. rewrite 2 M.gss. reflexivity. - rewrite 2 M.gso. rewrite 2 M.gro in H. assumption. assumption. assumption. assumption. assumption. Qed.Theorem set_remove: forall t x e sub, map_get_r t (M.set x e (M.remove x sub)) (M.set x e sub). Proof. unfold map_get_r; intros. destruct (var_dec v x). + subst. rewrite M.gss. rewrite M.gss. reflexivity. + rewrite M.gso. rewrite M.gro. rewrite M.gso. reflexivity. assumption. assumption. assumption. Qed.Theorem proper_remove: forall t v, Proper (map_get_r t ==> map_get_r t) (M.remove v). Proof. intros t v r. unfold map_get_r; intros. destruct (var_dec v0 v). - subst. rewrite 2 M.grs. reflexivity. - rewrite 2 M.gro. apply H. assumption. assumption. Qed.Theorem proper_set: forall t v e, Proper (map_get_r t ==> map_get_r t) (M.set v e). Proof. intros t v e r. unfold map_get_r; intros. destruct (var_dec v0 v). - subst. rewrite 2 M.gss. reflexivity. - rewrite 2 M.gso. apply H. assumption. assumption. Qed.End EQMAP. Section GETD. Definition getd {A:Type} (d:A) := fun v sub => match M.get v sub with | None => d | Some e => e end. Theorem e_getd: forall A (d:A) v sub, exists e, getd d v sub = e. Proof. unfold getd; intros; destruct (M.get v sub); [ exists a; reflexivity | exists d; reflexivity]. Qed. Theorem getd_det: forall A v (a1 a2 d:A) sub, getd d v sub = a1 -> getd d v sub = a2 -> a1 = a2. Proof. unfold getd; intros; destruct (M.get v sub); subst; trivial. Qed. Theorem gdss: forall A (d:A) x c v, getd d x (M.set x v c) = v. Proof. intros. unfold getd. rewrite M.gss. reflexivity. Qed. Theorem gdso: forall A (d:A) x x' c v, x <> x' -> getd d x (M.set x' v c) = getd d x c. Proof. unfold getd. intros. rewrite M.gso. reflexivity. assumption. Qed. Theorem gdempty: forall A (d:A) x, getd d x (M.empty A) = d. Proof. unfold getd. symmetry. rewrite M.gempty. reflexivity. Qed. End GETD. Section EQDMAP. Definition map_getd_r: forall t d, relation (M.t t) := fun t d => fun sub sub' => forall v, getd d v sub = getd d v sub'. Theorem smgd_refl: forall t d, Reflexive (map_getd_r t d). 
intros a0 a1. case (O1.lt_eq_lt_dec a0 a1). simple destruct 1. right. auto. simple destruct 1. left. right. trivial. left. left. trivial. left; trivial. left; trivial. right. auto. intros a0 a1. case (O2.lt_eq_lt_dec a0 a1). simple destruct 1. right. auto. simple destruct 1. left. right. trivial. left. left. trivial. Defined.End Sum_Order. Require Import Arith.Module Nat_Order : DEC_ORDER with Definition A := nat with Definition le := le with Definition lt := lt. Definition A := nat. Definition le := le. Definition lt := lt. Theorem ordered : order A le. Proof. split. unfold A, le, reflexive in |- *; auto with arith. unfold A, le, transitive in |- *; eauto with arith. unfold A, le, antisymmetric in |- *; eauto with arith. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. Proof. unfold A in |- *; exact lt_le_weak. Qed. Theorem lt_diff : forall a b : A, lt a b -> a <> b. Proof. unfold A, lt, le in |- *; intros a b H e. rewrite e in H. case (lt_irrefl b H). Qed. Theorem le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Proof. unfold A, le, lt in |- *. exact le_lt_or_eq. Qed. Definition lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a} := lt_eq_lt_dec. End Nat_Order. Definition bool_le (b b' : bool) := if b then if b' then True else False else True. Definition bool_lt (b b' : bool) := if b then False else if b' then True else False. Module Bool_Order : DEC_ORDER with Definition A := bool with Definition le := bool_le with Definition lt := bool_lt. Definition A := bool. Definition le := bool_le. Definition lt := bool_lt. Theorem ordered : order A le. Proof. split. unfold A, le, reflexive in |- *. intro x; case x; simpl in |- *; auto. unfold A, le, transitive in |- *; simple destruct x; simple destruct y; auto; simple destruct z; auto. unfold A, le, antisymmetric in |- *; simple destruct x; simple destruct y; simpl in |- *; auto; contradiction. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. Proof. unfold A, lt, le in |- *; simple destruct a; simple destruct b; simpl in |- *; tauto. Qed. Theorem lt_diff : forall a b : A, lt a b -> a <> b. 
intros. simpl in H. destruct c. + simpl in H. inversion H. destruct a0. * inversion H3. * inversion H3. + simpl in H. inversion H; subst; clear H. eapply IHa. apply H3. apply H0. Qed.Theorem equal_srev_sappend: forall a b c, a=b <-> sappend (srev a) c=sappend (srev b) c. Proof. intro a. induction a. - simpl. intros. destruct b. + simpl. split. * reflexivity. * reflexivity. + simpl. split. * intros. inversion H. * intros. remember (srev b). destruct s. -- simpl in H. symmetry in H. apply String_same_false in H. inversion H. -- symmetry in H. rewrite sappend_empty_equal in H. inversion H. - split. + intros. subst. reflexivity. + intros. destruct b. * simpl in H. rewrite sappend_empty_equal in H. remember (srev a0). destruct s. -- inversion H. -- inversion H. * simpl in H. rewrite <- sappend_assoc in H. rewrite <- sappend_assoc in H. remember (Ascii.eqb a a1). destruct b0. -- symmetry in Heqb0. apply Ascii.eqb_eq in Heqb0. subst. apply <- IHa in H. subst. reflexivity. -- symmetry in Heqb0. apply Ascii.eqb_neq in Heqb0. rewrite sappend_assoc in H. rewrite sappend_assoc in H. apply sappend_equal_tail in H. apply sappend_different_last in H. ++ inversion H. ++ apply Heqb0. Qed.Theorem equal_srev: forall a b, a=b <-> srev a=srev b. Proof. intros. split. - intros. subst. reflexivity. - intros. assert (sappend (srev a) ""=sappend (srev b) ""). + rewrite H. reflexivity. + apply <- equal_srev_sappend in H0. apply H0. Qed.Theorem sdisjPrefix_sappend_not_equal: forall s1 s2 p1 p2, sdisjPrefix s1 s2=true -> (sappend s1 p1=sappend s2 p2)%string -> False. Proof. intro s1. induction s1. - intros. inversion H. - destruct s2. + intros. inversion H. + intros. simpl in H. remember (Ascii.eqb a a0). destruct b. * symmetry in Heqb. rewrite Ascii.eqb_eq in Heqb. subst. simpl. simpl in H0. inversion H0; subst; clear H0. eapply IHs1. ++ apply H. ++ apply H2. * inversion H0; subst; clear H0. symmetry in Heqb. rewrite Ascii.eqb_neq in Heqb. apply Heqb. reflexivity. Qed.Theorem sdisjPrefix_sappend_false: forall p1 p2 s1 s2, sdisjPrefix (srev s1) (srev s2)=true -> sappend p1 s1=sappend p2 s2 -> False. Proof. intros. eapply sdisjPrefix_sappend_not_equal in H. - inversion H. - instantiate (1 := (srev p2)). instantiate (1 := (srev p1)). rewrite <- srev_sappend. rewrite <- srev_sappend. rewrite H0. reflexivity. Qed.Theorem sappend_append: forall s1 s2, sappend s1 s2=String.append s1 s2. Proof. intros. induction s1. - reflexivity. - simpl. rewrite IHs1. reflexivity. Qed.Hint Rewrite sappend_append : kami_rewrite_db. Theorem sdisjPrefix_false: forall p1 p2 s1 s2, sdisjPrefix (srev s1) (srev s2)=true -> (False <-> (p1++s1=p2++s2)%string). 
"%He". subst. iApply big_sepM2_empty. done. - iDestruct (big_sepM_insert with "Hm") as "[Hi Hm]"; eauto. iDestruct (big_sepM2_lookup_l_some _ _ _ i with "Hm2") as (x2) "%Hm2i"; eauto. { rewrite lookup_insert; eauto. } replace (m2) with (<[i:=x2]> (delete i m2)). 2: { rewrite insert_delete //. } iDestruct (big_sepM2_insert with "Hm2") as "[Hii Hm2]"; eauto. { rewrite lookup_delete; eauto. } iDestruct ("IH" with "Hm2 Hm") as "Hm2". iApply big_sepM2_insert; eauto. { rewrite lookup_delete; eauto. } iFrame. Qed. Lemma big_sepM2_filter Œ¶ (P : K -> Prop) (m1 : gmap K A) (m2 : gmap K B) `{! ‚àÄ k, Decision (P k)} : ‚ä¢ ( [‚àó map] k‚Ü¶y1;y2 ‚àà m1;m2, Œ¶ k y1 y2 ) ‚àó-‚àó ( ( [‚àó map] k‚Ü¶y1;y2 ‚àà filter (Œª x, P x.1) m1;filter (Œª x, P x.1) m2, Œ¶ k y1 y2 ) ‚àó ( [‚àó map] k‚Ü¶y1;y2 ‚àà filter (Œª x, ~P x.1) m1;filter (Œª x, ~P x.1) m2, Œ¶ k y1 y2 ) ). Proof. rewrite big_op.big_sepM2_unseal /big_op.big_sepM2_def. iSplit. - iIntros "[% Hm]". erewrite <- (map_filter_union_complement _ (map_zip m1 m2)). iDestruct (big_sepM_union with "Hm") as "[Hmp Hmnp]". { eapply map_disjoint_filter_complement. } iSplitL "Hmp". + iSplit. { iPureIntro; eapply filter_same_keys_0; eauto. } rewrite map_zip_filter. iFrame. + iSplit. { iPureIntro. eapply (filter_same_keys_0 _ _ (Œª k, ¬¨ P k)). eauto. } rewrite (map_zip_filter _ _ (Œª k, ¬¨ P k)). iFrame. - iIntros "[[% Hm1] [% Hm2]]". iSplit. { iPureIntro. eapply filter_same_keys_1; eauto. } rewrite map_zip_filter. rewrite (map_zip_filter _ _ (Œª k, ¬¨ P k)). iDestruct (big_sepM_union with "[$Hm1 $Hm2]") as "Hm". { eapply map_disjoint_filter_complement. } rewrite map_filter_union_complement. iFrame. Unshelve. all: typeclasses eauto. Qed. Lemma big_sepM2_insert_left_inv Œ¶ (m1 : gmap K A) (m2 : gmap K B) k a : m1 !! k = None ‚Üí ([‚àó map] k‚Ü¶y1;y2 ‚àà <[k := a]>m1; m2, Œ¶ k y1 y2) -‚àó ‚àÉ b, ‚åú m2 !! k = Some b ‚åù ‚àó Œ¶ k a b ‚àó [‚àó map] k‚Ü¶y1;y2 ‚àà m1; delete k m2, Œ¶ k y1 y2. Proof. iIntros (Hone) "H". iDestruct (big_sepM2_dom with "H") as %Hdom. assert (‚àÉ b, m2 !! k = Some b) as (b&Hlookup). { apply elem_of_dom. rewrite -Hdom. set_solver. } rewrite -(insert_id m2 k b) //. rewrite big_sepM2_insert_delete. iDestruct "H" as "(HŒ¶&H)". iExists b. iFrame. iSplit. { rewrite lookup_insert //. } rewrite delete_notin // delete_insert_delete //. Qed. End map2.Section gmap_uncurry. Context `{EqDecision A} `{Countable A}. Context `{EqDecision B} `{Countable B}. Variable (T : Type). Theorem gmap_curry_insert (m : gmap (A * B) T) (k : A * B) (v : T) : m !! k = None -> gmap_curry (<[k:=v]> m) = <[fst k := <[snd k := v]> (default ‚à ((gmap_curry m) !! fst k))]> (gmap_curry m). 
memoryIn (width := width) = match fcong (fun width => list (word width)) width (sym_eq allWords_eq) in _ = L return _ -> hlist _ L with | refl_equal => memoryIn_def (width := width) end. End ALL_WORDS.Module AllWords : ALL_WORDS. Definition allWords := allWords_def. Theorem allWords_eq : allWords = allWords_def. reflexivity. Defined. Definition memoryIn := memoryIn_def. Theorem memoryIn_eq : forall width, memoryIn (width := width) = match fcong (fun width => list (word width)) width (sym_eq allWords_eq) in _ = L return _ -> hlist _ L with | refl_equal => memoryIn_def (width := width) end. reflexivity. Qed. End AllWords.Import AllWords. Export AllWords.Lemma natToWord_injective : forall width n n', (n < pow2 width)%nat -> (n' < pow2 width)%nat -> natToWord width n = natToWord width n' -> n = n'. intros. destruct (wordToNat_natToWord width n); destruct (wordToNat_natToWord width n'); intuition. rewrite H1 in H4. rewrite H4 in H2. assert (x = 0). destruct x; simpl in *. omega. generalize dependent (x * pow2 width). intros. omega. assert (x0 = 0). destruct x0; simpl in *. omega. generalize dependent (x0 * pow2 width). intros. omega. subst. omega. Qed.Local Hint Constructors NoDup.Lemma NoDup_allWordsUpto' : forall width init' init, init <= init' < pow2 width -> ~In (natToWord width init') (allWordsUpto width init). induction init; simpl; intuition; match goal with | [ H : _ |- _ ] => apply natToWord_injective in H; omega end. Qed.Local Hint Resolve NoDup_allWordsUpto'.Theorem NoDup_allWordsUpto : forall width init, (init <= pow2 width)%nat -> NoDup (allWordsUpto width init). induction init; simpl; intuition. Qed.Theorem NoDup_allWords : forall width, NoDup (allWords width). rewrite allWords_eq; intros; apply NoDup_allWordsUpto; omega. Qed.Module BedrockHeap. Definition addr := W. Definition mem := mem. Definition mem_get := ReadByte. Definition mem_set := WriteByte. Definition mem_acc (m : mem) (a : addr) := exists v, m a = Some v. Theorem mem_get_acc : forall m p, mem_acc m p <-> exists v, mem_get m p = Some v. Proof. intuition eauto. Qed. Theorem mem_set_acc : forall m p, mem_acc m p <-> forall v, exists m', mem_set m p v = Some m'. Proof. intuition. destruct H. unfold mem_set, WriteByte. rewrite H. eauto. specialize (H (wzero _)). destruct H. unfold mem_set, mem_acc, WriteByte in *. destruct (m p); eauto. congruence. Qed. Theorem mem_acc_dec : forall m p, mem_acc m p \/ ~mem_acc m p. Proof. unfold mem_acc. intros; destruct (m p); eauto. right. intro. destruct H; congruence. Qed. Theorem mem_get_set_eq : forall m p v' m', mem_set m p v' = Some m' -> mem_get m' p = Some v'. 
Require Import Eqdep.Section WellOrdering. Variable A : Type. Variable B : A -> Type. Inductive WO : Type := sup : forall (a:A) (f:B a -> WO), WO. Inductive le_WO : WO -> WO -> Prop := le_sup : forall (a:A) (f:B a -> WO) (v:B a), le_WO (f v) (sup a f). Theorem wf_WO : well_founded le_WO. 
_ end = Some _ |- _ = _ => destruct x; [| try discriminate] | H : (let (_, _) := ?p in _) = Some _ |- _ = _ => destruct p | H : Some _ = Some _ |- _ = _ => inversion_clear H | H : extract_ser_value _ _ = @Some (interp_type ser_unit) ?i |- _ = _ => apply deserialize_unit_right_inverse in H as ->; destruct i | H : @deserialize_product _ _ _ _ _ = Some _ |- _ = _ => apply deserialize_product_right_inverse in H as ->; try clear H | |- forall _ _, _ -> _ => intros * deser_some; cbn in * end; auto with deser). Opaque deserialize serialize. Qed. Section LqtPoolCorrect. Arguments lqt_contract {_ _ _ _} _. Arguments lqt_total_supply_correct {_ _ _ _} _. Definition lqtTotal_total_supply_invariant (i_lqt_contract : LqtTokenInterface) : Prop := forall bstate caddr_main caddr_lqt (trace : ChainTrace empty_state bstate), env_contracts bstate caddr_main = Some (contract : WeakContract) -> env_contracts bstate caddr_lqt = Some (i_lqt_contract.(lqt_contract) : WeakContract) -> exists state_main state_lqt depinfo_main depinfo_lqt, contract_state bstate caddr_main = Some state_main /\ contract_state bstate caddr_lqt = Some state_lqt /\ deployment_info Setup trace caddr_main = Some depinfo_main /\ deployment_info Dexter2FA12.Setup trace caddr_lqt = Some depinfo_lqt /\ let initial_tokens_main := lqtTotal_ (deployment_setup depinfo_main) in let initial_tokens_lqt := initial_pool (deployment_setup depinfo_lqt) in (state_main.(lqtAddress) = caddr_lqt -> state_lqt.(admin) = caddr_main -> initial_tokens_main = initial_tokens_lqt -> filter (actTo state_main.(lqtAddress)) (outgoing_acts bstate caddr_main) = [] -> state_main.(lqtTotal) = state_lqt.(total_supply)). Lemma lqt_pool_correct_interface : forall (i_lqt_contract : LqtTokenInterface), (forall x (y : Address), deserialize x = Some y -> x = serialize y) -> lqtTotal_total_supply_invariant i_lqt_contract. Proof. intros ? ? ? ? ? ? deployed_main deployed_lqt. apply (lqt_total_correct _ _ trace) in deployed_main as main_correct. destruct main_correct as (state_main & depinfo_main & deployed_state_main & deploy_info_main & main_correct). apply (lqt_total_supply_correct _ _ _ trace) in deployed_lqt as lqt_correct. destruct lqt_correct as (state_lqt & depinfo_lqt & inc_calls_lqt & deployed_state_lqt & deploy_info_lqt & inc_acts_lqt & lqt_correct). specialize incomming_eq_outgoing as incoming_eq. edestruct incoming_eq as (? & inc_acts_lqt' & calls_eq); [| apply deployed_main | apply deployed_lqt |]. - intros. eapply deserialize_lqt_token_msg_right_inverse; auto. - setoid_rewrite inc_acts_lqt in inc_acts_lqt'. inversion inc_acts_lqt'. subst. clear inc_acts_lqt'. do 4 eexists. repeat split; eauto. cbn. intros addr_main_eq addr_lqt_eq init_pool_eq no_waiting_mint_acts. apply N2Z.inj. rewrite main_correct, lqt_correct, init_pool_eq, no_waiting_mint_acts, addr_main_eq, addr_lqt_eq. rewrite Z.add_0_r, Z.add_cancel_l. rewrite calls_eq, sumZ_map. apply sumZ_eq. intros. now rewrite <- mintedOrBurnedTokens_call_eq_tx. Qed. End LqtPoolCorrect. Theorem lqt_pool_correct_lqt_fa12 : (forall x (y : Address), deserialize x = Some y -> x = serialize y) -> lqtTotal_total_supply_invariant Dexter2FA12Correct.LqtFA12Token. 
:= (b, ofs')) in j. + destruct lk as (p & E0). rewrite E0 in j. inv j. * unfold block in *. rewr (OrdinalPool.getThreadR cnti @ (b, ofs')). simpl. unfold perm_of_sh. pose proof (readable_glb rsh3). repeat if_tac; try constructor; tauto. * unfold block in *. rewr (OrdinalPool.getThreadR cnti @ (b, ofs')). simpl. unfold perm_of_sh. pose proof (readable_glb rsh3). repeat if_tac; try constructor; tauto. Qed.Lemma valid_access_restrPermMap ge m i tp Phi b ofs ophi (compat : mem_compatible_with tp m Phi) (lock_coh : lock_coherence'(ge := ge) tp Phi m compat) (cnti : containsThread tp i) (Efind : AMap.find (elt:=option rmap) (b, Ptrofs.unsigned ofs) (lset tp) = Some ophi) (align : (4 | snd (b, Ptrofs.unsigned ofs))) (Hlt' : permMapLt (setPermBlock (Some Writable) b (Ptrofs.intval ofs) (juice2Perm_locks (getThreadR cnti) m) LKSIZE_nat) (getMaxPerm m)) : valid_access (restrPermMap Hlt') Mint32 b (Ptrofs.intval ofs) Writable. Proof. split. 2:exact align. intros ofs' r. unfold perm in *. pose proof restrPermMap_Cur as RR. unfold permission_at in *. rewrite RR. simpl. pose proof compat.(loc_writable) as LW. specialize (LW b (Ptrofs.unsigned ofs)). cleanup. rewrite Efind in LW. autospec LW. specialize (LW ofs'). rewrite setPermBlock_lookup. repeat (if_tac; [constructor |]). exfalso. simpl in r. assert (A : forall z, (b, z) <> (b, ofs') -> z <> ofs') by congruence. repeat match goal with H: (_,_)<>(_,_) |- _ => apply A in H end. contradiction H. unfold LKSIZE_nat; rewrite Z2Nat.id by lkomega. split; auto; lkomega. Qed.Lemma permMapLt_local_locks ge m i (tp : jstate ge) Phi b ofs ophi (compat : mem_compatible_with tp m Phi) (cnti : containsThread tp i) (Efind : AMap.find (elt:=option rmap) (b, Ptrofs.unsigned ofs) (lset tp) = Some ophi) : permMapLt (setPermBlock (Some Writable) b (Ptrofs.intval ofs) (juice2Perm_locks (getThreadR cnti) m) LKSIZE_nat) (getMaxPerm m). Proof. simpl. intros b' ofs'. assert (RR: (getMaxPerm m) !! b' ofs' = (mem_access m) !! b' ofs' Max) by (unfold getMaxPerm in *; rewrite PMap.gmap; reflexivity). pose proof compat.(loc_writable) as LW. specialize (LW b (Ptrofs.unsigned ofs)). cleanup. rewrite Efind in LW. autospec LW. specialize (LW ofs'). rewrite RR. rewrite setPermBlock_lookup; if_tac. { unfold LKSIZE_nat in H; rewrite Z2Nat.id in H by (pose proof LKSIZE_pos; omega). destruct H; subst; auto. } rewrite <-RR. apply juice2Perm_locks_cohere, mem_compat_thread_max_cohere. eexists; eauto. Qed.Section Progress. Variables (CS : compspecs) (ext_link : string -> ident) (ext_link_inj : forall s1 s2, ext_link s1 = ext_link s2 -> s1 = s2). Definition Jspec' := (@OK_spec (Concurrent_Espec unit CS ext_link)). Open Scope string_scope. Theorem progress ge Gamma n state : ~ blocked_at_external state CREATE -> state_invariant Jspec' Gamma (S n) state -> exists state', state_step(ge := ge) state state'. 
m ‚àà p). { apply (nat_trans p Hp m m‚Å∫)... } assert (Hmseg: m ‚àà A (Seg p ‚ÑïÃÉ)). { apply SepI... apply binRelI... } assert (Hm'seg: m‚Å∫ ‚àà A (Seg p ‚ÑïÃÉ)). { apply SepI... apply binRelI... } ext Hx. + apply (e_elim (Seg p ‚ÑïÃÉ)) in Hx as [k [Hk [Hkm [Heqx Hx]]]]... apply SepE in Hkm as [Hkm _]. apply binRelE2 in Hkm as [Hkw [_ Hkm]]. apply le_iff_lt_suc in Hkm as []... * apply BUnionI1. rewrite <- IH... eapply e_intro... apply seg_lt; apply binRelI... * apply BUnionI2. subst. rewrite <- IH at 2... + apply le_iff_lt_suc in Hx as []; [| |eapply œâ_trans|]... * rewrite <- IH in H... apply (e_elim (Seg p ‚ÑïÃÉ)) in H as [k [Hk [Hkm [Heqx Hx]]]]... apply SepE in Hkm as [Hkm _]. apply binRelE2 in Hkm as [Hkw [_ Hkm]]. eapply (e_intro (Seg p ‚ÑïÃÉ))... apply seg_lt; apply binRelI... apply BUnionI1... * apply (e_intro (Seg p ‚ÑïÃÉ) x m)... apply seg_lt; apply binRelI... rewrite IH... Qed.Example Œ±_nat : ‚àÄn ‚àà œâ, Œ± (Seg n ‚ÑïÃÉ) = n. Proof with neauto; try congruence. intros n Hn. œâ_induction n. - unfold Œ±. replace (E (Seg ‚à ‚ÑïÃÉ)) with ‚à . apply ran_of_empty. symmetry. apply e_empty. ext Hx; [|exfalso0]. apply SepE2 in Hx. apply binRelE3 in Hx... - assert (Hm': m‚Å∫ ‚àà œâ) by (apply œâ_inductive; auto). destruct (e_spec (Seg m‚Å∫ ‚ÑïÃÉ)) as [Hf [Hd _]]... ext y Hy. + apply ranE in Hy as [x Hp]. apply domI in Hp as Hx. rewrite Hd in Hx. apply SepE2 in Hx. apply binRelE2 in Hx as [Hx [_ Hx']]. apply func_ap in Hp... rewrite e_nat_nat in Hp... + assert (Hyw: y ‚àà œâ) by (eapply œâ_trans; eauto). apply (ranI _ y). apply func_point... * rewrite Hd. apply SepI... apply binRelI... * rewrite seg_e_ap... apply e_œâ_nat... apply binRelI... Qed.Example Œ±_œâ : Œ± ‚ÑïÃÉ = œâ. Proof with auto. destruct (e_spec ‚ÑïÃÉ) as [Hf [Hd _]]. ext m Hm. - apply ranE in Hm as [n Hp]. apply domI in Hp as Hn. rewrite Hd in Hn. apply func_ap in Hp... rewrite e_œâ_nat in Hp... subst... - apply (ranI _ m). apply func_point... rewrite Hd... apply e_œâ_nat... Qed.End EpsilonImageOfNats.Import WosetMin.FullVer.Definition Min := Œª S, Min (A S) (R S).Lemma min_correct : ‚àÄ S B, ‚¶ø B ‚Üí B ‚äÜ A S ‚Üí minimum (Min S)[B] B (R S). Proof. intros; apply min_correct; auto. Qed. Theorem wo_iso_at_least_trich : ‚àÄ S T, S ‚â T ‚à® (‚àÉt ‚àà A T, S ‚â Seg t T) ‚à® (‚àÉt ‚àà A S, Seg t S ‚â T). 
end. Theorem frequency_list_in : forall a n m, In (a, n) (frequency_list m) -> In a m. Proof using. intros a n m; generalize n; elim m; clear m n; simpl in |- *; auto. intros a0 l H n H0; case add_frequency_list_in_inv with (1 := H0); auto. intros H1; right; apply (H n); auto. Qed. Theorem frequency_list_perm : forall l : list A, permutation l (flat_map (fun p => id_list (fst p) (snd p)) (frequency_list l)). Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H. apply permutation_trans with (2 := add_frequency_list_perm a (frequency_list l0)); auto. Qed. Theorem frequency_list_unique : forall l : list A, unique_key (frequency_list l). Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H; apply add_frequency_list_unique_key; auto. Qed. Hint Resolve frequency_list_unique : core. Theorem in_frequency_map : forall l a, In a l -> In a (map fst (frequency_list l)). Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H a0 [H0| H0]; auto. rewrite H0; elim (frequency_list l0); simpl in |- *; auto. intros (a1, l1) l2; simpl in |- *; auto. case (eqA_dec a0 a1); simpl in |- *; auto. cut (In a0 (map (fst (A:=A) (B:=nat)) (frequency_list l0))); auto. elim (frequency_list l0); simpl in |- *; auto. intros (a1, l1) l2; simpl in |- *; auto. case (eqA_dec a a1); simpl in |- *; auto. intros e H1 [H2| H2]; auto; left; rewrite <- H2; auto. intros e H1 [H2| H2]; auto. Qed. Hint Resolve in_frequency_map : core. Theorem in_frequency_map_inv : forall l a, In a (map (fst (B:=_)) (frequency_list l)) -> In a l. Proof using. intros l a H; case in_map_inv with (1 := H); auto. intros (a1, l1) (Hl1, Hl2); simpl in |- *. rewrite Hl2; apply frequency_list_in with (1 := Hl1). Qed. Fixpoint number_of_occurrences (a : A) (l : list A) {struct l} : nat := match l with | nil => 0 | b :: l1 => match eqA_dec a b with | left _ => S (number_of_occurrences a l1) | right _ => number_of_occurrences a l1 end end. Theorem number_of_occurrences_O : forall a l, ~ In a l -> number_of_occurrences a l = 0. Proof using. intros a l; elim l; simpl in |- *; auto. intros a0 l0 H H0; case (eqA_dec a a0); auto. intros H1; case H0; auto. Qed. Theorem number_of_occurrences_permutation_ex : forall (m : list A) (a : A), exists m1 : list A, permutation m (id_list a (number_of_occurrences a m) ++ m1) /\ ~ In a m1. 
-> S := fun x : X => fun S : _ => fun f : compfun R S => pr1 f x.Definition compfuncomp { X : UU } ( R : hrel X ) { S S' : UU } ( f : compfun R S ) ( g : S -> S' ) : compfun R S' . Proof . intros . split with ( funcomp f g ) . intros x x' r . apply ( maponpaths g ( pr2 f x x' r ) ) . Defined . Definition setquot2 { X : UU } ( R : hrel X ) : UU := image ( compevmapset R ) . Theorem isasetsetquot2 { X : UU } ( R : hrel X ) : isaset ( setquot2 R ) . Proof. intros. assert (is1: isofhlevel 2 ( forall S: hSet, (compfun R S) -> S )). apply impred. intro. apply impred. intro X0. apply (pr2 t). apply (isasetsubset _ is1 (isinclpr1image _ )). Defined.Definition setquot2inset { X : UU } ( R : hrel X ) : hSet := hSetpair _ ( isasetsetquot2 R ) . Definition setquot2pr { X : UU } ( R : hrel X ) : X -> setquot2 R := fun x : X => imagepair ( compevmapset R ) _ ( hinhpr _ ( hfiberpair ( compevmapset R ) x ( idpath _ ) ) ) .Lemma issurjsetquot2pr { X : UU } ( R : hrel X ) : issurjective ( setquot2pr R ) . Proof. intros. apply issurjprtoimage. Defined. Lemma iscompsetquot2pr { X : UU } ( R : hrel X ) : iscomprelfun R ( setquot2pr R ) . Proof. intros. intros x x' r . assert (e1: paths ( compevmapset R x ) ( compevmapset R x' ) ) . apply funextsec. intro S. apply funextsec. intro f. unfold compfun in f. apply ( pr2 f x x' r ) . apply ( invmaponpathsincl _ ( isinclpr1image ( compevmapset R ) ) ( setquot2pr R x ) ( setquot2pr R x' ) e1 ) . Defined . Definition setquot2univ { X : UU } ( R : hrel X ) ( Y : hSet ) ( F : X -> Y ) (is : iscomprelfun R F ) ( c: setquot2 R ) : Y := pr1 c Y ( compfunpair _ F is ) . Theorem setquot2univcomm { X : UU } ( R : hrel X ) ( Y : hSet ) ( F : X -> Y ) (iscomp : iscomprelfun R F ) ( x : X) : paths (setquot2univ _ _ F iscomp ( setquot2pr R x )) (F x) . 
) : iscomprelfun R f . Proof . intros . intros x x' r . apply ( is _ _ ( pr2 ( lg _ _ ) r ) ) . Defined . Lemma isapropimeqclass { X : UU } ( R : hrel X ) ( Y : hSet ) ( f : X -> Y ) ( is : iscomprelfun R f ) ( c : setquot R ) : isaprop ( image ( fun x : c => f ( pr1 x ) ) ) . Proof. intros. apply isapropsubtype . intros y1 y2 . simpl . apply ( @hinhuniv2 _ _ ( hProppair ( paths y1 y2 ) ( pr2 Y y1 y2 ) ) ) . intros x1 x2 . simpl . destruct c as [ A iseq ] . destruct x1 as [ x1 is1 ] . destruct x2 as [ x2 is2 ] . destruct x1 as [ x1 is1' ] . destruct x2 as [ x2 is2' ] . simpl in is1 . simpl in is2 . simpl in is1' . simpl in is2' . assert ( r : R x1 x2 ) . apply ( eqax2 iseq _ _ is1' is2' ) . apply ( pathscomp0 ( pathsinv0 is1 ) ( pathscomp0 ( is _ _ r ) is2 ) ) . Defined . Theorem setquotuniv { X : UU } ( R : hrel X ) ( Y : hSet ) ( f : X -> Y ) ( is : iscomprelfun R f ) ( c : setquot R ) : Y . Proof. intros. apply ( pr1image ( fun x : c => f ( pr1 x ) ) ) . apply ( @hinhuniv ( pr1 c ) ( hProppair _ ( isapropimeqclass R Y f is c ) ) ( prtoimage ( fun x : c => f ( pr1 x ) ) ) ) . apply ( eqax0 ( pr2 c ) ) . Defined . Theorem setquotunivcomm { X : UU } ( R : eqrel X ) ( Y : hSet ) ( f : X -> Y ) ( is : iscomprelfun R f ) : forall x : X , paths ( setquotuniv R Y f is ( setquotpr R x ) ) ( f x ) . Proof. intros. unfold setquotuniv . unfold setquotpr . simpl . apply idpath . Defined. Theorem weqpathsinsetquot { X : UU } ( R : eqrel X ) ( x x' : X ) : weq ( R x x' ) ( paths ( setquotpr R x ) ( setquotpr R x' ) ) . 
q; induction n as [ | n IHn ]; intros q Hf1 Hf2 Ha. + rewrite msum_0; apply power_ge_1; omega. + rewrite msum_plus1; auto. apply lt_le_trans with (1*power (f n) p + a n * power (f n) p). * apply plus_lt_le_compat; auto. rewrite Nat.mul_1_l. apply IHn. - intros; apply Hf1; omega. - intros; apply Hf1; omega. - intros; apply Ha; omega. * rewrite <- Nat.mul_add_distr_r. replace q with (S (q-1)). - rewrite power_S; apply mult_le_compat; auto. ++ apply Ha; auto. ++ apply power_mono_l; try omega. generalize (Hf2 n); intros; omega. - generalize (Hf2 0); intros; omega. Qed. Lemma power_decomp_is_digit n a f : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> forall i, i < n -> is_digit (‚àë n (fun i => a i * power (f i) p)) p (f i) (a i). Proof. intros Hf Ha. induction n as [ | n IHn ]; intros i Hi. + omega. + split; auto. exists (‚àë (n-i) (fun j => a (S i + j) * power (f (S i+j) - f i - 1) p)), (‚àë i (fun j => a j * power (f j) p)); split. - replace (S n) with (S i + (n-i)) by omega. rewrite msum_plus, msum_plus1; auto. rewrite <- plus_assoc, plus_comm; f_equal. rewrite Nat.mul_add_distr_r, plus_comm; f_equal. rewrite <- mult_assoc, mult_comm, <- sum_0n_scal_l. apply msum_ext. intros j Hj. rewrite (mult_comm (_ * _)); repeat rewrite <- mult_assoc; f_equal. rewrite <- power_S, <- power_plus; f_equal. generalize (Hf i (S i+j)); intros; omega. - apply power_decomp_lt; auto. * intros; apply Hf; omega. * intros; apply Ha; omega. Qed. Theorem power_decomp_unique n f a b : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> (forall i, i < n -> b i < p) -> ‚àë n (fun i => a i * power (f i) p) = ‚àë n (fun i => b i * power (f i) p) -> forall i, i < n -> a i = b i. Proof. intros Hf Ha Hb E i Hi. generalize (power_decomp_is_digit _ _ Hf Ha Hi) (power_decomp_is_digit _ _ Hf Hb Hi). rewrite E; apply is_digit_fun. Qed.End power_decomp.Section power_decomp_uniq. Variable (p : nat) (Hp : 2 <= p). Theorem power_decomp_factor n f a : (forall i, 0 < i < S n -> f 0 < f i) -> ‚àë (S n) (fun i => a i * power (f i) p) = ‚àë n (fun i => a (S i) * power (f (S i) - f 0 - 1) p) * power (S (f 0)) p + a 0 * power (f 0) p. 
t0 : T, P t0 => forall t0 : T, paths (f t0) (g t0)) (fun t0:T => (pr1 fe) t0) (pr2 fe)). assert (isweqff: isweq ff). apply (isweqfpmap ( weqeta P ) (fun f: forall t:T, P t => forall t:T, paths (f t) (g t)) ). assert (ee: forall fe: (total2 (fun f : forall t0 : T, P t0 => forall t0 : T, paths (f t0) (g t0))), paths (ff (ff fe)) (ff fe)). intro. apply idpath. assert (eee: forall fe: (total2 (fun f : forall t0 : T, P t0 => forall t0 : T, paths (f t0) (g t0))), paths (ff fe) fe). intro. apply (invmaponpathsweq ( weqpair ff isweqff ) _ _ (ee fe)). apply (eee (tpair _ t x)). assert (eps0: forall u: Y, paths (p (s u)) u). intro. apply (pathscomp0 (eps u) (eetap u)). apply ( iscontrretract p s eps0). assumption. Defined. Theorem isweqtoforallpaths { T : UU } (P:T -> UU)( f g: forall t:T, P t) : isweq (toforallpaths P f g). Proof. intros. set (tmap:= fun ff: total2 (fun f0: forall t:T, P t => paths f0 g) => tpair (fun f0:forall t:T, P t => forall t:T, paths (f0 t) (g t)) (pr1 ff) (toforallpaths P (pr1 ff) g (pr2 ff))). assert (is1: iscontr (total2 (fun f0: forall t:T, P t => paths f0 g))). apply (iscontrcoconustot _ g). assert (is2:iscontr (total2 (fun f0:forall t:T, P t => forall t:T, paths (f0 t) (g t)))). apply funextweql1. assert (X: isweq tmap). apply (isweqcontrcontr tmap is1 is2). apply (isweqtotaltofib (fun f0: forall t:T, P t => paths f0 g) (fun f0:forall t:T, P t => forall t:T, paths (f0 t) (g t)) (fun f0:forall t:T, P t => (toforallpaths P f0 g)) X f). Defined. Theorem weqtoforallpaths { T : UU } (P:T -> UU)(f g : forall t:T, P t) : weq (paths f g) (forall t:T, paths (f t) (g t)) . Proof. intros. split with (toforallpaths P f g). apply isweqtoforallpaths. Defined. Definition funextsec { T : UU } (P: T-> UU) (s1 s2 : forall t:T, P t) : (forall t:T, paths (s1 t) (s2 t)) -> paths s1 s2 := invmap (weqtoforallpaths _ s1 s2) .Definition funextfun { X Y:UU } (f g:X->Y) : (forall x:X, paths (f x) (g x)) -> (paths f g):= funextsec (fun x:X => Y) f g. Theorem isweqfunextsec { T : UU } (P:T -> UU)(f g : forall t:T, P t) : isweq (funextsec P f g). 
left. reflexivity. destruct (isEmpty g) eqn : E. reflexivity. destruct (match_ n g) eqn : M. simpl in H0. inversion H0. symmetry in H3. subst. destruct m. - rewrite M. simpl. erewrite IH. reflexivity. apply lex1. unfold natNodes_lt. eapply match_decr_size. symmetry. apply M. intro. apply in_app_or in H2. destruct H2. apply H. right. assumption. rewrite in_map_iff in H2. destruct_all. inversion H2. 3 : { reflexivity. } rewrite map_app. rewrite map_app. unfold suci. rewrite (zip_fst_map _ _ (n :: l)). rewrite H5. reflexivity. rewrite repeat_length. apply length_equiv. rewrite map_app. rewrite map_app. rewrite H4. assert ( map snd (suci c (List.length (n :: l) - 1 + 1)%Z) = map (fun x : list Node => (List.length x - 1)%Z) (map (fun x0 : Node => x0 :: n :: l) (suc' c))). { unfold suci. assert ((List.length (n :: l) - 1 + 1)%Z = (List.length (n :: l))) by omega. rewrite H2. clear H2. simpl. rewrite <- length_equiv. assert (forall {A} (l: list A) l' , map snd (List.zip l (repeat (List.length l') (length l))) = map (fun x => ((List.length x - 1)%Z)) (map (fun x => x :: l') l)). { intros. generalize dependent l'. induction l0; intros. simpl. reflexivity. simpl. rewrite IHl0. assert (forall {B} (x : B) l, List.length (x :: l) = (List.length l + 1)%Z). { intros. assert (Z.to_nat (List.length (x :: l1)) = Z.to_nat (List.length l1 + 1)). rewrite <- length_equiv. rewrite Z2Nat.inj_add. rewrite <- length_equiv. assert (Z.to_nat 1%Z = 1). unfold Z.to_nat. unfold Pos.to_nat. unfold Pos.iter_op. reflexivity. rewrite H2. simpl. omega. unfold List.length. rewrite len_acc_def. simpl. omega. omega. apply Z2Nat.inj. unfold List.length. rewrite len_acc_def. simpl. apply Zle_0_pos . assert (0 <= List.length l1)%Z. unfold List.length. rewrite len_acc_def. simpl. omega. omega. apply H2. } rewrite H2. assert ((List.length l' + 1 - 1)%Z = List.length l') by omega. rewrite H3. reflexivity. } apply H2. } rewrite H2. reflexivity. - rewrite M. erewrite IH. reflexivity. apply lex2. unfold natNodes_eq. symmetry. eapply match_none_size. apply M. unfold list_length_lt. simpl. omega. intro. apply H. right. assumption. apply H5. apply H4. reflexivity. Qed.Lemma bft_length: forall (g: gr a b) v, map snd (level v g) = map (fun x => (List.length x - 1)%Z) (bft v g). Proof. intros. unfold level. unfold bft. rewrite <- leveln_leveln'_equiv. rewrite <- bf_bf'_equiv. apply bf_length. - intro. simpl in H. destruct H. inversion H. auto. - simpl. reflexivity. - simpl. reflexivity. Qed. Theorem bft_shortest_paths: forall (g: gr a b) v p d u, In (p, (u, d)) (List.zip (bft v g) (level v g)) -> shortest_path g v u p /\ length p = Z.to_nat d + 1. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. 
rem_lt, rem_lt in H; omega. Qed. Definition Zp_lprod := fold_right Zp_mult Zp_one. Fact Zp_lprod_nil : Zp_lprod nil = Op. Proof. trivial. Qed. Fact Zp_lprod_cons x l : Zp_lprod (x::l) = x ‚äó Zp_lprod l. Proof. trivial. Qed. Fact Zp_lprod_app l m : Zp_lprod (l++m) = Zp_lprod l ‚äó Zp_lprod m. Proof. induction l as [ | x l IHl ]. + rewrite Zp_lprod_nil, Zp_mult_one; auto. + simpl app; do 2 rewrite Zp_lprod_cons. rewrite IHl; ring. Qed. Theorem Zp_mult_autoinv l : ~ list_has_dup l -> (forall x, In x l -> x <> Zp /\ inv x <> x /\ In (inv x) l) -> Zp_lprod l = Op. Proof. induction on l as IHl with measure (length l); intros H0 Hl. destruct l as [ | x l ]. + rewrite Zp_lprod_nil; auto. + destruct (Hl x) as (H1 & H2 & [H3 | H3]); try (simpl; auto; fail). 1: destruct H2; auto. destruct in_split with (1 := H3) as (u & v & ?); subst. rewrite Zp_lprod_cons, Zp_lprod_app, Zp_lprod_cons. rewrite (Zp_mult_assoc _ (inv x)), (Zp_mult_comm _ (inv x)). repeat rewrite Zp_mult_assoc. rewrite (Zp_mult_comm _ (inv x)), Zp_invert_spec2; auto. rewrite Zp_mult_one, <- Zp_lprod_app. apply IHl. * simpl; do 2 rewrite app_length; simpl; omega. * contradict H0. constructor 2. apply perm_list_has_dup with (inv x::u++v). - apply Permutation_cons_app; auto. - constructor 2; auto. * intros y Hy. destruct (Hl y) as (G1 & G2 & G3). - apply in_app_or in Hy; right; apply in_or_app; simpl; tauto. - repeat (split; auto). destruct G3 as [ G3 | G3 ]. ++ destruct H0; rewrite G3 at 2. rewrite Zp_invert_involutive. constructor 2. apply perm_list_has_dup with (y::u++v). ** apply Permutation_cons_app; auto. ** constructor 1; auto. ++ apply in_or_app. apply in_app_or in G3. destruct G3 as [ | [ G3 | ] ]; try tauto. exfalso. apply f_equal with (f := inv) in G3. do 2 rewrite Zp_invert_involutive in G3. destruct H0. apply perm_list_has_dup with (inv x::(x::u)++v). ** apply Permutation_cons_app with (l1 := x::u); auto. ** simpl; constructor 2; constructor 1; subst; auto. Qed. Fact Zp_lprod_fact n : „Äöfact (S n)„Äõ= Zp_lprod (map nat2Zp (list_an 2 n)). Proof. induction n as [ | n IHn ]. + apply Zp_inj; simpl; auto. + rewrite fact_S, nat2Zp_mult. replace (S n)%nat with (n+1)%nat by omega. rewrite list_an_plus, map_app, Zp_lprod_app, <- IHn, Zp_mult_comm. f_equal. * do 2 f_equal; omega. * simpl list_an; unfold map. rewrite Zp_lprod_cons, Zp_mult_comm, Zp_mult_one. f_equal; omega. Qed. Theorem Wilson_thm_1 :„Äöfact (p-1)„Äõ= ‚à∏Op. 
(length vsl) vsl. Proof. induction vsl; eauto. simpl. unfold synced_list; simpl. f_equal. eauto. Qed. Lemma length_synced_up_to_n : forall n vsl, length vsl = length (synced_up_to_n n vsl). Proof. induction n; simpl; eauto; intros. destruct vsl; eauto. simpl; eauto. Qed. Lemma synced_up_to_n_nil : forall n, synced_up_to_n n nil = nil. Proof. induction n; eauto. Qed. Lemma synced_up_to_n_too_long : forall vsl n, n >= Datatypes.length vsl -> synced_up_to_n n vsl = synced_up_to_n (Datatypes.length vsl) vsl. Proof. induction vsl; simpl; intros; eauto. rewrite synced_up_to_n_nil; eauto. destruct n; try omega. simpl; f_equal. eapply IHvsl. omega. Qed. Lemma cons_synced_up_to_n' : forall synclen d l default, synclen <= Datatypes.length l -> (fst d, []) :: synced_up_to_n synclen l = synced_up_to_n synclen (d :: l) ‚ü¶ synclen := (fst (selN (d :: l) synclen default), nil) ‚üß. Proof. induction synclen; simpl; intros; eauto. f_equal. destruct l; simpl. rewrite synced_up_to_n_nil; eauto. erewrite IHsynclen; simpl in *; eauto. omega. Qed. Lemma cons_synced_up_to_n : forall synclen d l default, (fst d, []) :: synced_up_to_n synclen l = synced_up_to_n synclen (d :: l) ‚ü¶ synclen := (fst (selN (d :: l) synclen default), nil) ‚üß. Proof. intros. destruct (le_dec synclen (Datatypes.length l)). eapply cons_synced_up_to_n'; eauto. rewrite updN_oob by (simpl; omega). rewrite synced_up_to_n_too_long by omega. rewrite <- synced_list_up_to_n. rewrite synced_up_to_n_too_long by (simpl; omega). rewrite <- synced_list_up_to_n. firstorder. Qed. Fixpoint synced_file_alt_helper f off := match off with | O => f | S off' => let f' := mk_dirfile (updN (DFData f) off' (fst (selN (DFData f) off' ($0, nil)), nil)) (DFAttr f) in synced_file_alt_helper f' off' end. Fixpoint synced_file_alt_helper2 f off {struct off} := match off with | O => f | S off' => let f' := synced_file_alt_helper2 f off' in mk_dirfile (updN (DFData f') off' (fst (selN (DFData f') off' ($0, nil)), nil)) (DFAttr f') end. Lemma synced_file_alt_helper2_oob : forall off f off' v, let f' := synced_file_alt_helper f off in off' >= off -> (mk_dirfile (updN (DFData f') off' v) (DFAttr f')) = synced_file_alt_helper (mk_dirfile (updN (DFData f) off' v) (DFAttr f)) off. Proof. induction off; simpl; intros; eauto. - rewrite IHoff by omega; simpl. f_equal. f_equal. rewrite updN_comm by omega. rewrite selN_updN_ne by omega. auto. Qed. Lemma synced_file_alt_helper_selN_oob : forall off f off' default, off' >= off -> selN (DFData (synced_file_alt_helper f off)) off' default = selN (DFData f) off' default. Proof. induction off; simpl; eauto; intros. rewrite IHoff by omega; simpl. rewrite selN_updN_ne by omega. auto. Qed. Theorem synced_file_alt_helper_helper2_equiv : forall off f, synced_file_alt_helper f off = synced_file_alt_helper2 f off. 
if ?c then _ else _ ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ if ?c then _ else _ ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ |- context[ match ?c with Some _ => _ | None => _ end ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ match ?c with Some _ => _ | None => _ end ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ H : (?x <? ?y) = true |- _ ] => rewrite Nat.ltb_lt in H | [ H : (?x <? ?y) = false |- _ ] => rewrite Nat.ltb_nlt in H end; subst; auto.Lemma heap_extensionality : forall (h1 h2 : heap), h1 = h2 -> forall (x : nat), h1 x = h2 x. Proof. crush. Qed.Module SeparationProperty. Theorem pt2same_sep : forall (p x y : nat), p |-> x ** p |-> y ==> hlift False. Proof. hsimpl; intros; firstorder; subst. specialize (H p). hsolver; crush. Qed. Theorem pt2same_sep' : forall (p q x y : nat), p |-> x ** q |-> y ==> hlift (p <> q). Proof. hsimpl; intros; firstorder; subst. intros contra; subst. specialize (H q); repeat hsolver; crush. Qed. Theorem pt2same_and : forall (p x y : nat), p |-> x /~\ p |-> y ==> hlift (x = y). Proof. hsimpl; intros; intuition; subst. pose proof (@heap_extensionality _ _ H1 p); crush. hsolver; crush. Qed. Theorem pt_and_empty : forall (p x : nat), p |-> x /~\ hemp ==> hlift False. Proof. hsimpl; intros; intuition; subst. eapply heap_extensionality in H1. hsolver; crush. Qed. Theorem emp_unit : forall (P : assertion), hemp ** P <==> P /\ P ** hemp <==> P. Proof. hsimpl; intros; firstorder. + assert (h = x0); crush. + exists empty_heap, h. crush. + assert (h = x); crush. extensionality k; hsolver. + exists h, empty_heap. unfold empty_heap. crush. extensionality k; hsolver. Qed. Theorem hstar_commut : forall (P Q : assertion), P ** Q <==> Q ** P. Proof. hsimpl; intros; intuition; destruct H as [h1 [h2 H]]; intuition; exists h2, h1; intuition; try extensionality k; pose proof (H0 k); try tauto; pose proof (heap_extensionality H k); simpl in H4; intuition; repeat hsolver; crush. Qed. Theorem hstar_assoc : forall (P Q R : assertion), P ** (Q ** R) <==> (P ** Q) ** R. 
rewrite N2Nat.inj_add in H0. autorewrite with N in *. pre_nomega. simpl in *. omega. generalize H0; clear. unfold goodSize'. generalize (Npow2 32). intros. nomega. Qed.Lemma pow2_N : forall n, N.of_nat (pow2 n) = Npow2 n. intros. assert (N.to_nat (N.of_nat (pow2 n)) = N.to_nat (Npow2 n)). autorewrite with N. symmetry; apply Npow2_nat. assert (N.of_nat (N.to_nat (N.of_nat (pow2 n))) = N.of_nat (N.to_nat (Npow2 n))) by congruence. autorewrite with N in *. assumption. Qed.Lemma get_memoryIn : forall m w, smem_get w (memoryIn m) = m w. intros. unfold smem_get, memoryIn, HT.memoryIn, H.all_addr. rewrite allWords_eq. apply get_memoryIn'. apply wordToNat_bound. hnf. rewrite pow2_N. reflexivity. Qed.Require Import Bedrock.DepList.Fixpoint smem_put ls (sm : smem' ls) (w : W) (v : B) : smem' ls := match sm with | HNil => HNil | HCons w' _ v' sm' => HCons (if H.addr_dec w w' then Some v else v') (smem_put _ sm' w v) end.Fixpoint smem_clear ls (sm : smem' ls) (w : W) : smem' ls := match sm with | HNil => HNil | HCons w' _ v sm' => HCons (if H.addr_dec w w' then None else v) (smem_clear _ sm' w) end.Fixpoint smem_graft (sm sm' : smem) (p : W) (len : nat) : smem := match len with | O => sm | S len' => match smem_get p sm' with | None => sm | Some v => smem_put _ (smem_graft sm sm' (p ^+ $1) len') p v end end.Section OpSem. Variable m : module. Variable stn : settings. Variable prog : program. Hypothesis inj : forall l1 l2 w, Labels stn l1 = Some w -> Labels stn l2 = Some w -> l1 = l2. Definition labelSys' (l_pre : string * spec) := (Global (fst l_pre), Precondition (snd l_pre) None). Definition labelSys (l : LabelMap.key) (pre : assert) := fst l = "sys" /\ In (snd l, pre) (map labelSys' ( ("abort", abortS) :: ("printInt", printIntS) :: ("listen", listenS) :: ("accept", acceptS) :: ("connect", connectS) :: ("read", readS) :: ("write", writeS) :: ("declare", declareS) :: ("wait", waitS) :: ("close", closeS) :: nil)). Hypothesis impSys : LabelMap.fold (fun l pre P => labelSys l pre /\ P) (Imports m) True. Lemma preserve : forall (ls : list (LabelMap.key * assert)) Q, fold_left (fun P p => labelSys (fst p) (snd p) /\ P) ls Q -> Q. induction ls; simpl in *; intuition. apply IHls in H; tauto. Qed. Theorem impSys' : forall l pre, LabelMap.MapsTo l pre (Imports m) -> labelSys l pre. 
<> Float (- nNormMin radix precision) (- dExp b) -> Fnormal radix b (FSucc a). intros a H' H'0 H'1; cut (Fbounded b a); [ intros Fb0 | apply FnormalBounded with (1 := H'0) ]. cut (Fnum a <= 0)%Z; [ intros Z0 | apply R0LeFnum with (radix := radix) ]; auto with zarith. case (Zle_lt_or_eq _ _ Z0); intros Z1. 2: absurd (is_Fzero a); auto with float. 2: apply FnormalNotZero with (1 := H'0); auto. unfold FSucc in |- *. generalize (Z_eq_bool_correct (Fnum a) (pPred (vNum b))); case (Z_eq_bool (Fnum a) (pPred (vNum b))); auto. intros H'2; absurd (0 < Fnum a)%Z; auto with zarith arith. rewrite H'2; unfold pPred in |- *; apply Zlt_succ_pred; simpl in |- *; apply (vNumbMoreThanOne radix) with (precision := precision); auto with zarith arith. intros H'3; generalize (Z_eq_bool_correct (Fnum a) (- nNormMin radix precision)); case (Z_eq_bool (Fnum a) (- nNormMin radix precision)); auto. intros H'2; generalize (Z_eq_bool_correct (Fexp a) (- dExp b)); case (Z_eq_bool (Fexp a) (- dExp b)). intros H'4; Contradict H'1; auto. apply floatEq; auto. intros H'4; repeat split; simpl in |- *; auto with zarith. rewrite Zabs_Zopp. unfold pPred in |- *; rewrite Zabs_eq; auto with zarith. case (Zle_next (- dExp b) (Fexp a)); auto with float zarith. rewrite <- Zopp_mult_distr_r; rewrite Zabs_Zopp. rewrite Zabs_Zmult. repeat rewrite Zabs_eq; auto with float zarith. pattern (Zpos (vNum b)) at 1 in |- *; rewrite (PosNormMin radix) with (precision := precision); auto with zarith. apply Zle_Zmult_comp_l; auto with zarith. unfold pPred in |- *; apply Zle_Zpred; auto with float zarith. unfold pPred in |- *; apply Zle_Zpred; auto with float zarith. intros H'2; repeat split; simpl in |- *; auto with float zarith arith. apply Zlt_trans with (Zabs (Fnum a)); auto with float zarith. repeat rewrite Zabs_eq_opp; auto with float zarith. rewrite Zabs_Zmult. rewrite (Zabs_eq radix); [ idtac | apply Zle_trans with 1%Z; auto with zarith ]. repeat rewrite Zabs_eq_opp; auto with float zarith. pattern (Zpos (vNum b)) at 1 in |- *; rewrite (PosNormMin radix) with (precision := precision); auto with zarith. apply Zle_Zmult_comp_l; auto with zarith. replace (- Zsucc (Fnum a))%Z with (Zpred (- Fnum a)). auto with float zarith. unfold pPred in |- *; apply Zle_Zpred. case (Zle_lt_or_eq (nNormMin radix precision) (- Fnum a)); auto. rewrite <- Zabs_eq_opp; auto with float zarith. apply pNormal_absolu_min with (b := b); auto. intros H'4; Contradict H'2; rewrite H'4; ring. apply Zpred_Zopp_Zs; auto. Qed. Theorem FSuccNormNegNormMin : Fsubnormal radix b (FSucc (Float (- nNormMin radix precision) (- dExp b))). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. Record Functor (C C' : Category) : Type := { FO : C ‚Üí C'; FA : ‚àÄ {a b}, (a --> b)%morphism ‚Üí ((FO a) --> (FO b))%morphism; F_id : ‚àÄ c, FA (id c) = id (FO c); F_compose : ‚àÄ {a b c} (f : (a --> b)%morphism) (g : (b --> c)%morphism), (FA (g ‚àò f) = (FA g) ‚àò (FA f))%morphism }.Arguments FO {_ _} _ _. Arguments FA {_ _} _ _ _ _. Arguments F_id {_ _} _ _. Arguments F_compose {_ _} _ {_ _ _} _ _.Notation "C --> D" := (Functor C D) : functor_scope.Bind Scope functor_scope with Functor.Notation "F '_o'" := (FO F) : object_scope.Notation "F '@_a'" := (@FA _ _ F) : morphism_scope.Notation "F '_a'" := (@FA _ _ F _ _) : morphism_scope.Hint Extern 2 => (apply F_id) : core.Local Open Scope morphism_scope. Local Open Scope object_scope.Ltac Functor_Simplify := progress ( repeat rewrite F_id; ( repeat match goal with | [|- ?F _a ?A = id (?F _o ?x)] => (rewrite <- F_id; (cbn+idtac)) | [|- (id (?F _o ?x)) = ?F _a ?A] => (rewrite <- F_id; (cbn+idtac)) | [|- ?F _a ?A ‚àò ?F _a ?B = ?F _a ?C ‚àò ?F _a ?D] => (repeat rewrite <- F_compose; (cbn+idtac)) | [|- ?F _a ?A ‚àò ?F _a ?B = ?F _a ?C] => (rewrite <- F_compose; (cbn+idtac)) | [|- ?F _a ?C = ?F _a ?A ‚àò ?F _a ?B] => (rewrite <- F_compose; (cbn+idtac)) | [|- context [?F _a ?A ‚àò ?F _a ?B]] => (rewrite <- F_compose; (cbn+idtac)) end ) ) .Hint Extern 2 => Functor_Simplify : core.Section Functor_eq_simplification. Context {C C' : Category} (F G : (C --> C')%functor). Lemma Functor_eq_simplify (Oeq : F _o = G _o) : ((fun x y => match Oeq in _ = V return ((x --> y) ‚Üí ((V x) --> (V y)))%morphism with eq_refl => F @_a x y end) = G @_a) -> F = G. Proof. destruct F; destruct G. basic_simpl. ElimEq. PIR. trivial. Qed. Theorem FA_extensionality (Oeq : F _o = G _o) : ( ‚àÄ (a b : Obj) (h : (a --> b)%morphism), ( fun x y => match Oeq in _ = V return ((x --> y) ‚Üí ((V x) --> (V y)))%morphism with eq_refl => F @_a x y end ) _ _ h = G _a h ) ‚Üí ( fun x y => match Oeq in _ = V return ((x --> y) ‚Üí ((V x) --> (V y)))%morphism with eq_refl => F @_a x y end ) = G @_a. 
From Perennial.program_proof.mvcc Require Import txn_prelude txn_repr wrbuf_proof.Section program. Context `{!heapGS Œ£, !mvcc_ghostG Œ£}. Theorem wp_txn__Delete txn tid view (k : u64) dbv Œ≥ œÑ : {{{ own_txn txn tid view Œ≥ œÑ ‚àó txnmap_ptsto œÑ k dbv }}} Txn__Delete #txn #k {{{ (ok : bool), RET #ok; own_txn txn tid view Œ≥ œÑ ‚àó txnmap_ptsto œÑ k Nil }}}. 
Œ¶' }}) -‚àó ‚àÄ Œ¶, R -‚àó ‚ñ∑ (R -‚àó Œ¶ #()) -‚àó WP If #b e #() @ stk; E {{ Œ¶ }}. Proof. iIntros "Hwp" (Œ¶) "HR HŒ¶". wp_if_destruct. - wp_apply ("Hwp" with "[$HR]"). iFrame. - iApply ("HŒ¶" with "HR"). Qed.Theorem wp_If_join (R: iProp Œ£) (b: bool) stk E e1 e2 : ‚àÄ Œ¶, (‚åú b = true ‚åù -‚àó WP e1 @ stk; E {{ v, ‚åúv = #()‚åù ‚àó R }}) ‚àß (‚åú b = false ‚åù -‚àó WP e2 @ stk; E {{ v, ‚åúv = #()‚åù ‚àó R }}) -‚àó ‚ñ∑ (R -‚àó Œ¶ #()) -‚àó WP if: #b then e1 else e2 @ stk; E {{ Œ¶ }}. Proof. iIntros (Œ¶) "Hwp HŒ¶". wp_if_destruct. - iDestruct "Hwp" as "[He1 _]". iApply (wp_wand with "(He1 [//])"). iIntros (?) "[-> HR]". by iApply "HŒ¶". - iDestruct "Hwp" as "[_ He2]". iApply (wp_wand with "(He2 [//])"). iIntros (?) "[-> HR]". by iApply "HŒ¶". Qed. Lemma wp_If_join_evar Q (b : bool) e1 e2 Œ¶ : (‚àÄ b', ‚åúb' = b‚åù -‚àó WP if: #b then e1 else e2 {{ v, ‚åúv = #()‚åù ‚àó Q b' }}) -‚àó (Q b -‚àó Œ¶ #()) -‚àó WP if: #b then e1 else e2 {{ Œ¶ }}. Proof. iIntros "Hif Hcont". iApply (wp_wand with "[Hif]"). - iApply "Hif". done. - simpl. iIntros (v) "[-> HQ]". by iApply "Hcont". Qed. Lemma wp_If_join_evar' Q (b : bool) e1 e2 Œ¶ : (WP if: #b then e1 else e2 {{ v, ‚åúv = #()‚åù ‚àó Q }}) -‚àó (Q -‚àó Œ¶ #()) -‚àó WP if: #b then e1 else e2 {{ Œ¶ }}. Proof. iIntros "Hif Hcont". iApply (wp_If_join_evar with "[Hif] Hcont"). iIntros (? ->). done. Qed.Theorem wp_and_pure (P1 P2 : Prop) `{!Decision P1, !Decision P2} (e1 e2 : expr) (Œ¶ : val ‚Üí iProp Œ£) : WP e1 {{ v, ‚åúv = #(bool_decide P1)‚åù }} -‚àó (‚åúP1‚åù -‚àó WP e2 {{ v, ‚åúv = #(bool_decide P2)‚åù }}) -‚àó Œ¶ #(bool_decide (P1 ‚àß P2)) -‚àó WP e1 && e2 {{ Œ¶ }}. Proof. iIntros "He1 He2 HŒ¶". wp_bind e1. iApply (wp_wand with "He1"). iIntros (v1 ->). rewrite (bool_decide_decide P1). destruct (decide P1) as [HP1|HP1]. - wp_pures. iSpecialize ("He2" $! HP1). iApply (wp_wand with "He2"). iIntros (v1 ->). rewrite (bool_decide_decide P2). destruct (decide P2) as [HP2|HP2]. + rewrite bool_decide_eq_true_2 //. + rewrite bool_decide_eq_false_2 //. tauto. - wp_pures. iClear "He2". rewrite bool_decide_eq_false_2 //. tauto. Qed. Theorem wp_and (P1 P2 : Prop) (H : iProp Œ£) `{!Decision P1, !Decision P2} (e1 e2 : expr) (Œ¶ : val ‚Üí iProp Œ£) : H -‚àó WP e1 {{ v, ‚åúv = #(bool_decide P1)‚åù }} -‚àó (‚åúP1‚åù -‚àó H -‚àó WP e2 {{ v, ‚åúv = #(bool_decide P2)‚åù ‚àó H }}) -‚àó (H -‚àó Œ¶ #(bool_decide (P1 ‚àß P2))) -‚àó WP e1 && e2 {{ Œ¶ }}. 
clear H' H'0 x y. intros Fnum1 Fexp1 Fnum2 Fexp2 H' H'0; rewrite inj_abs; auto with zarith. Qed. Theorem FshiftO : forall x : float, Fshift 0 x = x. intros x; unfold Fshift in |- *; apply floatEq; simpl in |- *. replace (Zpower_nat radix 0) with 1%Z; auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem FshiftCorrectSym : forall x y : float, x = y :>R -> exists n : nat, (exists m : nat, Fshift n x = Fshift m y). intros x y H'. case (Z_le_gt_dec (Fexp x) (Fexp y)); intros H'1. exists 0; exists (Zabs_nat (Fexp y - Fexp x)). rewrite FshiftO. apply sym_equal. apply FshiftCorrectInv; auto. exists (Zabs_nat (Fexp x - Fexp y)); exists 0. rewrite FshiftO. apply FshiftCorrectInv; auto with zarith. Qed. Theorem FshiftAdd : forall (n m : nat) (p : float), Fshift (n + m) p = Fshift n (Fshift m p). intros n m p; case p; unfold Fshift in |- *; simpl in |- *. intros Fnum1 Fexp1; apply floatEq; simpl in |- *; auto with zarith. rewrite Zpower_nat_is_exp; auto with zarith. rewrite (Zmult_comm (Zpower_nat radix n)); auto with zarith. rewrite <- (Zminus_plus_simpl_r (Fexp1 - m) n m). replace (Fexp1 - m + m)%Z with Fexp1; auto with zarith. replace (Z_of_nat (n + m)) with (n + m)%Z; auto with zarith arith. rewrite <- inj_plus; auto. Qed. Theorem ReqGivesEqwithSameExp : forall p q : float, exists r : float, (exists s : float, p = r :>R /\ q = s :>R /\ Fexp r = Fexp s). intros p q; exists (Fshift (Zabs_nat (Fexp p - Zmin (Fexp p) (Fexp q))) p); exists (Fshift (Zabs_nat (Fexp q - Zmin (Fexp p) (Fexp q))) q); repeat split; auto with real. rewrite FshiftCorrect; auto. rewrite FshiftCorrect; auto. simpl in |- *. replace (Z_of_nat (Zabs_nat (Fexp p - Zmin (Fexp p) (Fexp q)))) with (Fexp p - Zmin (Fexp p) (Fexp q))%Z. replace (Z_of_nat (Zabs_nat (Fexp q - Zmin (Fexp p) (Fexp q)))) with (Fexp q - Zmin (Fexp p) (Fexp q))%Z. case (Zmin_or (Fexp p) (Fexp q)); intros H'; rewrite H'; auto with zarith. rewrite inj_abs; auto. apply Zplus_le_reg_l with (p := Zmin (Fexp p) (Fexp q)); auto with zarith. generalize (Zle_min_r (Fexp p) (Fexp q)); auto with zarith. rewrite inj_abs; auto. apply Zplus_le_reg_l with (p := Zmin (Fexp p) (Fexp q)); auto with zarith. Qed. Theorem FdigitEq : forall x y : float, ~ is_Fzero x -> x = y :>R -> Fdigit x = Fdigit y -> x = y. 
with (lv:=lvn) in XX;sp; try congruence; [| disjoint_reasoningv];[]. econstructor; eauto. eapply alpha_eq3_change_avoidvars; eauto. Qed.Theorem alphabt_change_var_aux {p} : forall nt1 nt2 lv1 lv2 lv, alpha_eq_bterm (bterm lv1 nt1) (bterm lv2 nt2) -> length lv1 = length lv -> disjoint lv (all_vars nt1 ++ all_vars nt2) -> no_repeats lv -> (alpha_eq (lsubst_aux nt1 (var_ren lv1 lv)) (lsubst_aux nt2 (@var_ren p lv2 lv)) # length lv1 = length lv2). Proof. introns HX. unfold lsubst. duplicate HX as Hl. inverts Hl. apply alphaeq_bterm3_if with (lva:=[]) in HX. split; spc; eapply alpha_eq_if3; eapply alpha3bt_change_var;eauto.Qed.Theorem alphabt_change_var {p} : forall nt1 nt2 lv1 lv2 lv, alpha_eq_bterm (bterm lv1 nt1) (bterm lv2 nt2) -> length lv1 = length lv -> disjoint lv (all_vars nt1 ++ all_vars nt2) -> no_repeats lv -> (alpha_eq (lsubst nt1 (var_ren lv1 lv)) (lsubst nt2 (@var_ren p lv2 lv)) # length lv1 = length lv2). Proof. introns HX. unfold lsubst. duplicate HX as Hl. inverts Hl. change_to_lsubst_aux4. apply alphaeq_bterm3_if with (lva:=[]) in HX. split; spc; eapply alpha_eq_if3; eapply alpha3bt_change_var;eauto.Qed.Hint Resolve alpha_eq_sym alpha_eq_trans : slow.Lemma alpha_eq_bterm_trans {p} : forall bt1 bt2 bt3, @alpha_eq_bterm p bt1 bt2 -> alpha_eq_bterm bt2 bt3 -> alpha_eq_bterm bt1 bt3. Proof. introv H1b H2b. destruct bt1 as [lv1 nt1]. destruct bt2 as [lv2 nt2]. destruct bt3 as [lv3 nt3]. pose proof (fresh_vars (length lv1) (all_vars nt1++all_vars nt2++all_vars nt3)). exrepnd. apply alphabt_change_var with (lv:=lvn) in H1b; eauto; disjoint_reasoningv. apply alphabt_change_var with (lv:=lvn) in H2b; eauto; disjoint_reasoningv;spc. apply al_bterm with (lv:=lvn); spc; disjoint_reasoningv. eauto with slow. Qed.Lemma alpha_eq_bterm_sym {p} : forall bt1 bt2, @alpha_eq_bterm p bt1 bt2 -> alpha_eq_bterm bt2 bt1. Proof. introv Hb. inverts Hb. apply @al_bterm with (lv:=lv);sp; eauto with slow; []. disjoint_reasoningv. Qed. Hint Resolve alpha_eq_bterm_trans alpha_eq_bterm_sym: slow. Definition lsubst_alpha3_congr_aux {p} t1 t2 lvi lnt1 lnt2 := @alpha_eq3 p [] t1 t2 -> length lvi = length lnt1 -> length lvi = length lnt2 -> disjoint (flat_map free_vars lnt1) (bound_vars t1) -> disjoint (flat_map free_vars lnt2) (bound_vars t2) -> bin_rel_nterm (alpha_eq3 []) lnt1 lnt2 -> alpha_eq3 [] (lsubst_aux t1 (combine lvi lnt1)) (lsubst_aux t2 (combine lvi lnt2)).Definition lsubst_alphabt3_congr_aux {p} bt1 bt2 lvi lnt1 lnt2 := @alpha_eq_bterm3 p [] bt1 bt2 -> length lvi = length lnt1 -> length lvi = length lnt2 -> disjoint (flat_map free_vars lnt1) (bound_vars_bterm bt1) -> disjoint (flat_map free_vars lnt2) (bound_vars_bterm bt2) -> bin_rel_nterm (alpha_eq3 []) lnt1 lnt2 -> alpha_eq_bterm3 [] (lsubst_bterm_aux bt1 (combine lvi lnt1)) (lsubst_bterm_aux bt2 (combine lvi lnt2)).Hint Unfold lsubst_alphabt3_congr_aux. Hint Unfold lsubst_alpha3_congr_aux. Theorem lsubst_alphabt3_congr_auxp {p} : forall bnt1 blv1, (forall t1' t2 lvi lnt1 lnt2, (@size p t1' <= @size p bnt1) -> lsubst_alpha3_congr_aux t1' t2 lvi lnt1 lnt2) -> forall bt2 lvi lnt1 lnt2, lsubst_alphabt3_congr_aux (bterm blv1 bnt1) bt2 lvi lnt1 lnt2. 
cancel. all : match goal with [H : Forall _ _ |- _] => inversion H; intuition end. Qed. Lemma indrep_n_helper_length : forall F Fs bxp ibn l m, (F * indrep_n_helper Fs bxp ibn l)%pred m -> length l = NIndirect. Proof. unfold indrep_n_helper, IndRec.rep, IndRec.items_valid. intros; destruct addr_eq_dec; destruct_lift H; unfold lift_empty in *; intuition; subst; autorewrite with lists; auto. unfold IndRec.Defs.item in *; simpl in *. omega. Qed. Lemma indrep_n_helper_length_piff : forall Fs bxp ibn l, indrep_n_helper Fs bxp ibn l <=p=> indrep_n_helper Fs bxp ibn l * [[ length l = NIndirect ]]. Proof. intros. split. - intros m H. pred_apply; cancel. eapply indrep_n_helper_length with (m := m). pred_apply; cancel. - cancel. Qed. Lemma indrep_n_length_pimpl : forall indlvl bxp ibn Fs l, indrep_n_tree indlvl bxp Fs ibn l <=p=> [[ length l = NIndirect ^ (S indlvl) ]] * indrep_n_tree indlvl bxp Fs ibn l. Proof. induction indlvl; simpl; intros. intros; split; intros m H; destruct_lift H; pred_apply; cancel. erewrite indrep_n_helper_length with (m := m); eauto; try omega. pred_apply; cancel. intros; split; intros m H; destruct_lift H; pred_apply; cancel. rewrite indrep_n_helper_length_piff, listmatch_length_pimpl in H; destruct_lift H. rewrite listmatch_lift_r in H; destruct_lift H. erewrite concat_hom_length; eauto. rewrite combine_length_eq in * by congruence. eassign (NIndirect ^ S indlvl). f_equal; omega. intros x y; destruct x. intros. rewrite IHindlvl. instantiate (1 := fun x y => indrep_n_tree indlvl bxp (snd x) (# (fst x)) y). split; cancel. Qed. Lemma listmatch_indrep_n_tree_forall_length : forall indlvl bxp (l1 : list (waddr * _)) l2, listmatch (fun a l' => indrep_n_tree indlvl bxp (snd a) # (fst a) l') l1 l2 <=p=> listmatch (fun a l' => indrep_n_tree indlvl bxp (snd a) # (fst a) l') l1 l2 * [[Forall (fun sublist : list waddr => (length sublist = NIndirect * NIndirect ^ indlvl)%nat) l2]]. Proof. intros. split; [> | cancel]. rewrite listmatch_lift_r at 1. cancel. eauto. intros. destruct x. rewrite indrep_n_length_pimpl. split; cancel. Qed. Local Hint Extern 1 (Forall (fun x => length x = _) _) => match goal with | [H : context [listmatch (fun x y => indrep_n_tree _ _ (snd x) # (fst x) y) _ ?l] |- Forall (fun x => length x = _) ?l ] => rewrite listmatch_indrep_n_tree_forall_length with (l2 := l) in H; destruct_lift H; solve [eassumption] | [|- Forall _ (upd_range ?l _ _ _)] => apply forall_upd_range; autorewrite with lists; eauto end. Theorem indrep_n_helper_pts_piff : forall Fs bxp ir l, ir <> 0 -> indrep_n_helper Fs bxp ir l <=p=> [[ length l = NIndirect ]] * [[ BALLOCC.bn_valid bxp ir ]] * [[ Fs <=p=> ir |->? ]] * ir |-> (IndRec.Defs.block2val l, []). 
Set Implicit Arguments. Unset Strict Implicit. Require Export point_cocyclicite. Definition orthocentre (H A B C : PO) := (orthogonal (vec H A) (vec B C) /\ orthogonal (vec H B) (vec A C)) /\ orthogonal (vec H C) (vec A B). Section Theoreme. Parameter H A B C : PO. Hypothesis triangle : ~ colineaire (vec A B) (vec A C). Hypothesis H_orthocentre : orthocentre H A B C. Lemma orthocentre_double : R (double (cons (vec H C) (vec H B))) (double (cons (vec A B) (vec A C))). unfold orthocentre in H_orthocentre. elim H_orthocentre; intros H0 H1; elim H0; intros H2 H3; clear H0 H_orthocentre; try exact H3. apply transitive with (double (plus (cons (vec H C) (vec A B)) (plus (cons (vec A B) (vec A C)) (cons (vec A C) (vec H B))))). apply R_double. auto. apply transitive with (plus (double (cons (vec H C) (vec A B))) (double (plus (cons (vec A B) (vec A C)) (cons (vec A C) (vec H B))))). auto. apply transitive with (plus (double (cons (vec H C) (vec A B))) (plus (double (cons (vec A B) (vec A C))) (double (cons (vec A C) (vec H B))))). apply compatible; auto. apply transitive with (plus pi (plus (double (cons (vec A B) (vec A C))) pi)). apply compatible; auto. apply compatible; auto. cut (orthogonal (vec A C) (vec H B)); (intros; auto). apply transitive with (plus (plus (double (cons (vec A B) (vec A C))) pi) pi). auto. apply transitive with (plus (double (cons (vec A B) (vec A C))) (plus pi pi)). auto. apply transitive with (plus (double (cons (vec A B) (vec A C))) zero). apply compatible; auto. apply transitive with (plus zero (double (cons (vec A B) (vec A C)))). auto. auto. Qed. Theorem symetrique_orthocentre_cercle : forall H' : PO, R (cons (vec H' B) (vec B C)) (cons (vec B C) (vec H B)) -> R (cons (vec H' C) (vec B C)) (cons (vec B C) (vec H C)) -> sont_cocycliques A B C H'. 
/\ snd (pBody q) = pBody p. Proof using. unfold mgv_deghost. simpl. intros. do_in_map. subst. simpl. eauto. Qed. Lemma state_machine_safety'_state_same_packet_subset : msg_refined_raft_net_invariant_state_same_packet_subset (fun net : ghost_log_network => state_machine_safety' (mgv_deghost net)). Proof using rmri. unfold msg_refined_raft_net_invariant_state_same_packet_subset, state_machine_safety'. intuition. - unfold state_machine_safety_host' in *. intuition. repeat find_apply_lem_hyp committed_lifted_committed. eauto 6 using lifted_committed_committed, lifted_committed_state_same. - unfold state_machine_safety_nw' in *. intuition. find_apply_lem_hyp exists_in_mgv_deghost_packet. break_exists. break_and. find_apply_hyp_hyp. find_apply_lem_hyp in_mgv_ghost_packet. match goal with | [ H : context [ pBody ] |- _ ] => eapply H; eauto end. + rewrite pBody_mgv_deghost_packet. repeat find_rewrite. eauto. + apply lifted_committed_committed. eapply lifted_committed_state_same; eauto using committed_lifted_committed. Qed. Lemma CRC_state_same_packet_subset : msg_refined_raft_net_invariant_state_same_packet_subset (fun net : ghost_log_network => commit_recorded_committed (mgv_deghost net)). Proof using rri. unfold msg_refined_raft_net_invariant_state_same_packet_subset, commit_recorded_committed, commit_recorded, committed, directly_committed. intros. specialize (H1 h e). repeat find_rewrite_lem deghost_spec. repeat find_rewrite_lem msg_deghost_spec'. repeat find_higher_order_rewrite. find_apply_hyp_hyp. break_exists_exists. repeat find_rewrite_lem msg_deghost_spec'. repeat rewrite msg_deghost_spec'. repeat find_higher_order_rewrite. intuition. break_exists_exists. intuition. find_apply_hyp_hyp. repeat find_rewrite_lem msg_deghost_spec'. repeat rewrite msg_deghost_spec'. repeat find_higher_order_rewrite. auto. Qed. Lemma everything_state_same_packet_subset : msg_refined_raft_net_invariant_state_same_packet_subset' everything. Proof using rmri lalcii smspi rri. unfold msg_refined_raft_net_invariant_state_same_packet_subset', everything. intuition. - eapply lifted_maxIndex_sanity_state_same_packet_subset; eauto. - eapply commit_invariant_state_same_packet_subset; eauto. - apply state_machine_safety_deghost. + eapply CRC_state_same_packet_subset; eauto. apply commit_invariant_lower_commit_recorded_committed; auto. + eapply state_machine_safety'_state_same_packet_subset; eauto. auto using state_machine_safety'_invariant, msg_simulation_1. Qed. Lemma everything_reboot : msg_refined_raft_net_invariant_reboot' everything. Proof using rmri lalcii smspi rri. unfold msg_refined_raft_net_invariant_reboot', everything. intuition. - eapply lifted_maxIndex_sanity_reboot; eauto. - eapply commit_invariant_reboot; eauto. - apply state_machine_safety_deghost. + apply commit_invariant_lower_commit_recorded_committed. auto. eapply commit_invariant_reboot; eauto. + apply state_machine_safety'_invariant. auto using msg_simulation_1. Qed. Theorem everything_invariant : forall net, msg_refined_raft_intermediate_reachable net -> everything net. Proof using rmri tsi glemi lphogli glci miaei lalcii rlmli smspi si rri. intros. apply msg_refined_raft_net_invariant'; auto. - apply everything_init. - apply everything_client_request. - apply everything_timeout. - apply everything_append_entries. - apply everything_append_entries_reply. - apply everything_request_vote. - apply everything_request_vote_reply. - apply everything_do_leader. - apply everything_do_generic_server. - apply everything_state_same_packet_subset. - apply everything_reboot. Qed. Theorem state_machine_safety_invariant : forall net, raft_intermediate_reachable net -> state_machine_safety net. Proof using rmri tsi glemi lphogli glci miaei lalcii rlmli smspi si rri. intros. apply lower_prop; intros; auto. apply msg_lower_prop with (P := fun net => _ (deghost net)); intros; auto. find_apply_lem_hyp everything_invariant. unfold everything in *. intuition. Qed. Theorem maxIndex_sanity_invariant : forall net, raft_intermediate_reachable net -> maxIndex_sanity net. Proof using rmri tsi glemi lphogli glci miaei lalcii rlmli smspi si rri. intros. apply lower_prop; intros; eauto. apply msg_lower_prop with (P := fun net => _ (deghost net)); intros; auto. find_apply_lem_hyp everything_invariant. unfold everything in *. intuition. auto using maxIndex_sanity_lower. Qed. Theorem commit_recorded_committed_invariant : forall net, refined_raft_intermediate_reachable net -> commit_recorded_committed net. 
-> In f meths -> TraceInclusion (Base (inlineSingle_BaseModule f regs rules meths)) (Base (BaseMod regs rules meths)). Proof. rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inline_BaseModule_all_l. Qed.Lemma TraceInclusion_inline_BaseModule_all_Wf_l {f} {m : BaseModuleWf type} (inMeth : In f (getMethods m)): TraceInclusion (inlineSingle_BaseModuleWf inMeth) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inline_BaseModule_all_l P2 inMeth) as P3. eauto using TraceInclusion_trans. Qed.Theorem TraceInclusion_inline_BaseModule_all_Wf_l_new {f} {m : BaseModuleWf_new type} (inMeth : In f (getMethods m)): TraceInclusion (inlineSingle_BaseModuleWf_new inMeth) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. eapply (@TraceInclusion_inline_BaseModule_all_Wf_l f m'). Unshelve. auto. Qed.Section inline_all_all_l. Lemma TraceInclusion_inlineSingle_pos_Rules_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> forall n, (WfMod type (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths)) (Base (BaseMod regs rules meths)). Proof. intros WfH n. unfold inlineSingle_Rules_pos. case_eq (nth_error meths n); intros sth; [intros sthEq|split; [assumption | apply TraceInclusion_refl]]. split. - apply nth_error_In in sthEq. pose proof (WfMod_inline_all_Rule sth (seq 0 (length rules)) sthEq WfH). repeat rewrite map_fold_right_eq in *. assumption. - apply TraceInclusion_inline_BaseModule_rules_l; auto. eapply nth_error_In; eauto. Qed. Theorem TraceInclusion_inlineSingle_pos_Rules_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> forall n, (WfMod_new type (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths)) (Base (BaseMod regs rules meths)). Proof. intros. rewrite WfMod_new_WfMod_iff in *. apply TraceInclusion_inlineSingle_pos_Rules_l; auto. Qed. Lemma TraceInclusion_inlineSingle_pos_Rules_Wf_l (m : BaseModuleWf type) n : TraceInclusion (inlineSingle_Rules_pos_BaseModuleWf m n) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineSingle_pos_Rules_l P2 n) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineSingle_pos_Rules_Wf_l_new (m : BaseModuleWf_new type) n : TraceInclusion (inlineSingle_Rules_pos_BaseModuleWf_new m n) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineSingle_pos_Rules_Wf_l m'). Qed. Lemma TraceInclusion_inlineAll_pos_Rules_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> (WfMod type (Base (BaseMod regs (inlineAll_Rules meths rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineAll_Rules meths rules) meths)) (Base (BaseMod regs rules meths)). Proof. intros WfH. unfold inlineAll_Rules. induction (Datatypes.length meths); [simpl in *; split; [assumption | apply TraceInclusion_refl]|]. rewrite seq_eq. rewrite fold_left_app; simpl in *. destruct IHn as [IHn1 IHn2]. pose proof (TraceInclusion_inlineSingle_pos_Rules_l IHn1 n) as [sth1 sth2]. destruct n; simpl in *; auto. split; auto. eapply TraceInclusion_trans; eauto. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> (WfMod_new type (Base (BaseMod regs (inlineAll_Rules meths rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineAll_Rules meths rules) meths)) (Base (BaseMod regs rules meths)). 
y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof Group.op_neg_def op_group. Theorem op_neg_inj : is_injective E E op_neg. Proof Group.op_neg_inj op_group. Theorem op_cancel_neg : forall x : E, op_neg (- x) = x. Proof Group.op_cancel_neg op_group. Theorem op_neg_onto : is_onto E E op_neg. Proof Group.op_neg_onto op_group. Theorem op_neg_bijective : is_bijective E E op_neg. Proof Group.op_neg_bijective op_group. Theorem op_neg_rev : forall x y : E, - x = y -> - y = x. Proof Group.op_neg_rev op_group. Theorem op_neg_distrib_inv_l : forall x y : E, op_is_inv_l (x + y) (- y + - x). Proof Group.op_neg_distrib_inv_l op_group. Theorem op_neg_distrib_inv_r : forall x y : E, op_is_inv_r (x + y) (- y + - x). Proof Group.op_neg_distrib_inv_r op_group. Theorem op_neg_distrib_inv : forall x y : E, op_is_inv (x + y) (- y + - x). 
:: l) -> In b l -> order a b. Proof using A order order_trans. intros a b l; generalize a b; elim l; clear l a b. intros a b H H2; inversion H2. simpl in |- *; intros c l H a b H0 [H1| H1]. rewrite <- H1; apply ordered_inv_order with (1 := H0). apply order_trans with (b := c); auto. apply ordered_inv_order with (1 := H0). apply H; auto. apply ordered_inv with (1 := H0). Qed. Theorem ordered_trans_app : forall (a b : A) (l1 l2 : list A), ordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b. Proof using A order order_trans. intros a b l1 l2; generalize a b; elim l1; simpl in |- *; clear l1 a b. intros a b H H1; case H1. intros c l H a b H0 [H1| H1] H2. rewrite <- H1; apply ordered_trans with (1 := H0); auto with datatypes. apply H; auto. apply ordered_inv with (1 := H0); auto. Qed. Theorem ordered_perm_antisym_eq : (forall a b : A, order a b -> order b a -> a = b) -> forall l1 l2 : list A, permutation l1 l2 -> ordered l1 -> ordered l2 -> l1 = l2. Proof using A order order_trans. intros antisym l1; elim l1; clear l1; simpl in |- *; auto. intros l2 H1 H2 H3; apply sym_equal; apply permutation_nil_inv. apply permutation_sym; auto. intros a l1 Rec l2; case l2; simpl in |- *. intros H; absurd (length (a :: l1) = length (A:=A) nil). simpl in |- *; red in |- *; intros; discriminate. apply permutation_length; auto. intros a0 l H H0 H1. cut (a = a0). intros H3; apply f_equal2 with (f := cons (A:=A)); auto. apply Rec; auto. apply permutation_inv with (a := a); auto. pattern a at 2 in |- *; rewrite H3; auto. apply ordered_inv with (1 := H0); auto. apply ordered_inv with (1 := H1); auto. generalize (permutation_in _ a _ _ H); simpl in |- *; (intros H2; case H2; auto; clear H2; intros H2). generalize (permutation_in _ a0 _ _ (permutation_sym _ _ _ H)); simpl in |- *; (intros H3; case H3; auto; clear H3; intros H3). apply antisym. apply ordered_trans with (1 := H0); auto. apply ordered_trans with (1 := H1); auto. Qed. End ordered. Hint Constructors ordered : core. Arguments ordered [A]. Theorem ordered_map_inv : forall (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B), ordered (fun x y => order (g x) (g y)) l -> ordered order (map g l). 
eqd (ls : list A), In None (getSupport (rndListElem eqd ls)) <-> ls = nil. intuition. unfold rndListElem in *. case_eq (length ls); intuition. destruct ls; simpl in *; trivial; discriminate. rewrite H0 in H. repeat simp_in_support. apply RndNat_support_lt in H1. edestruct (nth_option_some ls); eauto. rewrite H0. eauto. congruence. subst. simpl. intuition.Qed.Theorem rndListElem_uniform : forall (A : Set)(eqd : EqDec A)(ls : list A)(a1 a2 : option A), NoDup ls -> In a1 (getSupport (rndListElem _ ls)) -> In a2 (getSupport (rndListElem _ ls)) -> evalDist (rndListElem _ ls) a1 == evalDist (rndListElem _ ls) a2. intuition. destruct a1. destruct a2. rewrite <- rndListElem_support in *. unfold rndListElem. case_eq (length ls); intuition. destruct ls; simpl in *. intuition. omega. eapply comp_spec_impl_eq. eapply comp_spec_seq. apply (Some a). apply (Some a). eapply eq_impl_comp_spec. eapply well_formed_RndNat. omega. eapply well_formed_RndNat. omega. eapply RndNat_uniform. 3:{ intros. simpl in H5. eapply comp_spec_ret. assert (a1 = (firstIndexOf (EqDec_dec _) ls a 0) <-> b = (firstIndexOf (EqDec_dec _) ls a0 0)). eapply H5. clear H5. intuition; subst. rewrite H5. eapply nth_firstIndexOf; trivial. symmetry. eapply nth_firstIndexOf_if; intuition. rewrite H7. eapply nth_firstIndexOf; trivial. symmetry. eapply nth_firstIndexOf_if; intuition. } rewrite <- H2. apply firstIndexOf_in_lt; trivial. rewrite <- H2. apply firstIndexOf_in_lt; trivial. apply rndListElem_support in H0. apply rndListElem_support_None in H1. subst. simpl in *. intuition. destruct a2. apply rndListElem_support in H1. apply rndListElem_support_None in H0. subst. simpl in *. intuition. intuition.Qed.Lemma not_in_nth_option : forall (A : Set)(ls : list A)(a : A)(i : nat), (~In a ls) -> nth_option ls i = Some a -> False. induction ls; intuition; simpl in *. discriminate. destruct i. inversion H0; clear H0; subst. intuition. eapply IHls; eauto.Qed.Theorem nth_firstIndexOf_None : forall (A : Set)(eqd : eq_dec A)(ls : list A), NoDup ls -> forall (a a' : A) i, In a ls -> i <> firstIndexOf eqd ls a O -> nth_option ls i = Some a' -> a <> a'. induction 1; intuition; simpl in *. intuition; subst. destruct (eqd a' a'); subst; intuition. destruct i; intuition. eapply not_in_nth_option; eauto. destruct i; intuition. inversion H3; clear H3; subst. destruct (eqd a' a'); subst; intuition. destruct (eqd a' x); subst; intuition. eapply IHNoDup; eauto. Qed.Lemma nth_option_not_None : forall (A : Set)(ls : list A)(i : nat), i < length ls -> nth_option ls i = None -> False. induction ls; intuition; simpl in *. omega. destruct i. discriminate. assert (i < length ls). omega. eauto.Qed. Theorem rndListElem_uniform_gen : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls1 : list A)(ls2 : list B)(a1 : A)(a2 : B), NoDup ls1 -> NoDup ls2 -> length ls1 = length ls2 -> In a1 ls1 -> In a2 ls2 -> comp_spec (fun x y => x = Some a1 <-> y = Some a2) (rndListElem _ ls1) (rndListElem _ ls2). 
intros H'2 H'3; elim H'3; intros H'4 H'5; apply H'5; clear H'3 H'0. case H'1; auto. apply Rle_trans with q; auto. apply Rlt_le; auto. apply isMax_inv1 with (1 := H'1); auto. Qed. Theorem MinEq : forall (p q : float) (r : R), isMin r p -> isMin r q -> p = q :>R. intros p q r H' H'0; apply Rle_antisym. elim H'0; intros H'1 H'2; elim H'2; intros H'3 H'4; apply H'4; clear H'2 H'0; auto. case H'; auto. apply isMin_inv1 with (1 := H'); auto. elim H'; intros H'1 H'2; elim H'2; intros H'3 H'4; apply H'4; clear H'2 H'; auto. case H'0; auto. apply isMin_inv1 with (1 := H'0); auto. Qed. Theorem MaxEq : forall (p q : float) (r : R), isMax r p -> isMax r q -> p = q :>R. intros p q r H' H'0; apply Rle_antisym. elim H'; intros H'1 H'2; elim H'2; intros H'3 H'4; apply H'4; clear H'2 H'; auto. case H'0; auto. apply isMax_inv1 with (1 := H'0); auto. elim H'0; intros H'1 H'2; elim H'2; intros H'3 H'4; apply H'4; clear H'2 H'0; auto. case H'; auto. apply isMax_inv1 with (1 := H'); auto. Qed. Theorem MinOppMax : forall (p : float) (r : R), isMin r p -> isMax (- r) (Fopp p). intros p r H'; split. apply oppBounded; case H'; auto. split. unfold FtoRradix in |- *; rewrite Fopp_correct. apply Ropp_le_contravar; apply isMin_inv1 with (1 := H'); auto. intros f H'0 H'1. rewrite <- (Fopp_Fopp f). unfold FtoRradix in |- *; rewrite Fopp_correct; rewrite Fopp_correct. apply Ropp_le_contravar. elim H'. intros H'2 H'3; elim H'3; intros H'4 H'5; apply H'5; clear H'3. apply oppBounded; case H'; auto. rewrite <- (Ropp_involutive r). unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. Qed. Theorem MaxOppMin : forall (p : float) (r : R), isMax r p -> isMin (- r) (Fopp p). intros p r H'; split. apply oppBounded; case H'; auto. split. unfold FtoRradix in |- *; rewrite Fopp_correct. apply Ropp_le_contravar; apply isMax_inv1 with (1 := H'); auto. intros f H'0 H'1. rewrite <- (Fopp_Fopp f). unfold FtoRradix in |- *; repeat rewrite Fopp_correct. apply Ropp_le_contravar. rewrite <- (Fopp_correct radix f). elim H'. intros H'2 H'3; elim H'3; intros H'4 H'5; apply H'5; clear H'3. apply oppBounded; auto. rewrite <- (Ropp_involutive r). unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real. Qed. Theorem MinMax : forall (p : float) (r : R), isMin r p -> r <> p :>R -> isMax r (FNSucc b radix precision p). 
Zpower_nat: zarith.Theorem Zpower_exp x n m : n >= 0 -> m >= 0 -> x ^ (n + m) = x ^ n * x ^ m. Proof. Z.swap_greater. apply Z.pow_add_r. Qed.Section Powers_of_2. Definition shift_nat (n:nat) (z:positive) := nat_rect _ z (fun _ => xO) n. Definition shift_pos (n z:positive) := Pos.iter xO z n. Definition shift (n:Z) (z:positive) := match n with | Z0 => z | Zpos p => Pos.iter xO z p | Zneg p => z end. Definition two_power_nat (n:nat) := Zpos (shift_nat n 1). Definition two_power_pos (x:positive) := Zpos (shift_pos x 1). Definition two_p (x:Z) := match x with | Z0 => 1 | Zpos y => two_power_pos y | Zneg y => 0 end. Lemma shift_nat_equiv n p : shift_nat n p = Pos.shiftl_nat p n. Proof. reflexivity. Qed. Lemma shift_pos_equiv n p : shift_pos n p = Pos.shiftl p (Npos n). Proof. reflexivity. Qed. Lemma shift_equiv n p : 0<=n -> Zpos (shift n p) = Z.shiftl (Zpos p) n. Proof. destruct n. - trivial. - simpl; intros. now apply Pos.iter_swap_gen. - now destruct 1. Qed. Lemma two_power_nat_equiv n : two_power_nat n = 2 ^ (Z.of_nat n). Proof. induction n. - trivial. - now rewrite Nat2Z.inj_succ, Z.pow_succ_r, <- IHn by apply Nat2Z.is_nonneg. Qed. Lemma two_power_pos_equiv p : two_power_pos p = 2 ^ Zpos p. Proof. now apply Pos.iter_swap_gen. Qed. Lemma two_p_equiv x : two_p x = 2 ^ x. Proof. destruct x; trivial. apply two_power_pos_equiv. Qed. Lemma two_power_nat_S n : two_power_nat (S n) = 2 * two_power_nat n. Proof. reflexivity. Qed. Lemma shift_nat_plus n m x : shift_nat (n + m) x = shift_nat n (shift_nat m x). Proof. induction n; simpl; now f_equal. Qed. Theorem shift_nat_correct n x : Zpos (shift_nat n x) = Zpower_nat 2 n * Zpos x. Proof. induction n. - trivial. - now rewrite Zpower_nat_succ_r, <- Z.mul_assoc, <- IHn. Qed. Theorem two_power_nat_correct n : two_power_nat n = Zpower_nat 2 n. Proof. now rewrite two_power_nat_equiv, Zpower_nat_Z. Qed. Lemma shift_pos_nat p x : shift_pos p x = shift_nat (Pos.to_nat p) x. Proof. apply Pos2Nat.inj_iter. Qed. Lemma two_power_pos_nat p : two_power_pos p = two_power_nat (Pos.to_nat p). Proof. unfold two_power_pos. now rewrite shift_pos_nat. Qed. Theorem shift_pos_correct p x : Zpos (shift_pos p x) = Z.pow_pos 2 p * Zpos x. Proof. now rewrite shift_pos_nat, Zpower_pos_nat, shift_nat_correct. Qed. Theorem two_power_pos_correct x : two_power_pos x = Z.pow_pos 2 x. Proof. apply two_power_pos_equiv. Qed. Theorem two_power_pos_is_exp x y : two_power_pos (x + y) = two_power_pos x * two_power_pos y. 
Import EqNotations. From Perennial.Helpers Require Import Map. From Perennial.algebra Require Import auth_map liftable log_heap async.From Goose.github_com.mit_pdos.go_journal Require Import jrnl. From Perennial.program_logic Require Export ncinv. From Perennial.program_proof Require Import buf.buf_proof addr.addr_proof obj.obj_proof. From Perennial.program_proof Require jrnl.jrnl_proof. From Perennial.program_proof Require Import disk_prelude. From Perennial.goose_lang.lib Require Import slice.typed_slice. From Perennial.goose_lang.ffi Require Import disk_prelude. From Perennial.program_proof Require Import jrnl.sep_jrnl_invariant. Module mspec := jrnl.jrnl_proof.Section goose_lang. Context `{!jrnlG Œ£}. Context `{!heapGS Œ£}. Context (N:namespace). Implicit Types (l: loc) (Œ≥: jrnl_names) (Œ≥txn: gname). Implicit Types (obj: object). Theorem wp_Op__Begin' (l_txn: loc) Œ≥ dinit : {{{ is_txn l_txn Œ≥.(jrnl_txn_names) dinit ‚àó is_txn_system N Œ≥ }}} Begin #l_txn {{{ Œ≥txn Œ≥durable l, RET #l; "Hjrnl_mem" ‚à∑ is_jrnl_mem N l Œ≥ dinit Œ≥txn Œ≥durable ‚àó "Hdurable_frag" ‚à∑ map_ctx Œ≥durable (1/2) ‚à }}}. Proof. iIntros (Œ¶) "Hpre HŒ¶". iDestruct "Hpre" as "[#His_txn #Htxn_inv]". iApply wp_fupd. wp_apply (mspec.wp_jrnl_Begin with "His_txn"). iIntros (l) "Hjrnl". iMod (map_init ‚à ) as (Œ≥txn) "Hctx". iMod (map_init ‚à ) as (Œ≥durable) "[Hdurable Hdurable_frag]". iModIntro. iApply "HŒ¶". iFrame "Hdurable_frag". iExists ‚à , false. rewrite !fmap_empty. iFrame "Hctx". iFrame "‚àó#". auto with iFrame. Qed. Theorem wp_Op__Begin (l_txn: loc) Œ≥ dinit : {{{ is_txn l_txn Œ≥.(jrnl_txn_names) dinit ‚àó is_txn_system N Œ≥ }}} Begin #l_txn {{{ Œ≥txn l, RET #l; is_jrnl N l Œ≥ dinit Œ≥txn (Œª _, emp) }}}. Proof. iIntros (Œ¶) "Hpre HŒ¶". wp_apply (wp_Op__Begin' with "Hpre"). iIntros (???) "[? ?]". iNamed. iApply "HŒ¶". iExists Œ≥durable. iFrame. iExists ‚à . rewrite !big_sepM_empty. iFrame "‚àó#". auto with iFrame. Qed. Definition is_object l a obj: iProp Œ£ := ‚àÉ dirty, is_buf l a {| bufKind := objKind obj; bufData := objData obj; bufDirty := dirty |}. Theorem wp_Op__ReadBuf l Œ≥ dinit Œ≥txn Œ≥durable (a: addr) (sz: u64) obj : bufSz (objKind obj) = int.nat sz ‚Üí {{{ is_jrnl_mem N l Œ≥ dinit Œ≥txn Œ≥durable ‚àó jrnl_maps_to Œ≥txn a obj }}} Op__ReadBuf #l (addr2val a) #sz {{{ dirty (bufptr:loc), RET #bufptr; is_buf bufptr a (Build_buf _ (objData obj) dirty) ‚àó (‚àÄ (obj': bufDataT (objKind obj)) dirty', is_buf bufptr a (Build_buf _ obj' dirty') -‚àó ‚åúdirty' = true ‚à® (dirty' = dirty ‚àß obj' = objData obj)‚åù ==‚àó is_jrnl_mem N l Œ≥ dinit Œ≥txn Œ≥durable ‚àó jrnl_maps_to Œ≥txn a (existT (objKind obj) obj')) }}}. 
Require Import Prog. Require Import Pred. Require Import Hoare. Require Import Word. Require Import SepAuto. Require Import BasicProg. Require Import Log. Require Import Bool. Require Import Idempotent.Set Implicit Arguments.Definition inc_two T s0 s1 rx : prog T := v0 <- Read s0 ; Write s0 (v0 ^+ $1) ;; v1 <- Read s1 ; Write s1 (v1 ^+ $1) ;; rx tt.Theorem inc_two_ok: forall s0 s1, {< v0 v1, PRE s0 |-> v0 * s1 |-> v1 POST:r s0 |-> (v0 ^+ $1) * s1 |-> (v1 ^+ $1) CRASH s0 |-> v0 * s1 |-> v1 \/ s0 |-> (v0 ^+ $1) * s1 |-> v1 \/ s0 |-> (v0 ^+ $1) * s1 |-> (v1 ^+ $1) >} inc_two s0 s1. Proof. unfold inc_two. hoare. Qed. Definition log_inc_two T xp s0 s1 rx : prog T := LOG.begin xp ;; v0 <- LOG.read xp s0 ; ok0 <- LOG.write xp s0 (v0 ^+ $1) ; v1 <- LOG.read xp s1 ; ok1 <- LOG.write xp s1 (v1 ^+ $1) ; If (bool_dec (andb ok0 ok1) true) { LOG.commit xp ;; rx true } else { LOG.abort xp ;; rx false }. Theorem log_inc_two_ok: forall xp s0 s1, {< d v0 v1 F, PRE LOG.rep xp (NoTransaction d) * [[ (s0 |-> v0 * s1 |-> v1 * F)%pred d ]] POST:r [[ r = false ]] * LOG.rep xp (NoTransaction d) \/ [[ r = true ]] * exists d', LOG.rep xp (NoTransaction d') * [[ (s0 |-> (v0 ^+ $1) * s1 |-> (v1 ^+ $1) * F)%pred d' ]] CRASH LOG.log_intact xp d \/ exists d', LOG.log_intact xp d' * [[ (s0 |-> (v0 ^+ $1) * s1 |-> (v1 ^+ $1) * F)%pred d' ]] >} log_inc_two xp s0 s1. 
evts Hstep Hsender acct Hacct. destruct Hacct as [Hacct_owner Hacct_to]. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]. rewrite Hbalances. unfold a2v_upd_dec, a2v_upd_inc. subst sender. apply neq_beq_false in Hacct_owner. apply neq_beq_false in Hacct_to. rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)). rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_owner)). reflexivity. Qed. Theorem Property_restricted_owner_for_transferFrom: forall msg from to v, m_func msg = mc_transferFrom from to v -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> from /\ acct <> to -> st_balances (w_st C) acct = st_balances (w_st C') acct. Proof. intros msg from to v Hfunc env C C' evts Hstep Hsender acct Hacct. destruct Hacct as [Hacct_from Hacct_to]. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). - subst; simpl in *. destruct H2 as [_ [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]]. rewrite Hbalances. unfold a2v_upd_dec, a2v_upd_inc. subst sender. apply neq_beq_false in Hacct_from. apply neq_beq_false in Hacct_to. rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)). rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_from)). reflexivity. - subst; simpl in *; destruct H2 as [_ [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]]; rewrite Hbalances; unfold a2v_upd_dec, a2v_upd_inc; subst sender; apply neq_beq_false in Hacct_from; apply neq_beq_false in Hacct_to; rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)); rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_from)); reflexivity. Qed. Theorem Property_restricted_owner_for_approve: forall msg _spender _value, m_func msg = mc_approve _spender _value -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) -> forall spender, st_allowed (w_st C) (acct, spender) = st_allowed (w_st C') (acct, spender). Proof. intros msg _spender _value Hfunc env C C' evts Hstep Hsender acct Hacct spender. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H2 as [_ [_ [_ [_ [_ [_ [_ [_ [_ Hallowed]]]]]]]]]. rewrite Hallowed. rewrite <- Hsender in Hacct. assert (Hneq: beq (sender, _spender) (acct, spender) = false). { apply neq_beq_false. intros Heq. inversion Heq. apply Hacct; auto. } unfold aa2v_upd_2. rewrite (tmap_get_upd_ne (st_allowed (w_st C)) _ _ _value Hneq). reflexivity. Qed. Theorem Property_restricted_owner_for_increaseApproval: forall msg _spender _value, m_func msg = mc_increaseApproval _spender _value -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) -> forall spender, st_allowed (w_st C) (acct, spender) = st_allowed (w_st C') (acct, spender). 
? [ k l | k ]; inversion 1. apply list_One_Zero_inj in H1; destruct H1; subst k0 l1; auto. symmetry in H1; apply list_One_Zero_not in H1; tauto. apply list_One_Zero_not in H1; tauto. apply list_One_inj in H1; subst; auto. Qed. Fact list_bool_succ_nil l : list_bool_succ nil l -> l = Zero::nil. Proof. intros H; symmetry; revert H; apply list_bool_succ_fun. constructor 2 with (k := 0). Qed. Fact list_bool_succ_neq : forall l m, list_bool_succ l m -> l <> m. Proof. intros ? ? [ [|k] l | [|k] ]; discriminate. Qed. Fact list_bool_succ_neq_nil l : ~ list_bool_succ l nil. Proof. inversion 1. destruct k; discriminate. Qed.End list_bool_succ_props.Section list_bool_next. Let list_bool_next_def l : { m | list_bool_succ l m }. Proof. destruct (list_bool_choose_sym l) as [ (k & tl & H) | (k & H) ]; subst l. * exists (list_repeat Zero k ++ One :: tl); constructor. * exists (list_repeat Zero (S k)); constructor. Qed. Definition list_bool_next l := proj1_sig (list_bool_next_def l). Definition list_bool_next_spec l : list_bool_succ l (list_bool_next l). Proof. apply (@proj2_sig _ _). Qed. Fact list_bool_next_neq_nil l : list_bool_next l <> nil. Proof. intros H. generalize (list_bool_next_spec l). rewrite H. apply list_bool_succ_neq_nil. Qed. Fact iter_list_bool_next_nil l n : iter list_bool_next l n = nil -> n = 0 /\ l = nil. Proof. destruct n as [ | n ]. simpl; auto. replace (S n) with (n+1) by omega. rewrite iter_plus; simpl. intros H. apply list_bool_next_neq_nil in H. destruct H. Qed.End list_bool_next.Fact list_bool_succ_nat l m : list_bool_succ l m -> 1 + list_bool_nat l = list_bool_nat m. Proof. revert l m; intros ? ? [ k l | k ]; induction k; simpl in *; omega. Qed. Section list_bool_succ_rect. Variable (P : list bool -> Type) (HP0 : P nil) (HPS : forall l m, list_bool_succ l m -> P l -> P m). Let list_bool_succ_rec n : forall l, list_bool_nat l = n -> P l. Proof. induction n as [ | n IHn ]; intros l Hl. * generalize (list_bool_nat_ge_1 l); omega. * destruct (list_bool_choose l) as [ (k & tl & H) | ([ | k] & H) ]; subst l; [ generalize (in_lbs_0 k tl) | apply HP0 | generalize (in_lbs_1 k) ]; intros E; apply HPS with (1 := E), IHn; apply list_bool_succ_nat in E; omega. Qed. Theorem list_bool_succ_rect : forall l, P l. Proof. intro; apply list_bool_succ_rec with (1 := eq_refl). Qed.End list_bool_succ_rect. Theorem list_bool_next_total l : l <> nil -> { n | l = iter list_bool_next (Zero::nil) n }. 
destruct (M.get i a) eqn:Hgia. * destruct n. eexists. eexists. split. apply M.gss. split. constructor. reflexivity. split; intro; intros; destructAll. inv H7. inv H8. apply H6; auto. eapply H1 in H8; eauto. inv H8. rewrite H7 in H; inv H. inv H7. inv H8. apply H6; auto. eapply H1 in H8; eauto. inv H8. destruct (var_dec x0 k); subst. rewrite H7 in H; inv H. apply H6'. exists x0. eexists. eexists. eexists. split; auto. rewrite M.gso by auto. eauto. * eexists. eexists. split. apply M.gss. split. constructor. reflexivity. split; intro; intros; destructAll. inv H7; inv H8. apply H6; auto. inv H7; inv H8. apply H6; auto. + assert (H6'' := H6). rewrite M.gso in H6 by auto. apply H4 in H6. destructAll. { unfold update_ind_env. destruct v. destruct (cps.M.get ctor_ind_tag a) eqn:Hi0a. - destruct n0. destruct (var_dec i ctor_ind_tag). + subst. rewrite Hi0a in H6. inv H6. eexists. exists ((ctor_name, k, ctor_arity, ctor_ordinal) :: x1). split. rewrite M.gss; auto. split. constructor 2. auto. split. * intro; intros. destructAll. inv H10. inv H11. apply n; auto. apply H8. eexists; eexists; eexists. split; eauto. * intro; intros. destructAll. inv H10. inv H11. apply H6'. eexists. eexists. eexists. eexists. split. apply n. rewrite M.gss. reflexivity. eapply H9. eexists. eexists. eexists. split; eauto. + exists x0, x1. rewrite M.gso; auto. - exists x0, x1. rewrite M.gso. auto. intro; subst. rewrite H6 in Hi0a. inv Hi0a. } Qed. Corollary compute_domain_ienv: forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv) cenv (compute_ind_env cenv). Proof. assert ( forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv /\ correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv)) by apply compute_dc_ienv. simpl; intros. simpl in H. apply H in H0. destruct H0. auto. Qed. Corollary compute_correct_ienv: forall cenv, (fun cenv ienv => proper_cenv cenv -> correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv). Proof. assert ( forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv /\ correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv)) by apply compute_dc_ienv. simpl; intros. simpl in H. apply H in H0. destruct H0. auto. Qed. Definition correct_fenv_for_function (fenv:fun_env):= fun f (t:fun_tag) (ys:list L6.cps.var) (e:exp) => exists n l, M.get f fenv = Some (n, l) /\ n = N.of_nat (length l) /\ length l = length ys /\ NoDup l /\ Forall (fun i => 0 <= (Z.of_N i) < max_args)%Z l. SearchAbout fun_tag. Definition correct_fenv (fenv:fun_env) (fds:fundefs):= Forall_fundefs (correct_fenv_for_function fenv) fds. Theorem compute_correct_fenv: forall fds fenv, forall fenv', compute_fun_env_fds fds fenv' = fenv -> Forall_fundefs (correct_fenv_for_function fenv) fds. 
E_1 {r}.Arguments sum {r} x y.Arguments prod {r} x y.Arguments distinct_0_1 {r} _.Arguments sum_is_assoc {r} x y z.Arguments sum_is_comm {r} x y.Arguments sum_id_l {r} x.Arguments sum_inv_l_ex {r} x.Arguments prod_is_assoc {r} x y z.Arguments prod_id_l {r} x.Arguments prod_id_r {r} x.Arguments prod_sum_distrib_l {r} x y z.Arguments prod_sum_distrib_r {r} x y z.Notation "0" := E_0 : ring_scope.Notation "1" := E_1 : ring_scope.Notation "x + y" := (sum x y) (at level 50, left associativity) : ring_scope.Notation "{+}" := sum : ring_scope.Notation "x # y" := (prod x y) (at level 50, left associativity) : ring_scope.Notation "{#}" := prod : ring_scope.Open Scope ring_scope.Section Theorems. Variable r : Ring. Let E := E r. Definition nonzero (x : E) : Prop := x <> 0. Definition sum_is_id_l := Monoid.is_id_l E sum. Definition sum_is_id_r := Monoid.is_id_r E sum. Definition sum_is_id := Monoid.is_id E sum. Definition sum_abelian_group := Abelian_Group.abelian_group E 0 {+} sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex. Definition sum_group := Abelian_Group.op_group sum_abelian_group. Definition sum_monoid := Abelian_Group.op_monoid sum_abelian_group. Theorem sum_id_r : sum_is_id_r 0. Proof Abelian_Group.op_id_r sum_abelian_group. Theorem sum_id : sum_is_id 0. Proof Abelian_Group.op_id sum_abelian_group. Definition sum_is_inv_l := Abelian_Group.op_is_inv_l sum_abelian_group. Definition sum_is_inv_r := Abelian_Group.op_is_inv_r sum_abelian_group. Definition sum_is_inv := Abelian_Group.op_is_inv sum_abelian_group. Definition sum_has_inv_l := Abelian_Group.has_inv_l sum_abelian_group. Definition sum_has_inv_r := Abelian_Group.has_inv_r sum_abelian_group. Definition sum_has_inv := Abelian_Group.has_inv sum_abelian_group. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Abelian_Group.op_inv_r_ex sum_abelian_group. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Abelian_Group.op_id_l_uniq sum_abelian_group. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Abelian_Group.op_id_r_uniq sum_abelian_group. Theorem sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Abelian_Group.op_id_uniq sum_abelian_group. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Abelian_Group.op_inv_l_r_eq sum_abelian_group. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Abelian_Group.op_inv_sym sum_abelian_group. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Abelian_Group.op_inv_uniq sum_abelian_group. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Abelian_Group.op_inv_ex sum_abelian_group. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. Proof Abelian_Group.op_inv_uniq_ex sum_abelian_group. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Abelian_Group.op_intro_l sum_abelian_group. Theorem sum_intro_r : forall x y z : E, x = y -> x + z = y + z. 
H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem randomFunc_mem_preserves_coll : forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (randomFunc_mem _ _ RndR c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold randomFunc_mem in *. destruct (arrayLookup _ c0 (a, b0)). repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem F_randomFunc_wf : forall x y z, well_formed_comp (F_randomFunc x y z). intuition. unfold F_randomFunc. destruct (arrayLookup_f _ y (F x z)); wftac. Qed. Theorem randomFunc_mem_wf : forall (A B : Set) x y z (w : list (A * B)) v, well_formed_comp z -> well_formed_comp (randomFunc_mem x y z w v). intuition. unfold randomFunc_mem. destruct (arrayLookup x w v); intuition; wftac. Qed. Theorem A_randomFunc_F_spec : forall x, comp_spec (fun y1 y2 => funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (snd y1))) = funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (snd y2))) /\ (funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (snd y1))) = false -> y1 = y2)) (A (list (list (Bvector b) * Bvector b * Bvector c)) (list_EqDec (pair_EqDec (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)) (Bvector_EqDec c))) (F_randomFunc x) nil) (A (list (list (Bvector b) * Bvector b * Bvector c)) (list_EqDec (pair_EqDec (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)) (Bvector_EqDec c))) (fun (s : list (list (Bvector b) * Bvector b * Bvector c)) (a : list (Bvector b)) => randomFunc_mem (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)) (Bvector_EqDec c) ({ 0 , 1 }^c) s (a, F x a)) nil). 
high = sigma low k + sigma (S k) high. Proof. intros; induction k as [| k Hreck]. cut (low = 0%nat). intro; rewrite H1; unfold sigma; rewrite <- minus_n_n; rewrite <- minus_n_O; simpl; replace (high - 1)%nat with (pred high). apply (decomp_sum (fun k:nat => f k)). assumption. apply pred_of_minus. inversion H; reflexivity. cut ((low <= k)%nat \/ low = S k). intro; elim H1; intro. replace (sigma low (S k)) with (sigma low k + f (S k)). rewrite Rplus_assoc; replace (f (S k) + sigma (S (S k)) high) with (sigma (S k) high). apply Hreck. assumption. apply lt_trans with (S k); [ apply lt_n_Sn | assumption ]. unfold sigma; replace (high - S (S k))%nat with (pred (high - S k)). pattern (S k) at 3; replace (S k) with (S k + 0)%nat; [ idtac | ring ]. replace (sum_f_R0 (fun k0:nat => f (S (S k) + k0)) (pred (high - S k))) with (sum_f_R0 (fun k0:nat => f (S k + S k0)) (pred (high - S k))). apply (decomp_sum (fun i:nat => f (S k + i))). apply lt_minus_O_lt; assumption. apply sum_eq; intros; replace (S k + S i)%nat with (S (S k) + i)%nat. reflexivity. ring. replace (high - S (S k))%nat with (high - S k - 1)%nat. apply pred_of_minus. omega. unfold sigma; replace (S k - low)%nat with (S (k - low)). pattern (S k) at 1; replace (S k) with (low + S (k - low))%nat. symmetry ; apply (tech5 (fun i:nat => f (low + i))). omega. omega. rewrite <- H2; unfold sigma; rewrite <- minus_n_n; simpl; replace (high - S low)%nat with (pred (high - low)). replace (sum_f_R0 (fun k0:nat => f (S (low + k0))) (pred (high - low))) with (sum_f_R0 (fun k0:nat => f (low + S k0)) (pred (high - low))). apply (decomp_sum (fun k0:nat => f (low + k0))). apply lt_minus_O_lt. apply le_lt_trans with (S k); [ rewrite H2; apply le_n | assumption ]. apply sum_eq; intros; replace (S (low + i)) with (low + S i)%nat. reflexivity. ring. omega. inversion H; [ right; reflexivity | left; assumption ]. Qed. Theorem sigma_diff : forall low high k:nat, (low <= k)%nat -> (k < high)%nat -> sigma low high - sigma low k = sigma (S k) high. Proof. intros low high k H1 H2; symmetry ; rewrite (sigma_split H1 H2); ring. Qed. Theorem sigma_diff_neg : forall low high k:nat, (low <= k)%nat -> (k < high)%nat -> sigma low k - sigma low high = - sigma (S k) high. 
msg_refined_raft_net_invariant_do_generic_server'. eauto. eapply_prop msg_refined_raft_net_invariant_do_leader'. eauto. eapply msg_refined_raft_invariant_handle_input' with (P := P); auto. eauto. eauto. auto. eauto. eauto. eauto using in_app_or. auto. exact Hr1. simpl. break_if; intuition eauto. simpl. intros. break_if; intuition eauto. simpl. in_crush. auto. auto. simpl. break_if; eauto; congruence. simpl. intros. break_if; subst; repeat rewrite update_same by auto; repeat rewrite update_neq by auto; auto. simpl. in_crush. unfold add_ghost_msg in *. do_in_map. subst. do_in_app. intuition; try do_in_app; intuition. * left. apply in_app_iff. right. apply in_app_iff. left. simpl in *. rewrite map_map. apply in_map_iff. eexists; intuition; eauto. simpl in *. f_equal. f_equal. unfold write_ghost_log. simpl. find_apply_lem_hyp doGenericServer_log. find_apply_lem_hyp doLeader_log. repeat find_rewrite. auto. * left. apply in_app_iff. right. apply in_app_iff. right. simpl in *. rewrite map_map. apply in_map_iff. eexists; intuition; eauto. simpl in *. f_equal. f_equal. unfold write_ghost_log. simpl. find_apply_lem_hyp doGenericServer_log. find_apply_lem_hyp doLeader_log. repeat find_rewrite. auto. * right. simpl in *. rewrite map_map. apply in_map_iff. eexists; intuition; eauto. + match goal with | [ H : nwPackets ?net = _ |- _ {| nwPackets := ?ps ; nwState := ?st |} ] => assert (forall p, In p (nwPackets {| nwPackets := ps ; nwState := st |}) -> In p (nwPackets net)) by (intros; simpl in *; find_rewrite; in_crush) end. eapply_prop msg_refined_raft_net_invariant_state_same_packet_subset'; [|eauto|idtac|]; eauto. + match goal with | [ H : nwPackets ?net = _ |- _ {| nwPackets := ?ps ; nwState := ?st |} ] => assert (forall p, In p (nwPackets {| nwPackets := ps ; nwState := st |}) -> In p (nwPackets net)) by (intros; simpl in *; find_rewrite; in_crush) end. eapply_prop msg_refined_raft_net_invariant_state_same_packet_subset'; [|eauto|idtac|]; eauto. + auto. + eapply_prop msg_refined_raft_net_invariant_reboot'; eauto; intros; simpl in *; repeat break_if; intuition; subst; intuition eauto. * econstructor. eauto. eapply StepFailure_reboot; eauto. * destruct (nwState net h); auto. - eapply msg_refined_raft_invariant_handle_input'; eauto. eapply MRRIR_handleInput; eauto. - eapply msg_refined_raft_invariant_handle_message'; eauto. eapply MRRIR_handleMessage; eauto. - eapply_prop msg_refined_raft_net_invariant_do_leader'; eauto. eapply MRRIR_doLeader; eauto. - eapply_prop msg_refined_raft_net_invariant_do_generic_server'; eauto. eapply MRRIR_doGenericServer; eauto. Qed. Ltac workhorse := try match goal with | [ |- mkNetwork _ _ = mkNetwork _ _ ] => f_equal end; try match goal with | [ |- (fun _ => _) = (fun _ => _) ] => apply functional_extensionality; intros end; repeat break_match; repeat match goal with | [ H : (_, _) = (_, _) |- _ ] => invc H end; repeat (simpl in *; subst); repeat rewrite map_app; repeat rewrite map_map. Notation mgv_deghost := (@mgv_deghost _ _ ghost_log_params). Theorem simulation_1 : forall net, msg_refined_raft_intermediate_reachable net -> refined_raft_intermediate_reachable (mgv_deghost net). 
From Huffman Require Export OrderedCover. From Huffman Require Export WeightTree. Require Import ArithRing. From Huffman Require Export Ordered. From Huffman Require Export Prod2List. Section HeightPred. Variable A : Type. Variable f : A -> nat. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Inductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop := | height_pred_nil : forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t | height_pred_node : forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A) (l1 l2 : list (btree A)), height_pred (S n) ln1 l1 t1 -> height_pred (S n) ln2 l2 t2 -> height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2). Hint Resolve height_pred_nil height_pred_node : core. Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t. Proof using. intros n ln t l H; elim H; simpl in |- *; auto. Qed. Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil. 
Fact mma_div_cst_progress a v st : v#>s = a*k -> st = (q,v[0/s][(a+(v#>d))/d]) -> (i, mma_div_cst) // (i,v) -+> st. Proof using Hsd Hk. intros H1 H2; subst st; apply mma_div_cst_spec with (1 := H1); auto. Qed. End mma_div_cst. Notation DIV_CST‚Çê := mma_div_cst. Hint Rewrite mma_div_cst_length : length_db. Section mma_div_branch. Variable (x z : pos n) (Hxz : x <> z) (k i j : nat). Let p := 6+4*k+i. Let q := 13+7*k+i. Definition mma_div_branch := MOD_CST‚Çê x z p q k i ++ DIV_CST‚Çê z x k p ++ JUMP‚Çê j z ++ TRANSFERT‚Çê z x q. Fact mma_div_branch_length : length mma_div_branch = 16+7*k. Proof. unfold mma_div_branch; rew length; lia. Qed. Fact mma_div_branch_0_progress a v st : v#>z = 0 -> 0 < k -> v#>x = a*k -> st = (j,v[a/x]) -> (i, mma_div_branch) // (i,v) -+> st. Proof using Hxz. intros H1 H2 H3 ->; unfold mma_div_branch. apply sss_progress_trans with (st2 := (p,v[0/x][(a*k)/z])). 1:{ apply subcode_sss_progress with (P := (i,MOD_CST‚Çê x z p q k i)); auto. apply mma_mod_cst_divides_progress with a; auto. do 2 f_equal; lia. } apply sss_progress_trans with (st2 := (11+7*k+i,v[a/x])). 1:{ apply subcode_sss_progress with (P := (p,DIV_CST‚Çê z x k p)); auto. apply mma_div_cst_progress with a; auto; rew vec. unfold p. f_equal; try lia. apply vec_pos_ext; intros y. dest y x; dest y z. } 1:{ apply subcode_sss_progress with (P := (11+7*k+i,JUMP‚Çê j z)); auto. apply mma_jump_progress; auto. } Qed. Fact mma_div_branch_1_progress v st : v#>z = 0 -> 0 < k -> ~ divides k (v#>x) -> st = (16+7*k+i,v) -> (i, mma_div_branch) // (i,v) -+> st. Proof using Hxz. intros H1 H2 H3 ->; unfold mma_div_branch. destruct (div_full (v#>x) k) as (a & r & H5 & H6). assert (0 < r < k) as H7. 1:{ split; destruct r; try lia. destruct H3; exists a; lia. } apply sss_progress_trans with (st2 := (q,v[0/x][(v#>x)/z])). 1:{ apply subcode_sss_progress with (P := (i,MOD_CST‚Çê x z p q k i)); auto. apply mma_mod_cst_not_divides_progress with (3 := H5); auto. do 2 f_equal; lia. } 1:{ apply subcode_sss_progress with (P := (q,TRANSFERT‚Çê z x q)); auto. apply mma_transfert_progress; auto. f_equal; rew vec. apply vec_pos_ext; intros y. dest y x; dest y z. } Qed. End mma_div_branch. Section mma_loop. Variables (x : pos n) (i : nat). Definition mma_loop := JUMP‚Çê i x. Fact mma_loop_loop v : (i,mma_loop) // (i,v) -+> (i,v). Proof. apply mma_jump_progress; auto. Qed. Theorem mma_loop_spec v : ~ (i,mma_loop) // (i,v) ‚Üì. 
: Values.val) (pc : RTL.node) (rs : RTL.regset) (s : list RTL.stackframe) (vres : Values.val) (m : mem) (R1 : HTL.state), match_states (RTL.Returnstate (RTL.Stackframe res0 f sp pc rs :: s) vres m) R1 -> exists R2 : HTL.state, Smallstep.plus HTL.step tge R1 Events.E0 R2 /\ match_states (RTL.State s f sp pc (Registers.Regmap.set res0 vres rs) m) R2. Proof. intros res0 f sp pc rs s vres m R1 MSTATE. inversion MSTATE. inversion MF. Qed. #[local] Hint Resolve transl_returnstate_correct : htlproof. Lemma option_inv : forall A x y, @Some A x = Some y -> x = y. Proof. intros. inversion H. trivial. Qed. Lemma main_tprog_internal : forall b, Globalenvs.Genv.find_symbol tge tprog.(AST.prog_main) = Some b -> exists f, Genv.find_funct_ptr (Genv.globalenv tprog) b = Some (AST.Internal f). Proof. intros. destruct TRANSL. unfold main_is_internal in H1. repeat (unfold_match H1). replace b with b0. exploit function_ptr_translated; eauto. intros [tf [A B]]. unfold transl_fundef, AST.transf_partial_fundef, Errors.bind in B. unfold_match B. inv B. econstructor. apply A. apply option_inv. rewrite <- Heqo. rewrite <- H. rewrite symbols_preserved. replace (AST.prog_main tprog) with (AST.prog_main prog). trivial. symmetry; eapply Linking.match_program_main; eauto. Qed. Lemma transl_initial_states : forall s1 : Smallstep.state (RTL.semantics prog), Smallstep.initial_state (RTL.semantics prog) s1 -> exists s2 : Smallstep.state (HTL.semantics tprog), Smallstep.initial_state (HTL.semantics tprog) s2 /\ match_states s1 s2. Proof. induction 1. destruct TRANSL. unfold main_is_internal in H4. repeat (unfold_match H4). assert (f = AST.Internal f1). apply option_inv. rewrite <- Heqo0. rewrite <- H1. replace b with b0. auto. apply option_inv. rewrite <- H0. rewrite <- Heqo. trivial. exploit function_ptr_translated; eauto. intros [tf [A B]]. unfold transl_fundef, Errors.bind in B. unfold AST.transf_partial_fundef, Errors.bind in B. repeat (unfold_match B). inversion B. subst. exploit main_tprog_internal; eauto; intros. rewrite symbols_preserved. replace (AST.prog_main tprog) with (AST.prog_main prog). apply Heqo. symmetry; eapply Linking.match_program_main; eauto. inversion H5. econstructor; split. econstructor. apply (Genv.init_mem_transf_partial TRANSL'); eauto. replace (AST.prog_main tprog) with (AST.prog_main prog). rewrite symbols_preserved; eauto. symmetry; eapply Linking.match_program_main; eauto. apply H6. constructor. apply transl_module_correct. assert (Some (AST.Internal x) = Some (AST.Internal m)). replace (AST.fundef HTL.module) with (HTL.fundef). rewrite <- H6. setoid_rewrite <- A. trivial. trivial. inv H7. assumption. Qed. #[local] Hint Resolve transl_initial_states : htlproof. Lemma transl_final_states : forall (s1 : Smallstep.state (RTL.semantics prog)) (s2 : Smallstep.state (HTL.semantics tprog)) (r : Integers.Int.int), match_states s1 s2 -> Smallstep.final_state (RTL.semantics prog) s1 r -> Smallstep.final_state (HTL.semantics tprog) s2 r. Proof. intros. inv H0. inv H. inv H4. invert MF. constructor. reflexivity. Qed. #[local] Hint Resolve transl_final_states : htlproof. Theorem transl_step_correct: forall (S1 : RTL.state) t S2, RTL.step ge S1 t S2 -> forall (R1 : HTL.state), match_states S1 R1 -> exists R2, Smallstep.plus HTL.step tge R1 t R2 /\ match_states S2 R2. 
p q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q)); auto. apply spminusf_plusTerm_r with (1 := cs); auto. apply canonical_spminusf with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply spminusf_plusTerm_z; auto. exists (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (plusTerm (A:=A) plusA (n:=n) a c) b nZb (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p r) q); split; auto. change (reduceplus Q (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (pX a p) (pX c r)) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (plusTerm (A:=A) plusA (n:=n) a c) b nZb (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p r) q)) in |- *. rewrite <- pluspf_inv3b_eq with (1 := os) (a := a) (b := c) (p := p) (q := r); auto. apply reduce_imp_reduceplus. apply reducetop with (b := b) (nZb := nZb) (q := q); auto. change (reduceplus Q (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) (pX c r)) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (plusTerm (A:=A) plusA (n:=n) a c) b nZb (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p r) q)) in |- *. rewrite <- pluspf_inv2_eqa with (1 := os) (a := c) (p := spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) (q := r); auto. apply reduce_imp_reduceplus. apply reducetop with (b := b) (nZb := nZb) (q := q); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q)); auto. apply spminusf_plusTerm_r with (1 := cs); auto. apply canonical_spminusf with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply spminusf_plusTerm with (1 := cs); auto. apply canonical_spminusf_full_t with (1 := cs); auto. Qed. Theorem one_plus_reduceplus : forall (Q : list (poly A0 eqA ltM)) (p1 p2 : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p1 p2 -> forall r : list (Term A n), canonical A0 eqA ltM p1 -> canonical A0 eqA ltM r -> exists s : list (Term A n), reduceplus Q (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p1 r) s /\ reduceplus Q (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p2 r) s. 
x... now apply He, Rgt_not_eq. now rewrite <- d_eq, Y. rewrite u_eq, round_UP_small_pos with (ex:=e); trivial. 2: now apply He, Rgt_not_eq. rewrite ln_beta_bpow. ring_simplify (fexp e + 1 - 1)%Z. replace (fexp (fexp e)) with (fexp e). case exists_NE_; intros V. contradict V; rewrite Even_beta; discriminate. rewrite (proj2 (V e)); omega. apply sym_eq, valid_exp; omega. Qed.Lemma Fm: generic_format beta fexpe m. case (d_ge_0); intros Y.destruct m_eq as (g,(Hg1,Hg2)); trivial. apply generic_format_F2R' with g. now apply sym_eq. intros H; unfold canonic_exp; rewrite Hg2. rewrite ln_beta_m; trivial. rewrite <- Fexp_d; trivial. rewrite Cd. unfold canonic_exp. generalize (fexpe_fexp (ln_beta beta (F2R d))). omega.destruct m_eq_0 as (g,(Hg1,Hg2)); trivial. apply generic_format_F2R' with g. assumption. intros H; unfold canonic_exp; rewrite Hg2. rewrite ln_beta_m_0; try assumption. apply Zle_trans with (1:=fexpe_fexp _). assert (fexp (ln_beta beta (F2R u)-1) < fexp (ln_beta beta (F2R u))+1)%Z;[idtac|omega]. now apply fexp_m_eq_0. Qed.Lemma Zm: exists g : float beta, F2R g = m /\ canonic beta fexpe g /\ Zeven (Fnum g) = true. Proof with auto with typeclass_instances. case (d_ge_0); intros Y.destruct m_eq as (g,(Hg1,Hg2)); trivial. apply exists_even_fexp_lt. exists g; split; trivial. rewrite Hg2. rewrite ln_beta_m; trivial. rewrite <- Fexp_d; trivial. rewrite Cd. unfold canonic_exp. generalize (fexpe_fexp (ln_beta beta (F2R d))). omega.destruct m_eq_0 as (g,(Hg1,Hg2)); trivial. apply exists_even_fexp_lt. exists g; split; trivial. rewrite Hg2. rewrite ln_beta_m_0; trivial. apply Zle_lt_trans with (1:=fexpe_fexp _). assert (fexp (ln_beta beta (F2R u)-1) < fexp (ln_beta beta (F2R u))+1)%Z;[idtac|omega]. now apply fexp_m_eq_0. Qed. Lemma DN_odd_d_aux: forall z, (F2R d<= z< F2R u)%R -> Rnd_DN_pt (generic_format beta fexp) z (F2R d). Proof with auto with typeclass_instances. intros z Hz1. replace (F2R d) with (round beta fexp Zfloor z). apply round_DN_pt... case (Rnd_DN_UP_pt_split _ _ _ _ Hd Hu (round beta fexp Zfloor z)). apply generic_format_round... intros Y; apply Rle_antisym; trivial. apply round_DN_pt... apply Hd. apply Hz1. intros Y; absurd (z < z)%R. auto with real. apply Rlt_le_trans with (1:=proj2 Hz1), Rle_trans with (1:=Y). apply round_DN_pt... Qed.Lemma UP_odd_d_aux: forall z, (F2R d< z <= F2R u)%R -> Rnd_UP_pt (generic_format beta fexp) z (F2R u). Proof with auto with typeclass_instances. intros z Hz1. replace (F2R u) with (round beta fexp Zceil z). apply round_UP_pt... case (Rnd_DN_UP_pt_split _ _ _ _ Hd Hu (round beta fexp Zceil z)). apply generic_format_round... intros Y; absurd (z < z)%R. auto with real. apply Rle_lt_trans with (2:=proj1 Hz1), Rle_trans with (2:=Y). apply round_UP_pt... intros Y; apply Rle_antisym; trivial. apply round_UP_pt... apply Hu. apply Hz1. Qed. Theorem round_odd_prop_pos: round beta fexp (Znearest choice) (round beta fexpe Zrnd_odd x) = round beta fexp (Znearest choice) x. 
Set Warnings "-notation-overridden,-parsing". Require Export Logic. Require Coq.omega.Omega. Inductive ev : nat -> Prop := | ev_0 : ev 0 | ev_SS : forall n : nat, ev n -> ev (S (S n)).Fail Inductive wrong_ev (n : nat) : Prop := | wrong_ev_0 : wrong_ev 0 | wrong_ev_SS : forall n, wrong_ev n -> wrong_ev (S (S n)). Theorem ev_4 : ev 4. Proof. apply ev_SS. apply ev_SS. apply ev_0. Qed.Theorem ev_4' : ev 4. Proof. apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.Theorem ev_plus4 : forall n, ev n -> ev (4 + n). Proof. intros n. simpl. intros Hn. apply ev_SS. apply ev_SS. apply Hn. Qed. Theorem ev_double : forall n, ev (double n). Proof. Admitted. Theorem ev_minus2 : forall n, ev n -> ev (pred (pred n)). Proof. intros n E. inversion E as [| n' E']. - simpl. apply ev_0. - simpl. apply E'. Qed.Theorem ev_minus2' : forall n, ev n -> ev (pred (pred n)). Proof. intros n E. destruct E as [| n' E']. - simpl. apply ev_0. - simpl. apply E'. Qed.Theorem evSS_ev : forall n, ev (S (S n)) -> ev n.Proof. intros n E. destruct E as [| n' E']. - Abort.Theorem evSS_ev : forall n, ev (S (S n)) -> ev n. Proof. intros n E. inversion E as [| n' E']. apply E'. Qed.Theorem one_not_even : ~ ev 1. Proof. intros H. inversion H. Qed. Theorem SSSSev__even : forall n, ev (S (S (S (S n)))) -> ev n. Proof. Admitted.Theorem even5_nonsense : ev 5 -> 2 + 2 = 9. Proof. Admitted. Lemma ev_even_firsttry : forall n, ev n -> exists k, n = double k. Proof. intros n E. inversion E as [| n' E']. - exists 0. reflexivity. - simpl. assert (I : (exists k', n' = double k') -> (exists k, S (S n') = double k)). { intros [k' Hk']. rewrite Hk'. exists (S k'). reflexivity. } apply I. Admitted. Lemma ev_even : forall n, ev n -> exists k, n = double k. Proof. intros n E. induction E as [|n' E' IH]. - exists 0. reflexivity. - destruct IH as [k' Hk']. rewrite Hk'. exists (S k'). reflexivity. Qed.Theorem ev_even_iff : forall n, ev n <-> exists k, n = double k. Proof. intros n. split. - apply ev_even. - intros [k Hk]. rewrite Hk. apply ev_double. Qed. Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m). 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.SpecLemmas.Require Import VerdiRaft.TermSanityInterface. Require Import VerdiRaft.SortedInterface.Section SortedProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {tsi : term_sanity_interface}. Theorem logs_sorted_init : raft_net_invariant_init logs_sorted. Proof using. unfold raft_net_invariant_init, logs_sorted, logs_sorted_host, logs_sorted_nw, packets_gt_prevIndex, packets_ge_prevTerm in *. intuition; simpl in *; intuition. Qed. Theorem handleClientRequest_packets : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> ps = []. Proof using. intros. find_apply_lem_hyp handleClientRequest_log. intuition. Qed. Theorem logs_sorted_nw_packets_unchanged : forall net ps' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_packets_unchanged : forall net ps' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_ge_prevTerm_packets_unchanged : forall net ps' st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. unfold packets_ge_prevTerm in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Lemma handleClientRequest_logs_sorted : forall h client id c out st l net, handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st). Proof using tsi. unfold logs_sorted_host. intros. find_apply_lem_hyp handleClientRequest_log. intuition. + repeat find_rewrite. eauto. + find_apply_lem_hyp no_entries_past_current_term_invariant. break_exists; intuition; repeat find_rewrite. simpl. intuition eauto. * find_eapply_lem_hyp maxIndex_is_max; eauto. lia. * unfold no_entries_past_current_term, no_entries_past_current_term_host in *. intuition. simpl in *. find_apply_hyp_hyp. lia. Qed. Theorem logs_sorted_client_request : raft_net_invariant_client_request logs_sorted. 
m i a). Derive SizeMonotonicSuchThatOpt for (fun i => bind m i a). Derive GenSizedSuchThatSizeMonotonicOpt for (fun x => bind m x a). Instance adm_st m a : SuchThatCorrect (fun x => bind m x a) (genST (fun x => bind m x a)). Admitted.Instance bind_dec m x v : Dec (bind m x v) := {| dec := _ |}. Proof. move: x v. induction m => x v. - right => contra. inversion contra. - destruct a as [x' v']. destruct (eq_dec_id x x') as [[Eq | Neq]]. + destruct (eq_dec_ty v v') as [[EqV | NeqV]]. * subst; left ; constructor; eauto. * subst; right => Contra. inversion Contra; subst; eauto. + subst; specialize (IHm x v). destruct IHm as [L | R]. * left; constructor; eauto. * right => Contra; inversion Contra; subst; eauto. Defined.Reserved Notation "Gamma '|-' t '\typ' T" (at level 40).Inductive has_type : context -> trm -> ty -> Prop := | T_Var : forall Gamma i T, bind Gamma i T -> Gamma |- tvar i \typ T | T_Abs : forall Gamma i T11 T12 t12, cons (i, T11) Gamma |- t12 \typ T12 -> Gamma |- tabs i T11 t12 \typ TArrow T11 T12 | T_App : forall T11 T12 Gamma t1 t2, Gamma |- t1 \typ TArrow T11 T12 -> Gamma |- t2 \typ T11 -> Gamma |- tapp t1 t2 \typ T12 | T_True : forall Gamma, Gamma |- ttrue \typ TBool | T_False : forall Gamma, Gamma |- tfalse \typ TBool | T_If : forall t1 t2 t3 T Gamma, Gamma |- t1 \typ TBool -> Gamma |- t2 \typ T -> Gamma |- t3 \typ T -> Gamma |- tif t1 t2 t3 \typ Twhere "Gamma '|-' t '\typ' T" := (has_type Gamma t T).Hint Constructors has_type.Derive ArbitrarySizedSuchThat for (fun tm => has_type Gamma tm ty). Derive SizedProofEqs for (fun tm => value tm). Derive SizeMonotonicSuchThatOpt for (fun tm => value tm). Derive GenSizedSuchThatCorrect for (fun tm => value tm). Derive GenSizedSuchThatSizeMonotonicOpt for (fun tm => value tm).Instance has_type_gen_correct0 Gamma T : SuchThatCorrect (fun t => has_type Gamma t T) (@arbitraryST _ (fun t => has_type Gamma t T) _). Admitted.Fixpoint lookup (Gamma : context) (i : id) : option ty := match Gamma with | nil => None | cons (i',T) Gamma' => if beq_id i i' then Some T else lookup Gamma' i end. Theorem beq_id_true_iff : forall x y : id, beq_id x y = true <-> x = y. 
auto. Qed. Theorem all_fun_name_append: forall B2 B1, all_fun_name (fundefs_append B1 B2) = all_fun_name B1 ++ all_fun_name B2. Proof. induction B1; auto. simpl. rewrite IHB1. auto. Qed. Ltac normalize_ctx := match goal with | [H: context[rename_all_ns _ (_ |[ _ ]|)] |- _] => rewrite (proj1 (rename_all_ns_app_ctx _ _)) in H | [H: context[rename_all_fun_ns _ (_ <[ _ ]>)] |- _] => rewrite (proj2 (rename_all_ns_app_ctx _ _)) in H | [|- context[rename_all_ns _ (_ |[ _ ]|)]] => rewrite (proj1 (rename_all_ns_app_ctx _ _)) | [|- context[rename_all_fun_ns _ (_ <[ _ ]>)]] => rewrite (proj2 (rename_all_ns_app_ctx _ _)) | [H: context[rename_all_fun_ns _ (fundefs_append _ _)] |- _] => rewrite rename_all_ns_fundefs_append in H | [|- context[rename_all_fun_ns _ (fundefs_append _ _)]] => rewrite rename_all_ns_fundefs_append | [H: context[rename_all_ctx_ns _ (comp_ctx_f _ _)] |- _] => rewrite (proj1 (rename_all_ctx_ns_comp_ctx _ _)) in H | [|- context[rename_all_ctx_ns _ (comp_ctx_f _ _)]] => rewrite (proj1 (rename_all_ctx_ns_comp_ctx _ _)) | [H: context[rename_all_fun_ctx_ns _ (comp_f_ctx_f _ _)] |- _] => rewrite (proj2 (rename_all_ctx_ns_comp_ctx _ _)) in H | [|- context[rename_all_fun_ctx_ns _ (comp_f_ctx_f _ _)]] => rewrite (proj2 (rename_all_ctx_ns_comp_ctx _ _)) | [H: context[ inlined_ctx_f (comp_ctx_f _ _ ) _ ] |- _] => rewrite (proj1 (inlined_comp_ctx)) in H | [|-context[ inlined_ctx_f (comp_ctx_f _ _) _]] => rewrite (proj1 (inlined_comp_ctx)) | [H: context[ inlined_fundefs_ctx_f (comp_f_ctx_f _ _) _] |- _] => rewrite (proj2 (inlined_comp_ctx)) in H | [|-context[ inlined_fundefs_ctx_f (comp_f_ctx_f _ _) _]] => rewrite (proj2 (inlined_comp_ctx)) | [H: context[ inlined_fundefs_f (fundefs_append _ _) _] |- _] => rewrite inlined_fundefs_append in H | [|-context[ inlined_fundefs_f (fundefs_append _ _) _]] => rewrite inlined_fundefs_append end. Definition closed_fundefs := fun f => Empty_set var <--> occurs_free_fundefs f. Corollary closed_app_ctx: forall e c, closed_exp (c |[ e ]|) -> closed_ctx c. Proof. intros. assert (Hc := occurs_free_included_ctx e c). apply Included_Empty_set_l. unfold closed_exp in H. rewrite H in Hc; eauto. Qed. Theorem not_free_dead_or_bound e: (Complement _ (occurs_free e)) \subset ((dead_var e) :|: (bound_var e)). Proof. intros. intro. intro. apply not_free_bound_or_not_occur in H. destruct H; auto. Qed. Theorem not_bound_dead_or_free e : (Complement _ (bound_var e)) \subset ((dead_var e) :|: (occurs_free e)). Proof. intros. intro; intro. assert (He := Decidable_occurs_free e). inv He. specialize (Dec x). inv Dec; auto. apply not_free_dead_or_bound in H0. inv H0; auto. exfalso. auto. Qed. Theorem name_in_bound_var_fundefs_ctx cf : names_in_fundefs_ctx cf \subset bound_var_fundefs_ctx cf. Proof. induction cf; simpl; normalize_bound_var_ctx; auto with Ensembles_DB. intro. intro. inv H. auto. apply name_in_fundefs_bound_var_fundefs in H0. auto. Qed. Theorem not_free_bound_or_not_occur_ctx v: (forall c : exp_ctx, ~ occurs_free_ctx c v -> num_occur_ec c v 0 \/ bound_var_ctx c v) /\ (forall cf : fundefs_ctx, ~ occurs_free_fundefs_ctx cf v -> num_occur_fdc cf v 0 \/ bound_var_fundefs_ctx cf v). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.CompFold.Open Scope list_scope.Section DistSingle. Variable A B : Set. Hypothesis B_EqDec : EqDec B. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A1 : Comp (A * A_State). Variable A2 : A_State -> B -> Comp bool. Definition DistSingle_G(c : A -> Comp B) := [a, s_A] <-$2 A1; b <-$ c a; A2 s_A b. Definition DistSingle_Adv := | Pr[DistSingle_G c1] - Pr[DistSingle_G c2] |.End DistSingle.Section ListHybrid. Variable A B State : Set. Variable defA : A. Variable c1 c2 : A -> Comp B. Hypothesis c1_wf : forall a, well_formed_comp (c1 a). Hypothesis c2_wf : forall a, well_formed_comp (c2 a). Hypothesis A_EqDec : EqDec A. Hypothesis B_EqDec : EqDec B. Hypothesis State_EqDec : EqDec State. Variable A1 : Comp ((list A) * State). Variable A2 : State -> list B -> Comp bool. Variable maxA : nat. Hypothesis maxA_correct : forall ls s_A, In (ls, s_A) (getSupport A1) -> (length ls <= maxA)%nat. Definition ListHybrid_G (c : A -> Comp B) := [lsA, s_A] <-$2 A1; lsB <-$ compMap _ c lsA; A2 s_A lsB. Definition ListHybrid_Advantage := | Pr[ListHybrid_G c1] - Pr[ListHybrid_G c2] |. Definition G_hybrid i := [lsA, s_A] <-$2 A1; lsA1 <- firstn i lsA; lsA2 <- skipn i lsA; lsB1 <-$ compMap _ c1 lsA1; lsB2 <-$ compMap _ c2 lsA2; A2 s_A (lsB1 ++ lsB2). Theorem G_2_hybrid_eq : Pr[ListHybrid_G c2] == Pr[G_hybrid 0]. unfold ListHybrid_G, G_hybrid. comp_skip. comp_simp. eapply comp_spec_eq_impl_eq. simpl. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem skipn_ge_nil : forall (A : Type)(ls : list A)(n : nat), n >= length ls -> skipn n ls = nil. induction ls; destruct n; intuition; simpl in *. omega. eapply IHls. omega. Qed. Theorem G_1_hybrid_eq : Pr[ListHybrid_G c1] == Pr[G_hybrid maxA]. 
: Stream A), Q (Cons a l) -> Release P Q l -> Release P Q (Cons a l). Inductive Eventually (P : LTLProp A) : LTLProp A := | EventuallyHere : forall (a : A) (l : Stream A), P (Cons a l) -> Eventually P (Cons a l) | EventuallyLater : forall (a : A) (l : Stream A), Eventually P l -> Eventually P (Cons a l). CoInductive Always (P : LTLProp A) : LTLProp A := | AlwaysIntro : forall (a : A) (l : Stream A), P (Cons a l) -> Always P l -> Always P (Cons a l). Hint Unfold And Or Not : ltl. Hint Constructors Atomic Next Until Release Eventually Always : ltl. Definition equiv (P Q : LTLProp A) : Prop := forall (l : Stream A), P l <-> Q l. Notation "P ~= Q" := (equiv P Q) (at level 90). Ltac ltl_simpl := unfold equiv; try (split; intros); repeat match goal with | [ |- Next _ (Cons _ _) ] => constructor | [ |- Next _ ?l ] => destruct l; constructor | [ |- Not _ _ ] => let Hcontra := fresh "Hcontra" in intros Hcontra | [ H : And _ _ _ |- _ ] => destruct H | [ H : Or _ _ _ |- _ ] => inversion H; clear H | [ H : Next _ _ |- _ ] => inversion H; subst; clear H | [ H : Always _ (Cons _ _) |- _ ] => inversion H; subst; clear H end; simpl; auto with ltl. Lemma Not_inverse : forall (l : Stream A) (P Q : LTLProp A), (Not P l -> Q l) -> (Not Q l -> P l). Proof. intros; unfold Not in *; tauto. Qed. Lemma Not_inverse' : forall (l : Stream A) (P Q : LTLProp A), (P l -> Not Q l) -> (Q l -> Not P l). Proof. intros; unfold Not in *; tauto. Qed. Section Immediate. Theorem Always_Immediate : forall (P : LTLProp A), Always P ~= And P (Next (Always P)). Proof. ltl_simpl; unfold And. inversion H; subst; intuition. Qed. Theorem Eventually_Immediate : forall (P : LTLProp A), Eventually P ~= Or P (Next (Eventually P)). Proof. ltl_simpl; unfold Or in *. + inversion H; subst; intuition. + destruct l; constructor; auto. Qed. Theorem Until_Immediate : forall (P Q : LTLProp A), Until P Q ~= Or Q (And P (Next (Until P Q))). 
auto. rewrite S_INR. apply Rlt_dichotomy_converse; left. apply Rle_lt_0_plus_1. apply pos_INR. intros n' H' m; case m. intros H'0; Contradict H'0; auto. rewrite S_INR. apply Rlt_dichotomy_converse; right. red in |- *; apply Rle_lt_0_plus_1. apply pos_INR. intros m' H'0. rewrite (H' m'); auto. repeat rewrite S_INR in H'0. apply Rplus_eq_reg_l with (r := 1%R); repeat rewrite (Rplus_comm 1); auto with real. Qed. Theorem Rle_INR : forall x y : nat, x <= y -> (INR x <= INR y)%R. intros x y H; repeat rewrite INR_IZR_INZ. apply Rle_IZR; auto with zarith. Qed. Hint Resolve Rle_INR: real. Theorem le_Rle : forall n m : nat, (INR n <= INR m)%R -> n <= m. intros n m H'; case H'; auto. intros H'0; apply lt_le_weak; apply lt_Rlt; auto. intros H'0; rewrite <- (INR_inv _ _ H'0); auto with arith. Qed. Theorem Rmult_IZR : forall z t : Z, IZR (z * t) = (IZR z * IZR t)%R. intros z t; case z; case t; simpl in |- *; auto with real; unfold IZR; intros t1 z1; repeat rewrite <- INR_IPR. - rewrite nat_of_P_mult_morphism; auto with real. - rewrite nat_of_P_mult_morphism; auto with real. rewrite Rmult_comm. rewrite Ropp_mult_distr_l_reverse; auto with real. apply Ropp_eq_compat; rewrite mult_comm; auto with real. - rewrite nat_of_P_mult_morphism; auto with real. rewrite Ropp_mult_distr_l_reverse; auto with real. - rewrite nat_of_P_mult_morphism; auto with real. rewrite Rmult_opp_opp; auto with real. Qed. Theorem absolu_Zs : forall z : Z, (0 <= z)%Z -> Zabs_nat (Zsucc z) = S (Zabs_nat z). intros z; case z. 3: intros p H'; Contradict H'; auto with zarith. replace (Zsucc 0) with (Z_of_nat 1). intros H'; rewrite absolu_INR; simpl in |- *; auto. simpl in |- *; auto. intros p H'; rewrite <- Zpos_succ_morphism; simpl in |- *; auto with zarith. unfold nat_of_P in |- *; rewrite Pmult_nat_succ_morphism; auto. Qed. Hint Resolve Zlt_le_succ: zarith. Theorem Zlt_next : forall n m : Z, (n < m)%Z -> m = Zsucc n \/ (Zsucc n < m)%Z. intros n m H'; case (Zle_lt_or_eq (Zsucc n) m); auto with zarith. Qed. Theorem Zle_next : forall n m : Z, (n <= m)%Z -> m = n \/ (Zsucc n <= m)%Z. intros n m H'; case (Zle_lt_or_eq _ _ H'); auto with zarith. Qed. Theorem Zlt_Zopp_Inv : forall p q : Z, (- p < - q)%Z -> (q < p)%Z. intros x y H'; case (Zle_or_lt x y); auto with zarith. Qed. Theorem Zle_Zopp_Inv : forall p q : Z, (- p <= - q)%Z -> (q <= p)%Z. 
=> p < k)). Qed.Theorem update_primes_all_list_invariant : forall (P:nat->nat->nat->Prop), (forall k p n:nat, k = n -> P k p n -> P k p (n+p))-> (forall k p n:nat, n < k -> P k p n -> P k p (n+p))-> forall (k:nat)(l l':list(nat*nat))(b:bool), all_list (P k) l -> update_primes k l = (l',b) -> all_list (P k) l'. Proof. intros P Hp2 Hp3 k l; elim l. - simpl; intros Hal l' b Hup; injection Hup; intros Hb Hl'; rewrite <- Hl'; apply (all_list_nil (P k)). - simpl; intros (p, n) l0 Hrec l' b Hal; case_eq (update_primes k l0); intros l'0 b0 Hup0. case_eq (Nat.compare k n); intros Htwc Hup; injection Hup; intros Hb Hl'; rewrite <- Hl'; generalize (Hal nil l0 p n (refl_equal _)); intros HPkpn; generalize (Hrec l'0 b0 (all_list_transmit (P k) (p,n) l0 Hal) Hup0); intros Hal'; apply all_list_add; auto. + apply Hp2;[apply nat_compare_eq;auto| auto]. + apply Hp3;[apply nat_compare_Gt_gt;auto| auto]. Qed.Theorem divides_dec_aux : forall k n p:nat, n <= k -> divides p n \/ ~divides p n. Proof. intros k; elim k. - intros n p Hle; left; exists 0; rewrite mult_comm; simpl; symmetry; apply le_n_O_eq; auto. - intros k' Hrec n p Hlt; elim (le_lt_or_eq n (S k')). + auto with arith. + intros Heq; rewrite Heq. case p. * right; intros (q, Heq'). discriminate Heq'. * intros p'; case_eq (Nat.compare (S p') (S k')); intros Htwc. -- assert (H:S p' = S k'). { apply nat_compare_eq; auto. } left; exists 1; rewrite H. auto with arith. -- assert (S p' < S k'). apply nat_compare_Lt_lt; auto. elim (Hrec (minus (S k') (S p')) (S p')). ++ intros (q, Heq'); left; exists (S q). rewrite (le_plus_minus (S p') (S k')). ** rewrite Heq'. repeat rewrite (mult_comm (S p')). reflexivity. ** auto with arith. ++ intros Hndiv; right; intros Hdiv. apply Hndiv. elim Hdiv. intros q; case q. ** rewrite mult_comm; simpl; intros; discriminate. ** intros q' Heq'; exists q'. apply plus_reg_l with (S p'). rewrite le_plus_minus_r. { rewrite Heq'. rewrite plus_comm; rewrite mult_n_Sm; reflexivity. } auto with arith. ++ simpl; apply le_minus. -- assert (Hlt': S k' < S p'). { apply nat_compare_Gt_gt; auto. } right; intros Hdiv; elim Hdiv; intros q; case q. ++ rewrite mult_comm; simpl; intros; discriminate. ++ intros q' Heq'; elim (lt_not_le _ _ Hlt'). rewrite Heq'. rewrite mult_comm; simpl; auto with arith. + trivial. Qed. Theorem eq_nat_or : forall n m:nat, n=m \/ ~n=m. 
n h <> 0. Proof. intros n Hle; elim Hle. intros; discriminate. simpl; intros; apply le_2_n_not_zero; assumption. Qed.Theorem le_2_n_pred : forall (n:nat)(h:2 <= n), pred_partial n (le_2_n_not_zero n h) <> 0. Proof. intros n h; exact (le_2_n_pred' n h (le_2_n_not_zero n h)). Qed.Definition pred_partial_2 (n:nat)(h:2 <= n) : nat := pred_partial (pred_partial n (le_2_n_not_zero n h)) (le_2_n_pred n h).Check(forall n:nat, n <> 0 -> {v:nat | n = S v}).Check (forall n:nat, 2 <= n -> {v:nat | n = S (S v)}).Definition pred_strong : forall n:nat, n <> 0 -> {v:nat | n = S v}. intros n; case n; [intros H; elim H | intros p H'; exists p]; trivial. Defined.Theorem pred_strong2_th1 : forall n p:nat, 2 <= n -> n = S p -> p <> 0. Proof. intros; lia. Qed.Theorem pred_th1 : forall n p q:nat, n = S p -> p = S q -> n = S (S q). Proof. intros; subst n; auto. Qed.Definition pred_strong2 (n:nat)(h:2<=n):{v:nat | n = S (S v)} := match pred_strong n (le_2_n_not_zero n h) with | exist _ p h' => match pred_strong p (pred_strong2_th1 n p h h') with | exist _ p' h'' => exist (fun x:nat => n = S (S x)) p' (pred_th1 n p p' h' h'') end end.Definition pred_strong2' : forall n:nat, 2 <= n -> {v:nat | n = S (S v)}. Proof. intros n h; case (pred_strong n). - apply le_2_n_not_zero; assumption. - intros p h'; case (pred_strong p). + apply (pred_strong2_th1 n); assumption. + intros p' h''; exists p'; eapply pred_th1; eauto. Defined.Section minimal_specification_strengthening. Variable prime : nat->Prop. Definition divides (n p:nat) : Prop := exists q:_, q*p = n. Definition prime_divisor (n p:nat):= prime p /\ divides p n. Variable prime_test : nat->bool. Hypotheses (prime_test_t : forall n:nat, prime_test n = true -> prime n) (prime_test_f : forall n:nat, prime_test n = false -> ~prime n). Variable get_primediv_weak : forall n:nat, ~prime n -> nat. Hypothesis get_primediv_weak_ok : forall (n:nat)(H:~prime n), 1 < n -> prime_divisor n (get_primediv_weak n H). Lemma divides_refl : forall n:nat, divides n n. Proof. intro n; exists 1; simpl; auto. Qed. #[local] Hint Resolve divides_refl : core. Check (fun E:nat=> fun n:nat => if prime_test n then n else E). Definition bad_get_prime : nat->nat. intro n; case_eq (prime_test n). - intro; exact n. - intro Hfalse; apply (get_primediv_weak n); auto. Defined. Print bad_get_prime. Theorem bad_get_primediv_ok : forall n:nat, 1 < n -> prime_divisor n (bad_get_prime n). 
E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Monoid.op_inv_l_uniq prod_monoid. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Monoid.op_inv_r_uniq prod_monoid. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Monoid.op_inv_uniq prod_monoid. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Monoid.op_has_inv_l_0 prod_monoid. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Monoid.op_has_inv_r_0 prod_monoid. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Monoid.op_has_inv_0 prod_monoid. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Monoid.op_inv_0_eq_0 prod_monoid. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Monoid.op_inv_0_uniq prod_monoid. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_r prod_monoid. Theorem recipr_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_sum_distrib : is_distrib E prod sum. Proof conj prod_sum_distrib_l prod_sum_distrib_r. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof fun x => let H : (0 # x) + (0 # x) = (0 # x) + 0 := eq_refl (0 # x) || a # x = 0 # x @a by (sum_id_l 0) || a = 0 # x @a by <- prod_sum_distrib_r x 0 0 || (0 # x) + (0 # x) = a @a by sum_id_r (0 # x) in sum_cancel_l (0 # x) 0 (0 # x) H. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof fun x => let H : (x # 0) + (x # 0) = 0 + (x # 0) := eq_refl (x # 0) || x # a = x # 0 @a by sum_id_r 0 || a = x # 0 @a by <- prod_sum_distrib_l x 0 0 || (x # 0) + (x # 0) = a @a by sum_id_l (x # 0) in sum_cancel_r (x # 0) 0 (x # 0) H. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof ex_ind (fun x (H : x # 0 = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_r x)). Theorem prod_0_inv_r : ~ prod_has_inv_r 0. 
^(cs) Rof ^(cs); Ret cs. Definition sync_vecs_now a l cs := cs <- begin_sync cs; cs <- sync_vecs a l cs; cs <- end_sync cs; Ret cs. Definition sync_all cs := cs <- sync_vecs_now 0 (map fst (Map.elements (CSMap cs))) cs; Ret cs. Hint Extern 0 (okToUnify (arrayN ?pts ?a _) (arrayN ?pts ?a _)) => constructor : okToUnify. Theorem read_range_ok : forall A a nr vfold (a0 : A) cs, {< d F vs, PRE:hm rep cs d * [[ (F * arrayS a vs)%pred d ]] * [[ nr <= length vs ]] POST:hm' RET:^(cs, r) rep cs d * [[ r = fold_left vfold (firstn nr (map fst vs)) a0 ]] CRASH:hm' exists cs', rep cs' d >} read_range a nr vfold a0 cs. Proof. unfold read_range; intros. safestep. auto. auto. safestep. step; subst. rewrite firstn_S_selN_expand with (def := $0). rewrite fold_left_app; simpl. erewrite selN_map by omega; auto. rewrite map_length; omega. all: step. Unshelve. exact tt. eauto. Qed. Lemma vsupd_range_xcrash_firstn' : forall l F a n vs cs' d', (F * arrayN ptsto_subset a (vsupd_range vs (firstn n l)))%pred d' -> length l <= length vs -> crash_xform (rep cs' d') =p=> crash_xform (exists cs d, rep cs d * [[ (F * arrayN ptsto_subset a (vsupd_range vs l))%pred d ]]). Proof. induction l using rev_ind; simpl; intros. rewrite firstn_nil in H; cbn in *. apply crash_xform_pimpl; cancel. destruct (le_dec n (S (length l))). destruct (le_dec n (length l)). - rewrite app_length in *; simpl in *. rewrite firstn_app_l in H by auto. rewrite IHl; eauto; try omega. rewrite vsupd_range_app_tl; eauto. xform_norm. rewrite write_array_xcrash_ok with (i := length l); eauto. 2: rewrite vsupd_range_length; try omega; rewrite firstn_length, app_length, Nat.min_l; simpl; omega. xform_norm; cancel. apply crash_xform_pimpl. cancel. - assert (n = length l + 1) by omega; subst. rewrite app_length in *; simpl in *. rewrite firstn_oob in H by (rewrite app_length; simpl; omega). apply crash_xform_pimpl. cancel. - rewrite firstn_oob in H. apply crash_xform_pimpl; cancel. rewrite app_length; simpl; omega. Qed. Lemma vsupd_range_xcrash_firstn : forall F a n l vs, length l <= length vs -> crash_xform (exists cs' d', rep cs' d' * [[ (F * arrayN ptsto_subset a (vsupd_range vs (firstn n l)))%pred d' ]]) =p=> crash_xform (exists cs d, rep cs d * [[ (F * arrayN ptsto_subset a (vsupd_range vs l))%pred d ]]). Proof. intros. xform_norm. erewrite vsupd_range_xcrash_firstn'; eauto. xform_norm. do 2 (xform_normr; cancel). Qed. Theorem write_range_ok : forall a l cs, {< d F vs, PRE:hm rep cs d * [[ (F * arrayS a vs)%pred d ]] * [[ length l <= length vs ]] POST:hm' RET:cs exists d', rep cs d' * [[ (F * arrayS a (vsupd_range vs l))%pred d' ]] XCRASH:hm' exists cs' d', rep cs' d' * [[ (F * arrayS a (vsupd_range vs l))%pred d' ]] >} write_range a l cs. 
H3. apply H0. apply H1. + simpl. repeat (rewrite <- DisjKeyWeak_same). rewrite ?DisjKey_Cons1. rewrite ?DisjKeyWeak_same. split. - intros. inversion H; subst; clear H. split. * split. ++ apply H0. ++ rewrite IHx in H1. inversion H1; subst; clear H1. apply H. * rewrite IHx in H1. inversion H1; subst; clear H1. apply H2. - simpl. intros. inversion H; subst; clear H. split. * inversion H0; subst; clear H0. apply H. * simpl. rewrite IHx. split. ++ inversion H0; subst; clear H0. apply H2. ++ simpl. apply H1. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. + apply W. + apply W. + apply W. Qed. Theorem DisjKey_Append2: forall T Q (x:list (T*Q)) y z (W:forall (a1:T) (a2:T), {a1=a2}+{a1<>a2}), DisjKey x (y++z)<->(DisjKey x y /\ DisjKey x z). Proof. intros. rewrite ?DisjKeyWeak_same. induction y. + simpl. unfold DisjKeyWeak. split. - intros. tauto. - simpl. intros. inversion H; subst; clear H. assert (List.In k (List.map fst x) -> List.In k (List.map fst z) -> False). apply H3. apply H. apply H0. apply H1. + simpl. repeat (rewrite <- DisjKeyWeak_same). rewrite ?DisjKey_Cons2. rewrite ?DisjKeyWeak_same. split. - intros. inversion H; subst; clear H. * split. ++ split. -- apply H0. -- apply IHy in H1. inversion H1; subst; clear H1. apply H. ++ apply IHy in H1. inversion H1; subst; clear H1. apply H2. - intros. inversion H; subst; clear H. inversion H0; subst; clear H0. split. * apply H. * apply IHy. split. ++ apply H2. ++ apply H1. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. - apply W. + apply W. + apply W. + apply W. Qed. Theorem DisjKey_In_map2: forall A B a (k:A) r l (W:forall (a1:A) (a2:A), {a1=a2}+{a1<>a2}), @DisjKey A B a ((k,r)::l)<->(~List.In k (List.map fst a) /\ (DisjKey a l)). Proof. intros. rewrite DisjKey_Cons2. simpl. reflexivity. apply W. Qed. Theorem DisjKey_In_map1: forall A B b (k:A) r l (W:forall (a1:A) (a2:A), {a1=a2}+{a1<>a2}), @DisjKey A B ((k,r)::l) b<->(~List.In k (List.map fst b) /\ (DisjKey l b)). Proof. intros. rewrite DisjKey_Cons1. simpl. reflexivity. apply W. Qed. Theorem DisjKey_In_map_fst2: forall A B a (f:(A*B)) l (W:forall (a1:A) (a2:A), {a1=a2}+{a1<>a2}), @DisjKey A B a (f::l)<->(~List.In (fst f) (List.map fst a) /\ (DisjKey a l)). Proof. intros. rewrite DisjKey_Cons2. reflexivity. apply W. Qed. Theorem DisjKey_In_map_fst1: forall A B b (f:(A*B)) l (W:forall (a1:A) (a2:A), {a1=a2}+{a1<>a2}), @DisjKey A B (f::l) b<->(~List.In (fst f) (List.map fst b) /\ (DisjKey l b)). 
q v). Proof. unseal; apply _. Qed. Global Instance ptsto_ro_discretizable Œ≥ a v: Discretizable (ptsto_ro Œ≥ a v). Proof. unseal; apply _. Qed. Lemma Cinl_valid (A B:cmra) (x:A) : ‚úì @Cinl A B x ‚Üí ‚úì x. Proof. auto. Qed. Lemma Cinr_valid (A B:cmra) (x:B) : ‚úì @Cinr A B x ‚Üí ‚úì x. Proof. auto. Qed. Lemma Cinl_Cinr_op (A B:cmra) x y : @Cinl A B x ‚ã @Cinr A B y = CsumBot. Proof. reflexivity. Qed. Lemma Cinr_Cinl_op (A B:cmra) x y : @Cinr A B y ‚ã @Cinl A B x = CsumBot. Proof. reflexivity. Qed. Lemma ptsto_agree_frac_value Œ≥ k mq1 mq2 v1 v2 : ptsto Œ≥ k mq1 v1 -‚àó ptsto Œ≥ k mq2 v2 -‚àó ‚åúv1 = v2 ‚àß match mq1, mq2 with | Some q1, Some q2 => ‚úì(q1+q2)%Qp | None, None => True | _, _ => False end‚åù. Proof. unseal; rewrite /ptsto_def. iIntros "H1 H2". iCombine "H1 H2" as "H". destruct mq1, mq2. - rewrite -Cinl_op -pair_op frac_op. iDestruct (own_valid with "H") as %Hvalid. iPureIntro. apply auth_frag_valid in Hvalid as Hvalid%singleton_valid%Cinl_valid. apply pair_valid in Hvalid as [? ?%to_agree_op_inv%leibniz_equiv_iff]. simpl in *. auto. - rewrite Cinl_Cinr_op. iDestruct (own_valid with "H") as %Hvalid. apply auth_frag_valid in Hvalid as []%singleton_valid. - rewrite Cinr_Cinl_op. iDestruct (own_valid with "H") as %Hvalid. apply auth_frag_valid in Hvalid as []%singleton_valid. - rewrite -Cinr_op. iDestruct (own_valid with "H") as %Hvalid. iPureIntro. apply auth_frag_valid in Hvalid as Hvalid%singleton_valid%Cinr_valid. apply to_agree_op_inv, leibniz_equiv_iff in Hvalid; auto. Qed. Lemma ptsto_mut_agree_frac_value Œ≥ k q1 q2 v1 v2 : ptsto_mut Œ≥ k q1 v1 -‚àó ptsto_mut Œ≥ k q2 v2 -‚àó ‚åúv1 = v2 ‚àß ‚úì(q1+q2)%Qp‚åù. Proof. iIntros "H1 H2". iDestruct (ptsto_agree_frac_value with "H1 H2") as %?; auto. Qed. Theorem ptsto_agree Œ≥ k mq1 mq2 v1 v2 : ptsto Œ≥ k mq1 v1 -‚àó ptsto Œ≥ k mq2 v2 -‚àó ‚åúv1 = v2‚åù. Proof. iIntros "H1 H2". iDestruct (ptsto_agree_frac_value with "H1 H2") as %[? ?]. auto. Qed. Theorem ptsto_mut_valid Œ≥ k q v : ptsto_mut Œ≥ k q v -‚àó ‚úì q. Proof. unseal; rewrite /ptsto_def. rewrite own_valid. iIntros (Hvalid) "!%". apply (iffLR (auth_frag_valid _)) in Hvalid as Hvalid%singleton_valid%Cinl_valid. apply (iffLR (pair_valid _ _)) in Hvalid; intuition. Qed. Theorem ptsto_valid_2 Œ≥ k q1 q2 v1 v2 : ptsto_mut Œ≥ k q1 v1 -‚àó ptsto_mut Œ≥ k q2 v2 -‚àó ‚úì (q1 + q2)%Qp. Proof. iIntros "H1 H2". iDestruct (ptsto_mut_agree_frac_value with "H1 H2") as %[? ?]. auto. Qed. Theorem ptsto_conflict Œ≥ k v1 v2 : ptsto_mut Œ≥ k 1 v1 -‚àó ptsto_mut Œ≥ k 1 v2 -‚àó False. 
exists x, _ ] => eexists | [ |- _ /\ _ ] => split | [ |- simplify _ _ _ ] => eassumption || apply simplify_fwd | [ H : interp ?X (?Y _) |- interp ?X (?Y _) ] => eapply H end. unfold himp, heq; simpl; intros; repeat match goal with | [ H : _ -> _ |- _ ] => apply H; clear H | [ H : forall x, _ -> _ , H' : _ |- _ ] => apply H in H' | [ H : ?X -> _ , H' : ?X |- _ ] => apply H in H'; clear H end; propxFo; repeat match goal with | [ |- exists x, _ ] => eexists | [ |- _ /\ _ ] => split | [ |- simplify _ _ _ ] => eassumption || apply simplify_fwd | [ H : interp ?X (?Y _) |- interp ?X (?Y _) ] => eapply H end. *) Import PropXRel. Hint Immediate HT.split_comm : heaps. Hint Resolve HT.split_assoc HT.disjoint_split_join HT.split_split_disjoint : heaps. Lemma himp_star_comm : forall P Q, himp (star P Q) (star Q P). Proof. unfold star, himp, interp; intros; propxIntuition; eauto with heaps. Qed. Theorem heq_star_comm : forall P Q, heq (star P Q) (star Q P). Proof. intros. unfold heq. generalize himp_star_comm. intuition. Qed. Theorem himp_star_assoc : forall P Q R, himp (star (star P Q) R) (star P (star Q R)). Proof. unfold star, himp, interp; intros; propxIntuition. eapply HT.split_comm. eapply HT.split_assoc. eapply HT.split_comm. eassumption. eapply HT.split_comm. eassumption. eapply HT.disjoint_split_join. eapply HT.disjoint_comm. eauto with heaps. Qed. Theorem heq_star_assoc : forall P Q R, heq (star (star P Q) R) (star P (star Q R)). Proof. split. eapply himp_star_assoc. unfold star, himp, interp; intros; propxIntuition. eapply HT.split_assoc. eassumption. eassumption. eapply HT.split_comm. eapply HT.disjoint_split_join. eapply HT.disjoint_comm. eapply HT.split_split_disjoint. 2: eassumption. eauto with heaps. Qed. Theorem himp_star_frame : forall P Q R S, himp P Q -> himp R S -> himp (star P R) (star Q S). Proof. unfold himp, star, interp; intros; propxIntuition. Focus 2. eapply Imply_E. eapply valid_weaken. eapply H. firstorder. econstructor; firstorder. Focus 2. eapply Imply_E. eapply valid_weaken. eapply H0. firstorder. econstructor; firstorder. eauto. Qed. Theorem heq_star_frame : forall P Q R S, heq P Q -> heq R S -> heq (star P R) (star Q S). Proof. unfold heq; generalize himp_star_frame. intuition. Qed. Theorem himp_star_pure_p : forall P Q F, himp (star (inj F) P) Q -> (interp cs F -> himp P Q). 
b -> (prd (selN a i ad) (selN b i bd)) * F =p=> prd av bv -> (listmatch a b) * F =p=> listmatch (updN a i av) (updN b i bv). Proof. intros. rewrite listmatch_updN_removeN by auto. rewrite listmatch_isolate with (ad := ad) (bd := bd) by eauto. cancel; rewrite sep_star_comm; auto. Qed. Theorem listmatch_app_tail: forall F a b av bv, length a = length b -> F =p=> prd av bv -> (listmatch a b) * F =p=> listmatch (a ++ av :: nil) (b ++ bv :: nil). Proof. intros. eapply pimpl_trans2. eapply listmatch_isolate with (i := length a); try rewrite app_length; simpl; omega. rewrite removeN_tail. rewrite selN_last with (def := av); auto. rewrite H. rewrite removeN_tail. rewrite selN_last with (def := bv); auto. cancel; auto. Qed. Theorem listmatch_app : forall a1 b1 a2 b2, listmatch a1 b1 * listmatch a2 b2 =p=> listmatch (a1 ++ a2) (b1 ++ b2). Proof. unfold listmatch; intros; cancel. repeat rewrite combine_app by auto. rewrite listpred_app; cancel. repeat rewrite app_length; omega. Qed. Theorem listmatch_app_rev : forall a1 b1 a2 b2, length a1 = length b1 \/ length a2 = length b2 -> listmatch (a1 ++ a2) (b1 ++ b2) =p=> listmatch a1 b1 * listmatch a2 b2. Proof. unfold listmatch; cancel; repeat rewrite app_length in *; repeat (omega || rewrite combine_app || apply listpred_app). Qed. Theorem listmatch_split : forall a b n, listmatch a b <=p=> listmatch (firstn n a) (firstn n b) * listmatch (skipn n a) (skipn n b). Proof. unfold listmatch; intros. rewrite listpred_split with (n := n). rewrite firstn_combine_comm. split; cancel. rewrite skipn_combine; eauto; cancel. repeat rewrite firstn_length; auto. repeat rewrite skipn_length; auto. rewrite skipn_combine; auto. eapply skipn_firstn_length_eq; eauto. eapply skipn_firstn_length_eq; eauto. Qed. Theorem listmatch_emp : forall l1 l2, (forall x y, In x l1 -> In y l2 -> prd x y =p=> emp) -> listmatch l1 l2 =p=> emp. Proof. intros. unfold listmatch. rewrite listpred_emp. cancel. intros; destruct x; simpl. apply H; solve [eapply in_combine_l; eauto |eapply in_combine_r; eauto]. Qed. Theorem listmatch_emp_piff : forall l1 l2, (forall x y, In x l1 -> In y l2 -> prd x y <=p=> emp) -> listmatch l1 l2 <=p=> [[ length l1 = length l2 ]]. Proof. split. rewrite listmatch_length_pimpl; cancel. apply listmatch_emp; intuition. rewrite H; auto. unfold listmatch; rewrite listpred_emp_piff. cancel. intros; destruct x; simpl. apply H; solve [eapply in_combine_l; eauto |eapply in_combine_r; eauto]. Qed. Theorem listmatch_repeat_l : forall v n l2, listmatch (repeat v n) l2 <=p=> [[ n = length l2 ]] * listpred (prd v) l2. 
hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop := forall st st', c / st \\ st' -> P st -> Q st'.Notation "{{ P }} c {{ Q }}" := (hoare_triple P c Q) (at level 90, c at next level) : hoare_spec_scope.Theorem hoare_post_true : forall (P Q : Assertion) c, (forall st, Q st) -> {{P}} c {{Q}}. Admitted. Theorem hoare_pre_false : forall (P Q : Assertion) c, (forall st, ~(P st)) -> {{P}} c {{Q}}. Admitted. Definition assn_sub X a P : Assertion := fun (st : state) => P (t_update st X (aeval st a)).Notation "P [ X |-> a ]" := (assn_sub X a P) (at level 10).Theorem hoare_asgn : forall Q X a, {{assn_sub X a Q }} (X ::= a) {{Q}}. Admitted. Theorem hoare_asgn_fwd : (forall {X Y: Type} {f g : X -> Y}, (forall (x: X), f x = g x) -> f = g) -> forall m a P, {{fun st => P st /\ t_lookup st X = m}} X ::= a {{fun st => P (t_update st X m) /\ t_lookup st X = aeval (t_update st X m) a }}. Admitted. Theorem hoare_asgn_fwd_exists : (forall {X Y: Type} {f g : X -> Y}, (forall (x: X), f x = g x) -> f = g) -> forall a P, {{fun st => P st}} X ::= a {{fun st => exists m, P (t_update st X m) /\ t_lookup st X = aeval (t_update st X m) a }}. Admitted. Theorem hoare_consequence_pre : forall (P P' Q : Assertion) c, {{P'}} c {{Q}} -> P ->> P' -> {{P}} c {{Q}}. Admitted. Theorem hoare_consequence_post : forall (P Q Q' : Assertion) c, {{P}} c {{Q'}} -> Q' ->> Q -> {{P}} c {{Q}}. Admitted. Theorem hoare_consequence : forall (P P' Q Q' : Assertion) c, {{P'}} c {{Q'}} -> P ->> P' -> Q' ->> Q -> {{P}} c {{Q}}. Admitted. Lemma silly1 : forall (P : nat -> nat -> Prop) (Q : nat -> Prop), (forall x y : nat, P x y) -> (forall x y : nat, P x y -> Q x) -> Q 42. Admitted. Lemma silly2 : forall (P : nat -> nat -> Prop) (Q : nat -> Prop), (exists y, P 42 y) -> (forall x y : nat, P x y -> Q x) -> Q 42. Admitted. Theorem hoare_skip : forall P, {{P}} SKIP {{P}}. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.SpecLemmas.Require Import VerdiRaft.TermSanityInterface. Require Import VerdiRaft.SortedInterface.Section SortedProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {tsi : term_sanity_interface}. Theorem logs_sorted_init : raft_net_invariant_init logs_sorted. Proof using. unfold raft_net_invariant_init, logs_sorted, logs_sorted_host, logs_sorted_nw, packets_gt_prevIndex, packets_ge_prevTerm in *. intuition; simpl in *; intuition. Qed. Theorem handleClientRequest_packets : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> ps = []. Proof using. intros. find_apply_lem_hyp handleClientRequest_log. intuition. Qed. Theorem logs_sorted_nw_packets_unchanged : forall net ps' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_packets_unchanged : forall net ps' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_ge_prevTerm_packets_unchanged : forall net ps' st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. unfold packets_ge_prevTerm in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Lemma handleClientRequest_logs_sorted : forall h client id c out st l net, handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st). Proof using tsi. unfold logs_sorted_host. intros. find_apply_lem_hyp handleClientRequest_log. intuition. + repeat find_rewrite. eauto. + find_apply_lem_hyp no_entries_past_current_term_invariant. break_exists; intuition; repeat find_rewrite. simpl. intuition eauto. * find_eapply_lem_hyp maxIndex_is_max; eauto. lia. * unfold no_entries_past_current_term, no_entries_past_current_term_host in *. intuition. simpl in *. find_apply_hyp_hyp. lia. Qed. Theorem logs_sorted_client_request : raft_net_invariant_client_request logs_sorted. Proof using tsi. unfold raft_net_invariant_client_request. unfold logs_sorted. intuition. - unfold logs_sorted_host in *. simpl in *. intros. find_higher_order_rewrite. break_match; eauto. subst. eauto using handleClientRequest_logs_sorted. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using logs_sorted_nw_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_gt_prevIndex_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_ge_prevTerm_packets_unchanged. Qed. Theorem handleTimeout_log : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> log st' = log st. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.CandidatesVoteForSelvesInterface.Section CandidatesVoteForSelvesProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Ltac rewrite_state := match goal with | [st : name -> raft_data, H : forall _, ?st _ = _ |- _] => rewrite H in * end. Ltac t := repeat break_match; simpl in *; try find_inversion; rewrite_state; try use_applyEntries_spec; repeat break_if; subst; eauto; simpl in *; try discriminate. Theorem candidates_vote_for_selves_do_leader : raft_net_invariant_do_leader (candidates_vote_for_selves). Proof using. unfold raft_net_invariant_do_leader, candidates_vote_for_selves. intros. unfold doLeader, advanceCommitIndex in *. t. Qed. Lemma candidates_vote_for_selves_client_request : raft_net_invariant_client_request (candidates_vote_for_selves). Proof using. unfold raft_net_invariant_client_request, candidates_vote_for_selves. intros. unfold handleClientRequest in *. t. Qed. Lemma candidates_vote_for_selves_timeout : raft_net_invariant_timeout candidates_vote_for_selves. Proof using. unfold raft_net_invariant_timeout, candidates_vote_for_selves. intros. unfold handleTimeout, tryToBecomeLeader in *. t. Qed. Lemma candidates_vote_for_selves_append_entries : raft_net_invariant_append_entries candidates_vote_for_selves. Proof using. unfold raft_net_invariant_append_entries, candidates_vote_for_selves. intros. unfold handleAppendEntries, advanceCurrentTerm in *. t. Qed. Lemma candidates_vote_for_selves_append_entries_reply : raft_net_invariant_append_entries_reply candidates_vote_for_selves. Proof using. unfold raft_net_invariant_append_entries_reply, candidates_vote_for_selves. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. t. Qed. Lemma candidates_vote_for_selves_request_vote : raft_net_invariant_request_vote candidates_vote_for_selves. Proof using. unfold raft_net_invariant_request_vote, candidates_vote_for_selves. intros. unfold handleRequestVote, advanceCurrentTerm in *. t. exfalso. find_apply_hyp_hyp. congruence. Qed. Lemma candidates_vote_for_selves_request_vote_reply : raft_net_invariant_request_vote_reply candidates_vote_for_selves. Proof using. unfold raft_net_invariant_request_vote_reply, candidates_vote_for_selves. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. t. Qed. Lemma candidates_vote_for_selves_do_generic_server : raft_net_invariant_do_generic_server candidates_vote_for_selves. Proof using. unfold raft_net_invariant_do_generic_server, candidates_vote_for_selves. intros. unfold doGenericServer in *. t; eauto. Qed. Lemma candidates_vote_for_selves_state_same_packet_subset : raft_net_invariant_state_same_packet_subset candidates_vote_for_selves. Proof using. unfold raft_net_invariant_state_same_packet_subset, candidates_vote_for_selves. intros. repeat find_reverse_higher_order_rewrite; eauto. Qed. Lemma candidates_vote_for_selves_reboot : raft_net_invariant_reboot candidates_vote_for_selves. Proof using. unfold raft_net_invariant_reboot, candidates_vote_for_selves. intros. repeat find_higher_order_rewrite. simpl in *. subst. unfold reboot in *. break_if; simpl in *; eauto; discriminate. Qed. Theorem candidates_vote_for_selves_init : raft_net_invariant_init candidates_vote_for_selves. Proof using. unfold raft_net_invariant_init, candidates_vote_for_selves, step_async_init. simpl in *. intros; discriminate. Qed. Theorem candidates_vote_for_selves_invariant : forall net, raft_intermediate_reachable net -> candidates_vote_for_selves net. 
match goal with H: context [ptsto bn ?a], Hl: _ <=p=> _ |- _ => rewrite Hl, listpred_pick in H by eauto; destruct_lift H end. eapply ptsto_conflict_F with (m := m) (a := bn). pred_apply. cancel. rewrite <- surjective_pairing. cancel. - denote (locked _ = _) as Hl. rewrite locked_eq in Hl. rewrite <- Hl in H; clear Hl. match goal with H: context [ptsto bn ?a], Hl: _ <=p=> _ |- _ => rewrite Hl, listpred_pick in H by eauto; destruct_lift H end. eapply ptsto_conflict_F with (m := m) (a := bn). pred_apply. cancel. rewrite <- surjective_pairing. cancel. - erewrite listmatch_length_r; eauto. destruct (lt_dec inum (length ilist)); eauto. rewrite selN_oob in * by omega. unfold INODE.inode0 in H2; simpl in *; omega. - destruct (lt_dec inum (length ilist)); eauto. rewrite selN_oob in * by omega. unfold INODE.inode0 in *; simpl in *; omega. Grab Existential Variables. all: eauto. all: solve [exact ($0, nil) | exact bfile0]. Qed. Definition ilist_safe ilist1 free1 ilist2 free2 := incl free2 free1 /\ forall inum off bn, block_belong_to_file ilist2 bn inum off -> (block_belong_to_file ilist1 bn inum off \/ block_is_unused free1 bn). Theorem ilist_safe_refl : forall i f, ilist_safe i f i f. Proof. unfold ilist_safe; intuition. Qed. Local Hint Resolve ilist_safe_refl. Theorem ilist_safe_trans : forall i1 f1 i2 f2 i3 f3, ilist_safe i1 f1 i2 f2 -> ilist_safe i2 f2 i3 f3 -> ilist_safe i1 f1 i3 f3. Proof. unfold ilist_safe; intros. destruct H. destruct H0. split. - eapply incl_tran; eauto. - intros. specialize (H2 _ _ _ H3). destruct H2; eauto. right. unfold block_is_unused in *. eauto. Qed. Theorem ilist_safe_upd_nil : forall ilist frees i off, INODE.IBlocks i = nil -> ilist_safe ilist frees (updN ilist off i) frees. Proof. intros. destruct (lt_dec off (length ilist)). - unfold ilist_safe, block_belong_to_file. intuition auto. apply incl_refl. destruct (addr_eq_dec off inum); subst. rewrite selN_updN_eq in * by auto. rewrite H in *; cbn in *; omega. rewrite selN_updN_ne in * by auto. intuition auto. - rewrite updN_oob by omega; auto. Qed. Lemma block_belong_to_file_inum_ok : forall ilist bn inum off, block_belong_to_file ilist bn inum off -> inum < length ilist. Proof. intros. destruct (lt_dec inum (length ilist)); eauto. unfold block_belong_to_file in *. rewrite selN_oob in H by omega. simpl in H. omega. Qed. Lemma rep_used_block_eq_Some_helper : forall T (x y: T), Some x = Some y -> x = y. Proof. intros. inversion H. auto. Qed. Theorem rep_used_block_eq : forall F bxps sm ixp flist ilist m bn inum off frees allocc mscache icache dblocks, (F * rep bxps sm ixp flist ilist frees allocc mscache icache dblocks)%pred (list2nmem m) -> block_belong_to_file ilist bn inum off -> selN (BFData (selN flist inum bfile0)) off ($0, nil) = selN m bn ($0, nil). 
eqP A eqA n (mults a p) (pO A n) -> eqP A eqA n p (pO A n). intros a H' p; elim p; simpl in |- *; auto. intros a0 l H'0 H'1; inversion H'1; auto. Qed.Theorem mults_dist1 : forall p a b, eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> ~ zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> canonical A0 eqA ltM p -> eqP A eqA n (mults (plusTerm (A:=A) plusA (n:=n) a b) p) (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults a p) (mults b p)). intros p; elim p; simpl in |- *; auto. intros; apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply p0_pluspf_l with (1 := cs); auto. intros a l H' a0 b H'0 H'1 H'2 H'3 H'4. cut (canonical A0 eqA ltM l); try apply canonical_imp_canonical with (a := a); auto; intros C0. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pX (plusTerm (A:=A) plusA (n:=n) (multTerm (A:=A) multA (n:=n) a0 a) (multTerm (A:=A) multA (n:=n) b a)) (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults a0 l) (mults b l))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pX (plusTerm (A:=A) plusA (n:=n) (multTerm (A:=A) multA (n:=n) a0 a) (multTerm (A:=A) multA (n:=n) b a)) (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults a0 l) (mults b l))); auto. apply (eqpP1 _ eqA n); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply multTerm_plusTerm_dist_l with (1 := cs); auto. apply pluspf_inv3b with (1 := cs); auto. red in |- *; intros H'5; absurd (zeroP (A:=A) A0 eqA (n:=n) (multTerm (A:=A) multA (n:=n) (plusTerm (A:=A) plusA (n:=n) a0 b) a)); auto. red in |- *; intros H'6. elim multTerm_zeroP_div with (1 := cs) (a := plusTerm (A:=A) plusA (n:=n) a0 b) (b := a); auto. intros H'7; absurd (zeroP (A:=A) A0 eqA (n:=n) a); auto. apply canonical_nzeroP with (ltM := ltM) (p := l); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := plusTerm (A:=A) plusA (n:=n) (multTerm (A:=A) multA (n:=n) a0 a) (multTerm (A:=A) multA (n:=n) b a)); auto. apply multTerm_plusTerm_dist_l with (1 := cs); auto. Qed. Theorem mults_dist2 : forall (p : list (Term A n)) (a b : Term A n), eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> zeroP (A:=A) A0 eqA (n:=n) (plusTerm (A:=A) plusA (n:=n) a b) -> canonical A0 eqA ltM p -> eqP A eqA n (pO A n) (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults a p) (mults b p)). 
Require Export ZArith. Require Export Znumtheory. Require Export Zpow_facts. Lemma mod_sub_ish : forall a b m : Z, a mod m = b mod m -> (a - b) mod m = 0. Proof. intros. Admitted. Theorem theorem_54 : forall k m d : Z, Zis_gcd k m d -> forall a a' : Z, k*a mod m = k*a' mod m -> a mod (m/d) = a' mod (m/d). Proof. intros. induction H. destruct H as [k1 H]. destruct H1 as [m1 H1]. assert (rel_prime k1 m1). constructor. exists k1; omega. exists m1; omega. intros. admit. Admitted. Theorem theorem_55 : forall k m : Z, rel_prime k m -> forall a a' : Z, k*a mod m = k*a' mod m -> a mod m = a' mod m. 
Œ∫ Œ∫s nt) "(HœÉ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iSplit. { iPureIntro. eexists _, _, _, _, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). } iNext; iIntros (v2 œÉ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (ghost_async_map_update_flush_big with "Hd H") as "[$ Ha]". iModIntro; iSplit; first done. iFrame. iApply ("Hœï" with "[$]"). Qed. Lemma wp_WriteOp s E (a: u64) aset b0 b q l : {{{ ‚ñ∑ (int.Z a d‚Ü¶{#1}[aset] b0 ‚àó mapsto_block l q b) }}} ExternalOp WriteOp (Val $ PairV (LitV $ LitInt a) (LitV $ LitLoc l)) @ s; E {{{ RET LitV LitUnit; int.Z a d‚Ü¶{#1}[{[b0]} ‚à™ aset] b ‚àó mapsto_block l q b}}}. Proof. iIntros (Œ¶) ">H Hœï". iDestruct "H" as "(Ha&Hl)". iApply wp_lift_atomic_head_step_no_fork; first by auto. iIntros (œÉ1 g1 ns mj D Œ∫ Œ∫s nt) "(HœÉ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iDestruct (@ghost_async_map_lookup with "Hd Ha") as %Hlookup. destruct Hlookup as (vm&Hw&Hlatest&Hpend). iDestruct (heap_valid_block with "HœÉ Hl") as %?. iSplit. { iPureIntro. eexists _, _, _, _, _; cbn. constructor 1; cbn. repeat (monad_simpl; cbn). econstructor; eauto; [ econstructor; eauto| monad_simpl ]. } iNext; iIntros (v2 œÉ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (ghost_async_map_async_put with "Hd Ha") as "[$ Ha]". { eauto. } assert (b = b0); [ | subst b0 ]. { apply Block_to_vals_ext_eq; intros. specialize (H i); specialize (H1 i); intuition. simpl in H3. destruct_with_eqn (œÉ1.(heap) !! (l +‚Çó i)); try contradiction. destruct p as (n0&?); destruct n0; try contradiction; congruence. } iModIntro; iSplit; first done. iFrame. iApply ("Hœï" with "[$]"). Qed. Definition disk_array (l: Z) (q: dfrac) (vs: list Block): iProp Œ£ := ([‚àó list] i ‚Ü¶ b ‚àà vs, (l + i) d‚Ü¶{q}[‚à ] b)%I. Theorem disk_array_cons l q b vs : disk_array l q (b::vs) ‚ä£‚ä¢ l d‚Ü¶{q}[‚à ] b ‚àó disk_array (l + 1) q vs. Proof. rewrite /disk_array big_sepL_cons. rewrite Z.add_0_r. assert (forall l k, l + S k = l + 1 + k) by lia. setoid_rewrite H. reflexivity. Qed. Theorem disk_array_app l q vs1 vs2 : disk_array l q (vs1 ++ vs2) ‚ä£‚ä¢ disk_array l q vs1 ‚àó disk_array (l + length vs1) q vs2. Proof. rewrite /disk_array big_sepL_app. setoid_rewrite Nat2Z.inj_add. by setoid_rewrite Z.add_assoc. Qed. Theorem disk_array_emp l q : disk_array l q [] ‚ä£‚ä¢ emp. 
forall (x : M.elt) (x1 x0 : c_map), get_c x (M.combine (f_opt_d 0 Init.Nat.add) x1 x0) = (get_c x x1 + get_c x x0). Proof. unfold getd; intros. rewrite M.gcombine. destruct (M.get x x1); destruct (M.get x x0); simpl; subst; auto. reflexivity. Qed. Lemma gccombine_sub: forall (x : M.elt) (x1 x0 : c_map), get_c x (M.combine (f_opt_d 0 Init.Nat.sub) x1 x0) = (get_c x x1 - get_c x x0 ). Proof. unfold getd; intros. rewrite M.gcombine. destruct (M.get x x1); destruct (M.get x x0); simpl; subst; auto. reflexivity. Qed. Lemma proper_set_fun f x y z : map_getd_r nat 0 x y -> (forall c c' : Maps.PTree.t nat, map_getd_r nat 0 c c' -> forall n0 : var, f n0 c = f n0 c') -> map_getd_r nat 0 (M.set z (f z x) x) (M.set z (f z y) y). Proof. intro; intro; intros; intro. destruct (var_dec v z). subst. do 2 (rewrite gdss). apply H0; auto. rewrite gdso. rewrite gdso. apply H. auto. auto. Qed. Theorem proper_update_census_d_list: forall {l} {f} {sig}, (forall c c', map_getd_r _ 0 c c' -> forall n, f n c = f n c') -> Proper (map_getd_r _ 0 ==> map_getd_r _ 0) (update_census_list sig l f). Proof. induction l; intros. simpl. intro. intros. auto. intro. intros. simpl. apply IHl. intro; intros. apply H; auto. intro. destruct (M.elt_eq v (apply_r sig a)). subst. rewrite gdss. rewrite gdss. apply H; auto. rewrite gdso by auto. rewrite gdso by auto. apply H0. Qed. Theorem proper_update_census_d f : (forall c c', map_getd_r _ 0 c c' -> forall n, f n c = f n c') -> (forall e sig, Proper (map_getd_r _ 0 ==> map_getd_r _ 0) (update_census sig e f)) /\ (forall fds sig, Proper (map_getd_r _ 0 ==> map_getd_r _ 0) (update_census_f sig fds f)). Proof. intros fhs; eapply exp_def_mutual_ind; intros; simpl. - intro. intros. apply H. apply proper_update_census_d_list; auto. - intro; intros. apply proper_set_fun; auto. - intro; intros. eapply H. simpl in H0. apply H0. auto. - intro; intros. apply H. revert fhs. revert H0. apply proper_set_fun. - intro. intros. apply H. apply proper_update_census_d_list; auto. apply proper_set_fun; eauto. - intro. intros. apply H0. apply H. auto. - intro; intros. apply proper_update_census_d_list. auto. apply proper_set_fun; auto. - intro. intros. apply H. apply proper_update_census_d_list; auto. - intro; intros. apply proper_set_fun; auto. - intro; intros. apply H0. apply H. auto. - intro; intros. auto. Qed. Theorem proper_plus_census_d e sig: Proper (map_getd_r _ 0 ==> map_getd_r _ 0) (update_census sig e c_plus). 
From stdpp Require Import fin_maps. From iris.proofmode Require Import tactics. From iris.algebra Require Import lib.frac_auth auth numbers gmap excl. From iris.bi Require Import fractional. From Perennial.program_logic Require Export weakestpre. From Perennial.program_logic Require Import ectx_lifting. From Perennial.Helpers Require Import Transitions. From Perennial.base_logic Require Export proph_map frac_coPset. From Perennial.algebra Require Export na_heap. From Perennial.goose_lang Require Export lang. From Perennial.goose_lang Require Export tactics notation. From Perennial.goose_lang Require Import typing. Set Default Proof Using "Type".Notation nonAtomic T := (naMode * T)%type.Section definitions. Context `{ext:ffi_syntax}. Context `{hG: na_heapGS loc val Œ£}. Definition heap_mapsto_def l q v : iProp Œ£ := ‚åúl ‚â null‚åù ‚àó na_heap_mapsto (L:=loc) (V:=val) l q v. Definition heap_mapsto_aux : seal (@heap_mapsto_def). by eexists. Qed. Definition heap_mapsto := unseal heap_mapsto_aux. Definition heap_mapsto_eq : @heap_mapsto = @heap_mapsto_def := seal_eq heap_mapsto_aux. Global Instance heap_mapsto_fractional l v: Fractional (Œª q, heap_mapsto l q v)%I. Proof. intros p q. rewrite heap_mapsto_eq /heap_mapsto_def. rewrite na_heap_mapsto_fractional. iSplit. - by iIntros "(%&$&$)". - by iIntros "[[% $] [% $]]". Qed. Global Instance heap_mapsto_as_fractional l q v: AsFractional (heap_mapsto l q v) (Œª q, heap_mapsto l q v)%I q. Proof. rewrite heap_mapsto_eq /heap_mapsto_def. econstructor; eauto. apply _. Qed. Lemma heap_mapsto_agree l q1 q2 v1 v2 : heap_mapsto l q1 v1 ‚àó heap_mapsto l q2 v2 -‚àó ‚åúv1 = v2‚åù. Proof. rewrite heap_mapsto_eq /heap_mapsto_def. iIntros "[[% Hv1] [% Hv2]]". iApply (na_heap_mapsto_agree with "[$Hv1 $Hv2]"). Qed. Theorem na_mapsto_to_heap l q v : l ‚â null -> na_heap_mapsto l q v -‚àó heap_mapsto l q v. 
Require Import Perm. Require Import FunctionalExtensionality. Require Import Maps. Module SectionExample1. Definition mymap (V: Type) := list (nat*V). Definition empty (V: Type) : mymap V := nil. Fixpoint lookup (V: Type) (default: V) (x: nat) (m: mymap V) : V := match m with | (a,v)::al => if x =? a then v else lookup V default x al | nil => default end. Theorem lookup_empty (V: Type) (default: V): forall x, lookup V default x (empty V) = default. 
intros x y z H; rewrite H; auto. Qed. Theorem eq_le_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z). intros x y z H; rewrite H; auto. Qed. Theorem eq_ge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y). intros x y z H; rewrite H; auto. Qed. Theorem eq_ge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z). intros x y z H; rewrite H; auto. Qed.Theorem ge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y). intros x y z H1 H2; red; apply le_trans with z; auto. Qed.Close Scope nat_scope.Open Scope N_scope.Theorem Nplus_eq_compat_l: forall a b c, b = c -> a + b = a + c. intros; apply f_equal2 with (f:= Nplus); auto. Qed.Theorem Nplus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c. intros a b c H1 H2; case H1. apply Nplus_reg_l with a; auto. Qed.Theorem Nplus_lt_compat_l: forall n m p, n < m -> p + n < p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_gt_compat_l: forall n m p, n > m -> p + n > p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_le_compat_l: forall n m p, n <= m -> p + n <= p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_ge_compat_l: forall n m p, n >= m -> p + n >= p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c. intros a b c H H1; case H; apply f_equal2 with (f:= Nplus); auto. Qed.Theorem Nplus_lt_reg_l: forall n m p, p + n < p + m -> n < m. intros; to_nat; apply plus_lt_reg_l with nn1; auto with arith. Qed.Theorem Nplus_gt_reg_l: forall n m p, p + n > p + m -> n > m. intros; to_nat; apply plus_gt_reg_l with nn1; auto with arith. Qed.Theorem Nplus_le_reg_l: forall n m p, p + n <= p + m -> n <= m. intros; to_nat; apply plus_le_reg_l with nn1; auto with arith. Qed.Theorem Nplus_ge_reg_l: forall n m p, p + n >= p + m -> n >= m. intros; to_nat; apply plus_ge_reg_l with nn1; auto with arith. Qed. Theorem Neq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). 
allocŒ® k) ‚àó "HPalloc" ‚à∑ Palloc Œ≥used s_alloc). Definition is_single_inode l (sz: Z) : iProp Œ£ := ‚àÉ (inode_ref alloc_ref: loc) Œ≥alloc Œ≥used Œ≥blocks, "Hro_state" ‚à∑ s_inode_state l inode_ref alloc_ref ‚àó "#Hinode" ‚à∑ is_inode inodeN inode_ref (Pinode Œ≥blocks Œ≥used) (U64 0) ‚àó "#Halloc" ‚à∑ is_allocator (Palloc Œ≥used) allocŒ® allocN alloc_ref (rangeSet 1 (sz-1)) Œ≥alloc ‚àó "#Hinv" ‚à∑ ncinv s_inodeN (‚àÉ œÉ, s_inode_inv Œ≥blocks œÉ ‚àó P œÉ) . Definition s_inode_cinv sz œÉ (post_crash: bool) : iProp Œ£ := ‚àÉ Œ≥blocks Œ≥used, "Hinode" ‚à∑ (‚àÉ s_inode, "Hinode_cinv" ‚à∑ inode_cinv (U64 0) s_inode ‚àó "HPinode" ‚à∑ Pinode Œ≥blocks Œ≥used s_inode) ‚àó "Halloc" ‚à∑ alloc_crash_cond (Palloc Œ≥used) allocŒ® (rangeSet 1 (sz-1)) post_crash ‚àó "Hs_inode" ‚à∑ s_inode_inv Œ≥blocks œÉ . Local Hint Extern 1 (environments.envs_entails _ (s_inode_cinv _ _ _)) => unfold s_inode_cinv : core. Theorem s_inode_cinv_post_crash sz œÉ : s_inode_cinv sz œÉ true -‚àó s_inode_cinv sz œÉ false. Proof. iNamed 1. iExists _, _; iFrame. iApply (alloc_crash_cond_from_post_crash with "[$]"). Qed. Instance s_inode_inv_Timeless Œ≥blocks blocks : Timeless (s_inode_inv Œ≥blocks blocks). Proof. apply _. Qed. Theorem init_single_inode {E} (sz: Z) : (1 ‚â§ sz < 2^64)%Z ‚Üí ([‚àó list] i ‚àà seqZ 0 sz, i d‚Ü¶ block0) ={E}=‚àó let œÉ0 := s_inode.mk [] in s_inode_cinv sz œÉ0 true. Proof. iIntros (Hbound) "Hd". replace sz with (1 + (sz - 1))%Z at 1 by lia. rewrite -> seqZ_app by lia. change (0 + 1)%Z with 1%Z. rewrite big_sepL_app. iDestruct "Hd" as "[Hinodes Hfree]". iDestruct "Hinodes" as "[Hzero _]". change (0%nat + 0)%Z with (int.Z (U64 0)). iDestruct (init_inode with "Hzero") as "Hinode". simpl. iMod (ghost_var_alloc (nil : list Block)) as (Œ≥blocks) "[HŒ≥blocks Hownblocks]". iMod (ghost_var_alloc (‚à : gset u64)) as (Œ≥used) "[HŒ≥used Hownused]". iModIntro. iExists Œ≥blocks, Œ≥used. iFrame "HŒ≥blocks". iSplitL "Hinode Hownblocks Hownused". - iExists (inode.mk ‚à []). iFrame. - pose proof (new_alloc_state_properties 1 (sz-1) ‚à ltac:(set_solver)) as (Hdom&Hpost_crash&Hused&Hunused). iExists (new_alloc_state 1 (sz-1) ‚à ). iSplitR; first eauto. iSplitR. { rewrite /alloc.domain in Hdom; eauto. } rewrite /Palloc Hused. iFrame "HŒ≥used". rewrite Hunused difference_empty_L. rewrite /rangeSet. rewrite big_sepS_list_to_set; last first. { apply seq_U64_NoDup; word. } rewrite big_sepL_fmap. iApply (big_sepL_mono with "Hfree"). iIntros (???) "H". iExists _. iExactEq "H". f_equiv. * apply lookup_seqZ in H. word. * reflexivity. Qed. Theorem unify_used_set Œ≥blocks Œ≥used s_alloc s_inode : Palloc Œ≥used s_alloc -‚àó Pinode Œ≥blocks Œ≥used s_inode -‚àó ‚åús_inode.(inode.addrs) = alloc.used s_alloc‚åù. Proof. rewrite /Palloc; iNamed 1. iNamed 1. iDestruct (ghost_var_agree with "Hused2 Hused1") as %->. auto. Qed. Opaque alloc_crash_cond. Theorem wpc_Open (sz: u64) œÉ0 : (0 < int.Z sz)%Z ‚Üí {{{ "Hcinv" ‚à∑ s_inode_cinv (int.Z sz) œÉ0 true }}} Open (disk_val tt) #sz @ ‚ä§ {{{ l, RET #l; pre_s_inode l (int.Z sz) œÉ0 }}} {{{ s_inode_cinv (int.Z sz) œÉ0 true }}}. 
apply CS_Par2. apply CS_SeqStep. apply CS_AssStep. apply AS_Plus1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_AssStep. apply AS_Plus. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_Ass. eapply multi_step. apply CS_Par1. apply CS_Ass. eapply multi_step. apply CS_Par2. apply CS_SeqFinish. eapply multi_step. apply CS_Par2. apply CS_While. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq. simpl. eapply multi_step. apply CS_Par2. apply CS_IfFalse. eapply multi_step. apply CS_ParDone. eapply multi_refl. reflexivity. Qed. Lemma par_body_n__Sn : forall n st, st X = n /\ st Y = 0 -> par_loop / st ===>* par_loop / (t_update st X (S n)). Proof. Admitted.Lemma par_body_n : forall n st, st X = 0 /\ st Y = 0 -> exists st', par_loop / st ===>* par_loop / st' /\ st' X = n /\ st' Y = 0. Proof. Admitted. Theorem par_loop_any_X: forall n, exists st', par_loop / empty_state ===>* SKIP / st' /\ st' X = n. Proof. intros n. destruct (par_body_n n empty_state). split; unfold t_update; reflexivity. rename x into st. inversion H as [H' [HX HY]]; clear H. exists (t_update st Y 1). split. eapply multi_trans with (par_loop,st). apply H'. eapply multi_step. apply CS_Par1. apply CS_Ass. eapply multi_step. apply CS_Par2. apply CS_While. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq1. apply AS_Id. rewrite t_update_eq. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq. simpl. eapply multi_step. apply CS_Par2. apply CS_IfFalse. eapply multi_step. apply CS_ParDone. apply multi_refl. rewrite t_update_neq. assumption. intro X; inversion X. Qed.End CImp. Definition stack := list nat. Definition prog := list sinstr.Inductive stack_step : state -> prog * stack -> prog * stack -> Prop := | SS_Push : forall st stk n p', stack_step st (SPush n :: p', stk) (p', n :: stk) | SS_Load : forall st stk i p', stack_step st (SLoad i :: p', stk) (p', st i :: stk) | SS_Plus : forall st stk n m p', stack_step st (SPlus :: p', n::m::stk) (p', (m+n)::stk) | SS_Minus : forall st stk n m p', stack_step st (SMinus :: p', n::m::stk) (p', (m-n)::stk) | SS_Mult : forall st stk n m p', stack_step st (SMult :: p', n::m::stk) (p', (m*n)::stk).Theorem stack_step_deterministic : forall st, deterministic (stack_step st). Proof. unfold deterministic. intros st x y1 y2 H1 H2. induction H1; inversion H2; reflexivity. Qed.Definition stack_multistep st := multi (stack_step st). Definition compiler_is_correct_statement : Prop . Admitted. Theorem compiler_is_correct : compiler_is_correct_statement. 
in |- *; auto. apply not_null_inv with (1 := H1); auto. Qed. Theorem find_code_permutation : forall (a : A) (c1 c2 : code), permutation c1 c2 -> unique_prefix c1 -> find_code a c1 = find_code a c2. Proof using. intros a c1 c2 H; elim H; simpl in |- *; auto. intros a0; case a0. intros a1; case (eqA_dec a a1); auto. intros n l L1 L2 H0 H1 H2; apply H1. apply unique_prefix_inv with (1 := H2). intros a0; case a0. intros a1 l1. case (eqA_dec a a1). intros Ha1 b; case b; auto. intros a2 l2 L HL; case (eqA_dec a a2); auto. intros e. case unique_key_in with (1 := unique_prefix2 _ HL) (b2 := l2); auto. rewrite <- Ha1; rewrite e; simpl in |- *; auto. intros Ha1 b; case b; auto. intros L1 L2 L3 H0 H1 H2 H3 H4; apply trans_equal with (find_code a L2); auto. apply H3. apply (unique_prefix_permutation _ _ H0); auto. Qed. Theorem in_find_map : forall p a l b, In (a, l) p -> find_code a (map (fun v : A * list bool => match v with | (a1, b1) => (a1, b :: b1) end) p) = b :: find_code a p. Proof using. intros p; elim p; simpl in |- *; auto. intros a l b H; case H. intros (a1, l1) l H a0 l0 b [H0| H0]; auto. case (eqA_dec a0 a1); auto. intros HH; case HH; injection H0; auto. case (eqA_dec a0 a1); auto. intros n; apply (H a0 l0 b); auto. Qed. Theorem not_in_find_map : forall p a b, (forall l, ~ In (a, l) p) -> find_code a (map (fun v : A * list bool => match v with | (a1, b1) => (a1, b :: b1) end) p) = nil. Proof using. intros p; elim p; simpl in |- *; auto. intros (a1, l1) l H a0 b H0; case (eqA_dec a0 a1); auto. intros e; case (H0 l1); rewrite e; auto. intros n; apply (H a0 b); auto. intros l0; red in |- *; intros H1; case (H0 l0); auto. Qed. Fixpoint find_val (a : list bool) (l : code) {struct l} : option A := match l with | nil => None | (b, c) :: l1 => match list_eq_dec eq_bool_dec a c with | left _ => Some b | right _ => find_val a l1 end end. Theorem find_val_correct1 : forall (c : code) (a : A) (l : list bool), find_val l c = Some a -> In (a, l) c. 
p -> canonical A0 eqA ltM q -> (forall c : Term A n, In c p -> ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\ eqT c (multTerm (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b)) -> (forall c : Term A n, In c q -> ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\ eqT c (multTerm (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=a) nZa) a)) -> forall c : Term A n, In c p -> In c (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q). intros a b nZa nZb H'1 p q; pattern p, q in |- *. apply (Opm_ind A n ltM ltM_dec); simpl in |- *; intros; auto. elim H3; auto. rewrite minuspf_pO_refl_eq; auto. rewrite <- minuspf_inv2_eq; simpl in |- *; auto. right; apply H; auto. apply canonical_imp_canonical with (a := b0); auto. rewrite <- minuspf_inv1_eq; simpl in |- *; auto. elim H5; intros H'2; clear H5; auto. right; apply H; auto. apply canonical_imp_canonical with (a := a0); auto. elim (H4 b0); [ intros H'4 H'5 | idtac ]; auto. elim (H3 a0); [ intros H'6 H'7 | idtac ]; auto. cut (~ zeroP (A:=A) A0 eqA (n:=n) a0); [ intros Z0 | apply canonical_nzeroP with (ltM := ltM) (p := p0); auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) b0); [ intros Z1 | apply canonical_nzeroP with (ltM := ltM) (p := q0); auto ]. absurd (eqT (ppc (A:=A) A1 (n:=n) a b) (multTerm (A:=A) multA (n:=n) a b)); auto. apply eqT_not_ltT with (1 := os); auto. case (ltT_dec A n ltM ltM_dec (ppc (A:=A) A1 (n:=n) a b) a0); intros test; [ case test; clear test; intros test | idtac ]. apply (ltT_trans A n ltM os) with (y := a0); auto. absurd (ltT ltM a0 (ppc (A:=A) A1 (n:=n) a b)); auto. apply divP_is_not_order with (1 := cs); auto. cut (ppcm A A0 eqA multA divA n a b (ppc (A:=A) A1 (n:=n) a b)); [ intros H'8; inversion H'8 | idtac ]; auto. apply H6; auto. apply eqT_nzero_eqT_divP with (c := b0) (nZb := nZa) (1 := cs); auto. apply eqT_nzero_divP with (nZb := nZb) (1 := cs); auto. apply ppc_is_ppcm with (1 := cs); auto. apply eqT_compat_ltTl with (b := a0); auto. apply (eqT_sym A n); auto. Qed. Theorem multTerm_or_z_d1 : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p : list (Term A n)), canonical A0 eqA ltM (pX a p) -> forall c : Term A n, In c (mults (A:=A) multA (n:=n) b p) -> ltT ltM c (multTerm (A:=A) multA (n:=n) a b) /\ eqT c (multTerm (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) b). 
i) (S1 (points i)). Proof. by rewrite (S1_convn_proj [affine of idfun]). Qed.End convex_space_prop1.Section convex_space_prop2. Variables T U : convType. Implicit Types a b : T.Lemma affine_function_Sum (f : {affine T -> U}) n (g : 'I_n -> T) (d : {fdist 'I_n}) : f (<|>_d g) = <|>_d (f \o g). Proof. Import ScaledConvex. by apply S1_inj; rewrite S1_convn S1_convn_proj. Qed.Lemma eq_convn n (g1 g2 : 'I_n -> T) (d1 d2 : {fdist 'I_n}) : g1 =1 g2 -> d1 =1 d2 -> <|>_d1 g1 = <|>_d2 g2. Proof. move=> Hg Hd; apply S1_inj; rewrite !S1_convn. apply congr_big => // i _; by rewrite Hg Hd. Qed.Lemma convn_proj n (g : 'I_n -> T) (d : {fdist 'I_n}) i : d i = R1 -> <|>_d g = g i. Proof. move=> Hd; apply S1_inj. rewrite S1_convn (bigD1 i) ?inE //=. rewrite big1; first by rewrite addpt0 Hd scalept1. move=> j Hj. move/eqP/FDist1.P: Hd => -> //; by rewrite scalept0. Qed.Lemma ConvnFDist1 (n : nat) (j : 'I_n) (g : 'I_n -> T): <|>_(FDist1.d j) g = g j. Proof. by apply convn_proj; rewrite FDist1.dE eqxx. Qed.Lemma convn1E (g : 'I_1 -> T) (e : {fdist 'I_1}) : <|>_ e g = g ord0. Proof. rewrite /=; case: Bool.bool_dec => // /Bool.eq_true_not_negb H. exfalso; move/eqP: H; apply. by apply/eqP; rewrite FDist1.dE1 (FDist1.I1 e). Qed.Lemma convnE n (g : 'I_n.+1 -> T) (d : {fdist 'I_n.+1}) (i1 : d ord0 != 1%R) : <|>_d g = g ord0 <| probfdist d ord0 |> <|>_(DelFDist.d i1) (fun x => g (DelFDist.f ord0 x)). Proof. rewrite /=; case: Bool.bool_dec => /= [|/Bool.eq_true_not_negb] H. exfalso; by rewrite (eqP H) eqxx in i1. by rewrite (eq_irrelevance H i1). Qed.Lemma convn2E (g : 'I_2 -> T) (d : {fdist 'I_2}) : <|>_d g = g ord0 <| probfdist d ord0 |> g (lift ord0 ord0). Proof. case/boolP : (d ord0 == 1%R) => [|i1]. rewrite FDist1.dE1 => /eqP ->; rewrite ConvnFDist1. rewrite (_ : probfdist _ _ = 1%:pr) ?conv1 //. by apply val_inj; rewrite /= FDist1.dE eqxx. rewrite convnE; congr (_ <| _ |> _). by rewrite convn1E /DelFDist.f ltnn. Qed. Lemma Convn_perm (n : nat) (d : {fdist 'I_n}) (g : 'I_n -> T) (s : 'S_n) : <|>_d g = <|>_(PermFDist.d d s) (g \o s). Proof. apply S1_inj; rewrite !S1_convn (barycenter_perm _ s). apply eq_bigr => i _; by rewrite PermFDist.dE. Qed. Theorem Convn_convnfdist (n m : nat) (d : {fdist 'I_n}) (e : 'I_n -> {fdist 'I_m}) (x : 'I_m -> T) : <|>_d (fun i => <|>_(e i) x) = <|>_(ConvnFDist.d d e) x. 
Require Import List PeanoNat Lia Operators_Properties ConstructiveEpsilon. Import ListNotations. Require Import Undecidability.CounterMachines.CM2. Require Undecidability.CounterMachines.Deciders.CM2_UBOUNDED_dec. From Undecidability.CounterMachines.Util Require Import Facts CM2_facts. Require Import ssreflect ssrbool ssrfun.Set Default Goal Selector "!".Section Construction.Variable M : Cm2.#[local] Notation steps := (CM2.steps M). #[local] Notation mortal := (CM2.mortal M). #[local] Notation bounded := (bounded M). Variable K : nat. Variable HK : forall x, bounded K x.Lemma pos_K : K = 1 + (K - 1). Proof using HK. suff: K <> 0 by lia. move=> H'K. have := HK (0, (0, 0)). rewrite H'K. move=> [[|L]]. - by move=> [_] /(_ (0, (0, 0)) (reaches_refl _)). - move=> ? /=. lia. Qed.Lemma uniform_decision : (uniformly_mortal M) + (not (uniformly_mortal M)). Proof using HK. have := Forall_dec (fun 'x => mortal K x) _ (list_prod (seq 0 (length M)) (list_prod (seq 0 (K+1)) (seq 0 (K+1)))). case. { move=> x. rewrite /(mortal K). by case: (steps K x) => [y|]; [right|left]. } - move=> H'M. left. exists K => - [p [a b]]. have [?|?] : length M <= p \/ p < length M by lia. { rewrite /(mortal K) pos_K /steps iter_plus /= /step /=. have -> : nth_error M p = None by apply /nth_error_None. by rewrite oiter_None. } apply /mortal_K_bound. move: H'M => /Forall_forall. apply. apply /in_prod. { apply /in_seq. lia. } apply /in_prod; apply /in_seq; lia. - move=> H. right => - [K' H'M]. apply: H. apply /Forall_forall. move=> [p [a b]] /in_prod_iff [/in_seq ?] /in_prod_iff [/in_seq ?] /in_seq ?. by apply: (bounded_mortal_bound (HK _) (H'M _)). Qed. End Construction. Theorem decision (M: Cm2) : (uniformly_mortal M) + (not (uniformly_mortal M)). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.CompFold.Open Scope list_scope.Section DistSingle. Variable A B : Set. Hypothesis B_EqDec : EqDec B. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A1 : Comp (A * A_State). Variable A2 : A_State -> B -> Comp bool. Definition DistSingle_G(c : A -> Comp B) := [a, s_A] <-$2 A1; b <-$ c a; A2 s_A b. Definition DistSingle_Adv := | Pr[DistSingle_G c1] - Pr[DistSingle_G c2] |.End DistSingle.Section ListHybrid. Variable A B State : Set. Variable defA : A. Variable c1 c2 : A -> Comp B. Hypothesis c1_wf : forall a, well_formed_comp (c1 a). Hypothesis c2_wf : forall a, well_formed_comp (c2 a). Hypothesis A_EqDec : EqDec A. Hypothesis B_EqDec : EqDec B. Hypothesis State_EqDec : EqDec State. Variable A1 : Comp ((list A) * State). Variable A2 : State -> list B -> Comp bool. Variable maxA : nat. Hypothesis maxA_correct : forall ls s_A, In (ls, s_A) (getSupport A1) -> (length ls <= maxA)%nat. Definition ListHybrid_G (c : A -> Comp B) := [lsA, s_A] <-$2 A1; lsB <-$ compMap _ c lsA; A2 s_A lsB. Definition ListHybrid_Advantage := | Pr[ListHybrid_G c1] - Pr[ListHybrid_G c2] |. Definition G_hybrid i := [lsA, s_A] <-$2 A1; lsA1 <- firstn i lsA; lsA2 <- skipn i lsA; lsB1 <-$ compMap _ c1 lsA1; lsB2 <-$ compMap _ c2 lsA2; A2 s_A (lsB1 ++ lsB2). Theorem G_2_hybrid_eq : Pr[ListHybrid_G c2] == Pr[G_hybrid 0]. unfold ListHybrid_G, G_hybrid. comp_skip. comp_simp. eapply comp_spec_eq_impl_eq. simpl. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem skipn_ge_nil : forall (A : Type)(ls : list A)(n : nat), n >= length ls -> skipn n ls = nil. 
proof H0 as H0'. destruct H0 as [? [? [NoDupMeths [NoDupRegisters NoDupRle]]]]. specialize (inlineSingle_Rule_transform_nth f _ NoDupRle l) as TMP; dest. rewrite H3. assert (WfMod ty m) as P1; [constructor; auto|]. specialize (WfMod_Rule_inlined _ (fst x) P1 H) as P2. unfold inlineSingle_Rule_BaseModule in P2; simpl in *. inv P2; eauto. - apply Nat.nlt_ge in n. rewrite inlineSingle_transform_gt; auto. Qed.Lemma WfBaseMod_inline_nth_Rule_new ty m f i: In f (getMethods m) -> (WfBaseModule_new ty m) -> (WfBaseModule_new ty (BaseMod (getRegisters m) (transform_nth_right (inlineSingle_Rule f) i (getRules m)) (getMethods m))). Proof. repeat rewrite <- WfBaseModule_WfBaseModule_new_iff. apply WfBaseMod_inline_nth_Rule. Qed.Definition inline_nth_Rule_BaseModuleWf {f} {ty} {m : BaseModuleWf ty} i (inMeths : In f (getMethods m)):= (Build_BaseModuleWf (WfBaseMod_inline_nth_Rule f i inMeths (wfBaseModule m))).Definition inline_nth_Rule_BaseModuleWf_new {f} {ty} {m : BaseModuleWf_new ty} i (inMeths : In f (getMethods m)):= (Build_BaseModuleWf_new (WfBaseMod_inline_nth_Rule_new f i inMeths (wfBaseModule_new m))).Lemma inline_rule_transform_Wf {f} {m : BaseModuleWf type} i (inMeths : In f (getMethods m)): TraceInclusion m (inline_nth_Rule_BaseModuleWf i inMeths). Proof. intros; simpl. specialize (TraceInclusion_flatten_r m) as P1. specialize (wfMod (flatten_ModWf m)) as P2; simpl in *. unfold flatten, getFlat in *; simpl in *. specialize (inline_rule_transform f P2 inMeths i) as P3. eauto using TraceInclusion_trans. Qed.Theorem inline_rule_transform_Wf_new {f} {m : BaseModuleWf_new type} i (inMeths : In f (getMethods m)): TraceInclusion m (inline_nth_Rule_BaseModuleWf_new i inMeths). Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as x. eapply (@inline_rule_transform_Wf f x). Unshelve. exact inMeths. Qed.Section inlineSingle_nth. Variable (f : DefMethT). Variable (regs: list RegInitT) (rules: list RuleT) (meths: list DefMethT). Variable (Wf : WfMod type (Base (BaseMod regs rules meths))). Lemma inline_meth_fold_right xs: In f meths -> TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs rules (fold_right (transform_nth_right (inlineSingle_Meth f)) meths xs))). Proof. induction xs; intros. - simpl; apply TraceInclusion_refl. - simpl. specialize (IHxs H). specialize (WfMod_inline_all_Meth _ xs H Wf) as P1. specialize (inlined_Meth_not_transformed_fold_right _ xs _ H) as P2. specialize (inline_meth_transform _ P1 P2 a) as P3. apply (TraceInclusion_trans IHxs P3). Qed. Lemma inline_rule_fold_right xs: In f meths -> TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs (fold_right (transform_nth_right (inlineSingle_Rule f)) rules xs) meths)). Proof. induction xs; intros. - simpl; apply TraceInclusion_refl. - simpl. specialize (IHxs H). specialize (WfMod_inline_all_Rule _ xs H Wf) as P1. specialize (inline_rule_transform _ P1 H a) as P2. apply (TraceInclusion_trans IHxs P2). Qed. End inlineSingle_nth.Section inlineSingle_nth_new. Variable (f : DefMethT). Variable (regs: list RegInitT) (rules: list RuleT) (meths: list DefMethT). Variable (Wf : WfMod_new type (Base (BaseMod regs rules meths))). Theorem inline_meth_fold_right_new xs: In f meths -> TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs rules (fold_right (transform_nth_right (inlineSingle_Meth f)) meths xs))). 
Require Import Coq.omega.Omega. Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.WebServer Bedrock.Platform.Bootstrap. Module Type HIDE. Parameter heapSize4 : N -> N. Axiom heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. Parameter to_nat : N -> nat. Axiom to_nat_eq : to_nat = N.to_nat. End HIDE.Module Hide : HIDE. Definition heapSize4 n := (n * 4)%N. Theorem heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Poly.Theorem silly1 : forall (n m o p : nat), n = m -> [n;o] = [n;p] -> [n;o] = [m;p]. Admitted. Theorem silly2 : forall (n m o p : nat), n = m -> (forall (q r : nat), q = r -> [q;o] = [r;p]) -> [n;o] = [m;p]. Admitted. Theorem silly3_firsttry : forall (n : nat), n = 5 -> beq_nat (S (S n)) 7 = true. Admitted. QuickChick silly3_firsttry. *) Theorem rev_exercise1 : forall (l l' : list nat), l = rev l' -> l' = rev l. Admitted. QuickChick rev_exercise1. *)Theorem trans_eq : forall (X:Type) (n m o : X), n = m -> m = o -> n = o. Admitted. QuickChick trans_eq. *)Example trans_eq_example' : forall (a b c d e f : nat), [a;b] = [c;d] -> [c;d] = [e;f] -> [a;b] = [e;f]. Admitted. Example trans_eq_exercise : forall (n m o p : nat), m = (minustwo o) -> (n + p) = m -> (n + p) = (minustwo o). Admitted. Theorem S_injective : forall (n m : nat), S n = S m -> n = m. Admitted. Theorem beq_nat_0_l : forall n, 0 = n -> n = 0. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops. From Categories Require Import Cat.Cat. From Categories Require Import NatTrans.NatTrans.Local Open Scope nattrans_scope. Section Opposite_NatTrans. Context {C D : Category} {F F' : (C --> D)%functor} (N : (F --> F')%nattrans). Program Definition Opposite_NatTrans : F'^op --> F^op := {| Trans := Trans N; Trans_com := fun c c' h => (Trans_com_sym N h); Trans_com_sym := fun c c' h => (Trans_com N h) |}.End Opposite_NatTrans.Notation "N '^op'" := (Opposite_NatTrans N) : nattrans_scope. Section Compose_NOP. Context {C D : Category} {F F' F'' : (C --> D)%functor} (N : F --> F') (N' : F' --> F''). Theorem NatTrans_compose_Op : ((N' ‚àò N)^op = N^op ‚àò (N'^op))%nattrans. 
mb p q H H0 H1. apply eqpP1; auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Lemma eqp_inv1 : forall p, eqP (pO A n) p -> p = pO A n. unfold pO in |- *; intros p H'; inversion H'; auto. Qed. Theorem eqp_inv2 : forall p, eqP p (pO A n) -> p = pO A n. unfold pO in |- *; intros p H'; inversion H'; auto. Qed. Theorem eqp_inv3l : forall a b p q, eqP (pX a p) (pX b q) -> eqTerm (A:=A) eqA (n:=n) a b. intros a b p q H'; simple inversion H'; auto. unfold pO in H0; inversion H0. rewrite (pX_invl ma a p0 p); auto; rewrite (pX_invl mb b q0 q); auto. Qed. Theorem eqp_inv3r : forall a b p q, eqP (pX a p) (pX b q) -> eqP p q. intros a b p q H'; simple inversion H'; auto. unfold pO in H0; inversion H0. rewrite (pX_invr p0 p ma a); auto; rewrite (pX_invr q0 q mb b); auto. Qed. Theorem eqp_trans : transitive _ eqP. red in |- *. intros x; elim x; auto. intros y z H'; inversion_clear H'. intros H'0; inversion_clear H'0; auto. intros a l H' y z H'0; inversion_clear H'0. intros H4; inversion_clear H4. change (eqP (pX a l) (pX mb0 q0)) in |- *; apply eqpP1; eauto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mb); auto. Qed. Hint Resolve eqp_refl. Let eqTerm_imp_eqT := eqTerm_imp_eqT A eqA n. Theorem ltP_refl_pX : forall (a : Term A n) (p : list (Term A n)), canonical A0 eqA ltM (pX a p) -> ltP (A:=A) (n:=n) ltM p (pX a p). intros a p; case p; auto. intros a0 l H'. apply ltP_trans with (y := pX a (pO A n)); auto. change (ltP (A:=A) (n:=n) ltM (pX a0 l) (pX a (pO A n))) in |- *. apply ltP_hd; auto. apply (canonical_pX_order A A0) with (eqA := eqA) (l := l); auto. apply ltP_tl; auto. change (ltP (A:=A) (n:=n) ltM (pO A n) (pX a0 l)) in |- *; apply ltPO. Qed. Theorem eqp_eqTerm : forall a b p q, eqP (pX a p) (pX b q) -> eqTerm (A:=A) eqA (n:=n) a b. intros a b p q H'; inversion_clear H'; trivial. Qed. Theorem ltp_eqp_comp : forall p q r s, ltP (A:=A) (n:=n) ltM p q -> canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqP p r -> eqP q s -> ltP (A:=A) (n:=n) ltM r s. 
induction e; simpl in |- *; auto with coc core arith datatypes; intros. unfold def_cons, int_cons, ext_ik in |- *. elim (cl_term a (cls_of_int (def_intp l))); auto with coc core arith datatypes. Qed. Lemma def_adapt : forall e, wf e -> forall k, int_adapt e (def_intp e) (def_intt e k). simple induction e; simpl in |- *; intros. apply Build_int_adapt; auto with coc core arith datatypes.inversion_clear H0. cut (wf l); intros. elim H with (S k); trivial; intros in_interp ip_can_adapted same_classes. unfold def_cons, int_cons in |- *. apply Build_int_adapt; auto with coc core arith datatypes. apply int_cs; auto with coc core arith datatypes. apply (var_in_cand k (int_typ a (def_intp l) PROP)); auto with coc core arith datatypes. change (is_can PROP (int_typ a (def_intp l) PROP)) in |- *. apply int_typ_cr; auto with coc core arith datatypes.unfold ext_ik in |- *. rewrite same_classes. pattern (cl_term a (class_env l)) in |- *. apply class_typ_ord with s; auto with coc core arith datatypes.simpl in |- *. unfold ext_ik in |- *. rewrite same_classes. pattern (cl_term a (class_env l)) in |- *. apply class_typ_ord with s; unfold cls_of_int in |- *; elim same_classes; auto with coc core arith datatypes. simpl in |- *. rewrite same_classes. elim skel_sound with l a (Srt s); auto with coc core arith datatypes. simpl in |- *; auto with coc core arith datatypes. elim same_classes; auto with coc core arith datatypes.apply typ_wf with a (Srt s); auto with coc core arith datatypes. Qed. Hint Resolve def_intp_can def_adapt: coc. Lemma def_intt_id : forall n e k, def_intt e k n = Ref (k + n). simple induction n; simple destruct e; simpl in |- *; auto with coc core arith datatypes; intros. replace (k + 0) with k; auto with coc core arith datatypes.rewrite H. replace (k + S n0) with (S (k + n0)); auto with coc core arith datatypes. Qed. Lemma id_int_term : forall e t k, int_term t (def_intt e 0) k = t. simple induction t; simpl in |- *; intros; auto with coc core arith datatypes. elim (le_gt_dec k n); intros; auto with coc core arith datatypes. rewrite def_intt_id. simpl in |- *; unfold lift in |- *. rewrite lift_ref_ge; auto with coc core arith datatypes. rewrite H; rewrite H0; auto with coc core arith datatypes.rewrite H; rewrite H0; auto with coc core arith datatypes.rewrite H; rewrite H0; auto with coc core arith datatypes. Qed. Theorem str_norm : forall e t T, typ e t T -> sn t. 
Œ¶ name ‚Üí FromExist P Œ¶ ‚Üí IntoExist (Restore R P Q) (Œª x, Restore R (Œ¶ x) Q) name. Proof. unseal. rewrite /IntoExist /FromExist. iIntros (HP_ex HŒ¶_ex) "[HP #HR]". iDestruct (HP_ex with "HP") as (x) "HŒ¶". iExists x; iFrame. iIntros "!> HŒ¶". iApply "HR". iApply HŒ¶_ex; eauto. Qed. Global Instance restore_is_exists R P Q : IsExistential P ‚Üí IsExistential (Restore R P Q). Proof. Qed. Global Instance restore_finish_Persistent R P Q `{!Persistent P} `{BiAffine PROP} : IntoSep (Restore R P Q) P (Restore R emp Q). Proof. unseal. rewrite /IntoSep. iIntros "[#HP #HR]". iSpecialize ("HR" with "HP"). iFrame "HP". rewrite /Restore_def; iFrame. rewrite left_id. iIntros "!> _". iFrame "#". Qed. Global Instance restore_finish_IntoSep R P Q : IntoSep (Restore R P Q) P (Restore R emp (P ‚àó Q)) | 30. Proof. unseal. rewrite /IntoSep. iIntros "[$ #HR]". rewrite /Restore_def; iFrame. rewrite left_id. iIntros "!> _". iIntros "[? ?]". iApply ("HR" with "[$] [$]"). Qed. Global Instance restore_finish_IntoSep_emp R P : IntoSep (Restore R P emp) P (Restore R emp P) | 29. Proof. rewrite /IntoSep. iIntros "[$ HR]". rewrite right_id //. Qed. Theorem restore_done_persistent R Q : Persistent (Restore R emp Q). Proof. unseal. apply _. Qed. Theorem restore_elim R Q : Restore R emp Q -‚àó ‚ñ° (Q -‚àó R). Proof. unseal. iIntros "[_ #HR] !>". by iApply "HR". Qed.End bi.Ltac iNamedRestorable i := let j := iFresh in iDestruct (restore_intro with i) as j; iNamed j; let pat := constr:(intro_patterns.IIntuitionistic (intro_patterns.IIdent i)) in iDestruct (restore_elim with j) as pat; iClear j.Section tests. Context {PROP:bi}. Context `{BiAffine PROP}. Implicit Types (P Q R:PROP). Definition all3 P1 P2 P3: PROP := ("HP1" ‚à∑ P1 ‚àó "HP2" ‚à∑ P2 ‚àó "HP3" ‚à∑ P3)%I. Theorem example1 P1 P2 P3 : all3 P1 P2 P3 -‚àó P2 ‚àó (P2 -‚àó all3 P1 P2 P3). Proof. iIntros "H". iNamedRestorable "H". iFrame "HP2". iIntros "HP2". iApply "H"; iFrame. Qed. Definition absr P1 P2 P3 := ("HP1" ‚à∑ P1 ‚àó "#HP2" ‚à∑ ‚ñ°P2 ‚àó "HP3" ‚à∑ P3)%I. Theorem example2 P1 P2 P3 : absr P1 P2 P3 -‚àó P2 ‚àó P3 ‚àó (P3 -‚àó absr P1 P2 P3). Proof. iIntros "H". iNamedRestorable "H". iFrame "HP3". iSplitL ""; [ iFrame "#" | ]. iIntros "HP3". iApply "H"; iFrame. Qed. Definition absr' P1 P2 (Œ¶: nat ‚Üí PROP): PROP := ("#HP1" ‚à∑ ‚ñ°P1 ‚àó "Hn" ‚à∑ ‚àÉ n, "Hn1" ‚à∑ Œ¶ (n+1) ‚àó "HP2" ‚à∑ P2)%I. Theorem example3 P1 P2 Œ¶ : absr' P1 P2 Œ¶ -‚àó P2 ‚àó (P2 -‚àó absr' P1 P2 Œ¶). 
n1 Int.iwordsize) eqn:?; simpl; auto. rewrite Heqb; rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shru_shru; auto. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\ Val.lessdef (Val.mul x (Vint n)) v). TrivialExists. econstructor. EvalOp. simpl; eauto. econstructor. eauto. constructor. rewrite Val.mul_commut. auto. generalize (Int.one_bits_decomp n). generalize (Int.one_bits_range n). destruct (Int.one_bits n). intros. auto. destruct l. intros. rewrite H1. simpl. rewrite Int.add_zero. replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul. apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib. destruct l. intros. rewrite H1. simpl. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exploit (eval_add (x :: le)). eexact A1. eexact A2. intros [v [A B]]. exists v; split. econstructor; eauto. rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. eapply Val.lessdef_trans. 2: eauto. apply Val.add_lessdef; auto. simpl. repeat rewrite H0; auto with coqlib. intros. auto. Qed. Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros until x; unfold mulimm. predSpec Int.eq Int.eq_spec n Int.zero. intros. exists (Vint Int.zero); split. EvalOp. destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto. predSpec Int.eq Int.eq_spec n Int.one. intros. exists x; split; auto. destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto. case (mulimm_match a); intros; InvEval. TrivialExists. simpl. rewrite Int.mul_commut; auto. subst. rewrite Val.mul_add_distr_l. exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]]. exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]]. exists v''; split; auto. eapply Val.lessdef_trans. eapply Val.add_lessdef; eauto. rewrite Val.mul_commut; auto. apply eval_mulimm_base; auto. Qed.Theorem eval_mul: binary_constructor_sound mul Val.mul. Proof. red; intros until y. unfold mul; case (mul_match a b); intros; InvEval. rewrite Val.mul_commut. apply eval_mulimm. auto. apply eval_mulimm. auto. TrivialExists. Qed.Theorem eval_mulhs: binary_constructor_sound mulhs Val.mulhs. Proof. unfold mulhs; red; intros; TrivialExists. Qed. Theorem eval_mulhu: binary_constructor_sound mulhu Val.mulhu. Proof. unfold mulhu; red; intros; TrivialExists. Qed. Theorem eval_andimm: forall n, unary_constructor_sound (andimm n) (fun x => Val.and x (Vint n)). 
Theorem compFold_acc : forall numCalls0 bits acc state, comp_spec (fun x y : list (list (Bvector eta)) * KV => hd_error (fst x) = Some bits /\ tl (fst x) = fst y) (compFold (pair_EqDec (list_EqDec (list_EqDec eqdbv)) eqDecState) (fun (acc : list (list (Bvector eta)) * KV) (d : nat) => [rs, s]<-2 acc; z <-$ Generate s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (bits :: acc, state) (replicate numCalls0 blocksPerCall)) (compFold (pair_EqDec (list_EqDec (list_EqDec eqdbv)) eqDecState) (fun (acc : list (list (Bvector eta)) * KV) (d : nat) => [rs, s]<-2 acc; z <-$ Generate s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (acc, state) (replicate numCalls0 blocksPerCall)). Proof. intros. revert bits acc state. induction numCalls0; intros. - simpl. fcf_spec_ret. - simpl. fcf_inline_first. fcf_skip. remember a0 as bits1. remember b as state'. clear Heqbits1 Heqstate'. fcf_simp. apply IHnumCalls0. Qed. Theorem Generate_v_split_close : Pr[G_real] == Pr[G_real_split]. Proof. unfold G_real, G_real_split. unfold requestList. destruct numCalls as [ | numCalls']. * inversion H_numCalls. * Opaque Generate. simpl. fcf_to_prhl_eq. fcf_skip. fcf_simp. remember b as k. remember b0 as v. clear Heqk Heqv. remember (replicate numCalls' blocksPerCall) as requestList'. unfold oracleMap. simpl. fcf_inline_first. fcf_skip. Opaque getSupport. simpl in *. remember a0 as bits. remember b1 as state'. clear Heqbits Heqstate'. fcf_skip. instantiate (1 := (fun x y => hd_error (fst x) = Some bits /\ tail (fst x) = fst y)). - apply compFold_acc. - fcf_simp. simpl in H5. inversion H5. clear H5. destruct a1. inversion H6. simpl in *. inversion H6. subst. fcf_reflexivity. Transparent Generate. Qed. Theorem comp_spec_acc_2 : forall numCalls0 acc k v, comp_spec (fun x y : list (list (Bvector eta)) * KV => fst x = fst y) (compFold (pair_EqDec (list_EqDec (list_EqDec eqdbv)) eqDecState) (fun (acc : list (list (Bvector eta)) * KV) (d : nat) => [rs, s]<-2 acc; z <-$ Generate s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (acc, (k, f k (to_list v))) (replicate numCalls0 blocksPerCall)) (compFold (pair_EqDec (list_EqDec (list_EqDec eqdbv)) eqDecState) (fun (acc : list (list (Bvector eta)) * KV) (d : nat) => [rs, s]<-2 acc; z <-$ Generate_v s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (acc, (k, v)) (replicate numCalls0 blocksPerCall)). Proof. intros. revert v k acc. induction numCalls0 as [ | numCalls0']; intros. * simpl. fcf_spec_ret. * simpl. fcf_inline_first. fcf_simp. apply IHnumCalls0'. Qed. Theorem Generate_move_v_update : Pr[G_real] == Pr[G1_prg]. 
y r => Node111 l y (set' q x r) end. Definition set {A} (p: positive) (x: A) (m: tree A) : tree A := match m with | Empty => Nodes (set0 p x) | Nodes m' => Nodes (set' p x m') end. Fixpoint rem' {A} (p: positive) (m: tree' A) : tree A := match p, m with | xH, Node001 r => Nodes m | xH, Node010 _ => Empty | xH, Node011 _ r => Nodes (Node001 r) | xH, Node100 l => Nodes m | xH, Node101 l r => Nodes m | xH, Node110 l _ => Nodes (Node100 l) | xH, Node111 l _ r => Nodes (Node101 l r) | xO q, Node001 r => Nodes m | xO q, Node010 y => Nodes m | xO q, Node011 y r => Nodes m | xO q, Node100 l => Node (rem' q l) None Empty | xO q, Node101 l r => Node (rem' q l) None (Nodes r) | xO q, Node110 l y => Node (rem' q l) (Some y) Empty | xO q, Node111 l y r => Node (rem' q l) (Some y) (Nodes r) | xI q, Node001 r => Node Empty None (rem' q r) | xI q, Node010 y => Nodes m | xI q, Node011 y r => Node Empty (Some y) (rem' q r) | xI q, Node100 l => Nodes m | xI q, Node101 l r => Node (Nodes l) None (rem' q r) | xI q, Node110 l y => Nodes m | xI q, Node111 l y r => Node (Nodes l) (Some y) (rem' q r) end. Definition remove' := Eval cbv [rem' Node] in @rem'. Definition remove {A} (p: positive) (m: tree A) : tree A := match m with | Empty => Empty | Nodes m' => remove' p m' end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. reflexivity. Qed. Lemma gEmpty: forall (A: Type) (i: positive), get i (@Empty A) = None. Proof. reflexivity. Qed. Lemma gss0: forall {A} p (x: A), get' p (set0 p x) = Some x. Proof. induction p; simpl; auto. Qed. Lemma gso0: forall {A} p q (x: A), p<>q -> get' p (set0 q x) = None. Proof. induction p; destruct q; simpl; intros; auto; try apply IHp; congruence. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: tree A), get i (set i x m) = Some x. 
x). specialize (H0 _ tt _ _ _ _ H1_0 x). destruct H2. + apply in_or_app. intuition. + apply in_or_app; right; apply in_or_app. intuition. + specialize (IHae2 _ _ _ _ H1_ x). specialize (H0 _ tt _ _ _ _ H1_0 x). simpl in *. apply M.union_In in H2. destruct H2; apply in_or_app; right; apply in_or_app; intuition. - dependent destruction H. apply (IHae _ _ _ _ H x H0). - dependent destruction H. apply M.F.P.F.empty_in_iff in H0; intuition. Qed. Lemma callsR_subset: forall o u rName cs, Substep m o u (Rle (Some rName)) cs -> forall x, M.In x cs -> exists a, In (rName :: a)%struct (getRules m) /\ In x (getCallsA (a typeUT)). Proof. destruct mEquiv. clear mEquiv H0. intros. dependent destruction H0. exists a. constructor. intuition. pose proof (proj1 (RulesEquiv_in type typeUT (getRules m)) H _ HInRules). apply (callsA_subset H0 HAction); intuition. Qed. Lemma callsM_subset: forall o u mName argRet cs, Substep m o u (Meth (Some (mName :: argRet)%struct)) cs -> forall x, M.In x cs -> exists a, In (mName :: a)%struct (getDefsBodies m) /\ In x (getCallsA (projT2 a typeUT tt)). Proof. destruct mEquiv. clear mEquiv H. intros. dependent destruction H. destruct f. exists attrType. constructor. intuition. pose proof (proj1 (MethsEquiv_in type typeUT (getDefsBodies m)) H0 _ HIn argV tt). apply (callsA_subset H HAction); intuition. Qed. Lemma getCalls_rules_subset (a: Action Void) rName: forall x, In x (getCallsA (a typeUT)) -> In (rName :: a)%struct (getRules m) -> In x (getCalls m). Proof. intros. unfold getCalls. apply in_or_app. left. induction (getRules m). - intuition. - simpl in *. destruct H0; subst; apply in_or_app; intuition. Qed. Lemma getCalls_meths_subset (a: sigT MethodT) mName: forall x, In x (getCallsA (projT2 a typeUT tt)) -> In (mName :: a)%struct (getDefsBodies m) -> In x (getCalls m). Proof. intros. unfold getCalls. apply in_or_app. right. induction (getDefsBodies m). - intuition. - simpl in *. destruct H0; subst; apply in_or_app; intuition. Qed. Theorem getCalls_substep o u rm cs: Substep m o u rm cs -> forall f, M.In f cs -> In f (getCalls m). Proof. dependent induction rm; dependent induction o0; intros. - eapply callsR_subset in H; dest; subst; try eapply getCalls_rules_subset in H1; eauto. - dependent destruction H. apply M.F.P.F.empty_in_iff in H0; intuition. - destruct a. eapply callsM_subset in H; dest; subst; try eapply getCalls_meths_subset in H1; eauto. - dependent destruction H. apply M.F.P.F.empty_in_iff in H0; intuition. Qed. Theorem getCalls_substeps o ss: forall f, M.In f (calls (foldSSLabel (m := m) (o := o) ss)) -> In f (getCalls m). 
Sync;; Ret (cache0 cachesize). Definition read_array a i cs := r <- read (a + i) cs; Ret r. Definition write_array a i v cs := cs <- write (a + i) v cs; Ret cs. Definition sync_array a i cs := cs <- sync (a + i) cs; Ret cs. Definition size_valid cs := Map.cardinal (CSMap cs) = CSCount cs /\ Map.cardinal (CSMap cs) <= CSMaxCount cs /\ CSMaxCount cs <> 0. Definition addr_valid (d : rawdisk) (cm : cachemap) := forall a, Map.In a cm -> d a <> None. Definition addr_clean (cm : cachemap) a := Map.find a cm = None \/ exists v, Map.find a cm = Some (v, false). Definition addrs_clean cm al := Forall (addr_clean cm) al. Definition cachepred (cache : cachemap) (a : addr) (vs : valuset) : @pred _ addr_eq_dec valuset := (match Map.find a cache with | None => a |+> vs | Some (v, false) => a |+> vs * [[ v = fst vs ]] | Some (v, true) => exists v0, a |+> (v0, snd vs) * [[ v = fst vs /\ In v0 (snd vs) ]] end)%pred. Notation mem_pred := (@mem_pred _ addr_eq_dec _ _ addr_eq_dec _). Definition rep (cs : cachestate) (m : rawdisk) : rawpred := ([[ size_valid cs /\ addr_valid m (CSMap cs) ]] * mem_pred (cachepred (CSMap cs)) m)%pred. Definition synpred (cache : cachemap) (a : addr) (vs : valuset) : @pred _ addr_eq_dec valuset := (exists vsd, a |+> vsd * match Map.find a cache with | None => [[ vs = (fst vsd, nil) ]] | Some (v, false) => [[ vs = (fst vsd, nil) /\ v = fst vsd ]] | Some (v, true) => [[ vs = (v, (fst vsd) :: nil) ]] end)%pred. Definition synrep' (cs : cachestate) (m : rawdisk) : rawpred := ([[ size_valid cs /\ addr_valid m (CSMap cs) ]] * mem_pred (synpred (CSMap cs)) m)%pred. Definition synrep (cs : cachestate) (mbase m : rawdisk) : rawpred := (rep cs mbase /\ synrep' cs m)%pred. Theorem sync_invariant_cachepred : forall cache a vs, sync_invariant (cachepred cache a vs). Proof. unfold cachepred; intros. destruct (Map.find a cache); eauto. destruct p; destruct b; eauto. Qed. Theorem sync_invariant_synpred : forall cache a vs, sync_invariant (synpred cache a vs). Proof. unfold synpred; intros. destruct (Map.find a cache); eauto. destruct p; destruct b; eauto. Qed. Hint Resolve sync_invariant_cachepred sync_invariant_synpred. Theorem sync_invariant_rep : forall cs m, sync_invariant (rep cs m). 
H1; case H2; intros z1 Hz1 z2 Hz2. absurd (n = n); auto. pattern n at 1 in |- *; rewrite Hz1; rewrite Hz2; repeat rewrite (fun x => Zplus_comm x 1). case z1; case z2; simpl in |- *; try (intros; red in |- *; intros; discriminate). intros p p0; case p0; simpl in |- *; try (intros; red in |- *; intros; discriminate). Qed. Hint Resolve OddNEven EvenNOdd: zarith. Theorem EvenPlus1 : forall n m : Z, Even n -> Even m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem EvenPlus2 : forall n m : Z, Odd n -> Odd m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1 + 1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus1 : forall n m : Z, Odd n -> Even m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus2 : forall n m : Z, Even n -> Odd m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Hint Resolve EvenPlus1 EvenPlus2 OddPlus1 OddPlus2: zarith. Theorem EvenPlusInv1 : forall n m : Z, Even (n + m) -> Even n -> Even m. intros n m H H0; replace m with (n + m + - n)%Z; auto with zarith. Qed. Theorem EvenPlusInv2 : forall n m : Z, Even (n + m) -> Odd n -> Odd m. intros n m H H0; replace m with (n + m + - n)%Z; auto with zarith. Qed. Theorem OddPlusInv1 : forall n m : Z, Odd (n + m) -> Odd m -> Even n. intros n m H H0; replace n with (n + m + - m)%Z; auto with zarith. Qed. Theorem OddPlusInv2 : forall n m : Z, Odd (n + m) -> Even m -> Odd n. intros n m H H0; replace n with (n + m + - m)%Z; auto with zarith. Qed. Theorem EvenMult1 : forall n m : Z, Even n -> Even (n * m). 
auto. intros a1 a2 l1 l2 l3 H'0 H'1 H'2. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pX (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) a2) (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (pX a1 l1) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) l2))); auto. apply eqpP1; auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := invTerm (A:=A) invA (n:=n) (multTerm (A:=A) multA (n:=n) (T1 A1 n) a2)); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. simpl in |- *; apply pluspf_inv2 with (1 := cs); auto. change (ltT ltM a1 (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) a2)) in |- *; auto. apply eqT_compat_ltTr with (b := a2); auto. Qed. Theorem minuspf_is_pluspf_mults : forall p q : list (Term A n), eqP A eqA n (minuspf p q) (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)). intros p q; try assumption. apply minusP_is_plusP_mults with (p := p) (q := q); auto. Qed. Hint Resolve minuspf_is_pluspf_mults. Theorem pO_minusP_inv1 : forall p q : list (Term A n), minusP (pO A n) p q -> q = mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p. intros p; elim p. intros q H'; inversion H'; auto. intros a l H' q H'0; inversion H'0; auto. Qed. Theorem pO_minusP_inv2 : forall p q : list (Term A n), minusP p (pO A n) q -> p = q. intros p; elim p. intros q H'; inversion H'; auto. intros a l H' q H'0; inversion H'0; auto. Qed. Theorem minusP_inv1 : forall (a b : Term A n) (p q s : list (Term A n)), minusP (pX a p) (pX b q) s -> ltT ltM b a -> s = pX a (minuspf p (pX b q)). intros a b p q s H'; inversion_clear H'; intros. apply pX_inj; auto. apply uniq_minusp with (l := (p, pX b q)); simpl in |- *; auto. absurd (ltT ltM b a); auto. apply ltT_not_eqT; auto; apply eqT_sym; auto. absurd (ltT ltM b a); auto. apply ltT_not_eqT; auto; apply eqT_sym; auto. absurd (ltT ltM b a); auto. Qed. Theorem minusP_inv2 : forall (a b : Term A n) (p q s : list (Term A n)), minusP (pX a p) (pX b q) s -> ltT ltM a b -> s = pX (invTerm (A:=A) invA (n:=n) b) (minuspf (pX a p) q). 
n4_3 with P Q. intros n4_3a. apply propositional_extensionality in n4_3a. replace (Q‚àßP) with (P‚àßQ) in Sa by now apply n4_3a. MP Simp3_26a Sa. exact Simp3_26a. Qed.Theorem n5_35 : ‚àÄ P Q R : Prop, ((P ‚Üí Q) ‚àß (P ‚Üí R)) ‚Üí (P ‚Üí (Q ‚Üî R)). Proof. intros P Q R. specialize Comp3_43 with P Q R. intros Comp3_43a. specialize n5_1 with Q R. intros n5_1a. specialize Syll2_05 with P (Q‚àßR) (Q‚ÜîR). intros Syll2_05a. MP Syll2_05a n5_1a. Syll Comp3_43a Syll2_05a Sa. exact Sa. Qed.Theorem n5_36 : ‚àÄ P Q : Prop, (P ‚àß (P ‚Üî Q)) ‚Üî (Q ‚àß (P ‚Üî Q)). Proof. intros P Q. specialize Id2_08 with (P‚ÜîQ). intros Id2_08a. specialize n5_32 with (P‚ÜîQ) P Q. intros n5_32a. apply propositional_extensionality in n5_32a. replace (P‚ÜîQ‚ÜíP‚ÜîQ) with ((P‚ÜîQ)‚àßP‚Üî(P‚ÜîQ)‚àßQ) in Id2_08a by now apply n5_32a. specialize n4_3 with P (P‚ÜîQ). intros n4_3a. apply propositional_extensionality in n4_3a. replace ((P‚ÜîQ)‚àßP) with (P‚àß(P‚ÜîQ)) in Id2_08a by now apply n4_3a. specialize n4_3 with Q (P‚ÜîQ). intros n4_3b. apply propositional_extensionality in n4_3b. replace ((P‚ÜîQ)‚àßQ) with (Q‚àß(P‚ÜîQ)) in Id2_08a by now apply n4_3b. exact Id2_08a. Qed. Theorem n5_4 : ‚àÄ P Q : Prop, (P ‚Üí (P ‚Üí Q)) ‚Üî (P ‚Üí Q). Proof. intros P Q. specialize n2_43 with P Q. intros n2_43a. specialize Simp2_02 with (P) (P‚ÜíQ). intros Simp2_02a. Conj n2_43a Simp2_02a C. Equiv C. exact C. Qed.Theorem n5_41 : ‚àÄ P Q R : Prop, ((P ‚Üí Q) ‚Üí (P ‚Üí R)) ‚Üî (P ‚Üí Q ‚Üí R). Proof. intros P Q R. specialize n2_86 with P Q R. intros n2_86a. specialize n2_77 with P Q R. intros n2_77a. Conj n2_86a n2_77a C. Equiv C. exact C. Qed.Theorem n5_42 : ‚àÄ P Q R : Prop, (P ‚Üí Q ‚Üí R) ‚Üî (P ‚Üí Q ‚Üí P ‚àß R). Proof. intros P Q R. specialize n5_3 with P Q R. intros n5_3a. specialize n4_87 with P Q R. intros n4_87a. specialize Imp3_31 with P Q R. intros Imp3_31a. specialize Exp3_3 with P Q R. intros Exp3_3a. Conj Imp3_31a Exp3_3 Ca. Equiv Ca. apply propositional_extensionality in Ca. replace ((P‚àßQ)‚ÜíR) with (P‚ÜíQ‚ÜíR) in n5_3a by now apply Ca. specialize n4_87 with P Q (P‚àßR). intros n4_87b. specialize Imp3_31 with P Q (P‚àßR). intros Imp3_31b. specialize Exp3_3 with P Q (P‚àßR). intros Exp3_3b. Conj Imp3_31b Exp3_3b Cb. Equiv Cb. apply propositional_extensionality in Cb. replace ((P‚àßQ)‚Üí(P‚àßR)) with (P‚ÜíQ‚Üí(P‚àßR)) in n5_3a by now apply Cb. exact n5_3a. Qed. Theorem n5_44 : ‚àÄ P Q R : Prop, (P‚ÜíQ) ‚Üí ((P ‚Üí R) ‚Üî (P ‚Üí (Q ‚àß R))). 
Require Import Coq.Logic.FunctionalExtensionality. Require Import Coq.Logic.ProofIrrelevance. Require Import Main.CategoryTheory.Arrow. Require Import Main.CategoryTheory.Category. Require Import Main.CategoryTheory.Functor. Require Import Main.Tactics.#[local] Set Universe Polymorphism.Record naturalTransformation {C D} (F G : functor C D) := newNaturalTransformation { eta x : arrow (oMap F x) (oMap G x); naturality {x y} (f : arrow x y) : compose (eta y) (fMap F f) = compose (fMap G f) (eta x); }.Arguments newNaturalTransformation {_} {_}. Arguments eta {_} {_} {_} {_} _. Arguments naturality {_} {_} {_} {_} _ {_} {_}.#[export] Hint Resolve naturality : main. #[export] Hint Rewrite @naturality : main.Theorem eqNaturalTransformation {C D} (F G : functor C D) (Eta Mu : naturalTransformation F G) : eta Eta = eta Mu -> Eta = Mu. Proof. clean. assert ( match H in (_ = rhs) return forall (x y : object C) (f : arrow x y), compose (rhs y) (fMap F f) = compose (fMap G f) (rhs x) with | eq_refl => @naturality C D F G Eta end = @naturality C D F G Mu ). - apply proof_irrelevance. - destruct Eta. destruct Mu. magic. Qed.#[export] Hint Resolve eqNaturalTransformation : main.#[local] Theorem rightWhiskerNaturality {C D E} {F G : functor C D} {H : functor D E} {Eta : naturalTransformation F G} (x y : object C) (f : arrow x y) : compose (fMap H (eta Eta y)) (fMap (compFunctor H F) f) = compose (fMap (compFunctor H G) f) (fMap H (eta Eta x)). 
auto. intros; discriminate. Qed. Theorem not_one_zero : Qpos One <> Zero. discriminate. Qed. Definition Qinv (x : Q) := match x with | Qpos x => Qpos (Qpositive_inv x) | Qneg x => Qneg (Qpositive_inv x) | Zero => Zero end. Theorem Qinv_def : forall x : Q, x <> Zero -> Qmult x (Qinv x) = Qpos One. intros x; case x.2: intros x' Hneg; simpl in |- *. 2: rewrite Qpositive_mult_inv; auto.intros H; elim H; auto.intros x' Hneg; simpl in |- *. rewrite Qpositive_mult_inv; auto. Qed. Theorem Q_integral : forall x y : Q, Qmult x y = Zero -> x = Zero \/ y = Zero. intros x y; case y; case x; simpl in |- *; auto; intros x' y' H; discriminate H. Qed. Inductive Qgt : Q -> Q -> Prop := | Qgt_pos_pos : forall x' y' : Qpositive, ~ Qpositive_le x' y' -> Qgt (Qpos x') (Qpos y') | Qgt_neg_neg : forall x' y' : Qpositive, ~ Qpositive_le y' x' -> Qgt (Qneg x') (Qneg y') | Qgt_pos_zero : forall x' : Qpositive, Qgt (Qpos x') Zero | Qgt_pos_neg : forall x' y' : Qpositive, Qgt (Qpos x') (Qneg y') | Qgt_zero_neg : forall x' : Qpositive, Qgt Zero (Qneg x'). Hint Resolve Qgt_pos_pos Qgt_neg_neg Qgt_pos_zero Qgt_pos_neg Qgt_zero_neg. Theorem Qgt_total : forall x y : Q, Qgt x y \/ x = y \/ Qgt y x. intros x y; case y; case x; auto. intros x' y'; case (Qpositive_le_dec x' y'); auto with *. case (Qpositive_eq_dec x' y'). intros e q; right; left; rewrite e; auto. intros n q; right; right; apply Qgt_pos_pos. red in |- *; intros H; elim n; apply Qpositive_le_antisym; auto. intros x' y'; case (Qpositive_le_dec x' y'); auto with *. case (Qpositive_eq_dec x' y'). intros e q; right; left; rewrite e; auto. intros n q; left; apply Qgt_neg_neg. red in |- *; intros H; elim n; apply Qpositive_le_antisym; auto. Qed. Definition Q_eq_dec : forall x y : Q, {x = y} + {x <> y}. intros x y; case x; case y; try (right; discriminate).auto.intros y' x'; case (Qpositive_eq_dec x' y'). intros H; left; rewrite H; auto. intros H; right; red in |- *; intros H'; elim H. injection H'; auto.intros y' x'; case (Qpositive_eq_dec x' y'). intros H; left; rewrite H; auto. intros H; right; red in |- *; intros H'; elim H. injection H'; auto. Qed. Theorem Qgt_antisym : forall x y : Q, Qgt x y -> ~ Qgt y x. 
-> (bpow e2 < F2R (Float beta m e1))%R -> (bpow e2 <= F2R (Float beta (m - 1) e1))%R. Proof. intros m e1 e2 Hm. case (Zle_or_lt e1 e2); intros He. replace e2 with (e2 - e1 + e1)%Z by ring. rewrite bpow_plus. unfold F2R. simpl. rewrite <- (Z2R_Zpower beta (e2 - e1)). intros H. apply Rmult_le_compat_r. apply bpow_ge_0. apply Rmult_lt_reg_r in H. apply Z2R_le. rewrite (Zpred_succ (Zpower _ _)). apply Zplus_le_compat_r. apply Zlt_le_succ. now apply lt_Z2R. apply bpow_gt_0. now apply Zle_minus_le_0. intros H. apply Rle_trans with (1*bpow e1)%R. rewrite Rmult_1_l. apply bpow_le. now apply Zlt_le_weak. unfold F2R. simpl. apply Rmult_le_compat_r. apply bpow_ge_0. replace 1%R with (Z2R 1) by reflexivity. apply Z2R_le. omega. Qed.Theorem F2R_lt_bpow : forall f : float beta, forall e', (Zabs (Fnum f) < Zpower beta (e' - Fexp f))%Z -> (Rabs (F2R f) < bpow e')%R. Proof. intros (m, e) e' Hm. rewrite <- F2R_Zabs. destruct (Zle_or_lt e e') as [He|He]. unfold F2R. simpl. apply Rmult_lt_reg_r with (bpow (-e)). apply bpow_gt_0. rewrite Rmult_assoc, <- 2!bpow_plus, Zplus_opp_r, Rmult_1_r. rewrite <-Z2R_Zpower. 2: now apply Zle_left. now apply Z2R_lt. elim Zlt_not_le with (1 := Hm). simpl. cut (e' - e < 0)%Z. 2: omega. clear. case (e' - e)%Z ; try easy. intros p _. apply Zabs_pos. Qed.Theorem F2R_change_exp : forall e' m e : Z, (e' <= e)%Z -> F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e')) e'). Proof. intros e' m e He. unfold F2R. simpl. rewrite Z2R_mult, Z2R_Zpower, Rmult_assoc. apply f_equal. pattern e at 1 ; replace e with (e - e' + e')%Z by ring. apply bpow_plus. now apply Zle_minus_le_0. Qed.Theorem F2R_prec_normalize : forall m e e' p : Z, (Zabs m < Zpower beta p)%Z -> (bpow (e' - 1)%Z <= Rabs (F2R (Float beta m e)))%R -> F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e' + p)) (e' - p)). Proof. intros m e e' p Hm Hf. assert (Hp: (0 <= p)%Z). destruct p ; try easy. now elim (Zle_not_lt _ _ (Zabs_pos m)).replace (e - e' + p)%Z with (e - (e' - p))%Z by ring. apply F2R_change_exp. cut (e' - 1 < e + p)%Z. omega. apply (lt_bpow beta). apply Rle_lt_trans with (1 := Hf). rewrite <- F2R_Zabs, Zplus_comm, bpow_plus. apply Rmult_lt_compat_r. apply bpow_gt_0. rewrite <- Z2R_Zpower. now apply Z2R_lt. exact Hp. Qed. Theorem ln_beta_F2R_bounds : forall x m e, (0 < m)%Z -> (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R -> ln_beta beta x = ln_beta beta (F2R (Float beta m e)) :> Z. 
: list := match l with | nil => m | a :: l1 => a :: app l1 m end. Infix "++" := app (right associativity, at level 60) : list_scope.End Lists.Arguments nil {A}. Infix "::" := cons (at level 60, right associativity) : list_scope. Infix "++" := app (right associativity, at level 60) : list_scope.Open Scope list_scope.Delimit Scope list_scope with list.Bind Scope list_scope with list.Arguments list _%type_scope.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), nil <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = nil}. Proof. induction l as [|a tl]. right; reflexivity. left; exists a; exists tl; reflexivity. Qed. Theorem head_nil : head (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem head_cons : forall (l : list A) (x : A), head (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl in |- *; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl in |- *; auto. Qed. Theorem in_nil : forall a:A, ~ In a nil. Proof. unfold not in |- *; intros a H; inversion_clear H. Qed. Lemma In_split : forall x (l:list A), In x l -> exists l1, exists l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists (@nil A); exists l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1); exists l2; simpl; f_equal; auto. Qed. Theorem in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem In_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl in |- *; auto. destruct IHl; simpl in |- *; auto. right; unfold not in |- *; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), nil <> x ++ a :: y. Proof. unfold not in |- *. destruct x as [| a l]; simpl in |- *; intros. discriminate H. discriminate H. Qed. Theorem app_nil_end : forall l:list A, l = l ++ nil. 
idtac ]; intros test); change (P (pX a l) (pX a0 l0)) in |- *; auto. Qed. Theorem minuspf_eq_inv1 : forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM (pX a p) -> canonical A0 eqA ltM (pX a q) -> eqP A eqA n (pX a (minuspf p q)) (minuspf (pX a p) q). intros a p q; case q; simpl in |- *; auto. intros H' H'0; rewrite minuspf_pO_refl_eq; rewrite minuspf_pO_refl_eq; auto. intros a0 l H' H'0. change (eqP A eqA n (pX a (minuspf p (pX a0 l))) (minuspf (pX a p) (pX a0 l))) in |- *; apply minuspf_inv1; auto. apply (canonical_pX_order A A0 eqA) with (l := l); auto. Qed. Theorem minuspf_pOmults_eq : forall p : list (Term A n), minuspf (pO A n) p = mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) p. intros p; apply uniq_minusp with (l := (pO A n, p)); auto. Qed. Theorem minuspf_eq_inv2 : forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM (pX a p) -> canonical A0 eqA ltM (pX a q) -> eqP A eqA n (pX (invTerm (A:=A) invA (n:=n) a) (minuspf p q)) (minuspf p (pX a q)). intros a p; elim p; auto. intros q H' H'0; rewrite minuspf_pOmults_eq. rewrite minuspf_pOmults_eq; simpl in |- *. apply eqpP1; auto. change (eqTerm (A:=A) eqA (n:=n) (invTerm (A:=A) invA (n:=n) a) (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) a)) in |- *. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := invTerm (A:=A) invA (n:=n) (multTerm (A:=A) multA (n:=n) (T1 A1 n) a)); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. intros a0 l H' q H'0 H'1. change (eqP A eqA n (pX (invTerm (A:=A) invA (n:=n) a) (minuspf (pX a0 l) q)) (minuspf (pX a0 l) (pX a q))) in |- *. rewrite <- (minuspf_inv2_eq a0 a l q); auto. apply (canonical_pX_order A A0 eqA) with (l := l); auto. Qed. Definition inv : list (Term A n) -> Term A n -> Term A n. intros p; case p. intros a; exact (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) a). intros a1 p1 a; exact (invTerm (A:=A) invA (n:=n) a). Defined. Theorem inv_prop : forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM (pX a p) -> minuspf p (pX a q) = pX (inv p a) (minuspf p q). 
Require Export UniMath.Foundations.PartA. Fixpoint isofhlevel (n : nat) (X : UU) : UU := match n with | O => iscontr X | S m => ‚àè x : X, ‚àè x' : X, (isofhlevel m (x = x')) end.Theorem hlevelretract (n : nat) {X Y : UU} (p : X -> Y) (s : Y -> X) (eps : ‚àè y : Y , paths (p (s y)) y) : isofhlevel n X -> isofhlevel n Y. Proof. revert X Y p s eps. induction n as [ | n IHn ]. - intros X Y p s eps X0. unfold isofhlevel. apply (iscontrretract p s eps X0). - unfold isofhlevel. intros X Y p s eps X0 x x'. unfold isofhlevel in X0. assert (is: isofhlevel n (paths (s x) (s x'))) by apply X0. set (s':= @maponpaths _ _ s x x'). set (p':= pathssec2 s p eps x x'). set (eps':= @pathssec3 _ _ s p eps x x'). simpl. apply (IHn _ _ p' s' eps' is). Defined.Corollary isofhlevelweqf (n : nat) {X Y : UU} (f : X ‚âÉ Y) : isofhlevel n X -> isofhlevel n Y. Proof. intros X0. apply (hlevelretract n f (invmap f) (homotweqinvweq f)). assumption. Defined.Corollary isofhlevelweqb (n : nat) {X Y : UU} (f : X ‚âÉ Y) : isofhlevel n Y -> isofhlevel n X. Proof. intros X0. apply (hlevelretract n (invmap f) f (homotinvweqweq f)). assumption. Defined.Lemma isofhlevelsn (n : nat) {X : UU} (f : X -> isofhlevel (S n) X) : isofhlevel (S n) X. Proof. intros. simpl. intros x x'. apply (f x x x'). Defined.Lemma isofhlevelssn (n : nat) {X : UU} (is : ‚àè x : X, isofhlevel (S n) (x = x)) : isofhlevel (S (S n)) X. Proof. intros. simpl. intros x x'. change (‚àè (x0 x'0 : x = x'), isofhlevel n (x0 = x'0)) with (isofhlevel (S n) (x = x')). assert (X1 : x = x' -> isofhlevel (S n) (x = x')) by (intro X2; induction X2; apply (is x)). apply (isofhlevelsn n X1). Defined. Definition isofhlevelf (n : nat) {X Y : UU} (f : X -> Y) : UU := ‚àè y : Y, isofhlevel n (hfiber f y). Theorem isofhlevelfhomot (n : nat) {X Y : UU} (f f' : X -> Y) (h : ‚àè x : X, paths (f x) (f' x)) : isofhlevelf n f -> isofhlevelf n f'. 
as [ -> | C ]. - destruct (IHl t) as [ H | C ]. ++ left; destruct H as (x & ->). exists x; auto. ++ right; contradict C; destruct C as (x & E). exists x; inversion E; subst; auto. - right; contradict C; destruct C as (? & E); inversion E; auto. Qed. Fact is_a_tail_dec (l t : list X) : { exists x, x++t = l } + { ~ exists x, x++t = l }. Proof using eqX_dec. destruct (is_a_head_dec (rev l) (rev t)) as [ H | H ]. + left; destruct H as (x & Hx). exists (rev x). apply f_equal with (f := @rev _) in Hx. rewrite rev_app_distr in Hx. do 2 rewrite rev_involutive in Hx; auto. + right; contradict H. destruct H as (x & Hx); exists (rev x); subst. apply rev_app_distr. Qed.End dec.Notation "R ‚ä≥ s ‚àï t" := (derivable R s t) (at level 70, format "R ‚ä≥ s ‚àï t").Section pcp_hand_dec. Variable (X : Type) (lc : list (list X * list X)). Notation pcp_hand := (fun s t => lc ‚ä≥ s‚àït). Lemma pcp_hand_inv p q : lc ‚ä≥ p‚àïq -> In (p,q) lc \/ exists x y p' q', In (x,y) lc /\ lc ‚ä≥ p'‚àïq' /\ p = x++p' /\ q = y++q' /\ (x <> nil /\ y = nil \/ x = nil /\ y <> nil \/ x <> nil /\ y <> nil ). Proof. induction 1 as [ x y H | x y p q H1 H2 IH2 ]. + left; auto. + destruct x as [ | a x ]; [ destruct y as [ | b y ] | ]. * simpl; auto. * right; exists nil, (b::y), p, q; simpl; msplit 4; auto. right; left; split; auto; discriminate. * right; exists (a::x), y, p, q; simpl; msplit 4; auto. destruct y. - left; split; auto; discriminate. - right; right; split; discriminate. Qed. Section pcp_induction. Implicit Type (l m : list X). Definition strict_suffix x y l m := { a : _ & { b | (a <> nil \/ b <> nil) /\ l = a++x /\ m = b++y } }. Variable (P : list X -> list X -> Type) (IHP : forall l m, (forall l' m', strict_suffix l' m' l m -> P l' m') -> P l m). Theorem pcp_induction l m : P l m. 
Require Export Fbound. Section Fnormalized_Def. Variable radix : Z. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Let FtoRradix := FtoR radix. Coercion FtoRradix : float >-> R. Variable b : Fbound. Definition Fnormal (p : float) := Fbounded b p /\ (Zpos (vNum b) <= Zabs (radix * Fnum p))%Z. Theorem FnormalBounded : forall p : float, Fnormal p -> Fbounded b p. intros p H; case H; auto. Qed. Theorem FnormalBound : forall p : float, Fnormal p -> (Zpos (vNum b) <= Zabs (radix * Fnum p))%Z. intros p H; case H; auto. Qed. Hint Resolve FnormalBounded FnormalBound: float. Theorem FnormalNotZero : forall p : float, Fnormal p -> ~ is_Fzero p. unfold is_Fzero in |- *; intros p H; red in |- *; intros H1. case H; rewrite H1. replace (Zabs (radix * 0)) with 0%Z; auto with zarith. rewrite Zmult_comm; simpl in |- *; auto. Qed. Theorem FnormalFop : forall p : float, Fnormal p -> Fnormal (Fopp p). intros p H; split; auto with float. replace (Zabs (radix * Fnum (Fopp p))) with (Zabs (radix * Fnum p)); auto with float. case p; simpl in |- *; auto with zarith. intros Fnum1 Fexp1; rewrite <- Zopp_mult_distr_r; apply sym_equal; apply Zabs_Zopp. Qed. Theorem FnormalFabs : forall p : float, Fnormal p -> Fnormal (Fabs p). 
L); auto. elim L; simpl in |- *; auto. intros a l H0 a0 H1; elim H1; clear H1; intros H1; auto. case H1; auto. Qed. Theorem Cb_trans_cons : forall (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q (p :: L) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L. intros L p q H H0. apply Cb_trans with (1 := cs) (b := p); auto. apply Cb_cons_addEnd; auto. Qed. Theorem Cb_cons : forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p L) (p :: L). intros p L; unfold nf, LetP in |- *; auto. case (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os L p); simpl in |- *; auto. intros x0; case x0; simpl in |- *. intros x c H'. change (CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec (p :: L) (mults (A:=A) multA (n:=n) (unit A A0 A1 eqA divA n ltM (mks A A0 eqA n ltM x c)) x)) in |- *. apply CombLinear_mults1 with (1 := cs); auto. apply unit_nZ with (1 := cs); auto. apply reducestar_cb1 with (1 := cs); auto. Qed. Theorem Cb_comp : forall L1 L2 : list (poly A0 eqA ltM), (forall p : poly A0 eqA ltM, In p L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2) -> forall q : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2. intros L1 L2 H' q; case q; simpl in |- *. intros x H'0 H'1. apply CombLinear_compo with (1 := cs) (L1 := L1); auto. intros q0 H'2. case inPolySet_inv1 with (1 := H'2); auto. intros q1 H; elim H; intros H0 H1; clear H. lapply (H' q1); [ intros H'6 | idtac ]; auto. generalize H'6 H1; case q1; simpl in |- *; auto. intros x0 H'5 H'7 H'8; rewrite H'8; auto. Defined. Theorem Cb_nf : forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p L :: L). 
Require Import List Arith Max Lia Wellfounded Bool.From Undecidability.Shared.Libs.DLW.Utils Require Import list_focus utils_tac utils_list utils_nat.Set Implicit Arguments.Section list_choose_d. Variable (X : Type) (P Q : X -> Prop). Theorem list_choose_d l : (forall x, In x l -> P x \/ Q x) -> (exists x, In x l /\ P x) \/ forall x, In x l -> Q x. Proof. induction l as [ | x l IHl ]; intros Hl. + right; intros _ []. + destruct (Hl x) as [ H1 | H1 ]. * left; auto. * left; exists x; simpl; auto. * destruct IHl as [ (y & H2 & H3) | H2 ]. - intros; apply Hl; right; auto. - left; exists y; simpl; auto. - right; intros ? [ <- | ]; auto. Qed.End list_choose_d.Section bounded_choose_d. Variable (P Q : nat -> Prop). Theorem bounded_choose_d n : (forall x, x < n -> P x \/ Q x) -> (exists x, x < n /\ P x) \/ forall x, x < n -> Q x. Proof. intros H. destruct list_choose_d with (P := P) (Q := Q) (l := list_an 0 n) as [ (x & H1 & H2) | H1 ]. + intro; rewrite list_an_spec; intro; apply H; lia. + left; exists x; split; auto. apply list_an_spec in H1; lia. + right; intros x Hx; apply H1, list_an_spec; lia. Qed. End bounded_choose_d.Section bounded_min. Variable (P Q : nat -> Prop). Theorem bounded_min_d n : (forall x, x < n -> P x \/ Q x) -> (exists x, x < n /\ P x /\ forall y, y < x -> Q y) \/ forall x, x < n -> Q x. Proof. induction n as [ | n IHn ]; intros Hn. + right; intros; lia. + destruct IHn as [ (x & H1 & H2 & H3) | H1 ]. * intros; apply Hn; lia. * left; exists x; msplit 2; auto; lia. * destruct (Hn n); auto. - left; exists n; msplit 2; auto. - right; intros x Hx. destruct (eq_nat_dec x n); subst; auto. apply H1; lia. Qed.End bounded_min.Section list_choose_dep. Variable (X : Type) (P Q : X -> Prop). Theorem list_choose_dep l : (forall x, In x l -> { P x } + { Q x }) -> { x | In x l /\ P x } + { forall x, In x l -> Q x }. 
(ident * typ)) (fields : list typ), (forall (f : typ), In f fields -> sized_typ defs f) -> (forall (f : typ), In f fields -> guarded_wf_typ defs f) -> guarded_wf_typ defs (TYPE_Struct fields)| guarded_wf_typ_Packed_struct : forall (defs : list (ident * typ)) (fields : list typ), (forall (f : typ), In f fields -> sized_typ defs f) -> (forall (f : typ), In f fields -> guarded_wf_typ defs f) -> guarded_wf_typ defs (TYPE_Packed_struct fields)| guarded_wf_typ_Opaque : forall (defs : list (ident * typ)), guarded_wf_typ defs TYPE_Opaque .Hint Constructors guarded_wf_typ. Theorem wf_typ_is_guarded_wf_typ : forall env t, wf_typ env t -> guarded_wf_typ env t. Proof. induction 1; auto. Qed.Inductive unrolled_typ : typ -> Prop := | unrolled_typ_I : forall (sz : N), unrolled_typ (TYPE_I sz)| unrolled_typ_Pointer : forall (t : typ), unrolled_typ (TYPE_Pointer t)| unrolled_typ_Void : unrolled_typ TYPE_Void| unrolled_typ_Half : unrolled_typ TYPE_Half| unrolled_typ_Float : unrolled_typ TYPE_Float| unrolled_typ_Double : unrolled_typ TYPE_Double| unrolled_typ_X86_fp80 : unrolled_typ TYPE_X86_fp80| unrolled_typ_Fp128 : unrolled_typ TYPE_Fp128| unrolled_typ_Ppc_fp128 : unrolled_typ TYPE_Ppc_fp128| unrolled_typ_Metadata : unrolled_typ TYPE_Metadata| unrolled_typ_X86_mmx : unrolled_typ TYPE_X86_mmx| unrolled_typ_Array : forall (sz : N) (t : typ), unrolled_typ t -> unrolled_typ (TYPE_Array sz t)| unrolled_typ_Function : forall (ret : typ) (args : list typ), unrolled_typ ret -> Forall unrolled_typ args -> unrolled_typ (TYPE_Function ret args)| unrolled_typ_Struct : forall (fields : list typ), Forall (unrolled_typ) fields -> unrolled_typ (TYPE_Struct fields)| unrolled_typ_Packed_struct : forall (fields : list typ), Forall (unrolled_typ) fields -> unrolled_typ (TYPE_Packed_struct fields)| unrolled_typ_Opaque : unrolled_typ TYPE_Opaque| unrolled_typ_Vector : forall (sz : N) (t : typ), unrolled_typ (TYPE_Vector sz t) . Inductive typ_order : typ -> typ -> Prop := | typ_order_Pointer : forall (t : typ), typ_order t (TYPE_Pointer t) | typ_order_Array : forall (sz : N) (t : typ), typ_order t (TYPE_Array sz t) | typ_order_Vector : forall (sz : N) (t : typ), typ_order t (TYPE_Vector sz t) | typ_order_Struct : forall (fields : list typ), forall f, In f fields -> typ_order f (TYPE_Struct fields) | typ_order_Packed_struct : forall (fields : list typ), forall f, In f fields -> typ_order f (TYPE_Packed_struct fields) | typ_order_Function_args : forall (ret : typ) (args : list typ), forall a, In a args -> typ_order a (TYPE_Function ret args) | typ_order_Function_ret : forall (ret : typ) (args : list typ), typ_order ret (TYPE_Function ret args) . Hint Constructors typ_order. Theorem wf_typ_order : well_founded typ_order. Proof. unfold well_founded. induction a; constructor; intros y H'; inversion H'; subst; auto. Qed. Theorem wf_lt_typ_order : well_founded (lex_ord lt typ_order). 
H1; Contradict H; apply Zle_not_lt. apply le_IZR; auto. Qed. Hint Resolve Rlt_IZR: real. Theorem Rle_IZR : forall x y : Z, (x <= y)%Z -> (IZR x <= IZR y)%R. intros x y H'. case (Zle_lt_or_eq _ _ H'); clear H'; intros H'. apply Rlt_le; auto with real. rewrite <- H'; auto with real. Qed. Hint Resolve Rle_IZR: real. Theorem Rlt_IZRO : forall p : Z, (0 < p)%Z -> (0 < IZR p)%R. intros p H; replace 0%R with (IZR 0); auto with real. Qed. Hint Resolve Rlt_IZRO: real. Theorem Rle_IZRO : forall x y : Z, (0 <= y)%Z -> (0 <= IZR y)%R. intros; replace 0%R with (IZR 0); auto with real. Qed. Hint Resolve Rle_IZRO: real. Theorem Rlt_IZR1 : forall p q : Z, (1 < q)%Z -> (1 < IZR q)%R. intros; replace 1%R with (IZR 1); auto with real. Qed. Hint Resolve Rlt_IZR1: real. Theorem Rle_IZR1 : forall x y : Z, (1 <= y)%Z -> (1 <= IZR y)%R. intros; replace 1%R with (IZR 1); auto with real. Qed. Hint Resolve Rle_IZR1: real. Theorem lt_Rlt : forall n m : nat, (INR n < INR m)%R -> n < m. intros n m H'; case (le_or_lt m n); auto; intros H0; Contradict H'; auto with real. case (le_lt_or_eq _ _ H0); intros H1; auto with real. rewrite H1; apply Rlt_irrefl. Qed. Theorem INR_inv : forall n m : nat, INR n = INR m -> n = m. intros n; elim n; auto; try rewrite S_INR. intros m; case m; auto. intros m' H1; Contradict H1; auto. rewrite S_INR. apply Rlt_dichotomy_converse; left. apply Rle_lt_0_plus_1. apply pos_INR. intros n' H' m; case m. intros H'0; Contradict H'0; auto. rewrite S_INR. apply Rlt_dichotomy_converse; right. red in |- *; apply Rle_lt_0_plus_1. apply pos_INR. intros m' H'0. rewrite (H' m'); auto. repeat rewrite S_INR in H'0. apply Rplus_eq_reg_l with (r := 1%R); repeat rewrite (Rplus_comm 1); auto with real. Qed. Theorem Rle_INR : forall x y : nat, x <= y -> (INR x <= INR y)%R. intros x y H; repeat rewrite INR_IZR_INZ. apply Rle_IZR; auto with zarith. Qed. Hint Resolve Rle_INR: real. Theorem le_Rle : forall n m : nat, (INR n <= INR m)%R -> n <= m. intros n m H'; case H'; auto. intros H'0; apply lt_le_weak; apply lt_Rlt; auto. intros H'0; rewrite <- (INR_inv _ _ H'0); auto with arith. Qed. Theorem Rmult_IZR : forall z t : Z, IZR (z * t) = (IZR z * IZR t)%R. 
<- (digit_abs radix (Fnum x)). case (Fnum x); simpl in |- *; auto. Qed. Definition Fabs (x : float) := Float (Zabs (Fnum x)) (Fexp x). Theorem Fabs_correct1 : forall x : float, (0 <= FtoR radix x)%R -> Fabs x = x :>R. intros x; case x; unfold FtoRradix, FtoR in |- *; simpl in |- *. intros Fnum1 Fexp1 H'. repeat rewrite <- (Rmult_comm (powerRZ radix Fexp1)); apply Rmult_eq_compat_l; auto. cut (0 <= Fnum1)%Z. unfold Zabs, Zle in |- *. case Fnum1; simpl in |- *; auto. intros p H'0; case H'0; auto. apply Znot_gt_le; auto. Contradict H'. apply Rgt_not_le; auto. rewrite Rmult_comm. replace 0%R with (powerRZ radix Fexp1 * 0)%R; auto with real. red in |- *; apply Rmult_lt_compat_l; auto with real zarith. Qed. Theorem Fabs_correct2 : forall x : float, (FtoR radix x <= 0)%R -> Fabs x = (- x)%R :>R. intros x; case x; unfold FtoRradix, FtoR in |- *; simpl in |- *. intros Fnum1 Fexp1 H'. rewrite <- Ropp_mult_distr_l_reverse; repeat rewrite <- (Rmult_comm (powerRZ radix Fexp1)); apply Rmult_eq_compat_l; auto. cut (Fnum1 <= 0)%Z. unfold Zabs, Zle in |- *. case Fnum1; unfold IZR; auto with real. intros p H'0; case H'0; auto. apply Znot_gt_le. Contradict H'. apply Rgt_not_le; auto. rewrite Rmult_comm. replace 0%R with (powerRZ radix Fexp1 * 0)%R; auto with real. red in |- *; apply Rmult_lt_compat_l; auto with real arith. replace 0%R with (IZR 0); auto with real zarith arith. Qed. Theorem Fabs_correct : forall x : float, Fabs x = Rabs x :>R. intros x; unfold Rabs in |- *. case (Rcase_abs x); intros H1. unfold FtoRradix in |- *; apply Fabs_correct2; auto with arith. apply Rlt_le; auto. unfold FtoRradix in |- *; apply Fabs_correct1; auto with arith. apply Rge_le; auto. Qed. Theorem RleFexpFabs : forall p : float, p <> 0%R :>R -> (Float 1%nat (Fexp p) <= Fabs p)%R. intros p H'. unfold FtoRradix, FtoR, Fabs in |- *; simpl in |- *. apply Rmult_le_compat_r; auto with real arith. rewrite Zabs_absolu. replace 1%R with (INR 1); auto with real. repeat rewrite <- INR_IZR_INZ; apply Rle_INR; auto. cut (Zabs_nat (Fnum p) <> 0); auto with zarith. Contradict H'. unfold FtoRradix, FtoR in |- *; simpl in |- *. replace (Fnum p) with 0%Z; try (simpl;ring). generalize H'; case (Fnum p); simpl in |- *; auto with zarith arith; intros p0 H'3; Contradict H'3; auto with zarith arith. Qed. Theorem Fabs_Fzero : forall x : float, ~ is_Fzero x -> ~ is_Fzero (Fabs x). 
Require Import List Crush. Import ListNotations.Set Implicit Arguments.Section TwoStackQueue. Parameter A : Type. Definition stack := list. Definition queue : Type := (stack A * stack A) % type. Definition IsQueue (q : queue) : Prop := match q with | ([], []) => True | ([], _) => False | _ => True end. Definition AbsRelate (q : queue) (l : list A) := match q with | (xs, ys) => xs ++ rev ys = l end. Definition empty : queue := ([], []). Definition is_empty (q : queue) : bool := match q with | ([], _) => true | _ => false end. Definition front (q : queue) : option A := match q with | ([], _) => None | (x :: xs, _) => Some x end. Definition enque (x : A) (q : queue) : queue := match q with | ([], _) => ([x], []) | (ys, xs) => (ys, x :: xs) end. Definition deque (q : queue) : queue := match q with | ([], _) => ([], []) | ([x], ys) => (rev ys, []) | (x :: xs, ys) => (xs, ys) end. Ltac break_match := match goal with | [ H : context [ match ?X with _ => _ end ] |- _ ] => destruct X eqn:? | [ |- context [ match ?X with _ => _ end ] ] => destruct X eqn:? end. Ltac break_queue := match goal with | [ q : queue |- _ ] => destruct q end. Ltac breaker := repeat (break_match || break_queue). Ltac crush := repeat (crush' false fail; breaker); crush' false fail. Theorem IsQueue_empty : IsQueue empty. Proof. crush. Qed. Theorem IsQueue_enque : forall (q : queue) (x : A), IsQueue q -> IsQueue (enque x q). Proof. crush. Qed. Theorem IsQueue_deque : forall (q : queue), IsQueue q -> IsQueue (deque q). Proof. crush. Qed. Theorem AbsRelate_empty : AbsRelate empty []. Proof. crush. Qed. Theorem AbsRelate_front0 : forall (q : queue), AbsRelate q [] -> front q = None. Proof. crush. Qed. Theorem AbsRelate_front : forall (q : queue) (x : A) (xs : list A), IsQueue q -> AbsRelate q (x :: xs) -> front q = Some x. Proof. crush. Qed. Theorem AbsRelate_enque : forall (q : queue) (x : A) (xs : list A), IsQueue q -> AbsRelate q xs -> AbsRelate (enque x q) (xs ++ [x]). 
v). intro; apply H1. apply Free_Ecase3. auto. apply H in H2. apply H0 in H3. inv H2. inv H3. left. inv H2. rewrite H8. eapply num_occur_n. constructor. constructor. apply H4. apply H7. simpl. destruct (cps_util.var_dec v v0). inv H8. auto. right. apply bound_var_Ecase_cons. right; auto. right. apply bound_var_Ecase_cons. auto. - destruct (var_dec v0 v). right; subst; constructor. assert (~ occurs_free e v). intro; apply H0. constructor. auto. auto. apply H in H1. destruct H1. left. eapply num_occur_n. constructor; eauto. simpl. destruct (cps_util.var_dec v v1). exfalso; apply H0; subst; constructor. auto. right; auto. - destruct (var_dec x v). + right. subst. constructor. + assert (~ List.In v (f :: ys)). { intros Hc. eapply H0; eauto. } assert (~ (occurs_free e) v). { intro; apply H0. eapply Free_Eletapp2; eauto. } eapply H in H2. inv H2. left. apply not_occur_list_not_in in H1. eapply num_occur_n. constructor; eauto. lia. right. econstructor. eassumption. - assert ( ~ occurs_free_fundefs f2 v). intro. apply H1. apply Free_Efun2. auto. assert (Hf2 := Decidable_name_in_fundefs f2). destruct Hf2. specialize (Dec v). destruct Dec as [Hin | Hnin]. + right. constructor. apply name_in_fundefs_bound_var_fundefs. auto. + assert (~ occurs_free e v). intro. apply H1. constructor; auto. apply H0 in H3. apply H in H2. inv H3. inv H2. left. eapply num_occur_n. constructor; eauto. auto. right; auto. right; auto. - left. eapply num_occur_n. constructor. simpl. destruct (cps_util.var_dec v v0). exfalso; apply H; subst; auto. apply not_occur_list_not_in. intro; apply H. constructor. auto. - destruct (var_dec v0 v). + right. subst. constructor. + assert (~ List.In v l). intro; apply H0. constructor; auto. assert (~ (occurs_free e) v). intro; apply H0. apply Free_Eprim2; auto. apply H in H2. inv H2. left. apply not_occur_list_not_in in H1. eapply num_occur_n. constructor. apply H3. rewrite H1. auto. right. apply bound_var_Eprim. left; auto. - left. eapply num_occur_n. constructor. simpl. destruct (cps_util.var_dec v v0). exfalso; apply H; subst; auto. auto. - destruct (var_dec v0 v). right; subst; auto. assert (Hl := Decidable_FromList l). inv Hl. specialize (Dec v). inv Dec. right. constructor. right; auto. assert (Hf5 := Decidable_name_in_fundefs f5). destruct Hf5; specialize (Dec v); inv Dec. right. constructor 2. apply name_in_fundefs_bound_var_fundefs. auto. assert (~ occurs_free e v). intro; apply H1. constructor; auto. apply H in H4. assert (~ occurs_free_fundefs f5 v). intro; apply H1. constructor 2; auto. apply H0 in H5. destruct H4. destruct H5. left. eapply num_occur_fds_n. constructor; eauto. auto. right. constructor 2. auto. right. auto. - left; constructor. Qed. Theorem Disjoint_Setminus_swap: forall {A} s1 s2 s3, Disjoint A (Setminus _ s1 s2) s3 <-> Disjoint A s1 (Setminus _ s3 s2). 
Ftop fsxp sm' mscs' ts' ds']] * [[ ds' = dsupd_iter ds bnl (combine new_blocks (map vsmerge old_blocks)) ]] * [[ ts' = tsupd_iter ts pathname block_off (combine new_blocks (map vsmerge old_blocks)) ]] * [[ treeseq_pred (treeseq_safe pathname (MSAlloc mscs) (ts' !!)) ts' ]] * [[ (Ftree * pathname |-> File inum f')%pred (dir2flatmem2 (TStree ts' !!)) ]] XCRASH:hm' exists i ds' ts' mscs' sm' bnl, let new_blocks := map list2valu (list_split_chunk i valubytes (firstn (i * valubytes) data)) in let old_blocks := get_sublist (DFData f) block_off i in LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds' hm' * [[ i <= num_of_full_blocks ]] * [[ ds' = dsupd_iter ds bnl (combine new_blocks (map vsmerge old_blocks)) ]] * [[ ts' = tsupd_iter ts pathname block_off (combine new_blocks (map vsmerge old_blocks)) ]] * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds' ]] * [[ length bnl = i ]] * [[ MSAlloc mscs' = MSAlloc mscs ]] >} dwrite_middle_blocks fsxp inum mscs block_off num_of_full_blocks data. Proof. unfold dwrite_middle_blocks; safestep. 3: instantiate (1:= nil). 3: instantiate (1:= ds). 9: rewrite <- plus_n_O. eauto. eauto. eauto. eauto. eauto. eauto. eauto. eauto. pred_apply; cancel. eauto. eauto. eauto. - safestep. eauto. eauto. eauto. eauto. pred_apply. rewrite <- plus_n_O. rewrite arrayN_split with (i:= valubytes) (a:= (skipn (length bnl * valubytes) old_data)) at 1. instantiate (1:= nil). instantiate (3:= nil). simpl; cancel. solve_ineq_dwrite_middle. solve_ineq_dwrite_middle. solve_ineq_dwrite_middle. auto. rewrite get_sublist_length at 2; auto;[| solve_ineq_dwrite_middle]. replace (valubytes - valubytes) with 0 by omega. rewrite Nat.min_0_r; auto. + step. solve_dsupd_iter. solve_tsupd_iter. length_rewrite_l. solve_cancel_dwrite_middle block_off bnl. + subst; repeat xcrash_rewrite; xform_norm; cancel; xform_normr. * unfold pimpl; intros; repeat apply sep_star_lift_apply'; [eauto | apply Nat.lt_le_incl; eauto | | | | | ]. all: eauto. * unfold pimpl; intros. repeat apply sep_star_lift_apply'. 5: eauto. all: eauto. solve_dsupd_iter. solve_tsupd_iter. length_rewrite_l. - step; [rewrite <- H5; rewrite firstn_exact; rewrite <- H6; rewrite firstn_exact; rewrite skipn_exact; simpl; cancel | rewrite <- H5; rewrite firstn_exact; auto | rewrite <- H5; rewrite firstn_exact; auto]. - instantiate (1:= LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) _ hm). unfold pimpl; intros m' Hy. apply sep_star_lift_apply in Hy as Hx. destruct Hx as [Hz Hx0]. clear Hz; pred_apply. split_hypothesis. subst; repeat xcrash_rewrite; xform_norm; cancel; xform_normr. rewrite LOG.idempred_hashmap_subset; [| eauto]. safecancel. 4: eauto. instantiate (1:= 0); omega. instantiate (1:= nil). simpl; auto. simpl; auto. all: eauto. Unshelve. constructor. Qed.Hint Extern 1 ({{_}} Bind (dwrite_middle_blocks _ _ _ _ _ _) _) => apply dwrite_middle_blocks_ok : prog. Theorem dwrite_last_ok : forall fsxp inum block_off data mscs, {< ds sm Fd Fm Ftop Ftree ts pathname f fy old_data tail_data, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[ treeseq_in_ds Fm Ftop fsxp sm mscs ts ds ]] * [[ treeseq_pred (treeseq_safe pathname (MSAlloc mscs) (ts !!)) ts ]] * [[ (Ftree * pathname |-> File inum f)%pred (dir2flatmem2 (TStree ts!!)) ]] * [[ AByteFile.rep f fy ]] * [[[ (ByFData fy) ::: (Fd * arrayN (ptsto (V:=byteset)) (block_off * valubytes) old_data * arrayN (ptsto (V:=byteset)) (block_off * valubytes + length old_data) tail_data)]]] * [[ length old_data = length data]] * [[ length data < valubytes ]] * [[ min (length (ByFData fy) - (block_off * valubytes + length data)) (valubytes - length data) = length tail_data ]] POST:hm' RET:^(mscs') exists bn fy' f' ds' ts' sm', let old_blocks := selN (DFData f) block_off valuset0 in let tail_pad := skipn (length data) (valu2list (fst old_blocks))in let new_block := list2valu (data ++ tail_pad) in ([[ length data = 0 ]] * LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm) \/ (LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds') (MSLL mscs') sm' hm' * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds']] * [[ (Ftree * pathname |-> File inum f')%pred (dir2flatmem2 (TStree ts' !!)) ]] * [[ ds' = dsupd ds bn (new_block, vsmerge old_blocks) ]] * [[ ts' = tsupd ts pathname block_off (new_block, vsmerge old_blocks) ]] * [[ AByteFile.rep f' fy' ]] * [[[ (ByFData fy') ::: (Fd * arrayN (ptsto (V:=byteset)) (block_off * valubytes) (merge_bs data old_data) * arrayN (ptsto (V:=byteset)) (block_off * valubytes + length data) (merge_bs (map fst tail_data) tail_data))]]] * [[ ByFAttr fy = ByFAttr fy' ]] * [[ treeseq_pred (treeseq_safe pathname (MSAlloc mscs) (ts' !!)) ts' ]] * [[ MSAlloc mscs' = MSAlloc mscs ]])XCRASH:hm' LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' \/ exists bn ds' ts' mscs' sm', let old_blocks := selN (DFData f) block_off valuset0 in let tail_pad := skipn (length data) (valu2list (fst old_blocks))in let new_block := list2valu (data ++ tail_pad) in LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds' hm' * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds']] * [[ ds' = dsupd ds bn (new_block, vsmerge old_blocks) ]] * [[ ts' = tsupd ts pathname block_off (new_block, vsmerge old_blocks) ]] * [[ MSAlloc mscs' = MSAlloc mscs ]] >} dwrite_last fsxp inum mscs block_off data. 
auto. do 6 (destruct f; auto). destruct l0; auto. destruct e0; auto. do 7 (destruct f; auto). do 2 (destruct l1; auto). destruct l0; auto. replace (nth_error funcs 4) with (Some (ILEnv.wlt_r types)) by (unfold funcs, Array.funcs; erewrite repr_nth_error; reflexivity). match goal with | [ |- match ?E with None => _ | Some _ => _ end ] => let E' := eval simpl in E in change E with E' end. case_eq (exprD funcs uvars vars e wordT); intuition. case_eq (exprD funcs uvars vars e0 wordT); intuition. destruct e0; auto. do 6 (destruct f; auto). destruct l; auto. destruct e0; auto. do 7 (destruct f; auto). do 2 (destruct l0; auto). destruct l; auto. simpl in H0. specialize (deupd_correct uvars vars (sz := size e0) e0). assert (size e0 <= size e0)%nat by auto; intuition. destruct (exprD funcs uvars vars e0 listWT); try discriminate. destruct (exprD funcs uvars vars (deupd e0) listWT); try tauto. do 2 esplit; eauto. do 2 esplit; eauto. injection H0; clear H0; intros; subst. rewrite H3. reflexivity. Qed. Section vars. Variables uvars vars : env types. Definition pairValid (p : expr types * expr types) := exists i, exprD funcs uvars vars (fst p) wordT = Some i /\ exists a, exprD funcs uvars vars (snd p) listWT = Some a /\ i < $ (length a). Definition boundValid (summ : boundSummary) := List.Forall pairValid summ. Theorem boundLearn1Correct : forall sum, boundValid sum -> forall hyp, Provable funcs uvars vars hyp -> boundValid (boundLearn1 sum hyp). Proof. unfold Provable, boundLearn1, boundValid; intros. specialize (factIn_correct uvars vars hyp). destruct (exprD funcs uvars vars hyp tvProp); try tauto. destruct (factIn hyp); intuition. destruct p. do 2 destruct H1. do 2 destruct H2. subst. unfold pairValid. constructor; eauto. Qed. Hint Resolve boundLearn1Correct. Theorem boundLearnCorrect : forall sum, boundValid sum -> forall hyps, AllProvable funcs uvars vars hyps -> boundValid (boundLearn sum hyps). Proof. induction hyps; simpl; intuition. Qed. Theorem boundSummarizeCorrect : forall hyps, AllProvable funcs uvars vars hyps -> boundValid (boundSummarize hyps). intros; apply boundLearnCorrect; hnf; auto. Qed. Lemma hypMatchesCorrect : forall p sum, boundValid sum -> hypMatches p sum = true -> pairValid p. induction sum as [ | [ ] ]; simpl; intuition. apply orb_prop in H0; intuition. apply andb_prop in H1; intuition. apply expr_seq_dec_correct in H0. apply expr_seq_dec_correct in H2. subst. inversion H; auto. inversion H; auto. Qed. End vars. Hint Resolve boundLearnCorrect boundSummarizeCorrect. Theorem boundProverCorrect : ProverCorrect funcs boundValid boundProve. 
Œ±}. Proof with eauto. intros Œ± Hlim. assert (H := Hlim). destruct H as [HoŒ± _]. apply sub_antisym; intros x Hx. - apply V_elim in Hx as [Œ≤ [HŒ≤ Hx]]... rewrite <- V_suc in Hx; [|eapply ord_is_ords]... eapply FUnionI; revgoals... apply sucord_in_limord... - apply FUnionE in Hx as [Œ≤ [HŒ≤ Hx]]. eapply V_sub... Qed. Definition grounded := Œª x, ‚àÉŒ± ‚ãµ ùêéùêç, x ‚äÜ V Œ±. Notation ùêñùê := grounded.Definition rank_spec := Œª A Œ±, Œ± ‚ãµ ùêéùêç ‚àß A ‚äÜ V Œ± ‚àß ‚àÄŒ≤ ‚ãµ ùêéùêç, A ‚äÜ V Œ≤ ‚Üí Œ± ‚ã∏ Œ≤.Lemma rank_exists : ‚àÄA ‚ãµ ùêñùê , ‚àÉ! Œ±, rank_spec A Œ±. Proof with eauto; try congruence. intros A [Œ± [HoŒ± HsubŒ±]]. set {Œæ ‚àä Œ±‚Å∫ | A ‚äÜ V Œæ} as B. destruct (ords_woset B) as [_ Hmin]. { intros x Hx. apply SepE1 in Hx. eapply ord_is_ords; revgoals... } pose proof (Hmin B) as [Œº [HŒº Hle]]... { exists Œ±. apply SepI... } apply SepE in HŒº as [HŒº HsubŒº]. assert (HoŒº: Œº ‚ãµ ùêéùêç). { eapply ord_is_ords; revgoals... } rewrite <- unique_existence. split. - exists Œº. repeat split... intros Œ≤ HoŒ≤ HsubŒ≤. apply ord_le_iff_not_gt... intros HŒ≤. assert (Œ≤ ‚àà B). { apply SepI... eapply ord_trans... } apply Hle in H as []. + apply binRelE3 in H. eapply ord_not_lt_gt; revgoals... + eapply ord_not_lt_self... - intros a b [Ha [H11 H12]] [Hb [H21 H22]]. apply H12 in H21... apply H22 in H11... apply ord_le_iff_sub in H11... apply ord_le_iff_sub in H21... apply sub_antisym... Qed. Definition rank := Œª A, describe (rank_spec A).Lemma rank_spec_intro : ‚àÄA ‚ãµ ùêñùê , rank_spec A (rank A). Proof. intros A Hgnd. apply (desc_spec (rank_spec A)). apply rank_exists. apply Hgnd. Qed. Lemma rank_is_ord : ‚àÄ A, A ‚ãµ ùêñùê ‚Üí rank A ‚ãµ ùêéùêç. Proof. intros A Hgnd. apply rank_spec_intro. apply Hgnd. Qed. Global Hint Immediate rank_is_ord : core.Lemma grounded_in_rank : ‚àÄA ‚ãµ ùêñùê , A ‚äÜ V (rank A). Proof. intros A Hgnd. apply rank_spec_intro. apply Hgnd. Qed.Lemma grounded_under_rank : ‚àÄA ‚ãµ ùêñùê , A ‚àà V (rank A)‚Å∫. Proof with auto. intros A Hgnd. rewrite V_suc... apply PowerAx. apply grounded_in_rank... Qed. Theorem member_grounded : ‚àÄA ‚ãµ ùêñùê , A ‚™Ω ùêñùê . Proof with eauto. intros A Hgnd a Ha. apply grounded_in_rank in Hgnd as HA. apply HA in Ha. apply V_elim in Ha as [Œ≤ [HŒ≤ Ha]]... apply PowerAx in Ha. exists Œ≤. split... eapply ord_is_ords; revgoals... Qed. Theorem rank_of_member : ‚àÄA ‚ãµ ùêñùê , ‚àÄa ‚àà A, rank a ‚àà rank A. 
(id, t) defs -> guarded_wf_typ defs t) -> guarded_wf_typ defs (TYPE_Identified id) | guarded_wf_typ_Struct : forall (defs : list (ident * typ)) (fields : list typ), (forall (f : typ), In f fields -> sized_typ defs f) -> (forall (f : typ), In f fields -> guarded_wf_typ defs f) -> guarded_wf_typ defs (TYPE_Struct fields)| guarded_wf_typ_Packed_struct : forall (defs : list (ident * typ)) (fields : list typ), (forall (f : typ), In f fields -> sized_typ defs f) -> (forall (f : typ), In f fields -> guarded_wf_typ defs f) -> guarded_wf_typ defs (TYPE_Packed_struct fields)| guarded_wf_typ_Opaque : forall (defs : list (ident * typ)), guarded_wf_typ defs TYPE_Opaque .Hint Constructors guarded_wf_typ. Theorem wf_typ_is_guarded_wf_typ : forall env t, wf_typ env t -> guarded_wf_typ env t. Proof. induction 1; auto. Qed.Inductive unrolled_typ : typ -> Prop := | unrolled_typ_I : forall (sz : N), unrolled_typ (TYPE_I sz)| unrolled_typ_Pointer : forall (t : typ), unrolled_typ (TYPE_Pointer t)| unrolled_typ_Void : unrolled_typ TYPE_Void| unrolled_typ_Half : unrolled_typ TYPE_Half| unrolled_typ_Float : unrolled_typ TYPE_Float| unrolled_typ_Double : unrolled_typ TYPE_Double| unrolled_typ_X86_fp80 : unrolled_typ TYPE_X86_fp80| unrolled_typ_Fp128 : unrolled_typ TYPE_Fp128| unrolled_typ_Ppc_fp128 : unrolled_typ TYPE_Ppc_fp128| unrolled_typ_Metadata : unrolled_typ TYPE_Metadata| unrolled_typ_X86_mmx : unrolled_typ TYPE_X86_mmx| unrolled_typ_Array : forall (sz : N) (t : typ), unrolled_typ t -> unrolled_typ (TYPE_Array sz t)| unrolled_typ_Function : forall (ret : typ) (args : list typ), unrolled_typ ret -> Forall unrolled_typ args -> unrolled_typ (TYPE_Function ret args)| unrolled_typ_Struct : forall (fields : list typ), Forall (unrolled_typ) fields -> unrolled_typ (TYPE_Struct fields)| unrolled_typ_Packed_struct : forall (fields : list typ), Forall (unrolled_typ) fields -> unrolled_typ (TYPE_Packed_struct fields)| unrolled_typ_Opaque : unrolled_typ TYPE_Opaque| unrolled_typ_Vector : forall (sz : N) (t : typ), unrolled_typ (TYPE_Vector sz t) . Inductive typ_order : typ -> typ -> Prop := | typ_order_Pointer : forall (t : typ), typ_order t (TYPE_Pointer t) | typ_order_Array : forall (sz : N) (t : typ), typ_order t (TYPE_Array sz t) | typ_order_Vector : forall (sz : N) (t : typ), typ_order t (TYPE_Vector sz t) | typ_order_Struct : forall (fields : list typ), forall f, In f fields -> typ_order f (TYPE_Struct fields) | typ_order_Packed_struct : forall (fields : list typ), forall f, In f fields -> typ_order f (TYPE_Packed_struct fields) | typ_order_Function_args : forall (ret : typ) (args : list typ), forall a, In a args -> typ_order a (TYPE_Function ret args) | typ_order_Function_ret : forall (ret : typ) (args : list typ), typ_order ret (TYPE_Function ret args) . Hint Constructors typ_order. Theorem wf_typ_order : well_founded typ_order. 
x... now apply He, Rgt_not_eq. now rewrite <- d_eq, Y. rewrite u_eq, round_UP_small_pos with (ex:=e); trivial. 2: now apply He, Rgt_not_eq. rewrite ln_beta_bpow. ring_simplify (fexp e + 1 - 1)%Z. replace (fexp (fexp e)) with (fexp e). case exists_NE_; intros V. contradict V; rewrite Even_beta; discriminate. rewrite (proj2 (V e)); omega. apply sym_eq, valid_exp; omega. Qed.Lemma Fm: generic_format beta fexpe m. case (d_ge_0); intros Y.destruct m_eq as (g,(Hg1,Hg2)); trivial. apply generic_format_F2R' with g. now apply sym_eq. intros H; unfold canonic_exp; rewrite Hg2. rewrite ln_beta_m; trivial. rewrite <- Fexp_d; trivial. rewrite Cd. unfold canonic_exp. generalize (fexpe_fexp (ln_beta beta (F2R d))). omega.destruct m_eq_0 as (g,(Hg1,Hg2)); trivial. apply generic_format_F2R' with g. assumption. intros H; unfold canonic_exp; rewrite Hg2. rewrite ln_beta_m_0; try assumption. apply Zle_trans with (1:=fexpe_fexp _). assert (fexp (ln_beta beta (F2R u)-1) < fexp (ln_beta beta (F2R u))+1)%Z;[idtac|omega]. now apply fexp_m_eq_0. Qed.Lemma Zm: exists g : float beta, F2R g = m /\ canonic beta fexpe g /\ Zeven (Fnum g) = true. Proof with auto with typeclass_instances. case (d_ge_0); intros Y.destruct m_eq as (g,(Hg1,Hg2)); trivial. apply exists_even_fexp_lt. exists g; split; trivial. rewrite Hg2. rewrite ln_beta_m; trivial. rewrite <- Fexp_d; trivial. rewrite Cd. unfold canonic_exp. generalize (fexpe_fexp (ln_beta beta (F2R d))). omega.destruct m_eq_0 as (g,(Hg1,Hg2)); trivial. apply exists_even_fexp_lt. exists g; split; trivial. rewrite Hg2. rewrite ln_beta_m_0; trivial. apply Zle_lt_trans with (1:=fexpe_fexp _). assert (fexp (ln_beta beta (F2R u)-1) < fexp (ln_beta beta (F2R u))+1)%Z;[idtac|omega]. now apply fexp_m_eq_0. Qed. Lemma DN_odd_d_aux: forall z, (F2R d<= z< F2R u)%R -> Rnd_DN_pt (generic_format beta fexp) z (F2R d). Proof with auto with typeclass_instances. intros z Hz1. replace (F2R d) with (round beta fexp Zfloor z). apply round_DN_pt... case (Rnd_DN_UP_pt_split _ _ _ _ Hd Hu (round beta fexp Zfloor z)). apply generic_format_round... intros Y; apply Rle_antisym; trivial. apply round_DN_pt... apply Hd. apply Hz1. intros Y; absurd (z < z)%R. auto with real. apply Rlt_le_trans with (1:=proj2 Hz1), Rle_trans with (1:=Y). apply round_DN_pt... Qed.Lemma UP_odd_d_aux: forall z, (F2R d< z <= F2R u)%R -> Rnd_UP_pt (generic_format beta fexp) z (F2R u). Proof with auto with typeclass_instances. intros z Hz1. replace (F2R u) with (round beta fexp Zceil z). apply round_UP_pt... case (Rnd_DN_UP_pt_split _ _ _ _ Hd Hu (round beta fexp Zceil z)). apply generic_format_round... intros Y; absurd (z < z)%R. auto with real. apply Rle_lt_trans with (2:=proj1 Hz1), Rle_trans with (2:=Y). apply round_UP_pt... intros Y; apply Rle_antisym; trivial. apply round_UP_pt... apply Hu. apply Hz1. Qed. Theorem round_odd_prop_pos: round beta fexp (Znearest choice) (round beta fexpe Zrnd_odd x) = round beta fexp (Znearest choice) x. 
, '/ ' p ']'") : type_scope.Notation "'exists2' x , p & q" := (ex2 (fun x => p) (fun x => q)) (at level 200, x ident, p at level 200, right associativity) : type_scope. Notation "'exists2' x : A , p & q" := (ex2 (A:=A) (fun x => p) (fun x => q)) (at level 200, x ident, A at level 200, p at level 200, right associativity, format "'[' 'exists2' '/ ' x : A , '/ ' '[' p & '/' q ']' ']'") : type_scope.Notation "'exists2' ' x , p & q" := (ex2 (fun x => p) (fun x => q)) (at level 200, x strict pattern, p at level 200, right associativity) : type_scope. Notation "'exists2' ' x : A , p & q" := (ex2 (A:=A) (fun x => p) (fun x => q)) (at level 200, x strict pattern, A at level 200, p at level 200, right associativity, format "'[' 'exists2' '/ ' ' x : A , '/ ' '[' p & '/' q ']' ']'") : type_scope.Section universal_quantification. Variable A : Type. Variable P : A -> Prop. Theorem inst : forall x:A, all (fun x => P x) -> P x. Proof. unfold all; auto. Qed. Theorem gen : forall (B:Prop) (f:forall y:A, B -> P y), B -> all P. Proof. red; auto. Qed.End universal_quantification.Inductive eq (A:Type) (x:A) : A -> Prop := eq_refl : x = x :>Awhere "x = y :> A" := (@eq A x y) : type_scope.Notation "x = y" := (x = y :>_) : type_scope. Notation "x <> y :> T" := (~ x = y :>T) : type_scope. Notation "x <> y" := (x <> y :>_) : type_scope.Arguments eq {A} x _. Arguments eq_refl {A x} , [A] x.Arguments eq_ind [A] x P _ y _. Arguments eq_rec [A] x P _ y _. Arguments eq_rect [A] x P _ y _.Hint Resolve I conj or_introl or_intror : core. Hint Resolve eq_refl: core. Hint Resolve ex_intro ex_intro2: core.Section Logic_lemmas. Theorem absurd : forall A C:Prop, A -> ~ A -> C. Proof. unfold not; intros A C h1 h2. destruct (h2 h1). Qed. Section equality. Variables A B : Type. Variable f : A -> B. Variables x y z : A. Theorem eq_sym : x = y -> y = x. Proof. destruct 1; trivial. Defined. Theorem eq_trans : x = y -> y = z -> x = z. 
m m', mem_after_n_proj_store b ofs vs i m m' -> (forall j, (ofs+int_size*i) <= j < ofs+int_size*(i + Z.of_nat (length vs)) -> ~ L b j)%Z -> Mem.unchanged_on L m m'. Proof. induction vs; intros; inv H. - eapply Mem.store_unchanged_on; eauto. intros. apply H0. unfold int_size in *. simpl length. simpl Z.of_nat. chunk_red; omega. - apply Mem.unchanged_on_trans with (m2 := m'0). + eapply Mem.store_unchanged_on; eauto. intros. apply H0. simpl length. rewrite Nat2Z.inj_succ. chunk_red; omega. + eapply IHvs; eauto. intros. apply H0. simpl length. rewrite Nat2Z.inj_succ. chunk_red; omega. Qed.Theorem mem_after_n_proj_snoc_unchanged: forall L b ofs vs m m', mem_after_n_proj_snoc b ofs vs m m' -> (forall j, ofs <= j < ofs+int_size*(Z.of_nat (length vs)) -> ~ L b j)%Z -> Mem.unchanged_on L m m'. Proof. induction vs. - intros. inv H. apply Mem.unchanged_on_refl. - intros. inv H. apply Mem.unchanged_on_trans with (m2 := m'0). + apply IHvs in H5; auto. simpl length in H0. rewrite Nat2Z.inj_succ in H0. intros. apply H0. chunk_red; omega. + eapply Mem.store_unchanged_on; eauto. intros. simpl length in H0. rewrite Nat2Z.inj_succ in H0. intros. apply H0. chunk_red; omega. Qed. Definition prefix_ctx {A:Type} rho' rho := forall x v, M.get x rho' = Some v -> @M.get A x rho = Some v. Definition repr_unboxed_L7: N -> Z -> Prop := fun t => fun h => (h = (Z.shiftl (Z.of_N t) 1) + 1)%Z /\ (0 <= (Z.of_N t) < Ptrofs.half_modulus )%Z. Theorem repr_unboxed_eqm: forall h t, repr_unboxed_L7 t h -> Ptrofs.eqm h (Z.of_N ((N.shiftl t 1) + 1)). Proof. intros. inv H. rewrite OrdersEx.Z_as_DT.shiftl_mul_pow2; try omega. simpl. rewrite N.shiftl_mul_pow2. rewrite N2Z.inj_add. rewrite N2Z.inj_mul. simpl. rewrite Z.pow_pos_fold. rewrite Pos2Z.inj_pow. apply Ptrofs.eqm_refl. Qed. SearchAbout Int.max_signed. Theorem nat_shiftl_p1: forall n z, 1 < z -> n < (z / 2) -> n * 2 + 1 < z. Proof. induction n; intros. simpl. auto. simpl. destruct z. inv H0. destruct z. - inv H0. - rewrite <- Nat.div2_div in H0. simpl in H0. rewrite Nat.div2_div in H0. apply lt_S_n in H0. assert (Hz := NPeano.Nat.lt_decidable 1 z). inv Hz. specialize (IHn _ H1 H0). omega. destruct z. inv H0. inv H. destruct z. inv H0. exfalso. apply H1. omega. Qed. Theorem pos_nat_div2 : forall p, p <> xH -> Pos.to_nat (Pos.div2 p) = Nat.div2 (Pos.to_nat p). Proof. intros. destruct p0. - simpl Pos.div2. rewrite Pos2Nat.inj_xI. rewrite Nat.div2_succ_double. reflexivity. - simpl Pos.div2. rewrite Pos2Nat.inj_xO. rewrite Div2.div2_double. reflexivity. - exfalso. apply H; auto. Qed. Theorem Div2_Z_to_nat: forall n, (0 <= n)%Z -> Z.to_nat (Z.div2 n) = Nat.div2 (Z.to_nat n). 
Fexp p - Fexp q)%Z; auto with zarith. case (Fexp p - Fexp q)%Z; simpl in |- *; auto with zarith. intros p0 H'6; generalize (convert_not_O p0); auto with zarith. intros p0 H'6; discriminate. apply sym_equal; auto with float. apply sym_equal; auto with float. apply FnormalNotZero; auto with arith. unfold Fdigit in |- *; apply digit_monotone; auto with arith. repeat rewrite Zabs_eq; auto with zarith. apply LeR0Fnum with (radix := radix); auto with zarith. apply Rle_trans with (r2 := FtoRradix p); auto with real. apply LeR0Fnum with (radix := radix); auto with zarith. unfold FtoRradix in |- *; rewrite FshiftCorrect; auto. Qed. Theorem FnormalLtNeg : forall p q : float, Fnormal p -> Fnormal q -> (q <= 0)%R -> (p < q)%R -> (Fexp q < Fexp p)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z. intros p q H' H'0 H'1 H'2. cut ((Fexp (Fopp q) < Fexp (Fopp p))%Z \/ Fexp (Fopp q) = Fexp (Fopp p) /\ (Fnum (Fopp q) < Fnum (Fopp p))%Z). simpl in |- *. intros H'3; elim H'3; clear H'3; intros H'3; [ idtac | elim H'3; clear H'3; intros H'3 H'4 ]; auto; right; split; auto with zarith. apply FnormalLtPos; try apply FnormalFop; auto; unfold FtoRradix in |- *; repeat rewrite Fopp_correct; replace 0%R with (-0)%R; auto with real. Qed. Definition nNormMin := Zpower_nat radix (pred precision). Theorem nNormPos : (0 < nNormMin)%Z. unfold nNormMin in |- *; auto with zarith. Qed. Theorem digitnNormMin : digit radix nNormMin = precision. unfold nNormMin, Fdigit in |- *; simpl in |- *; apply digitInv; auto with zarith arith. rewrite Zabs_eq; auto with zarith. Qed. Theorem nNrMMimLevNum : (nNormMin <= Zpos (vNum b))%Z. rewrite pGivesBound. unfold nNormMin in |- *; simpl in |- *; auto with zarith arith. Qed. Hint Resolve nNrMMimLevNum: arith. Definition firstNormalPos := Float nNormMin (- dExp b). Theorem firstNormalPosNormal : Fnormal firstNormalPos. repeat split; unfold firstNormalPos in |- *; simpl in |- *; auto with zarith. rewrite pGivesBound. rewrite Zabs_eq; auto with zarith. unfold nNormMin in |- *; simpl in |- *; auto with zarith arith. apply Zlt_le_weak; auto with zarith. apply nNormPos. rewrite pGivesBound. replace precision with (pred precision + 1). rewrite Zpower_nat_is_exp; auto with zarith. rewrite Zpower_nat_1; auto with zarith. rewrite (fun x => Zmult_comm x radix); unfold nNormMin in |- *; auto with zarith. unfold nNormMin in |- *; auto with zarith. Qed. Theorem pNormal_absolu_min : forall p : float, Fnormal p -> (nNormMin <= Zabs (Fnum p))%Z. 
usl : set -> W -> HProp. Axiom usl'_extensional : forall s n p, HProp_extensional (usl' s n p). Axiom usl_extensional : forall s p, HProp_extensional (usl s p). Axiom usl'_set_extensional : forall n s s' p, s %= s' -> usl' s n p ===> usl' s' n p. Axiom usl_fwd : forall s p, usl s p ===> [| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r. Axiom usl_bwd : forall s p, ([| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r) ===> usl s p. Axiom nil_fwd : forall s n (p : W), p = 0 -> usl' s n p ===> [| s %= empty /\ n = O |]. Axiom nil_bwd : forall s n (p : W), p = 0 -> [| s %= empty /\ n = O |] ===> usl' s n p. Axiom cons_fwd : forall s n (p : W), p <> 0 -> usl' s n p ===> Ex n', Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| freeable p 2 /\ n = S n' /\ v %in s |]. Axiom cons_bwd : forall s n (p : W), p <> 0 -> (Ex n', Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| freeable p 2 /\ n = S n' /\ v %in s |]) ===> usl' s n p. End USL.Module Usl : USL. Open Scope Sep_scope. Fixpoint usl' (s : set) (n : nat) (p : W) : HProp := match n with | O => [| p = 0 /\ s %= empty |] | S n' => [| p <> 0 /\ freeable p 2 |] * Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| v %in s |] end. Definition usl (s : set) (p : W) := [| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r. Theorem usl'_extensional : forall s n p, HProp_extensional (usl' s n p). destruct n; reflexivity. Qed. Theorem usl_extensional : forall s p, HProp_extensional (usl s p). 
:= r <- get lxp xp ix ms; Ret r. Definition put_array lxp xp ix item ms := r <- put lxp xp ix item ms; Ret r. Definition read_array lxp xp nblocks ms := r <- read lxp xp nblocks ms; Ret r. Definition ifind_array lxp xp cond ms := r <- ifind lxp xp cond ms; Ret r. Theorem get_array_ok : forall lxp xp ix ms, {< F Fm Fi m0 sm m items e, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: Fm * rep xp items ]]] * [[[ items ::: Fi * (ix |-> e) ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[ r = e ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} get_array lxp xp ix ms. Proof. unfold get_array. hoare. eapply list2nmem_ptsto_bound; eauto. subst; apply eq_sym. eapply list2nmem_sel; eauto. Qed. Theorem put_array_ok : forall lxp xp ix e ms, {< F Fm Fi m0 sm m items e0, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ Rec.well_formed e ]] * [[[ m ::: Fm * rep xp items ]]] * [[[ items ::: Fi * (ix |-> e0) ]]] POST:hm' RET:ms' exists m' items', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms' sm hm' * [[ items' = updN items ix e ]] * [[[ m' ::: Fm * rep xp items' ]]] * [[[ items' ::: Fi * (ix |-> e) ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} put_array lxp xp ix e ms. Proof. unfold put_array. hoare. eapply list2nmem_ptsto_bound; eauto. eapply list2nmem_updN; eauto. Qed. Lemma read_array_length_ok : forall l xp Fm Fi m items nblocks, length l = nblocks * items_per_val -> (Fm * rep xp items)%pred (list2nmem m) -> (Fi * arrayN (@ptsto _ addr_eq_dec _) 0 l)%pred (list2nmem items) -> nblocks <= RALen xp. Proof. unfold rep; intuition. destruct_lift H0. unfold items_valid in *; subst; intuition. apply list2nmem_arrayN_length in H1. rewrite H, H3 in H1. eapply Nat.mul_le_mono_pos_r. apply items_per_val_gt_0. auto. Qed. Lemma read_array_list_ok : forall (l : list item) nblocks items Fi, length l = nblocks * items_per_val -> (Fi ‚ú∂ arrayN (@ptsto _ addr_eq_dec _) 0 l)%pred (list2nmem items) -> firstn (nblocks * items_per_val) items = l. Proof. intros. eapply arrayN_list2nmem in H0. rewrite <- H; simpl in *; auto. exact item0. Qed. Theorem read_array_ok : forall lxp xp nblocks ms, {< F Fm Fi m0 sm m items l, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ length l = (nblocks * items_per_val)%nat ]] * [[[ m ::: Fm * rep xp items ]]] * [[[ items ::: Fi * arrayN (@ptsto _ addr_eq_dec _) 0 l ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[ r = l ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} read_array lxp xp nblocks ms. 
Require Import Undecidability.Synthetic.Undecidability.Require Import Undecidability.SetConstraints.FMsetC. Require Undecidability.SetConstraints.Reductions.H10UC_SAT_to_FMsetC_SAT.Require Import Undecidability.DiophantineConstraints.H10C_undec. Theorem FMsetC_SAT_undec : undecidable FMsetC_SAT. 
Hle]. split... intros b Hb. apply Hle in Hb as []... apply binRelE3 in H as []... subst... - intros [Ha Hle]. split... intros b Hb. apply Hle in Hb as Han. destruct (classic (a = b)). right... left. apply binRelI... Qed. Definition po_archimedean := Œª A R, ‚àÄx ‚àà A, ‚àÉy ‚àà A, (x <·µ£ y) R. Lemma po_archimedean_iff_no_maximal : ‚àÄ A R, poset A R ‚Üí po_archimedean A R ‚Üî ¬¨ ‚àÉ m, maximal m A R. Proof with eauto; try congruence. intros A R [_ [_ [_ Hir]]]. split. - intros Harc [m [Hm Hmax]]. apply Harc in Hm as [y [Hy Hmy]]. apply Hmax in Hy as []... subst. eapply Hir... - intros Hnex x Hx. pose proof (not_ex_all_not set (Œª x, maximal x A R) Hnex). specialize H with x. apply not_and_or in H as []... apply set_not_all_ex_not in H as [y [Hy H]]. apply not_or_and in H as [H _]. exists y. split... apply NNPP in H... Qed. Definition SubRel := Œª R B, {p ‚àä R | p ‚àà B √ó B}. Notation "R ‚•è B" := (SubRel R B) (at level 60).Lemma subRel_is_binRel : ‚àÄ R B, is_binRel (R ‚•è B) B. Proof with auto. intros * p Hp. apply SepE2 in Hp... Qed.Lemma subRel_absorption : ‚àÄ R A B, B ‚äÜ A ‚Üí (R ‚•è A) ‚•è B = R ‚•è B. Proof with auto. intros * Hsub. ext Hx. - apply SepE in Hx as [Hx Hp]. apply SepE1 in Hx. apply CPrdE1 in Hp as [a [Ha [b [Hb Heq]]]]. subst x. apply SepI... apply CPrdI... - apply SepE in Hx as [Hx Hp]. apply CPrdE1 in Hp as [a [Ha [b [Hb Heq]]]]. subst x. apply SepI; [|apply CPrdI]... apply SepI... apply CPrdI; apply Hsub... Qed. Theorem subRel_poset : ‚àÄ A R B, poset A R ‚Üí B ‚äÜ A ‚Üí poset B (R ‚•è B). Proof with eauto. intros * [Hbr [_ [Htr Hir]]] Hsub. repeat split. - intros p Hp. apply SepE2 in Hp... - eapply binRel_is_rel. intros p Hp. apply SepE2 in Hp... - intros x y z Hxy Hyz. apply SepE in Hxy as [Hxy Hx]. apply CPrdE2 in Hx as [Hx _]. apply SepE in Hyz as [Hyz Hz]. apply CPrdE2 in Hz as [_ Hz]. apply SepI. eapply Htr... apply CPrdI... - intros x Hp. eapply Hir. apply SepE1 in Hp... Qed. Theorem subRel_loset : ‚àÄ A R B, loset A R ‚Üí B ‚äÜ A ‚Üí loset B (R ‚•è B). 
-> P p q -> (Rabs p <= r)%R -> (Rabs q <= r)%R. intros P p q r H' H'0 H'1 H'2. case (Rle_or_lt 0 p); intros Rl1. rewrite Rabs_right; auto with real. apply RleBoundRoundr with (P := P) (r := p); auto with real. rewrite <- (Rabs_right p); auto with real. apply Rle_ge; apply RleRoundedR0 with (P := P) (r := p); auto. rewrite Faux.Rabsolu_left1; auto. rewrite <- (Ropp_involutive r); apply Ropp_le_contravar. rewrite <- (Fopp_correct radix); auto. apply RleBoundRoundl with (P := P) (r := p); auto with float. rewrite (Fopp_correct radix); rewrite <- (Ropp_involutive p); rewrite <- (Faux.Rabsolu_left1 p); auto with real; apply Rlt_le; auto. apply RleRoundedLessR0 with (P := P) (r := p); auto; apply Rlt_le; auto. Qed. Theorem RoundAbsMonotonel : forall (P : R -> float -> Prop) (p : R) (q r : float), RoundedModeP b radix P -> Fbounded b r -> P p q -> (r <= Rabs p)%R -> (r <= Rabs q)%R. intros P p q r H' H'0 H'1 H'2. case (Rle_or_lt 0 p); intros Rl1. rewrite Rabs_right; auto. apply RleBoundRoundl with (P := P) (r := p); auto. rewrite <- (Rabs_right p); auto with real. apply Rle_ge; apply RleRoundedR0 with (P := P) (r := p); auto. rewrite Faux.Rabsolu_left1; auto. rewrite <- (Ropp_involutive r); apply Ropp_le_contravar. rewrite <- (Fopp_correct radix); auto. apply RleBoundRoundr with (P := P) (r := p); auto with float. rewrite (Fopp_correct radix); rewrite <- (Ropp_involutive p); rewrite <- (Faux.Rabsolu_left1 p); auto with real; apply Rlt_le; auto. apply RleRoundedLessR0 with (P := P) (r := p); auto; apply Rlt_le; auto. Qed. Theorem ZroundZ : forall (P : R -> float -> Prop) (z : Z) (p : float), RoundedModeP b radix P -> P z p -> exists z' : Z, p = z' :>R. intros P z p HP H'. case (RoundedModeRep b radix precision) with (P := P) (p := Float z 0%nat) (q := p); auto. cut (CompatibleP b radix P); [ intros Cp | apply RoundedModeP_inv2 with (1 := HP); auto ]; auto. apply Cp with (1 := H'); auto. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_r; auto. apply RoundedModeBounded with (P := P) (r := IZR z); auto. intros x H'0; exists x; auto. unfold FtoRradix in |- *; rewrite H'0. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_r; auto. Qed. Theorem NroundN : forall (P : R -> float -> Prop) (n : nat) (p : float), RoundedModeP b radix P -> P n p -> exists n' : nat, p = n' :>R. 
_] |- _ ] => unfold ratCD in * | [H : context[match rat0 with | RatIntro _ _ => _ end ] |- _ ] => unfold rat0 in H | [H1 : context[match ?r with | RatIntro _ _ => _ end], H2 : ?r = RatIntro _ _ |- _ ] => rewrite H2 in H1 | [H : context[match ?r with | RatIntro _ _ => _ end ] |- _ ] => case_eq r; intuition | [|- context[let (_, _) := ?x in _] ] => case_eq x; intuition | [H : context[ratAdd _ _] |- _ ] => unfold ratAdd in H | [H : context[ratMult _ _] |- _ ] => unfold ratMult in H | [H: context [eq_nat_dec ?x ?y] |- _] => destruct (eq_nat_dec x y) | [H: context [le_gt_dec ?x ?y] |- _] => destruct (le_gt_dec x y) | [|- (if (eq_nat_dec ?x ?y) then true else false) = true ] => assert (x = y); destruct (eq_nat_dec x y); trivial | [|- (if (le_gt_dec ?x ?y) then true else false) = true ] => assert (x <= y); [idtac | destruct (le_gt_dec x y); trivial] | [|- context[posnatMult _ _ ] ] => unfold posnatMult | [|- (eqRat _ _) ] => unfold eqRat, beqRat | [|- (leRat _ _) ] => unfold leRat, bleRat | [|- (posnatEq _ _ ) ] => econstructor | [|- context[(posnatToNat _)] ] => unfold posnatToNat in * | [H : context[let (_, _) := ?p in _] |- _] => destruct p end. Ltac rattac := intuition; unfold ratCD in *; repeat (rattac_one; subst); repeat rewrite mult_1_r; repeat rewrite plus_0_r; trivial; try congruence; try omega.Lemma ratCD_comm : forall r1 r2 n1 n2 d n1' n2' d', ratCD r1 r2 = (n1, n2, d) -> ratCD r2 r1 = (n1', n2', d') -> n1 = n2' /\ n1' = n2 /\ (posnatEq d d'). rattac. Qed.Infix "*" := ratMult : rat_scope. Local Open Scope rat_scope. Notation "n / d" := (RatIntro n (pos d)) : rat_scope.Notation "0" := rat0 : rat_scope. Notation "1" := rat1 : rat_scope.Infix "+" := ratAdd : rat_scope.Delimit Scope rat_scope with rat.Notation " | a - b |" := (ratDistance a%rat b%rat) (at level 30, a at next level, b at next level) : rat_scope.Infix "<=" := leRat : rat_scope. Infix "==" := eqRat (at level 70) : rat_scope. Theorem le_Rat_dec : forall r1 r2, {r1 <= r2} + {~r1 <= r2}. 
ixp dnum dmap' ilist' frees' f' ms' sm * [[ dmap' = Mem.upd dmap name (inum, isdir) ]] * [[ (Fd * name |-> (inum, isdir))%pred dmap' ]] * [[ (Fd dmap /\ notindomain name dmap) ]] * [[ BFILE.ilist_safe ilist (BFILE.pick_balloc frees (MSAlloc ms')) ilist' (BFILE.pick_balloc frees' (MSAlloc ms')) ]] * [[ BFILE.treeseq_ilist_safe dnum ilist ilist' ]] )) CRASH:hm' LOG.intact lxp F m0 sm hm' >} link lxp bxp ixp dnum name inum isdir ixhint ms. Proof. unfold link, rep_macro, rep. step. step; msalloc_eq. step. erewrite Dent.items_length_ok with (xp := f) (m := (list2nmem (BFILE.BFData f))). unfold Dent.RA.RALen. auto. pred_apply; cancel. destruct is_valid eqn:?. prestep. unfold rep_macro, rep. norm. cancel. intuition ((pred_apply; cancel) || eauto). step. or_r. cancel. eauto. eapply listpred_dmatch_notindomain; eauto. cancel. step; msalloc_eq. erewrite Dent.items_length_ok with (xp := f) (m := (list2nmem (BFILE.BFData f))). unfold Dent.RA.RALen. auto. pred_apply; cancel. cbv; tauto. step. or_r; cancel. eexists; split; eauto. apply listpred_dmatch_mem_upd; auto. rewrite Bool.negb_true_iff; auto. erewrite Dent.items_length_ok with (xp := f) (m := (list2nmem (BFILE.BFData f))). unfold Dent.RA.RALen. auto. pred_apply; cancel. eapply ptsto_upd_disjoint; auto. apply BFILE.ilist_safe_refl. apply BFILE.treeseq_ilist_safe_refl. prestep. unfold rep_macro, rep. norm. cancel. intuition ((pred_apply; cancel) || eauto). step. or_r. cancel. eauto. eapply listpred_dmatch_notindomain; eauto. cancel. Unshelve. all: eauto. Qed. Hint Extern 1 ({{_}} Bind (lookup _ _ _ _ _) _) => apply lookup_ok : prog. Hint Extern 1 ({{_}} Bind (unlink _ _ _ _ _) _) => apply unlink_ok : prog. Hint Extern 1 ({{_}} Bind (link _ _ _ _ _ _ _ _ _) _) => apply link_ok : prog. Hint Extern 1 ({{_}} Bind (readdir _ _ _ _) _) => apply readdir_ok : prog. Hint Extern 0 (okToUnify (rep ?f _) (rep ?f _)) => constructor : okToUnify. Theorem dmatch_complete : forall de m1 m2, dmatch de m1 -> dmatch de m2 -> m1 = m2. Proof. unfold dmatch, is_dir; intros. destruct (bool_dec (is_valid de) false). apply emp_complete; eauto. eapply ptsto_complete; pred_apply; cancel. Qed. Lemma listpred_dmatch_eq : forall l m1 m2, listpred dmatch l m1 -> listpred dmatch l m2 -> m1 = m2. Proof. induction l; simpl; auto. apply emp_complete; auto. intros m1 m2. unfold_sep_star; intuition. repeat deex; f_equal. eapply dmatch_complete; eauto. eapply IHl; eauto. Qed. Lemma rep_mem_eq : forall f m1 m2, rep f m1 -> rep f m2 -> m1 = m2. Proof. unfold rep; intros. repeat deex. pose proof (Dent.rep_items_eq H0 H1); subst. eapply listpred_dmatch_eq; eauto. Qed. Theorem bfile0_empty : rep BFILE.bfile0 empty_mem. 
base | T a k v b => elements' a ((k,v) :: elements' b base) end.Definition elements (s: tree) : list (key * V) := elements' s nil. Section EXAMPLES. Variables v2 v4 v5 : V. Eval compute in insert 5 v5 (insert 2 v2 (insert 4 v5 empty_tree)). Eval compute in lookup 5 (T (T E 2 v2 E) 4 v5 (T E 5 v5 E)). Eval compute in lookup 3 (T (T E 2 v2 E) 4 v5 (T E 5 v5 E)). Eval compute in elements (T (T E 2 v2 E) 4 v5 (T E 5 v5 E)). End EXAMPLES. Check t_update_eq. Check t_update_neq. Check t_update_shadow. Check t_update_same. Check t_update_permute. Check t_apply_empty. Definition example_tree (v2 v4 v5 : V) := T (T E 2 v2 E) 4 v4 (T E 5 v5 E). Definition example_map (v2 v4 v5: V) : total_map V . Admitted. Definition combine {A} (pivot: key) (m1 m2: total_map A) : total_map A := fun x => if x <? pivot then m1 x else m2 x.Inductive Abs: tree -> total_map V -> Prop := | Abs_E: Abs E (t_empty default) | Abs_T: forall a b l k v r, Abs l a -> Abs r b -> Abs (T l k v r) (t_update (combine k a b) k v). Lemma check_example_map: forall v2 v4 v5, Abs (example_tree v2 v4 v5) (example_map v2 v4 v5). Proof. intros. unfold example_tree. evar (m: total_map V). replace (example_map v2 v4 v5) with m; subst m. repeat constructor. extensionality x. Admitted.Lemma check_too_clever: forall v2 v4 v5: V, True. Proof. intros. evar (m: total_map V). assert (Abs (example_tree v2 v4 v5) m). repeat constructor. (change m with (example_map v2 v4 v5) in H || auto);fail "Did you use copy-and-paste, from your check_example_map proof, into your example_map definition? If so, very clever. Please try it again with an example_map definition that you make up from first principles. Or, to skip that, uncomment the above.". Qed.Theorem empty_tree_relate: Abs empty_tree (t_empty default). Proof. constructor. Qed. Theorem lookup_relate: forall k t cts , Abs t cts -> lookup k t = cts k. Proof. Admitted.Theorem insert_relate: forall k v t cts, Abs t cts -> Abs (insert k v t) (t_update cts k v). Proof. Admitted.Fixpoint list2map (el: list (key*V)) : total_map V := match el with | nil => t_empty default | (i,v)::el' => t_update (list2map el') i v end. Theorem elements_relate: forall t cts, Abs t cts -> list2map (elements t) = cts. 
From Undecidability Require Import FOL.Util.Tarski FOL.Util.Syntax FOL.Util.Syntax_facts. Import FragmentSyntax. From Undecidability Require Import Shared.ListAutomation. Import ListAutomationNotations. Local Set Implicit Arguments. Require Import Lia.Ltac comp := repeat (progress (cbn in *; autounfold in *)).Inductive peirce := class | intu. Existing Class peirce.Section ND_def. Context {Œ£_funcs : funcs_signature}. Context {Œ£_preds : preds_signature}. Reserved Notation "A ‚ä¢ phi" (at level 61). Implicit Type p : peirce. Implicit Type ff : falsity_flag. Inductive prv : forall (ff : falsity_flag) (p : peirce), list form -> form -> Prop := | II {ff} {p} A phi psi : phi::A ‚ä¢ psi -> A ‚ä¢ phi --> psi | IE {ff} {p} A phi psi : A ‚ä¢ phi --> psi -> A ‚ä¢ phi -> A ‚ä¢ psi | AllI {ff} {p} A phi : map (subst_form ‚Üë) A ‚ä¢ phi -> A ‚ä¢ ‚àÄ phi | AllE {ff} {p} A t phi : A ‚ä¢ ‚àÄ phi -> A ‚ä¢ phi[t..] | Exp {p} A phi : prv p A falsity -> prv p A phi | Ctx {ff} {p} A phi : phi el A -> A ‚ä¢ phi | Pc {ff} A phi psi : prv class A (((phi --> psi) --> phi) --> phi) where "A ‚ä¢ phi" := (prv _ A phi). Arguments prv {_} _ _. Context {ff : falsity_flag}. Context {p : peirce}. Lemma impl_prv A B phi : (rev B ++ A) ‚ä¢ phi -> A ‚ä¢ (B ==> phi). Proof. revert A; induction B; intros A; cbn; simpl_list; intros. - firstorder. - eapply II. now eapply IHB. Qed. Theorem Weak A B phi : A ‚ä¢ phi -> A <<= B -> B ‚ä¢ phi. 
Notation pos_nxt := Fin.FS.Notation pos0 := (@pos_fst _). Notation pos1 := (pos_nxt pos0). Notation pos2 := (pos_nxt pos1). Notation pos3 := (pos_nxt pos2). Notation pos4 := (pos_nxt pos3). Notation pos5 := (pos_nxt pos4). Notation pos6 := (pos_nxt pos5). Notation pos7 := (pos_nxt pos6). Notation pos8 := (pos_nxt pos7). Notation pos9 := (pos_nxt pos8). Notation pos10 := (pos_nxt pos9). Notation pos11 := (pos_nxt pos10). Notation pos12 := (pos_nxt pos11). Notation pos13 := (pos_nxt pos12). Notation pos14 := (pos_nxt pos13). Notation pos15 := (pos_nxt pos14). Notation pos16 := (pos_nxt pos15). Notation pos17 := (pos_nxt pos16). Notation pos18 := (pos_nxt pos17). Notation pos19 := (pos_nxt pos18). Notation pos20 := (pos_nxt pos19).Definition pos_iso n m : n = m -> pos n -> pos m. Proof. intros []; auto. Defined.Section pos_inv. Let pos_inv_t n := match n as x return pos x -> Set with | 0 => fun _ => False | S n => fun i => (( i = pos_fst ) + { p | i = pos_nxt p })%type end. Let pos_inv : forall n p, @pos_inv_t n p. Proof. intros _ [ | n p ]; simpl; [ left | right ]; auto; exists p; auto. Defined. Definition pos_O_inv : pos 0 -> False. Proof. apply pos_inv. Defined. Definition pos_S_inv n (p : pos (S n)) : ( p = pos_fst ) + { q | p = pos_nxt q }. Proof. apply (pos_inv p). Defined. Definition pos_nxt_inj n (p q : pos n) (H : pos_nxt p = pos_nxt q) : p = q := match H in _ = a return match a as a' in pos m return match m with | 0 => Prop | S n' => pos n' -> Prop end with | pos_fst => fun _ => True | pos_nxt y => fun x' => x' = y end p with | eq_refl => eq_refl end.End pos_inv.Arguments pos_S_inv {n} p /.Section pos_invert. Let pos_invert_t n : (pos n -> Type) -> Type := match n with 0 => fun P => True | S n => fun P => (P (pos_fst) * forall p, P (pos_nxt p))%type end. Let pos_invert n : forall (P : pos n -> Type), pos_invert_t P -> forall p, P p. Proof. intros P HP; induction p; simpl in HP; apply HP. Defined. Theorem pos_O_invert X : pos 0 -> X. Proof. apply pos_invert; simpl; trivial. Defined. Theorem pos_S_invert n P : P (@pos_fst n) -> (forall p, P (pos_nxt p)) -> forall p, P p. 
Section DistMult. Variable A B : Set. Hypothesis B_EqDec : EqDec B. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A1 : Comp (A * A_State). Variable A2 : A_State -> list B -> Comp bool. Variable n : nat. Definition DistMult_G(c : A -> Comp B) := [a, s_A] <-$2 A1; b <-$ compMap _ (fun _ => (c a)) (forNats n); A2 s_A b. Definition DistMult_Adv := | Pr[DistMult_G c1] - Pr[DistMult_G c2] |.End DistMult. Section DistSingle_impl_Mult. Variable A B : Set. Variable A_EqDec : EqDec A. Variable B_EqDec : EqDec B. Variable c1 c2 : A -> Comp B. Variable A_State : Set. Variable A_State_EqDec : EqDec A_State. Variable A1 : Comp (A * A_State). Variable A2 : A_State -> list B -> Comp bool. Hypothesis c1_wf : forall a, well_formed_comp (c1 a). Hypothesis c2_wf : forall a, well_formed_comp (c2 a). Definition computeHybrid(n i : nat) a : Comp (list B) := b1 <-$ compMap _ (fun _ => (c1 a)) (forNats i); b2 <-$ compMap _ (fun _ => (c2 a)) (forNats (minus n i)); ret (b1 ++ b2). Variable n : nat. Hypothesis n_pos : n > 0. Theorem hybrid_replace_c1_equiv : forall i x a, i < n -> evalDist (b <-$ (c1 a); hybrid <-$ computeHybrid n i a; ret (listReplace hybrid i b b)) x == evalDist (computeHybrid n (S i) a) x. induction n; destruct i; intuition; try omega. unfold computeHybrid. unfold minus. fold minus. rewrite <- minus_n_O. unfold forNats. fold forNats. unfold compMap. fold compMap. inline_first. comp_skip. inline_first. comp_simp. comp_irr_l. inline_first. comp_skip. simpl. intuition. unfold computeHybrid. unfold minus. fold minus. unfold forNats. fold forNats. unfold compMap. fold compMap. inline_first. do 2 comp_at comp_inline leftc 1%nat. comp_swap_l. comp_skip. assert (evalDist (a1 <-$ (lsb' <-$ (b <-$ (c1 a); lsb' <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats i); ret b :: lsb'); ret x0 :: lsb'); a2 <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats (n0 - S i)); ret a1 ++ a2) x == evalDist (ls <-$ (computeHybrid n0 (S i) a); ret (x0 :: ls)) x). unfold computeHybrid. unfold forNats. fold forNats. unfold compMap. fold compMap. inline_first. comp_skip. inline_first. comp_skip. comp_simp. inline_first. comp_skip. comp_simp. simpl. intuition. rewrite H1. clear H1. eapply eqRat_trans. 2:{ comp_skip. eapply eqRat_refl. } unfold computeHybrid. inline_first. comp_skip. inline_first. comp_skip. inline_first. comp_skip. comp_simp. simpl. intuition. Qed. Theorem hybrid_replace_c2_equiv : forall i x a, i < n -> evalDist (b <-$ (c2 a); hybrid <-$ computeHybrid n i a; ret (listReplace hybrid i b b)) x == evalDist (computeHybrid n i a) x. 
clear H1; intros; subst. hnf in H0. simpl in H0. inversion_clear H0. generalize dependent H. clear IHpairs H1. assert (WordMap.MapsTo k x (store_pair h (k, ADT x))). unfold SemanticsUtil.store_pair; simpl. apply WordMap.add_1; auto. generalize dependent (store_pair h (k, ADT x)). induction pairs; simpl in *; intuition; try destruct b; intuition. simpl in *; intuition subst. apply IHpairs. unfold SemanticsUtil.store_pair; simpl. apply WordMap.add_2; auto. auto. apply IHpairs; auto. hnf in H0. simpl in H0. inversion_clear H0; auto. Qed. Lemma i_didn't_do_it : forall k ls h, (forall a o, ~List.In {| Word := k; ADTIn := ADT a; ADTOut := o |} ls) -> WordMap.In k (fold_left store_out ls h) -> WordMap.In k h. induction ls; simpl; intuition. apply IHls in H0; eauto. unfold Semantics.store_out in H0. destruct a; simpl in *. destruct ADTIn; auto. destruct ADTOut. apply add_in_iff in H0; intuition subst. exfalso; eauto. apply remove_in_iff in H0; intuition subst. Qed. Lemma heap_merge_store_out : forall h pairs outs, good_inputs h pairs -> let h1 := make_heap pairs in let triples := make_triples pairs outs in WordMap.Equal (update (diff h h1) (fold_left store_out triples h1)) (fold_left store_out triples h). simpl; intros. apply Equal_mapsto_iff; intuition. apply update_mapsto_iff in H0; intuition. eapply fold_weaken; eauto. intros. destruct H. apply fold_fwd in H0; intuition. apply empty_mapsto_iff in H3; tauto. eapply Forall_forall in H; try apply H3. hnf in H; simpl in H. apply WordMap.find_2; auto. apply diff_mapsto_iff in H0; intuition subst. eapply keep_when_agrees; eauto. apply fold_fwd' in H0; intuition idtac. Focus 2. destruct H1. destruct H. apply update_mapsto_iff; left. eapply get_pair; eauto. case_eq (WordMap.mem k (make_heap pairs)); intros. apply update_mapsto_iff; left; intuition. apply get_pair'; auto. destruct H; auto. apply WordMap.mem_2 in H1. apply In_make_heap in H1; destruct H1. destruct H. eapply Forall_forall in H; [ | eassumption ]. hnf in H; simpl in H. apply WordMap.find_1 in H0. rewrite H0 in H; injection H; clear H; intros; subst. unfold make_heap. apply grab_it; auto. apply update_mapsto_iff; right; intuition. apply diff_mapsto_iff; intuition. apply not_mem_in_iff in H3; tauto. assert (~WordMap.In k (make_heap pairs)). intro. apply not_mem_in_iff in H4; tauto. clear H1. apply H4; clear H4. eapply i_didn't_do_it; eauto. Qed. Local Hint Constructors NoDup. Theorem In_InA : forall A x ls, List.In x ls -> SetoidList.InA (WordMap.eq_key (elt:=A)) x ls. induction ls; simpl; intuition. Qed. Theorem NoDupA_NoDup : forall A ls, SetoidList.NoDupA (WordMap.eq_key (elt:=A)) ls -> NoDup ls. induction 1; eauto. constructor; auto. intro; apply H. eauto using In_InA. Qed. Theorem In_InA' : forall A x ls, List.In x ls -> SetoidList.InA (WordMap.eq_key_elt (elt:=A)) x ls. 
E' (Power E) -> INC E' E. simple induction E. intros A f r; unfold INC in |- *; simpl in |- *. intros E'; simple induction 1; intros P. elim E'; simpl in |- *. intros A' f' r'. simple induction 1; intros HA HB. intros E''; simple induction 1; intros a' e. elim (HA a'). simple induction x; intros a p. intros; exists a. auto with zfc. apply EQ_tran with (f' a'); auto with zfc. Qed.Theorem INC_IN_Power : forall E E' : Ens, INC E' E -> IN E' (Power E). simple induction E; intros A f r; unfold INC in |- *; simpl in |- *. simple induction E'; intros A' f' r' i. exists (fun a : A => IN (f a) (sup A' f')). simpl in |- *. split. intros. elim (i (f' x)); auto with zfc. intros a e. cut (EQ (f a) (f' x)); auto with zfc. intros e1. exists (dep_i A (fun a : A => EXType A' (fun y : A' => EQ (f a) (f' y))) a (EXTypei A' (fun y : A' => EQ (f a) (f' y)) x e1)). simpl in |- *. auto with zfc.auto with zfc. simpl in |- *. exists x; auto with zfc.simple induction y; simpl in |- *. simple induction 1; intros. exists x0; auto with zfc. Qed.Theorem Power_mon : forall E E' : Ens, INC E E' -> INC (Power E) (Power E'). intros. unfold INC in |- *; intros. apply INC_IN_Power. cut (INC E0 E). unfold INC in |- *; unfold INC in H; intros; auto with zfc. apply IN_Power_INC; auto with zfc. Qed.Theorem Power_sound : forall E E' : Ens, EQ E E' -> EQ (Power E) (Power E'). intros E E' e. apply INC_EQ; unfold INC in |- *. intros A i. cut (INC A E'). intros; apply INC_IN_Power; assumption. cut (INC A E); intros. apply INC_sound_right with E; auto with zfc. apply IN_Power_INC; assumption. intros A i. cut (INC A E). intros; apply INC_IN_Power; assumption. cut (INC A E'); intros. apply INC_sound_right with E'; auto with zfc. apply IN_Power_INC; assumption. Qed.Theorem not_EQ_Sing_Vide : forall E : Ens, EQ (Sing E) Vide -> F. intros E e; cut False. simple induction 1. cut (IN E Vide). simpl in |- *; simple induction 1; intros xx; elim xx; simple induction 1. apply IN_sound_right with (Sing E); auto with zfc. Qed. Theorem not_EQ_Vide_Sing : forall E : Ens, EQ Vide (Sing E) -> F. 
NMap := IMap(NIndexed).Module Type EQUALITY_TYPE. Parameter t: Type. Parameter eq: forall (x y: t), {x = y} + {x <> y}. End EQUALITY_TYPE.Module EMap(X: EQUALITY_TYPE) <: MAP. Definition elt := X.t. Definition elt_eq := X.eq. Definition t (A: Type) := X.t -> A. Definition init (A: Type) (v: A) := fun (_: X.t) => v. Definition get (A: Type) (x: X.t) (m: t A) := m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. 
(fun a => baseField_scaleE a 1)). by exists [fieldExtType F of baseFieldType L]. exists (x%:A :: zs); rewrite big_cons; set rhs := _ * _. by rewrite Dp mulrC [_^%:A]rmorphM /= mapXsubC /= eqp_mull. Qed.Lemma PrimePowerField p k (m := (p ^ k)%N) : prime p -> 0 < k -> {Fm : finFieldType | p \in [char Fm] & #|Fm| = m}. Proof. move=> pr_p k_gt0; have m_gt1: m > 1 by rewrite (ltn_exp2l 0) ?prime_gt1. have m_gt0 := ltnW m_gt1; have m1_gt0: m.-1 > 0 by rewrite -ltnS prednK. pose q := 'X^m - 'X; have Dq R: q R = ('X^m.-1 - 1) * ('X - 0). by rewrite subr0 mulrBl mul1r -exprSr prednK. have /FinSplittingFieldFor[/= L splitLq]: q [ringType of 'F_p] != 0. by rewrite Dq monic_neq0 ?rpredM ?monicXsubC ?monic_Xn_sub_1. rewrite [_^%:A]rmorphB rmorphX /= map_polyX -/(q L) in splitLq. have charL: p \in [char L] by rewrite char_lalg char_Fp. pose Fm := FinFieldExtType L; exists Fm => //. have /finField_galois_generator[/= a _ Da]: (1 <= {:L})%VS by apply: sub1v. pose Em := fixedSpace (a ^+ k)%g; rewrite card_Fp //= dimv1 expn1 in Da. have{splitLq} [zs DqL defL] := splitLq. have Uzs: uniq zs. rewrite -separable_prod_XsubC -(eqp_separable DqL) Dq separable_root andbC. rewrite /root !hornerE subr_eq0 eq_sym hornerXn expr0n gtn_eqF ?oner_eq0 //=. rewrite cyclotomic.separable_Xn_sub_1 // -subn1 natrB // subr_eq0. by rewrite natrX charf0 // expr0n gtn_eqF // eq_sym oner_eq0. suffices /eq_card->: Fm =i zs. apply: succn_inj; rewrite (card_uniqP _) //= -(size_prod_XsubC _ id). by rewrite -(eqp_size DqL) size_addl size_polyXn // size_opp size_polyX. have in_zs: zs =i Em. move=> z; rewrite -root_prod_XsubC -(eqp_root DqL) (sameP fixedSpaceP eqP). rewrite /root !hornerE subr_eq0 /= hornerXn /m; congr (_ == z). elim: (k) => [|i IHi]; first by rewrite gal_id. by rewrite expgSr expnSr exprM IHi galM ?Da ?memvf. suffices defEm: Em = {:L}%VS by move=> z; rewrite in_zs defEm memvf. apply/eqP; rewrite eqEsubv subvf -defL -[Em]subfield_closed agenvS //. by rewrite subv_add sub1v; apply/span_subvP=> z; rewrite in_zs. Qed.End FinFieldExists.Section FinDomain.Import order ssrnum ssrint algC cyclotomic Order.TTheory Num.Theory. Local Infix "%|" := dvdn. Variable R : finUnitRingType.Hypothesis domR : GRing.IntegralDomain.axiom R. Implicit Types x y : R.Let lregR x : x != 0 -> GRing.lreg x. Proof. by move=> xnz; apply: mulrI0_lreg => y /domR/orP[/idPn | /eqP]. Qed.Lemma finDomain_field : GRing.Field.mixin_of R. Proof. move=> x /lregR-regx; apply/unitrP; exists (invF regx 1). by split; first apply: (regx); rewrite ?mulrA f_invF // mulr1 mul1r. Qed. Theorem finDomain_mulrC : @commutative R R *%R. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Inductive ev : nat -> Prop := | ev_0 : ev 0 | ev_SS : forall n : nat, ev n -> ev (S (S n)).Derive ArbitrarySizedSuchThat for (fun n => ev n). Derive SizedProofEqs for (fun n => ev n). Derive SizeMonotonicSuchThatOpt for (fun n => ev n). Derive GenSizedSuchThatCorrect for (fun n => ev n). Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => ev n). Instance dec_ev (n : nat) : Dec (ev n) := {| dec := let fix aux n := let n' := n in let Heq := erefl n' : n' = n in match n as n'' return (n' = n'' -> _) with | O => fun H => left _ | S O => fun H => right _ | S (S n) => fun H => _ (aux n) end Heq in aux n |}. Proof. - assert (Eq: n' = n) by auto. rewrite -Eq; rewrite H; constructor. - assert (Eq: n' = n) by auto. rewrite -Eq; rewrite H => Contra. inversion Contra. - assert (Eq: n' = n2) by auto. clear Heq; rewrite Eq in H; clear Eq. move => [EvN | OddN]. + rewrite H; left; constructor; auto. + rewrite H; right => Contra. inversion Contra; subst; auto. Defined.Theorem ev_plus4 : forall n, ev n -> ev (4 + n). Admitted. QuickChick ev_plus4. *)Theorem ev_double : forall n, ev (double n). Admitted. Theorem ev_minus2 : forall n, ev n -> ev (Peano.pred (Peano.pred n)). 
Zle_Zmult_comp_r : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (x * z <= y * z)%Z. intros x y z H' H'0; case (Zle_lt_or_eq _ _ H'); intros Zlt1. apply Zmult_gt_0_le_compat_r; auto. apply Zlt_gt; auto. rewrite <- Zlt1; repeat rewrite <- Zmult_0_r_reverse; auto with zarith. Qed. Theorem Zle_Zmult_comp_l : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (z * x <= z * y)%Z. intros x y z H' H'0; repeat rewrite (Zmult_comm z); apply Zle_Zmult_comp_r; auto. Qed. Theorem NotZmultZero : forall z1 z2 : Z, z1 <> 0%Z -> z2 <> 0%Z -> (z1 * z2)%Z <> 0%Z. intros z1 z2; case z1; case z2; simpl in |- *; intros; auto; try discriminate. Qed. Hint Resolve NotZmultZero: zarith. Theorem IZR_zero : forall p : Z, p = 0%Z -> IZR p = 0%R. intros p H'; rewrite H'; auto. Qed. Hint Resolve not_O_INR: real. Theorem IZR_zero_r : forall p : Z, IZR p = 0%R -> p = 0%Z. intros p; case p; simpl in |- *; auto. intros p1 H'; Contradict H'; auto with real zarith. intros p1 H'; absurd (INR (nat_of_P p1) = 0%R); auto with real zarith. rewrite <- (Ropp_involutive (INR (nat_of_P p1))). unfold IZR in H'; rewrite <- INR_IPR in H'. rewrite H'; auto with real. Qed. Theorem INR_lt_nm : forall n m : nat, n < m -> (INR n < INR m)%R. intros n m H'; elim H'; auto. replace (INR n) with (INR n + 0)%R; auto with real; rewrite S_INR; auto with real. intros m0 H'0 H'1. replace (INR n) with (INR n + 0)%R; auto with real; rewrite S_INR; auto with real. Qed. Hint Resolve INR_lt_nm: real. Theorem Rlt_INR1 : forall n : nat, 1 < n -> (1 < INR n)%R. replace 1%R with (INR 1); auto with real. Qed. Hint Resolve Rlt_INR1: real. Theorem NEq_INR : forall n m : nat, n <> m -> INR n <> INR m. intros n m H'; (case (le_or_lt n m); intros H'1). case (le_lt_or_eq _ _ H'1); intros H'2. apply Rlt_dichotomy_converse; auto with real. Contradict H'; auto. apply Compare.not_eq_sym; apply Rlt_dichotomy_converse; auto with real. Qed. Hint Resolve NEq_INR: real. Theorem NEq_INRO : forall n : nat, n <> 0 -> INR n <> 0%R. replace 0%R with (INR 0); auto with real. Qed. Hint Resolve NEq_INRO: real. Theorem NEq_INR1 : forall n : nat, n <> 1 -> INR n <> 1%R. 
Hypothesis p : IN X N.Section naturals_main_induction3em. Hypothesis contra : ~ StrictSUB X N.Section naturals_main_induction3a. Hypothesis q : IN X A. Let step3a1 : StrictSUB X A := h1 X q.Let step3a2 : StrictSUB X N := StrictSUB_trans1 X A N step3a1 sub_A_N.Definition naturals_main_induction3a_Out : False := contra step3a2.End naturals_main_induction3a.Let step3_1 : ~ IN X A := naturals_main_induction3a_Out.Section naturals_main_induction3b. Hypothesis r : IN X (Singleton A).Let r_bis : EQ A X := Singleton_pr2 A X r. Let subXA : SUB X A := EQ_backwards A X r_bis. Let subAX : SUB A X := EQ_forwards A X r_bis.Let step3b1 : SUB A N := sub_A_N.Let step3b2 : SUB X N := SUB_trans X A N subXA step3b1.Section naturals_main_induction3bI. Hypothesis s : EQ X N. Let step3bI1 : EQ A N := EQ_trans A X N r_bis s. Let step3bI2 : SUB N A := EQ_backwards A N step3bI1. Let step3bI3 : IN A A := step3bI2 A in_A_N.Definition naturals_main_induction3bI_Out : False := h2 step3bI3.End naturals_main_induction3bI.Let step3b3 : ~ EQ X N := naturals_main_induction3bI_Out.Let step3b4 : StrictSUB X N := Build_StrictSUB X N step3b2 step3b3. Definition naturals_main_induction3b_Out : False := contra step3b4.End naturals_main_induction3b.Let step3_2 : ~ IN X (Singleton A) := naturals_main_induction3b_Out.Let step3_3 : ~ IN X N := union_th3 A (Singleton A) X step3_1 step3_2.Definition naturals_main_induction3em_Out : False := step3_3 p.End naturals_main_induction3em.Let sublemma2 : ~ ~ StrictSUB X N := naturals_main_induction3em_Out.Definition naturals_main_induction3_Out : StrictSUB X N := excluded_middle (StrictSUB X N) sublemma2. End naturals_main_induction3.Let sublemma3 : in_then_strictsub N := naturals_main_induction3_Out.Definition naturals_main_induction_step_Out : naturals_main_ind_hyp N := Build_naturals_main_ind_hyp N sublemma3 sublemma1. End naturals_main_induction_step.Theorem naturals_main_induction_next : forall (A : Ens) (h : naturals_main_ind_hyp A), naturals_main_ind_hyp (Next A). Proof naturals_main_induction_step_Out.Theorem naturals_main_induction_next_1 : naturals_induction_nexts naturals_main_ind_hyp. Proof fun (A : Ens) (u : IN A Naturals) (h : naturals_main_ind_hyp A) => naturals_main_induction_next A h. Theorem naturals_main_th1 : forall (B : Ens) (i : IN B Naturals), naturals_main_ind_hyp B. Proof naturals_inductionA naturals_main_ind_hyp naturals_main_ind_for_Zero naturals_main_induction_next_1. Theorem naturals_main_th2 : forall (B : Ens) (i : IN B Naturals), in_then_strictsub B. Proof fun (B : Ens) (i : IN B Naturals) => naturals_main_ind1 B (naturals_main_th1 B i).Theorem naturals_main_th2_rewrite : forall (B : Ens) (i : IN B Naturals) (A : Ens) (j : IN A B), StrictSUB A B. Proof naturals_main_th2.Theorem naturals_main_th3 : forall (B : Ens) (i : IN B Naturals), not_in_itself B. Proof fun (B : Ens) (i : IN B Naturals) => naturals_main_ind2 B (naturals_main_th1 B i). Theorem naturals_main_th3_rewrite : forall (B : Ens) (i : IN B Naturals), ~ IN B B. 
Require Import Coq.Lists.List.Set Implicit Arguments. Set Strict Implicit.Section parametric. Variable T : Type. Lemma nth_error_app_L : forall (A B : list T) n, n < length A -> nth_error (A ++ B) n = nth_error A n. Proof. induction A; destruct n; simpl; intros; auto. { inversion H. } { inversion H. } { eapply IHA. apply Lt.lt_S_n; assumption. } Qed. Lemma nth_error_app_R : forall (A B : list T) n, length A <= n -> nth_error (A ++ B) n = nth_error B (n - length A). Proof. induction A; destruct n; simpl; intros; auto. + inversion H. + apply IHA. apply Le.le_S_n; assumption. Qed. Lemma nth_error_weaken : forall ls' (ls : list T) n v, nth_error ls n = Some v -> nth_error (ls ++ ls') n = Some v. Proof. clear. induction ls; destruct n; simpl; intros; unfold value, error in *; try congruence; auto. Qed. Lemma nth_error_nil : forall n, nth_error nil n = @None T. Proof. destruct n; reflexivity. Qed. Lemma nth_error_past_end : forall (ls : list T) n, length ls <= n -> nth_error ls n = None. Proof. clear. induction ls; destruct n; simpl; intros; auto. + inversion H. + apply IHls. apply Le.le_S_n; assumption. Qed. Lemma nth_error_length : forall (ls ls' : list T) n, nth_error (ls ++ ls') (n + length ls) = nth_error ls' n. Proof. induction ls; simpl; intros. rewrite Plus.plus_0_r. auto. rewrite <- Plus.plus_Snm_nSm. simpl. eapply IHls. Qed. Theorem nth_error_length_ge : forall T (ls : list T) n, nth_error ls n = None -> length ls <= n. 
Monoid.is_id_l E {#}. Definition prod_is_id_r := Monoid.is_id_r E {#}. Definition prod_is_id := Monoid.is_id E {#}. Theorem prod_id_r : prod_is_id_r 1. Proof fun x : E => eq_ind_r (fun a => a = x) (prod_id_l x) (prod_is_comm x 1). Theorem prod_sum_distrib_r : Ring.is_distrib_r E {#} {+}. Proof fun x y z : E => prod_sum_distrib_l x y z || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z || a = (y # x) + (z # x) @a by <- prod_is_comm x (y + z). Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r. Definition sum_abelian_group := Ring.sum_abelian_group ring. Definition sum_group := Ring.sum_group ring. Definition sum_monoid := Ring.sum_monoid ring. Definition prod_monoid := Ring.prod_monoid ring. Theorem distinct_1_0 : E_1 (c := r) <> E_0 (c := r). Proof fun H : E_1 = E_0 => distinct_0_1 (eq_sym H). Definition nonzero : E -> Prop := Ring.nonzero ring. Theorem sum_id_r : sum_is_id_r 0. Proof Ring.sum_id_r ring. Theorem sum_id : sum_is_id 0. Proof Ring.sum_id ring. Definition sum_is_inv_l := Ring.sum_is_inv_l ring. Definition sum_is_inv_r := Ring.sum_is_inv_r ring. Definition sum_is_inv := Ring.sum_is_inv ring. Definition sum_has_inv_l := Ring.sum_has_inv_l ring. Definition sum_has_inv_r := Ring.sum_has_inv_r ring. Definition sum_has_inv := Ring.sum_has_inv ring. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Ring.sum_inv_r_ex ring. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Ring.sum_id_l_uniq ring. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Ring.sum_id_r_uniq ring. Theorem sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Ring.sum_id_uniq ring. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Ring.sum_inv_l_r_eq ring. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Ring.sum_inv_sym ring. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Ring.sum_inv_uniq ring. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Ring.sum_inv_ex ring. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. Proof Ring.sum_inv_uniq_ex ring. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. 
x sub = None -> cmap_view_ctx (M.set x (SVconstr t xs) sub) (comp_ctx_f c (Econstr_c x t xs Hole_c)). Proof. intros; split; intros; split; intros. - destruct (var_dec x0 x). + exists c, Hole_c. subst. rewrite M.gss in H1. inv H1. auto. + rewrite M.gso in H1 by auto. apply H in H1. destructAll. exists x1, (comp_ctx_f x2 (Econstr_c x t xs Hole_c)). rewrite comp_ctx_f_assoc. simpl. auto. - destructAll. apply comp_ctx_split in H1. destruct H1. + destructAll. destruct x3; inv H1. * rewrite M.gss. auto. * rewrite M.gso. 2:{ intro. subst. destruct H. specialize (H x c l). assert ((exists c' c'' : exp_ctx, comp_ctx_f x1 (Econstr_c x c l x3) = comp_ctx_f c' (Econstr_c x c l c''))) by eauto. apply H in H2. rewrite H0 in H2. inv H2. } apply H. eauto. + destructAll. destruct x4; inv H3. * rewrite M.gss; auto. * destruct x4; inv H6. - rewrite M.gso in H1. apply H in H1. destructAll. exists x0. exists (comp_ctx_f x1 (Econstr_c x t xs Hole_c)). rewrite comp_ctx_f_assoc. simpl. eauto. intro. subst. rewrite M.gss in H1. inv H1. - destructAll. rewrite M.gso. apply H. apply comp_ctx_split in H1. destruct H1. + destructAll; subst. destruct x4; inv H1. eauto. + destructAll. destruct x5; inv H3. destruct x5; inv H6. + intro; subst. apply comp_ctx_split in H1. destruct H1. * destructAll; subst. destruct x4; inv H1. destruct H. specialize (H1 x t0 ys e). assert (exists (c' c'' : exp_ctx) (B1 B2 : fundefs), comp_ctx_f x0 (Efun1_c (fundefs_append x2 (Fcons x t0 ys e x3)) x4) = comp_ctx_f c' (Efun1_c (fundefs_append B1 (Fcons x t0 ys e B2)) c'')) by eauto. apply H1 in H2. rewrite H0 in H2. inv H2. * destructAll. destruct x5; inv H3. destruct x5; inv H6. Qed. Theorem cmap_view_prim: forall sub c v p l, cmap_view_ctx sub c -> cmap_view_ctx sub (comp_ctx_f c (Eprim_c v p l Hole_c)). Proof. intros; split; intros; split; intros. - apply H in H0. destructAll. eexists; eexists. rewrite comp_ctx_f_assoc. simpl. reflexivity. - apply H. destructAll. apply comp_ctx_split in H0. destruct H0; destructAll. + destruct x2; inv H0. eauto. + destruct x3; inv H2. destruct x3; inv H5. - apply H in H0. destructAll. eexists; eexists; eexists; eexists. rewrite comp_ctx_f_assoc. simpl. reflexivity. - apply H. destructAll. apply comp_ctx_split in H0. destruct H0; destructAll. + destruct x3; inv H0. eauto. + destruct x4; inv H2. destruct x4; inv H5. Qed. Theorem cmap_view_proj: forall sub c v t n v', cmap_view_ctx sub c -> cmap_view_ctx sub (comp_ctx_f c (Eproj_c v t n v' Hole_c)). 
Set Primitive Projections. Record total2 { T: Type } ( P: T -> Type ) := tpair { pr1 : T; pr2 : P pr1 }. Theorem onefiber' {X : Type} (P : X -> Type) (x : X) : True. 
cbn. - rewrite csplit_capp; reflexivity. - reflexivity. Defined. End Args. Create HintDb lowering. Hint Rewrite @context_equiv_cassoc : lowering. Hint Rewrite @context_equiv_creplace : lowering. Hint Rewrite @context_equiv_CtxCons : lowering. Hint Rewrite @context_equiv_ctl : lowering. Hint Rewrite <- @log_equiv_cons : lowering. Hint Rewrite @lower_unop_correct : lowering. Hint Rewrite @lower_binop_correct : lowering. Hint Rewrite @value_of_bits_of_value : lowering. Hint Rewrite @lower_r_eqn : lowering. Hint Rewrite @lower_sigma_eqn : lowering. Hint Rewrite @log_equiv_may_read : lowering. Hint Rewrite @log_equiv_may_write : lowering. Hint Rewrite @log_equiv_latest_write0 : lowering. Hint Rewrite @latest_write0_app : lowering. Hint Rewrite @csplit_capp : lowering. Hint Rewrite @InternalCall_correct : lowering. Ltac destruct_res r := destruct r as [((?, ?), ?) | ] eqn:?; cbn. Ltac lowering_correct_t_step := match goal with | _ => cleanup_step | _ => progress (subst; unfold opt_bind) | _ => progress autorewrite with lowering | [ H: context[linterp _ _ _ _ = _] |- context[linterp (lower_context ?G) (lower_log ?L) (lower_log ?l) (lower_action ?ta)] ] => setoid_rewrite (H _ _ ta G L l) | [ |- context[linterp (CtxCons _ _ _) _ _ _] ] => setoid_rewrite context_equiv_CtxCons | [ |- context[ctl (lower_context _)] ] => setoid_rewrite context_equiv_ctl | [ |- context[tinterp] ] => destruct tinterp as [((?, ?), ?) | ] | [ |- context[latest_write0] ] => destruct latest_write0 | [ |- context[if ?x then _ else _] ] => destruct x | _ => eauto using InternalCall_correct end. Ltac lowering_correct_t := repeat lowering_correct_t_step. Theorem action_lowering_correct: forall {sig tau} (ta: taction sig tau) tGamma tL tl, linterp (lower_context tGamma) (lower_log tL) (lower_log tl) (lower_action ta) = lower_result (tinterp tGamma tL tl ta). Proof. fix IHta 3; destruct ta; simpl; intros; cbn. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. - lowering_correct_t. Qed. Context (rules: rule_name_t -> TypedSyntax.rule pos_t var_t fn_name_t R Sigma). Notation lrules r := (lower_action (rules r)). Lemma scheduler_lowering_correct': forall s L, LoweredSemantics.interp_scheduler' lr lsigma (fun r => lrules r) (lower_log L) s = lower_log (TypedSemantics.interp_scheduler' r sigma rules L s). Proof. induction s; intros; cbn; unfold TypedSemantics.interp_rule, LoweredSemantics.interp_rule. - reflexivity. - rewrite log_equiv_empty. setoid_rewrite (action_lowering_correct (rules r0) CtxEmpty L log_empty). destruct tinterp as [((?, ?), ?) | ]; cbn; try rewrite log_equiv_app; eauto. - rewrite log_equiv_empty. setoid_rewrite (action_lowering_correct (rules r0) CtxEmpty L log_empty). destruct tinterp as [((?, ?), ?) | ]; cbn; try rewrite log_equiv_app; eauto. - eauto. Qed. Theorem scheduler_lowering_correct: forall s, LoweredSemantics.interp_scheduler lr lsigma (fun r => lrules r) s = lower_log (TypedSemantics.interp_scheduler r sigma rules s). 
Require Import Le Gt Minus Min Bool.Set Implicit Arguments. Section Lists. Variable A : Type. Inductive list : Type := | nil : list | cons : A -> list -> list. Infix "::" := cons (at level 60, right associativity) : list_scope. Open Scope list_scope. Definition head (l:list) := match l with | nil => error | x :: _ => value x end. Definition hd (default:A) (l:list) := match l with | nil => default | x :: _ => x end. Definition tail (l:list) : list := match l with | nil => nil | a :: m => m end. Fixpoint length (l:list) : nat := match l with | nil => 0 | _ :: m => S (length m) end.Parameter size : list -> nat. Axiom size_nil : size nil = 0. Fixpoint In (a:A) (l:list) {struct l} : Prop := match l with | nil => False | b :: m => b = a \/ In a m end. Fixpoint app (l m:list) {struct l} : list := match l with | nil => m | a :: l1 => a :: app l1 m end. Infix "++" := app (right associativity, at level 60) : list_scope.End Lists.Arguments nil {A}. Infix "::" := cons (at level 60, right associativity) : list_scope. Infix "++" := app (right associativity, at level 60) : list_scope.Open Scope list_scope.Delimit Scope list_scope with list.Bind Scope list_scope with list.Arguments list _%type_scope.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), nil <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = nil}. Proof. induction l as [|a tl]. right; reflexivity. left; exists a; exists tl; reflexivity. Qed. Theorem head_nil : head (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem head_cons : forall (l : list A) (x : A), head (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). 
Qed. Theorem F2R_0 : forall e : Z, F2R (Float beta 0 e) = 0%R. Proof. intros e. unfold F2R. simpl. apply Rmult_0_l. Qed.Theorem eq_0_F2R : forall m e : Z, F2R (Float beta m e) = 0%R -> m = Z0. Proof. intros m e H. apply eq_F2R with e. now rewrite F2R_0. Qed.Theorem ge_0_F2R : forall m e : Z, (0 <= F2R (Float beta m e))%R -> (0 <= m)%Z. Proof. intros m e H. apply le_F2R with e. now rewrite F2R_0. Qed.Theorem le_0_F2R : forall m e : Z, (F2R (Float beta m e) <= 0)%R -> (m <= 0)%Z. Proof. intros m e H. apply le_F2R with e. now rewrite F2R_0. Qed.Theorem gt_0_F2R : forall m e : Z, (0 < F2R (Float beta m e))%R -> (0 < m)%Z. Proof. intros m e H. apply lt_F2R with e. now rewrite F2R_0. Qed.Theorem lt_0_F2R : forall m e : Z, (F2R (Float beta m e) < 0)%R -> (m < 0)%Z. Proof. intros m e H. apply lt_F2R with e. now rewrite F2R_0. Qed.Theorem F2R_ge_0 : forall f : float beta, (0 <= Fnum f)%Z -> (0 <= F2R f)%R. Proof. intros f H. rewrite <- F2R_0 with (Fexp f). now apply F2R_le. Qed.Theorem F2R_le_0 : forall f : float beta, (Fnum f <= 0)%Z -> (F2R f <= 0)%R. Proof. intros f H. rewrite <- F2R_0 with (Fexp f). now apply F2R_le. Qed.Theorem F2R_gt_0 : forall f : float beta, (0 < Fnum f)%Z -> (0 < F2R f)%R. Proof. intros f H. rewrite <- F2R_0 with (Fexp f). now apply F2R_lt. Qed.Theorem F2R_lt_0 : forall f : float beta, (Fnum f < 0)%Z -> (F2R f < 0)%R. Proof. intros f H. rewrite <- F2R_0 with (Fexp f). now apply F2R_lt. Qed.Theorem F2R_neq_0 : forall f : float beta, (Fnum f <> 0)%Z -> (F2R f <> 0)%R. Proof. intros f H H1. apply H. now apply eq_0_F2R with (Fexp f). Qed. Lemma Fnum_ge_0: forall (f : float beta), (0 <= F2R f)%R -> (0 <= Fnum f)%Z. Proof. intros f H. case (Zle_or_lt 0 (Fnum f)); trivial. intros H1; contradict H. apply Rlt_not_le. now apply F2R_lt_0. Qed.Lemma Fnum_le_0: forall (f : float beta), (F2R f <= 0)%R -> (Fnum f <= 0)%Z. Proof. intros f H. case (Zle_or_lt (Fnum f) 0); trivial. intros H1; contradict H. apply Rlt_not_le. now apply F2R_gt_0. Qed. Theorem F2R_bpow : forall e : Z, F2R (Float beta 1 e) = bpow e. 
arith. Qed. Inductive genPcP : poly A0 eqA ltM -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop := | genPcP0 : forall (i : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), genPcP i nil L L | genPcP1 : forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM), slice i a L1 = Keep L2 -> genPcP i L2 L L3 -> genPcP i (a :: L1) L (addEnd A A0 eqA n ltM (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os i a) L3) | genPcP2 : forall (L L1 L2 L3 : list _) (a i : poly A0 eqA ltM), slice i a L1 = DontKeep L2 -> genPcP i L2 L L3 -> genPcP i (a :: L1) L L3. Hint Resolve genPcP0. Theorem genPcP_spolyp1 : forall (i : poly A0 eqA ltM) (L L1 L2 : list _), genPcP i L1 L L2 -> forall a : poly A0 eqA ltM, In a L2 -> (exists b : poly A0 eqA ltM, In b L1 /\ a = spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os i b) \/ In a L. intros i L L1 L2 H'; elim H'; clear H'; simpl in |- *; auto. intros L0 L3 L4 L5 a i0 H' H'0 H'1 a0 H'2. case (addEnd_cons A A0 eqA n ltM) with (1 := H'2); auto; intros H'7. rewrite H'7; auto. left; exists a; split; simpl in |- *; auto. elim (H'1 a0); auto. intros H'3; case H'3; intros b E; case E; intros H'4 H'5; rewrite H'5; clear E H'3. left; exists b; split; auto. right; try assumption. generalize (slicef_incl i0 a L3); unfold slicef in |- *; rewrite H'; auto. intros L0 L3 L4 L5 a i0 H' H'0 H'1 a0 H'2. elim (H'1 a0); [ intros H'5; elim H'5; intros b E; elim E; intros H'6 H'7; rewrite H'7; clear E H'5 | intros H'5 | idtac ]; auto. left; exists b; split; [ right | idtac ]; auto. generalize (slicef_incl i0 a L3); unfold slicef in |- *; rewrite H'; auto. Qed. Hint Resolve (addEnd_id2 A A0 eqA n ltM). Hint Resolve (addEnd_id1 A A0 eqA n ltM). Theorem genPcP_incl : forall (i : poly A0 eqA ltM) (L L1 L2 : list _), genPcP i L1 L L2 -> incl L L2. 
l2; clear a l1 l2; simpl in |- *; auto. intros a l1 H1; case H1. intros a l H a0 l1 [H0| H0]. injection H0; intros H1 H2; rewrite H2; rewrite H1; auto. generalize H H0; elim (split_one l); simpl in |- *; auto. intros H1 H2; case H2. intros a1 l0 H1 H2 [H3| H3]; auto. injection H3; intros H4 H5; (rewrite <- H4; rewrite <- H5). apply permutation_trans with (a :: fst a1 :: snd a1); auto. apply permutation_skip. apply H2; auto. case a1; simpl in |- *; auto. Qed. Theorem split_one_in_ex : forall (a : A) (l1 : list A), In a l1 -> exists l2 : list A, In (a, l2) (split_one l1). Proof using. intros a l1; elim l1; simpl in |- *; auto. intros H; case H. intros a0 l H [H0| H0]; auto. exists l; left; apply f_equal2 with (f := pair (A:=A) (B:=list A)); auto. case H; auto. intros x H1; exists (a0 :: x); right; auto. apply (in_map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l) (a, x)); auto. Qed. Fixpoint all_permutations_aux (l : list A) (n : nat) {struct n} : list (list A) := match n with | O => nil :: nil | S n1 => flat_map (fun p : A * list A => map (cons (fst p)) (all_permutations_aux (snd p) n1)) (split_one l) end. Definition all_permutations (l : list A) := all_permutations_aux l (length l). Lemma all_permutations_aux_permutation : forall (n : nat) (l1 l2 : list A), n = length l2 -> In l1 (all_permutations_aux l2 n) -> permutation l1 l2. Proof using. intros n; elim n; simpl in |- *; auto. intros l1 l2; case l2. simpl in |- *; intros H0 [H1| H1]. rewrite <- H1; auto. case H1. simpl in |- *; intros; discriminate. intros n0 H l1 l2 H0 H1. case in_flat_map_ex with (1 := H1). clear H1; intros x; case x; clear x; intros a1 l3 (H1, H2). case in_map_inv with (1 := H2). simpl in |- *; intros y (H3, H4). rewrite H4; auto. apply permutation_trans with (a1 :: l3); auto. apply permutation_skip; auto. apply H with (2 := H3). apply eq_add_S. apply trans_equal with (1 := H0). change (length l2 = length (a1 :: l3)) in |- *. apply permutation_length; auto. apply permutation_sym; apply split_one_permutation; auto. apply split_one_permutation; auto. Qed. Theorem all_permutations_permutation : forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2. 
From Perennial.program_proof.mvcc Require Import tuple_prelude tuple_repr.Section proof. Context `{!heapGS Œ£, !mvcc_ghostG Œ£}. Local Theorem wp_findRightVer (tid : u64) (versS : Slice.t) (vers : list (u64 * bool * u64)) : {{{ ‚åú‚àÉ (ver : pver), (ver ‚àà vers) ‚àß (int.Z ver.1.1 < int.Z tid)‚åù ‚àó slice.is_slice versS (structTy Version) 1 (ver_to_val <$> vers) }}} findRightVer #tid (to_val versS) {{{ (ver : pver), RET (ver_to_val ver); ‚åúspec_find_ver vers tid = Some ver‚åù ‚àó slice.is_slice versS (structTy Version) 1 (ver_to_val <$> vers) }}}. 
forall r, (r one eins : Prop) -> paco2 teq_gen r two zwei. Proof. intros; pcofix CIH. pfold. rewrite (tunf_eq two), (tunf_eq zwei); simpl. constructor; auto. Qed. Theorem teq'_eins : teq' one eins. Proof. pcofix CIH. pmult; apply teq'_two_one, teq'_one_two, CIH. Qed.Theorem teq'_zwei : teq' two zwei. Proof. pcofix CIH. pmult; apply teq'_one_two, teq'_two_one, CIH. Qed. Inductive eqone_gen eqone eqtwo : inftree -> Prop := | _eqone_gen : forall tl tr (EQL : eqone tl : Prop) (EQR : eqtwo tr : Prop), eqone_gen eqone eqtwo (node 1 tl tr).Inductive eqtwo_gen eqone eqtwo : inftree -> Prop := | _eqtwo_gen : forall tl tr (EQL : eqone tl : Prop) (EQR : eqtwo tr : Prop), eqtwo_gen eqone eqtwo (node 2 tl tr).Hint Constructors eqone_gen eqtwo_gen.CoInductive eqone (t : inftree) : Prop := | eqone_fold (EQ : eqone_gen eqone eqtwo t) with eqtwo (t : inftree) : Prop := | eqtwo_fold (EQ : eqtwo_gen eqone eqtwo t).Lemma eqone_eins : eqone eins. Proof. cofix CIH0; apply eqone_fold. rewrite tunf_eq; simpl; constructor. apply CIH0. cofix CIH1; apply eqtwo_fold. constructor. apply CIH0. rewrite tunf_eq; apply CIH1. Qed.Definition eqone' t := paco1_2_0 eqone_gen eqtwo_gen bot1 bot1 t. Definition eqtwo' t := paco1_2_1 eqone_gen eqtwo_gen bot1 bot1 t. Hint Unfold eqone' eqtwo'. Lemma eqone_gen_mon: monotone1_2 eqone_gen. Proof. pmonauto. Qed. Lemma eqtwo_gen_mon: monotone1_2 eqtwo_gen. Proof. pmonauto. Qed. Hint Resolve eqone_gen_mon eqtwo_gen_mon : paco.Lemma eqone'_eins: eqone' eins. Proof. pcofix CIH0; pfold. rewrite tunf_eq; simpl; constructor. right; apply CIH0. left; pcofix CIH1; pfold. constructor. right; apply CIH0. right; rewrite tunf_eq; apply CIH1. Qed. Section safety. Context (X:Type) (P: X -> X -> Prop). CoInductive path x: Prop:= | step x': path x' -> P x x' -> path x. CoInductive stutter_path x: nat -> Prop := | step' n1 n2 x': stutter_path x' n1 -> P x x' -> stutter_path x n2 | stutter n : stutter_path x n -> stutter_path x (S n). Inductive path_gen path : X -> Prop := | _path_gen : forall x x', P x x' -> path x' -> path_gen path x. Definition path' := paco1 path_gen. Inductive stutterpath_gen (stutterpath : X -> nat -> Prop) : X -> nat -> Prop:= | _stutterpath_step : forall n1 n2 x x', P x x' -> stutterpath x' n1 -> stutterpath_gen stutterpath x n2 | _stutterpath_stut : forall n x, stutterpath x n -> stutterpath_gen stutterpath x (S n). Definition stutterpath' := paco2 stutterpath_gen. Theorem theorem : forall x n, stutterpath' bot2 x n -> path' bot1 x. 
N) $0 in let^ (ms, r') <- indread_to_aligned indlvl' lxp # ir' (start mod N) ms; Ret ^(ms, r' ++ r) end }. Theorem indread_to_aligned_ok : forall indlvl lxp ir start ms, let N := NIndirect ^ S indlvl in {< F Fm IFs m0 sm m bxp l, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: Fm * indrep_n_tree indlvl bxp IFs ir l ]]] * [[ start < length l ]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[ r = skipn start l ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indread_to_aligned indlvl lxp ir start ms. Proof. induction indlvl; cbn [indread_to_aligned]. - hoare. rewrite indrep_n_helper_0 in *; destruct_lifts. autorewrite with core. rewrite skipn_repeat; auto. rewrite indrep_n_helper_valid by auto. cancel. rewrite firstn_oob by indrep_n_tree_bound. auto. - step. step. erewrite indrep_n_tree_repeat_concat with (m := list2nmem m). 3: pred_apply; cancel. rewrite skipn_repeat; eauto. indrep_n_tree_bound. step. rewrite indrep_n_helper_valid by auto. cancel. rewrite firstn_oob by indrep_n_tree_bound. step. match goal with |- context [skipn ?k] => rewrite listmatch_split with (n := S k) end. rewrite skipn_combine by auto. cancel. repeat match goal with |- context [match ?x with _ => _ end] => destruct x end; cbn [length] in *; autorewrite with core; congruence. step. indrep_n_extract. cancel. indrep_n_tree_bound. indrep_n_tree_bound. eapply lt_le_trans; [eapply Nat.mod_upper_bound|]; auto. indrep_n_extract. erewrite indrep_n_length_pimpl in *. destruct_lifts. match goal with H: context [selN] |- _ => rewrite H; omega end. indrep_n_tree_bound. indrep_n_tree_bound. step. erewrite <- skipn_hom_concat by eauto. auto. Unshelve. all: solve [eauto | exact $0]. Qed. Opaque indread_to_aligned. Local Hint Extern 1 ({{_}} Bind (indread_to_aligned _ _ _ _ _ ) _) => apply indread_to_aligned_ok : prog. Fixpoint indread_from_aligned indlvl lxp ir len ms := let N := (NIndirect ^ S indlvl) in If (addr_eq_dec ir 0) { Ret ^(ms, repeat $0 len) } else { let^ (ms, indbns) <- IndRec.read lxp ir 1 ms; match indlvl with | 0 => Ret ^(ms, firstn len indbns) | S indlvl' => let N := (NIndirect ^ S indlvl') in let^ (ms, r) <- indread_aligned indlvl' lxp (firstn (len / N) indbns) ms; If (addr_eq_dec (len mod N) 0) { Ret ^(ms, r) } else { let ir' := selN indbns (len / N) $0 in let^ (ms, r') <- indread_from_aligned indlvl' lxp # ir' (len mod N) ms; Ret ^(ms, r ++ r') } end }. Theorem indread_from_aligned_ok : forall indlvl lxp ir len ms, let N := NIndirect ^ S indlvl in {< F Fm IFs m0 sm m bxp l, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: Fm * indrep_n_tree indlvl bxp IFs ir l ]]] * [[ len <= length l ]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[ r = firstn len l ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indread_from_aligned indlvl lxp ir len ms. 
now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. subst o. exists (M.xelements l (xO j)), (M.xelements r (xI j)). rewrite xelements_set_node_xH, !M.xelements_Node. split; auto. Qed. Theorem elements_set_none: forall (A: Type) v (m: M.t A) i , M.get i m = None -> exists l1 l2, M.elements m = l1 ++ l2 /\ M.elements (M.set i v m) = l1 ++ (i,v)::l2. Proof. unfold M.elements. intros. apply xelements_set_none with (v:= v) (j := xH) (m := m) in H. simpl in H. apply H. Qed. Theorem xelements_set_some: forall (A: Type) v v' (m: M.t A) i j, M.get i m = Some v' -> exists l1 l2, M.xelements m j = l1 ++ (M.prev_append j i,v')::l2 /\ M.xelements (M.set i v m) j = l1 ++ (M.prev_append j i,v)::l2. Proof. intros A v v' m. induction m using M.tree_ind; intros. - rewrite M.gempty in H. congruence. - destruct i; simpl in *. + rewrite M.gNode in H0. rewrite xelements_set_node_xI, M.xelements_Node. apply IHm0 with (j:= xI j) in H0; do 3 (destruct H0). rewrite M.xelements_Node. cbn. rewrite H0. destruct o. * exists (M.xelements l (xO j) ++ ((M.prev j, a) :: x)), x0. split. cbn. now rewrite <- app_assoc. now rewrite <- app_assoc, H1. * exists ((M.xelements l (xO j)) ++ x), x0. split; auto. cbn. now rewrite <- app_assoc. now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. rewrite xelements_set_node_xO, !M.xelements_Node. apply IHm with (j := xO j) in H0; destructAll. destruct o as [a|]. * exists x, (x0 ++ ((M.prev j, a)::M.xelements r (xI j))). split; auto. cbn. change ((M.prev_append j (xO i), v') :: x0 ++ (M.prev j, a) :: M.xelements r (xI j)) with (((M.prev_append j (xO i), v') :: nil) ++ x0 ++ (M.prev j, a) :: M.xelements r (xI j)). rewrite H0, !app_assoc. f_equal. now rewrite <- app_assoc. change ((M.prev_append j (xO i), v) :: x0 ++ (M.prev j, a) :: M.xelements r (xI j)) with (((M.prev_append j (xO i), v) :: nil) ++ x0 ++ (M.prev j, a) :: M.xelements r (xI j)). rewrite H1, !app_assoc. cbn. rewrite <- app_assoc. simpl. now rewrite <- (app_assoc x _ x0). * exists x, (x0 ++ M.xelements r (xI j)). split; auto. simpl. now rewrite H0, <- app_assoc. now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. subst o. exists (M.xelements l (xO j)), (M.xelements r (xI j)). rewrite xelements_set_node_xH, !M.xelements_Node. split; auto. Qed. Theorem elements_set_some: forall (A: Type) i v v' (m: M.t A), M.get i m = Some v' -> exists l1 l2, M.elements m = l1 ++ (i, v') :: l2 /\ M.elements (M.set i v m) = l1 ++ (i,v)::l2. 
apply Rle_lt_trans with (2:=proj2 Hex). rewrite <- Rplus_0_r. apply Rplus_le_compat_l. rewrite <- Ropp_0. apply Ropp_le_contravar. apply bpow_ge_0. apply Rle_ge. apply Rle_0_minus. rewrite Fx. unfold F2R, canonic_exp; simpl. rewrite Lex. pattern (bpow (fexp ex)) at 1; rewrite <- Rmult_1_l. apply Rmult_le_compat_r. apply bpow_ge_0. replace 1%R with (Z2R (Zsucc 0)) by reflexivity. apply Z2R_le. apply Zlt_le_succ. apply F2R_gt_0_reg with beta (canonic_exp beta fexp x). now rewrite <- Fx. Qed. Lemma pred_pos_plus_ulp_aux2 : forall x, (0 < x)%R -> F x -> let e := ln_beta_val beta x (ln_beta beta x) in x = bpow (e - 1) -> (x - bpow (fexp (e-1)) <> 0)%R -> ((x - bpow (fexp (e-1))) + ulp (x - bpow (fexp (e-1))) = x)%R. Proof. intros x Zx Fx e Hxe Zp. replace (ulp (x - bpow (fexp (e - 1)))) with (bpow (fexp (e - 1))). ring. assert (He:(fexp (e-1) <= e-1)%Z). apply generic_format_bpow_inv with beta; trivial. rewrite <- Hxe; assumption. case (Zle_lt_or_eq _ _ He); clear He; intros He.rewrite ulp_neq_0; trivial. apply f_equal. unfold canonic_exp; apply f_equal. apply sym_eq. apply ln_beta_unique. rewrite Rabs_right. split. apply Rplus_le_reg_l with (bpow (fexp (e-1))). ring_simplify. apply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R. apply Rplus_le_compat; apply bpow_le; omega. apply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac]. apply Rle_trans with (bpow 1*bpow (e - 2))%R. apply Rmult_le_compat_r. apply bpow_ge_0. replace 2%R with (Z2R 2) by reflexivity. replace (bpow 1) with (Z2R beta). apply Z2R_le. apply <- Zle_is_le_bool. now destruct beta. simpl. unfold Zpower_pos; simpl. now rewrite Zmult_1_r. rewrite <- bpow_plus. replace (1+(e-2))%Z with (e-1)%Z by ring. now right. rewrite <- Rplus_0_r, Hxe. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0. apply Rle_ge; apply Rle_0_minus. rewrite Hxe. apply bpow_le. omega.contradict Zp. rewrite Hxe, He; ring. Qed.Lemma pred_pos_plus_ulp_aux3 : forall x, (0 < x)%R -> F x -> let e := ln_beta_val beta x (ln_beta beta x) in x = bpow (e - 1) -> (x - bpow (fexp (e-1)) = 0)%R -> (ulp 0 = x)%R. Proof. intros x Hx Fx e H1 H2. assert (H3:(x = bpow (fexp (e - 1)))). now apply Rminus_diag_uniq. assert (H4: (fexp (e-1) = e-1)%Z). apply bpow_inj with beta. now rewrite <- H1. unfold ulp; rewrite Req_bool_true; trivial. case negligible_exp_spec. intros K. specialize (K (e-1)%Z). contradict K; omega. intros n Hn. rewrite H3; apply f_equal. case (Zle_or_lt n (e-1)); intros H6. apply valid_exp; omega. apply sym_eq, valid_exp; omega. Qed. Theorem pred_pos_plus_ulp : forall x, (0 < x)%R -> F x -> (pred_pos x + ulp (pred_pos x) = x)%R. 
Require Export approx.Definition compute_to_same_name {o} lib (a b : @NTerm o) := {n : get_patom_set o & (a =v>(lib) (mk_utoken n)) # (b =v>(lib) (mk_utoken n))}.Definition computes_to_same_name {o} lib (a b : @NTerm o) := forall (n : get_patom_set o), (a =v>(lib) (mk_utoken n)) -> (b =v>(lib) (mk_utoken n)). Definition old1_ex_close_compute_exc {o} lib ex (R: @NTrel o) (tl tr : @NTerm o) : [univ]:= forall a e, (tl =e>(a,lib) e) -> R a ex + {a' : NTerm & {e' : NTerm & (tr =e>(a',lib) e') # R a a' # R e e' }}. Definition old2_ex_close_compute_exc {o} lib ex (R: @NTrel o) (tl tr : @NTerm o) : [univ]:= forall a e, (tl =e>(a,lib) e) -> compute_to_same_name lib a ex.Definition ex_close_compute_exc {o} lib ex (R: @NTrel o) (tl tr : @NTerm o) : [univ]:= forall a e, (tl =e>(a,lib) e) -> compute_to_same_name lib a ex + {a' : NTerm & {e' : NTerm & (tr =e>(a',lib) e') # alpha_eq a a' # alpha_eq e e' }}.Definition ex_close_comput {p} lib ex (R: NTrel) (tl tr : @NTerm p) : [univ]:= isprogram tl # isprogram tr # close_compute_val lib R tl tr # ex_close_compute_exc lib ex R tl tr # close_compute_seq lib R tl tr # True .CoInductive ex_approx_bad {o} : @library o -> @NTerm o -> @NTerm o -> @NTerm o -> [univ] := | ex_approxC: forall lib ex tl tr, ex_close_comput lib ex (ex_approx_bad lib ex) tl tr -> ex_approx_bad lib ex tl tr.CoInductive ex_approx_aux {p} (lib : library) (ex : NTerm) (R : bin_rel NTerm) (tl tr: @NTerm p): [univ] := | ex_approx_fold: ex_close_comput lib ex (ex_approx_aux lib ex R \2/ R) tl tr -> ex_approx_aux lib ex R tl tr.Definition ex_approx {p} lib ex := @ex_approx_aux p lib ex bot2. Theorem ex_approx_acc {p} : forall (lib : library) (ex : NTerm) (l r0 : bin_rel (@NTerm p)) (OBG: forall (r: bin_rel NTerm) (INC: r0 =2> r) (CIH: l =2> r), l =2> ex_approx_aux lib ex r), l =2> ex_approx_aux lib ex r0. 
zarith. unfold Zle in |- *; intros H; rewrite H; red in |- *; intros; discriminate. Qed. Theorem ZmaxSym : forall z1 z2 : Z, Zmax z1 z2 = Zmax z2 z1. intros z1 z2; unfold Zmax in |- *; CaseEq (z1 ?= z2)%Z; CaseEq (z2 ?= z1)%Z; intros H1 H2; try case (Zcompare_EGAL _ _ H1); auto; try case (Zcompare_EGAL _ _ H2); auto; Contradict H1. case (Zcompare.Zcompare_Gt_Lt_antisym z2 z1); auto. intros H' H'0; rewrite H'0; auto; red in |- *; intros; discriminate. case (Zcompare.Zcompare_Gt_Lt_antisym z1 z2); auto. intros H'; rewrite H'; auto; intros; red in |- *; intros; discriminate. Qed. Theorem Zmax_le2 : forall z1 z2 : Z, (z1 <= z2)%Z -> Zmax z1 z2 = z2. intros z1 z2; unfold Zle, Zmax in |- *; case (z1 ?= z2)%Z; auto. intros H'; case H'; auto. Qed. Theorem Zmax_le1 : forall z1 z2 : Z, (z2 <= z1)%Z -> Zmax z1 z2 = z1. intros z1 z2 H'; rewrite ZmaxSym; apply Zmax_le2; auto. Qed. Theorem ZmaxLe2 : forall z1 z2 : Z, (z2 <= Zmax z1 z2)%Z. intros z1 z2; rewrite ZmaxSym; apply ZmaxLe1. Qed. Hint Resolve ZmaxLe1 ZmaxLe2: zarith. Theorem Zeq_Zs : forall p q : Z, (p <= q)%Z -> (q < Zsucc p)%Z -> p = q. intros p q H' H'0; apply Zle_antisym; auto. apply Zlt_succ_le; auto. Qed. Theorem Zmin_Zmax : forall z1 z2 : Z, (Zmin z1 z2 <= Zmax z1 z2)%Z. intros z1 z2; case (Zle_or_lt z1 z2); unfold Zle, Zlt, Zmin, Zmax in |- *; CaseEq (z1 ?= z2)%Z; auto; intros H1 H2; try rewrite H1; try rewrite H2; red in |- *; intros; discriminate. Qed. Theorem Zabs_Zmult : forall z1 z2 : Z, Zabs (z1 * z2) = (Zabs z1 * Zabs z2)%Z. intros z1 z2; case z1; case z2; simpl in |- *; auto with zarith. Qed. Theorem Zle_Zmult_comp_r : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (x * z <= y * z)%Z. intros x y z H' H'0; case (Zle_lt_or_eq _ _ H'); intros Zlt1. apply Zmult_gt_0_le_compat_r; auto. apply Zlt_gt; auto. rewrite <- Zlt1; repeat rewrite <- Zmult_0_r_reverse; auto with zarith. Qed. Theorem Zle_Zmult_comp_l : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (z * x <= z * y)%Z. intros x y z H' H'0; repeat rewrite (Zmult_comm z); apply Zle_Zmult_comp_r; auto. Qed. Theorem NotZmultZero : forall z1 z2 : Z, z1 <> 0%Z -> z2 <> 0%Z -> (z1 * z2)%Z <> 0%Z. 
n (ls : Blist) r := exists vals count, rel_map (fun s v => (evalDet c (ls ++ s) v)) (getAllBlists n) vals /\ pred_count (eq (ca_done a)) vals count /\ count /expnat 2 n == r.Lemma lowDistApprox_ls_impl : forall n (A : Set)(c : Comp A) a r, lowDistApprox c a n r -> lowDistApprox_ls c a n nil r. intuition. destruct H. destruct H. intuition. econstructor. econstructor. intuition. simpl. eapply rel_map_eq. eapply H0. eauto. intuition. eauto. intuition. Qed.Lemma evalDet_lowDistApprox_ls_done_inv : forall (A : Set)(eqd : eq_dec A)(c : Comp A) s a1 a2 n r, evalDet c s (ca_done a1) -> lowDistApprox_ls c a2 n s r -> r == if (eqd a2 a1) then 1 else 0. intuition. destruct H0. destruct H0. intuition. destruct (eqd a2 a1); subst. rewrite <- H3. erewrite pred_count_eq_all_inv at 1. erewrite <- rel_map_length. rewrite getAllBlists_length. apply num_dem_same_rat1. unfold posnatToNat. unfold natToPosnat. eauto. eapply H1. eauto. intuition. eapply rel_map_unary_pred. eapply H1. intuition. eapply evalDet_app_eq in H. eapply evalDet_func; eauto. trivial. rewrite <- H3. erewrite pred_count_eq_0 at 1. apply rat_num_0. 2:{ eapply H1. } 2:{ eapply H0. } intuition. subst. eapply n0. assert (ca_done a1 = ca_done a2). eapply evalDet_func. eapply evalDet_app_eq. eauto. eauto. inversion H5. trivial. Qed. Lemma low_tree_approx_same_inv_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A) ls t, dat_correct_h c ls n t -> forall a r, lowDistApprox_ls c a n ls r -> lowDistApproxFromTree eqd t a == r. induction 1; intuition; simpl in *. symmetry. eapply evalDet_lowDistApprox_ls_done_inv; eauto. inversion H0; clear H0; subst. destruct H1; intuition. simpl in *. rewrite <- H3. erewrite pred_count_eq_0 at 1. apply eqRat_symm. apply rat_num_0. 2:{ eapply H1. } 2:{ eapply H0. } intuition. simpl in *. intuition. subst. rewrite app_nil_r in *. eapply H; eauto. destruct H2. destruct H2. intuition. simpl in *. apply rel_map_app_inv in H3. intuition. apply rel_map_map_inv in H4. apply rel_map_map_inv in H6. eapply (pred_count_first_skip) in H2. destruct H2. destruct H2. intuition. rewrite IHdat_correct_h1. 2:{ econstructor. econstructor. intuition. eapply rel_map_eq. eapply H4. trivial. intuition. rewrite <- app_assoc. simpl. trivial. eapply H3. eapply eqRat_refl. } rewrite IHdat_correct_h2. 2:{ econstructor. econstructor. intuition. eapply rel_map_eq. eapply H6. trivial. intuition. rewrite <- app_assoc. simpl. trivial. eapply H2. eapply eqRat_refl. } rewrite <- ratMult_distrib_r. rewrite <- ratAdd_den_same. rewrite H8. rewrite <- ratMult_num_den. rewrite mult_1_r. unfold posnatMult. unfold natToPosnat. rewrite <- H5. eapply eqRat_terms; trivial. unfold natToPosnat, posnatToNat. rewrite mult_comm. simpl. trivial. Qed. Theorem low_tree_approx_same_inv : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) (a : A) r, dat_correct c n t -> lowDistApprox c a n r -> lowDistApproxFromTree eqd t a == r. 
Require Import List.Require Import Verdi.Net. Require Import StructTact.StructTactics.Class InverseTraceRelation `{State : Type} `{Event : Type} (step : step_relation State Event) := { init : State; T : (list Event) -> Prop; R : State -> Prop; R_dec : forall s, {R s} + {~ R s}; T_monotonic : forall tr o, T tr -> T (tr ++ o); R_false_init : ~ R init; R_implies_T : forall s s' o tr, refl_trans_1n_trace step init s tr -> ~ R s -> step s s' o -> R s' -> T (tr ++ o) }.Section InverseTraceRelations. Context `{ITR : InverseTraceRelation}. Theorem inverse_trace_relations_work : forall s tr, refl_trans_1n_trace step init s tr -> R s -> T tr. 
=> /H {}H [<-]. by apply: typing_ren_poly_type. Qed.Lemma typing_weakening {Gamma Gamma' P t} : incl Gamma Gamma' -> typing Gamma P t -> exists Œæ, typing Gamma' (ren_term id Œæ P) t. Proof. move=> /incl_nth_error [Œæ] + /typing_ren_term' H => /H ?. eexists. by eassumption. Qed. Lemma typing_normal_form_poly_arrE {Gamma P s t}: normal_form P -> typing Gamma P (poly_arr s t) -> exists Q, normal_form Q /\ term_size Q <= term_size P + 2 /\ typing (s :: Gamma) Q t. Proof. case. - move=> {}P HP. move=> /(@typing_ren_term' S) => /(_ (s :: Gamma) ltac:(done)) H. exists (app (ren_term id S P) (var 0)). constructor; last constructor. + apply: normal_form_head_form. apply: head_form_app; [by apply: head_form_ren_term | by eauto using normal_form, head_form ]. + rewrite /= term_size_ren_term. by lia. + apply: typing_app; [by eassumption | by apply: typing_var]. - move=> > ? /typingE [?] [[-> ->]] ?. eexists. constructor; first by eassumption. move=> /=. constructor; [by lia | done]. - by move=> ? ? /typingE [?] []. Qed. Lemma typing_normal_form_poly_absE {Gamma P t}: normal_form P -> typing Gamma P (poly_abs t) -> forall x, exists Q, normal_form Q /\ term_size Q <= term_size P + 2 /\ typing Gamma Q (ren_poly_type (x .: id) t). Proof. case. - move=> {}P ? HP x. exists (ty_app P (poly_var x)). constructor; first by eauto using normal_form, head_form. constructor; first by move=> /=; lia. move: HP => /typing_ty_app => /(_ (poly_var x)). congr typing. rewrite -[RHS]subst_poly_type_poly_var ?poly_type_norm. apply: ext_poly_type. by case. - by move=> > ? /typingE [?] []. - move=> {}P ? /typingE [?] [[<-]] + x. move=> /(typing_ren_poly_type (x .: id)) HP. exists (ren_term (x .: id) id P). constructor; first by apply: normal_form_ren_term. rewrite term_size_ren_term /=. constructor; first by lia. move: HP. congr typing. rewrite map_map -[RHS]map_id. apply: map_ext. move=> ?. by rewrite ?poly_type_norm ren_poly_type_id'. Qed.Lemma typing_many_app_arguments {Gamma P Qs t ss t'} : length Qs = length ss -> typing Gamma (many_app P Qs) t -> typing Gamma P (many_poly_arr ss t') -> Forall2 (typing Gamma) Qs ss. Proof. elim: Qs P t ss t'. - move=> ? ? [|] *; [by constructor | done]. - move=> Q Qs IH P ? [|? ?] ?; first done. move=> [/IH {}IH] /= /copy [/IH {}IH]. rewrite -many_argument_app_map_argument_term. move=> /typing_many_argument_subterm [?]. move=> /copy [/typingE [?] [+ ?]]. move=> /typing_functional H + /H{H} [? ?]. subst. move=> /IH ?. by constructor. Qed. Theorem typing_to_type_assignment {Gamma P t} : typing Gamma P t -> type_assignment Gamma (erase P) t. 
in *. destruct ls1; simpl in *. omega. f_equal. eapply IHn. omega. Qed.Lemma sumList_rel_func : forall (A : Set)(f : A -> Rat -> Prop) ls r1, sumList_rel f ls r1 -> forall r2, sumList_rel f ls r2 -> (forall a v1 v2, f a v1 -> f a v2 -> v1 == v2) -> r1 == r2. induction 1; intuition. inversion H0; clear H0; subst. rewrite H. rewrite H2. intuition. inversion H2; clear H2; subst. rewrite H1. rewrite H9. eapply ratAdd_eqRat_compat; eauto. Qed.Lemma sumList_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat), sumList ls f == sumList ls (fun a => (f a) * (if (P a) then 1 else 0)) + sumList ls (fun a => (f a) * (if (P a) then 0 else 1)). induction ls; intuition. unfold sumList; simpl in *. eapply ratAdd_0_l. repeat rewrite sumList_cons. destruct (P a); rewrite ratMult_0_r; rewrite <- ratAdd_0_l; rewrite ratMult_1_r; rewrite IHls. rewrite ratAdd_assoc. intuition. rewrite (ratAdd_comm (sumList ls (fun a0 : A => f a0 * (if P a0 then 1 else 0)))). rewrite <- ratAdd_assoc. rewrite <- ratAdd_comm. intuition. Qed.Lemma sumList_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat), (forall a, In a ls -> f1 a <= f2 a) -> sumList ls f1 <= sumList ls f2. induction ls; intuition. unfold sumList; simpl in *. intuition. rewrite sumList_cons. eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. rewrite sumList_cons. eapply eqRat_refl. } simpl in *. eapply ratAdd_leRat_compat. eapply H. intuition. eapply IHls. intuition. Qed.Lemma sumList_distance_prod : forall (A : Set)(ls : list A)(f f1 f2 : A -> Rat), | (sumList ls (fun a => (f a) * (f1 a))) - (sumList ls (fun a => (f a) * (f2 a))) | <= sumList ls (fun a => (f a) * | (f1 a) - (f2 a) |). induction ls; intuition. unfold sumList; simpl in *. eapply eqRat_impl_leRat. rewrite <- ratIdentityIndiscernables. intuition. repeat rewrite sumList_cons. rewrite rat_distance_of_sum. eapply ratAdd_leRat_compat. eapply eqRat_impl_leRat. eapply ratMult_ratDistance_factor_l. eapply IHls. Qed.Theorem sumList_all : forall (A : Set)(ls : list A)(f : A -> Rat) c, (forall a, In a ls -> (f a) == c) -> sumList ls f == (length ls)/1 * c. induction ls; intuition. unfold sumList; simpl. symmetry. eapply ratMult_0_l. rewrite sumList_cons. simpl in *. rewrite H; intuition. rewrite IHls; intuition. rewrite ratMult_comm. rewrite ratMult_ratAdd_cd. simpl. eapply ratMult_comm. Qed. Theorem filter_app : forall (A : Set)(ls1 ls2 : list A)(f : A -> bool), filter f (ls1 ++ ls2) = filter f ls1 ++ filter f ls2. 
~ zeroP (A:=A) A0 eqA (n:=n) a). Defined. Definition canonical (a : list (Term A n)) : Prop := olist a /\ nZterm a. Set Strict Implicit. Unset Implicit Arguments. Theorem canonical_imp_olist : forall a, canonical a -> olist a. intros a H'; elim H'; auto. Qed. Hint Resolve canonical_imp_olist. Theorem canonical0 : forall a b, ltT b a -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX a (pX b pO)). intros a b H' H'0 H'1; simpl in |- *; auto. split; simpl in |- *; auto. Qed. Theorem canonical_ltT : forall l a b, canonical (l ++ pX a (pX b pO)) -> ltT b a. intros l a b H'; auto. apply olist_ltT with (l := l); auto. Qed. Theorem canonical_nzeroP : forall a p, canonical (pX a p) -> ~ zeroP (A:=A) A0 eqA (n:=n) a. intros a p H'; red in |- *; intros H'0; inversion H'. generalize H0; simpl in |- *; intuition; auto. Qed. Theorem canonical_cons : forall l a b, ltT b a -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> canonical (pX b l) -> canonical (pX a (pX b l)). intros l a b H' H'0 H'1; split; simpl in |- *; auto. apply olist_cons; auto. repeat split; auto. inversion H'1; simpl in H0; intuition. apply canonical_nzeroP with (p := l); auto. Qed. Theorem canonical_pX_eqT : forall a b p, canonical (pX a p) -> eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX b p). intros a b p H' H'0 H'1. split; auto. apply olist_pX_eqT with (a := a); auto. simpl in |- *; split; auto. case H'; simpl in |- *; intuition. Qed. Theorem canonical_pX_order : forall l a b, canonical (pX a (pX b l)) -> ltT b a. intros l a b H'; auto. apply olist_pX_order with (l := l); auto. Qed. Theorem canonical_imp_canonical : forall l a, canonical (pX a l) -> canonical l. intros l a H'. split; auto. apply olist_X with (a := a); auto. elim H'; simpl in |- *; intuition. Qed. Theorem canonical_skip_fst : forall l a b, canonical (pX a (pX b l)) -> canonical (pX a l). intros l a b H'; split; auto. apply olist_imp_olist with (b := b); auto. inversion H'. generalize H0; simpl in |- *; intuition. Qed. Theorem canonical_pX_ltP : forall a p, canonical (pX a p) -> ltP p (pX a pO). 
intros; try congruence. { destruct o; simpl; eauto. destruct m1; simpl; eauto. destruct (pmap_remove k m2) eqn:?; try congruence. rewrite <- Heqp. eauto. } { destruct o; simpl; eauto. destruct (pmap_remove k m1) eqn:?; try congruence. - destruct m2; try congruence; eauto. destruct k; simpl; congruence. - rewrite <- Heqp. eauto. } { destruct m1; try congruence. destruct m2; try congruence. } Qed. Lemma pmap_lookup_remove_neq : forall (m : pmap) (k k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_remove k m) = Some v'. Proof. induction m. Local Ltac t := unfold branch; repeat match goal with | |- context [ match ?X with _ => _ end ] => lazymatch X with | match _ with _ => _ end => fail | _ => destruct X eqn:?; subst; try tauto end end. { destruct k; simpl; split; try congruence. } { destruct k', k; simpl; intros; try solve [ t; rewrite lookup_empty; tauto ]. { assert (k <> k') by congruence. rewrite IHm2; eauto. simpl. t. rewrite lookup_empty. tauto. } { assert (k <> k') by congruence. rewrite IHm1; eauto. simpl. t. rewrite lookup_empty. tauto. } } Qed. Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap. Proof. refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}. { abstract (induction k; simpl; congruence). } { abstract (induction k; simpl; intros; forward). } { eauto using pmap_lookup_insert_eq. } { eauto using pmap_lookup_insert_Some_neq. } { eauto using pmap_lookup_remove_eq. } { eauto using pmap_lookup_remove_neq. } Defined. Definition from_list : list T -> pmap := (fix from_list acc i ls {struct ls} := match ls with | nil => acc | List.cons l ls => from_list (pmap_insert i l acc) (Pos.succ i) ls end) Empty 1%positive.End pmap.Arguments Empty {_}. Arguments Branch {_} _ _ _.Section fmap. Variables T U : Type. Variable f : T -> U. Fixpoint fmap_pmap (m : pmap T) : pmap U := match m with | Empty => Empty | Branch h l r => Branch (fmap f h) (fmap_pmap l) (fmap_pmap r) end. Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m). Proof. induction a; destruct m; simpl; intros; try congruence. { eapply IHa. eapply H. } { eapply IHa; eapply H. } { subst. auto. } Qed. Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\ f b' = b. 
Name := | Client : Client_index -> Name | Server : Name. Definition list_Clients := map Client (all_fin num_Clients). Definition Name_eq_dec : forall a b : Name, {a = b} + {a <> b}. decide equality. apply fin_eq_dec. Qed. Inductive Msg := | Lock : Msg | Unlock : Msg | Locked : Msg. Definition Msg_eq_dec : forall a b : Msg, {a = b} + {a <> b}. decide equality. Qed. Definition Input := Msg. Definition Output := Msg. Record Data := mkData { queue : list Client_index ; held : bool }. Definition init_data (n : Name) : Data := mkData [] false. Definition Handler (S : Type) := GenHandler (Name * Msg) S Output unit. Definition ClientNetHandler (i : Client_index) (m : Msg) : Handler Data := match m with | Locked => (put (mkData [] true)) >> write_output Locked | _ => nop end. Definition ClientIOHandler (i : Client_index) (m : Msg) : Handler Data := match m with | Lock => send (Server, Lock) | Unlock => data <- get ;; when (held data) (put (mkData [] false) >> send (Server, Unlock)) | _ => nop end. Definition ServerNetHandler (src : Name) (m : Msg) : Handler Data := st <- get ;; let q := queue st in match m with | Lock => match src with | Server => nop | Client c => when (null q) (send (src, Locked)) >> put (mkData (q++[c]) (held st)) end | Unlock => match q with | _ :: x :: xs => put (mkData (x :: xs) (held st)) >> send (Client x, Locked) | _ => put (mkData [] (held st)) end | _ => nop end. Definition ServerIOHandler (m : Msg) : Handler Data := nop. Definition NetHandler (nm src : Name) (m : Msg) : Handler Data := match nm with | Client c => ClientNetHandler c m | Server => ServerNetHandler src m end. Definition InputHandler (nm : Name) (m : Msg) : Handler Data := match nm with | Client c => ClientIOHandler c m | Server => ServerIOHandler m end. Ltac handler_unfold := repeat (monad_unfold; unfold NetHandler, InputHandler, ServerNetHandler, ClientNetHandler, ClientIOHandler, ServerIOHandler in *). Definition Nodes := Server :: list_Clients. Theorem In_n_Nodes : forall n : Name, In n Nodes. Proof using. intros. unfold Nodes, list_Clients. simpl. destruct n. - right. apply in_map. apply all_fin_all. - left. reflexivity. Qed. Theorem nodup : NoDup Nodes. 
int_size * (1+(i+(Z.of_nat (length vs)))) <= ofs')%Z) -> Mem.load int_chunk m' b' ofs' = Mem.load int_chunk m b' ofs'. Proof. induction vs; intros; inv H. - eapply Mem.load_store_other. apply H8. unfold int_size in *. rewrite <- Zred_factor3 in H0. rewrite Z.add_assoc in H0. simpl length in H0. simpl Z.of_nat in H0. inv H0; auto. inv H; auto. right; right. rewrite Z.add_comm with (n := i) in H0. rewrite <- Zred_factor3 in H0. rewrite Z.add_assoc in H0. simpl size_chunk in H0. assert (Hisp := int_size_pos). omega. - eapply IHvs in H9. symmetry. erewrite <- Mem.load_store_other. symmetry. apply H9. apply H5. { destruct H0; auto. unfold int_size in *. destruct H; auto. right. right. simpl length in H. rewrite Nat2Z.inj_succ in H. chunk_red ; omega. } { assert (Hisp := int_size_pos). unfold int_size in *. simpl size_chunk in *. simpl length in H0. rewrite Nat2Z.inj_succ in H0. destruct H0; auto. destruct H. right. left. chunk_red; omega. right. right. chunk_red; omega. } Qed. Theorem mem_after_n_proj_store_unchanged: forall L b ofs vs i m m', mem_after_n_proj_store b ofs vs i m m' -> (forall j, (ofs+int_size*i) <= j < ofs+int_size*(i + Z.of_nat (length vs)) -> ~ L b j)%Z -> Mem.unchanged_on L m m'. Proof. induction vs; intros; inv H. - eapply Mem.store_unchanged_on; eauto. intros. apply H0. unfold int_size in *. simpl length. simpl Z.of_nat. chunk_red; omega. - apply Mem.unchanged_on_trans with (m2 := m'0). + eapply Mem.store_unchanged_on; eauto. intros. apply H0. simpl length. rewrite Nat2Z.inj_succ. chunk_red; omega. + eapply IHvs; eauto. intros. apply H0. simpl length. rewrite Nat2Z.inj_succ. chunk_red; omega. Qed.Theorem mem_after_n_proj_snoc_unchanged: forall L b ofs vs m m', mem_after_n_proj_snoc b ofs vs m m' -> (forall j, ofs <= j < ofs+int_size*(Z.of_nat (length vs)) -> ~ L b j)%Z -> Mem.unchanged_on L m m'. Proof. induction vs. - intros. inv H. apply Mem.unchanged_on_refl. - intros. inv H. apply Mem.unchanged_on_trans with (m2 := m'0). + apply IHvs in H5; auto. simpl length in H0. rewrite Nat2Z.inj_succ in H0. intros. apply H0. chunk_red; omega. + eapply Mem.store_unchanged_on; eauto. intros. simpl length in H0. rewrite Nat2Z.inj_succ in H0. intros. apply H0. chunk_red; omega. Qed. Definition prefix_ctx {A:Type} rho' rho := forall x v, M.get x rho' = Some v -> @M.get A x rho = Some v. Definition repr_unboxed_L7: N -> Z -> Prop := fun t => fun h => (h = (Z.shiftl (Z.of_N t) 1) + 1)%Z /\ (0 <= (Z.of_N t) < Ptrofs.half_modulus )%Z. Theorem repr_unboxed_eqm: forall h t, repr_unboxed_L7 t h -> Ptrofs.eqm h (Z.of_N ((N.shiftl t 1) + 1)). 
replace (- Zsucc (Zneg p))%Z with (Zpos p - 1)%Z. replace (Zsucc (Zabs (Zneg p))) with (Zpos p + 1)%Z; auto with zarith. unfold Zsucc in |- *; rewrite Zopp_plus_distr. auto with zarith. Qed. Hint Resolve Zabs_Zs: zarith. Theorem Zle_Zpred : forall x y : Z, (x < y)%Z -> (x <= Zpred y)%Z. intros x y H; apply Zlt_succ_le. rewrite <- Zsucc_pred; auto. Qed. Hint Resolve Zle_Zpred: zarith. Theorem Zabs_Zopp : forall z : Z, Zabs (- z) = Zabs z. intros z; case z; simpl in |- *; auto. Qed. Theorem Zle_Zabs : forall z : Z, (z <= Zabs z)%Z. intros z; case z; simpl in |- *; red in |- *; simpl in |- *; auto; try (red in |- *; intros; discriminate; fail). intros p; elim p; simpl in |- *; auto; try (red in |- *; intros; discriminate; fail). Qed. Hint Resolve Zle_Zabs: zarith. Theorem Zlt_mult_simpl_l : forall a b c : Z, (0 < c)%Z -> (c * a < c * b)%Z -> (a < b)%Z. intros a b0 c H H0; apply Zgt_lt. apply Zmult_gt_reg_r with (p := c); try apply Zlt_gt; auto with zarith. repeat rewrite (fun x => Zmult_comm x c); auto with zarith. Qed. Fixpoint pos_eq_bool (a b : positive) {struct b} : bool := match a, b with | xH, xH => true | xI a', xI b' => pos_eq_bool a' b' | xO a', xO b' => pos_eq_bool a' b' | _, _ => false end. Theorem pos_eq_bool_correct : forall p q : positive, match pos_eq_bool p q with | true => p = q | false => p <> q end. intros p q; generalize p; elim q; simpl in |- *; auto; clear p q. intros p Rec q; case q; simpl in |- *; try (intros; red in |- *; intros; discriminate; fail). intros q'; generalize (Rec q'); case (pos_eq_bool q' p); simpl in |- *; auto. intros H1; rewrite H1; auto. intros H1; Contradict H1; injection H1; auto. intros p Rec q; case q; simpl in |- *; try (intros; red in |- *; intros; discriminate; fail). intros q'; generalize (Rec q'); case (pos_eq_bool q' p); simpl in |- *; auto. intros H1; rewrite H1; auto. intros H1; Contradict H1; injection H1; auto. intros q; case q; simpl in |- *; try (intros; red in |- *; intros; discriminate; fail); auto. Qed. Theorem Z_O_1 : (0 < 1)%Z. 
Require Import List Arith Omega.Require Import utils_tac utils_list sums pos vec. Require Import sss mm_defs fractran_defs fractran_dio mm_fractran prime_seq. Require Import dio_logic dio_elem dio_single.Set Implicit Arguments.Local Notation "P /MM/ s ‚Üì" := (sss_terminates (@mm_sss _) P s) (at level 70, no associativity). Local Notation "l '/F/' x ‚Üì" := (fractran_terminates l x) (at level 70, no associativity). Local Notation "'‚ü¶' p '‚üß'" := (fun œÜ ŒΩ => dp_eval œÜ ŒΩ p).Definition mm_recognisable_n n (R : vec nat n -> Prop) := { m & { M : list (mm_instr (n+m)) | forall v, R v <-> (1,M) /MM/ (1,vec_app v vec_zero) ‚Üì } }.Definition diophantine_n n (R : vec nat n -> Prop) := { m : nat & { p : dio_polynomial (pos m) (pos n) & { q : dio_polynomial (pos m) (pos n) | forall v, R v <-> exists w, ‚ü¶p‚üß (vec_pos w) (vec_pos v) = ‚ü¶q‚üß (vec_pos w) (vec_pos v) } } }.Section DPRM_n. Variable (n : nat) (R : vec nat n -> Prop) (HR : mm_recognisable_n R). Let FRACTRAN : { l | forall v, R v <-> l /F/ ps 1 * exp 1 v ‚Üì }. Proof. destruct HR as (m & Q & HQ). destruct mm_fractran_n with (P := Q) as (l & _ & Hl). exists l. intros x; rewrite HQ, Hl. rewrite exp_app, exp_zero, Nat.mul_1_r; tauto. Qed. Theorem DPRM_n : diophantine_n R. 
prod. Definition prod_is_id := Monoid.is_id E prod. Definition prod_monoid := Monoid.monoid E 1 {#} prod_is_assoc prod_id_l prod_id_r. Theorem prod_id : prod_is_id 1. Proof Monoid.op_id prod_monoid. Theorem prod_id_l_uniq : forall x : E, (Monoid.is_id_l E prod x) -> x = 1. Proof Monoid.op_id_l_uniq prod_monoid. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E prod x) -> x = 1. Proof Monoid.op_id_r_uniq prod_monoid. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E prod x) -> x = 1. Proof Monoid.op_id_uniq prod_monoid. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. Proof Monoid.op_intro_l prod_monoid. Theorem prod_intro_r : forall x y z : E, x = y -> x # z = y # z. Proof Monoid.op_intro_r prod_monoid. Definition prod_is_inv_l := Monoid.op_is_inv_l prod_monoid. Definition prod_is_inv_r := Monoid.op_is_inv_r prod_monoid. Definition prod_is_inv := Monoid.op_is_inv prod_monoid. Definition prod_has_inv_l := Monoid.has_inv_l prod_monoid. Definition prod_has_inv_r := Monoid.has_inv_r prod_monoid. Definition prod_has_inv := Monoid.has_inv prod_monoid. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. Proof Monoid.op_inv_l_r_eq prod_monoid. Theorem prod_inv_sym : forall x y : E, prod_is_inv x y <-> prod_is_inv y x. Proof Monoid.op_inv_sym prod_monoid. Theorem prod_cancel_l : forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y. Proof Monoid.op_cancel_l prod_monoid. Theorem prod_cancel_r : forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y. Proof Monoid.op_cancel_r prod_monoid. Theorem prod_inv_l_uniq : forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Monoid.op_inv_l_uniq prod_monoid. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Monoid.op_inv_r_uniq prod_monoid. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Monoid.op_inv_uniq prod_monoid. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Monoid.op_has_inv_l_0 prod_monoid. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Monoid.op_has_inv_r_0 prod_monoid. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Monoid.op_has_inv_0 prod_monoid. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Monoid.op_inv_0_eq_0 prod_monoid. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. 
From Perennial.algebra Require Import append_list. From Perennial.Helpers Require Import Integers List Map. From Perennial.program_proof.wal Require Import abstraction.From Perennial.program_proof Require Import disk_prelude.Class txns_ctxG Œ£ := { txns_ctx_alist :> alistG Œ£ (u64 * list update.t) }. Definition txns_ctxŒ£ : gFunctors := #[alistŒ£ (u64 * list update.t)].#[global] Instance subG_txns_ctx Œ£ : subG txns_ctxŒ£ Œ£ ‚Üí txns_ctxG Œ£. Proof. solve_inG. Qed.Section goose. Context `{!heapGS Œ£} `{!txns_ctxG Œ£}. Implicit Types (Œ≥:gname).Definition txn_val Œ≥ txn_id (txn: u64 * list update.t): iProp Œ£ := list_el Œ≥ txn_id txn.Definition txn_pos Œ≥ txn_id (pos: u64) : iProp Œ£ := ‚àÉ upds, txn_val Œ≥ txn_id (pos, upds).Definition txns_ctx Œ≥ txns : iProp Œ£ := list_ctx Œ≥ 1 txns.Theorem alloc_txns_ctx E txns : ‚ä¢ |={E}=> ‚àÉ Œ≥txns, txns_ctx Œ≥txns txns. Proof. iMod (alist_alloc txns) as (Œ≥txns) "Hctx". iExists Œ≥txns. rewrite /txns_ctx //=. Qed.Theorem txn_val_to_pos Œ≥ txn_id pos upds : txn_val Œ≥ txn_id (pos, upds) -‚àó txn_pos Œ≥ txn_id pos. Proof. rewrite /txn_pos. iIntros "Hval". iExists _; iFrame. Qed.Lemma txns_ctx_app {Œ≥} txns' txns : txns_ctx Œ≥ txns ==‚àó txns_ctx Œ≥ (txns ++ txns'). Proof. rewrite /txns_ctx. iIntros "Hctx". by iMod (alist_app _ txns' with "Hctx") as "[$ _]". Qed.Global Instance txn_pos_timeless Œ≥ txn_id pos : Timeless (txn_pos Œ≥ txn_id pos) := _.Global Instance txn_pos_persistent Œ≥ txn_id pos : Persistent (txn_pos Œ≥ txn_id pos) := _.Definition txns_are Œ≥ (start: nat) (txns_sub: list (u64*list update.t)) : iProp Œ£ := list_subseq Œ≥ start txns_sub.Global Instance txns_are_Persistent Œ≥ start txns_sub : Persistent (txns_are Œ≥ start txns_sub). Proof. apply _. Qed.Theorem txns_are_sound Œ≥ txns start txns_sub : txns_ctx Œ≥ txns -‚àó txns_are Œ≥ start txns_sub -‚àó ‚åúsubslice start (start + length txns_sub)%nat txns = txns_sub‚åù. Proof. iIntros "Hctx Htxns_are". iDestruct (alist_subseq_lookup with "Hctx Htxns_are") as "$". Qed.Lemma txns_are_unify Œ≥ txns start txns_sub1 txns_sub2 : txns_ctx Œ≥ txns -‚àó txns_are Œ≥ start txns_sub1 -‚àó txns_are Œ≥ start txns_sub2 -‚àó ‚åúlength txns_sub1 = length txns_sub2‚åù -‚àó ‚åútxns_sub1 = txns_sub2‚åù. Proof. iIntros "Htxns_ctx Htxns_sub1 Htxns_sub2 %Hlen". iDestruct (txns_are_sound with "Htxns_ctx Htxns_sub1") as %<-. iDestruct (txns_are_sound with "Htxns_ctx Htxns_sub2") as %<-. rewrite <-Hlen. eauto. Qed.Lemma txns_are_nil Œ≥ start : ‚ä¢ txns_are Œ≥ start []. Proof. iApply list_subseq_nil. Qed. Theorem alloc_txn_pos pos upds Œ≥ txns : txns_ctx Œ≥ txns ==‚àó txns_ctx Œ≥ (txns ++ [(pos, upds)]) ‚àó txn_val Œ≥ (length txns) (pos, upds). 
(drop (length l1) l2). apply list_eq_bounded. - list_simpl; lia. - intros i Hlt. destruct (decide (i < length l1)). + list_simpl. rewrite Heq //. + list_simpl. auto with list lia. Qed.End list.Ltac find_list_hyps := repeat match goal with | H: @eq (list _) ?l1 ?l2 |- _ => learn_hyp (list_eq_length l1 l2 H); pose proof (list_eq_forall l1 l2 H); clear H | H: ?l1 `prefix_of` ?l2 |- _ => let Hnew := fresh H "len" in learn_hyp (prefix_length l1 l2 H) as Hnew; pose proof (list_prefix_forall l1 l2 H); clear H end.Ltac learn_feed_as H i := feed_core H using (fun p => let P := type of p in lazymatch goal with | H: P |- _ => fail 1 | _ => pose proof p as i end).Ltac use_list_hyps := repeat match goal with | H: (forall (i:nat), _), i: nat |- _ => let Hi := fresh H i in learn_feed_as (H i) Hi; [ lia .. | ] end.Ltac start_list_eq := let i := fresh "i" in first [ apply list_eq_bounded; [ lia | intros i ? ] | apply list_eq; intros i ].Definition lt_le_dec n1 n2 : {n1 < n2} + {n2 ‚â§ n1}. Proof. destruct (decide (n1 < n2)); [ left | right ]; lia. Qed. Ltac split_i l i := first [ assert_succeeds ((assert (i < length l) by lia) || (assert (length l ‚â§ i) by lia)); fail 1 "i < length l or not already" | destruct (lt_le_dec i (length l)) ].Ltac split_app_lookups := repeat match goal with | |- context[(?l1 ++ _) !! ?i] => split_i l1 i | H: context[(?l1 ++ _) !! ?i] |- _ => split_i l1 i end.Ltac solve_list_eq := find_list_hyps; start_list_eq; repeat first [ progress list_simpl | progress use_list_hyps | progress split_app_lookups ]; auto with lia list.Ltac start_list_prefix := apply list_prefix_bounded; [ list_simpl; solve [ auto with list lia ] | let i := fresh "i" in let Hle := fresh "Hle" in intros i Hle ].Ltac solve_list_prefix := find_list_hyps; start_list_prefix; list_simpl; use_list_hyps; list_simpl; auto with lia list.Ltac solve_list_general := find_list_hyps; list_simpl; auto with lia list.Ltac list_solver := autounfold with list in *; intros; lazymatch goal with | |- @eq (list _) _ _ => solve [ solve_list_eq ] | |- _ `prefix_of` _ => solve [ solve_list_prefix ] | _ => solve [ solve_list_general ] end.Section test. Context {A: Type}. Implicit Types (l: list A). Theorem test_1 l1 l2 : length l2 ‚â§ length l1 ‚Üí l1 `prefix_of` l2 ‚Üí l1 = l2. 
assumption. subst. clear H0. generalize dependent y. generalize dependent l. clear. induction l; intros; simpl. inversion H3. inversion H3. inversion H. rewrite H0 in H4; assumption. inversion H; apply IHl; auto. Defined.Lemma wf_R_expr ts : well_founded (@R_expr ts). Proof. let v := eval cbv beta iota zeta delta [ wf_R_expr' list_ind list_rec list_rect eq_ind eq_ind_r eq_rect eq_sym expr_ind ] in (@wf_R_expr' ts) in exact v. Defined. Module Unifier (E : OrderedType.OrderedType with Definition t := uvar with Definition eq := @eq uvar) <: SynUnifier. Module FM := FMapAVL.Make E. Remove Hints FM.E.eq_sym FM.E.eq_refl FM.E.eq_trans FM.E.lt_not_eq FM.E.lt_trans FM.Raw.Proofs.L.PX.eqk_refl FM.Raw.Proofs.L.PX.eqk_sym FM.Raw.Proofs.L.PX.eqk_trans FM.Raw.Proofs.PX.eqk_refl FM.Raw.Proofs.PX.eqk_sym FM.Raw.Proofs.PX.eqk_trans FM.Raw.Proofs.L.PX.eqke_refl FM.Raw.Proofs.L.PX.eqke_sym FM.Raw.Proofs.L.PX.eqke_trans FM.Raw.Proofs.PX.eqke_refl FM.Raw.Proofs.PX.eqke_sym FM.Raw.Proofs.PX.eqke_trans FM.Raw.Proofs.L.PX.MO.lt_eq FM.Raw.Proofs.L.PX.MO.eq_lt FM.Raw.Proofs.L.MX.lt_eq FM.Raw.Proofs.L.MX.eq_lt FM.Raw.Proofs.PX.MO.lt_eq FM.Raw.Proofs.PX.MO.eq_lt FM.Raw.Proofs.MX.lt_eq FM.Raw.Proofs.MX.eq_lt FM.Raw.Proofs.L.PX.eqk_ltk FM.Raw.Proofs.L.PX.ltk_eqk FM.Raw.Proofs.L.PX.ltk_trans FM.Raw.Proofs.PX.eqk_ltk FM.Raw.Proofs.PX.ltk_eqk FM.Raw.Proofs.PX.ltk_trans FM.Raw.Proofs.L.PX.MO.lt_antirefl FM.Raw.Proofs.L.MX.lt_antirefl FM.Raw.Proofs.PX.MO.lt_antirefl FM.Raw.Proofs.MX.lt_antirefl FM.Raw.Proofs.L.PX.eqk_not_ltk FM.Raw.Proofs.L.PX.ltk_not_eqke FM.Raw.Proofs.L.PX.ltk_not_eqk FM.Raw.Proofs.L.PX.MO.lt_not_gt FM.Raw.Proofs.L.PX.MO.eq_not_gt FM.Raw.Proofs.L.PX.MO.eq_neq FM.Raw.Proofs.L.PX.MO.neq_eq FM.Raw.Proofs.L.PX.MO.eq_le FM.Raw.Proofs.L.PX.MO.le_eq FM.Raw.Proofs.L.PX.MO.eq_not_lt FM.Raw.Proofs.L.PX.MO.gt_not_eq FM.Raw.Proofs.L.MX.lt_not_gt FM.Raw.Proofs.L.MX.eq_not_gt FM.Raw.Proofs.L.MX.eq_neq FM.Raw.Proofs.L.MX.neq_eq FM.Raw.Proofs.L.MX.eq_le FM.Raw.Proofs.L.MX.le_eq FM.Raw.Proofs.L.MX.eq_not_lt FM.Raw.Proofs.L.MX.gt_not_eq FM.Raw.Proofs.PX.eqk_not_ltk FM.Raw.Proofs.PX.ltk_not_eqke FM.Raw.Proofs.PX.ltk_not_eqk FM.Raw.Proofs.PX.MO.lt_not_gt FM.Raw.Proofs.PX.MO.eq_not_gt FM.Raw.Proofs.PX.MO.eq_neq FM.Raw.Proofs.PX.MO.neq_eq FM.Raw.Proofs.PX.MO.eq_le FM.Raw.Proofs.PX.MO.le_eq FM.Raw.Proofs.PX.MO.eq_not_lt FM.Raw.Proofs.PX.MO.gt_not_eq FM.Raw.Proofs.MX.lt_not_gt FM.Raw.Proofs.MX.eq_not_gt FM.Raw.Proofs.MX.eq_neq FM.Raw.Proofs.MX.neq_eq FM.Raw.Proofs.MX.eq_le FM.Raw.Proofs.MX.le_eq FM.Raw.Proofs.MX.eq_not_lt FM.Raw.Proofs.MX.gt_not_eq FM.Raw.Proofs.L.PX.Sort_Inf_NotIn FM.Raw.Proofs.PX.Sort_Inf_NotIn FM.Raw.Proofs.L.PX.Inf_eq FM.Raw.Proofs.L.PX.MO.Inf_lt FM.Raw.Proofs.L.MX.Inf_lt FM.Raw.Proofs.PX.Inf_eq FM.Raw.Proofs.PX.MO.Inf_lt FM.Raw.Proofs.MX.Inf_lt FM.Raw.Proofs.L.PX.Inf_lt FM.Raw.Proofs.L.PX.MO.Inf_lt FM.Raw.Proofs.L.MX.Inf_lt FM.Raw.Proofs.PX.Inf_lt FM.Raw.Proofs.PX.MO.Inf_lt FM.Raw.Proofs.MX.Inf_lt FM.Raw.InRight FM.Raw.InLeft FM.Raw.InRoot FM.Raw.Proofs.L.PX.InA_eqke_eqk FM.Raw.Proofs.L.PX.MO.In_eq FM.Raw.Proofs.L.PX.MO.ListIn_In FM.Raw.Proofs.L.MX.In_eq FM.Raw.Proofs.L.MX.ListIn_In FM.Raw.Proofs.PX.InA_eqke_eqk FM.Raw.Proofs.PX.MO.In_eq FM.Raw.Proofs.PX.MO.ListIn_In FM.Raw.Proofs.MX.In_eq FM.Raw.Proofs.MX.ListIn_In FM.Raw.Proofs.L.PX.In_inv_3 FM.Raw.Proofs.PX.In_inv_3 FM.Raw.Proofs.L.PX.In_inv_2 FM.Raw.Proofs.PX.In_inv_2 FM.Raw.MapsRight FM.Raw.MapsLeft FM.Raw.MapsRoot FM.Raw.Proofs.L.PX.MO.Sort_NoDup FM.Raw.Proofs.L.MX.Sort_NoDup FM.Raw.Proofs.PX.MO.Sort_NoDup FM.Raw.Proofs.MX.Sort_NoDup FM.Raw.BSLeaf FM.Raw.BSNode FM.Raw.Leaf FM.Raw.Node. Module FACTS := FMapFacts.Facts FM. Module MFACTS := NatMap.MoreFMapFacts FM. Module PROPS := FMapFacts.Properties FM. Section typed. Variable types : list type. Section Normalization. Variable ctx : FM.t (expr types). Fixpoint normalized (e : expr types) : bool := match e with | Var _ | Const _ _ => true | UVar x => match FM.find x ctx with | None => true | Some _ => false end | Not e => normalized e | Equal _ e1 e2 => (normalized e1) && (normalized e2) | Func _ l => fold_right (fun x acc => acc && (normalized x)) true l end. End Normalization. Definition WellFormed (this : FM.t (expr types)) : Prop := forall k v, FM.MapsTo k v this -> normalized this v = true. Definition Subst : Type := { this : FM.t (expr types) & WellFormed this }. Definition Subst_WellTyped (funcs : tfunctions) (U G : tenv) (s : Subst) : Prop := forall k v, FM.MapsTo k v (projT1 s) -> exists t, nth_error U k = Some t /\ is_well_typed funcs U G v t = true. Definition subst_empty : FM.t (expr types) := FM.empty _. Theorem WF_subst_empty : WellFormed subst_empty. 
hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop := forall st st', c / st \\ st' -> P st -> Q st'.Notation "{{ P }} c {{ Q }}" := (hoare_triple P c Q) (at level 90, c at next level) : hoare_spec_scope.Theorem hoare_post_true : forall (P Q : Assertion) c, (forall st, Q st) -> {{P}} c {{Q}}. Admitted. Theorem hoare_pre_false : forall (P Q : Assertion) c, (forall st, ~(P st)) -> {{P}} c {{Q}}. Admitted. Definition assn_sub X a P : Assertion := fun (st : state) => P (t_update st X (aeval st a)).Notation "P [ X |-> a ]" := (assn_sub X a P) (at level 10).Theorem hoare_asgn : forall Q X a, {{assn_sub X a Q }} (X ::= a) {{Q}}. Admitted. Theorem hoare_asgn_fwd : (forall {X Y: Type} {f g : X -> Y}, (forall (x: X), f x = g x) -> f = g) -> forall m a P, {{fun st => P st /\ t_lookup st X = m}} X ::= a {{fun st => P (t_update st X m) /\ t_lookup st X = aeval (t_update st X m) a }}. Admitted. Theorem hoare_asgn_fwd_exists : (forall {X Y: Type} {f g : X -> Y}, (forall (x: X), f x = g x) -> f = g) -> forall a P, {{fun st => P st}} X ::= a {{fun st => exists m, P (t_update st X m) /\ t_lookup st X = aeval (t_update st X m) a }}. Admitted. Theorem hoare_consequence_pre : forall (P P' Q : Assertion) c, {{P'}} c {{Q}} -> P ->> P' -> {{P}} c {{Q}}. Admitted. Theorem hoare_consequence_post : forall (P Q Q' : Assertion) c, {{P}} c {{Q'}} -> Q' ->> Q -> {{P}} c {{Q}}. Admitted. Theorem hoare_consequence : forall (P P' Q Q' : Assertion) c, {{P'}} c {{Q'}} -> P ->> P' -> Q' ->> Q -> {{P}} c {{Q}}. Admitted. Lemma silly1 : forall (P : nat -> nat -> Prop) (Q : nat -> Prop), (forall x y : nat, P x y) -> (forall x y : nat, P x y -> Q x) -> Q 42. Admitted. Lemma silly2 : forall (P : nat -> nat -> Prop) (Q : nat -> Prop), (exists y, P 42 y) -> (forall x y : nat, P x y -> Q x) -> Q 42. Admitted. Theorem hoare_skip : forall P, {{P}} SKIP {{P}}. 
ms = fst ms'). Inductive logstate := | Synced (na : nat) (d : diskstate) | Flushing (d : diskstate) (ents : DLog.contents) | Applying (d : diskstate) | Rollback (d : diskstate) | Recovering (d : diskstate) . Definition equal_unless_in (keys: list addr) (l1 l2: list valuset) := length l1 = length l2 /\ forall a, ~ In a keys -> selN l1 a ($0, nil) = selN l2 a ($0, nil). Definition synced_rep xp (d : diskstate) : rawpred := arrayS (DataStart xp) d. Definition unsync_rep xp (ms : valumap) (old : diskstate) : rawpred := (exists vs, [[ equal_unless_in (map_keys ms) old vs ]] * arrayS (DataStart xp) vs )%pred. Definition rep xp st mm hm := ( exists log d0, [[ Map.Equal mm (replay_mem log vmap0) ]] * [[ goodSize addrlen (length d0) /\ map_valid mm d0 ]] * match st with | Synced na d => [[ map_replay mm d0 d ]] * synced_rep xp d0 * DLog.rep xp (DLog.Synced na log) hm | Flushing d ents => exists na, [[ log_valid ents d /\ map_replay mm d0 d ]] * synced_rep xp d0 * (DLog.rep xp (DLog.Synced na log) hm \/ DLog.rep xp (DLog.Extended log ents) hm) | Applying d => exists na, [[ map_replay mm d0 d ]] * (((DLog.rep xp (DLog.Synced na log) hm) * (unsync_rep xp mm d0)) \/ ((DLog.rep xp (DLog.Truncated log) hm) * (synced_rep xp d))) | Rollback d => [[ map_replay mm d0 d ]] * synced_rep xp d0 * DLog.rep xp (DLog.Rollback log) hm | Recovering d => [[ map_replay mm d0 d ]] * synced_rep xp d0 * DLog.rep xp (DLog.Recovering log) hm end)%pred. Definition would_recover_before xp d hm := (exists mm, rep xp (Applying d) mm hm \/ exists mm na', rep xp (Synced na' d) mm hm)%pred. Definition would_recover_either xp d ents hm := (exists mm, (exists na', rep xp (Synced na' d) mm hm) \/ (exists na', rep xp (Synced na' (replay_disk ents d)) mm hm) \/ rep xp (Flushing d ents) mm hm \/ rep xp (Applying d) mm hm \/ rep xp (Recovering d) mm hm)%pred. Theorem sync_invariant_rep : forall xp st mm hm, sync_invariant (rep xp st mm hm). Proof. unfold rep, synced_rep, unsync_rep; destruct st; intros; eauto 20. Qed. Hint Resolve sync_invariant_rep. Theorem sync_invariant_would_recover_before : forall xp d hm, sync_invariant (would_recover_before xp d hm). Proof. unfold would_recover_before; eauto. Qed. Theorem sync_invariant_would_recover_either : forall xp d ents hm, sync_invariant (would_recover_either xp d ents hm). 
Require Import Coq.Lists.List. Require Import Monads.Monad. Require Import Tactics.CpdtTactics.Set Implicit Arguments. Module List <: Monad. Definition m := list. Definition ret {A : Type} (x : A) := cons x nil. Definition bind {A B : Type} (n : list A) (f : A -> list B) := concat (map f n). Infix ">>=" := bind (at level 50, left associativity). Ltac nake := unfold m; unfold ret; unfold bind. Theorem left_id : forall (A B : Type) (x : A) (f : A -> m B), ret x >>= f = f x. 
by <- op_id_l x. Theorem op_id_uniq : forall x : M, (op_is_id x) -> x = 0. Proof fun x => and_ind (fun H _ => op_id_l_uniq x H). Theorem op_intro_l : forall x y z : M, x = y -> z + x = z + y. Proof fun x y z H => f_equal ({+} z) H. Theorem op_intro_r : forall x y z : M, x = y -> x + z = y + z. Proof fun x y z H => eq_refl (x + z) || x + z = a + z @a by <- H. Definition op_is_inv_l := is_inv_l M {+} 0 op_id. Definition op_is_inv_r := is_inv_r M {+} 0 op_id. Definition op_is_inv := is_inv M {+} 0 op_id. Definition has_inv_l := fun x => exists y : M, op_is_inv_l x y. Definition has_inv_r := fun x => exists y : M, op_is_inv_r x y. Definition has_inv := fun x => exists y : M, op_is_inv x y. Theorem op_inv_l_r_eq : forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z. Proof fun x y H1 z H2 => op_is_assoc y x z || y + a = (y + x) + z @a by <- H2 || a = (y + x) + z @a by <- op_id_r y || y = a + z @a by <- H1 || y = a @a by <- op_id_l z. Theorem op_inv_sym : forall x y : M, op_is_inv x y <-> op_is_inv y x. Proof fun x y => conj (fun H : op_is_inv x y => conj (proj2 H) (proj1 H)) (fun H : op_is_inv y x => conj (proj2 H) (proj1 H)). Theorem op_cancel_l : forall x y z : M, has_inv_l z -> z + x = z + y -> x = y. Proof fun x y z H H0 => ex_ind (fun u H1 => op_intro_l (z + x) (z + y) u H0 || a = u + (z + y) @a by <- op_is_assoc u z x || (u + z) + x = a @a by <- op_is_assoc u z y || a + x = a + y @a by <- H1 || a = 0 + y @a by <- op_id_l x || x = a @a by <- op_id_l y) H. Theorem op_cancel_r : forall x y z : M, has_inv_r z -> x + z = y + z -> x = y. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Import Coq.Bool.Bool. Require Import Coq.Arith.Arith. Require Import Coq.Arith.EqNat. Require Import Coq.lia.Lia. Require Import Imp. Require Import Maps. Definition Assertion := state -> Prop.Definition assert_implies (P Q : Assertion) : Prop := forall st, P st -> Q st.Notation "P ->> Q" := (assert_implies P Q) (at level 80) : hoare_spec_scope. Open Scope hoare_spec_scope.Notation "P <<->> Q" := (P ->> Q /\ Q ->> P) (at level 80) : hoare_spec_scope.Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop := forall st st', c / st \\ st' -> P st -> Q st'.Notation "{{ P }} c {{ Q }}" := (hoare_triple P c Q) (at level 90, c at next level) : hoare_spec_scope.Theorem hoare_post_true : forall (P Q : Assertion) c, (forall st, Q st) -> {{P}} c {{Q}}. Admitted. Theorem hoare_pre_false : forall (P Q : Assertion) c, (forall st, ~(P st)) -> {{P}} c {{Q}}. 
Require Import Coq.micromega.Lia. Require Import Main.Kleene.KleeneData. Require Import Main.Tactics.Module KleeneTheorems (Kleene : KleeneData). Import Kleene. Definition monotone f := forall x1 x2, leq x1 x2 -> leq (f x1) (f x2). #[export] Hint Unfold monotone : main. Definition continuous (f : T -> T) := forall P x1, directed P -> supremum P x1 -> supremum (fun x2 => exists x3, P x3 /\ x2 = f x3) (f x1). #[export] Hint Unfold continuous : main. Fixpoint approx f n := match n with | 0 => bottom | S n => f (approx f n) end. #[local] Theorem natDiff : forall n1 n2, exists n3, n1 = n2 + n3 \/ n2 = n1 + n3. Proof. clean. induction n1; eMagic. clean. destruct H. - exists (S x). lia. - destruct x; [exists 1 | exists x]; lia. Qed. #[local] Hint Resolve natDiff : main. Theorem supremumUniqueness : forall P x1 x2, supremum P x1 -> supremum P x2 -> x1 = x2. 
Require Import List. Require Import Arith.Fixpoint update_primes (k:nat) (l: list (nat*nat)) {struct l} : list (nat*nat)*bool := match l with | nil => (nil,false) | (p,n)::tl => let (l',b) := update_primes k tl in match Nat.compare k n with | Lt => ((p, n)::l', b) | Eq => ((p, n+p)::l', true) | Gt => ((p, n+p)::l', b) end end.Fixpoint prime_sieve (n:nat) : list (nat*nat) := match n with | O => nil | 1 => nil | S k' => let (l', b) := update_primes (S k')(prime_sieve k') in if b then l' else ((S k', 2*S k')::l') end.Definition prime_fun (n:nat) : bool := match prime_sieve n with | nil => false | (p,q)::tl => match Nat.compare p n with | Eq => true | _ => false end end. Definition divides (p n:nat) := exists q:nat, n = p*q.Definition prime (n:nat) := (n<>0/\n<>1)/\~(exists k:nat, 1 < k < n /\ divides k n).Definition all_list(P:nat->nat->Prop) (l:list(nat*nat)):= forall (l1 l2:list(nat*nat))(p n:nat), l = l1++(p, n)::l2 -> (P p n).Definition all_first_less_than (k:nat) := all_list (fun p n:nat => p < k).Definition all_first_prime := all_list (fun p n:nat => prime p).Definition all_intervals (k:nat) := all_list (fun p n:nat => n-p<k<=n).Definition all_multiples := all_list (fun p n:nat => exists q:nat, n=p*q).Definition all_greater_than_one := all_list (fun p n => 1 < p).Definition all_prime_in_first (k:nat)(l:list (nat*nat)) := forall n:nat, 0 < n < k -> prime n -> (exists l1: list (nat*nat), (exists l2: list (nat*nat), (exists p: nat, l= l1++(n,p)::l2))). Theorem mult_lt_reg_l : forall m n p, m * n < m * p -> n < p. 
pos_right n m : pos m -> pos (n+m) := match n with | 0 => fun x => x | S n => fun p => pos_nxt (pos_right n p) end.Definition pos_both n m : pos (n+m) -> pos n + pos m. Proof. induction n as [ | n IHn ]; intros p. + right; exact p. + simpl in p; pos_inv p. * left; apply pos_fst. * destruct (IHn p) as [ a | b ]. - left; apply (pos_nxt a). - right; apply b. Defined.Definition pos_lr n m : pos n + pos m -> pos (n+m). Proof. intros [ p | p ]; revert p. + apply pos_left. + apply pos_right. Defined.Fact pos_both_left n m p : @pos_both n m (@pos_left n m p) = inl p. Proof. induction p as [ | n p IHp ]; simpl; auto. rewrite IHp; auto. Qed.Fact pos_both_right n m p : @pos_both n m (@pos_right n m p) = inr p. Proof. revert p; induction n as [ | n IHn]; intros p; simpl; auto. rewrite IHn; auto. Qed.Fact pos_left_right_neq n m p q : @pos_left n m p <> @pos_right n m q. Proof. intros H. apply f_equal with (f := @pos_both _ _) in H. now rewrite pos_both_left, pos_both_right in H. Qed.Fact pos_left_inj n m p q : @pos_left n m p = @pos_left n m q -> p = q. Proof. intros H. apply f_equal with (f := @pos_both _ _) in H. rewrite !pos_both_left in H. now inversion H. Qed.Fact pos_right_inj n m p q : @pos_right n m p = @pos_right n m q -> p = q. Proof. intros H. apply f_equal with (f := @pos_both _ _) in H. rewrite !pos_both_right in H. now inversion H. Qed.Fact pos_both_lr n m p : @pos_both n m (pos_lr p) = p. Proof. destruct p as [ p | p ]. + apply pos_both_left. + apply pos_both_right. Qed.Fact pos_lr_both n m p : pos_lr (@pos_both n m p) = p. Proof. revert p; induction n as [ | n IHn ]; intros p; auto. simpl in p; pos_inv p; simpl; auto. specialize (IHn p). destruct (pos_both n m p); simpl in *; f_equal; auto. Qed.Section pos_left_right_rect. Variable (n m : nat) (P : pos (n+m) -> Type). Hypothesis (HP1 : forall p, P (pos_left _ p)) (HP2 : forall p, P (pos_right _ p)). Theorem pos_left_right_rect : forall p, P p. 
sync_xform (synpred cm a vs) =p=> cachepred cm a vs. Proof. unfold cachepred, synpred; intros. rewrite sync_xform_exists_comm. apply pimpl_exists_l; intro vs0. rewrite sync_xform_sep_star_dist. destruct vs0 as [v0 l0]. destruct (Map.find a cm) eqn:?; try destruct p, b; rewrite sync_xform_lift_empty, sync_xform_ptsto_subset_precise; unfold ptsto_subset; cancel; apply incl_nil. Qed. Lemma sync_xform_listpred_synpred_cachepred : forall l cm, sync_xform (listpred (fun x => synpred cm (fst x) (snd x)) l) =p=> listpred (fun x => cachepred cm (fst x) (snd x)) l. Proof. intros; rewrite sync_xform_listpred'; eauto. intros; eapply synpred_cachepred_sync. Qed. Lemma rep_synrep_split : forall cs d F, rep cs d /\ (exists d', synrep' cs d' * [[ F d' ]]) =p=> (exists d', (rep cs d ‚ãÄ synrep' cs d') * [[ F d' ]]). Proof. intros. rewrite pimpl_and_r_exists. unfold pimpl; intros. destruct H. destruct H. destruct_lift H0. exists x. eapply sep_star_lift_apply'; eauto. split; eauto. Qed. Lemma synrep_rep : forall cs d0 d, synrep cs d0 d =p=> rep cs d0. Proof. unfold synrep; intros. apply pimpl_l_and; eauto. Qed. Lemma nil_if_clean_synced : forall l a cm vs, Forall (nil_if_clean cm) l -> addr_clean cm a -> avs2mem addr_eq_dec l a = Some vs -> NoDup (map fst l) -> snd vs = nil. Proof. induction l; simpl; intros. cbv in H1; congruence. inversion H; inversion H2; subst. destruct a; cbn in H1; simpl in *. destruct (addr_eq_dec n a0); subst. rewrite upd_eq in H1 by auto; inversion H1; subst; eauto. rewrite upd_ne in H1 by auto. eapply IHl; eauto; simpl in *. Qed. Lemma rep_synrep : forall (F : rawpred) d0 cs, F d0 -> sync_invariant F -> rep cs d0 =p=> exists d, synrep cs d0 d * [[ F d /\ forall a vs, addr_clean (CSMap cs) a -> d a = Some vs -> snd vs = nil ]]. Proof. unfold synrep; intros. rewrite <- rep_synrep_split. apply pimpl_and_split; auto. unfold rep, synrep', mem_pred, mem_pred_one. norml; unfold stars; simpl. rewrite listpred_cachepred_synpred. cancel. eapply addr_valid_mem_match; eauto. apply avs2mem_mem_match. erewrite avs_match_map_fst_eq; eauto. erewrite avs_match_map_fst_eq; eauto. eapply avs_match_sync_invariant; eauto. eapply nil_if_clean_synced; eauto. erewrite avs_match_map_fst_eq; eauto. Qed. Theorem begin_sync_ok : forall cs, {< d F, PRE:hm rep cs d * [[ F d /\ sync_invariant F ]] POST:hm' RET:cs exists d', synrep cs d d' * [[ F d' ]] CRASH:hm' exists cs', rep cs' d >} begin_sync cs. Proof. unfold begin_sync, synrep. step. prestep. norml; unfold stars; simpl. rewrite rep_synrep by eauto. cancel; eauto. Qed. Theorem end_sync_ok : forall cs, {< d0 d, PRE:hm synrep cs d0 d POST:hm' RET:cs rep cs d CRASH:hm' exists cs', rep cs' d0 >} end_sync cs. 
in *. unfold collidesWith in *. simpl in *. case_eq (eqb b3 b1); intuition. rewrite H1 in H0. simpl in *. case_eq (eqb a0 a); intuition. rewrite H2 in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H2. subst. unfold eqbPair in *. simpl in *. repeat rewrite eqb_refl in H. simpl in *. trivial. rewrite H2 in H0. simpl in *. discriminate. rewrite H1 in H0. simpl in *. unfold eqbPair in *. simpl in *. rewrite H1 in H. case_eq (eqb a0 a); intuition. rewrite H2 in H. simpl in *. eapply IHx1; eauto. rewrite H2 in H. simpl in *. eapply IHx1; eauto. Qed. Theorem in_impl_collidesWith : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B), In (a, b) ls -> a <> a' -> collidesWith _ _ ls a' b = true. unfold collidesWith in *. induction ls; intuition; simpl in *. intuition. pairInv. case_eq (eqb a' a); intuition. rewrite eqb_leibniz in H. subst. intuition. rewrite eqb_refl. simpl in *. trivial. case_eq (eqb b1 b0); intuition. case_eq (eqb a' a0); intuition. simpl. eapply IHls; intuition. eauto. subst; intuition. simpl. eapply IHls; eauto. Qed. Theorem funcCollision_false_impl_collidesWith_false : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B), funcCollision _ _ ls = false -> In (a, b) ls -> collidesWith _ _ ls a b = false. induction ls; intuition; simpl in *. intuition. pairInv. unfold collidesWith, funcCollision in *. simpl in *. repeat rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b1); intuition. rewrite H0 in H. discriminate. unfold collidesWith, funcCollision in *. simpl in *. case_eq (eqb a0 a); intuition. rewrite eqb_leibniz in H0. subst. rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b0); intuition; rewrite H0 in H. discriminate. case_eq (eqb b1 b0); intuition. simpl. eapply IHls; intuition. simpl. eapply IHls; intuition. assert (a <> a0). intuition. subst. rewrite eqb_refl in H0. discriminate. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H3. subst. intuition. simpl. case_eq (eqb b1 b0); intuition. simpl. rewrite eqb_leibniz in H4. subst. specialize (in_impl_collidesWith _ _ ls _ H1 H2); intuition. unfold collidesWith in H4. destruct (findCollision_1 eqda eqdb ls a0 b0); discriminate. simpl. case_eq (findCollision_1 eqda eqdb ls a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). 
-> In a ls2) -> sumList ls1 f <= sumList ls2 f. induction ls1; intuition; simpl in *. unfold sumList; simpl. eapply rat0_le_all. inversion H; clear H; subst. rewrite sumList_cons. eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. symmetry. eapply (@sumList_permutation _ _ _ (a :: removeFirst (EqDec_dec _) ls2 a)%list). eapply removeFirst_permutation. eapply H1. intuition. } eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. symmetry. eapply sumList_cons. } eapply ratAdd_leRat_compat; intuition. eapply IHls1; intuition. eapply removeFirst_NoDup. trivial. destruct (EqDec_dec _ a a0). subst. intuition. eapply removeFirst_in. eapply H1; intuition. intuition. Qed.Fixpoint allNatsLt (n : nat) := match n with | 0 => nil | S n' => allNatsLt n' ++ (n' :: nil) end. Lemma allNatsLt_length : forall n, length (allNatsLt n) = n. induction n; intuition; simpl in *. rewrite app_length. rewrite IHn. rewrite plus_comm. trivial. Qed. Lemma allNatsLt_lt : forall n v, In v (allNatsLt n) -> v < n. induction n; intuition; simpl in *. intuition. apply in_app_or in H. simpl in *. intuition. Qed. Lemma app_NoDup : forall(A : Set)(ls1 ls2 : list A), NoDup ls1 -> NoDup ls2 -> (forall a, In a ls1 -> ~In a ls2) -> (forall a, In a ls2 -> ~In a ls1) -> NoDup (ls1 ++ ls2). induction ls1; intuition. inversion H; clear H; subst. rewrite <- app_comm_cons. econstructor. intuition. eapply in_app_or in H. intuition. eapply H1. simpl. left. eauto. trivial. eapply IHls1; eauto. intuition. eapply H1. simpl. right. eauto. eauto. intuition. eapply H1. simpl. right. eauto. eauto. Qed.Lemma allNatsLt_NoDup : forall (n : nat), NoDup (allNatsLt n). induction n; simpl in *; intuition. econstructor. eapply app_NoDup; intuition. econstructor. simpl; intuition. econstructor. simpl in *. intuition; subst. eapply allNatsLt_lt in H. omega. simpl in *. intuition; subst. eapply allNatsLt_lt in H0. omega. Qed. Lemma allNatsLt_lt_if : forall (n i : nat), i < n -> In i (allNatsLt n). induction n; intuition; simpl in *. omega. eapply in_or_app. destruct (lt_dec i n). left. eauto. right. simpl. intuition. Qed.Lemma nth_allNatsLt_lt : forall k n, n < k -> nth n (allNatsLt k) n = n. induction k; intuition; simpl in *. destruct (lt_dec n k). rewrite app_nth1. eauto. rewrite allNatsLt_length. trivial. rewrite app_nth2. rewrite allNatsLt_length. assert (k = n). omega. rewrite H0. rewrite minus_diag. simpl. trivial. rewrite allNatsLt_length. omega.Qed.Lemma nth_allNatsLt : forall k n, nth n (allNatsLt k) n = n. intuition. destruct (lt_dec n k). eapply nth_allNatsLt_lt; intuition. eapply nth_overflow. rewrite allNatsLt_length. omega. Qed. Theorem allNatsLt_filter_lt : forall (p n : nat), (n <= p)%nat-> filter (fun z => if (lt_dec z n) then true else false) (allNatsLt p) = allNatsLt n. 
(typeof e1) && numeric_type t2)%bool = true /\ access_mode (typeof e1) = By_value ch /\ access_mode t2 = By_value ch' /\ decode_encode_val_ok ch ch' /\ writable_share sh) && |> ( (tc_lvalue Delta e1) && (tc_expr Delta (Ecast e2 (typeof e1))) && ((`(mapsto_ sh (typeof e1)) (eval_lvalue e1) && `(mapsto_ sh t2) (eval_lvalue e1)) * (ALL v': val, `(mapsto sh t2) (eval_lvalue e1) (`v') -* imp (local ((`decode_encode_val ) ((` force_val) ((`(sem_cast (typeof e2) (typeof e1))) (eval_expr e2))) (`ch) (`ch') (`v') )) (P))))) (Sassign e1 e2) (normal_ret_assert P). Proof. intros. eapply semax_pre_simple; [| apply semax_store_store_union_hack_backward]. apply orp_right2; auto. Qed.End Sassign2StoreUnionHack.Module Type CLIGHT_SEPARATION_HOARE_LOGIC_CALL_FORWARD.Declare Module CSHL_Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF.Import CSHL_Def.Axiom semax_call_forward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall A P Q NEP NEQ ts x (F: environ -> mpred) ret argsig retsig cc a bl, Cop.classify_fun (typeof a) = Cop.fun_case_f (typelist_of_type_list argsig) retsig cc -> (retsig = Ctypes.Tvoid -> ret = None) -> tc_fn_return Delta ret retsig -> @semax CS Espec Delta ((((tc_expr Delta a) && (tc_exprlist Delta argsig bl))) && (`(func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) && (|> (F * (fun rho => P ts x (ge_of rho, eval_exprlist argsig bl rho)))))) (Scall ret a bl) (normal_ret_assert (EX old:val, substopt ret (`old) F * maybe_retval (Q ts x) retsig ret)).End CLIGHT_SEPARATION_HOARE_LOGIC_CALL_FORWARD.Module Type CLIGHT_SEPARATION_HOARE_LOGIC_CALL_BACKWARD.Declare Module CSHL_Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF.Import CSHL_Def.Axiom semax_call_backward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall ret a bl R, @semax CS Espec Delta (EX argsig: _, EX retsig: _, EX cc: _, EX A: _, EX P: _, EX Q: _, EX NEP: _, EX NEQ: _, EX ts: _, EX x: _, !! (Cop.classify_fun (typeof a) = Cop.fun_case_f (typelist_of_type_list argsig) retsig cc /\ (retsig = Ctypes.Tvoid -> ret = None) /\ tc_fn_return Delta ret retsig) && (((tc_expr Delta a) && (tc_exprlist Delta argsig bl))) && `(func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) && |>((fun rho => (P ts x (ge_of rho, eval_exprlist argsig bl rho))) * oboxopt Delta ret (maybe_retval (Q ts x) retsig ret -* R))) (Scall ret a bl) (normal_ret_assert R).End CLIGHT_SEPARATION_HOARE_LOGIC_CALL_BACKWARD.Module CallF2B (Def: CLIGHT_SEPARATION_HOARE_LOGIC_DEF) (Conseq: CLIGHT_SEPARATION_HOARE_LOGIC_CONSEQUENCE with Module CSHL_Def := Def) (Extr: CLIGHT_SEPARATION_HOARE_LOGIC_EXTRACTION with Module CSHL_Def := Def) (CallF: CLIGHT_SEPARATION_HOARE_LOGIC_CALL_FORWARD with Module CSHL_Def := Def): CLIGHT_SEPARATION_HOARE_LOGIC_CALL_BACKWARD with Module CSHL_Def := Def.Module CSHL_Def := Def. Module ConseqFacts := GenConseqFacts (Def) (Conseq). Module ExtrFacts := GenExtrFacts (Def) (Conseq) (Extr). Import Def. Import Conseq. Import ConseqFacts. Import Extr. Import ExtrFacts. Import CallF. Theorem semax_call_backward: forall {CS: compspecs} {Espec: OracleKind} (Delta: tycontext), forall ret a bl R, @semax CS Espec Delta (EX argsig: _, EX retsig: _, EX cc: _, EX A: _, EX P: _, EX Q: _, EX NEP: _, EX NEQ: _, EX ts: _, EX x: _, !! (Cop.classify_fun (typeof a) = Cop.fun_case_f (typelist_of_type_list argsig) retsig cc /\ (retsig = Ctypes.Tvoid -> ret = None) /\ tc_fn_return Delta ret retsig) && (((tc_expr Delta a) && (tc_exprlist Delta argsig bl))) && `(func_ptr (mk_funspec (argsig,retsig) cc A P Q NEP NEQ)) (eval_expr a) && |>((fun rho => P ts x (ge_of rho, eval_exprlist argsig bl rho)) * oboxopt Delta ret (maybe_retval (Q ts x) retsig ret -* R))) (Scall ret a bl) (normal_ret_assert R). 
Require Import Kami.Kami.Set Implicit Arguments. Set Asymmetric Patterns. Definition producer := MODULE { Register "data" : Bit 32 <- Default with Rule "produce" := Read data <- "data"; Call (MethodSig "send" (Bit 32 ): Void ) (#data) ; Write "data" <- #data + $1 ; Retv }. #[global] Hint Unfold producer : ModuleDefs. Definition consumer := MODULE { Method "send" (data: Bit 32): Void := Call (MethodSig "extCall" (Bit 32): Void) (#data); Retv }. #[global] Hint Unfold consumer : ModuleDefs. Definition producerConsumerImpl := (producer ++ consumer)%kami. #[global] Hint Unfold producerConsumerImpl : ModuleDefs. Definition producerConsumerSpec := MODULE { Register "data" : Bit 32 <- Default with Rule "produce_consume" := Read data <- "data"; Call (MethodSig "extCall" (Bit 32): Void) (#data); Write "data" <- #data + $1; Retv }. Definition producer_consumer_ruleMap (_: RegsT): string -> option string := "produce" |-> "produce_consume"; ||. Definition producer_consumer_regMap (r: RegsT): RegsT. kgetv "data"%string datav r (Bit 32) (M.empty _: RegsT). exact (M.add "data"%string (existT _ _ datav) (M.empty _)). Defined. #[global] Hint Unfold producer_consumer_regMap: MethDefs. Lemma impl_ModEquiv: ModPhoasWf producerConsumerImpl. Proof. kequiv. Qed. #[global] Hint Resolve impl_ModEquiv. Theorem producer_consumer_refinement: producerConsumerImpl <<== producerConsumerSpec. Proof. kinline_left implInlined. kdecompose_nodefs producer_consumer_regMap producer_consumer_ruleMap. kinvert. kinv_magic_light. Qed. Definition producer_consumer_refinement_config := {| inlining := ITManual; decomposition := DTFunctional producer_consumer_regMap producer_consumer_ruleMap; invariants := IVNil |}. Theorem producer_consumer_refinement_again: producerConsumerImpl <<== producerConsumerSpec. 
init). induction init; simpl; intuition. Qed.Theorem NoDup_allWords : forall width, NoDup (allWords width). rewrite allWords_eq; intros; apply NoDup_allWordsUpto; omega. Qed.Module BedrockHeap. Definition addr := W. Definition mem := mem. Definition mem_get := ReadByte. Definition mem_set := WriteByte. Definition mem_acc (m : mem) (a : addr) := exists v, m a = Some v. Theorem mem_get_acc : forall m p, mem_acc m p <-> exists v, mem_get m p = Some v. Proof. intuition eauto. Qed. Theorem mem_set_acc : forall m p, mem_acc m p <-> forall v, exists m', mem_set m p v = Some m'. Proof. intuition. destruct H. unfold mem_set, WriteByte. rewrite H. eauto. specialize (H (wzero _)). destruct H. unfold mem_set, mem_acc, WriteByte in *. destruct (m p); eauto. congruence. Qed. Theorem mem_acc_dec : forall m p, mem_acc m p \/ ~mem_acc m p. Proof. unfold mem_acc. intros; destruct (m p); eauto. right. intro. destruct H; congruence. Qed. Theorem mem_get_set_eq : forall m p v' m', mem_set m p v' = Some m' -> mem_get m' p = Some v'. Proof. unfold mem_set, mem_get, ReadByte, WriteByte. intros. destruct (m p); try congruence. inversion H; clear H; subst. destruct (weq p p); auto. congruence. Qed. Theorem mem_get_set_neq : forall m p p' v' m', p <> p' -> mem_set m p' v' = Some m' -> mem_get m' p = mem_get m p. Proof. unfold mem_set, mem_get, ReadByte, WriteByte; intros. destruct (m p'); try congruence. inversion H0; clear H0; subst. destruct (weq p p'); auto. congruence. Qed. Theorem mem_set_perm : forall m p v m', mem_set m p v = Some m' -> (forall p, mem_acc m p -> mem_acc m' p). Proof. unfold mem_set, mem_acc, ReadByte, WriteByte; intros. generalize dependent H. case_eq (weq p p0); intros; subst. destruct (m p0); try congruence. inversion H1; subst; auto. rewrite H. eauto. destruct (m p); try congruence. inversion H1; subst. destruct (weq p0 p); eauto. Qed. Definition footprint_w (p : addr) : addr * addr * addr * addr := (p , p ^+ $1 , p ^+ $2 , p ^+ $3). Theorem footprint_disjoint : forall p a b c d, footprint_w p = (a,b,c,d) -> a <> b /\ a <> c /\ a <> d /\ b <> c /\ b <> d /\ c <> d. Proof. unfold footprint_w. inversion 1. clear. repeat split; W_neq. Qed. Definition addr_dec := @weq 32. Definition all_addr := allWords 32. Theorem NoDup_all_addr : NoDup all_addr. 
(string_dec a name); subst; auto. unfold ptsto in H3; intuition. pose proof (H7 _ n); congruence. unfold mem_disjoint in H1; repeat deex. firstorder. eapply notindomain_mem_union; eauto. Qed. Lemma dirlist_pred_add_notin: forall xp ents name subtree, ~ In name (map fst ents) -> NoDup (map fst ents) -> dirlist_pred (tree_pred xp) (add_to_list name subtree ents) =p=> tree_pred xp subtree * dirlist_pred (tree_pred xp) ents. Proof. induction ents; intros; simpl; auto. destruct a. destruct (string_dec s name); subst; simpl. cancel. cancel. inversion H0. apply IHents; auto. Qed. Lemma dirlist_pred_add_delete : forall xp ents name subtree, NoDup (map fst ents) -> dirlist_pred (tree_pred xp) (add_to_list name subtree (delete_from_list name ents)) =p=> dirlist_pred (tree_pred xp) (add_to_list name subtree ents). Proof. induction ents; simpl; intros; auto. destruct a. destruct (string_dec s name); subst; simpl. inversion H; subst. apply dirlist_pred_add_notin; auto. destruct (string_dec s name); subst; simpl. congruence. cancel; apply IHents. inversion H; auto. Qed. Theorem tree_dir_names_pred_update' : forall fnlist subtree subtree' d, find_subtree fnlist d = Some subtree -> dirtree_inum subtree = dirtree_inum subtree' -> dirtree_isdir subtree = dirtree_isdir subtree' -> (dirtree_inum d, dirtree_isdir d) = (dirtree_inum (update_subtree fnlist subtree' d), dirtree_isdir (update_subtree fnlist subtree' d)). Proof. destruct fnlist; simpl; intros. congruence. destruct d; auto. Qed. Lemma tree_dir_names_pred'_distinct : forall l, tree_dir_names_pred' l =p=> tree_dir_names_pred' l * [[ NoDup (map fst l) ]]. Proof. unfold pimpl; intros. assert ((emp * tree_dir_names_pred' l)%pred m) by (pred_apply; cancel). apply dir_names_distinct' in H0 as Hnodup. clear H0. pred_apply; cancel. Qed. Theorem tree_dir_names_pred_notfound : forall l fnlist subtree' name, ~ In name (map fst l) -> tree_dir_names_pred' l <=p=> tree_dir_names_pred' (map (update_subtree_helper (update_subtree fnlist subtree') name) l). Proof. induction l; simpl; intros. auto. destruct a; simpl. destruct (string_dec s name); subst; try intuition. split; cancel; apply IHl; eauto. Qed. Theorem tree_dir_names_pred'_update : forall l fnlist subtree subtree' name, fold_right (find_subtree_helper (find_subtree fnlist) name) None l = Some subtree -> dirtree_inum subtree = dirtree_inum subtree' -> dirtree_isdir subtree = dirtree_isdir subtree' -> tree_dir_names_pred' l =p=> tree_dir_names_pred' (map (update_subtree_helper (update_subtree fnlist subtree') name) l). Proof. intros; rewrite tree_dir_names_pred'_distinct; cancel. induction l; simpl; intros. cancel. destruct a. case_eq (update_subtree_helper (update_subtree fnlist subtree') name (s, d)); intros. unfold update_subtree_helper in H2. simpl in *. destruct (string_dec s name); subst. - inversion H2; clear H2; subst; simpl in *. erewrite <- tree_dir_names_pred_update'; eauto. cancel. apply tree_dir_names_pred_notfound. inversion H4; eauto. - inversion H2; clear H2; subst; simpl in *. cancel. apply H2. inversion H4; eauto. Qed. Theorem tree_dir_names_pred'_update_inv : forall l fnlist subtree subtree' name, fold_right (find_subtree_helper (find_subtree fnlist) name) None l = Some subtree -> dirtree_inum subtree = dirtree_inum subtree' -> dirtree_isdir subtree = dirtree_isdir subtree' -> tree_dir_names_pred' (map (update_subtree_helper (update_subtree fnlist subtree') name) l) =p=> tree_dir_names_pred' l. 
Require Import Prog. Require Import Word AsyncDisk. Require Import Mem Pred PredCrash.Require Import FunctionalExtensionality. Require Import List. Require Import Arith.PeanoNat. Require Import RelationClasses. Require Import ListUtils.Set Implicit Arguments.Arguments possible_sync {AT AEQ} _ _. Hint Resolve possible_sync_refl. Hint Resolve possible_sync_trans.Ltac inv_opt := repeat match goal with | [ H: Some _ = Some _ |- _ ] => inversion H; subst; clear H | [ H: Some _ = None |- _ ] => solve [ inversion H ] | [ H: None = Some _ |- _ ] => solve [ inversion H ] end.Ltac sigT_eq := match goal with | [ H: @eq (sigT _) _ _ |- _ ] => apply ProofIrrelevance.ProofIrrelevanceTheory.EqdepTheory.inj_pair2 in H; subst end.Section StepPreSync. Arguments possible_sync {AT AEQ} _ _. Hint Constructors step. Hint Resolve ListUtils.incl_cons2. Lemma possible_sync_respects_upd : forall A AEQ (m m': @mem A AEQ _) a v l l', possible_sync m m' -> incl l' l -> possible_sync (upd m a (v, l)) (upd m' a (v,l')). Proof. unfold possible_sync; intros. destruct (AEQ a a0); subst; autorewrite with upd; intuition eauto. specialize (H a0); intuition auto. right; repeat eexists; eauto. repeat deex. right; repeat eexists; eauto. Qed. Hint Resolve incl_refl. Lemma possible_sync_respects_sync_mem : forall A AEQ (m m': @mem A AEQ _), possible_sync m m' -> possible_sync (sync_mem m) (sync_mem m'). Proof. unfold possible_sync, sync_mem; intros. specialize (H a). destruct (m a) as [ [] | ]; destruct (m' a) as [ [] | ]; subst; intuition eauto; try congruence; repeat deex; inv_opt; right. do 3 eexists; intuition eauto. Qed. Hint Resolve possible_sync_respects_upd. Hint Resolve possible_sync_respects_sync_mem. Theorem step_presync : forall T (m m' m'' m''': rawdisk) vm hm (p: prog T) vm' hm' v, possible_sync (AEQ:=Nat.eq_dec) m m' -> step m' vm hm p m'' vm' hm' v -> possible_sync (AEQ:=Nat.eq_dec) m'' m''' -> exists (m'2: rawdisk), step m vm hm p m'2 vm' hm' v /\ possible_sync (AEQ:=Nat.eq_dec) m'2 m'''. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. 
: Œì ‚ä¢v ListNilV : listT t | val_cons_hasTy vhd vtl t : Œì ‚ä¢v vhd : t -> Œì ‚ä¢v vtl : listT t -> Œì ‚ä¢v ListConsV vhd vtl : listT t | val_injL_hasTy v1 t1 t2 : Œì ‚ä¢v v1 : t1 -> Œì ‚ä¢v InjLV v1 : sumT t1 t2 | val_injR_hasTy v2 t1 t2 : Œì ‚ä¢v v2 : t2 -> Œì ‚ä¢v InjRV v2 : sumT t1 t2 | rec_val_hasTy f x e t1 t2 : (<[f := arrowT t1 t2]> $ <[x := t1]> $ ‚à ) ‚ä¢ e : t2 -> Œì ‚ä¢v RecV f x e : arrowT t1 t2 | mapNilV_hasTy v t : Œì ‚ä¢v v : t -> Œì ‚ä¢v MapNilV v : mapValT t where "Œì ‚ä¢v v : A" := (val_hasTy Œì v A) . Hint Constructors expr_hasTy val_hasTy base_lit_hasTy : core. Theorem zero_val_ty t Œì : has_zero t -> Œì ‚ä¢v zero_val t : t. Proof. revert Œì. induction t; simpl; eauto; intros; intuition eauto. destruct t; eauto. Qed. Lemma extend_context_add: ‚àÄ Œì Œì' : Ctx, (‚àÄ (x : string) (t0 : ty), Œì !! x = Some t0 ‚Üí Œì' !! x = Some t0) ‚Üí ‚àÄ (x : binder) (t: ty) (x0 : string) (t0 : ty), (<[x:=t]> Œì) !! x0 = Some t0 ‚Üí (<[x:=t]> Œì') !! x0 = Some t0. Proof. intros Œì Œì' Heq f t x t0 HŒì. unfold insert, ctx_insert in *. destruct f; eauto. destruct (s =? x)%string eqn:Heq_s. - apply String.eqb_eq in Heq_s. subst. move: HŒì. rewrite ?lookup_insert //=. - apply String.eqb_neq in Heq_s. move: HŒì. rewrite ?lookup_insert_ne //=; eauto. Qed. Hint Resolve extend_context_add : core. Theorem context_extension Œì (t: ty) e : Œì ‚ä¢ e : t -> forall Œì', (forall x t0, Œì !! x = Some t0 -> Œì' !! x = Some t0) -> Œì' ‚ä¢ e : t with val_context_extension Œì (t: ty) v : Œì ‚ä¢v v : t -> forall Œì', (forall x t0, Œì !! x = Some t0 -> Œì' !! x = Some t0) -> Œì' ‚ä¢v v : t. Proof. - inversion 1; subst; solve [ econstructor; eauto ]. - inversion 1; subst; solve [ econstructor; eauto ]. Qed. Theorem empty_context_to_any e t : ‚à ‚ä¢ e : t -> forall Œì, Œì ‚ä¢ e : t. Proof. intros. eapply context_extension; eauto. inversion 1. Qed. Theorem empty_context_to_any_val v t : ‚à ‚ä¢v v : t -> forall Œì, Œì ‚ä¢v v : t. 
cancel. or_l; cancel. cancel. Qed. Definition read xp cs := Eval compute_rec in let^ (cs, v) <- BUFCACHE.read (LAHdr xp) cs; let header := (val2hdr v) in Ret ^(cs, ((# (header :-> "previous_ndesc"), # (header :-> "previous_ndata")), (# (header :-> "ndesc"), # (header :-> "ndata")), (header :-> "addr_checksum", header :-> "valu_checksum"))). Definition write xp n cs := cs <- BUFCACHE.write (LAHdr xp) (hdr2val (mk_header n)) cs; Ret cs. Definition sync xp cs := cs <- BUFCACHE.sync (LAHdr xp) cs; Ret cs. Definition sync_now xp cs := cs <- BUFCACHE.begin_sync cs; cs <- BUFCACHE.sync (LAHdr xp) cs; cs <- BUFCACHE.end_sync cs; Ret cs. Definition init xp cs := h <- Hash default_valu; cs <- BUFCACHE.write (LAHdr xp) (hdr2val (mk_header ((0, 0), (0, 0), (h, h)))) cs; cs <- BUFCACHE.begin_sync cs; cs <- BUFCACHE.sync (LAHdr xp) cs; cs <- BUFCACHE.end_sync cs; Ret cs. Local Hint Unfold rep state_goodSize : hoare_unfold. Theorem write_ok : forall xp n cs, {< F d old, PRE:hm BUFCACHE.rep cs d * [[ hdr_goodSize n ]] * [[ previous_length n = current_length old \/ previous_length old = current_length n ]] * [[ (F * rep xp (Synced old))%pred d ]] POST:hm' RET: cs exists d', BUFCACHE.rep cs d' * [[ (F * rep xp (Unsync n old))%pred d' ]] XCRASH:hm' exists cs' d', BUFCACHE.rep cs' d' * [[ (F * rep xp (Unsync n old))%pred d' ]] >} write xp n cs. Proof. unfold write. step. step. xcrash. step. xcrash. Qed. Theorem read_ok : forall xp cs, {< F d n, PRE:hm BUFCACHE.rep cs d * [[ (F * rep xp (Synced n))%pred d ]] POST:hm' RET: ^(cs, r) BUFCACHE.rep cs d * [[ (F * rep xp (Synced n))%pred d ]] * [[ r = n ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d >} read xp cs. Proof. unfold read. hoare. subst; rewrite val2hdr2val; simpl. unfold hdr_goodSize in *; intuition. repeat rewrite wordToNat_natToWord_idempotent'; auto. destruct n; auto. destruct p as (p1 , p2); destruct p1, p2, p0; auto. Qed. Theorem sync_ok : forall xp cs, {< F d0 d n old, PRE:hm BUFCACHE.synrep cs d0 d * [[ (F * rep xp (Unsync n old))%pred d ]] * [[ sync_invariant F ]] POST:hm' RET: cs exists d', BUFCACHE.synrep cs d0 d' * [[ (F * rep xp (Synced n))%pred d' ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d0 >} sync xp cs. Proof. unfold sync. step. step. Qed. Theorem sync_now_ok : forall xp cs, {< F d n old, PRE:hm BUFCACHE.rep cs d * [[ (F * rep xp (Unsync n old))%pred d ]] * [[ sync_invariant F ]] POST:hm' RET: cs exists d', BUFCACHE.rep cs d' * [[ (F * rep xp (Synced n))%pred d' ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d >} sync_now xp cs. 
* destruct external; apply log_rwdata_consistent_mux_r; try apply IHs2; ceauto. - eauto. Qed. Notation init_scheduler_circuit := (init_scheduler_circuit lco). Lemma log_rwdata_consistent_empty_init_scheduler: log_rwdata_consistent log_empty (init_scheduler_circuit rc). Proof. red; unfold init_scheduler_circuit, init_scheduler_rwdata; intros; rewrite !getenv_create, !log_existsb_empty; cbn; rewrite lco_proof; eauto. Qed. Lemma log_data0_consistent'_empty_init_scheduler: circuit_env_equiv -> log_data0_consistent' log_empty (init_scheduler_circuit rc). Proof. red; unfold init_scheduler_circuit, init_scheduler_rwdata, circuit_env_equiv; intros; rewrite !getenv_create; cbn; rewrite lco_proof, latest_write0_empty; eauto. Qed. Lemma log_data1_consistent'_empty_init_scheduler: log_data1_consistent' log_empty (init_scheduler_circuit rc). Proof. red; intros * H. rewrite log_existsb_empty in H; discriminate. Qed. Hint Resolve log_rwdata_consistent_empty_init_scheduler : circuits. Hint Resolve log_data0_consistent'_empty_init_scheduler : circuits. Hint Resolve log_data1_consistent'_empty_init_scheduler : circuits. Definition log_writes_ordered (l: Log) idx := latest_write l idx = match latest_write1 l idx with | Some v => Some v | None => match latest_write0 l idx with | Some v => Some v | None => None end end. Theorem action_log_writes_ordered: forall sig tau a ctx Log log idx, log_writes_ordered (log_app log Log) idx -> match @interp_action pos_t var_t reg_t ext_fn_t CR CSigma REnv cr csigma sig tau ctx Log log a with | Some (l', _, _) => log_writes_ordered (log_app l' Log) idx | None => True end. Proof. induction a; cbn; intros; eauto; repeat match goal with | _ => progress cbn | [ IH: context[interp_action _ _ _ _ _ ?a] |- context[interp_action ?cr ?csigma ?ctx ?Log ?log ?a] ] => specialize (IH ctx Log log _ ltac:(ceauto)); destruct (interp_action cr csigma ctx Log log a) as [((? & ?) & ?) | ] eqn:? | [ |- match (if ?x then _ else _) with _ => _ end ] => destruct x eqn:? | _ => solve [eauto] end. - destruct port; destruct may_read; cbn; eauto; unfold log_writes_ordered, log_cons in *; unfold latest_write, latest_write0, latest_write1, log_find in *; unfold log_app in *; rewrite !getenv_map2 in *; (destruct (eq_dec idx idx0); subst; [ rewrite !get_put_eq | rewrite !get_put_neq by eassumption ]; [ | ]); cbn; eauto. - destruct port; unfold log_writes_ordered, log_cons in *; unfold latest_write, latest_write0, latest_write1, log_find in *; unfold log_app in *; rewrite !getenv_map2 in *; (destruct (eq_dec idx idx0); subst; [ rewrite !get_put_eq | rewrite !get_put_neq by eassumption ]; [ | ]); cbn; eauto. may_read_write_t. rewrite list_find_opt_app. change (list_find_opt _ (getenv _ ?l ?idx)) with (latest_write1 l idx); rewrite !latest_write1_None; eauto. Qed. Lemma log_writes_ordered_empty idx: log_writes_ordered (log_empty: Log) idx. Proof. unfold log_writes_ordered, log_cons; unfold latest_write, latest_write0, latest_write1, log_find, log_empty; rewrite !getenv_create; reflexivity. Qed. Hint Resolve log_writes_ordered_empty : circuits. Theorem scheduler_log_writes_ordered: forall s log idx, log_writes_ordered log idx -> log_writes_ordered (interp_scheduler' cr csigma rules log s) idx. 
: ActionT ty k := GatherActions xs as ys; Ret (utila_find f ys). Definition utila_acts_find_pkt (k : Kind) (xs : list (ActionT ty (Maybe k))) : ActionT ty (Maybe k) := GatherActions xs as ys; Ret (utila_find_pkt ys). Close Scope kami_action. End defs. Arguments utila_mopt_pkt {ty} {monad} {k}. Arguments utila_mopt_default {ty} {monad} {k}. Arguments utila_mopt_bind {ty} {monad} {j} {k}. Arguments utila_mfoldr {ty} {monad} {j} {k}. Arguments utila_mall {ty} {monad}. Arguments utila_many {ty} {monad}. Arguments utila_mfind {ty} {monad} {k}. Arguments utila_mfind_pkt {ty} {monad} {k}. Section ver. Local Notation "{{ X }}" := (evalExpr X). Local Notation "X ==> Y" := (evalExpr X = Y) (at level 75). Local Notation "==> Y" := (fun x => evalExpr x = Y) (at level 75). Let utila_is_true (x : Bool @# type) := x ==> true. Lemma fold_left_andb_forall' : forall (xs : list (Bool @# type)) a, fold_left andb (map (@evalExpr _) xs) a = true <-> Forall utila_is_true xs /\ a = true. Proof. induction xs; simpl; auto; split; intros; auto. - tauto. - rewrite IHxs in H. rewrite andb_true_iff in H. split; try tauto. constructor; simpl; tauto. - dest. inv H. unfold utila_is_true in *; simpl in *. pose proof (conj H4 H3). rewrite <- IHxs in H. auto. Qed. Theorem fold_left_andb_forall : forall xs : list (Bool @# type), fold_left andb (map (@evalExpr _) xs) true = true <-> Forall utila_is_true xs. Proof. intros. rewrite fold_left_andb_forall'. tauto. Qed. Theorem utila_all_correct : forall xs : list (Bool @# type), utila_all xs ==> true <-> Forall utila_is_true xs. Proof. apply fold_left_andb_forall. Qed. Theorem fold_left_andb_forall_false' : forall (xs : list (Bool @# type)) a, fold_left andb (map (@evalExpr _) xs) a = false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs \/ a = false. Proof. induction xs; simpl; auto; intros; split; try tauto. - intros; auto. destruct H; auto. inv H. - rewrite IHxs. intros. rewrite andb_false_iff in H. destruct H. + left. right; auto. + destruct H. * auto. * left. left. auto. - intros. rewrite IHxs. rewrite andb_false_iff. destruct H. + inv H; auto. + auto. Qed. Theorem fold_left_andb_forall_false : forall xs : list (Bool @# type), fold_left andb (map (@evalExpr _) xs) true = false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. Proof. intros. rewrite fold_left_andb_forall_false'. split; intros. - destruct H; congruence. - auto. Qed. Theorem utila_all_correct_false : forall xs : list (Bool @# type), utila_all xs ==> false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. 
x := if Archi.ptr64 then (Init_int64 (Int64.repr x)) else (Init_int32 (Int.repr x)). Definition make_vint z := if Archi.ptr64 then Vlong (Int64.repr z) else Vint (Int.repr z). Definition make_cint z t := if Archi.ptr64 then Econst_long (Int64.repr z) t else (Econst_int (Int.repr z) t). Transparent val. Transparent uval. Transparent val_typ. Transparent Init_int. Transparent make_vint. Transparent make_cint. *) Definition int_size := (size_chunk int_chunk). Definition max_args := 1024%Z. Theorem int_size_pos: (0 <= size_chunk int_chunk)%Z. Proof. apply Z.lt_le_incl. apply Z.gt_lt. apply size_chunk_pos. Qed. Definition uint_range : Z -> Prop := fun i => (0 <= i <= Ptrofs.max_unsigned)%Z. Transparent uint_range.Theorem uint_range_unsigned: forall i, uint_range (Ptrofs.unsigned i). Proof. apply Ptrofs.unsigned_range_2. Qed. Ltac int_red := unfold int_size in *; simpl size_chunk in *.Ltac chunk_red := unfold int_size in *; unfold int_chunk in *; destruct Archi.ptr64 eqn:Harchi; simpl size_chunk in *.Ltac uomega := (unfold int_size; simpl size_chunk; omega).Definition uint_range_l: list Z -> Prop := fun l => Forall uint_range l. Theorem ptrofs_mu_weak: (Int.max_unsigned <= Ptrofs.max_unsigned)%Z. Proof. unfold Int.max_unsigned. unfold Ptrofs.max_unsigned. destruct (Archi.ptr64) eqn:Harchi. rewrite Ptrofs.modulus_eq64 by auto. unfold Int.modulus. unfold Int64.modulus. simpl. omega. rewrite Ptrofs.modulus_eq32 by auto. reflexivity. Qed.Theorem ptrofs_ms: (Ptrofs.max_signed = if Archi.ptr64 then Int64.max_signed else Int.max_signed )%Z. Proof. unfold Int.max_signed. unfold Ptrofs.max_signed. unfold Ptrofs.half_modulus. destruct (Archi.ptr64) eqn:Harchi. rewrite Ptrofs.modulus_eq64 by auto; reflexivity. rewrite Ptrofs.modulus_eq32 by auto; reflexivity. Qed. Theorem ptrofs_mu: (Ptrofs.max_unsigned = if Archi.ptr64 then Int64.max_unsigned else Int.max_unsigned )%Z. Proof. unfold Int.max_unsigned. unfold Ptrofs.max_unsigned. destruct (Archi.ptr64) eqn:Harchi. rewrite Ptrofs.modulus_eq64 by auto; reflexivity. rewrite Ptrofs.modulus_eq32 by auto; reflexivity. Qed.Ltac uint_range_ptrofs := unfold uint_range_l; unfold uint_range; rewrite ptrofs_mu.Ltac solve_uint_range:= unfold Int64.max_unsigned in *; unfold Int64.modulus in *; unfold Int.max_unsigned in *; unfold Int.modulus in *; simpl in *; (match goal with | [H:uint_range _ |- _] => unfold uint_range in H; rewrite ptrofs_mu in H; solve_uint_range | [H:uint_range_l _ |- _] => unfold uint_range_l in H; solve_uint_range | [H: Forall uint_range _ |- _] => inv H; solve_uint_range | [|- uint_range _] => unfold uint_range; unfold Int.max_unsigned; unfold Int.modulus; simpl; try omega | [|- uint_range (Ptrofs.unsigned _)] => apply uint_range_unsigned | [|- uint_range (Int.unsigned _)] => apply uint_range_unsigned | [|- uint_range_l _] => unfold uint_range_l; solve_uint_range | [ |- Forall uint_range _] => constructor; solve_uint_range | _ => auto end).Theorem int_z_mul : forall i y, uint_range_l [i; y] -> Ptrofs.mul (Ptrofs.repr i) (Ptrofs.repr y) = Ptrofs.repr (i * y)%Z. Proof. intros. unfold Ptrofs.mul. rewrite Ptrofs.unsigned_repr. rewrite Ptrofs.unsigned_repr. reflexivity. inv H. inv H3; auto. inv H; auto. Qed. Theorem int_z_add: forall i y, uint_range_l [i; y] -> Ptrofs.add (Ptrofs.repr i) (Ptrofs.repr y) = Ptrofs.repr (i + y)%Z. 
Require Import VST.floyd.proofauto. Require Import VST.progs64.ptr_cmp.#[export] Instance CompSpecs : compspecs. make_compspecs prog. Defined. Definition Vprog : varspecs. mk_varspecs prog. Defined.Definition t_struct_tree := Tstruct _tree noattr.Inductive Tree : Type := | E | T (k: Z) (lch: Tree) (rch: Tree). Fixpoint tree_rep (t: Tree) (p p_lch p_rch: val): mpred := match t with | T k lch rch => EX p_lch_l: val, EX p_lch_r: val, EX p_rch_l: val, EX p_rch_r: val, data_at Tsh t_struct_tree (Vint (Int.repr k), (p_lch, p_rch)) p * tree_rep lch p_lch p_lch_l p_lch_r * tree_rep rch p_rch p_rch_l p_rch_r | E => !! (p = nullval) && emp end. Definition fa_rep (d: bool) (t: Tree) (p_ch p_fa: val) : mpred := match d with | true => EX p_oppo: val, tree_rep t p_fa p_ch p_oppo | false => EX p_oppo: val, tree_rep t p_fa p_oppo p_ch end. Lemma tree_rep_saturate_local: forall t p p_lch p_rch, tree_rep t p p_lch p_rch |-- !! is_pointer_or_null p. Proof. destruct t; simpl; intros. entailer!. Intros p_lch_l p_lch_r p_rch_l p_rch_r. entailer!. Qed. #[export] Hint Resolve tree_rep_saturate_local: saturate_local.Lemma tree_rep_valid_pointer: forall t p p_lch p_rch, tree_rep t p p_lch p_rch |-- valid_pointer p. Proof. intros. destruct t. - simpl. entailer!. - simpl; normalize; auto with valid_pointer. Qed. #[export] Hint Resolve tree_rep_valid_pointer: valid_pointer.Definition bool2int (d: bool) : Z := match d with | true => 1 | false => 0 end. Definition get_branch_spec := DECLARE _get_branch WITH t: Tree, d: bool, p_fa: val, p: val PRE [ tptr t_struct_tree, tptr t_struct_tree ] PROP (p_fa <> nullval; p <> nullval) PARAMS (p; p_fa) SEP (fa_rep d t p p_fa) POST [ tint ] PROP () RETURN (Vint (Int.repr (bool2int d))) SEP (fa_rep d t p p_fa).Definition Gprog : funspecs := ltac:(with_library prog [get_branch_spec]). Theorem body_get_branch_old_fashion: semax_body Vprog Gprog f_get_branch get_branch_spec. 
z. intros z; unfold Zpower_nat in |- *; simpl in |- *; rewrite Zmult_1_r; auto. Qed. Theorem Zmin_le1 : forall z1 z2 : Z, (z1 <= z2)%Z -> Zmin z1 z2 = z1. intros z1 z2; unfold Zle, Zmin in |- *; case (z1 ?= z2)%Z; auto; intros H; Contradict H; auto. Qed. Theorem Zmin_le2 : forall z1 z2 : Z, (z2 <= z1)%Z -> Zmin z1 z2 = z2. intros z1 z2 H; rewrite Zmin_sym; apply Zmin_le1; auto. Qed. Theorem Zmin_Zle : forall z1 z2 z3 : Z, (z1 <= z2)%Z -> (z1 <= z3)%Z -> (z1 <= Zmin z2 z3)%Z. intros z1 z2 z3 H' H'0; unfold Zmin in |- *. case (z2 ?= z3)%Z; auto. Qed. Theorem Zminus_n_predm : forall n m : Z, Zsucc (n - m) = (n - Zpred m)%Z. intros n m. unfold Zpred in |- *; unfold Zsucc in |- *; ring. Qed. Theorem Zopp_Zpred_Zs : forall z : Z, (- Zpred z)%Z = Zsucc (- z). intros z; unfold Zpred, Zsucc in |- *; ring. Qed. Theorem Zle_mult_gen : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z. intros x y H' H'0; case (Zle_lt_or_eq _ _ H'). intros H'1; rewrite Zmult_comm; apply Zmult_gt_0_le_0_compat; auto; apply Zlt_gt; auto. intros H'1; rewrite <- H'1; simpl in |- *; auto with zarith. Qed. Hint Resolve Zle_mult_gen: zarith. Definition Zmax : forall x_ x_ : Z, Z := fun n m : Z => match (n ?= m)%Z with | Datatypes.Eq => m | Datatypes.Lt => m | Datatypes.Gt => n end. Theorem ZmaxLe1 : forall z1 z2 : Z, (z1 <= Zmax z1 z2)%Z. intros z1 z2; unfold Zmax in |- *; CaseEq (z1 ?= z2)%Z; simpl in |- *; auto with zarith. unfold Zle in |- *; intros H; rewrite H; red in |- *; intros; discriminate. Qed. Theorem ZmaxSym : forall z1 z2 : Z, Zmax z1 z2 = Zmax z2 z1. intros z1 z2; unfold Zmax in |- *; CaseEq (z1 ?= z2)%Z; CaseEq (z2 ?= z1)%Z; intros H1 H2; try case (Zcompare_EGAL _ _ H1); auto; try case (Zcompare_EGAL _ _ H2); auto; Contradict H1. case (Zcompare.Zcompare_Gt_Lt_antisym z2 z1); auto. intros H' H'0; rewrite H'0; auto; red in |- *; intros; discriminate. case (Zcompare.Zcompare_Gt_Lt_antisym z1 z2); auto. intros H'; rewrite H'; auto; intros; red in |- *; intros; discriminate. Qed. Theorem Zmax_le2 : forall z1 z2 : Z, (z1 <= z2)%Z -> Zmax z1 z2 = z2. 
Require Import Fcore_Raux. Require Import Fcore_defs.Section Float_prop.Variable beta : radix.Notation bpow e := (bpow beta e).Theorem Rcompare_F2R : forall e m1 m2 : Z, Rcompare (F2R (Float beta m1 e)) (F2R (Float beta m2 e)) = Zcompare m1 m2. Proof. intros e m1 m2. unfold F2R. simpl. rewrite Rcompare_mult_r. apply Rcompare_Z2R. apply bpow_gt_0. Qed. Theorem F2R_le_reg : forall e m1 m2 : Z, (F2R (Float beta m1 e) <= F2R (Float beta m2 e))%R -> (m1 <= m2)%Z. 
eapply evalDet_steps_done_func; eauto. exfalso. eapply evalDet_steps_done_eof_func; eauto. inversion H0; clear H0; subst. exfalso. eapply evalDet_steps_done_eof_func; eauto. trivial. Qed.Definition evalDet_equiv(A : Set)(c1 c2 : Comp A) := (forall s y, evalDet c1 s y <-> evalDet c2 s y).Lemma evalDet_equiv_symm : forall (A : Set)(c1 c2 : Comp A), evalDet_equiv c1 c2 -> evalDet_equiv c2 c1. unfold evalDet_equiv. intuition. eapply H; trivial. eapply H; trivial. Qed.Theorem evalDet_steps_bind_done_inv_h : forall (A : Set)(x y : comp_state A), evalDet_steps x y -> forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a, x = (cs_more (Bind c1 c2) s) -> y = (cs_done a s') -> exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\ evalDet_steps (cs_more (c2 b) s'') (cs_done a s'). induction 1; intuition; subst. discriminate. inversion H1; clear H1; subst. inversion H0; clear H0; subst. case_eq (evalDet_step c1 s0); intuition; rewrite H in H2; discriminate. case_eq (evalDet_step c1 s0); intuition; rewrite H0 in H. inversion H; clear H; subst. econstructor. econstructor. intuition. econstructor. eapply H0. econstructor. econstructor; eauto. discriminate. inversion H; clear H; subst. edestruct IHevalDet_steps. simpl. rewrite H0. eauto. eauto. destruct H. intuition. econstructor. econstructor. intuition. econstructor. eapply H0. eauto. trivial. Qed.Theorem evalDet_steps_bind_done_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a, evalDet_steps (cs_more (Bind c1 c2) s) (cs_done a s') -> exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\ evalDet_steps (cs_more (c2 b) s'') (cs_done a s'). intuition. eapply evalDet_steps_bind_done_inv_h; eauto.Qed.Theorem evalDet_steps_bind_eof_inv_h : forall (A : Set)(x y : comp_state A), evalDet_steps x y -> forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s, x = (cs_more (Bind c1 c2) s) -> y = (@cs_eof A) -> evalDet_steps (cs_more c1 s) (@cs_eof B) \/ exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ evalDet_steps (cs_more (c2 b) s') (@cs_eof A). induction 1; intuition; subst. discriminate. inversion H1; clear H1; subst. inversion H0; clear H0; subst. case_eq (evalDet_step c1 s0); intuition; rewrite H in H2. discriminate. left. econstructor. rewrite H. eauto. econstructor. discriminate. case_eq (evalDet_step c1 s0); intuition; rewrite H0 in H. inversion H; clear H; subst. right. econstructor. econstructor. intuition. econstructor. eauto. econstructor. econstructor. eauto. trivial. discriminate. inversion H; clear H; subst. edestruct (IHevalDet_steps). simpl. rewrite H0. eauto. trivial. left. econstructor; eauto. destruct H. destruct H. intuition. right. econstructor. econstructor. intuition. econstructor; eauto. trivial.Qed. Theorem evalDet_steps_bind_eof_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s, evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A) -> evalDet_steps (cs_more c1 s) (@cs_eof B) \/ exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ evalDet_steps (cs_more (c2 b) s') (@cs_eof A). 
in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_not_append_entries : forall net ps' p' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. intros. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold packets_gt_prevIndex in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_ge_prevTerm_only_new_packets_matter : forall net ps' l st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_ge_prevTerm (mkNetwork l st') -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_ge_prevTerm_no_append_entries : forall net ps' l st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. intros. eapply packets_ge_prevTerm_only_new_packets_matter; eauto. unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_ge_prevTerm_not_append_entries : forall net ps' p' st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. intros. unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold packets_ge_prevTerm in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem handleTimeout_not_is_append_entries : forall h st st' ps p, handleTimeout h st = (st', ps) -> In p (send_packets h ps) -> ~ is_append_entries (pBody p). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; simpl in *; eauto; repeat (do_in_map; subst; simpl in *); intuition; break_exists; congruence. Qed. Theorem logs_sorted_timeout : raft_net_invariant_timeout logs_sorted. Proof using. unfold raft_net_invariant_timeout. unfold logs_sorted. intuition. - unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp handleTimeout_log. find_higher_order_rewrite. break_match; repeat find_rewrite; eauto. - eapply logs_sorted_nw_no_append_entries; eauto. intros. eauto using handleTimeout_not_is_append_entries. - eapply packets_gt_prevIndex_no_append_entries; eauto. intros. eauto using handleTimeout_not_is_append_entries. - eapply packets_ge_prevTerm_no_append_entries; eauto. intros. eauto using handleTimeout_not_is_append_entries. Qed. Ltac find_eapply_hyp_goal := match goal with | H : _ |- _ => eapply H end. Theorem sorted_append : forall l l', sorted l -> sorted l' -> (forall e e', In e l -> In e' l' -> eIndex e > eIndex e') -> (forall e e', In e l -> In e' l' -> eTerm e >= eTerm e') -> sorted (l ++ l'). 
Require Setoid. Require Import PeanoNat Le Gt Minus Bool Lt.Set Implicit Arguments. Open Scope list_scope. Module ListNotations. Notation "[ ]" := nil (format "[ ]") : list_scope. Notation "[ x ]" := (cons x nil) : list_scope. Notation "[ x ; y ; .. ; z ]" := (cons x (cons y .. (cons z nil) ..)) : list_scope. End ListNotations.Import ListNotations.Section Lists. Variable A : Type. Definition hd (default:A) (l:list A) := match l with | [] => default | x :: _ => x end. Definition hd_error (l:list A) := match l with | [] => None | x :: _ => Some x end. Definition tl (l:list A) := match l with | [] => nil | a :: m => m end. Fixpoint In (a:A) (l:list A) : Prop := match l with | [] => False | b :: m => b = a \/ In a m end.End Lists.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), [] <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = []}. Proof. induction l as [|a tail]. right; reflexivity. left; exists a, tail; reflexivity. Qed. Lemma hd_error_tl_repr : forall l (a:A) r, hd_error l = Some a /\ tl l = r <-> l = a :: r. Proof. destruct l as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. 
simpl; intros. reflexivity. specialize (IHls base). revert IHls. case_eq (starred F ls base); intros; rewrite <- IHls; heq_canceler. Qed. Theorem starred_base : forall T F ls base, (@starred T F ls base) <===> (SE.Star base (@starred T F ls Emp)). Proof. intros. repeat rewrite starred_def. revert base. induction ls; simpl in *; intros. heq_canceler. rewrite IHls. heq_canceler. Qed. Ltac heq_canceler := repeat match goal with | [ H : SE.heq _ _ _ _ _ _ _ |- _ ] => rewrite H | [ |- context [ starred ?F ?L ?B ] ] => match B with | SE.Emp => fail 1 | _ => rewrite (@starred_base _ F L B) end end; SE_FACTS.heq_canceler. Global Add Parametric Morphism : (fun k0 : nat => starred (Func k0)) with signature (eq ==> eq ==> heq funcs preds U G cs ==> heq funcs preds U G cs) as star_himp_mor'. Proof. intros. repeat rewrite starred_def. revert H. revert x; revert y1. induction y0; unfold heq in *; simpl in *; intros; try eauto. rewrite IHy0; eauto. heq_canceler. Qed. Lemma transpose_neqkey_starred : NatMap.IntMapProperties.transpose_neqkey (SE.heq funcs preds U G cs) (fun k0 : nat => starred (Func k0)). Proof. red. intros. rewrite starred_base. symmetry. rewrite starred_base. repeat rewrite starred_base with (base := a). heq_canceler. Qed. Lemma transpose_neqkey_Star (X : Type) F : NatMap.IntMapProperties.transpose_neqkey (heq funcs preds U G cs) (fun (k0 : nat) (ls : X) (a1 : sexpr types _ _) => Star (F k0 ls) a1). Proof. red. intros. heq_canceler. Qed. Hint Resolve transpose_neqkey_starred transpose_neqkey_Star : hprop. Hint Extern 1 (Morphisms.Proper _ _) => (unfold Morphisms.Proper, Morphisms.respectful; intros; subst; repeat match goal with | [ H : heq _ _ _ _ _ _ _ |- _ ] => rewrite H end; reflexivity) : hprop. Hint Extern 1 (MM.PROPS.transpose_neqkey _ _) => (clear; red; intros; subst; repeat rewrite MM.FACTS.add_o; repeat match goal with | [ |- context [ FM.E.eq_dec ?X ?Y ] ] => destruct (FM.E.eq_dec X Y) | [ H : FM.E.eq ?X ?Y |- _ ] => rewrite H in * end; solve [ auto | exfalso; auto | heq_canceler ]) : hprop. Theorem impuresD_Add : forall f argss i i', MM.PROPS.Add f argss i i' -> ~FM.In f i -> SE.heq funcs preds U G cs (impuresD i') (SE.Star (starred (SE.Func f) argss SE.Emp) (impuresD i)). Proof. unfold impuresD; intros. rewrite MM.PROPS.fold_Add; eauto with typeclass_instances hprop. heq_canceler. Qed. Theorem impuresD_Empty : forall i, FM.Empty i -> SE.heq funcs preds U G cs (impuresD i) SE.Emp. 
(boxed n a) -> boxed_header n a tag -> repr_branches_L6_L7 ((t, e)::cl) (LScons (Some (Z.land tag 255)) (Ssequence s Sbreak) (LScons lsa lsb lsc)) ls'. Theorem repr_branches_LSnil_no_unboxed: forall t e cl ls, findtag cl t = Some e -> repr_branches_L6_L7 cl ls LSnil -> ~ (exists arr, M.get t rep_env = Some (enum arr)). Proof. induction cl; intros. - inv H. - simpl in H. destruct a. destruct (M.elt_eq c t). + subst. inv H0; intro; destruct H0; rewrite H0 in H8; inv H8. + inv H0. inv H4. inv H. eapply IHcl; eauto. Qed.Theorem repr_branches_LSnil_no_boxed: forall t e cl ls, findtag cl t = Some e -> repr_branches_L6_L7 cl LSnil ls -> ~ (exists arr s, M.get t rep_env = Some (boxed arr s)). Proof. induction cl; intros. - inv H. - simpl in H. destruct a. destruct (M.elt_eq c t). + subst. inv H0; intro; destruct H0; destruct H0. rewrite H0 in H7; inv H7. rewrite H0 in H8; inv H8. + inv H0. inv H8. inv H. eapply IHcl; eauto. Qed. Definition gc_vars := ((allocIdent, valPtr)::(limitIdent, valPtr)::(argsIdent, valPtr)::(caseIdent, boolTy) ::nil).Definition gc_set := (allocIdent ::= Efield tinfd allocIdent valPtr ; limitIdent ::= Efield tinfd limitIdent valPtr ; argsIdent ::= Efield tinfd argsIdent (Tarray val maxArgs noattr)).Definition gc_test (gcArrIdent:positive) (l:N) (vs : list positive) (ind : list N) (fenv : fun_env) (finfo_env : fun_info_env) := (reserve argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent nParam gcArrIdent (Z.of_N (l + 2)) vs ind fenv finfo_env).Definition gc_test' (gcArrIdent:positive) (l:N) (vs : list positive) (ind : list N) (fenv : fun_env) (finfo_env : fun_info_env) := (reserve' argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent nParam gcArrIdent (Z.of_N (l + 2)) vs ind fenv finfo_env).Inductive right_param_asgn: list positive -> list N -> statement -> Prop := | asgn_nil: right_param_asgn nil nil Sskip | asgn_cons: forall x xs n ns s, right_param_asgn xs ns s -> right_param_asgn (x::xs) (n::ns) ((x ::= args[Z.of_N n]);s).Definition lenv_param_asgn (lenv lenv':temp_env) (xs:list positive) (vs:list Values.val): Prop := forall i, (forall z, nthN xs z = Some i -> M.get i lenv' = nthN vs z) /\ (~ List.In i xs -> M.get i lenv' = M.get i lenv).Inductive lenv_param_asgn_i: temp_env -> temp_env -> list positive -> list Values.val -> Prop := | LPA_nil: forall lenv, lenv_param_asgn_i lenv lenv [] [] | LPA_cons: forall lenv lenv' ys vs y v, lenv_param_asgn_i (M.set y v lenv) lenv' ys vs -> lenv_param_asgn_i lenv lenv' (y::ys) (v::vs). Theorem lenv_param_asgn_i_length: forall ys vs lenv lenv', lenv_param_asgn_i lenv lenv' ys vs -> length ys = length vs. 
((fun x' => ex_intro _ _) _). refine (ex_intro _). refine (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) _ x input0_). (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_). Definition s A (input0_ : A) := (fun x => conj (fun Hin => match Hin with | ex_intro s Hc => match Hc with | conj Hl Hin => nat_ind (fun n => forall x (input0_ : A), Basics.impl ((let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) x) ((@eq A) x input0_)) (fun x (input0_ : A) hin => match hin with | or_introl Hr0 => eq_ind _ _ (eq_refl _) _ Hr0 | or_intror Hl0 => False_ind _ Hl0 end) (fun size0 IHs x (input0_ : A) hin => match hin with | or_introl Hr1 => eq_ind _ _ (eq_refl _) _ Hr1 | or_intror Hl1 => False_ind _ Hl1 end) s x input0_ Hin end end) (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_)). *) Theorem plus_id_exercise : forall n m o : nat, n = m -> m = o -> n + m = m + o. Admitted. QuickChick plus_id_exercise.Theorem mult_0_plus : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem mult_S_1 : forall n m : nat, m = S n -> m * (1 + n) = m * m. Admitted. Theorem plus_1_neq_0_firsttry : forall n : nat, beq_nat (n + 1) 0 = false. Admitted. Theorem negb_involutive : forall b : bool, negb (negb b) = b. Admitted. Theorem andb_commutative : forall b c, andb b c = andb c b. Admitted. Theorem andb_true_elim2 : forall b c : bool, andb b c = true -> c = true. Admitted. Theorem zero_nbeq_plus_1 : forall n : nat, beq_nat 0 (n + 1) = false. 
sm = sm_synced ]] * [[[ d ::: crash_xform (diskIs (list2nmem (nthd n ds))) ]]] * [[ BFILE.MSinitial ms ]] XCRASH:hm' LOG.before_crash (FSXPLog fsxp) (SB.rep fsxp) ds hm' >} recover cachesize. Proof. unfold recover, LOG.after_crash; intros. eapply pimpl_ok2; monad_simpl. eapply BUFCACHE.init_recover_ok. intros; norm. cancel. intuition simpl. eauto. prestep. norml. denote ((crash_xform _) d') as Hx. apply crash_xform_sep_star_dist in Hx. rewrite SB.crash_xform_rep in Hx. rewrite LOG.after_crash_idem' in Hx; eauto. destruct_lift Hx; denote (crash_xform (crash_xform _)) as Hx. apply crash_xform_idem_l in Hx. norm. cancel. intuition. pred_apply. apply sep_star_comm; eauto. step. prestep. norm. cancel. unfold LOG.after_crash; norm. cancel. intuition simpl. pred_apply; norml. unfold stars; simpl. norm. cancel. rewrite LOG.rep_inner_hashmap_subset. eassign (SB.rep fsxp). cancel. or_l; cancel. auto. intuition simpl; eauto. safecancel. rewrite LOG.rep_inner_hashmap_subset. or_r; cancel. auto. eauto. auto. intuition. step. prestep. norm. 2: intuition idtac. cancel. intuition simpl; eauto. intuition simpl; eauto. intuition simpl; eauto. xcrash. eapply LOG.crash_xform_cached_before; eauto. xcrash. denote (SB.rep) as Hsb. rewrite SB.rep_magic_number in Hsb. destruct_lift Hsb. step. xcrash. unfold LOG.before_crash. denote or as Hor; apply sep_star_or_distr in Hor. destruct Hor as [ Hor | Hor ]; rewrite LOG.rep_inner_hashmap_subset in Hor; eauto. rewrite LOG.rep_inner_notxn_pimpl in Hor. destruct_lift Hor. norm. cancel. intuition. pred_apply. safecancel. rewrite LOG.rep_inner_rollbacktxn_pimpl in Hor. norm. cancel. intuition. pred_apply. safecancel. xcrash. unfold LOG.before_crash. denote or as Hor; apply sep_star_or_distr in Hor. destruct Hor as [ Hor | Hor ]; rewrite LOG.rep_inner_hashmap_subset in Hor; eauto. rewrite LOG.rep_inner_notxn_pimpl in Hor. destruct_lift Hor. norm. cancel. intuition. pred_apply. safecancel. rewrite LOG.rep_inner_rollbacktxn_pimpl in Hor. norm. cancel. intuition. pred_apply. safecancel. Unshelve. all: eauto. Qed. Hint Extern 1 ({{_}} Bind (recover _) _) => apply recover_ok : prog. Ltac recover_ro_ok := intros; repeat match goal with | [ |- forall_helper _ ] => unfold forall_helper; intros; eexists; intros | [ |- corr3 ?pre' _ _ ] => eapply corr3_from_corr2_rx; eauto with prog | [ |- corr3 _ _ _ ] => eapply pimpl_ok3; intros | [ |- corr2 _ _ ] => step | [ H: crash_xform ?x =p=> ?x |- context [ crash_xform ?x ] ] => rewrite H | [ H: diskIs _ _ |- _ ] => unfold diskIs in * | [ |- pimpl (crash_xform _) _ ] => progress autorewrite with crash_xform end. Hint Extern 0 (okToUnify (LOG.idempred _ _ _ _) (LOG.idempred _ _ _ _)) => constructor : okToUnify. Hint Extern 0 (okToUnify (LOG.after_crash _ _ _ _ _) (LOG.after_crash _ _ _ _ _)) => constructor : okToUnify. Theorem file_getattr_ok : forall fsxp inum mscs, {< ds sm pathname Fm Ftop tree f ilist frees, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: (Fm * rep fsxp Ftop tree ilist frees mscs sm) ]]] * [[ find_subtree pathname tree = Some (TreeFile inum f) ]] POST:hm' RET:^(mscs',r) LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[[ ds!! ::: (Fm * rep fsxp Ftop tree ilist frees mscs' sm) ]]] * [[ r = DFAttr f /\ MSAlloc mscs' = MSAlloc mscs /\ MSCache mscs' = MSCache mscs ]] CRASH:hm' LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' >} file_get_attr fsxp inum mscs. 
+ destruct Hinputs as (H''&?&?&?&?). rewrite H0 in Hfind. inv Hfind. destruct H6 as (?&_). eapply LCS.sem_clocks_det' in H8; eauto. - specialize (Href f ins outs). rewrite ident_eqb_neq in Hident. eapply sem_node_cons'... apply Href. split. 1:rewrite <- LCS.sem_clock_inputs_cons in Hinputs... econstructor... eapply Forall_impl_In; [| eauto]. intros eq Hin Hsem. eapply sem_equation_global_tl... eapply find_node_later_not_Is_node_in in Hord1... intro Hisin. apply Hord1. rewrite Is_node_in_Exists. rewrite Exists_exists. eexists... Qed. Fact iface_eq_sem_clocks_input : forall G G' f ins, global_iface_eq G G' -> LCS.sem_clock_inputs G f ins -> LCS.sem_clock_inputs G' f ins. Proof. intros * Hglob [H [n [Hfind [Hinputs Hsem]]]]. specialize (Hglob f). rewrite Hfind in Hglob; inv Hglob. destruct H2 as (Hname&_&Hins&_). exists H. exists sy. repeat split; auto; congruence. Qed. Fact normfby_global_names' : forall G Hwl Hprefs, Forall2 (fun n n' => n_name n = n_name n') G (normfby_global G Hwl Hprefs). Proof. intros. induction G; simpl; auto. Qed. Lemma normfby_global_refines : forall G Hunt Hprefs, wt_global G -> wc_global G -> Forall LCA.node_causal G -> LCS.global_sc_refines G (normfby_global G Hunt Hprefs). Proof with eauto. intros G Hunt. specialize (normfby_global_eq G Hunt) as Heq. induction G; intros * Hwt Hwc Hcaus; simpl. - apply LCS.global_sc_ref_nil. - apply LCS.global_sc_ref_cons with (f:=n_name a)... + eapply wt_global_Ordered_nodes. eapply Typing.normfby_global_wt in Hwt; eauto. + inv Hwt; inv Hwc; inv Hcaus. eapply IHG... eapply normfby_global_eq... + intros ins outs Hsem. destruct Hsem as [Hinputs Hsem]. split. * eapply iface_eq_sem_clocks_input... * eapply normfby_node_eq... -- apply normfby_global_names'. -- apply normfby_global_eq. -- inv Hwt; inv Hwc; inv Hcaus. eapply IHG... eapply normfby_global_eq... -- inv Hwt. eapply normfby_global_wt... -- inv Hwc. eapply normfby_global_wc... -- eapply wt_global_Ordered_nodes. eapply normfby_global_wt in Hwt... -- inv Hwc. inv Hcaus. eapply normfby_global_causal; eauto. Qed. Corollary normfby_global_sem : forall G Hunt Hprefs f ins outs, wt_global G -> wc_global G -> Ordered_nodes G -> Forall LCA.node_causal G -> sem_node G f ins outs -> LCS.sem_clock_inputs G f ins -> sem_node (normfby_global G Hunt Hprefs) f ins outs. Proof. intros. eapply normfby_global_refines with (Hunt:=Hunt) in H; eauto. specialize (H f ins outs (conj H4 H3)) as [_ ?]; eauto. Qed. Corollary normfby_global_sem_clock_inputs : forall G Hwl Hprefs f ins, LCS.sem_clock_inputs G f ins -> LCS.sem_clock_inputs (normfby_global G Hwl Hprefs) f ins. Proof. intros. specialize (normfby_global_eq G Hwl Hprefs) as Heq. destruct H as [H [n' [Hfind [Hvars Hsem]]]]. eapply global_iface_eq_find in Heq as [? [? [Hname [_ [Hin Hout]]]]]; eauto. exists H. exists x. repeat split; auto. 1,2:congruence. Qed. Theorem normalize_global_sem : forall G Hwl Hprefs G' f ins outs, wt_global G -> wc_global G -> sem_node G f ins outs -> LCS.sem_clock_inputs G f ins -> normalize_global G Hwl Hprefs = Errors.OK G' -> sem_node G' f ins outs. 
x) < ulp x)%R. Proof with auto with typeclass_instances. intros rnd Zrnd x Zx. destruct (generic_format_EM beta fexp x) as [Hx|Hx].rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. rewrite ulp_neq_0; trivial. apply bpow_gt_0.destruct (round_DN_or_UP beta fexp rnd x) as [H|H] ; rewrite H ; clear H.rewrite Rabs_left1. rewrite Ropp_minus_distr. apply Rplus_lt_reg_l with (round beta fexp Zfloor x). rewrite <- round_UP_DN_ulp with (1 := Hx). ring_simplify. assert (Hu: (x <= round beta fexp Zceil x)%R). apply round_UP_pt... destruct Hu as [Hu|Hu]. exact Hu. elim Hx. rewrite Hu. apply generic_format_round... apply Rle_minus. apply round_DN_pt...rewrite Rabs_pos_eq. rewrite round_UP_DN_ulp with (1 := Hx). apply Rplus_lt_reg_r with (x - ulp x)%R. ring_simplify. assert (Hd: (round beta fexp Zfloor x <= x)%R). apply round_DN_pt... destruct Hd as [Hd|Hd]. exact Hd. elim Hx. rewrite <- Hd. apply generic_format_round... apply Rle_0_minus. apply round_UP_pt... Qed. Theorem error_le_ulp : forall rnd { Zrnd : Valid_rnd rnd } x, (Rabs (round beta fexp rnd x - x) <= ulp x)%R. Proof with auto with typeclass_instances. intros rnd Zrnd x. case (Req_dec x 0). intros Zx; rewrite Zx, round_0... unfold Rminus; rewrite Rplus_0_l, Ropp_0, Rabs_R0. apply ulp_ge_0. intros Zx; left. now apply error_lt_ulp. Qed. Theorem error_le_half_ulp : forall choice x, (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp x)%R. Proof with auto with typeclass_instances. intros choice x. destruct (generic_format_EM beta fexp x) as [Hx|Hx].rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. apply Rmult_le_pos. apply Rlt_le. apply Rinv_0_lt_compat. now apply (Z2R_lt 0 2). apply ulp_ge_0.set (d := round beta fexp Zfloor x). destruct (round_N_pt beta fexp choice x) as (Hr1, Hr2). destruct (Rle_or_lt (x - d) (d + ulp x - x)) as [H|H].apply Rle_trans with (Rabs (d - x)). apply Hr2. apply (round_DN_pt beta fexp x). rewrite Rabs_left1. rewrite Ropp_minus_distr. apply Rmult_le_reg_r with 2%R. now apply (Z2R_lt 0 2). apply Rplus_le_reg_r with (d - x)%R. ring_simplify. apply Rle_trans with (1 := H). right. field. apply Rle_minus. apply (round_DN_pt beta fexp x).assert (Hu: (d + ulp x)%R = round beta fexp Zceil x). unfold d. now rewrite <- round_UP_DN_ulp. apply Rle_trans with (Rabs (d + ulp x - x)). apply Hr2. rewrite Hu. apply (round_UP_pt beta fexp x). rewrite Rabs_pos_eq. apply Rmult_le_reg_r with 2%R. now apply (Z2R_lt 0 2). apply Rplus_le_reg_r with (- (d + ulp x - x))%R. ring_simplify. apply Rlt_le. apply Rlt_le_trans with (1 := H). right. field. apply Rle_0_minus. rewrite Hu. apply (round_UP_pt beta fexp x). Qed. Theorem ulp_DN : forall x, (0 < round beta fexp Zfloor x)%R -> ulp (round beta fexp Zfloor x) = ulp x. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.TermSanityInterface.Section TermSanityProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Theorem no_entries_past_current_term_nw_packets_unchanged : forall net ps' st', no_entries_past_current_term_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> no_entries_past_current_term_nw (mkNetwork ps' st'). Proof using. unfold no_entries_past_current_term_nw in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem no_entries_past_current_term_nw_only_new_packets_matter : forall net ps' l st', no_entries_past_current_term_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> no_entries_past_current_term_nw (mkNetwork l st') -> no_entries_past_current_term_nw (mkNetwork ps' st'). Proof using. unfold no_entries_past_current_term_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem no_entries_past_current_term_nw_no_append_entries : forall net ps' h l st', no_entries_past_current_term_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p (send_packets h l)) -> (forall m, In m l -> ~ is_append_entries (snd m)) -> no_entries_past_current_term_nw (mkNetwork ps' st'). 
(dir2flatmem2 (TStree ts'!!))) ]]) \/ ([[ r = OK tt ]] * exists tf' tfy', ([[ tree_with_tmp Ftree srcpath tmppath srcinum file tinum tf' dstbase dstname dstfile (dir2flatmem2 (TStree ts'!!)) ]] * [[ AByteFile.rep tf' tfy' ]] * [[[ (ByFData tfy') ::: (arrayN (ptsto (V:= byteset)) 0 (map (fun x => (x, nil:list byte)) (map fst copy_data))) ]]] * [[ ByFAttr tfy' = ByFAttr fy]]))) XCRASH:hm' exists ds' ts' sm' mscs', LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds' hm' * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds' ]] * [[ treeseq_pred (tree_rep Ftree srcpath tmppath srcinum file tinum dstbase dstname dstfile) ts']] >} copy2temp fsxp srcinum tinum mscs. Proof. unfold copy2temp, tree_with_tmp; step. instantiate(1:= file). instantiate(1:= srcpath). cancel. step. rewrite H19; eauto. cancel. unfold rep in *; split_hypothesis. rewrite <- H13; rewrite H14; rewrite H15; auto. rewrite Nat.div_mul; auto. step. step. prestep; norm. inversion H23. inversion H23. unfold stars; cancel. instantiate (10:= fy). split. split. split. split. split. split. split. intuition. eauto. rewrite H14; apply H35. rewrite H28; rewrite H4; apply H26. rewrite H19; eauto. rewrite update_update_subtree_same. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. eauto. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. unfold tree_with_tmp. pred_apply; cancel. eauto. apply bytefile_exists. simpl. rewrite setlen_length. rewrite roundup_div_mul; auto. eauto. simpl; apply list2nmem_array. simpl. unfold rep in *; split_hypothesis. rewrite H25; auto. auto. auto. step. unfold tree_with_tmp in *; or_l; cancel. unfold tree_with_tmp in *; or_r; safecancel. eauto. eauto. auto. xcrash. xcrash; eauto. unfold stars; cancel. unfold tree_with_tmp; or_l; cancel. 2: intuition; eauto. pred_apply; cancel. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. eauto. unfold stars; cancel. intuition; eauto. rewrite update_update_subtree_same. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. xcrash; eauto. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. rewrite update_update_subtree_same. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. xcrash; eauto. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. xcrash; eauto. apply treeseq_pushd_tree_rep; auto. apply tree_rep_update_subtree; auto. xcrash; eauto. Unshelve. all: repeat econstructor. all: apply any. Qed.Hint Extern 1 ({{_}} Bind (copy2temp _ _ _ _) _) => apply copy2temp_ok : prog. Definition copy_and_rename fsxp src_inum tinum (dstbase:list string) (dstname:string) mscs := let^ (mscs, ok) <- copy2temp fsxp src_inum tinum mscs; match ok with | Err _ => let^ (mscs) <- AFS.tree_sync fsxp mscs; Ret ^(mscs, ok) | OK _ => let^ (mscs, r) <- AFS.rename fsxp the_dnum [] temp_fn dstbase dstname mscs; let^ (mscs) <- AFS.tree_sync fsxp mscs; Ret ^(mscs, r) end. Theorem copy_and_rename_ok : forall fsxp srcinum tinum (dstbase: list string) (dstname:string) mscs, {< Fm Ftop Ftree ds ts sm srcpath file tfile fy copy_data dstfile, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[ treeseq_in_ds Fm Ftop fsxp sm mscs ts ds ]] * [[ treeseq_pred (treeseq_safe [temp_fn] (MSAlloc mscs) (ts !!)) ts ]] * [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dstfile) ts ]] * [[ tree_with_tmp Ftree srcpath [temp_fn] srcinum file tinum tfile dstbase dstname dstfile (dir2flatmem2 (TStree ts!!)) ]] * [[ AByteFile.rep file fy ]] * [[[ (ByFData fy) ::: (arrayN (ptsto (V:= byteset)) 0 copy_data) ]]] * [[ dirtree_inum (TStree ts!!) = the_dnum ]] * [[ length (DFData tfile) <= length (DFData file) ]] * [[ length copy_data > 0 ]] POST:hm' RET:^(mscs', r) exists ds' ts' sm', LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds') (MSLL mscs') sm' hm' * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds' ]] * (([[ isError r ]] * (exists f' dfile, [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dfile) ts' ]] * [[ tree_with_tmp Ftree srcpath [temp_fn] srcinum file tinum f' dstbase dstname dfile (dir2flatmem2 (TStree ts'!!)) ]])) \/ ([[r = OK tt]] * (exists dfile dfy, [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dfile) ts' ]] * [[ tree_with_src Ftree srcpath [temp_fn] srcinum file dstbase dstname dfile (dir2flatmem2 (TStree ts'!!)) ]] * [[AByteFile.rep dfile dfy ]] * [[[ (ByFData dfy) ::: (arrayN (ptsto (V:= byteset)) 0 (map (fun x => (x, nil:list byte)) (map fst copy_data))) ]]] * [[ ByFAttr fy = ByFAttr dfy ]]))) XCRASH:hm' exists mscs' ds' ts' sm', LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds' hm' * ((exists t, [[ ts' = (t, nil) ]] * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds' ]] * [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dstfile) ts']] ) \/ (exists t ts'' dfile, [[ ts' = pushd t ts'' ]] * [[ treeseq_in_ds Fm Ftop fsxp sm' mscs' ts' ds' ]] * [[ tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dfile t ]] * [[ treeseq_pred (tree_rep Ftree srcpath [temp_fn] srcinum file tinum dstbase dstname dstfile) ts'' ]] )) >} copy_and_rename fsxp srcinum tinum dstbase dstname mscs. 
From Huffman Require Export BTree. From Huffman Require Export Ordered. Require Import ArithRing. Section WeightTree. Variable A : Type. Variable f : A -> nat.Fixpoint sum_leaves (t : btree A) : nat := match t with | leaf n => f n | node t1 t2 => sum_leaves t1 + sum_leaves t2 end.Definition sum_order x y := sum_leaves x <= sum_leaves y.Definition le_sum x y := le_bool (sum_leaves x) (sum_leaves y). Theorem le_sum_correct1 : forall a b1 : btree A, le_sum a b1 = true -> sum_order a b1. Proof using. intros a b1; apply (le_bool_correct3 (sum_leaves a) (sum_leaves b1)). Qed. Theorem le_sum_correct2 : forall a b1 : btree A, le_sum a b1 = false -> sum_order b1 a. 
E; elim E; intros H'11 H'12; elim H'12; intros H'13 H'14; elim H'13; [ intros H'15; clear H'13 H'12 E | intros H'15; clear H'13 H'12 E ] | idtac | idtac | idtac ] | idtac ]; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redInInclQ with (Q := genOCPf l); auto. apply redInclP with (P := l); auto. apply H'; auto. apply incl_tran with (m := a :: l); simpl in |- *; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redIn1; auto. apply red_incl with (1 := cs) (p := addEnd A A0 eqA n ltM a l); auto. apply addEnd_incl; auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. Qed. Theorem OBuch_Stable_f : forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> stable P Q. intros P Q H'; try assumption. apply OBuch_Stable with (Q := genOCPf P); auto. intros a H'0; try assumption. apply genOCPf_stable; auto. Qed. Theorem OBuch_Inv_f : forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> forall a b : poly A0 eqA ltM, In a Q -> In b Q -> reds a b Q. intros P Q H' a b H'0 H'1; try assumption. apply OBuch_Inv with (aP := P) (Q := genOCPf P); auto. intros a0 b0 H'3 H'4. apply genOCp_redln; auto. apply ObuchPincl with (Q := genOCPf P); auto. Qed. Require Import Lexicographic_Product. Let FPset (A : list (poly A0 eqA ltM)) := list (poly A0 eqA ltM). Definition Fl : forall x : list (poly A0 eqA ltM), FPset x -> FPset x -> Prop. unfold FPset in |- *; simpl in |- *. intros H' P1 P2. exact (Tl P1 P2). Defined. Theorem wf_Fl : forall x : list (poly A0 eqA ltM), well_founded (Fl x). unfold FPset in |- *; simpl in |- *. intros x; generalize wf_Tl; auto. Qed. Let Co := lexprod (list (poly A0 eqA ltM)) FPset (RO A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os) Fl. Theorem wf_Co : well_founded Co. 
applied_entries sigma. Proof using. intros. apply applied_entries_log_lastApplied_same. - intros. update_destruct; subst; rewrite_update; auto. eapply doLeader_same_log; eauto. - intros. update_destruct; subst; rewrite_update; auto. unfold doLeader in *. repeat break_match; find_inversion; auto. Qed. Lemma applyEntries_spec : forall es h st os st', applyEntries h st es = (os, st') -> exists d cc, st' = {[ {[ st with stateMachine := d ]} with clientCache := cc ]}. Proof using. induction es; intros; simpl in *; intuition. - find_inversion. destruct st'; repeat eexists; eauto. - unfold cacheApplyEntry, applyEntry in *. repeat break_match; repeat find_inversion; find_apply_hyp_hyp; break_exists; repeat eexists; eauto. Qed. Lemma applyEntries_spec_ind : forall {es h st os st'}, applyEntries h st es = (os, st') -> forall P : raft_data -> Prop, (forall d cc, P {[ {[ st with stateMachine := d ]} with clientCache := cc ]}) -> P st'. Proof using. intros. find_apply_lem_hyp applyEntries_spec. break_exists. subst. eauto. Qed. Lemma handleClientRequest_commitIndex : forall h st client id c out st' l, handleClientRequest h st client id c = (out, st', l) -> commitIndex st' = commitIndex st. Proof using. unfold handleClientRequest. intros. repeat break_match; find_inversion; auto. Qed. Lemma handleTimeout_commitIndex : forall h st out st' l, handleTimeout h st = (out, st', l) -> commitIndex st' = commitIndex st. Proof using. unfold handleTimeout, tryToBecomeLeader; intros; repeat break_match; repeat find_inversion; auto. Qed. Lemma handleAppendEntriesReply_same_commitIndex : forall n st src t es b st' l, handleAppendEntriesReply n st src t es b = (st', l) -> commitIndex st' = commitIndex st. Proof using. unfold handleAppendEntriesReply, advanceCurrentTerm. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma handleRequestVote_same_commitIndex : forall n st t c li lt st' ms, handleRequestVote n st t c li lt = (st', ms) -> commitIndex st' = commitIndex st. Proof using. unfold handleRequestVote, advanceCurrentTerm. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma handleRequestVoteReply_same_commitIndex : forall n st src t v, commitIndex (handleRequestVoteReply n st src t v) = commitIndex st. Proof using. unfold handleRequestVoteReply, advanceCurrentTerm. intros. repeat break_match; simpl; auto. Qed. Lemma doGenericServer_commitIndex : forall h st out st' ms, doGenericServer h st = (out, st', ms) -> commitIndex st' = commitIndex st. Proof using. unfold doGenericServer. intros. repeat break_match; repeat find_inversion; simpl; eapply applyEntries_spec_ind; eauto. Qed. Functional Scheme div2_ind := Induction for div2 Sort Prop. Theorem div2_correct' : forall n, n <= div2 n + S (div2 n). Proof using. intro n. functional induction (div2 n); lia. Qed. Theorem div2_correct : forall c a b, a > div2 c -> b > div2 c -> a + b > c. 
: forall (A : Set), Comp A -> Prop := | well_formed_Ret : forall (A : Set)(pf : eq_dec A)(a : A), well_formed_comp (Ret pf a) | well_formed_Bind : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A), well_formed_comp c1 -> (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) -> well_formed_comp (Bind c1 c2) | well_formed_Rnd : forall n, well_formed_comp (Rnd n) | well_formed_Repeat : forall (A : Set)(eqd : eq_dec A)(c : Comp A) P b, well_formed_comp c -> In b (filter P (getSupport c)) -> well_formed_comp (Repeat c P).Delimit Scope comp_scope with comp.Theorem lt_eq_false : forall n, n < n -> False. destruct n; intuition.Qed.Lemma length_nz_exists : forall (A : Type)(ls : list A), length ls > 0 -> exists a, In a ls. destruct ls; intuition; simpl in *. exfalso. eapply lt_eq_false; eauto. econstructor; eauto. Qed. Theorem getSupport_length_nz : forall (A : Set)(c : Comp A), well_formed_comp c -> length (getSupport c) > 0. induction 1; intuition; simpl in *. apply length_getUnique_nz. apply length_nz_exists in IHwell_formed_comp. destruct IHwell_formed_comp. eapply length_flatten_nz. eapply in_map_iff. econstructor; intuition; eauto. eapply H1. trivial. apply getAllBvectors_length_nz. destruct (filter P (getSupport c)); simpl in *; intuition. Qed.Lemma filter_NoDup : forall (A : Set)(ls : list A)(P : A -> bool), NoDup ls -> NoDup (filter P ls). induction ls; intuition; simpl in *. inversion H; clear H; subst. case_eq (P a); intuition. econstructor; intuition. eapply H2. eapply filter_In; eauto.Qed.Lemma getSupport_NoDup : forall (A : Set)(c : Comp A), NoDup (getSupport c). induction c; intuition; simpl in *. econstructor. apply in_nil. econstructor. eapply getUnique_NoDup. eapply getAllBvectors_NoDup. eapply filter_NoDup. trivial.Qed. Lemma getSupport_Bind_In : forall (A B : Set) (c : Comp B)(f : B -> Comp A) a, In a (getSupport (Bind c f)) -> exists b, In b (getSupport c) /\ In a (getSupport (f b)). intuition. simpl in *. apply in_getUnique_if in H. eapply in_flatten in H. destruct H. intuition. apply in_map_iff in H0. destruct H0. intuition. subst. econstructor. intuition; eauto. Qed.Ltac pairInv := match goal with | [H : (_, _) = (_, _) |-_ ] => inversion H; clear H; subst end.Ltac destruct_exists := match goal with | [H : exists x, _ |- _ ] => destruct H end.Theorem getSupport_In_Ret : forall (A : Set)(eqd : eq_dec A) x a, In x (getSupport (Ret eqd a)) -> x = a. intuition. simpl in *. intuition.Qed. Theorem getSupport_In_Seq : forall (A B : Set)(c : Comp A)(f : A -> Comp B) b a, In a (getSupport c) -> In b (getSupport (f a)) -> In b (getSupport (Bind c f)). 
auto. - revert m j H; induction i; destruct j,m; simpl; intros; auto; solve [apply IHi; congruence | apply gso0; congruence | congruence]. Qed. Lemma gNode: forall {A} (i: positive) (l: tree A) (x: option A) (r: tree A), get i (Node l x r) = match i with xH => x | xO j => get j l | xI j => get j r end. Proof. intros. destruct l, x, r; simpl; auto; destruct i; auto. Qed. Theorem grs: forall (A: Type) (i: positive) (m: tree A), get i (remove i m) = None. Proof. Local Opaque Node. destruct m as [ |m]; simpl. auto. change (remove' i m) with (rem' i m). revert m. induction i; destruct m; simpl; auto; rewrite gNode; auto. Qed. Theorem gro: forall (A: Type) (i j: positive) (m: tree A), i <> j -> get i (remove j m) = get i m. Proof. Local Opaque Node. destruct m as [ |m]; simpl. auto. change (remove' j m) with (rem' j m). revert j m. induction i; destruct j, m; simpl; intros; auto; solve [ congruence | rewrite gNode; auto; apply IHi; congruence ]. Qed. Section MAP_FILTER. Variables A B: Type. Definition option_map (f: A -> option B) (o: option A): option B := match o with None => None | Some a => f a end. Fixpoint map_filter' (f: A -> option B) (m: tree' A) : tree B := match m with | Node001 r => Node Empty None (map_filter' f r) | Node010 x => Node Empty (f x) Empty | Node011 x r => Node Empty (f x) (map_filter' f r) | Node100 l => Node (map_filter' f l) None Empty | Node101 l r => Node (map_filter' f l) None (map_filter' f r) | Node110 l x => Node (map_filter' f l) (f x) Empty | Node111 l x r => Node (map_filter' f l) (f x) (map_filter' f r) end. Definition map_filter'_opt := Eval cbv [map_filter' Node] in map_filter'. Definition map_filter (f: A -> option B) (m: tree A) : tree B := match m with | Empty => Empty | Nodes m' => map_filter'_opt f m' end. Theorem gmap_filter': forall (f: A -> option B) (m: tree' A) (i: positive), get i (map_filter' f m) = option_map f (get' i m). Proof using Type. induction m; simpl; intros; rewrite gNode; destruct i; simpl; auto. Qed. Theorem gmap_filter: forall (f: A -> option B) (m: tree A) (i: positive), get i (map_filter f m) = option_map f (get i m). 
Require Export ZArith. Require Export Znumtheory. Require Import Classical. Theorem euclids_first_theorem : forall p : Z, prime p -> forall a b : Z, (p | a * b) -> (p | a) \/ (p | b). Proof. intros p prime_p a b div. elim (classic (p | a)). intros. left. assumption. intros. right. specialize (prime_rel_prime p). intros. apply H0 with (a:=a) in prime_p; [|assumption]. specialize (Gauss p a b). intros. auto. Qed.Theorem infinite_primes: forall n : Z, exists p : Z, p > n /\ prime p. Proof. Abort. Theorem theorem_5: forall n : Z, exists c : Z, forall x : Z, c <= x < c+n -> ~(prime x). Proof. Abort. Theorem twin_prime_conjecture: forall n : Z, exists p : Z, p > n /\ prime p /\ prime (p+2). 
propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 \/ interp P2 | _ => fun _ _ => False end P1 P2 | Imply G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 -> interp P2 | _ => fun _ _ => False end P1 P2 | Forall G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => forall x, interp (P1 x) | _ => fun _ => False end P1 | Exists G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => exists x, interp (P1 x) | _ => fun _ => False end P1 | ForallX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => forall x, interp (Subst P1 x) | _ => fun _ => False end P1 | ExistsX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => exists x, interp (Subst P1 x) | _ => fun _ => False end P1 | _ => False end. intros ? H; apply normalization in H; inversion H; subst; clear H; try solve [ elimtype False; eauto ]; intuition eauto. Qed. Ltac sound := intros; match goal with | [ H : interp _ |- _ ] => solve [ apply interp_sound in H; auto ] end. Theorem Inj_sound : forall p, interp (Inj p) -> p. sound. Qed. Theorem Cptr_sound : forall f a, interp (Cptr f a) -> specs f = Some (fun x => a x). sound. Qed. Theorem And_sound : forall P Q, interp (And P Q) -> interp P /\ interp Q. sound. Qed. Theorem Or_sound : forall P Q, interp (Or P Q) -> interp P \/ interp Q. sound. Qed. Theorem Imply_sound : forall P Q, interp (Imply P Q) -> interp P -> interp Q. sound. Qed. Theorem Forall_sound : forall A (P : A -> _), interp (Forall P) -> forall x, interp (P x). sound. Qed. Theorem Exists_sound : forall A (P : A -> _), interp (Exists P) -> exists x, interp (P x). sound. Qed. Theorem ForallX_sound : forall A (P : propX (A :: nil)), interp (ForallX P) -> forall f, interp (Subst P f). 
(plusA (multA a1 (invA a0)) A0); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (invA a0)) (plusA (multA a1 a0) (invA (multA a1 a0)))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (plusA (multA a1 (invA a0)) (multA a1 a0)) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (plusA (invA a0) a0)) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (plusA a0 (invA a0))) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 A0) (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA A0 a1) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA A0 (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (invA (multA a1 a0)) A0); auto. Qed. Theorem eqTerm_invTerm_comp : forall a b : Term, eqTerm a b -> eqTerm (invTerm a) (invTerm b). intros a b; case a; case b; simpl in |- *; auto. intuition. Qed. Theorem invTerm_eqT : forall a : Term, eqT a (invTerm a). intros a; case a; simpl in |- *; auto. Qed. Theorem T1_eqT : forall a b : Term, eqTerm a T1 -> eqT b (multTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1; case H1; intros H2 H3; auto. rewrite H3; auto. unfold eqT in |- *; simpl in |- *; apply sym_eq; unfold M1 in |- *; apply mult_mon_zero_l. Qed. Theorem eqTerm_T1_eqT : forall a : Term, eqTerm a T1 -> eqT a T1. intros a; case a; simpl in |- *; auto. intuition. Qed. Set Implicit Arguments. Unset Strict Implicit. Definition minusTerm : Term -> Term -> Term. intros H; case H; intros b2 c2 H'; case H'; intros b3 c3; exact (minusA b2 b3, c2). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem eqTerm_minusTerm_plusTerm_invTerm : forall a b : Term, eqTerm (minusTerm a b) (plusTerm a (invTerm b)). 
(b + d) = c + d. Proof. intros. omega. Qed. Fact combine_eq_rect_combine : forall a b c d H (wa : word a) (wb : word b) (wa' : word d), combine (eq_rect (a + b) word (combine wa wb) c H) wa' = eq_rect _ word (combine wa (combine wb wa')) _ (combine_eq_rect_combine_helper a b d H). Proof. intros a b c d H. subst c. intros. eq_rect_simpl. erewrite combine_assoc, eq_rect_word_match. reflexivity. Qed. Fact split2_eq_rect_combine : forall a b c H (wa : word a) (wc : word c), split2 a b (eq_rect (a + c) word (combine wa wc) (a + b) H) = eq_rect c word wc b (plus_reg_l c b a H). Proof. intros a b c H. assert (c = b) by omega; subst. intros. eq_rect_simpl. apply split2_combine. Qed. Theorem word_selN_shift_eq_middle : forall idx off n w, @word_selN_shift (idx + 1 + off) n idx w = middle (idx * n) n (off * n) (eq_rec _ word w _ (eq_sym (word_shift_helper3 idx off n))). Proof. intros. eq_rect_simpl. rewrite word_selN_shift_gt_0. generalize_proof. replace ((idx + off) * n) with (idx * n + off * n) by lia. intros HH. unfold wrshift. eq_rect_simpl. erewrite combine_eq_rect2. rewrite eq_rect_combine_dist3 with (w := w); eq_rect_simpl. erewrite combine_eq_rect_combine; eq_rect_simpl. erewrite split2_eq_rect_combine; eq_rect_simpl. repeat erewrite combine_assoc, eq_rect_word_match; eq_rect_simpl. unfold middle. repeat progress (rewrite eq_rect_combine || rewrite split1_combine || rewrite split2_combine). reflexivity. Grab Existential Variables. all : lia. Qed. Theorem word_selN_shift_equiv : forall ft l idx w, idx < l -> @word_selN ft l idx w = @word_selN_shift l (len ft) idx w. Proof. intros. generalize dependent w. remember (l - idx - 1) as off. assert (l = (idx + 1+ off)) by omega. subst l. intros w. unfold word_selN. destruct lt_dec; try omega. erewrite word_selN_shift_eq_middle. generalize dependent (word_selN_helper (len ft) l). replace ((idx + 1 + off) * len ft - len ft - idx * len ft) with (off * len ft) by lia. intros HH. f_equal. apply eq_rect_both; eq_rect_simpl. reflexivity. Qed. Definition word_selN' {ft : type} {l : nat} (idx : nat) (w : word (len (ArrayF ft l))) : word (len ft) := @word_selN_shift l (len ft) idx w. Theorem word_selN'_equiv : forall ft l idx w def, idx < l -> of_word (@word_selN' ft l idx w) = selN (of_word w) idx def. Proof. intros. unfold word_selN'. rewrite <- word_selN_shift_equiv; auto. apply word_selN_equiv; auto. Qed. Theorem word_updN_shift_l_gt_0 : forall idx off n w v, @word_updN_shift (idx + 1 + off) n idx w v = w ^& wnot (word_mask (idx + 1 + off) n idx) ^| wlshift ( eq_rect _ word (zext v ((idx + off) * n)) _ (word_shift_helper1 n idx off)) (idx * n). 
b}. intros a b H. case (D.lt_eq_lt_dec a b). trivial. intro H0; case (le_not_lt a b H H0). Defined.End More_Dec_Orders. Module Forget_Order (D: DEC_ORDER) : KEY with Definition A := D.A. Module M := More_Dec_Orders D. Definition A := D.A. Definition eqdec : forall a b : A, {a = b} + {a <> b}. intros a b; case (D.lt_eq_lt_dec a b). intro H; case H. right; apply D.lt_diff; auto. left; trivial. intro d; right. intro e; rewrite e in d. apply (M.lt_irreflexive b); auto. Defined. End Forget_Order. Module Lexico (D1: DEC_ORDER) (D2: DEC_ORDER) <: DEC_ORDER with Definition A := (D1.A * D2.A)%type. Module M1 := More_Dec_Orders D1. Module M2 := More_Dec_Orders D2. Definition A := (D1.A * D2.A)%type. Definition le (a b : A) : Prop := let (a1, a2) := a in let (b1, b2) := b in D1.lt a1 b1 \/ a1 = b1 /\ D2.le a2 b2. Definition lt (a b : A) : Prop := let (a1, a2) := a in let (b1, b2) := b in D1.lt a1 b1 \/ a1 = b1 /\ D2.lt a2 b2. Theorem ordered : order A le. Proof. split. unfold reflexive in |- *; intros. unfold le in |- *; case x. right. split; [ trivial | apply M2.le_refl; auto ]. unfold le, transitive in |- *. simple destruct x; simple destruct y; simple destruct z. simple destruct 1; intro H1. simple destruct 1. left. eapply M1.lt_trans. eexact H1. assumption. simple destruct 1. simple destruct 1. auto. simple destruct 1. intro. case H1; intros e H3; rewrite e; auto. case H1; intros e H3; rewrite e; auto. simple destruct 1. simple destruct 1. right. split; try auto. eapply M2.le_trans; eauto. unfold antisymmetric, A, le in |- *. simple destruct x; simple destruct y. simple destruct 1; simple destruct 2. intro. absurd (D1.lt a1 a1). apply M1.lt_irreflexive. eapply M1.lt_trans; eauto. simple destruct 1; intros e H3. rewrite e in H0. case (M1.lt_irreflexive a H0). case H0; intros e H3. rewrite e; intro H2. case (M1.lt_irreflexive a1 H2). simple destruct 1; intros e H3; rewrite e. case (M2.le_antisym a2 a0). auto. case H0; auto. auto. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. Proof. unfold A, lt, le in |- *; intros a b; case a; case b. simple destruct 1; intros; auto. right; case H0; split; auto. apply D2.lt_le_weak; trivial. Qed. Theorem lt_diff : forall a b : A, lt a b -> a <> b. 
(now apply hd_error_Some_In); auto. - apply not_Is_defined_not_Is_sub_in_eqs. assert (In x l) by (now apply hd_error_Some_In); auto. Qed. Lemma gather_insts_Is_sub_in_translate_eqns: forall eqs x, InMembers x (gather_insts eqs) -> exists k, Is_sub_in x k (translate_eqns eqs). Proof. unfold gather_insts, translate_eqns. induction eqs as [|[]]; simpl; try contradiction; intros * Hin. - edestruct IHeqs; eauto; eexists; right; eauto. - destruct l; simpl in *; auto. destruct o as [(?&?)|]. + destruct Hin; subst. * exists 1; apply Exists_app'; left; right; left; constructor. * edestruct IHeqs; eauto; eexists; apply Exists_app; eauto. + destruct Hin; subst. * exists 1; apply Exists_app'; left; left; constructor. * edestruct IHeqs; eauto; eexists; apply Exists_app; eauto. - edestruct IHeqs; eauto; eexists; right; eauto. Qed. Lemma state_closed_insts_empty: forall P insts, state_closed_insts P insts (empty_memory _). Proof. intros ???? Find. rewrite find_inst_gempty in Find; discriminate. Qed. Corollary equations_correctness: forall G bk H M eqs vars, (forall f xss M yss, msem_node G f xss M yss -> sem_system_n (translate G) f M xss yss (next M)) -> Ordered_nodes G -> Forall (NL.Clo.wc_equation G vars) eqs -> CE.Sem.sem_clocked_vars bk H vars -> NoDup_defs eqs -> Forall (msem_equation G bk H M) eqs -> exists Is, sem_trconstrs_n (translate G) bk H M Is (next M) (translate_eqns eqs) /\ (forall n, state_closed_insts (translate G) (gather_insts eqs) (Is n)) /\ forall n x, find_val x (Is n) = None. Proof. intros ???????? WC ?? Heqs. unfold translate_eqns. induction eqs as [|eq eqs IHeqs]; simpl; inv WC. - exists (fun n => empty_memory _); split; try constructor. + intro; apply state_closed_insts_empty. + intro; apply find_val_gempty. - apply Forall_cons2 in Heqs as [Heq Heqs]. apply IHeqs in Heqs as (?&?&?&?); auto. + unfold gather_insts; simpl. eapply equation_correctness; eauto. eapply Nodup_defs_translate_eqns; eauto. + eapply NoDup_defs_cons; eauto. Qed. Lemma not_Is_node_in_not_Is_system_in: forall eqs f, ~ Is_node_in f eqs -> ~ Is_system_in f (translate_eqns eqs). Proof. unfold translate_eqns. induction eqs as [|eq]; simpl; intros * Hnin Hin. - inv Hin. - apply not_Is_node_in_cons in Hnin as (Hnineq & Hnin). apply IHeqs in Hnin. destruct eq; simpl in *. + inversion_clear Hin as [?? E|?? Hins]; try inv E; auto. + destruct l; auto. destruct o as [(?&?)|]; inversion_clear Hin as [?? E|?? Hins]; auto. * inv E; apply Hnineq; constructor. * inversion_clear Hins as [?? E|?? Hins']; auto. inv E; apply Hnineq; constructor. * inv E; apply Hnineq; constructor. + inversion_clear Hin as [?? E|?? Hins]; try inv E; auto. Qed. Theorem correctness: forall G f xss M yss, Ordered_nodes G -> wc_global G -> msem_node G f xss M yss -> sem_system_n (translate G) f M xss yss (next M). 
destruct (ixm (Embed 0 = Embed 0))... destruct (ixm (Embed 1 = Embed 0)). split... apply mul_cancel' in Heq... assert (H2m: (2 ‚ã m)%œâ ‚àà œâ) by (apply mul_ran; nauto). exfalso. apply (no_even_and_odd (2 ‚ã m)%œâ H2m). split. exists m. split... rewrite Heq. exists p. split... + destruct (ixm (Embed 0 = Embed 0))... destruct (ixm (Embed 1 = Embed 0)). split... apply mul_cancel' in Heq... assert (H2p: (2 ‚ã p)%œâ ‚àà œâ) by (apply mul_ran; nauto). exfalso. apply (no_even_and_odd (2 ‚ã p)%œâ H2p). split. exists p. split... rewrite <- Heq. exists m. split... + destruct (ixm (Embed 1 = Embed 0)). * exfalso. eapply suc_neq_0... * assert (H2m: (2 ‚ã m)%œâ ‚àà œâ) by (apply mul_ran; nauto). assert (H2p: (2 ‚ã p)%œâ ‚àà œâ) by (apply mul_ran; nauto). split... rewrite <- suc, <- suc in Heq... apply suc_injective in Heq... apply mul_cancel' in Heq... - intros y Hy. destruct (even_or_odd y Hy). + destruct H as [n [Hn Heqy]]. exists <n, 0>. split. apply BUnionI1. apply CPrdI... zfc_simple. destruct (ixm (Embed 0 = Embed 0))... + destruct H as [n [Hn Heqy]]. exists <n, 1>. split. apply BUnionI2. apply CPrdI... zfc_simple. destruct (ixm (Embed 1 = Embed 0))... exfalso. eapply suc_neq_0... Qed.Fact cardMul_expAleph0_expAleph0 : ‚àÄ ùú , ùú ^ ‚Ñµ‚ÇÄ ‚ã ùú ^ ‚Ñµ‚ÇÄ = ùú ^ ‚Ñµ‚ÇÄ. Proof. intros. rewrite <- cardExp_add. rewrite cardAdd_aleph0_aleph0. reflexivity. Qed.Fact cardMul_aleph0_expAleph0 : ‚àÄ ùú , 2 ‚â§ ùú ‚Üí ‚Ñµ‚ÇÄ ‚ã ùú ^ ‚Ñµ‚ÇÄ = ùú ^ ‚Ñµ‚ÇÄ. Proof with auto. intros. eapply cardLe_antisym. - rewrite <- cardMul_expAleph0_expAleph0 at 2. apply cardMul_preserve_le. eapply cardLe_trans; revgoals. apply cardExp_preserve_base_le. apply H. apply cardLt_power. apply aleph0_is_card. - rewrite <- (cardMul_1_r (ùú ^ ‚Ñµ‚ÇÄ)) at 1... rewrite cardMul_comm. apply cardMul_preserve_le. pose proof (cardLt_aleph0_if_finite 1) as []; nauto. Qed.Fact cardExp_expAleph0_expAleph0 : ‚àÄ ùú ùúÜ, 2 ‚â§ ùúÜ ‚Üí (ùú ^ ‚Ñµ‚ÇÄ) ^ (ùúÜ ^ ‚Ñµ‚ÇÄ) = ùú ^ (ùúÜ ^ ‚Ñµ‚ÇÄ). Proof with auto. intros AC6 * H2. rewrite cardExp_exp, cardMul_aleph0_expAleph0... Qed.Fact cardMul_aleph0_aleph0 : ‚Ñµ‚ÇÄ ‚ã ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ. Proof with auto. apply CardAx1. eapply Equivalence_Transitive. apply cardMul_well_defined; rewrite <- CardAx0; reflexivity. symmetry. apply œâ_eqnum_œâ_cp_œâ. Qed.Fact cardExp_aleph0_n : ‚àÄn ‚àà œâ, n ‚â ‚à ‚Üí ‚Ñµ‚ÇÄ ^ n = ‚Ñµ‚ÇÄ. Proof with auto. intros n Hn. œâ_induction n. - intros. exfalso... - intros _. destruct (classic (m = 0)). + subst m. rewrite cardExp_1_r... + apply IH in H. rewrite <- card_suc, cardExp_suc, H... apply cardMul_aleph0_aleph0. Qed. Theorem cardExp_aleph0_aleph0 : ‚Ñµ‚ÇÄ ^ ‚Ñµ‚ÇÄ = 2 ^ ‚Ñµ‚ÇÄ. 
Require Import missing. Require Import division. Require Import Wf_nat.Unset Standard Proposition Elimination Names. Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a). intros. elim H0;intro q;intro. replace b with (b*1);try ring. rewrite H1. apply mult_le_compat;try omega. destruct q;omega. Qed. Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\ (r < b)}}. 
Require Import Bool. Definition bool_not (b:bool) : bool := if b then false else true. Definition bool_xor (b b':bool) : bool := if b then bool_not b' else b'.Definition bool_and (b b':bool) : bool := if b then b' else false.Definition bool_or (b b':bool) := if b then true else b'. Definition bool_eq (b b':bool) := if b then b' else bool_not b'. Theorem bool_xor_not_eq : forall b1 b2:bool, bool_xor b1 b2 = bool_not (bool_eq b1 b2). 
Hp HR; clear H; split; [ auto with zarith | rewrite two_p_S with (x := Z.succ (log_inf p)) by (apply Z.le_le_succ_r; trivial); rewrite two_p_S by trivial; rewrite two_p_S in HR by trivial; rewrite (BinInt.Pos2Z.inj_xI p); omega ] | elim H; intros Hp HR; clear H; split; [ auto with zarith | rewrite two_p_S with (x := Z.succ (log_inf p)) by (apply Z.le_le_succ_r; trivial); rewrite two_p_S by trivial; rewrite two_p_S in HR by trivial; rewrite (BinInt.Pos2Z.inj_xO p); omega ] | unfold two_power_pos; unfold shift_pos; simpl; omega ]. Qed. Definition log_inf_correct1 (p:positive) := proj1 (log_inf_correct p). Definition log_inf_correct2 (p:positive) := proj2 (log_inf_correct p). Opaque log_inf_correct1 log_inf_correct2. Hint Resolve log_inf_correct1 log_inf_correct2: zarith. Lemma log_sup_correct1 : forall p:positive, 0 <= log_sup p. Proof. simple induction p; intros; simpl; auto with zarith. Qed. Theorem log_sup_log_inf : forall p:positive, IF Zpos p = two_p (log_inf p) then Zpos p = two_p (log_sup p) else log_sup p = Z.succ (log_inf p). Proof. simple induction p; intros; [ elim H; right; simpl; rewrite (two_p_S (log_inf p0) (log_inf_correct1 p0)); rewrite BinInt.Pos2Z.inj_xI; unfold Z.succ; omega | elim H; clear H; intro Hif; [ left; simpl; rewrite (two_p_S (log_inf p0) (log_inf_correct1 p0)); rewrite (two_p_S (log_sup p0) (log_sup_correct1 p0)); rewrite <- (proj1 Hif); rewrite <- (proj2 Hif); auto | right; simpl; rewrite (two_p_S (log_inf p0) (log_inf_correct1 p0)); rewrite BinInt.Pos2Z.inj_xO; unfold Z.succ; omega ] | left; auto ]. Qed. Theorem log_sup_correct2 : forall x:positive, two_p (Z.pred (log_sup x)) < Zpos x <= two_p (log_sup x). Proof. intro. elim (log_sup_log_inf x). intros [E1 E2]; rewrite E2. split; [ apply two_p_pred; apply log_sup_correct1 | apply Z.le_refl ]. intros [E1 E2]; rewrite E2. rewrite (Z.pred_succ (log_inf x)). generalize (log_inf_correct2 x); omega. Qed. Lemma log_inf_le_log_sup : forall p:positive, log_inf p <= log_sup p. Proof. simple induction p; simpl; intros; omega. Qed. Lemma log_sup_le_Slog_inf : forall p:positive, log_sup p <= Z.succ (log_inf p). Proof. simple induction p; simpl; intros; omega. Qed. Fixpoint log_near (x:positive) : Z := match x with | xH => 0 | xO xH => 1 | xI xH => 2 | xO y => Z.succ (log_near y) | xI y => Z.succ (log_near y) end. Theorem log_near_correct1 : forall p:positive, 0 <= log_near p. Proof. simple induction p; simpl; intros; [ elim p0; auto with zarith | elim p0; auto with zarith | trivial with zarith ]. intros; apply Z.le_le_succ_r. generalize H0; now elim p1. intros; apply Z.le_le_succ_r. generalize H0; now elim p1. Qed. Theorem log_near_correct2 : forall p:positive, log_near p = log_inf p \/ log_near p = log_sup p. 
Set Warnings "-notation-overridden,-parsing". Require Export IndProp.Print ev. Check ev_SS. Theorem ev_4 : ev 4. Proof. apply ev_SS. apply ev_SS. apply ev_0. Qed.Print ev_4. Check (ev_SS 2 (ev_SS 0 ev_0)). Theorem ev_4': ev 4. 
Qed. Lemma Some_Cinr_included (A B: cmra) (x:B) (y: csumR A B) : Some (Cinr x) ‚âº Some y ‚Üí y = CsumBot ‚à® (‚àÉ x', y = Cinr x' ‚àß (x ‚â° x' ‚à® x ‚âº x')). Proof. intros H%Some_included_inv. intuition idtac. - inversion H0; subst; eauto. - apply Cinr_included_inv in H0. intuition eauto. right. destruct H as [? (?&?)]; eauto. Qed. Lemma map_ptsto_included k q v (m: gmap K (V*bool)) : {[k := Cinl (q, to_agree v)]} ‚âº to_mapUR m ‚Üí m !! k = Some (v, false). Proof. rewrite singleton_included_l lookup_fmap. intros [y [Hequiv Hincl]]. apply fmap_Some_equiv in Hequiv as [ [v' ro] [Hlookup Hy_equiv] ]. rewrite Hlookup. f_equiv. apply Some_Cinl_included in Hincl as [-> | Hincl]. { destruct ro; inversion Hy_equiv. } destruct Hincl as [ [q' v''] [-> Hequiv_incl ]]. destruct ro; [ inversion Hy_equiv | ]. f_equiv. inversion Hy_equiv; subst; clear Hy_equiv. rewrite -> H1 in Hequiv_incl. destruct Hequiv_incl as [Hequiv|Hincl]. - inversion Hequiv; subst; simpl in *. apply (inj to_agree), leibniz_equiv_iff in H0; auto. - apply pair_included in Hincl as [_ Hincl]; simpl in Hincl. apply to_agree_included, leibniz_equiv in Hincl; auto. Qed. Lemma map_ptsto_ro_included k v (m: gmap K (V*bool)) : {[k := Cinr (to_agree v)]} ‚âº to_mapUR m ‚Üí m !! k = Some (v, true). Proof. rewrite singleton_included_l lookup_fmap. intros [y [Hequiv Hincl]]. apply fmap_Some_equiv in Hequiv as [ [v' ro] [Hlookup Hy_equiv] ]. rewrite Hlookup. f_equiv. apply Some_Cinr_included in Hincl as [-> | Hincl]. { destruct ro; inversion Hy_equiv. } destruct Hincl as [ [q' v''] [-> Hequiv_incl ]]. destruct ro; [ | by inversion Hy_equiv ]. f_equiv. inversion Hy_equiv; subst; clear Hy_equiv. rewrite -> H1 in Hequiv_incl. destruct Hequiv_incl as [Hequiv|Hincl]. - apply (inj to_agree), leibniz_equiv_iff in Hequiv; auto. - apply to_agree_included, leibniz_equiv in Hincl; auto. Qed. Theorem map_valid {Œ≥ m} k q mq v : map_ctx Œ≥ q m -‚àó ptsto Œ≥ k mq v -‚àó ‚åúm !! k = Some v‚åù. Proof. unseal; rewrite /ptsto_def. iDestruct 1 as (m_ro ->) "Hm". iIntros "Hk". rewrite lookup_fmap. destruct mq. - iDestruct (own_valid_2 with "Hm Hk") as %(_ & Hlookup%map_ptsto_included & _)%auth_both_dfrac_valid_discrete. iPureIntro. rewrite Hlookup //. - iDestruct (own_valid_2 with "Hm Hk") as %(_ & Hlookup%map_ptsto_ro_included & _)%auth_both_dfrac_valid_discrete. iPureIntro. rewrite Hlookup //. Qed. Theorem map_ro_valid {Œ≥ m} k q v : map_ctx Œ≥ q m -‚àó ptsto_ro Œ≥ k v -‚àó ‚åúm !! k = Some v‚åù. Proof. apply map_valid. Qed. Theorem map_valid_subset Œ≥ q (m0 m: gmap K V) mq : map_ctx Œ≥ q m -‚àó ([‚àó map] a‚Ü¶v ‚àà m0, ptsto Œ≥ a mq v) -‚àó ‚åúm0 ‚äÜ m‚åù. 
a + u * u0 * n + u * c) (v := v0 * b + v * v0 * n + v * d). repeat rewrite mult_plus_distr_r. repeat rewrite plus_assoc. rewrite (mult_comm u0); rewrite (mult_comm v0). repeat rewrite mult_assoc_reverse. repeat rewrite (mult_comm a); repeat rewrite (mult_comm b). repeat rewrite <- mult_plus_distr_r. repeat rewrite mult_assoc. repeat rewrite mult_comm with (m := n). rewrite (mult_assoc n u); rewrite (mult_assoc n v). repeat rewrite mult_assoc. repeat rewrite (mult_assoc_reverse n n). rewrite mult_comm with (m := n * u); rewrite mult_comm with (m := n * v). repeat rewrite mult_assoc_reverse with (m := n). repeat rewrite (mult_comm (n * u)); repeat rewrite (mult_comm (n * v)). repeat rewrite plus_assoc_reverse; repeat rewrite <- mult_plus_distr_r. rewrite plus_comm with (m := c); rewrite plus_comm with (m := d). repeat rewrite (mult_comm (c + n * u0)); repeat rewrite (mult_comm (d + n * v0)). repeat rewrite (mult_comm (c + n * u0)); repeat rewrite (mult_comm (d + n * v0)). repeat rewrite <- mult_plus_distr_r. repeat rewrite (mult_comm n); rewrite H; auto. Qed. Lemma cong_pow : forall a b c : nat, congruent a b -> congruent (power a c) (power b c). intros a b c; elim c; simpl in |- *; auto. intros H'; apply cong_ref. intros n0 H' H'0. apply cong_mult; auto. Qed. Theorem congruent' : forall a b : nat, b <= a -> congruent a b -> exists k : nat, a = k * n + b. intros a b H' H'0; inversion_clear H'0. exists (v - u). rewrite mult_minus_distr_r; auto. rewrite plus_minus_assoc. rewrite plus_comm; rewrite <- H; rewrite plus_comm; auto with arith. apply le_plus_le with (a := b) (b := a); auto. Qed. Lemma cong1_le : forall x : nat, 1 < n -> congruent x 1 -> 1 <= x. Proof. intros x; case x; auto with arith. intros H' H'0; inversion_clear H'0. absurd (n = 1). red in |- *; intros H'0; absurd (1 < n); auto; rewrite H'0; auto with arith. apply mult_SO with (y := u - v); auto. rewrite mult_comm. rewrite mult_minus_distr_r; auto. simpl in H; rewrite H. rewrite <- minus_Sn_m; auto with arith. Qed. Lemma divides_cong : forall x : nat, divides n x -> congruent 0 x. Proof. intros x H; inversion_clear H. apply congruentDef with (u := q) (v := 0); simpl in |- *; rewrite H0; auto with arith. Qed. Theorem cong_divides : forall a b : nat, b <= a -> congruent a b -> divides n (a - b). 
match argss , nth_error tp p with | nil , _ => true | _ , None => false | argss , Some ts => allb (fun args => all2 (is_well_typed tf tU tG) args ts) argss end) impures true. Proof. reflexivity. Qed. Definition WellTyped_sheap (tf : tfunctions) (tp : tpredicates) (tU tG : tenv) (h : SHeap) : bool := WellTyped_impures tf tp tU tG (impures h) && allb (fun e => is_well_typed tf tU tG e tvProp) (pures h). Theorem WellTyped_sheap_eq : forall (tf : tfunctions) (tp : SE.tpredicates) (tU tG : tenv) (h : SHeap), WellTyped_sheap tf tp tU tG h = WellTyped_impures tf tp tU tG (impures h) && allb (fun e => is_well_typed tf tU tG e tvProp) (pures h). Proof. clear. reflexivity. Qed. Lemma starred_const_well_typed : forall tf tp tU tG e x, WellTyped_sexpr tf tp tU tG (starred (@Const _ _ _) x e) = WellTyped_sexpr tf tp tU tG e. Proof. clear. induction x; simpl; intros; auto. destruct (starred (Const (stateType:=stateType)) x e); auto. Qed. Lemma starred_pures_well_typed : forall tf tp tU tG e x, WellTyped_sexpr tf tp tU tG (starred (@Inj _ _ _) x e) = allb (fun e => is_well_typed tf tU tG e tvProp) x && WellTyped_sexpr tf tp tU tG e. Proof. clear. induction x; simpl; intros; auto. consider (is_well_typed tf tU tG a tvProp); intros; destruct (starred (Inj (stateType:=stateType)) x e); simpl in *; think; auto. rewrite <- IHx. auto. Qed. Lemma starred_funcs_well_typed : forall tf tp tU tG p, forall e x, WellTyped_sexpr tf tp tU tG (starred (@Func _ _ _ p) x e) = match x , nth_error tp p with | nil , _ => true | _ , None => false | x , Some ts => allb (fun args => all2 (is_well_typed tf tU tG) args ts) x end && WellTyped_sexpr tf tp tU tG e. Proof. clear. induction x; simpl; intros; auto. destruct x; simpl in *. { destruct e; simpl; repeat match goal with | [ |- context [ nth_error ?a ?b ] ] => destruct (nth_error a b) | [ |- context [ all2 ?a ?b ?c ] ] => destruct (all2 a b c) end; auto. } { repeat (simpl in *; match goal with | [ |- context [ match ?X with _ => _ end ] ] => destruct X end); auto. } Qed. Theorem WellTyped_sheap_WellTyped_sexpr : forall tf tp tU tG h, WellTyped_sheap tf tp tU tG h = SE.WellTyped_sexpr tf tp tU tG (sheapD h). 
From hydras Require Import primRec cPair extEqualNat.Fixpoint fib (n:nat) : nat := match n with | 0 => 1 | 1 => 1 | S ((S p) as q) => fib q + fib p end. Section Proof_of_FibIsPR. Let fib_step (p: nat * nat) := (fst p + snd p, fst p). Let fib_iter n p:= (nat_rec (fun _ => (nat*nat)%type) p (fun _ p => fib_step p) n). Definition fib_alt n := snd (fib_iter n (1,1)). Compute fib_alt 10. Let fib_step_cPair p := cPair (cPairPi1 p + cPairPi2 p) (cPairPi1 p). Let fib_iter_cPair n p := nat_rec (fun _ => nat) p (fun _ p => fib_step_cPair p) n. Definition fibPR n := cPairPi2 (fib_iter_cPair n (cPair 1 1)). Lemma fibPRIsPR: isPR 1 fibPR. Admitted. Lemma L2 : extEqual 1 fib_alt fibPR. Admitted. Lemma fib_altIsPR : isPR 1 fib_alt. Admitted. Lemma fib_OK0 : forall n, fib_iter n (1,1) = (fib (S n), fib n). Admitted. Lemma fib_alt_Ok : extEqual 1 fib fib_alt. Admitted. Theorem fibIsPR : isPR 1 fib. 
with | Inj _ p => p | Cptr G f a => match G return (_ -> propX G) -> Prop with | nil => fun a => specs f = Some (fun x => a x) | _ => fun _ => False end a | And G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 /\ interp P2 | _ => fun _ _ => False end P1 P2 | Or G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 \/ interp P2 | _ => fun _ _ => False end P1 P2 | Imply G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 -> interp P2 | _ => fun _ _ => False end P1 P2 | Forall G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => forall x, interp (P1 x) | _ => fun _ => False end P1 | Exists G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => exists x, interp (P1 x) | _ => fun _ => False end P1 | ForallX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => forall x, interp (Subst P1 x) | _ => fun _ => False end P1 | ExistsX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => exists x, interp (Subst P1 x) | _ => fun _ => False end P1 | _ => False end. intros ? H; apply normalization in H; inversion H; subst; clear H; try solve [ elimtype False; eauto ]; intuition eauto. Qed. Ltac sound := intros; match goal with | [ H : interp _ |- _ ] => solve [ apply interp_sound in H; auto ] end. Theorem Inj_sound : forall p, interp (Inj p) -> p. sound. Qed. Theorem Cptr_sound : forall f a, interp (Cptr f a) -> specs f = Some (fun x => a x). sound. Qed. Theorem And_sound : forall P Q, interp (And P Q) -> interp P /\ interp Q. 
Require Import Bool. Require Import Arith. Require Import Compare_dec. Require Import Peano_dec. Require Import General. Require Import MyList. Require Import MyRelations.Require Export Main. Require Export SortV6.Section CoqV6Beta. Definition trm_v6 := term srt_v6. Definition env_v6 := env srt_v6. Definition v6 : CTS_spec srt_v6 := Build_CTS_spec _ axiom_v6 rules_v6 univ_v6 (beta_rule _). Definition v6_pts : PTS_sub_spec srt_v6 := cts_pts_functor _ v6. Definition le_type : red_rule srt_v6 := Rule _ (Le_type _ (pts_le_type _ v6_pts)). Definition typ_v6 : env_v6 -> trm_v6 -> trm_v6 -> Prop := typ _ v6_pts. Definition wft_v6 : env_v6 -> trm_v6 -> Prop := wf_type _ v6_pts. Definition wf_v6 : env_v6 -> Prop := wf _ v6_pts. Definition v6_sn := sn srt_v6 (ctxt _ (Rule _ (head_reduct _ v6))). Hint Unfold le_type typ_v6 wft_v6 wf_v6 v6_sn: pts. Lemma whnf : forall (e : env_v6) (t : trm_v6), v6_sn e t -> {u : trm_v6 | red _ (beta _) e t u & head_normal _ (beta _) e u}. Proof beta_whnf srt_v6. Lemma beta_conv_hnf : forall (e : env_v6) (x y : trm_v6), v6_sn e x -> v6_sn e y -> decide (conv_hn_inv _ (beta_rule _) e x y). Proof CR_WHNF_convert_hn srt_v6 v6_sort_dec (beta_rule srt_v6) (church_rosser_red srt_v6) whnf. Theorem v6_is_subtype_dec : subtype_dec_CTS _ v6. 
forall l a, In a l -> In a (map fst (frequency_list l)). Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H a0 [H0| H0]; auto. rewrite H0; elim (frequency_list l0); simpl in |- *; auto. intros (a1, l1) l2; simpl in |- *; auto. case (eqA_dec a0 a1); simpl in |- *; auto. cut (In a0 (map (fst (A:=A) (B:=nat)) (frequency_list l0))); auto. elim (frequency_list l0); simpl in |- *; auto. intros (a1, l1) l2; simpl in |- *; auto. case (eqA_dec a a1); simpl in |- *; auto. intros e H1 [H2| H2]; auto; left; rewrite <- H2; auto. intros e H1 [H2| H2]; auto. Qed. Hint Resolve in_frequency_map : core. Theorem in_frequency_map_inv : forall l a, In a (map (fst (B:=_)) (frequency_list l)) -> In a l. Proof using. intros l a H; case in_map_inv with (1 := H); auto. intros (a1, l1) (Hl1, Hl2); simpl in |- *. rewrite Hl2; apply frequency_list_in with (1 := Hl1). Qed. Fixpoint number_of_occurrences (a : A) (l : list A) {struct l} : nat := match l with | nil => 0 | b :: l1 => match eqA_dec a b with | left _ => S (number_of_occurrences a l1) | right _ => number_of_occurrences a l1 end end. Theorem number_of_occurrences_O : forall a l, ~ In a l -> number_of_occurrences a l = 0. Proof using. intros a l; elim l; simpl in |- *; auto. intros a0 l0 H H0; case (eqA_dec a a0); auto. intros H1; case H0; auto. Qed. Theorem number_of_occurrences_permutation_ex : forall (m : list A) (a : A), exists m1 : list A, permutation m (id_list a (number_of_occurrences a m) ++ m1) /\ ~ In a m1. Proof using. intros m; elim m; simpl in |- *; auto. intros a; exists (nil (A:=A)); split; auto with datatypes. intros a l H a0. case (eqA_dec a0 a); simpl in |- *; intros H1. case (H a0); intros m1 (H2, H3). exists m1; split; auto. pattern a0 at 1 in |- *; rewrite H1; auto. case (H a0); intros m1 (H2, H3). exists (a :: m1); split; auto. apply permutation_trans with ((a :: m1) ++ id_list a0 (number_of_occurrences a0 l)); auto. simpl in |- *; apply permutation_skip; auto. apply permutation_trans with (1 := H2); auto. simpl in |- *; Contradict H3; case H3; intros H4; auto; case H1; auto. Qed. Theorem number_of_occurrences_app : forall l1 l2 a, number_of_occurrences a (l1 ++ l2) = number_of_occurrences a l1 + number_of_occurrences a l2. 
Theorem double : nat -> nat. Proof. exact (fun x => 2 * x). Qed.Compute double 3. Theorem weird_double : nat -> nat. Proof. exact (fun x => 340). Qed.Theorem double' : nat -> nat. Proof. refine (fun x => _). exact (2 * x). Qed.Theorem double'' : nat -> nat. Proof. intros x. exact (2 * x). Qed. Theorem idtheorem: forall (A: Type), A -> A. Proof. intros. exact X. Qed.Theorem idtheorem': forall (A: Type), A -> A. Proof. exact (fun (A:Type) (x:A) => x). Qed. Definition eq_3 : (3 = 3) := eq_refl.Definition eq_22 : (2 + 2 = 4) := eq_refl.Theorem eq_3: 3 = 3. Proof. exact eq_refl. Qed. Theorem eq_3': 3 = 3. Proof. reflexivity. Qed. Definition eq_3'' : 3 = 3 := eq_refl.Theorem andb1 : andb true true = true. Proof. exact eq_refl. Qed.Theorem andb1' : andb true true = true. Proof. reflexivity. Qed. Theorem nat_eq: forall (n:nat), n = n. Proof. intros n. reflexivity. Qed.Theorem zero_id: forall n, 0 + n = n. Proof. intros n. reflexivity. Qed.Theorem zero_id': forall n, n + 0 = n. Proof. intros n. induction n. reflexivity. simpl. rewrite IHn. reflexivity. Qed.Theorem zero_id'': forall n, n + 0 = n. Proof. auto. Qed. Print zero_id''.Search nat. Theorem double_plus_ungood: forall n, 2 * n = n + n. Proof. intros. simpl. rewrite zero_id'. reflexivity. Qed. Theorem double_plus_ungood': forall n, 2 * n = n + n. 
Kard. Module IsomorphismType. Import ScottsTrick.ForAnyType. Import OrderedStruct.Definition it := Œª S, scott (Œª S, <A S, R S>) isomorphic S.Fact it_nonempty : ‚àÄ S, it S ‚â ‚à . Proof. intros. apply scott_nonempty. apply iso_equiv. Qed.Theorem it_correct : ‚àÄ S T, it S = it T ‚Üî S ‚â T. Proof. intros. apply scott_correct. intros U V Heq. apply op_iff in Heq as []. apply eq_intro; auto. apply iso_equiv. Qed.End IsomorphismType.Example ex7_33 : ‚àÄ D ‚ãµ ùêñùê , trans D ‚Üí ‚àÄ B, (‚àÄa ‚àà D, a ‚äÜ B ‚Üí a ‚àà B) ‚Üí D ‚äÜ B. Proof with eauto. intros D Hgnd Htr B HB. contra as Hnsub. assert (Hne: ‚¶ø (D - B)). { apply EmptyNE. intros H0. apply sub_iff_no_comp in H0... } set {rank x | x ‚àä D - B} as Œ©. destruct (ords_woset Œ©) as [_ Hmin]. { intros x Hx. apply ReplAx in Hx as [d [Hd Heq]]. subst x. apply rank_is_ord... eapply member_grounded... apply SepE1 in Hd... } pose proof (Hmin Œ©) as [Œº [HŒº Hle]]... { destruct Hne as [d Hd]. exists (rank d). apply ReplI... } apply ReplAx in HŒº as [m [Hm HeqŒº]]. subst Œº. apply SepE in Hm as [Hm Hm']. apply Hm'. apply HB... intros x Hxm. contra as Hx'. assert (HxD: x ‚àà D)... assert (Hx: x ‚àà D - B). apply SepI... assert (rank x ‚àà Œ©). apply ReplI... assert (Hgm: m ‚ãµ ùêñùê ). eapply member_grounded... assert (Hgx: x ‚ãµ ùêñùê ). eapply member_grounded... apply rank_of_member in Hxm... apply Hle in H as []. - apply binRelE3 in H. eapply ord_not_lt_gt; revgoals... - rewrite H in Hxm. eapply ord_irrefl; revgoals... Qed.Section RegularWorld. Import RegularityConsequences.Example ex7_34 : ‚àÄ x y u v, {x, {x, y}} = {u, {u, v}} ‚Üí x = u ‚àß y = v. Proof with eauto; try congruence. intros. assert (Hx: x ‚àà {u, {u, v}}). { rewrite <- H. apply PairI1. } assert (Hp: {x, y} ‚àà {u, {u, v}}). { rewrite <- H. apply PairI2. } apply PairE in Hx as []. - subst u. split... apply PairE in Hp as []. + exfalso. eapply pair_regularity... + apply pair_eq_pair in H0 as [[]|[]]... - apply PairE in Hp as []. + exfalso. apply (no_descending_chain_2 x {x, y}). apply PairI1. rewrite H1, H0. apply PairI1. + apply pair_eq_pair in H1 as [[]|[]]... subst. exfalso. rewrite pair_ordering_agnostic in H1. eapply pair_regularity... Qed. Theorem suc_injective : ‚àÄ a b, a‚Å∫ = b‚Å∫ ‚Üí a = b. 
w sc, tq w sc ===> Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc. Axiom tq_bwd : forall w sc, (Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc) ===> tq w sc. Axiom tq_weaken : forall w w' sc, evolve w w' -> tq w sc ===>* tq w' sc. End TQ.Module Tq : TQ. Open Scope Sep_scope. Definition susps (w : world) (b : bag) (sc : W) : HProp := starB (fun p => susp w sc (fst p) (snd p)) b. Theorem susps_empty_bwd : forall w sc, Emp ===> susps w empty sc. intros; apply starB_empty_bwd. Qed. Theorem susps_add_bwd : forall w sc b pc sp, pc = pc -> mergeSusp -> susp w sc pc sp * susps w b sc ===> susps w (b %+ (pc, sp)) sc. intros; eapply Himp_trans; [ | apply starB_add_bwd ]. unfold susps; simpl. apply Himp_star_comm. Qed. Theorem susps_del_fwd : forall w sc b pc sp, (pc, sp) %in b -> susps w b sc ===> susp w sc pc sp * susps w (b %- (pc, sp)) sc. intros; eapply Himp_trans; [ apply starB_del_fwd; eauto | apply Himp_refl ]. Qed. Definition tq (w : world) (sc : W) : HProp := Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc. Theorem tq_extensional : forall w sc, HProp_extensional (tq w sc). reflexivity. Qed. Theorem tq_fwd : forall w sc, tq w sc ===> Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc. unfold tq; sepLemma. Qed. Theorem tq_bwd : forall w sc, (Ex b, Ex p, Ex sp, Ex vs, (sc ==*> p, sp) * (sc ^+ $8) =?> 2 * locals ("rp" :: "sc" :: "ss" :: "curPc" :: "curSp" :: "newPc" :: "newSp" :: nil) vs 14 sp * queue b p * susps w b sc) ===> tq w sc. 
From iris.algebra Require Import gmap. From iris.proofmode Require Import tactics. From Perennial.base_logic.lib Require Import iprop. From Perennial.algebra Require Import big_op.Section liftable. Context `{PROP:bi} `{!BiAffine PROP} `{!BiPureForall PROP}. Context {L V: Type} `{!EqDecision L} `{!Countable L}. Implicit Types (P Q : (L ‚Üí V ‚Üí PROP) ‚Üí PROP). Set Default Proof Using "BiAffine0". Definition PredRestore P (m: gmap L V) : PROP := (‚àÄ mapsto2, ([‚àó map] a‚Ü¶v ‚àà m, mapsto2 a v) -‚àó P mapsto2)%I. Global Instance PredRestore_proper : Proper (pointwise_relation _ (‚ä£‚ä¢) ==> eq ==> (‚ä£‚ä¢)) PredRestore. Proof. intros P1 P2 Hequiv m m' ->. rewrite /PredRestore. setoid_rewrite Hequiv. auto. Qed. Class Liftable (P : (L -> V -> PROP) -> PROP) := liftable : ‚àÄ mapsto1, Conflicting mapsto1 -> P mapsto1 -‚àó ‚àÉ (m : gmap L V), ([‚àó map] a ‚Ü¶ v ‚àà m, mapsto1 a v) ‚àó ‚ñ° PredRestore P m. Global Instance liftable_proper : Proper (pointwise_relation _ (‚ä£‚ä¢) ==> iff) Liftable. Proof. intros P1 P2 Hequiv. rewrite /Liftable. setoid_rewrite Hequiv. auto. Qed. Lemma liftable_restore_elim P `{!Liftable P} mapsto1 `{!Conflicting mapsto1} : P mapsto1 -‚àó ‚àÉ m, ([‚àó map] a‚Ü¶v ‚àà m, mapsto1 a v) ‚àó ‚ñ°PredRestore P m. Proof. iIntros "HP". iDestruct (liftable with "HP") as (m) "[Hm HP]". iExists _; iFrame. Qed. Theorem liftable_sep P Q : Liftable P ‚Üí Liftable Q ‚Üí Liftable (fun h => P h ‚àó Q h)%I. Proof using BiAffine0 BiPureForall0. unfold Liftable in *. intros LiftableP LiftableQ. iIntros (??) "[Hp Hq]". iDestruct (LiftableP with "Hp") as (mp) "[Hpm #Hpi]"; eauto. iDestruct (LiftableQ with "Hq") as (mq) "[Hqm #Hqi]"; eauto. iExists (mp ‚à™ mq). iDestruct (big_sepM_disjoint_pred with "[$Hpm] [$Hqm]") as %?; eauto. iDestruct (big_sepM_union with "[$Hpm $Hqm]") as "Hm"; eauto. iFrame. iIntros "!>" (h2) "Hm". rewrite big_sepM_union; eauto. iDestruct "Hm" as "[Hpm Hqm]". iDestruct ("Hpi" with "Hpm") as "Hp". iDestruct ("Hqi" with "Hqm") as "Hq". iFrame. Unshelve. all: eauto. Qed. Theorem liftable_or P Q : Liftable P ‚Üí Liftable Q ‚Üí Liftable (fun h => P h ‚à® Q h)%I. 
++ v = ¬ß0^m ++ w -> m <= n. Proof. elim: m n; first by lia. move=> m IH [|n]; first done. have H : forall k, ¬ß0^(S k) = [¬ß0] ++ ¬ß0^k by (move=> ?; rewrite ?app_norm). rewrite ?H -?app_assoc. move /app_inv_head /IH. by lia. Qed. Lemma zero_prefix_eq {n m v1 v2} : ¬ß0^n ++ [¬ß1] ++ v1 = ¬ß0^m ++ [¬ß1] ++ v2 -> n = m. Proof. move /copy => [/zero_prefix_lt + /esym /zero_prefix_lt]. by lia. Qed. Lemma contradict_G_prefix {v1 v2 n} : ¬ß0^G ++ v1 = ¬ß0^n ++ [¬ß1] ++ v2 -> n < G -> False. Proof. move=> /esym /zero_prefix_lt. by lia. Qed. Local Definition transition := SM.transition (State := State) (Symbol := Symbol). Theorem flip_consistent_M {s1 t1 X c b1 s2 t2 c2 b2} : In ((s1, t1, X), c, b1) M -> In ((s2, t2, X), c2, b2) M -> b1 = b2. Proof. move=> /state_flip + /state_flip. case: X; last by congruence. case; (case; by congruence). Qed. Ltac unify_iP := match goal with H1 : In (?i, (?j1, ?n1)) iP, H2 : In (?i, (?j2, ?n2)) iP |- _ => have [? ?]:= in_iP_unique H1 H2; subst; clear H1 H2 end. Ltac unify_igotos := match goal with | H1 : In (?i, (?n1, ?X1, ?Y1)) igotos, H2 : In (?i, (?n2, ?X2, ?Y2)) igotos |- _ => have [? [? ?]] := in_igotos_unique H1 H2; subst; clear H1 H2 | H1 : In (?i1, (?n, ?X, ?Y)) igotos, H2 : In (?i2, (?n, ?X, ?Y)) igotos |- _ => have ? := in_igotos_unique_index H1 H2; subst; clear H1 H2 end. Ltac unify_app := match goal with | H : ?l ++ ?l1 = ?l ++ ?l2 |- _ => move /app_inv_head in H; subst | H : ?a :: ?l1 = ?a :: ?l2 |- _ => (have ? : l1 = l2 by congruence); subst; clear H | H : ¬ß0^?n ++ (¬ß1 :: ?v1) = ¬ß0^?m ++ (¬ß1 :: ?v2) |- _ => have ? := zero_prefix_eq H; subst | H1 : ¬ß0^G ++ ?v1 = ¬ß0^?n ++ (¬ß1 :: ?v2), H2 : ?n < G |- _ => have ? := contradict_G_prefix H1 H2; clear H1 H2 | H1 : ¬ß0^?n ++ (¬ß1 :: ?v2) = ¬ß0^G ++ ?v1, H2 : ?n < G |- _ => have ? := contradict_G_prefix (esym H1) H2; clear H1 H2 end. Theorem deterministic_M : SM.deterministic M. 
H'2 H'3 H'4; rewrite H'3; rewrite H'4; auto. Qed. Theorem eqTerm_divTerm_comp : forall (a b c d : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c) (nZd : ~ zeroP (A:=A) A0 eqA (n:=n) d), eqTerm (A:=A) eqA (n:=n) a b -> eqTerm (A:=A) eqA (n:=n) c d -> eqTerm (A:=A) eqA (n:=n) (divTerm a nZc) (divTerm b nZd). intros a b c d; case a; case b; case c; case d; simpl in |- *; auto. intros A0' c0 d2 c2 d3 c3 d4 c4 nZd2 H'0 H'1 H'2. case H'2; intros H'3 H'4; clear H'2. case H'1; intros H'2 H'5; clear H'1. split; auto. rewrite H'5; rewrite H'4; auto. Qed. Hint Resolve eqTerm_divTerm_comp. Theorem divTerm_multTerm_l : forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) -> eqTerm (A:=A) eqA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) c b) nZa) (multTerm (A:=A) multA (n:=n) c (divTerm b nZa)). intros a b c; case a; case b; case c; simpl in |- *; auto. intros d c0 A0' c2 d2 c3 nZd2 H'0; case H'0; intros H'1 H'2; auto. split; auto. apply divA_multA_comp_l with (1 := cs). rewrite H'2. repeat rewrite mult_div_com. rewrite mult_mon_assoc. repeat rewrite mult_div_com; auto. Qed. Theorem divTerm_multTerm_r : forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) -> eqTerm (A:=A) eqA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) b c) nZa) (multTerm (A:=A) multA (n:=n) (divTerm b nZa) c). intros a b c; case a; case b; case c; simpl in |- *; auto. intros a0 m a1 m0 a2 m1 nZa H'; split; auto. apply divA_multA_comp_r with (1 := cs). elim H'; intros H'0 H'1; rewrite H'1; clear H'. rewrite mult_div_com; auto. rewrite <- mult_mon_assoc. rewrite (mult_mon_com n m1 m). rewrite mult_mon_assoc. rewrite mult_div_com; auto. Qed. Hint Resolve divTerm_multTerm_l divTerm_multTerm_r. Theorem div_is_T1 : forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) (divTerm a nZa) (T1 A1 n). intros a; case a; simpl in |- *; auto. intros a0 m nZa; split; auto. apply divA_A1 with (1 := cs). unfold M1 in |- *; apply mult_div_id; auto. Qed. Hint Resolve div_is_T1. Theorem divTerm_nZ : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, ~ zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). 
Require Export ZArith. Require Export Znumtheory. Require Export Zpow_facts. Lemma mod_sub_ish : forall a b m : Z, a mod m = b mod m -> (a - b) mod m = 0. Proof. intros. Admitted. Theorem theorem_54 : forall k m d : Z, Zis_gcd k m d -> forall a a' : Z, k*a mod m = k*a' mod m -> a mod (m/d) = a' mod (m/d). 
Hsem. rewrite Hsem. rewrite andb_true_iff. intuition. Qed. Lemma partition_1 : forall (s : t) (f : elt -> bool), compat_bool E.eq f -> Equal (fst (partition f s)) (filter f s). Proof. intros [s?] f HProper. apply compat_bool_Eeq_op_zeze in HProper. unfold Equal, In, filter, partition, fst, proj1_sig. eapply filter_Desc; try eassumption. intros s' HB _ Hsem. eapply partition_spec; try eassumption. intros s1 s2 [HD1 HD2]. eapply HD1; intros s1' HBs1' _ Hsems1'. intro. rewrite Hsem, Hsems1'. reflexivity. Qed. Lemma compat_bool_negb: forall A R (f : A -> bool), compat_bool R f -> compat_bool R (fun x => negb (f x)). Proof. intros. intros x y HR. f_equal. apply H. assumption. Qed. Lemma partition_2 : forall (s : t) (f : elt -> bool), compat_bool E.eq f -> Equal (snd (partition f s)) (filter (fun x : elt => negb (f x)) s). Proof. intros [s?] f HProper. apply compat_bool_Eeq_op_zeze in HProper. pose proof (compat_bool_negb _ _ _ HProper). unfold Equal, In, filter, partition, snd, proj1_sig. eapply filter_Desc; try eassumption. intros s' HB _ Hsem. eapply partition_spec; try eassumption. intros s1 s2 [HD1 HD2]. eapply HD2; intros s2' HBs2' _ Hsems2'. intro. rewrite Hsem, Hsems2'. reflexivity. Qed. Lemma elements_1 : forall (s : t) (x : elt), In x s -> InA E.eq x (elements s). Proof. intros [s?] x H. unfold In, elements, proj1_sig in *. rewrite InA_Eeq_elem in *. erewrite toList_sem in H by eassumption. assumption. Qed. Lemma elements_2 : forall (s : t) (x : elt), InA E.eq x (elements s) -> In x s. Proof. intros [s?] x H. unfold In, elements, proj1_sig in *. rewrite InA_Eeq_elem in *. erewrite toList_sem in * by eassumption. assumption. Qed. Lemma elements_3 (s : t) : Sorted E.lt (elements s). Proof. destruct s as [s WFs]; unfold elements; simpl. eapply StronglySorted_Sorted, StronglySorted_R_ext. - apply E_lt_zl. - eapply to_List_sorted; eassumption. Qed. Lemma elements_3w (s : t) : NoDupA E.eq (elements s). Proof. apply OrdFacts.Sort_NoDup, elements_3. Qed. Definition compare (s s' : t) : Compare lt eq s s'. Proof. destruct (compare s s') eqn:CMP. - apply EQ. abstract now apply equal_2; destruct s, s'; generalize dependent CMP; rewrite Ord_compare_Eq; unfold "==", Eq_Set_WF; simpl. - apply LT; abstract order t. - apply GT; abstract order t. Defined. Theorem lt_trans (s1 s2 s3 : t) : lt s1 s2 -> lt s2 s3 -> lt s1 s3. Proof. unfold lt; order t. Qed. Theorem lt_not_eq (s1 s2 : t) : lt s1 s2 -> ~ eq s1 s2. 
list bool), In (a1, lb1) l -> In (a2, lb2) l -> is_prefix lb1 lb2 -> a1 = a2) /\ unique_key l. Theorem unique_prefix_nil : unique_prefix nil. Proof using. split; auto. intros a1 a2 lb1 lb2 H; inversion H; auto. Qed. Hint Resolve unique_prefix_nil : core. Theorem unique_prefix1 : forall (c : code) (a1 a2 : A) (lb1 lb2 : list bool), unique_prefix c -> In (a1, lb1) c -> In (a2, lb2) c -> is_prefix lb1 lb2 -> a1 = a2. Proof using. intros c a1 a2 lb1 lb2 (H1, H2); apply (H1 a1 a2 lb1 lb2); auto. Qed. Theorem unique_prefix2 : forall c : code, unique_prefix c -> unique_key c. Proof using. intros c (H1, H2); auto. Qed. Theorem unique_prefix_inv : forall (c : code) (a : A) (l : list bool), unique_prefix ((a, l) :: c) -> unique_prefix c. Proof using. intros c a l (H1, H2); split. intros a1 a2 lb1 lb2 H H0 H3; apply (H1 a1 a2 lb1 lb2); simpl in |- *; auto. apply unique_key_inv with (1 := H2); auto. Qed. Theorem unique_prefix_not_null : forall (c : code) (a b : A), a <> b -> in_alphabet (a :: b :: nil) c -> unique_prefix c -> not_null c. Proof using. intros c a b H H0 H1. unfold not_null in |- *; intros a1; red in |- *; intros Ha1. case (H0 a); simpl in |- *; auto; intros l1 Hl1. case (H0 b); simpl in |- *; auto; intros l2 Hl2. case H; apply trans_equal with a1. apply sym_equal; apply unique_prefix1 with (3 := Hl1) (2 := Ha1); auto. apply unique_prefix1 with (3 := Hl2) (2 := Ha1); auto. Qed. Theorem unique_prefix_permutation : forall c1 c2 : code, permutation c1 c2 -> unique_prefix c1 -> unique_prefix c2. Proof using. intros c1 c2 H (H1, H2). cut (permutation c2 c1); [ intros HP; split | apply permutation_sym; auto ]. intros a1 a2 lb1 lb2 H0 H3 H4. apply (H1 a1 a2 lb1 lb2); auto. apply permutation_in with (2 := H0); auto. apply permutation_in with (2 := H3); auto. apply unique_key_perm with (2 := H2); auto. Qed. Fixpoint find_code (a : A) (l : code) {struct l} : list bool := match l with | nil => nil | (b, c) :: l1 => match eqA_dec a b with | left _ => c | right _ => find_code a l1 end end. Theorem find_code_correct1 : forall (c : code) (a : A) (b : bool) (l : list bool), find_code a c = b :: l -> In (a, b :: l) c. 
auto). Qed. Theorem rename_all_ns_fundefs_append: forall sig B2 B1, rename_all_fun_ns sig (fundefs_append B1 B2) = fundefs_append (rename_all_fun_ns sig B1) (rename_all_fun_ns sig B2). Proof. induction B1; simpl; auto. rewrite IHB1. auto. Qed. Theorem all_fun_name_append: forall B2 B1, all_fun_name (fundefs_append B1 B2) = all_fun_name B1 ++ all_fun_name B2. Proof. induction B1; auto. simpl. rewrite IHB1. auto. Qed. Ltac normalize_ctx := match goal with | [H: context[rename_all_ns _ (_ |[ _ ]|)] |- _] => rewrite (proj1 (rename_all_ns_app_ctx _ _)) in H | [H: context[rename_all_fun_ns _ (_ <[ _ ]>)] |- _] => rewrite (proj2 (rename_all_ns_app_ctx _ _)) in H | [|- context[rename_all_ns _ (_ |[ _ ]|)]] => rewrite (proj1 (rename_all_ns_app_ctx _ _)) | [|- context[rename_all_fun_ns _ (_ <[ _ ]>)]] => rewrite (proj2 (rename_all_ns_app_ctx _ _)) | [H: context[rename_all_fun_ns _ (fundefs_append _ _)] |- _] => rewrite rename_all_ns_fundefs_append in H | [|- context[rename_all_fun_ns _ (fundefs_append _ _)]] => rewrite rename_all_ns_fundefs_append | [H: context[rename_all_ctx_ns _ (comp_ctx_f _ _)] |- _] => rewrite (proj1 (rename_all_ctx_ns_comp_ctx _ _)) in H | [|- context[rename_all_ctx_ns _ (comp_ctx_f _ _)]] => rewrite (proj1 (rename_all_ctx_ns_comp_ctx _ _)) | [H: context[rename_all_fun_ctx_ns _ (comp_f_ctx_f _ _)] |- _] => rewrite (proj2 (rename_all_ctx_ns_comp_ctx _ _)) in H | [|- context[rename_all_fun_ctx_ns _ (comp_f_ctx_f _ _)]] => rewrite (proj2 (rename_all_ctx_ns_comp_ctx _ _)) | [H: context[ inlined_ctx_f (comp_ctx_f _ _ ) _ ] |- _] => rewrite (proj1 (inlined_comp_ctx)) in H | [|-context[ inlined_ctx_f (comp_ctx_f _ _) _]] => rewrite (proj1 (inlined_comp_ctx)) | [H: context[ inlined_fundefs_ctx_f (comp_f_ctx_f _ _) _] |- _] => rewrite (proj2 (inlined_comp_ctx)) in H | [|-context[ inlined_fundefs_ctx_f (comp_f_ctx_f _ _) _]] => rewrite (proj2 (inlined_comp_ctx)) | [H: context[ inlined_fundefs_f (fundefs_append _ _) _] |- _] => rewrite inlined_fundefs_append in H | [|-context[ inlined_fundefs_f (fundefs_append _ _) _]] => rewrite inlined_fundefs_append end. Definition closed_fundefs := fun f => Empty_set var <--> occurs_free_fundefs f. Corollary closed_app_ctx: forall e c, closed_exp (c |[ e ]|) -> closed_ctx c. Proof. intros. assert (Hc := occurs_free_included_ctx e c). apply Included_Empty_set_l. unfold closed_exp in H. rewrite H in Hc; eauto. Qed. Theorem not_free_dead_or_bound e: (Complement _ (occurs_free e)) \subset ((dead_var e) :|: (bound_var e)). Proof. intros. intro. intro. apply not_free_bound_or_not_occur in H. destruct H; auto. Qed. Theorem not_bound_dead_or_free e : (Complement _ (bound_var e)) \subset ((dead_var e) :|: (occurs_free e)). Proof. intros. intro; intro. assert (He := Decidable_occurs_free e). inv He. specialize (Dec x). inv Dec; auto. apply not_free_dead_or_bound in H0. inv H0; auto. exfalso. auto. Qed. Theorem name_in_bound_var_fundefs_ctx cf : names_in_fundefs_ctx cf \subset bound_var_fundefs_ctx cf. 
a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). induction arr; intuition; simpl in *. discriminate. remember (split arr) as z. destruct z. simpl. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H0. intuition. rewrite H0 in H. right. eapply IHarr; intuition. eauto. Qed. Theorem arrayLookup_noCollision_eq_f : forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c, arrayLookup_f _ x1 b = Some c -> collidesWith _ _ (fst (split x1)) a b = false -> arrayLookup _ x1 (a, b) = Some c. induction x1; intuition; simpl in *. remember (split x1) as z. destruct z. simpl in *. unfold collidesWith in *. simpl in *. case_eq (eqb b2 b1); intuition. rewrite H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem randomFunc_mem_preserves_coll : forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (randomFunc_mem _ _ RndR c0 d)) -> funcCollision _ _ (fst (split b0)) = true. 
- norm. cancel. eassign (repeat (@emp _ addr_eq_dec bool) NIndirect). rewrite listmatch_emp_piff. cancel. rewrite combine_repeat. repeat rewrite repeat_length. reflexivity. rewrite combine_repeat. intros x y; intros. erewrite repeat_spec with (y := x) by eauto. erewrite repeat_spec with (y := y) by eauto. cbn. repeat match goal with H: In _ _ |- _ => eapply repeat_spec in H end. subst. eassign (@natToWord addrlen 0). rewrite IHindlvl. split; cancel. autorewrite with lists. rewrite pred_fold_left_repeat_emp. intuition eauto. split; cancel. erewrite concat_hom_repeat. 2: eapply Forall_repeat; reflexivity. autorewrite with lists; eauto. Qed. Lemma listmatch_indrep_n_tree_empty': forall indlvl n bxp, listmatch (fun x y => indrep_n_tree indlvl bxp (snd x) # (fst x) y) (combine (repeat (@natToWord addrlen 0) n) (repeat emp n)) (repeat (repeat $0 (NIndirect ^ (S indlvl))) n) <=p=> emp. Proof. intros. rewrite listmatch_emp_piff. autorewrite with lists; auto. split; cancel. intros. rewrite combine_repeat in *. eapply repeat_spec in H. eapply repeat_spec in H0. subst. rewrite indrep_n_tree_0. split; cancel. Qed. Lemma listmatch_indrep_n_tree_empty'': forall indlvl n fsl l bxp, length fsl = n -> listmatch (fun x y => indrep_n_tree indlvl bxp (snd x) # (fst x) y) (combine (repeat (@natToWord addrlen 0) n) fsl) l =p=> [[ pred_fold_left fsl <=p=> emp ]] * [[ l = (repeat (repeat $0 (NIndirect ^ (S indlvl))) n) ]]. Proof. cbn -[Nat.div]; intros. rewrite listmatch_lift_l with (P := fun x => snd x <=p=> emp). erewrite listmatch_lift_r with (P := fun x => x = repeat $0 (NIndirect ^ (S indlvl))). rewrite listmatch_emp_piff. autorewrite with lists. rewrite Nat.min_l by omega. do 2 intro; destruct_lifts. - repeat eapply sep_star_lift_apply'; unfold lift_empty; intuition. rewrite Forall_combine_r in H1. rewrite pred_fold_left_Forall_emp; eauto. autorewrite with lists; eauto. reflexivity. eapply list_selN_ext. autorewrite with lists; auto. intros. rewrite Forall_forall in *. rewrite H2 with (x := selN l pos nil). rewrite repeat_selN; auto; omega. eapply in_selN; auto. - instantiate (1 := fun x y => emp). auto. - instantiate (1 := fun x y => ([[ y = repeat $0 (NIndirect ^ (S indlvl)) ]])%pred). split; cancel. - intros. erewrite in_combine_repeat_l in * by eauto. rewrite indrep_n_tree_0. split; cancel. Qed. Lemma listmatch_indrep_n_tree_empty: forall indlvl bxp, let iblocks := (repeat $0 NIndirect) in indrep_n_helper emp bxp 0 iblocks * listmatch (fun x y => indrep_n_tree indlvl bxp (snd x) # (fst x) y) (combine iblocks (repeat emp NIndirect)) (repeat (repeat $0 (NIndirect ^ (S indlvl))) NIndirect) <=p=> emp. Proof. cbn -[Nat.div]; intros. rewrite listmatch_indrep_n_tree_empty'. split; cancel. Qed. Theorem indrep_n_helper_bxp_switch : forall Fs bxp bxp' ir iblocks, BmapNBlocks bxp = BmapNBlocks bxp' -> indrep_n_helper Fs bxp ir iblocks <=p=> indrep_n_helper Fs bxp' ir iblocks. 
(S P C A / S P A B = S P A C / S P B A)... congruence... Qed. Hint Resolve A6_4: Geom.Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B. Proof with Geometry. intros... assert (P ** A / O ** A = S P B A / S O B A)... assert (S P A B = - S P B A)... assert (S O A B = - S O B A)... rewrite H3... rewrite H4... rewrite H2... assert (S O B A <> 0)... field... Qed.Hint Resolve A6_5: Geom.Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B. Proof with Geometry. intros... assert (S R A B / S Q A B = S R B A / S Q B A)... rewrite H2... Qed.Hint Resolve A6_6: Geom.Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B. Proof with try solve [ Geometry | congruence | field; Geometry ]. intros... cases_equality C A... assert (Col A B D)... rewrite H4... symmetry in |- *... assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))... assert (A <> C)... assert (Col C D A)... eauto with Geom... assert (C ** D / C ** A = S P C D / S P C A)... assert (A ** C / A ** B = S P A C / S P A B)... assert (C ** A / A ** B = S P C A / S P A B)... assert (C ** D / C ** A * (C ** A / A ** B) = C ** D / A ** B)... Qed. Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q. 
find_rewrite. in_crush. + simpl. auto. Qed. Lemma handleRequestVoteReply_log : forall h st src t vg st', handleRequestVoteReply h st src t vg = st' -> log st' = log st. Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; subst; auto. Qed. Theorem logs_sorted_request_vote_reply : raft_net_invariant_request_vote_reply logs_sorted. Proof using. unfold raft_net_invariant_request_vote_reply. unfold logs_sorted. intuition; simpl in *. - unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp handleRequestVoteReply_log. repeat find_higher_order_rewrite. break_match; try find_rewrite; eauto. - eauto using logs_sorted_nw_packets_unchanged. - eauto using packets_gt_prevIndex_packets_unchanged. - eauto using packets_ge_prevTerm_packets_unchanged. Qed. Lemma doLeader_log : forall h st os st' ps, doLeader st h = (os, st', ps) -> log st' = log st. Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; subst; auto. Qed. Lemma doLeader_messages : forall h st os st' ms m t n pli plt entries c, doLeader st h = (os, st', ms) -> sorted (log st) -> In m ms -> snd m = AppendEntries t n pli plt entries c -> subseq entries (log st) /\ (forall e, In e entries -> eIndex e > pli) /\ (forall e, In e entries -> eTerm e >= plt). Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; subst; simpl in *; intuition. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. apply subseq_findGtIndex. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. find_apply_lem_hyp findGtIndex_necessary; intuition. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. break_match; intuition. find_apply_lem_hyp findGtIndex_necessary; intuition. find_apply_lem_hyp findAtIndex_elim. simpl in *. intuition. repeat find_rewrite. eapply sorted_index_term; eauto. lia. Qed. Theorem logs_sorted_do_leader : raft_net_invariant_do_leader logs_sorted. Proof using. unfold raft_net_invariant_do_leader. unfold logs_sorted. intuition; simpl in *. - unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp doLeader_log. repeat find_higher_order_rewrite. break_match; subst; try find_rewrite; eauto. - unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; intuition; eauto using sorted_subseq. - unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; [idtac|idtac|idtac|eauto]; intuition eauto. - unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; [idtac|idtac|idtac|eauto]; intuition eauto. Qed. Lemma doGenericServer_packets : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> ps = []. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; subst; auto. Qed. Theorem logs_sorted_do_generic_server : raft_net_invariant_do_generic_server logs_sorted. 
Require Import Coq.omega.Omega. Require Import Bedrock.Platform.AutoSep.Require Import Bedrock.Platform.Malloc Bedrock.Platform.Cito.examples.Seq.Module Type ADT. Parameter arr : list W -> W -> HProp. Axiom arr_fwd : forall ws self, arr ws self ===> [| self <> 0 |] * [| freeable self (2 + length ws) |] * [| goodSize (2 + length ws) |] * (Ex junk, self ==*> $ (length ws), junk) * array ws (self ^+ $8). Axiom arr_bwd : forall ws (self : W), [| self <> 0 |] * [| freeable self (2 + length ws) |] * [| goodSize (2 + length ws) |] * (Ex junk, self ==*> $ (length ws), junk) * array ws (self ^+ $8) ===> arr ws self. End ADT.Module Adt : ADT. Open Scope Sep_scope. Definition arr (ws : list W) (self : W) : HProp := [| self <> 0 |] * [| freeable self (2 + length ws) |] * [| goodSize (2 + length ws) |] * (Ex junk, self ==*> $ (length ws), junk) * array ws (self ^+ $8). Theorem arr_fwd : forall ws self, arr ws self ===> [| self <> 0 |] * [| freeable self (2 + length ws) |] * [| goodSize (2 + length ws) |] * (Ex junk, self ==*> $ (length ws), junk) * array ws (self ^+ $8). 
length items), exists meet, meet = safe_lookup steps Hlength /\ items = (take n items) ++ [use meet] ++ (drop (S n) items). Theorem Steps_split program first steps last: Steps program first steps last -> forall n (Hlength: n < length steps), exists meet, meet = safe_lookup steps Hlength /\ Steps program first (take n steps) (use meet) /\ Steps program (use meet) (drop (S n) steps) last. Proof. intros. Qed. Definition execute_eternal (program: list Instruction) (well_formed: WellFormed program) (start: MachineState) : forall previous cur, Within program cur -> . refine (cofix execute_eternal previous cur _ _ := let (instr, _) := (get_instr cur program) in if (is_stopping instr) then (previous ++ cur) else let (next, _) := (@execute_instruction instr cur _) in execute_eternal next _ ) Defined. Theorem Steps_deterministic: forall program start between1 last1 between2 last2, Steps program start between1 last1 -> Steps program start between2 last2 -> length between1 = length between2 -> last1 = last2 /\ between1 = between2. Proof. Qed. Definition stateprop := MachineState -> Prop. Definition triple (block: list Instruction) (H Q: stateprop) := forall prefix postfix first last between, H first -> Steps (prefix ++ block ++ postfix) first between last -> Q last. Definition triple (block: list Instruction) (H Q: stateprop) := forall prefix postfix first, H first -> Within program first -> exists between last, Steps (prefix ++ block ++ postfix) first between last /\ Q last. Definition exiting_triple (block: list Instruction). Definition execute_program_unsafe (program: list Instruction) : nat -> MachineState -> option MachineState . refine (fix go Steps cur := match (cur_instr cur program) with | None => None | Some instr => if (is_stopping instr) then Some cur else match Steps with | 0 => None | S Steps' => let (next, _) := (@execute_instruction instr cur _) in go Steps' next end end ); assumption. Defined. Notation WellFormed program := (forall cur next, Step program cur next -> Within program next) (only parsing). Notation InstWellFormed len_program := (fun index instr => forall program cur next, len_program <= (length program) -> lookup (index%nat) program = Some instr -> cur.(counter) = (index%nat) -> Step program cur next -> Within program next ) (only parsing). Theorem Step_implies_instr program cur next: Step program cur next -> exists instr, (cur_instr cur program) = Some instr. Proof. intros []; eauto. Qed. Notation IndexPairsWellFormed program := (fun index_instr => InstWellFormed (length program) index_instr.1 index_instr.2) (only parsing). Theorem index_pairs_InstWellFormed_implies_WellFormed program: Forall (IndexPairsWellFormed program) (imap pair program) -> WellFormed program. 
set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. 
iIntros "!>" (alloc_ref) "Halloc_mem". iNamed 1. wpc_pures. wpc_frame. rewrite -wp_fupd. wp_apply wp_allocStruct. { auto. } iIntros (l) "Hstruct". iDestruct (struct_fields_split with "Hstruct") as "(i&alloc&_)". iMod (readonly_alloc_1 with "i") as "#i". iMod (readonly_alloc_1 with "alloc") as "#alloc". iMod (ghost_var_alloc (nil : list Block)) as (Œ¥buf) "[HŒ¥buf Hownbuf]". iMod (fmlist_alloc (œÉ0.(s_inode.durable_blocks))) as (Œ≥buf') "(HŒ≥buf1&HŒ≥buf2)". iMod (fmlist_get_lb with "HŒ≥buf1") as "(HŒ≥buf1&Hbuf_lb)". iModIntro. iNamed 1. iApply "HŒ¶". iExists Œ≥buf'. iFrame "HŒ≥buf1". iNamed "HP". iFrame "Hfm_all_blocks". iDestruct "Hdurable_lb" as "($&_)". iFrame "Hbuf_lb". iExists inode_ref, alloc_ref, _, _, _. rewrite /s_inode_inv. iFrame "HŒ¥durable_blocks". iSplitR. { iFrame "#". } iSplitL "HŒ¥buf". { iApply "HŒ¥buf". } iSplitL "Hpre_inode HPinode Hownbuf". { iExists _; iFrame. rewrite /Pinode. iNamed "HPinode". iFrame "Hownbuf". iFrame. } iSplitR "Hfm_dur_blocks HŒ≥buf2". { iExists _. iFrame "‚àó %". } iFrame. simpl. rewrite app_nil_r. iFrame. Qed. Lemma is_allocator_pre_post_crash alloc_ref s_alloc : is_allocator_mem_pre alloc_ref s_alloc -‚àó ‚åúalloc_post_crash s_alloc‚åù. Proof. iNamed 1. iFrame "%". Qed. Theorem pre_s_inode_to_cinv Œ≥dur Œ≥buf l sz œÉ : pre_s_inode Œ≥dur Œ≥buf l sz œÉ -‚àó s_inode_cinv Œ≥dur Œ≥buf sz œÉ true. Proof. iNamed 1. iExists _, _; iFrame. iNamed "Hinode". iNamed "Halloc". iDestruct (is_allocator_pre_post_crash with "Halloc_mem") as %Hpost_crash. iSplitL "Hpre_inode HPinode". { iExists _; iFrame. iSplitL "Hpre_inode". { iNamed "Hpre_inode". iApply inode_linv_to_cinv; auto. } iNamed "HPinode". iFrame. } iFrame "‚àó %". iSplitL "Halloc_mem HPalloc Hunused". { iExists _. iFrame "‚àó %". } iNamed "Hs_inv". iFrame. Qed. Theorem is_single_inode_alloc k Œ≥dur Œ≥buf l (sz: Z) œÉ : (1 ‚â§ sz < 2^64)%Z ‚Üí pre_s_inode Œ≥dur Œ≥buf l sz œÉ ={‚ä§}=‚àó is_single_inode Œ≥dur Œ≥buf l sz k ‚àó <disc> |C={‚ä§}=> ‚àÉ œÉ', s_inode_cinv Œ≥dur Œ≥buf sz œÉ' false. Proof. iIntros (?); iNamed 1. iNamed "Hinode". iNamed "Halloc". iMod (is_allocator_alloc _ _ _ k with "Hunused HPalloc Halloc_mem") as (Œ≥alloc) "[Halloc Halloc_crash]". iMod (is_inode_alloc inodeN (k:=k) with "HPinode Hpre_inode") as "[Hinode Hinode_crash]". iMod (ncinv_alloc s_inodeN _ (‚àÉ œÉ, s_inode_inv Œ¥dur Œ¥buf œÉ ‚àó P Œ≥dur Œ≥buf œÉ)%I with "[Hs_inv HP]") as "(#Hinv&Hinv_crash)". { iNext. iExists _; iFrame. } rewrite Halloc_dom. iModIntro. iSplitL "Halloc Hinode". { iExists _, _, _, _, _, _. iFrame "Hinode". iFrame "Halloc". iFrame "# ‚àó". } iModIntro. iMod "Halloc_crash" as "Halloc". iMod "Hinode_crash" as "Hinode". iMod (cfupd_weaken_mask with "Hinv_crash") as "Hs_inode"; first lia. { solve_ndisj. } iModIntro. iNext. iDestruct "Hs_inode" as (œÉ') "[Hs_inv HP]". iExists _; iFrame. iExists _, _; iFrame. iSplitL "Hinode". { iDestruct "Hinode" as (?) "(?&H)". iExists _. iFrame. iNamed "H". iFrame. } { iNamed "Hs_inv". iFrame. } Qed. Theorem wpc_SingleInode__Read {k} (Q: option Block ‚Üí iProp Œ£) Œ≥dur Œ≥buf l sz k' (i: u64) : (S k < k')%nat ‚Üí {{{ "#Hinode" ‚à∑ is_single_inode Œ≥dur Œ≥buf l sz k' ‚àó "Hfupd" ‚à∑ ‚àÄ blks, inode_mapsto Œ≥buf blks ={‚ä§ ‚àñ ‚ÜëN}=‚àó inode_mapsto Œ≥buf blks ‚àó Q (blks !! int.nat i) }}} SingleInode__Read #l #i @ (S k); ‚ä§ {{{ (s:Slice.t) mb, RET (slice_val s); match mb with | None => ‚åús = Slice.nil‚åù | Some b => (‚àÉ q, is_block s q b) end ‚àó Q mb }}} {{{ True }}}. 
Require Import Verdi.GhostSimulations.Require Import VerdiRaft.CommonTheorems. Require Import VerdiRaft.Raft. Require Import VerdiRaft.SortedInterface. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.StateMachineSafetyPrimeInterface. Require Import VerdiRaft.LeaderCompletenessInterface. Require Import VerdiRaft.LeaderLogsContiguousInterface. Require Import VerdiRaft.AllEntriesLeaderLogsInterface. Require Import VerdiRaft.LogMatchingInterface. Require Import VerdiRaft.UniqueIndicesInterface. Require Import VerdiRaft.AppendEntriesRequestLeaderLogsInterface. Require Import VerdiRaft.LeaderLogsSortedInterface. Require Import VerdiRaft.LeaderLogsLogMatchingInterface. Require Import VerdiRaft.LogsLeaderLogsInterface. Require Import VerdiRaft.OneLeaderLogPerTermInterface. Require Import VerdiRaft.RefinedLogMatchingLemmasInterface.Local Arguments update {_} {_} {_} _ _ _ _ : simpl never.Section StateMachineSafety'. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lci : leader_completeness_interface}. Context {aelli : all_entries_leader_logs_interface}. Context {lmi : log_matching_interface}. Context {uii : unique_indices_interface}. Context {aerlli : append_entries_leaderLogs_interface}. Context {llsi : leaderLogs_sorted_interface}. Context {lsi : sorted_interface}. Context {llci : leaderLogs_contiguous_interface}. Context {lllmi : leaderLogs_entries_match_interface}. Context {llli : logs_leaderLogs_interface}. Context {ollpti : one_leaderLog_per_term_interface}. Context {rlmli : refined_log_matching_lemmas_interface}. Theorem lift_log_matching : forall net, refined_raft_intermediate_reachable net -> log_matching (deghost net). Proof using lmi rri. intros. eapply lift_prop; eauto using log_matching_invariant. Qed. Theorem lift_sorted : forall net, refined_raft_intermediate_reachable net -> logs_sorted (deghost net). Proof using lsi rri. intros. eapply lift_prop; eauto using logs_sorted_invariant. Qed. Theorem lift_entries_match : forall net h h', refined_raft_intermediate_reachable net -> entries_match (log (snd (nwState net h))) (log (snd (nwState net h'))). Proof using lmi rri. intros. find_apply_lem_hyp lift_log_matching. unfold log_matching, log_matching_hosts in *. intuition. unfold deghost in *. simpl in *. repeat break_match; eauto. Qed. Theorem lift_UniqueIndices : forall net, refined_raft_intermediate_reachable net -> UniqueIndices (deghost net). Proof using uii rri. intros. eapply lift_prop; eauto using UniqueIndices_invariant. Qed. Theorem lift_uniqueIndices_log : forall net h, refined_raft_intermediate_reachable net -> uniqueIndices (log (snd (nwState net h))). Proof using uii rri. intros. find_apply_lem_hyp lift_UniqueIndices. unfold UniqueIndices, uniqueIndices_host_invariant in *. intuition. unfold deghost in *. simpl in *. break_match; eauto. Qed. Theorem lift_logs_sorted : forall net h, refined_raft_intermediate_reachable net -> sorted (log (snd (nwState net h))). 
x <-$ { 0 , 1 }^eta; ret (x, (a, x) :: ls)).Variable lsx : list (D * Bvector eta). Check ((PRF_DRBG_f_G2 v_init O) _ _ (fun (ls : list (D * Bvector eta)) (a : D) => x <-$ { 0 , 1 }^eta; ret (x, (a, x) :: ls)) nil). induction n; intuition; simpl in *. fcf_simp. fcf_spec_ret. simpl. rewrite app_nil_r. apply Permutation_refl. fcf_inline_first. fcf_skip. fcf_skip. fcf_spec_ret. simpl in H3. simpl. destruct (split ls). simpl in H3. simpl. eapply Permutation_trans. apply H3. apply Permutation_cons_app. apply Permutation_refl. Qed. Check PRF_A _ _ (fun ls a => x <-$ {0, 1}^eta; ret (x, (a, x)::ls)) nil. Fixpoint PRF_DRBG_f_bad (v : D)(n : nat) : Comp (list D) := match n with | O => ret nil | S n' => r <-$ {0,1}^eta; ls' <-$ (PRF_DRBG_f_bad (injD r) n'); ret (v :: ls') end.Check PRF_DRBG_f_bad. Definition PRF_DRBG_G3_bad_1 := ls <-$ PRF_DRBG_f_bad v_init l; ret (hasDups _ ls). *) Theorem PRF_DRBG_G3_bad_equiv : Pr[x <-$ PRF_DRBG_G3_3; ret (snd x)] == Pr[PRF_DRBG_G3_bad_1]. Proof. unfold PRF_DRBG_G3_3, PRF_DRBG_G3_bad_1. simpl. fcf_inline_first. fcf_to_prhl_eq. fcf_skip. * apply PRF_DRBG_f_bad_spec. * simpl in H1. fcf_inline_first. fcf_irr_l. fcf_simp. simpl. fcf_spec_ret. apply Permutation_hasDups. assumption. Qed. Fixpoint PRF_DRBG_f_bad_2 (n : nat) := match n with | O => ret nil | S n' => r <-$ {0,1}^eta; ls' <-$ (PRF_DRBG_f_bad_2 n'); ret (r :: ls') end.Check PRF_DRBG_f_bad_2. Definition PRF_DRBG_G3_bad_2 := ls <-$ PRF_DRBG_f_bad_2 (pred l); ret (hasDups _ (v_init :: (map injD ls))). Theorem PRF_DRBG_f_bad_2_equiv : forall n v, comp_spec (fun x1 x2 => x1 = v :: (map injD x2)) (PRF_DRBG_f_bad v (S n)) (PRF_DRBG_f_bad_2 n). induction n; intuition; simpl in *. fcf_irr_l. fcf_simp. fcf_spec_ret. fcf_skip. fcf_skip. fcf_spec_ret. Qed. Theorem PRF_DRBG_G3_bad_1_2_equiv : Pr[PRF_DRBG_G3_bad_1] == Pr[PRF_DRBG_G3_bad_2]. unfold PRF_DRBG_G3_bad_1, PRF_DRBG_G3_bad_2. fcf_to_prhl_eq. destruct l; simpl; intuition. fcf_simp. simpl. fcf_reflexivity. fcf_skip. apply PRF_DRBG_f_bad_2_equiv. simpl in H1. subst. fcf_spec_ret. Qed. Definition PRF_DRBG_G3_bad_3 := ls <-$ compMap _ (fun _ => {0, 1}^eta) (forNats (pred l)); ret (hasDups _ (v_init :: (map injD ls))). Theorem PRF_DRBG_f_bad_2_compMap_equiv : forall n, comp_spec eq (PRF_DRBG_f_bad_2 n) (compMap (Bvector_EqDec eta) (fun _ : nat => { 0 , 1 }^eta) (forNats n)). induction n; intuition; simpl in *. fcf_reflexivity. fcf_skip. fcf_skip. apply IHn. subst. fcf_reflexivity. Qed. Theorem PRF_DRBG_G3_bad_2_3_equiv : Pr[PRF_DRBG_G3_bad_2] == Pr[PRF_DRBG_G3_bad_3]. unfold PRF_DRBG_G3_bad_2, PRF_DRBG_G3_bad_3. fcf_to_prhl_eq. pose proof PRF_DRBG_f_bad_2_compMap_equiv. fcf_skip. Qed. Definition PRF_DRBG_G3_bad_4 := ls <-$ compMap _ (fun _ => {0, 1}^eta) (forNats (pred l)); ret (hasDups _ (r_init :: ls)). Theorem PRF_DRBG_G3_bad_3_4_equiv : Pr[PRF_DRBG_G3_bad_3] == Pr[PRF_DRBG_G3_bad_4]. 
C = S A D C). assert (S A D C + S C D C = S B D C + S D D C). apply l2_11a... basic_simpl...assert (S4 D B C P = S D B C + S D C P)... assert (S4 D B C P = S P D C - S A D C). rewrite H1. uniformize_signed_areas. rewrite H0. ring.assert (S P A B = S P D B - S P C B). assert (S A B P + S C B P = S D B P + S B B P). apply l2_11a... basic_simpl. uniformize_signed_areas. rewrite <- H3. ring.rewrite H3.assert (S4 D B C P = S D B P - S C B P)... uniformize_signed_areas. congruence. Qed.Theorem l2_12a_strong_3 : forall A B C D P : Point, weak_3_parallelogram A B C D -> S P A B = S P D C - S A D C. Proof with Geometry. intros. assert (S B D C = S A D C). assert (S A D C + S C D C = S B D C + S D D C). apply l2_11a_strong_strong_strong... basic_simpl...assert (S4 D B C P = S D B C + S D C P)... assert (S4 D B C P = S P D C - S A D C). rewrite H1. uniformize_signed_areas. rewrite H0. ring.assert (S P A B = S P D B - S P C B). assert (S A B P + S C B P = S D B P + S B B P). apply l2_11a_strong_strong_strong... unfold weak_3_parallelogram in *. DecompExAnd H Z. exists Z;split... basic_simpl. uniformize_signed_areas. rewrite <- H3. ring.rewrite H3.assert (S4 D B C P = S D B P - S C B P)... uniformize_signed_areas. congruence. Qed. Theorem l2_12b : forall A B C D P : Point, parallelogram A B C D -> S P A B = S4 P D A C. Proof with Geometry. intros. replace (S4 P D A C) with (S P D C - S A D C)... apply l2_12a... Qed.Theorem l2_12b_strong_3 : forall A B C D P : Point, weak_3_parallelogram A B C D -> S P A B = S4 P D A C. Proof with Geometry. intros. replace (S4 P D A C) with (S P D C - S A D C)... apply l2_12a_strong_3... Qed. Theorem pascalian_ax : forall A B C P Q R : Point, Col A B C -> Col P Q R -> parallel A Q R B -> parallel B P Q C -> parallel A P R C. 
trivial. Defined. Global Arguments Acc_inv [x] _ [y] _, [x] _ y _. Definition well_founded := forall a:A, Acc a. Hypothesis Rwf : well_founded. Theorem well_founded_induction_type : forall P:A -> Type, (forall x:A, (forall y:A, R y x -> P y) -> P x) -> forall a:A, P a. Proof. intros; apply Acc_rect; auto. Defined. Theorem well_founded_induction : forall P:A -> Set, (forall x:A, (forall y:A, R y x -> P y) -> P x) -> forall a:A, P a. Proof. exact (fun P:A -> Set => well_founded_induction_type P). Defined. Theorem well_founded_ind : forall P:A -> Prop, (forall x:A, (forall y:A, R y x -> P y) -> P x) -> forall a:A, P a. Proof. exact (fun P:A -> Prop => well_founded_induction_type P). Defined. Section FixPoint. Variable P : A -> Type. Variable F : forall x:A, (forall y:A, R y x -> P y) -> P x. Fixpoint Fix_F (x:A) (a:Acc x) : P x := F (fun (y:A) (h:R y x) => Fix_F (Acc_inv a h)). Scheme Acc_inv_dep := Induction for Acc Sort Prop. Lemma Fix_F_eq : forall (x:A) (r:Acc x), F (fun (y:A) (p:R y x) => Fix_F (x:=y) (Acc_inv r p)) = Fix_F (x:=x) r. Proof. destruct r using Acc_inv_dep; auto. Qed. Definition Fix (x:A) := Fix_F (Rwf x). Hypothesis F_ext : forall (x:A) (f g:forall y:A, R y x -> P y), (forall (y:A) (p:R y x), f y p = g y p) -> F f = F g. Lemma Fix_F_inv : forall (x:A) (r s:Acc x), Fix_F r = Fix_F s. Proof. intro x; induction (Rwf x); intros. rewrite <- (Fix_F_eq r); rewrite <- (Fix_F_eq s); intros. apply F_ext; auto. Qed. Lemma Fix_eq : forall x:A, Fix x = F (fun (y:A) (p:R y x) => Fix y). Proof. intro x; unfold Fix. rewrite <- Fix_F_eq. apply F_ext; intros. apply Fix_F_inv. Qed. End FixPoint.End Well_founded.Section Well_founded_2. Variables A B : Type. Variable R : A * B -> A * B -> Prop. Variable P : A -> B -> Type. Section FixPoint_2. Variable F : forall (x:A) (x':B), (forall (y:A) (y':B), R (y, y') (x, x') -> P y y') -> P x x'. Fixpoint Fix_F_2 (x:A) (x':B) (a:Acc R (x, x')) : P x x' := F (fun (y:A) (y':B) (h:R (y, y') (x, x')) => Fix_F_2 (x:=y) (x':=y') (Acc_inv a (y,y') h)). End FixPoint_2. Hypothesis Rwf : well_founded R. Theorem well_founded_induction_type_2 : (forall (x:A) (x':B), (forall (y:A) (y':B), R (y, y') (x, x') -> P y y') -> P x x') -> forall (a:A) (b:B), P a b. 
]. pattern (Fexp p) at 2 in |- *; replace (Fexp p) with (Zsucc (Zpred (Fexp p))); [ rewrite powerRZ_Zs; auto with real zarith | unfold Zsucc, Zpred in |- *; ring ]. repeat rewrite <- Rmult_assoc. apply Rmult_le_compat_r; auto with real arith. rewrite <- Rmult_IZR; apply Rle_IZR. rewrite <- (Zabs_eq radix); auto with zarith. rewrite <- Zabs_Zmult; rewrite Zmult_comm; auto with float. Qed. Theorem vNumbMoreThanOne : (1 < Zpos (vNum b))%Z. replace 1%Z with (Z_of_nat 1); [ idtac | simpl in |- *; auto ]. rewrite <- (Zpower_nat_O radix); rewrite pGivesBound; auto with zarith. Qed. Theorem PosNormMin : Zpos (vNum b) = (radix * nNormMin)%Z. pattern radix at 1 in |- *; rewrite <- (Zpower_nat_1 radix); unfold nNormMin in |- *. rewrite pGivesBound; rewrite <- Zpower_nat_is_exp. generalize precisionNotZero; case precision; auto with zarith. Qed. Theorem FnormalPpred : forall x : Z, (- dExp b <= x)%Z -> Fnormal (Float (pPred (vNum b)) x). intros x H; (cut (0 <= pPred (vNum b))%Z; [ intros Z1 | unfold pPred in |- *; auto with zarith ]). repeat split; simpl in |- *; auto with zarith. rewrite (Zabs_eq (pPred (vNum b))). unfold pPred in |- *; auto with zarith. unfold pPred in |- *; rewrite pGivesBound; auto with zarith. rewrite Zabs_Zmult; repeat rewrite Zabs_eq; auto with zarith. apply Zle_trans with ((1 + 1) * pPred (vNum b))%Z; auto with zarith. replace ((1 + 1) * pPred (vNum b))%Z with (pPred (vNum b) + pPred (vNum b))%Z; auto with zarith. replace (Zpos (vNum b)) with (1 + Zpred (Zpos (vNum b)))%Z; unfold pPred in |- *; auto with zarith. apply Zplus_le_compat_r; apply Zle_Zpred. apply vNumbMoreThanOne. Qed. Theorem FcanonicPpred : forall x : Z, (- dExp b <= x)%Z -> Fcanonic (Float (pPred (vNum b)) x). intros x H; left; apply FnormalPpred; auto. Qed. Theorem FnormalNnormMin : forall x : Z, (- dExp b <= x)%Z -> Fnormal (Float nNormMin x). intros x H; (cut (0 < nNormMin)%Z; [ intros Z1 | apply nNormPos ]). repeat split; simpl in |- *; auto with zarith. rewrite Zabs_eq; auto with zarith. rewrite PosNormMin. pattern nNormMin at 1 in |- *; replace nNormMin with (1 * nNormMin)%Z; auto with zarith. apply Zmult_gt_0_lt_compat_r; auto with zarith. rewrite PosNormMin; auto with zarith. Qed. Theorem FcanonicNnormMin : forall x : Z, (- dExp b <= x)%Z -> Fcanonic (Float nNormMin x). intros x H; left; apply FnormalNnormMin; auto. Qed. Theorem boundedNorMinGivesExp : forall (x : Z) (p : float), Fbounded b p -> (- dExp b <= x)%Z -> (Float nNormMin x <= p)%R -> (p <= Float (pPred (vNum b)) x)%R -> Fexp (Fnormalize p) = x. 
Qed. Theorem evolve_trans : forall w1 w2 w3, evolve w1 w2 -> evolve w2 w3 -> evolve w1 w3. unfold evolve; intuition eauto. Qed. Definition globalInv (w : world) (p : W) : hpropB (tq_args world :: nil) := starB (fun p' stn sm => Var0 {| World := w; Pointer := p'; Settings := stn; Mem := sm |}) (fst w %- p) * ^[M.globalInv (fst w) (snd w)]. End M'.Module Q := ThreadQueue.Make(M'). Import M' Q.Module Type TQS. Parameter tqs' : world -> bag -> HProp. Axiom tqs'_eq : tqs' = fun w => starB (tq w). Parameter tqs : bag -> M.world -> HProp. Axiom tqs_eq : tqs = fun b w => tqs' (b, w) b. Definition tqs'_pick_this_one (_ : W) := tqs'. Axiom tqs'_empty_bwd : forall w, Emp ===> tqs' w empty. Axiom tqs'_add_bwd : forall w ts t, tqs' w ts * tq w t ===> tqs' w (ts %+ t). Axiom tqs'_del_fwd : forall w ts t, t %in ts -> tqs'_pick_this_one t w ts ===> tq w t * tqs' w (ts %- t). Axiom tqs'_del_bwd : forall w ts t, t %in ts -> tqs' w (ts %- t) * tq w t ===> tqs' w ts. Axiom tqs'_weaken : forall w w' b, evolve w w' -> tqs' w b ===>* tqs' w' b. End TQS.Module Tqs : TQS. Open Scope Sep_scope. Definition tqs' w := starB (tq w). Theorem tqs'_eq : tqs' = fun w => starB (tq w). auto. Qed. Definition tqs b w := tqs' (b, w) b. Theorem tqs_eq : tqs = fun b w => tqs' (b, w) b. auto. Qed. Definition tqs'_pick_this_one (_ : W) := tqs'. Theorem tqs'_empty_bwd : forall w, Emp ===> tqs' w empty. intros; apply starB_empty_bwd. Qed. Theorem tqs'_add_bwd : forall w ts t, tqs' w ts * tq w t ===> tqs' w (ts %+ t). intros; apply (starB_add_bwd (tq w)). Qed. Theorem tqs'_del_fwd : forall w ts t, t %in ts -> tqs'_pick_this_one t w ts ===> tq w t * tqs' w (ts %- t). intros; apply (starB_del_fwd (tq w)); auto. Qed. Theorem tqs'_del_bwd : forall w ts t, t %in ts -> tqs' w (ts %- t) * tq w t ===> tqs' w ts. intros; eapply Himp_trans; [ | apply (starB_del_bwd (tq w)); eauto ]. eapply Himp_trans; [ apply Himp_star_comm | ]. apply Himp_refl. Qed. Theorem tqs'_weaken : forall w w' b, evolve w w' -> tqs' w b ===>* tqs' w' b. 
- split; intro; constructor. - assert (Hi4 : (Ptrofs.unsigned i + int_size)%Z = (Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr int_size)))). { unfold int_size in *; simpl size_chunk in *. rewrite Ptrofs.add_unsigned. rewrite Ptrofs.unsigned_repr. rewrite Ptrofs.unsigned_repr. reflexivity. compute; destruct Archi.ptr64; split; intros Hlt; inv Hlt. rewrite Ptrofs.unsigned_repr. simpl length in H. rewrite Nat2Z.inj_succ in H. rewrite Z.mul_succ_l in H. assert (0 <= Z.of_nat (length vs))%Z. apply Zle_0_nat. rewrite Z.add_assoc in H. assert (0 <= Ptrofs.unsigned i)%Z by apply Ptrofs.unsigned_range. inv H. split. apply OrdersEx.Z_as_OT.add_nonneg_nonneg. auto. chunk_red; omega. chunk_red; omega. compute; destruct Archi.ptr64; split; intros Hlt; inv Hlt. } split; intro; inv H0. + econstructor; eauto; unfold int_size in *; simpl size_chunk in *. apply IHvs in H10. rewrite Hi4. auto. rewrite <- Hi4. simpl length in H. rewrite Nat2Z.inj_succ in H. assert (0 <= Ptrofs.unsigned i)%Z by apply Ptrofs.unsigned_range. assert (0 <= Z.of_nat (length vs))%Z by apply Zle_0_nat. inv H. rewrite Z.mul_succ_l in H7. rewrite Z.add_assoc in H7. split; chunk_red; omega. + econstructor; eauto. unfold int_size in *; simpl size_chunk in *. apply IHvs. rewrite <- Hi4. simpl length in H. rewrite Nat2Z.inj_succ in H. assert (0 <= Ptrofs.unsigned i)%Z by apply Ptrofs.unsigned_range. assert (0 <= Z.of_nat (length vs))%Z by apply Zle_0_nat. inv H. rewrite Z.mul_succ_l in H6. rewrite Z.add_assoc in H6. split; chunk_red; omega. rewrite <- Hi4. auto. Qed. Inductive repr_val_id_L_L6_L7: L6.cps.val -> mem -> locProp -> temp_env -> positive -> Prop := | RVid_F: forall b f lenv fds L m, Genv.find_symbol (Genv.globalenv p) f = Some b -> repr_val_L_L6_L7 (cps.Vfun (M.empty cps.val) fds f) m L (Vptr b (Ptrofs.zero)) -> repr_val_id_L_L6_L7 (cps.Vfun (M.empty cps.val) fds f) m L lenv f | RVid_V: forall x m lenv L v6 v7, Genv.find_symbol (Genv.globalenv p) x = None -> M.get x lenv = Some v7 -> repr_val_L_L6_L7 v6 m L v7 -> repr_val_id_L_L6_L7 v6 m L lenv x. Theorem repr_val_id_L_L6_L7_vint_or_vptr: forall v6 m L v7, repr_val_L_L6_L7 v6 m L v7 -> Vint_or_Vptr v7 = true. Proof. intros; inv H; auto. Qed.Theorem repr_val_id_L_L6_L7_ptr: forall v6 m L lenv x, repr_val_id_L_L6_L7 v6 m L lenv x -> exists v7, repr_val_L_L6_L7 v6 m L v7 /\ ((M.get x lenv = Some v7 /\ Genv.find_symbol (Genv.globalenv p) x = None) \/ (exists b, v7 = Vptr b Ptrofs.zero /\ Genv.find_symbol (Genv.globalenv p) x = Some b)). Proof. intros. inv H. - exists (Vptr b (Ptrofs.zero)). split; auto. right. exists b; auto. - exists v7. split; auto. Qed. Theorem get_var_or_funvar_eval: forall lenv a v m, find_symbol_domain finfo_env -> finfo_env_correct -> get_var_or_funvar lenv a v -> eval_expr (globalenv p) empty_env lenv m (var_or_funvar_f a) v. 
X : UU ) ( ee : forall x x' : X , paths x x' ) : isaprop X. Proof. intros . unfold isaprop. unfold isofhlevel . intro x . assert ( is1 : iscontr X ). split with x. intro t . apply ( ee t x). assert ( is2 : isaprop X). apply isapropifcontr. assumption. unfold isaprop in is2. unfold isofhlevel in is2. apply (is2 x). Defined. Lemma isweqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) : isweq f. Proof. intros. assert (isx0: forall x:X, paths (g (f x)) x). intro. apply proofirrelevance . apply isx . assert (isy0 : forall y : Y, paths (f (g y)) y). intro. apply proofirrelevance . apply isy . apply (gradth f g isx0 isy0). Defined. Definition weqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) := weqpair _ ( isweqimplimpl f g isx isy ) .Theorem isapropempty: isaprop empty. Proof. unfold isaprop. unfold isofhlevel. intros x x' . destruct x. Defined. Theorem isapropifnegtrue { X : UU } ( a : X -> empty ) : isaprop X . Proof . intros . set ( w := weqpair _ ( isweqtoempty a ) ) . apply ( isofhlevelweqb 1 w isapropempty ) . Defined . Axiom funextempty : forall ( X : UU ) ( f g : X -> empty ) , paths f g . Theorem isapropneg (X:UU): isaprop (X -> empty). Proof. intro. apply invproofirrelevance . intros x x' . apply ( funextempty X x x' ) . Defined . Corollary isapropdneg (X:UU): isaprop (dneg X). Proof. intro. apply (isapropneg (neg X)). Defined. Definition isaninvprop (X:UU) := isweq (todneg X).Definition invimpl (X:UU) (is: isaninvprop X) : (dneg X) -> X:= invmap ( weqpair (todneg X) is ) . Lemma isapropaninvprop (X:UU): isaninvprop X -> isaprop X. Proof. intros X X0. apply (isofhlevelweqb (S O) ( weqpair (todneg X) X0 ) (isapropdneg X)). Defined. Theorem isaninvpropneg (X:UU): isaninvprop (neg X). Proof. intros. set (f:= todneg (neg X)). set (g:= negf (todneg X)). set (is1:= isapropneg X). set (is2:= isapropneg (dneg X)). apply (isweqimplimpl f g is1 is2). Defined. Theorem isapropdec (X:UU): (isaprop X) -> (isaprop (coprod X (X-> empty))). 
Require Import Coq.omega.Omega. Require Import Coq.Structures.OrderedType Coq.FSets.FMapAVL. Require Import Coq.Lists.List. Require Import Coq.Setoids.Setoid Coq.Classes.RelationClasses. Require Import Bedrock.Reflection. Require Import Coq.Numbers.Natural.Peano.NPeano.Set Implict Arguments. Set Strict Implicit.Module Ordered_nat <: OrderedType with Definition t := nat. Definition t := nat. Definition eq := @eq nat. Definition lt := @lt. Theorem eq_refl : forall x, eq x x. reflexivity. Qed. Theorem eq_sym : forall a b, eq a b -> eq b a. intros; symmetry; auto. Qed. Theorem eq_trans : forall a b c, eq a b -> eq b c -> eq a c. intros; etransitivity; eauto. Qed. Theorem lt_trans : forall a b c, lt a b -> lt b c -> lt a c. intros. unfold lt in *. omega. Qed. Theorem lt_not_eq : forall a b, lt a b -> ~(eq a b). 
v) "(% & Hk & Hml)". iExists _, _. iSplitR; first eauto. iFrame. iIntros (v' lv') "Hk". iSpecialize ("Hml" with "Hk"). replace (length l0) with (length l0 + 0) by lia. rewrite insert_app_r. simpl. iFrame. Qed. Theorem big_sepML_lookup_m_acc Œ¶ m l k v : m !! k = Some v -> big_sepML Œ¶ m l -‚àó ‚àÉ i lv, ‚åú l !! i = Some lv ‚åù ‚àó Œ¶ k v lv ‚àó ‚àÄ v' lv', Œ¶ k v' lv' -‚àó big_sepML Œ¶ (<[k := v']> m) (<[i := lv']> l). Proof. iIntros (Hi) "Hml". rewrite big_sepML_eq /big_sepML_def. iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_lookup_l_some with "Hml") as (xm) "%"; eauto. iDestruct (big_sepM2_insert_acc with "Hml") as "[Hx Hml]"; eauto. eapply map_to_list_some_list in H1 as H1'; eauto. destruct H1'. iExists _, _. iSplitR; first by done. iFrame. iIntros (v' lv') "Hx". iSpecialize ("Hml" with "Hx"). iExists (<[k := lv']> lm). iFrame. iPureIntro. eapply map_to_list_insert_overwrite; eauto. Qed. Theorem big_sepML_mono Œ¶ Œ® m l : big_sepML Œ¶ m l -‚àó ‚åú ‚àÄ k v lv, Œ¶ k v lv -‚àó Œ® k v lv ‚åù -‚àó big_sepML Œ® m l. Proof. rewrite big_sepML_eq; iIntros "Hml %". iDestruct "Hml" as (lm) "[% Hml]". iExists lm; iSplitR; first by eauto. iApply big_sepM2_mono; eauto. Qed. Theorem big_sepML_lookup_l_Some Œ¶ m l i lv : l !! i = Some lv -> big_sepML Œ¶ m l -‚àó ‚åú ‚àÉ k v, m !! k = Some v ‚åù. Proof. iIntros (Hl) "Hml". iDestruct (big_sepML_lookup_l_acc with "Hml") as (k v) "[% Hml]"; eauto. Qed. Theorem big_sepML_lookup_m_Some Œ¶ m l k v : m !! k = Some v -> big_sepML Œ¶ m l -‚àó ‚åú ‚àÉ i lv, l !! i = Some lv ‚åù. Proof. iIntros (Hm) "Hml". iDestruct (big_sepML_lookup_m_acc with "Hml") as (i lv) "[% Hml]"; eauto. Qed. Theorem big_sepML_empty_m Œ¶ m : big_sepML Œ¶ m [] -‚àó ‚åú m = ‚à ‚åù. Proof. rewrite big_sepML_eq /big_sepML_def. iIntros "Hml". iDestruct "Hml" as (lm) "[% Hml]". destruct (map_to_list lm) eqn:Heq. - apply map_to_list_empty_iff in Heq; subst. iDestruct (big_sepM2_empty_l with "Hml") as %He. done. - simpl in *. apply Permutation_nil_cons in H0. eauto. Qed. Theorem big_sepML_empty_l Œ¶ l : big_sepML Œ¶ ‚à l -‚àó ‚åú l = [] ‚åù. Proof. rewrite big_sepML_eq /big_sepML_def. iIntros "Hml". iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_empty_r with "Hml") as %He; subst. rewrite map_to_list_empty /= in H0. iPureIntro. eapply Permutation_nil_r. done. Qed. Theorem big_sepML_sep Œ¶ Œ® m l : big_sepML (Œª k v lv, Œ¶ k v lv ‚àó Œ® k v lv) m l -‚àó big_sepML Œ¶ m l ‚àó big_sepML Œ® m l. 
in n2_82a by now rewrite Impl1_01. replace (¬¨Q‚à®S) with (Q‚ÜíS) in n2_82a by now rewrite Impl1_01. replace (¬¨P‚à®(Q‚ÜíS)) with (P‚ÜíQ‚ÜíS) in n2_82a by now rewrite Impl1_01. exact n2_82a. Qed.Theorem n2_85 : ‚àÄ P Q R : Prop, ((P ‚à® Q) ‚Üí (P ‚à® R)) ‚Üí (P ‚à® (Q ‚Üí R)). Proof. intros P Q R. specialize Add1_3 with P Q. intros Add1_3a. specialize Syll2_06 with Q (P‚à®Q) R. intros Syll2_06a. MP Syll2_06a Add1_3a. specialize n2_55 with P R. intros n2_55a. specialize Syll2_05 with (P‚à®Q) (P‚à®R) R. intros Syll2_05a. Syll n2_55a Syll2_05a Ha. specialize n2_83 with (¬¨P) ((P‚à®Q)‚Üí(P‚à®R)) ((P‚à®Q)‚ÜíR) (Q‚ÜíR). intros n2_83a. MP n2_83a Ha. specialize Comm2_04 with (¬¨P) (P‚à®Q‚ÜíP‚à®R) (Q‚ÜíR). intros Comm2_04a. Syll Ha Comm2_04a Hb. specialize n2_54 with P (Q‚ÜíR). intros n2_54a. specialize Simp2_02 with (¬¨P) ((P‚à®Q‚ÜíR)‚Üí(Q‚ÜíR)). intros Simp2_02a. MP Syll2_06a Simp2_02a. MP Hb Simp2_02a. Syll Hb n2_54a Hc. exact Hc. Qed.Theorem n2_86 : ‚àÄ P Q R : Prop, ((P ‚Üí Q) ‚Üí (P ‚Üí R)) ‚Üí (P ‚Üí (Q ‚Üí R)). Proof. intros P Q R. specialize n2_85 with (¬¨P) Q R. intros n2_85a. replace (¬¨P‚à®Q) with (P‚ÜíQ) in n2_85a by now rewrite Impl1_01. replace (¬¨P‚à®R) with (P‚ÜíR) in n2_85a by now rewrite Impl1_01. replace (¬¨P‚à®(Q‚ÜíR)) with (P‚ÜíQ‚ÜíR) in n2_85a by now rewrite Impl1_01. exact n2_85a. Qed.End No2.Module No3.Import No1. Import No2. Theorem Prod3_01 : ‚àÄ P Q : Prop, (P ‚àß Q) = (¬¨(¬¨P ‚à® ¬¨Q)). Proof. intros P Q. apply propositional_extensionality. split. specialize or_not_and with (P) (Q). intros or_not_and. specialize Transp2_03 with (¬¨P ‚à® ¬¨Q) (P ‚àß Q). intros Transp2_03. MP Transp2_03 or_not_and. exact Transp2_03. specialize not_and_or with (P) (Q). intros not_and_or. specialize Transp2_15 with (P ‚àß Q) (¬¨P ‚à® ¬¨Q). intros Transp2_15. MP Transp2_15 not_and_or. exact Transp2_15. Qed. Theorem Conj3_03 : ‚àÄ P Q : Prop, P ‚Üí Q ‚Üí (P‚àßQ). Proof. intros P Q. specialize n2_11 with (¬¨P‚à®¬¨Q). intros n2_11a. specialize n2_32 with (¬¨P) (¬¨Q) (¬¨(¬¨P ‚à® ¬¨Q)). intros n2_32a. MP n2_32a n2_11a. replace (¬¨(¬¨P‚à®¬¨Q)) with (P‚àßQ) in n2_32a by now rewrite Prod3_01. replace (¬¨Q ‚à® (P‚àßQ)) with (Q‚Üí(P‚àßQ)) in n2_32a by now rewrite Impl1_01. replace (¬¨P ‚à® (Q ‚Üí (P‚àßQ))) with (P‚ÜíQ‚Üí(P‚àßQ)) in n2_32a by now rewrite Impl1_01. exact n2_32a. Qed. Ltac Conj H1 H2 C := let C := fresh C in match goal with | [ H1 : ?P, H2 : ?Q |- _ ] => (specialize Conj3_03 with P Q; intros C; MP Conj3_03 P; MP Conj3_03 Q) end. Theorem n3_1 : ‚àÄ P Q : Prop, (P ‚àß Q) ‚Üí ¬¨(¬¨P ‚à® ¬¨Q). 
revert h. induction n; intros. - omega. - simpl. destruct i. + rewrite <- plus_n_O. apply allocate_prewrite; try omega. hsimpl; hsolver; crush. + replace (base + S i) with (S base + i) by omega. rewrite IHn; auto; omega. Qed.Theorem HtAlloc : forall P (x : var) (n : nat), (fun v h => exists base, (v $ x = base) /\ (forall i, i < n -> h $ (base + i) = Some 0) ) ==> P -> htriple hemp (Alloc x n) P. Proof. h; hsimpl; subst. eapply H. exists base. intuition; try hsolver; crush. apply allocate_spec; omega. Qed.Theorem HtSeq : forall P Q R c1 c2, htriple Q c2 R -> htriple P c1 Q -> htriple P (Seq c1 c2) R. Proof. h. eapply H; eauto. Qed.Theorem HtIf : forall P Q cond br1 br2, htriple (fun v h => P v h /\ beval cond v = true) br1 Q -> htriple (fun v h => P v h /\ beval cond v = false) br2 Q -> htriple P (If cond br1 br2) Q. Proof. h; firstorder. Qed.Theorem HtWhile : forall I cond body, htriple (fun v h => I v h /\ beval cond v = true) body I -> htriple I (While I cond body) (fun v h => I v h /\ beval cond v = false). Proof. unfold htriple; intros. remember (While I cond body) as E. induction H0; inversion HeqE; crush; clear IHexecute1 HeqE; pose proof (H v1 h1 v2 h2); intuition. Qed.Theorem HtConsequence : forall P Q P' Q' c, htriple P c Q -> P' ==> P -> Q ==> Q' -> htriple P' c Q'. Proof. unfold htriple; intros. apply H1. eapply H; eauto. Qed.Section BadFrameRule. Lemma HtFrameBadExample : forall (x : var), ~ (htriple (hemp ** (fun v h => v $ x = 0)) (Assign x (Const 1)) (hemp ** (fun v h => v $ x = 0))). Proof. intros. intros Hcontra. unfold htriple in *. hsimpl. assert (execute empty_valuation empty_heap (Assign x (Const 1)) (add empty_valuation x 1) empty_heap). constructor. pose proof (Hcontra _ _ _ _ H). clear Hcontra H. assert (HTauto : forall (P Q : Prop), (P -> Q) -> P -> (Q -> False) -> False). tauto. eapply HTauto. + apply H0. + exists empty_heap, empty_heap; intuition. + intros [h1 [h2 Hcontra]]; crush. hsimpl; hsolver; congruence. Qed. Theorem HtFrameBad : ~ (forall P Q R c, htriple P c Q -> htriple (P ** R) c (Q ** R)). 
listpred_pimpl_replace. cancel. unfold SS.For_all. setoid_rewrite SetFacts.empty_iff. intuition. Qed. Definition block_belong_to_file ilist bn inum off := off < length (INODE.IBlocks (selN ilist inum INODE.inode0)) /\ bn = # (selN (INODE.IBlocks (selN ilist inum INODE.inode0)) off $0). Definition block_is_unused freeblocks (bn : addr) := In bn freeblocks. Definition block_is_unused_dec freeblocks (bn : addr) : { block_is_unused freeblocks bn } + { ~ block_is_unused freeblocks bn } := In_dec addr_eq_dec bn freeblocks. Lemma block_is_unused_xor_belong_to_file : forall F Ftop fsxp sm files ilist free allocc mscache icache dblocks m flag bn inum off, (F * rep fsxp sm Ftop files ilist free allocc mscache icache dblocks)%pred m -> block_is_unused (pick_balloc free flag) bn -> block_belong_to_file ilist bn inum off -> False. Proof. unfold rep, block_is_unused, block_belong_to_file; intuition. rewrite <- locked_eq with (x := bn) in H3. destruct_lift H. rewrite listmatch_isolate with (i := inum) in H. unfold file_match at 2 in H. erewrite listmatch_isolate with (i := off) (a := (BFData files ‚ü¶ inum ‚üß)) in H by simplen. erewrite selN_map in H; eauto. unfold BALLOCC.rep in H; destruct_lift H. unfold BALLOCC.Alloc.rep in H; destruct_lift H. unfold BALLOCC.Alloc.Alloc.rep in H; destruct_lift H. destruct flag; simpl in *. - denote (locked _ = _) as Hl. rewrite locked_eq in Hl. rewrite <- Hl in H; clear Hl. match goal with H: context [ptsto bn ?a], Hl: _ <=p=> _ |- _ => rewrite Hl, listpred_pick in H by eauto; destruct_lift H end. eapply ptsto_conflict_F with (m := m) (a := bn). pred_apply. cancel. rewrite <- surjective_pairing. cancel. - denote (locked _ = _) as Hl. rewrite locked_eq in Hl. rewrite <- Hl in H; clear Hl. match goal with H: context [ptsto bn ?a], Hl: _ <=p=> _ |- _ => rewrite Hl, listpred_pick in H by eauto; destruct_lift H end. eapply ptsto_conflict_F with (m := m) (a := bn). pred_apply. cancel. rewrite <- surjective_pairing. cancel. - erewrite listmatch_length_r; eauto. destruct (lt_dec inum (length ilist)); eauto. rewrite selN_oob in * by omega. unfold INODE.inode0 in H2; simpl in *; omega. - destruct (lt_dec inum (length ilist)); eauto. rewrite selN_oob in * by omega. unfold INODE.inode0 in *; simpl in *; omega. Grab Existential Variables. all: eauto. all: solve [exact ($0, nil) | exact bfile0]. Qed. Definition ilist_safe ilist1 free1 ilist2 free2 := incl free2 free1 /\ forall inum off bn, block_belong_to_file ilist2 bn inum off -> (block_belong_to_file ilist1 bn inum off \/ block_is_unused free1 bn). Theorem ilist_safe_refl : forall i f, ilist_safe i f i f. 
2 * x = x + x. intros x; ring. Qed. Theorem lt_neq : forall x y : nat, x < y -> x <> y. unfold not in |- *; intros x y H H1; elim (lt_irrefl x); pattern x at 2 in |- *; rewrite H1; auto. Qed. Hint Resolve lt_neq. Theorem monotonic_inverse : forall f : nat -> nat, (forall x y : nat, x < y -> f x < f y) -> forall x y : nat, f x < f y -> x < y. intros f Hmon x y Hlt; case (le_gt_dec y x); auto. intros Hle; elim (le_lt_or_eq _ _ Hle). intros Hlt'; elim (lt_asym _ _ Hlt); apply Hmon; auto. intros Heq; elim (lt_neq _ _ Hlt); rewrite Heq; auto. Qed. Theorem mult_lt : forall a b c : nat, c <> 0 -> a < b -> a * c < b * c. intros a b c; elim c. intros H; elim H; auto. intros c'; case c'. intros; omega. intros c'' Hrec Hneq Hlt; repeat rewrite <- (fun x : nat => mult_n_Sm x (S c'')). auto with *. Qed. Remark add_sub_square_identity : forall a b : nat, (b + a - b) * (b + a - b) = (b + a) * (b + a) + b * b - 2 * ((b + a) * b). intros a b; rewrite minus_plus. repeat rewrite mult_plus_distr_r || rewrite <- (mult_comm (b + a)). replace (b * b + a * b + (b * a + a * a) + b * b) with (b * b + a * b + (b * b + a * b + a * a)); try (ring; fail). rewrite expand_mult2; repeat rewrite minus_plus; auto with *. Qed. Theorem sub_square_identity : forall a b : nat, b <= a -> (a - b) * (a - b) = a * a + b * b - 2 * (a * b). intros a b H; rewrite (le_plus_minus b a H); apply add_sub_square_identity. Qed. Theorem square_monotonic : forall x y : nat, x < y -> x * x < y * y. intros x; case x. intros y; case y; simpl in |- *; auto with *. intros x' y Hlt; apply lt_trans with (S x' * y). rewrite (mult_comm (S x') y); apply mult_lt; auto. apply mult_lt; omega. Qed. Theorem root_monotonic : forall x y : nat, x * x < y * y -> x < y. 
true). intros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc. elim (H4 false); simpl in |- *. simple induction x0; simpl in |- *. intros. cut (EQ (Sing B') Vide). simpl in |- *. simple induction 1. intros yy; elim (yy true). simple induction x1.apply EQ_tran with A; auto with zfc.intros; cut (EQ (Sing B') Vide). simpl in |- *. simple induction 1. intros yy; elim (yy true). simple induction x1.apply EQ_tran with A; auto with zfc.intros yy. elim (HB true); simpl in |- *. simple induction x0. change (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE. apply IN_Sing_EQ. apply IN_sound_right with (Sing A); auto with zfc. change (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *. intros zz. elimtype F. apply (not_EQ_Sing_Vide A'). apply EQ_tran with B. apply IN_Sing_EQ. apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc. apply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.Qed.Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'. unfold Couple in |- *; simpl in |- *. simple induction 1; intros H1 H2. elim (H1 false). intros bb1; elim bb1. intros HF. change (EQ (Paire Vide (Sing A')) (Sing B)) in HF. cut F. simple induction 1. apply (not_EQ_Vide_Sing A'). apply EQ_tran with B. apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc. apply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc. change (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *. intros HP; cut (EQ (Sing A') (Sing B')). intros; auto with zfc. cut (IN (Sing A') (Paire Vide (Sing B'))). intros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI). intros; cut F. simple induction 1. apply not_EQ_Sing_Vide with A'; assumption. trivial with zfc. apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.Qed.Definition Prod (E E' : Ens) : Ens := match E, E' with | sup A f, sup A' f' => sup _ (fun c : prod_t A A' => match c with | pair_t a a' => Couple (f a) (f' a') end) end. Hint Resolve Paire_sound_left Paire_sound_right: zfc. Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B). 
Obligation. intros; cbn; repeat rewrite F_id; trivial. Qed.Next Obligation. intros; cbn; repeat rewrite F_compose; trivial. Qed.Definition Bi_Func_1 {Cx C1 C1' Cy : Category} (F : Cx --> C1) (F' : (C1 √ó C1') --> Cy) : (Cx √ó C1') --> Cy := F' ‚àò (Prod_Functor F (@Functor_id C1')).Definition Bi_Func_2 {Cx C1 C1' Cy : Category} (F : Cx --> C1') (F' : (C1 √ó C1') --> Cy) : (C1 √ó Cx) --> Cy := Functor_compose (Prod_Functor (@Functor_id C1) F) F'.Local Hint Extern 2 => cbn : Core.Local Obligation Tactic := basic_simpl; do 2 auto.Program Definition Fix_Bi_Func_1 {C1 C1' Cy : Category} (x : C1) (F : (C1 √ó C1') --> Cy) : C1' --> Cy := {| FO := fun a => (F _o (x, a))%object; FA := fun _ _ f => (F @_a (_, _) (_, _) (@id _ x, f))%morphism |}.Program Definition Fix_Bi_Func_2 {C1 C1' Cy : Category} (x : C1') (F : (C1 √ó C1') --> Cy) : C1 --> Cy := {| FO := fun a => (F _o (a, x))%object; FA := fun _ _ f => (F @_a (_, _) (_, _) (f, @id _ x))%morphism |}.Program Definition Diag_Func (C : Category) : C --> (C √ó C) := {| FO := fun a => (a, a); FA := fun _ _ f => (f, f); F_id := fun _ => eq_refl; F_compose := fun _ _ _ _ _ => eq_refl |}.Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C --> (D √ó D')) : ((Prod_Functor ((Cat_Proj1 _ _) ‚àò F) ((Cat_Proj2 _ _) ‚àò F)) ‚àò (Diag_Func C))%functor = F. Proof. Func_eq_simpl; trivial. Qed.Program Definition Twist_Func (C C' : Category) : (C √ó C') --> (C' √ó C) := {| FO := fun a => (snd a, fst a); FA := fun _ _ f => (snd f, fst f); F_id := fun _ => eq_refl; F_compose := fun _ _ _ _ _ => eq_refl |}.Section Twist_Prod_Func_Twist. Context {C C' : Category} (F : C --> C') {D D' : Category} (G : D --> D'). Theorem Twist_Prod_Func_Twist : (((Twist_Func _ _) ‚àò (Prod_Functor F G)) ‚àò (Twist_Func _ _))%functor = Prod_Functor G F. Proof. Func_eq_simpl; trivial. Qed.End Twist_Prod_Func_Twist.Section Prod_Functor_compose. Context {C D E: Category} (F : C --> D) (G : D --> E) {C' D' E': Category} (F' : C' --> D') (G' : D' --> E'). Theorem Prod_Functor_compose : ((Prod_Functor G G') ‚àò (Prod_Functor F F') = Prod_Functor (G ‚àò F) (G' ‚àò F'))%functor. 
Require Import Rbase. Require Import Rfunctions. Require Import Rseries. Require Import PartSum. Require Import Omega. Local Open Scope R_scope.Set Implicit Arguments.Section Sigma. Variable f : nat -> R. Definition sigma (low high:nat) : R := sum_f_R0 (fun k:nat => f (low + k)) (high - low). Theorem sigma_split : forall low high k:nat, (low <= k)%nat -> (k < high)%nat -> sigma low high = sigma low k + sigma (S k) high. 
Require Export Zenum. Require Export FPred. Section FMinMax. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Coercion FtoRradix : float >-> R. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition boundNat (n : nat) := Float 1%nat (digit radix n). Theorem boundNatCorrect : forall n : nat, (n < boundNat n)%R. intros n; unfold FtoRradix, FtoR, boundNat in |- *; simpl in |- *. rewrite Rmult_1_l. rewrite <- Zpower_nat_Z_powerRZ; auto with real zarith. rewrite INR_IZR_INZ; auto with real zarith. apply Rle_lt_trans with (Zabs n); [rewrite (Zabs_eq (Z_of_nat n))|idtac];auto with real zarith. Qed. Theorem boundBoundNat : forall n : nat, Fbounded b (boundNat n). 
(mag beta eps) = fexp n). apply valid_exp; try assumption. assert(mag beta eps-1 < fexp n)%Z;[idtac|omega]. apply lt_bpow with beta. apply Rle_lt_trans with (2:=H). destruct (mag beta eps) as (e,He). simpl; rewrite Rabs_pos_eq in He. now apply He, Rgt_not_eq. now left. replace (Zceil (eps * bpow (- fexp (mag beta eps)))) with 1%Z. unfold F2R; simpl; rewrite H0; ring. apply sym_eq, Zceil_imp. split. simpl; apply Rmult_lt_0_compat. apply Heps. apply bpow_gt_0. apply Rmult_le_reg_r with (bpow (fexp n)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus. rewrite H0; ring_simplify (-fexp n + fexp n)%Z. simpl; rewrite Rmult_1_l, Rmult_1_r. now left. intros P; rewrite P. apply round_generic... apply generic_format_ulp_0. Qed. Theorem round_UP_pred_plus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x) )%R -> round beta fexp Zceil (pred x + eps) = x. Proof. intros x Hx Fx eps Heps. rewrite round_UP_plus_eps_pos; trivial. rewrite pred_eq_pos. apply pred_pos_plus_ulp; trivial. now left. now apply pred_ge_0. apply generic_format_pred; trivial. Qed.Theorem round_DN_minus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x))%R -> round beta fexp Zfloor (x - eps) = pred x. Proof. intros x Hpx Fx eps. rewrite pred_eq_pos;[intros Heps|now left]. replace (x-eps)%R with (pred_pos x + (ulp (pred_pos x)-eps))%R. 2: pattern x at 3; rewrite <- (pred_pos_plus_ulp x); trivial. 2: ring. rewrite round_DN_plus_eps_pos; trivial. now apply pred_pos_ge_0. now apply generic_format_pred_pos. split. apply Rle_0_minus. now apply Heps. rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. now apply Heps. Qed. Theorem round_DN_plus_eps: forall x, F x -> forall eps, (0 <= eps < if (Rle_bool 0 x) then (ulp x) else (ulp (pred (-x))))%R -> round beta fexp Zfloor (x + eps) = x. Proof. intros x Fx eps Heps. case (Rle_or_lt 0 x); intros Zx. apply round_DN_plus_eps_pos; try assumption. split; try apply Heps. rewrite Rle_bool_true in Heps; trivial. now apply Heps.rewrite Rle_bool_false in Heps; trivial. rewrite <- (Ropp_involutive (x+eps)). pattern x at 2; rewrite <- (Ropp_involutive x). rewrite round_DN_opp. apply f_equal. replace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R. rewrite round_UP_pred_plus_eps_pos; try reflexivity. now apply Ropp_0_gt_lt_contravar. now apply generic_format_opp. split. apply Rplus_lt_reg_l with eps; ring_simplify. apply Heps. apply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify. apply Heps. unfold pred. rewrite Ropp_involutive. unfold succ; rewrite Rle_bool_false; try assumption. rewrite Ropp_involutive; unfold Rminus. rewrite <- Rplus_assoc, pred_pos_plus_ulp. ring. now apply Ropp_0_gt_lt_contravar. now apply generic_format_opp. Qed. Theorem round_UP_plus_eps : forall x, F x -> forall eps, (0 < eps <= if (Rle_bool 0 x) then (ulp x) else (ulp (pred (-x))))%R -> round beta fexp Zceil (x + eps) = (succ x)%R. 
isasetsetquot R (setquotpr R x) (setquotpr R x') ) . assumption . Defined . Definition iscomprelrelfun { X Y : UU } ( RX : hrel X ) ( RY : hrel Y ) ( f : X -> Y ) := forall x x' : X , RX x x' -> RY ( f x ) ( f x' ) .Lemma iscomprelfunlogeqf1 { X Y : UU } { LX RX : hrel X } ( RY : hrel Y ) ( lg : hrellogeq LX RX ) ( f : X -> Y ) ( is : iscomprelrelfun LX RY f ) : iscomprelrelfun RX RY f . Proof . intros . intros x x' r . apply ( is _ _ ( pr2 ( lg _ _ ) r ) ) . Defined . Lemma iscomprelfunlogeqf2 { X Y : UU } ( RX : hrel X ) { LY RY : hrel Y } ( lg : hrellogeq LY RY ) ( f : X -> Y ) ( is : iscomprelrelfun RX LY f ) : iscomprelrelfun RX RY f . Proof . intros . intros x x' r . apply ( ( pr1 ( lg _ _ ) ) ( is _ _ r ) ) . Defined . Definition setquotfun { X Y : UU } ( RX : hrel X ) ( RY : eqrel Y ) ( f : X -> Y ) ( is : iscomprelrelfun RX RY f ) ( cx : setquot RX ) : setquot RY . Proof . intros . set ( ff := funcomp f ( setquotpr RY ) ) . assert ( isff : iscomprelfun RX ff ) . intros x x' . intro r . apply ( weqpathsinsetquot RY ( f x ) ( f x' ) ) . apply is . apply r . apply ( setquotuniv RX ( setquotinset RY ) ff isff cx) . Defined . Definition setquotfuncomm { X Y : UU } ( RX : eqrel X ) ( RY : eqrel Y ) ( f : X -> Y ) ( is : iscomprelrelfun RX RY f ) : forall x : X , paths ( setquotfun RX RY f is ( setquotpr RX x ) ) ( setquotpr RY ( f x ) ) . Proof . intros . simpl . apply idpath . Defined . Theorem setquotunivprop { X : UU } ( R : eqrel X ) ( P : setquot R -> hProp ) ( is : forall x : X , P ( setquotpr R x ) ) : forall c : setquot R , P c . 
(forall p, In p (nwPackets {| nwPackets := ps ; nwState := st |}) -> In p (nwPackets net)) by (intros; simpl in *; find_rewrite; in_crush) end. eapply_prop msg_refined_raft_net_invariant_state_same_packet_subset; [|eauto|idtac|]; eauto. + match goal with | [ H : nwPackets ?net = _ |- _ {| nwPackets := ?ps ; nwState := ?st |} ] => assert (forall p, In p (nwPackets {| nwPackets := ps ; nwState := st |}) -> In p (nwPackets net)) by (intros; simpl in *; find_rewrite; in_crush) end. eapply_prop msg_refined_raft_net_invariant_state_same_packet_subset; [|eauto|idtac|]; eauto. + auto. + eapply_prop msg_refined_raft_net_invariant_reboot; eauto; intros; simpl in *; repeat break_if; intuition; subst; intuition eauto. destruct (nwState net h); auto. - eapply msg_refined_raft_invariant_handle_input; eauto. - eapply msg_refined_raft_invariant_handle_message; eauto. - eapply_prop msg_refined_raft_net_invariant_do_leader; eauto. - eapply_prop msg_refined_raft_net_invariant_do_generic_server; eauto. Qed. Lemma msg_refined_raft_invariant_handle_message' P : forall xs p ys net st' ps' gd d l, msg_refined_raft_net_invariant_append_entries' P -> msg_refined_raft_net_invariant_append_entries_reply' P -> msg_refined_raft_net_invariant_request_vote' P -> msg_refined_raft_net_invariant_request_vote_reply' P -> handleMessage (pSrc p) (pDst p) (snd (pBody p)) (snd (nwState net (pDst p))) = (d, l) -> update_elections_data_net (pDst p) (pSrc p) (snd (pBody p)) (nwState net (pDst p)) = gd -> P net -> msg_refined_raft_intermediate_reachable net -> msg_refined_raft_intermediate_reachable (mkNetwork ps' st') -> nwPackets net = xs ++ p :: ys -> (forall h, st' h = update name_eq_dec (nwState net) (pDst p) (gd, d) h) -> (forall p', In p' ps' -> In p' (xs ++ ys) \/ In p' (send_packets (pDst p) (@add_ghost_msg _ _ ghost_log_params (pDst p) (gd, d) l))) -> P (mkNetwork ps' st'). Proof using. intros. unfold handleMessage, update_elections_data_net in *. break_match; repeat break_let; repeat find_inversion; [eapply_prop msg_refined_raft_net_invariant_request_vote'| eapply_prop msg_refined_raft_net_invariant_request_vote_reply'| eapply_prop msg_refined_raft_net_invariant_append_entries'| eapply_prop msg_refined_raft_net_invariant_append_entries_reply']; eauto; unfold send_packets in *; simpl in *; intros; subst; auto; find_apply_hyp_hyp; intuition. Qed. Lemma msg_refined_raft_invariant_handle_input' P : forall h inp net st' ps' gd out d l, msg_refined_raft_net_invariant_timeout' P -> msg_refined_raft_net_invariant_client_request' P -> handleInput h inp (snd (nwState net h)) = (out, d, l) -> update_elections_data_input h inp (nwState net h) = gd -> P net -> msg_refined_raft_intermediate_reachable net -> msg_refined_raft_intermediate_reachable (mkNetwork ps' st') -> (forall h', st' h' = update name_eq_dec (nwState net) h (gd, d) h') -> (forall p', In p' ps' -> In p' (nwPackets net) \/ In p' (send_packets h (@add_ghost_msg _ _ ghost_log_params h (gd, d) l))) -> P (mkNetwork ps' st'). Proof using. intros. unfold handleInput, update_elections_data_input in *. break_match; repeat break_let; repeat find_inversion; [eapply_prop msg_refined_raft_net_invariant_timeout'| eapply_prop msg_refined_raft_net_invariant_client_request']; eauto; subst; auto. Qed. Theorem msg_refined_raft_net_invariant' : forall P net, msg_refined_raft_net_invariant_init P -> msg_refined_raft_net_invariant_client_request' P -> msg_refined_raft_net_invariant_timeout' P -> msg_refined_raft_net_invariant_append_entries' P -> msg_refined_raft_net_invariant_append_entries_reply' P -> msg_refined_raft_net_invariant_request_vote' P -> msg_refined_raft_net_invariant_request_vote_reply' P -> msg_refined_raft_net_invariant_do_leader' P -> msg_refined_raft_net_invariant_do_generic_server' P -> msg_refined_raft_net_invariant_state_same_packet_subset' P -> msg_refined_raft_net_invariant_reboot' P -> msg_refined_raft_intermediate_reachable net -> P net. 
(ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) r))) q); apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply eqp_pluspf_com with (1 := cs); auto. Qed. Hint Resolve spminusf_pluspf. Theorem eqptail_spminusf_com : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf a b nZb p r) (spminusf a b nZb q r). unfold spminusf in |- *; auto. Qed. Theorem eqTerm_spminusf_com : forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqTerm (A:=A) eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf a c nZc p q) (spminusf b c nZc p q). intros a b c nZc p q H' H'0 H'1 H'2. cut (divP A A0 eqA multA divA n b c); [ intros H'3 | auto ]. unfold spminusf in |- *; auto. apply divP_eqTerm_comp with (1 := cs) (a := a); auto. Qed. Theorem eqp_spminusf_com : forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> eqTerm (A:=A) eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf a c nZc p r) (spminusf b c nZc q r). intros a b c nZc p q r H' H'0 H'1 H'2 H'3 H'4. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := spminusf b c nZc p r); auto. apply eqTerm_spminusf_com; auto. apply eqptail_spminusf_com; auto. apply divP_eqTerm_comp with (1 := cs) (a := a); auto. Qed. Hint Resolve eqTerm_spminusf_com eqp_spminusf_com eqp_spminusf_com. Theorem spminusf_minuspf : forall (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf a b nZb (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) r) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf a b nZb p r) q). 
(A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a a0) (b:=a) nZa) (pX a l)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a a0) (b:=a0) nZa0) (pX a0 l0))); auto. apply spolyf_canonical with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. change (eqP A eqA n (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX a l) (pX a0 l0) Cp Cq) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a a0) (b:=a) nZa) (pX a l)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a a0) (b:=a0) nZa0) (pX a0 l0)))) in |- *. apply spoly_is_minus with (1 := cs); auto. Qed. Theorem CombLinear_reduce : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p. intros Q p q H'0 H'1 H'2. case reduce_inv2 with (1 := cs) (3 := H'0); auto. intros x H; elim H; intros a H0; elim H0; intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6; clear H4 H2 H0 H. apply CombLinear_1 with (a := a) (p := q) (q := x); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n). cut (canonical A0 eqA ltM q); [ intros Op1 | apply canonical_reduce with (1 := cs) (3 := H'0) ]; auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a x) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults (A:=A) multA (n:=n) a x))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults (A:=A) multA (n:=n) a x)) (mults (A:=A) multA (n:=n) a x)); auto. apply pluspf_minuspf_id with (1 := cs); auto. Qed. Theorem CombLinear_reduceplus : forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> CombLinear Q q -> CombLinear Q p. 
Require Import FunctionalExtensionality.Set Implicit Arguments.Definition EqDec (T : Type) := forall (a b : T), {a = b} + {a <> b}.Definition mem {A : Type} {AEQ : EqDec A} {V : Type} := A -> option V. Definition empty_mem {A : Type} {AEQ : EqDec A} {V : Type} : @mem A AEQ V := fun a => None.Section GenMem. Variable A : Type. Variable V : Type. Variable AEQ : EqDec A. Definition upd (m : @mem A AEQ V) (a : A) (v : V) : @mem A AEQ V := fun a' => if AEQ a' a then Some v else m a'. Definition updSome (m : @mem A AEQ V) (a : A) (v : V) : @mem A AEQ V := fun a' => if AEQ a' a then match m a with | None => None | Some _ => Some v end else m a'. Definition delete (m : @mem A AEQ V) (a : A) : @mem A AEQ V := fun a' => if AEQ a' a then None else m a'. Definition insert (m : @mem A AEQ V) (a : A) (v : V) : @mem A AEQ V := fun a' => if AEQ a' a then match m a with | None => Some v | Some _ => m a' end else m a'. Theorem upd_eq : forall m (a : A) (v : V) a', a' = a -> upd m a v a' = Some v. Proof. intros; subst; unfold upd. destruct (AEQ a a); tauto. Qed. Theorem updSome_eq : forall m (a : A) (v v' : V) a', m a = Some v' -> a' = a -> updSome m a v a' = Some v. Proof. intros; subst; unfold updSome. rewrite H. destruct (AEQ a a); tauto. Qed. Theorem insert_eq : forall m (a : A) (v v' : V) a', m a = None -> a' = a -> insert m a v a' = Some v. Proof. intros; subst; unfold insert. rewrite H. destruct (AEQ a a); congruence. Qed. Theorem upd_ne : forall m (a : A) (v : V) a', a' <> a -> upd m a v a' = m a'. Proof. intros; subst; unfold upd. destruct (AEQ a' a); tauto. Qed. Theorem updSome_ne : forall m (a : A) (v : V) a', a' <> a -> updSome m a v a' = m a'. 
a n x z, eval_expr ge sp e m le a x -> Val.shrxl x (Vint n) = Some z -> exists v, eval_expr ge sp e m le (shrxlimm a n) v /\ Val.lessdef z v. Proof. unfold shrxlimm. intros. destruct Archi.splitlong eqn:SL. eapply SplitLongproof.eval_shrxlimm; eauto. predSpec Int.eq Int.eq_spec n Int.zero. - subst n. destruct x; simpl in H0; inv H0. econstructor; split; eauto. change (Int.ltu Int.zero (Int.repr 63)) with true. simpl. rewrite Int64.shrx'_zero; auto. - TrivialExists. Qed.Theorem eval_divls_base: partial_binary_constructor_sound divls_base Val.divls. Proof. unfold divls_base; red; intros. destruct Archi.splitlong eqn:SL. eapply SplitLongproof.eval_divls_base; eauto. TrivialExists. Qed.Lemma eval_modl_aux: forall divop semdivop, (forall sp x y m, eval_operation ge sp divop (x :: y :: nil) m = semdivop x y) -> forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> semdivop x y = Some z -> eval_expr ge sp e m le (modl_aux divop a b) (Val.subl x (Val.mull z y)). Proof. intros; unfold modl_aux. eapply eval_Elet. eexact H0. eapply eval_Elet. apply eval_lift. eexact H1. eapply eval_Eop. eapply eval_Econs. eapply eval_Eletvar. simpl; reflexivity. eapply eval_Econs. eapply eval_Eop. eapply eval_Econs. eapply eval_Eop. eapply eval_Econs. apply eval_Eletvar. simpl; reflexivity. eapply eval_Econs. apply eval_Eletvar. simpl; reflexivity. apply eval_Enil. rewrite H. eauto. eapply eval_Econs. apply eval_Eletvar. simpl; reflexivity. apply eval_Enil. simpl; reflexivity. apply eval_Enil. reflexivity. Qed.Theorem eval_modls_base: partial_binary_constructor_sound modls_base Val.modls. Proof. unfold modls_base. red; intros. destruct Archi.splitlong eqn:SL. eapply SplitLongproof.eval_modls_base; eauto. assert (DEFAULT: exists v : val, eval_expr ge sp e m le (modl_aux Odivl a b) v /\ Val.lessdef z v). exploit Val.modls_divls; eauto. intros [v [A B]]. { subst. econstructor; split; eauto. apply eval_modl_aux with (semdivop := Val.divls); auto. } destruct (is_longconst a) as [n1|] eqn:A. exploit is_longconst_sound. eauto. eauto. intros. destruct (is_longconst b) as [n2|] eqn:B; auto. exploit is_longconst_sound. eauto. eauto. intros. predSpec Int64.eq Int64.eq_spec Int64.zero n2; simpl. auto. predSpec Int64.eq Int64.eq_spec n1 (Int64.repr Int64.min_signed); predSpec Int64.eq Int64.eq_spec n2 Int64.mone; simpl; auto; subst. - econstructor; split. apply eval_longconst. unfold Val.modls in H1. rewrite Int64.eq_false in H1; auto. rewrite (Int64.eq_false n2 Int64.mone H6) in H1. inversion H1. auto. - econstructor; split. apply eval_longconst. unfold Val.modls in H1. rewrite Int64.eq_false in H1; auto. rewrite Int64.eq_false in H1; auto. inversion H1. auto. - econstructor; split. apply eval_longconst. unfold Val.modls in H1. rewrite Int64.eq_false in H1; auto. rewrite Int64.eq_false in H1; auto. inversion H1. auto. - apply DEFAULT. Qed. Theorem eval_divlu_base: partial_binary_constructor_sound divlu_base Val.divlu. 
exrepnd. rename Hcv1 into Hcb. applydup_clear Hbc3 in Hcb. exrepnd. exists a'0 e'0; sp. + revert Hcv2 Hcb2. apply Ht. + revert Hcv0 Hcb0. apply Ht. - introv comp. apply Hab4 in comp; exrepnd. apply Hbc4 in comp1; exrepnd. eexists; dands; eauto. Qed.Lemma sqlen_n_trans {o} : forall lib n, trans_rel (@sqle_n o lib n). Proof. induction n; intros a b c Hab Hbc; invertsn Hab; invertsn Hbc; constructor; auto;[]. revert Hab Hbc. apply trans_rel_close_comput; eauto with respects. Qed.Lemma trans_rel_olift_sqlen {o} : forall lib n, trans_rel (lblift (olift (@sqle_n o lib n))). Proof. intros. apply trans_lblift; eauto with respects;[]. apply sqlen_n_trans. Qed.Theorem sqlen_closed {o} : forall lib n, is_rel_on_progs (@sqle_n o lib n). Proof. induction n as [| n Hind]; intros t1 t2 Hsq; invertsn Hsq; auto. rename Hsq into Hclose. unfold close_comput in Hclose. sp; auto. Qed.Definition sqle {o} lib (tl tr : @NTerm o) := forall n, sqle_n lib n tl tr. Definition sq_closure {o} lib := fun (R : @NTerm o -> @NTerm o -> [univ]) => is_rel_on_progs R # le_bin_rel R (close_comput lib R).Theorem sqle_ge_postfixpoint {o} : forall lib, is_ge_any_rel_sat (sqle lib) (@sq_closure o lib). Proof. unfold is_ge_any_rel_sat, le_bin_rel, sq_closure. auto. intros lib Rp Hsat a b Hrp n. gen a b. repnd. induction n; intros a b Hrp; constructor; try (apply Hsat0 in Hrp; sp; auto; fail). apply Hsat in Hrp. clear Hsat. allunfold @close_comput; repnd. repeat(split;auto). - intros c tl_subterms Hcv. apply Hrp2 in Hcv. exrepnd. exists tr_subterms. sp; auto. clear Hcv1. gen tl_subterms tr_subterms. fold (@le_bin_rel NTerm Rp (sqle_n lib n)) in IHn. fold (@le_bin_rel (list BTerm ) (lblift Rp) (lblift (sqle_n lib n)) ) . apply le_lblift. apply le_olift in IHn. auto. - introv ce. apply Hrp3 in ce; exrepnd. exists a' e'; auto. - introv comp. apply Hrp4 in comp; exrepnd. eexists; dands; eauto. Qed. Theorem close_comput_mono {o}: forall lib R1 R2, (le_bin_rel R1 R2) -> le_bin_rel (@close_comput o lib R1) (close_comput lib R2). Proof. intros ? ? ? Hle. intros ? ? Hcr1. allunfold @close_comput. repnd. repeat(split;auto). - intros ? ? Hcomp. apply Hcr3 in Hcomp. parallel tr_subterms Hrelbt. repnd. split;auto. allunfold @lblift. exrepnd. dands;sp. eapply le_blift_olift; eauto. - introv ce. apply Hcr4 in ce; exrepnd. exists a' e'; auto. - introv comp. apply Hcr5 in comp; exrepnd. eexists; dands; eauto. Qed.Definition nt_id_prog {o} := fun x y : @NTerm o => isprogram x # isprogram y # x = y. Theorem sqle_suff_necc: eq_bin_rel (close_comput sqle) (sqle). 
: OracleComp (list (Bvector b)) (Bvector b) (Bvector c * list ((list (Bvector b) * Bvector b) * Bvector c)) := fd <--$ OC_Query _ d; match arrayLookup_f _ f fd with | Some r => $ ret (r, ((d, fd), r) :: f) | None => r <--$$ {0, 1}^c; $ ret (r, ((d, fd), r) :: f) end. Definition au_F_A : OracleComp (list (Bvector b)) (Bvector b) _ := [_, p ] <--$2 OC_Run _ _ _ A F_randomFunc_O nil; let coll := match (findCollision _ _ (fst (split p)) ) with | None => (nil, nil) | Some p => fst p end in $ ret (coll). Definition G2_3_bad := k_in <-$ {0, 1}^k; [p, _] <-$2 au_F_A _ _ (WCR_Oracle _ F k_in) tt; [d1, d2] <-2 p; ret (negb (eqb d1 d2) && eqb (F k_in d1) (F k_in d2)). Theorem G2_3_bad_small : Pr[G2_3_bad] == Adv_WCR _ _ F (Rnd k) au_F_A. reflexivity. Qed. Theorem G2_3_bad_equiv : Pr[x <-$ G2_3; ret (snd x)] == Pr[G2_3_bad]. unfold G2_3, G2_3_bad. inline_first. comp_skip. unfold au_F_A. simpl. inline_first. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => a = fst b)). trivial. intuition. subst. unfold F_randomFunc, WCR_Oracle. inline_first. comp_simp. case_eq (arrayLookup_f (Bvector_EqDec b) (fst x2) (F x a)); intuition. simpl. inline_first. comp_simp. simpl. eapply comp_spec_ret; intuition. simpl. inline_first. comp_skip. apply (oneVector c). apply (oneVector c). comp_simp. inline_first. comp_simp. simpl. eapply comp_spec_ret; intuition. simpl in *. intuition; subst. comp_simp. simpl. inline_first. unfold funcCollision. case_eq (findCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (fst (snd b1))))); intuition. destruct p. destruct p. simpl. comp_simp. eapply comp_spec_ret; intuition. destruct b1. simpl in *. destruct p. simpl in *. Theorem findCollision_1_correct : forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y, findCollision_1 eqd1 eqd2 ls x1 y = Some x2 -> x1 <> x2 /\ In (x2, y) ls. induction ls; intros; simpl in *. discriminate. destruct a. case_eq (eqb y b0); intros. rewrite H0 in H. case_eq (eqb x1 a); intros. rewrite H1 in H. simpl in *. eapply IHls in H. intuition. rewrite H1 in H. simpl in *. inversion H; clear H; subst. rewrite eqb_leibniz in H0. subst. intuition. subst. rewrite eqb_refl in H1. discriminate. rewrite H0 in H. simpl in *. eapply IHls in H. intuition. Qed. Theorem findCollision_correct : forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y, findCollision eqd1 eqd2 ls = Some (x1, x2, y) -> x1 <> x2 /\ In (x1, y) ls /\ In (x2, y) ls. 
heapSizeLowerBound''. Definition bootS := {| Reserved := 49; Formals := nil; Precondition := fun _ => st ~> ![ 0 =?> (heapSize' + 50 + 2) * db ts ] st |}. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "xml_driver"!"main" @ [mainS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%N;; Assert [PREmain[_] globalSched =?> 2 * 0 =?> heapSize' * db ts];; Call "malloc"!"init"(0, heapSize) [PREmain[_] globalSock =?> 1 * globalSched =?> 1 * mallocHeap 0 * db ts];; Goto "xml_driver"!"main" end }}. Lemma bootstrap_Sp_nonzero : forall sp : W, sp = 0 -> sp = (heapSize' * 4)%nat -> goodSize (heapSize' * 4) -> False. intros; eapply bootstrap_Sp_nonzero; try eassumption; eauto. Qed. Lemma bootstrap_Sp_freeable : forall sp : W, sp = (heapSize' * 4)%nat -> freeable sp 50. intros; eapply bootstrap_Sp_freeable; try eassumption; eauto. instantiate (1 := 2). unfold size in mem_size. eapply goodSize_weaken; try apply mem_size. omega. Qed. Lemma noWrap : noWrapAround 4 (wordToNat (NToW heapSize) - 1). intros. unfold NToW; rewrite NToWord_nat by auto. unfold heapSize' in *; rewrite Hide.to_nat_eq in *. rewrite wordToNat_natToWord_idempotent. apply noWrap; eauto. eapply goodSize_weaken. 2: instantiate (1 := (heapSize' * 4)%nat). unfold heapSize'; rewrite Hide.to_nat_eq; auto. unfold heapSize'; rewrite Hide.to_nat_eq; auto. Qed. Local Hint Immediate bootstrap_Sp_nonzero bootstrap_Sp_freeable noWrap. Lemma break : NToW ((heapSize + 50) * 4)%N = ((heapSize' + 50) * 4)%nat. intros. unfold NToW; rewrite NToWord_nat by auto. unfold heapSize'; rewrite N2Nat.inj_mul; auto. rewrite Hide.to_nat_eq; rewrite N2Nat.inj_add; auto. Qed. Lemma times4 : (Hide.heapSize4 heapSize : W) = (heapSize' * 4)%nat. rewrite Hide.heapSize4_eq; intros. unfold NToW; rewrite NToWord_nat by auto. unfold heapSize'; rewrite N2Nat.inj_mul; auto. rewrite Hide.to_nat_eq; auto. Qed. Lemma wordToNat_heapSize : wordToNat (NToW heapSize) = heapSize'. unfold heapSize'; rewrite Hide.to_nat_eq. unfold NToW. rewrite NToWord_nat. apply wordToNat_natToWord_idempotent. eapply goodSize_weaken. 2: instantiate (1 := (heapSize' * 4)%nat). auto. unfold heapSize'; rewrite Hide.to_nat_eq; auto. Qed. Hint Rewrite break times4 wordToNat_heapSize : sepFormula. Lemma globalSched_plus4 : Locations.globalSched ^+ natToW 4 = natToW ((heapSize' + 50) * 4 + 4). unfold Locations.globalSched, heapSize'. rewrite wplus_alt; unfold wplusN, wordBinN. unfold NToW; rewrite NToWord_nat by auto. rewrite N2Nat.inj_mul; auto. rewrite Hide.to_nat_eq; rewrite N2Nat.inj_add; auto. change (wordToNat (natToW 4)) with 4. change (N.to_nat 4) with 4. rewrite wordToNat_natToWord_idempotent. reflexivity. eapply goodSize_weaken; try apply mem_size. unfold size, heapSize'. rewrite Hide.to_nat_eq. change (N.to_nat 50) with 50. omega. Qed. Hint Rewrite globalSched_plus4 : sepFormula. Ltac t := unfold M'''.globalSched, Locations.globalSched, Locations.globalSock, localsInvariantMain; genesis; rewrite natToW_plus; reflexivity. Theorem okb : moduleOk boot. 
inversion H4; subst; auto. rewrite H3 in H9; discriminate. Qed. Fact mm_steps_DEC_1_inv k P i x p v u st : (i,DEC x p::nil) <sc P -> k <> 0 -> v#>x = S u -> P // (i,v) -[k]-> st -> exists k', k' < k /\ P // (1+i,v[u/x]) -[k']-> st. Proof. intros H1 H2 H3 H4. apply sss_steps_inv in H4. destruct H4 as [ (? & ?) | (k' & st2 & ? & H4 & H5) ]; subst; auto. destruct H2; auto. apply sss_step_subcode_inv with (1 := H1) in H4. exists k'; split. lia. inversion H4; subst; auto; rewrite H3 in H9. discriminate. inversion H9; subst; auto. Qed. End Minsky_Machine.Local Notation "i // s -1> t" := (@mm_sss _ i s t). Local Notation "P // s -[ k ]-> t" := (sss_steps (@mm_sss _) P k s t). Local Notation "P // s -+> t" := (sss_progress (@mm_sss _) P s t). Local Notation "P // s ->> t" := (sss_compute (@mm_sss _) P s t). Local Notation "P // s ~~> t" := (sss_output (@mm_sss _) P s t).Tactic Notation "mm" "sss" "INC" "with" uconstr(a) := match goal with | |- _ // _ -+> _ => apply mm_progress_INC with (x := a) | |- _ // _ ->> _ => apply mm_compute_INC with (x := a) end; auto.Tactic Notation "mm" "sss" "DEC" "zero" "with" uconstr(a) uconstr(b) := match goal with | |- _ // _ -+> _ => apply mm_progress_DEC_0 with (x := a) (k := b) | |- _ // _ ->> _ => apply mm_compute_DEC_0 with (x := a) (k := b) end; auto.Tactic Notation "mm" "sss" "DEC" "S" "with" uconstr(a) uconstr(b) uconstr(c) := match goal with | |- _ // _ -+> _ => apply mm_progress_DEC_S with (x := a) (k := b) (u := c) | |- _ // _ ->> _ => apply mm_compute_DEC_S with (x := a) (k := b) (u := c) end; auto. Tactic Notation "mm" "sss" "stop" := exists 0; apply sss_steps_0; auto.Section mm_special_ind. Variables (n : nat) (P : nat*list (mm_instr (pos n))) (se : nat * vec nat n) (Q : nat * vec nat n -> Prop). Hypothesis (HQ0 : Q se) (HQ1 : forall i œÅ v j w, (i,œÅ::nil) <sc P -> œÅ // (i,v) -1> (j,w) -> P // (j,w) ->> se -> Q (j,w) -> Q (i,v)). Theorem mm_special_ind s : P // s ->> se -> Q s. 
H1 in H. rewrite H1 in H0. inversion H; clear H; subst. simpl in *. case_eq (eqb a0 a); intuition. rewrite H in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H. subst. unfold eqbPair. simpl. repeat rewrite eqb_refl. simpl. trivial. rewrite H in H0. simpl in *. discriminate. rewrite H1 in H0. rewrite H1 in H. simpl in *. unfold eqbPair. simpl. rewrite H1. case_eq (eqb a0 a); intuition. simpl. eapply IHx1; eauto. simpl. eapply IHx1; eauto. Qed. Theorem funcCollision_true_cons : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a, funcCollision _ _ ls = true -> funcCollision _ _ (a :: ls) = true. unfold funcCollision. intuition. simpl in *. destruct (findCollision_1 eqda eqdb ls a0 b0). trivial. trivial. Qed. Theorem F_randomFunc_preserves_coll : forall c0 x d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (F_randomFunc x c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. rewrite H2 in H1. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem randomFunc_mem_preserves_coll : forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0, funcCollision _ _ (fst (split c0)) = true -> In (a, b0) (getSupport (randomFunc_mem _ _ RndR c0 d)) -> funcCollision _ _ (fst (split b0)) = true. intuition. unfold randomFunc_mem in *. destruct (arrayLookup _ c0 (a, b0)). repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. eapply funcCollision_true_cons; eauto. Qed. Theorem F_randomFunc_wf : forall x y z, well_formed_comp (F_randomFunc x y z). intuition. unfold F_randomFunc. destruct (arrayLookup_f _ y (F x z)); wftac. Qed. Theorem randomFunc_mem_wf : forall (A B : Set) x y z (w : list (A * B)) v, well_formed_comp z -> well_formed_comp (randomFunc_mem x y z w v). intuition. unfold randomFunc_mem. destruct (arrayLookup x w v); intuition; wftac. Qed. Theorem A_randomFunc_F_spec : forall x, comp_spec (fun y1 y2 => funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (snd y1))) = funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (snd y2))) /\ (funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split (snd y1))) = false -> y1 = y2)) (A (list (list (Bvector b) * Bvector b * Bvector c)) (list_EqDec (pair_EqDec (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)) (Bvector_EqDec c))) (F_randomFunc x) nil) (A (list (list (Bvector b) * Bvector b * Bvector c)) (list_EqDec (pair_EqDec (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)) (Bvector_EqDec c))) (fun (s : list (list (Bvector b) * Bvector b * Bvector c)) (a : list (Bvector b)) => randomFunc_mem (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)) (Bvector_EqDec c) ({ 0 , 1 }^c) s (a, F x a)) nil). 
] => destruct H end; eauto 10 ] | [ H1 : _, H2 : _ |- _ ] => solve [ apply (inj _ _ _ H1) in H2; subst; specialize (omitImp _ _ H1); match goal with | [ H : _ |- _ ] => apply agree in H; post; congruence end ] end; match goal with | [ x : label, H5 : LabelMap.MapsTo _ _ (Imports _) |- _ ] => destruct x; specialize (impSys' _ _ H5); intro Hi; hnf in Hi; unfold labelSys' in Hi; simpl in Hi; intuition subst; match goal with | [ H : (_, _) = (_, _) |- _ ] => injection H; clear H; intros; subst end; eauto; post; try match goal with | [ H1 : _, H2 : _ |- _ ] => solve [ apply (inj _ _ _ H1) in H2; cbv beta in H2; congruence ] end; post; match goal with | [ H : _ = _ |- _ ] => apply specs_hit in H; destruct H; intuition idtac end; match goal with | [ st' : state |- _ ] => destruct st'; simpl in *; subst end; descend; eauto; match goal with | [ H : forall x : state, _ |- _ ] => apply (Imply_sound (H _)); propxFo; descend; try (apply ILTacCommon.ignore_regs; eassumption) end end; match goal with | [ H : interp (specs _ ?stn) (![?P] (_, snd ?st))%PropX |- _ ] => match P with | context[locals _ ?V _ _] => (eapply ILTacCommon.interp_interp_himp in H; [ | apply comeOnOut ]; eapply ILTacCommon.interp_interp_himp; [ | apply goOnIn ]; eapply tickle_bytes; eauto; assert (ReadWord stn (IL.Mem (snd st)) (st#Sp ^+ $8) = Some (sel V "buffer")) by prove_ReadWord; assert (ReadWord stn (IL.Mem (snd st)) (st#Sp ^+ $12) = Some (sel V "size")) by prove_ReadWord; cbv beta in *; simpl; congruence) || (eapply ILTacCommon.interp_interp_himp in H; [ | apply comeOnOut ]; eapply ILTacCommon.interp_interp_himp; [ | apply goOnIn ]; eapply tickle_bytes; eauto; assert (ReadWord stn (IL.Mem (snd st)) (st#Sp ^+ $4) = Some (sel V "address")) by prove_ReadWord; assert (ReadWord stn (IL.Mem (snd st)) (st#Sp ^+ $8) = Some (sel V "size")) by prove_ReadWord; cbv beta in *; simpl; congruence) end end. Qed. Lemma safety' : forall st, goodState st -> forall st', sys_reachable stn prog st st' -> goodState st'. induction 2; simpl; eauto using preservation. Qed. Theorem safety : forall st mn g pre, LabelMap.MapsTo (mn, Global g) pre (Exports m) -> Labels stn (mn, Global g) = Some (fst st) -> interp (specs0 m stn) (pre (stn, snd st)) -> sys_safe stn prog st. 
H: exec _ _ _ _ (Failed _) |- _ ] => inversion H; repeat inj_existT; subst; clear H end; match goal with | [ H: fail_step _ _ _ |- _ ] => inversion H; subst; clear H end.Ltac inv_crash_step := try match goal with | [ H: exec _ _ _ _ (Crashed _ _ _) |- _ ] => inversion H; repeat inj_existT; subst; clear H end; match goal with | [ H: crash_step _ |- _ ] => inversion H; subst; clear H end.Ltac inv_exec' H := inversion H; repeat inj_existT; subst; try inv_step; try inv_fail_step; try inv_crash_step; subst; clear H.Ltac inv_exec := lazymatch goal with | [ H: exec _ _ _ (Ret _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (AlertModified) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (Debug _ _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (Bind _ _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ _ _ |- _ ] => inv_exec' H end.Section MonadLaws. Definition prog_equiv T : prog T -> prog T -> Prop := fun p1 p2 => forall m vm hm out, exec m vm hm p1 out <-> exec m vm hm p2 out. Arguments prog_equiv {T} _ _. Infix "~=" := prog_equiv (at level 50, left associativity). Theorem bind_left_id : forall T T' v (p: T -> prog T'), Bind (Ret v) p ~= p v. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_left_alert_modified : forall T' (p: unit -> prog T'), Bind (AlertModified) p ~= p tt. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_left_debug : forall T' (p: unit -> prog T') s a, Bind (Debug s a) p ~= p tt. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_right_id : forall T (p: prog T), Bind p Ret ~= p. Proof. split; intros. - inv_exec; eauto. inv_exec; eauto. - destruct out; eauto. Qed. Theorem bind_assoc : forall T T' T'' (p1: prog T) (p2: T -> prog T') (p3: T' -> prog T''), Bind (Bind p1 p2) p3 ~= Bind p1 (fun x => Bind (p2 x) p3). Proof. split; intros. - inv_exec; eauto; inv_exec; eauto. - inv_exec; eauto. inv_exec; eauto. Qed. Theorem corr2_equivalence : forall T (p p': prog T) pre, corr2 pre p' -> prog_equiv p p' -> corr2 pre p. 
Require Import VST.msl.base. Require Import VST.msl.sepalg. Require Import VST.msl.psepalg. Require Import VST.msl.sepalg_generators. Require Import VST.msl.cjoins. Require Import VST.msl.eq_dec. Definition sa_distributive (A: Type) {JOIN: Join A} := forall a b x z, join a b z -> constructive_join_sub x z -> {a' : A & {b' : A & (constructive_join_sub a' a * constructive_join_sub b' b * join a' b' x)%type}}. Definition weak_cross_split `{sepalg A} := forall a b c d z : A, join a b z -> join c d z -> exists x:(A*A*A*A), match x with (ac,ad,bc,bd) => join ac ad a /\ join bc bd b /\ join ac bc c /\ join ad bd d end. *) Theorem cross_split_distibutive {A} `{Perm_alg A}{SA: Sep_alg A}{CS: Cross_alg A} : sa_distributive A. 
y r => Node111 l y (set' q x r) end. Definition set {A} (p: positive) (x: A) (m: tree A) : tree A := match m with | Empty => Nodes (set0 p x) | Nodes m' => Nodes (set' p x m') end. Fixpoint rem' {A} (p: positive) (m: tree' A) : tree A := match p, m with | xH, Node001 r => Nodes m | xH, Node010 _ => Empty | xH, Node011 _ r => Nodes (Node001 r) | xH, Node100 l => Nodes m | xH, Node101 l r => Nodes m | xH, Node110 l _ => Nodes (Node100 l) | xH, Node111 l _ r => Nodes (Node101 l r) | xO q, Node001 r => Nodes m | xO q, Node010 y => Nodes m | xO q, Node011 y r => Nodes m | xO q, Node100 l => Node (rem' q l) None Empty | xO q, Node101 l r => Node (rem' q l) None (Nodes r) | xO q, Node110 l y => Node (rem' q l) (Some y) Empty | xO q, Node111 l y r => Node (rem' q l) (Some y) (Nodes r) | xI q, Node001 r => Node Empty None (rem' q r) | xI q, Node010 y => Nodes m | xI q, Node011 y r => Node Empty (Some y) (rem' q r) | xI q, Node100 l => Nodes m | xI q, Node101 l r => Node (Nodes l) None (rem' q r) | xI q, Node110 l y => Nodes m | xI q, Node111 l y r => Node (Nodes l) (Some y) (rem' q r) end. Definition remove' := Eval cbv [rem' Node] in @rem'. Definition remove {A} (p: positive) (m: tree A) : tree A := match m with | Empty => Empty | Nodes m' => remove' p m' end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. reflexivity. Qed. Lemma gEmpty: forall (A: Type) (i: positive), get i (@Empty A) = None. Proof. reflexivity. Qed. Lemma gss0: forall {A} p (x: A), get' p (set0 p x) = Some x. Proof. induction p; simpl; auto. Qed. Lemma gso0: forall {A} p q (x: A), p<>q -> get' p (set0 q x) = None. Proof. induction p; destruct q; simpl; intros; auto; try apply IHp; congruence. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: tree A), get i (set i x m) = Some x. 
Require Import processus. Require Import fresh.Unset Standard Proposition Elimination Names.Theorem gettype_not_added_name : forall (G : env) (p q : PP) (t : type), p <> q -> addenv G p t q = G q. Proof. intros G p q t p_not_q. unfold addenv in |- *. case (PP_decidable p q). intro absurd; elim p_not_q; assumption. intro; reflexivity. Qed.Theorem gettype_added_name : forall (G : env) (p : PP) (t : type), addenv G p t p = t. Proof. intros. unfold addenv in |- *. case (PP_decidable p p). intro; reflexivity. intro absurd; elim absurd; reflexivity. Qed.Theorem eqv_addenv : forall (G D : env) (p : PP) (t : type), eqvenv G D -> eqvenv (addenv G p t) (addenv D p t). Proof. intros G D p t eq1. unfold eqvenv in |- *. intro r; unfold addenv in |- *. case (PP_decidable p r). intro; reflexivity. intro; apply eq1. Qed.Theorem eqv_trans : forall G G' G'' : env, eqvenv G G' -> eqvenv G' G'' -> eqvenv G G''. Proof. intros. unfold eqvenv in |- *. intros. transitivity (G' p). apply H. apply H0. Qed. Theorem eqv_typing : forall G D : env, eqvenv G D -> forall P : proc, typing G P -> typing D P. 
(1 := H1) (a := a); auto. Qed. Theorem distinct_pbleaves_pbadd_prop2 : forall a1 l1 l, ~ inpb (pbleaf a1) l -> distinct_pbleaves l -> distinct_pbleaves (pbadd a1 l l1). Proof using. intros a1 l1 l H H0; apply all_pbleaves_unique. apply ulist_pbadd_prop2; auto. apply all_pbleaves_ulist; auto. Qed. Theorem fold_pbadd_prop_left : forall l a, l <> nil -> fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) (map (fun v => match v with | (a1, b1) => (a1, false :: b1) end) l) = pbleft (fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) l). Proof using. intros l; elim l. intros a H; elim H; simpl in |- *; auto. simpl in |- *; intros (a1, l1) l0; case l0. case l1; simpl in |- *; auto. intros p l2 H a H0. rewrite H; auto. red in |- *; intros H1; discriminate. Qed. Theorem fold_pbadd_prop_right : forall l a, l <> nil -> fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) (map (fun v => match v with | (a1, b1) => (a1, true :: b1) end) l) = pbright (fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf a) l). Proof using. intros l; elim l. intros a H; elim H; simpl in |- *; auto. simpl in |- *; intros (a1, l1) l0; case l0. case l1; simpl in |- *; auto. intros p l2 H a H0. rewrite H; auto. red in |- *; intros H1; discriminate. Qed. Theorem fold_pbadd_prop_node : forall l a, l <> nil -> fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbright a) (map (fun v => match v with | (a1, b1) => (a1, false :: b1) end) l) = pbnode (fold_right (fun a (c : pbtree) => pbadd (fst a) c (snd a)) (pbleaf empty) l) a. Proof using. intros l; elim l. intros a H; elim H; simpl in |- *; auto. simpl in |- *; intros (a1, l1) l0; case l0. case l1; simpl in |- *; auto. intros p l2 H a H0. rewrite H; auto. red in |- *; intros H1; discriminate. Qed. Definition pbbuild (l : code A) : pbtree := fold_right (fun a c => pbadd (fst a) c (snd a)) (pbleaf empty) l. Theorem pbfree_pbbuild_prop1 : forall a l1 l2, l2 <> nil -> unique_prefix ((a, l1) :: l2) -> pbfree l1 (pbbuild l2). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main. From Categories Require Import Cat.Cat. From Categories Require Import Basic_Cons.Terminal. From Categories Require Import Archetypal.Discr.Discr. From Categories Require Import NatTrans.NatTrans NatTrans.NatIso. Program Definition Functor_To_1_Cat (C' : Category) : (C' --> 1)%functor := {| FO := fun x => tt; FA := fun a b f => tt; F_id := fun _ => eq_refl; F_compose := fun _ _ _ _ _ => eq_refl |}. Program Instance Cat_Term : (ùüô_ Cat)%object := { terminal := 1%category; t_morph := fun x => Functor_To_1_Cat x }.Next Obligation. Proof. Func_eq_simpl; FunExt; match goal with [|- ?A = ?B] => destruct A; destruct B end; trivial. Qed. Section From_Term_Cat. Context {C : Category} (F : (1 --> C)%functor). Theorem From_Term_Cat : ‚àÄ h, (F @_a tt tt h)%morphism = id. 
= Some x2 -> x1 <> x2 /\ In (x2, y) ls. induction ls; intros; simpl in *. discriminate. destruct a. case_eq (eqb y b0); intros. rewrite H0 in H. case_eq (eqb x1 a); intros. rewrite H1 in H. simpl in *. eapply IHls in H. intuition. rewrite H1 in H. simpl in *. inversion H; clear H; subst. rewrite eqb_leibniz in H0. subst. intuition. subst. rewrite eqb_refl in H1. discriminate. rewrite H0 in H. simpl in *. eapply IHls in H. intuition. Qed. Theorem findCollision_correct : forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y, findCollision eqd1 eqd2 ls = Some (x1, x2, y) -> x1 <> x2 /\ In (x1, y) ls /\ In (x2, y) ls. induction ls; intros; simpl in *; subst; try discriminate. destruct a. case_eq (findCollision_1 eqd1 eqd2 ls a b0); intros. rewrite H0 in H. eapply findCollision_1_correct in H0. intuition. subst. inversion H; clear H; subst. intuition. inversion H; clear H; subst. intuition. inversion H; clear H; subst. intuition. rewrite H0 in H. eapply IHls in H. intuition. Qed. apply findCollision_correct in H2. intuition. case_eq (eqb l l0); intuition. rewrite eqb_leibniz in H4. intuition. simpl. assert (forall a b, In (a, b) (fst (split l1)) -> b = F x a). intuition. eapply (@oc_comp_invariant _ _ _ _ _ (fun l1 => forall a b, In (a, b) (fst (split l1)) -> b = F x a)) in H0. eauto. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. intuition. simpl in *. intuition. trivial. assert (b0 = F x l). eapply H6. trivial. eapply H6 in H5. subst. rewrite H7. rewrite eqbBvector_complete. trivial. comp_simp. rewrite eqb_refl. simpl. eapply comp_spec_eq_refl. Qed. Theorem G2_3_4_close : | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <= Adv_WCR _ _ F (Rnd k) au_F_A. eapply leRat_trans. eapply fundamental_lemma_h. eapply G2_3_4_bad_eq . eapply G2_3_4_eq_until_bad. rewrite G2_3_bad_equiv. rewrite G2_3_bad_small. intuition. Qed. Definition G2_5 := [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil; ret b. Theorem G2_4_5_equiv : Pr[x <-$ G2_4; ret fst x] == Pr[G2_5]. 
(gcArrIdent:positive) (l:N) (vs : list positive) (ind : list N) (fenv : fun_env) (finfo_env : fun_info_env) := (reserve' argsIdent allocIdent limitIdent gcIdent threadInfIdent tinfIdent nParam gcArrIdent (Z.of_N (l + 2)) vs ind fenv finfo_env).Inductive right_param_asgn: list positive -> list N -> statement -> Prop := | asgn_nil: right_param_asgn nil nil Sskip | asgn_cons: forall x xs n ns s, right_param_asgn xs ns s -> right_param_asgn (x::xs) (n::ns) ((x ::= args[Z.of_N n]);s).Definition lenv_param_asgn (lenv lenv':temp_env) (xs:list positive) (vs:list Values.val): Prop := forall i, (forall z, nthN xs z = Some i -> M.get i lenv' = nthN vs z) /\ (~ List.In i xs -> M.get i lenv' = M.get i lenv).Inductive lenv_param_asgn_i: temp_env -> temp_env -> list positive -> list Values.val -> Prop := | LPA_nil: forall lenv, lenv_param_asgn_i lenv lenv [] [] | LPA_cons: forall lenv lenv' ys vs y v, lenv_param_asgn_i (M.set y v lenv) lenv' ys vs -> lenv_param_asgn_i lenv lenv' (y::ys) (v::vs). Theorem lenv_param_asgn_i_length: forall ys vs lenv lenv', lenv_param_asgn_i lenv lenv' ys vs -> length ys = length vs. Proof. induction ys; intros. inv H; reflexivity. inv H. simpl. eapply IHys in H5. auto. Qed. Theorem lenv_param_asgn_rel: forall ys vs lenv lenv', lenv_param_asgn_i lenv lenv' ys vs -> NoDup ys -> lenv_param_asgn lenv lenv' ys vs. Proof. induction ys; intros. - inv H. constructor; intros. inv H. reflexivity. - inv H. eapply IHys in H6. split; intros; specialize (H6 i); destruct H6. + rewrite nthN_equation in *. destruct (var_dec a i). * destruct z. subst. rewrite H2. rewrite M.gss. reflexivity. inv H0; auto. apply H1 in H. auto. * destruct z. exfalso. inv H. apply n; auto. apply H1 in H. auto. + rewrite M.gso in H2. apply H2. intro. apply H. constructor 2. auto. intro. apply H. constructor; auto. + inv H0; auto. Qed.Theorem e_lenv_param_asgn_i: forall ys lenv vs, length ys = length vs -> NoDup ys -> exists lenv', lenv_param_asgn_i lenv lenv' ys vs. Proof. induction ys; intros. - destruct vs; inv H. exists lenv. constructor. - destruct vs; inv H. inv H0. specialize (IHys (M.set a v lenv)). specialize (IHys _ H2 H4). destruct IHys as [lenv' Hlenv']. eexists; constructor; eauto. Qed.Theorem e_lenv_param_asgn: forall lenv ys vs, length ys = length vs -> NoDup ys -> exists lenv', lenv_param_asgn lenv lenv' ys vs. Proof. intros. assert (Hi := e_lenv_param_asgn_i ys lenv vs H H0). destruct Hi. apply lenv_param_asgn_rel in H1; eauto. Qed. Theorem get_list_nth_get' (B:Type): forall (vs : list B) rho v xs N, get_list xs rho = Some vs -> nthN vs N = Some v -> exists x, nthN xs N = Some x /\ M.get x rho = Some v. 
x... now apply He, Rgt_not_eq. now rewrite <- d_eq, Y. rewrite u_eq, round_UP_small_pos with (ex:=e); trivial. 2: now apply He, Rgt_not_eq. rewrite ln_beta_bpow. ring_simplify (fexp e + 1 - 1)%Z. replace (fexp (fexp e)) with (fexp e). case exists_NE_; intros V. contradict V; rewrite Even_beta; discriminate. rewrite (proj2 (V e)); omega. apply sym_eq, valid_exp; omega. Qed.Lemma Fm: generic_format beta fexpe m. case (d_ge_0); intros Y.destruct m_eq as (g,(Hg1,Hg2)); trivial. apply generic_format_F2R' with g. now apply sym_eq. intros H; unfold canonic_exp; rewrite Hg2. rewrite ln_beta_m; trivial. rewrite <- Fexp_d; trivial. rewrite Cd. unfold canonic_exp. generalize (fexpe_fexp (ln_beta beta (F2R d))). omega.destruct m_eq_0 as (g,(Hg1,Hg2)); trivial. apply generic_format_F2R' with g. assumption. intros H; unfold canonic_exp; rewrite Hg2. rewrite ln_beta_m_0; try assumption. apply Zle_trans with (1:=fexpe_fexp _). assert (fexp (ln_beta beta (F2R u)-1) < fexp (ln_beta beta (F2R u))+1)%Z;[idtac|omega]. now apply fexp_m_eq_0. Qed.Lemma Zm: exists g : float beta, F2R g = m /\ canonic beta fexpe g /\ Zeven (Fnum g) = true. Proof with auto with typeclass_instances. case (d_ge_0); intros Y.destruct m_eq as (g,(Hg1,Hg2)); trivial. apply exists_even_fexp_lt. exists g; split; trivial. rewrite Hg2. rewrite ln_beta_m; trivial. rewrite <- Fexp_d; trivial. rewrite Cd. unfold canonic_exp. generalize (fexpe_fexp (ln_beta beta (F2R d))). omega.destruct m_eq_0 as (g,(Hg1,Hg2)); trivial. apply exists_even_fexp_lt. exists g; split; trivial. rewrite Hg2. rewrite ln_beta_m_0; trivial. apply Zle_lt_trans with (1:=fexpe_fexp _). assert (fexp (ln_beta beta (F2R u)-1) < fexp (ln_beta beta (F2R u))+1)%Z;[idtac|omega]. now apply fexp_m_eq_0. Qed. Lemma DN_odd_d_aux: forall z, (F2R d<= z< F2R u)%R -> Rnd_DN_pt (generic_format beta fexp) z (F2R d). Proof with auto with typeclass_instances. intros z Hz1. replace (F2R d) with (round beta fexp Zfloor z). apply round_DN_pt... case (Rnd_DN_UP_pt_split _ _ _ _ Hd Hu (round beta fexp Zfloor z)). apply generic_format_round... intros Y; apply Rle_antisym; trivial. apply round_DN_pt... apply Hd. apply Hz1. intros Y; absurd (z < z)%R. auto with real. apply Rlt_le_trans with (1:=proj2 Hz1), Rle_trans with (1:=Y). apply round_DN_pt... Qed.Lemma UP_odd_d_aux: forall z, (F2R d< z <= F2R u)%R -> Rnd_UP_pt (generic_format beta fexp) z (F2R u). Proof with auto with typeclass_instances. intros z Hz1. replace (F2R u) with (round beta fexp Zceil z). apply round_UP_pt... case (Rnd_DN_UP_pt_split _ _ _ _ Hd Hu (round beta fexp Zceil z)). apply generic_format_round... intros Y; absurd (z < z)%R. auto with real. apply Rle_lt_trans with (2:=proj1 Hz1), Rle_trans with (2:=Y). apply round_UP_pt... intros Y; apply Rle_antisym; trivial. apply round_UP_pt... apply Hu. apply Hz1. Qed. Theorem round_odd_prop_pos: round beta fexp (Znearest choice) (round beta fexpe Zrnd_odd x) = round beta fexp (Znearest choice) x. 
::: (Fm * rep fsxp Ftop tree ilist frees mscs' sm) ]]] * [[ r = INODE.ABytes (DFAttr f) /\ MSAlloc mscs' = MSAlloc mscs ]] CRASH:hm' LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' >} file_get_sz fsxp inum mscs. Proof. unfold file_get_sz; intros. step. step. step. step. Unshelve. all: exact tt. Qed. Hint Extern 1 ({{_}} Bind (file_get_sz _ _ _) _) => apply file_get_sz_ok : prog. Ltac xcrash_solve := repeat match goal with | [ H: forall _ _ _, _ =p=> (?crash _) |- _ =p=> (?crash _) ] => eapply pimpl_trans; try apply H; cancel | [ |- crash_xform (LOG.rep _ _ _ _ _ _) =p=> _ ] => rewrite LOG.notxn_intact; cancel | [ H: crash_xform ?rc =p=> _ |- crash_xform ?rc =p=> _ ] => rewrite H; xform_norm end. Ltac intuition' := match goal with | [|- _ /\ _] => split; intuition' | [|- True] => auto | _ => idtac end. Ltac simpl_idempred_l := simpl; repeat xform_dist; repeat xform_deex_l; xform_dist; rewrite crash_xform_lift_empty; norml; unfold stars; simpl; match goal with | [ H: crash_xform ?x =p=> crash_xform _ |- context[crash_xform ?x] ] => rewrite H end; repeat xform_dist; try rewrite sep_star_or_distr; rewrite LOG.crash_xform_idempred. Ltac simpl_idempred_r := recover_ro_ok; (norml; unfold stars; simpl); (norm'r; unfold stars; simpl); try (cancel); intuition'; repeat xform_dist; repeat rewrite crash_xform_idem. Theorem read_fblock_ok : forall fsxp inum off mscs, {< ds sm Fm Ftop tree pathname f Fd vs ilist frees, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: (Fm * rep fsxp Ftop tree ilist frees mscs sm) ]]] * [[ find_subtree pathname tree = Some (TreeFile inum f) ]] * [[[ (DFData f) ::: (Fd * off |-> vs) ]]] POST:hm' RET:^(mscs', r) LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[[ ds!! ::: (Fm * rep fsxp Ftop tree ilist frees mscs' sm) ]]] * [[ r = fst vs /\ MSAlloc mscs' = MSAlloc mscs ]] CRASH:hm' LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' >} read_fblock fsxp inum off mscs. Proof. unfold read_fblock; intros. step. safestep. safestep. all: try eassumption. eapply pimpl_ok2; monad_simpl. apply LOG.commit_ro_ok. cancel. step. step. pimpl_crash; cancel. rewrite LOG.notxn_intact. apply LOG.intact_idempred. pimpl_crash; cancel. apply LOG.intact_idempred. pimpl_crash. norml. clear H. cancel. apply LOG.notxn_idempred. Unshelve. all: exact tt. Qed. Hint Extern 1 ({{_}} Bind (read_fblock _ _ _ _) _) => apply read_fblock_ok : prog. Theorem file_set_attr_ok : forall fsxp inum attr mscs, {< ds sm pathname Fm Ftop tree f ilist frees, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: (Fm * rep fsxp Ftop tree ilist frees mscs sm) ]]] * [[ find_subtree pathname tree = Some (TreeFile inum f) ]] POST:hm' RET:^(mscs', ok) [[ MSAlloc mscs' = MSAlloc mscs ]] * ([[ isError ok ]] * (LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[ BFILE.mscs_same_except_log mscs mscs' ]] * [[[ ds!! ::: (Fm * rep fsxp Ftop tree ilist frees mscs' sm) ]]]) \/ ([[ ok = OK tt ]] * exists d tree' f' ilist', LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn (pushd d ds)) (MSLL mscs') sm hm' * [[[ d ::: (Fm * rep fsxp Ftop tree' ilist' frees mscs' sm)]]] * [[ tree' = update_subtree pathname (TreeFile inum f') tree ]] * [[ f' = mk_dirfile (DFData f) attr ]] * [[ dirtree_safe ilist (BFILE.pick_balloc frees (MSAlloc mscs')) tree ilist' (BFILE.pick_balloc frees (MSAlloc mscs')) tree' ]] * [[ BFILE.treeseq_ilist_safe inum ilist ilist' ]]) ) XCRASH:hm' LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) ds hm' \/ exists d tree' f' ilist' mscs', [[ MSAlloc mscs' = MSAlloc mscs ]] * LOG.idempred (FSXPLog fsxp) (SB.rep fsxp) (pushd d ds) hm' * [[[ d ::: (Fm * rep fsxp Ftop tree' ilist' frees mscs' sm)]]] * [[ tree' = update_subtree pathname (TreeFile inum f') tree ]] * [[ f' = mk_dirfile (DFData f) attr ]] * [[ dirtree_safe ilist (BFILE.pick_balloc frees (MSAlloc mscs')) tree ilist' (BFILE.pick_balloc frees (MSAlloc mscs')) tree' ]] * [[ BFILE.treeseq_ilist_safe inum ilist ilist' ]] >} file_set_attr fsxp inum attr mscs. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Representable.Hom_Func. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations Ext_Cons.Prod_Cat.Nat_Facts. From Categories Require Import Adjunction.Adjunction. From Categories Require Import KanExt.Local. From Categories Require Import Basic_Cons.Terminal.Local Open Scope functor_scope. Section Facts. Context {C C' : Category} (p : C --> C') {D : Category} (F : C --> D). Section LoKan_Cone_Morph_eq_simplify. Context {Cn Cn' : LoKan_Cone p F} (M M' : LoKan_Cone_Morph Cn Cn'). Theorem LoKan_Cone_Morph_eq_simplify : M = M' :> (_ --> _)%nattrans ‚Üí M = M'. Proof. intros H. destruct M; destruct M'; cbn in *. ElimEq. PIR. trivial. Qed. End LoKan_Cone_Morph_eq_simplify. Section LoKan_id_Cone_Morph. Context (Cn : LoKan_Cone p F). Local Hint Extern 1 => apply NatTrans_eq_simplify; cbn : core. Program Definition LoKan_id_Cone_Morph : LoKan_Cone_Morph Cn Cn := {| cone_morph := NatTrans_id _ |}. End LoKan_id_Cone_Morph. Section LoKan_Cone_Morph_compose. Context {Cn Cn' Cn'' : LoKan_Cone p F} (h : LoKan_Cone_Morph Cn Cn') (h' : LoKan_Cone_Morph Cn' Cn''). Program Definition LoKan_Cone_Morph_compose : LoKan_Cone_Morph Cn Cn'' := {| cone_morph := NatTrans_compose h h' |}. Next Obligation. Proof. rewrite (cone_morph_com h). rewrite (cone_morph_com h'). rewrite NatTrans_compose_assoc. rewrite NatTrans_comp_hor_comp. rewrite NatTrans_id_unit_right. trivial. Qed. End LoKan_Cone_Morph_compose. Section LoKan_Cone_Morph_compose_assoc. Context {Cn Cn' Cn'' Cn''' : LoKan_Cone p F} (h : LoKan_Cone_Morph Cn Cn') (h' : LoKan_Cone_Morph Cn' Cn'') (h'' : LoKan_Cone_Morph Cn'' Cn'''). Theorem LoKan_Cone_Morph_compose_assoc : LoKan_Cone_Morph_compose h (LoKan_Cone_Morph_compose h' h'') = LoKan_Cone_Morph_compose (LoKan_Cone_Morph_compose h h') h''. Proof. apply LoKan_Cone_Morph_eq_simplify. apply NatTrans_compose_assoc. Qed. End LoKan_Cone_Morph_compose_assoc. Section LoKan_id_Cone_Morph_unit. Context {Cn Cn' : LoKan_Cone p F} (h : LoKan_Cone_Morph Cn Cn'). Theorem LoKan_id_Cone_Morph_unit_right : LoKan_Cone_Morph_compose (LoKan_id_Cone_Morph _) h = h. 
AEQ V} {A : Type} : Proper (pointwise_relation A pimpl ==> pimpl) (@exis AT AEQ V A). Proof. firstorder. Qed.Example pimpl_exists_rewrite : forall AT AEQ V (p : @pred AT AEQ V) q, p =p=> q -> (exists x, p * x) =p=> (exists x, q * x). Proof. intros. setoid_rewrite H. reflexivity. Qed. Instance exists_proper_pimpl_impl {AT AEQ V} {A : Type} : Proper (pointwise_relation A piff ==> eq ==> iff) (@exis AT AEQ V A). Proof. intros a b Hab m1 m2 Hm. split; unfold Basics.impl, exis; intros; deex; eexists. eapply Hab; eauto. eapply Hab; eauto. Qed. Instance lift_empty_proper_iff {AT AEQ V} : Proper (iff ==> @piff _ _ _) (@lift_empty AT AEQ V). Proof. firstorder. Qed. Instance lift_empty_proper_impl {AT AEQ V} : Proper (Basics.impl ==> @pimpl _ _ _) (@lift_empty AT AEQ V). Proof. firstorder. Qed.Instance lift_empty_proper_eq {AT AEQ V} : Proper (eq ==> eq) (@lift_empty AT AEQ V). Proof. congruence. Qed.Instance lift_empty_proper_expanded_impl {AT AEQ V} : Proper (Basics.impl ==> eq ==> Basics.impl) (@lift_empty AT AEQ V). Proof. unfold lift_empty. intros a b Hab m1 m2 Hm H; subst. intuition. Qed.Instance lift_empty_proper_expanded_flipimpl {AT AEQ V} : Proper (Basics.flip Basics.impl ==> eq ==> Basics.flip Basics.impl) (@lift_empty AT AEQ V). Proof. unfold lift_empty. intros a b Hab m1 m2 Hm H; subst. intuition. Qed.Instance lift_empty_proper_expanded_iff {AT AEQ V} : Proper (iff ==> eq ==> iff) (@lift_empty AT AEQ V). Proof. unfold lift_empty. intros a b Hab m1 m2 Hm; subst. intuition. Qed.Instance funext_subrelation {A f R} {subf : subrelation R eq}: subrelation (@pointwise_relation A f R) eq. Proof. unfold pointwise_relation. intros a b Hab. apply functional_extensionality; auto. Qed. Global Program Instance eq_equivalence {A} : Equivalence (@eq A) | 0. Instance pred_apply_pimpl_proper {AT AEQ V} : Proper (eq ==> pimpl ==> Basics.impl) (@pred_apply AT AEQ V). Proof. unfold pred_apply. intros ma mb Hmab p q Hpq H. subst. auto. Qed.Instance pred_apply_pimpl_flip_proper {AT AEQ V} : Proper (eq ==> Basics.flip pimpl ==> Basics.flip Basics.impl) (@pred_apply AT AEQ V). Proof. unfold pred_apply. intros ma mb Hmab p q Hpq H. subst. auto. Qed.Instance pred_apply_piff_proper {AT AEQ V} : Proper (eq ==> piff ==> iff) (@pred_apply AT AEQ V). Proof. unfold pred_apply. intros ma mb Hmab p q Hpq. subst. destruct Hpq. intuition. Qed. Example pred_apply_rewrite : forall AT AEQ V p q (m : @mem AT AEQ V), m ## p*q -> m ## q*p. Proof. intros. rewrite sep_star_comm1 in H. auto. Qed. Theorem diskIs_extract : forall AT AEQ V a v (m : @mem AT AEQ V), (exists F, F * a |-> v)%pred m -> (diskIs m =p=> diskIs (mem_except m a) * a |-> v). 
d2 d3, R d1 d2 -> R d2 d3 -> R d1 d3) -> (forall d1 d2 d3, R d1 d2 -> seq_step R d2 d3 -> seq_step R d1 d3) -> (forall d1 d2 d3, seq_step R d1 d2 -> R d2 d3 -> seq_step R d1 d3) -> seq_step R d1 d2 -> seq_step R d2 d3 -> seq_step R d1 d3. Proof. intros R d1 d2 d3 TR RL RR H12. generalize dependent d3. induction H12; intros d3 H21. - inversion H21; subst; constructor; auto. - remember (scons n s2) as s. induction H21; inversion Heqs; subst; try clear Heqs. + constructor. eapply TR; eauto. + apply seq_cons_z_l. eapply RL; eauto. + apply seq_cons_z_r. apply IHseq_step; auto. - apply seq_cons_z_l. apply IHseq_step. apply H21. - remember (scons 0 s2) as s. induction H21; inversion Heqs; subst; try clear Heqs. + apply seq_cons_z_r. eapply RR. apply H12. exact R0. + apply IHseq_step. exact H21. + apply seq_cons_z_r. apply IHseq_step0; auto. Qed. Lemma seq_trans' : forall (R:stream nat -> stream nat -> Prop) (s t u : stream nat), (forall d, paco2 seq_step R d d) -> (forall d1 d2 d3, seq_step R d1 d2 -> seq_step R d2 d3 -> seq_step R d1 d3) -> (forall d1 d2 d3, R d1 d2 -> seq_step R d2 d3 -> seq_step R d1 d3) -> (forall d1 d2 d3, seq_step R d1 d2 -> R d2 d3 -> seq_step R d1 d3) -> paco2 seq_step R s t -> paco2 seq_step R t u -> paco2 seq_step R s u. Proof.Admitted.Lemma seq_r_trans' : forall (R:stream nat -> stream nat -> Prop) (d1 d2 d3 : stream nat), (forall d1 d2 d3, seq_step R d1 d2 -> seq_step R d2 d3 -> seq_step R d1 d3) -> (forall s t u, paco2 seq_step R s t -> paco2 seq_step R t u -> paco2 seq_step R s u) -> paco2 seq_step R d1 d2 -> seq_step R d2 d3 -> seq_step R d1 d3. Proof. intros. generalize dependent d1. induction H2; intros. - punfold H1. remember snil as d2. induction H1; inversion Heqd2; try subst. + constructor. + apply seq_cons_z_l. apply IHseq_step; auto. Admitted. Section S_EQUIV_COIND. Variable R : stream nat -> stream nat -> Prop. Variables (p:stream nat) (q:stream nat). Hypothesis Hrpq : R p q. Hypothesis H : forall d1 d2, R d1 d2 -> s_equiv_step R d1 d2. Theorem s_equiv_coind : s_equiv p q. 
auto. apply ppc_nZ; auto. apply divTerm_ppcr; auto. Qed. Theorem ppc_multTerm_divP : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) (ppc a b). intros a b H' H'0. elim ppc_is_ppcm; auto. Qed. Hint Resolve ppc_multTerm_divP. Theorem divP_comp : forall a b c d : Term A n, divP a c -> eqTerm (A:=A) eqA (n:=n) a b -> eqTerm (A:=A) eqA (n:=n) c d -> divP b d. intros a b c d H'; generalize b d; elim H'. intros a0 b0 nZa0 nZb0 H'2 b1 d0 H'3 H'4; auto. cut (~ zeroP (A:=A) A0 eqA (n:=n) d0); [ intros nZd0 | auto ]. apply divTerm_def with (nZb := nZd0); auto. red in |- *; intros nz1; absurd (zeroP (A:=A) A0 eqA (n:=n) a0); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := b1); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := a0); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a0 nZb0) b0); auto. red in |- *; intros nz1; absurd (zeroP (A:=A) A0 eqA (n:=n) b0); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := d0); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem divP_multTerm_l : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c a. intros a b c H' H'0 H'1. apply divP_comp with (a := multTerm (A:=A) multA (n:=n) a b) (c := a); auto. Qed. Theorem divP_multTerm_r : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c b. intros a b c H' H'0 H'1. apply divP_comp with (a := multTerm (A:=A) multA (n:=n) a b) (c := b); auto. Qed. Hint Resolve divP_multTerm_r divP_multTerm_l. Theorem divP_ppcl : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (ppc a b) a. 
Require Import Bedrock.Platform.Thread Bedrock.Platform.Arrays8 Bedrock.Platform.MoreArrays Bedrock.Platform.Buffers Bedrock.Platform.Io Bedrock.Platform.tests.StringDb. Require Import Coq.Strings.Ascii.Definition W_of_ascii (ch : ascii) : W := N_of_ascii ch. Coercion W_of_ascii : ascii >-> W.Local Hint Extern 1 (@eq W _ _) => words. Section strings. Open Scope Sep_scope. Fixpoint strings (n : nat) (p : W) : HProp := Ex len, p =*> len * match n with | O => [| len = 0 |] | S n' => [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Definition strings' (n : nat) (p len : W) : HProp := match n with | O => [| len = 0 |] | S n' => [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Theorem strings_fwd : forall n p, strings n p ===> Ex len, p =*> len * strings' n p len. 
rewrite Rmult_assoc. rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r. change (bpow 0) with (Z2R 1). rewrite <- Z2R_plus. rewrite Ztrunc_Z2R. rewrite Z2R_plus. rewrite Rmult_plus_distr_r. now rewrite Rmult_1_l. now apply Rgt_not_eq. rewrite Rabs_pos_eq. split. apply Rle_trans with (1 := proj1 Ex'). pattern x at 1 ; rewrite <- Rplus_0_r. apply Rplus_le_compat_l. apply ulp_ge_0. exact H. apply Rplus_le_le_0_compat. now apply Rlt_le. apply ulp_ge_0. rewrite H. apply generic_format_bpow. apply valid_exp. destruct (Zle_or_lt ex (fexp ex)) ; trivial. elim Rlt_not_le with (1 := Zx). rewrite Fx. replace (Ztrunc (scaled_mantissa beta fexp x)) with Z0. rewrite F2R_0. apply Rle_refl. unfold scaled_mantissa. rewrite canonic_exp_fexp with (1 := Ex). destruct (mantissa_small_pos beta fexp x ex) ; trivial. rewrite Ztrunc_floor. apply sym_eq. apply Zfloor_imp. split. now apply Rlt_le. exact H2. now apply Rlt_le. now apply Rlt_le. Qed.Theorem generic_format_pred_pos : forall x, F x -> (0 < x)%R -> F (pred_pos x). Proof. intros x Fx Zx. unfold pred_pos; case Req_bool_spec; intros H. now apply generic_format_pred_aux2. now apply generic_format_pred_aux1. Qed. Theorem generic_format_succ : forall x, F x -> F (succ x). Proof. intros x Fx. unfold succ; case Rle_bool_spec; intros Zx. destruct Zx as [Zx|Zx]. now apply generic_format_succ_aux1. rewrite <- Zx, Rplus_0_l. apply generic_format_ulp_0. apply generic_format_opp. apply generic_format_pred_pos. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem generic_format_pred : forall x, F x -> F (pred x). Proof. intros x Fx. unfold pred. apply generic_format_opp. apply generic_format_succ. now apply generic_format_opp. Qed.Theorem pred_pos_lt_id : forall x, (x <> 0)%R -> (pred_pos x < x)%R. Proof. intros x Zx. unfold pred_pos. case Req_bool_spec; intros H.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. rewrite ulp_neq_0; trivial. apply bpow_gt_0. Qed.Theorem succ_gt_id : forall x, (x <> 0)%R -> (x < succ x)%R. Proof. intros x Zx; unfold succ. case Rle_bool_spec; intros Hx. pattern x at 1; rewrite <- (Rplus_0_r x). apply Rplus_lt_compat_l. rewrite ulp_neq_0; trivial. apply bpow_gt_0. pattern x at 1; rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar. apply pred_pos_lt_id. now auto with real. Qed. Theorem pred_lt_id : forall x, (x <> 0)%R -> (pred x < x)%R. Proof. intros x Zx; unfold pred. pattern x at 2; rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar. apply succ_gt_id. now auto with real. Qed.Theorem succ_ge_id : forall x, (x <= succ x)%R. Proof. intros x; case (Req_dec x 0). intros V; rewrite V. unfold succ; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l; apply ulp_ge_0. intros; left; now apply succ_gt_id. Qed. Theorem pred_le_id : forall x, (pred x <= x)%R. 
Set Warnings "-notation-overridden". From Coq Require Import ssreflect ssrbool ssrfun. From mathcomp Require Import ssrnat seq eqtype. Set Bullet Behavior "Strict Subproofs". Require Import Coq.Sorting.Sorted. Require Import GHC.Base Proofs.GHC.Base. Require Import Data.Foldable Proofs.Data.Foldable. Require Import Data.Bits Proofs.Data.Bits.Popcount. Require Import Data.IntSet.Internal. Require Import Utils.Containers.Internal.BitUtil. Require Import DyadicIntervals. Require Import IntSetProofs. Require Import BitUtils. Require Import HSUtil SortedUtil. Notation list := Coq.Init.Datatypes.list. Notation seq := Coq.Lists.List.seq. Notation reflect := ssrbool.reflect. Theorem bitcount_0_1_power (n : Word) : bitcount #0 n = #1 <-> exists i, n = (2^i)%N. Proof. rewrite /bitcount /popCount /=. split=> [/N_popcount_1_pow2 [i def_n] | [i ->{n}]]. - by exists i. - apply N_popcount_pow2. Qed.Theorem WF_Bin_mask_power_N {p : Prefix} {m : Mask} {l r : IntSet} : WF (Bin p m l r) -> ex (fun i => m = 2^i)%N. Proof. move=> /valid_maskPowerOfTwo /= /and3P [/Eq_eq BITS _ _]. by apply bitcount_0_1_power. Qed. Theorem WF_Bin_children (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF l /\ WF r. Proof. case=> fn; inversion 1 as [|s bounds fn' desc]; subst s fn'; inversion desc as [|l' bounds_l fn_l r' bounds_r fn_r p' m' bounds' fn' desc_l desc_r is_pos sub_l sub_r def_p def_m spec_fn]; subst p' m' l' r' bounds' fn'. split; [exists fn_l | exists fn_r]; eauto using DescSem. Qed.Corollary WF_Bin_left (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF l. Proof. by move=> /WF_Bin_children []. Qed.Corollary WF_Bin_right (p : Prefix) (m : Mask) (l r : IntSet) : WF (Bin p m l r) -> WF r. Proof. by move=> /WF_Bin_children []. Qed. Theorem toList_sorted (s : IntSet) : WF s -> StronglySorted _<_ (toList s). 
freeblocks) ms) ]]] * [[ (Fs * smrep (rev l ++ freeblocks))%pred sm ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} freevec lxp xp l ms. Proof. unfold freevec. safestep. eauto. eauto. prestep; norml. denote Fm as Hx. denote smrep as Hs. destruct l. denote (_ < _) as Hy; simpl in Hy; inversion Hy. rewrite listpred_isolate with (i := 0) in Hx, Hs by (rewrite skipn_length; omega). rewrite skipn_selN, Nat.add_0_r in Hx, Hs. apply sep_star_reorder_helper in Hx. apply pimpl_exists_r_star_r in Hx; destruct Hx as [ [? ?] ?]. destruct_lift Hs. safecancel. rewrite selN_cons_fold; apply Forall_selN; auto. eauto. rewrite sep_star_assoc_1, sep_star_comm. eauto. step. rewrite removeN_0_skipn; cancel. rewrite selN_cons_fold. replace ([n]) with (rev [n]) by auto. rewrite <- rev_app_distr. rewrite app_comm_cons, <- rev_unit. rewrite <- firstn_S_selN by auto. cancel. rewrite removeN_0_skipn; cancel. rewrite selN_cons_fold. rewrite smrep_cons. rewrite app_comm_cons, <- rev_unit. rewrite <- firstn_S_selN by auto. cancel. step. rewrite firstn_oob by auto. rewrite skipn_oob by auto. step. cancel. erewrite <- LOG.intact_hashmap_subset; eauto. Unshelve. all: eauto; try exact tt. exact (LOG.mk_memstate0 (BUFCACHE.cache0 0)). Qed. Hint Extern 1 ({{_}} Bind (freevec _ _ _ _) _) => apply freevec_ok : prog. Lemma xparams_ok_goodSize : forall xp a, Sig.xparams_ok xp -> a < (BmapNBlocks xp) * valulen -> goodSize addrlen a. Proof. unfold Sig.xparams_ok; intuition. eapply goodSize_trans. eapply Nat.lt_le_incl; eauto. eapply goodSize_trans. eapply mult_le_compat_r; eauto. unfold goodSize. replace addrlen with (16 + 16 + 16 + 16) by (compute; auto). rewrite <- Nat.mul_1_r at 1. repeat apply mult_pow2_bound; try apply valulen_bound. apply one_lt_pow2. Qed. Lemma bn_valid_goodSize : forall F l m ms xp a, (F * rep xp l ms)%pred m -> bn_valid xp a -> goodSize addrlen a. Proof. unfold rep, bn_valid. unfold Alloc.rep, Alloc.Alloc.rep, Alloc.Alloc.Bmp.rep, Alloc.Alloc.Bmp.items_valid, Alloc.Alloc.BmpSig.xparams_ok; intuition. destruct_lift H. eapply xparams_ok_goodSize; eauto. Qed. Lemma bn_valid_goodSize_pimpl : forall l xp ms, rep xp l ms <=p=> [[ forall a, bn_valid xp a -> goodSize addrlen a ]] * rep xp l ms. Proof. intros; split. unfold pimpl; intros. pred_apply; cancel. apply emp_star in H. eapply bn_valid_goodSize; eauto. cancel. Qed. Lemma bn_valid_facts : forall xp bn, bn_valid xp bn -> bn <> 0 /\ bn < (BmapNBlocks xp) * valulen. Proof. unfold bn_valid; auto. Qed. Theorem bn_valid_roundtrip' : forall xp a, Sig.xparams_ok xp -> bn_valid xp a -> bn_valid xp (# (natToWord addrlen a)). Proof. unfold bn_valid; intuition. rewrite wordToNat_natToWord_idempotent' in H0; auto. eapply xparams_ok_goodSize; eauto. rewrite wordToNat_natToWord_idempotent'; auto. eapply xparams_ok_goodSize; eauto. Qed. Theorem bn_valid_roundtrip : forall xp a F l ms m, (F * rep xp l ms)%pred m -> bn_valid xp a -> bn_valid xp (# (natToWord addrlen a)). 
d, i < length items -> cache_rep items cache -> cache_rep items (Cache.add i (selN items i d) cache). Proof. unfold cache_rep in *. intros. rewrite M.mm_add_upd. destruct (M.mm _ cache i) eqn:?. eapply cache_rep_some in H0 as ?; eauto. rewrite Mem.upd_nop; eauto. rewrite Heqo. f_equal. eauto. generalize dependent (M.mm _ cache). clear cache. intros. eapply arrayN_mem_upd_none; eauto. edestruct arrayN_except as [H' _]; eauto; apply H' in H0; clear H'. unfold sep_star in *. rewrite sep_star_is in *. unfold sep_star_impl in *. repeat deex. apply mem_union_none_sel in Heqo. cbv [cache_ptsto or ptsto] in *. intuition try congruence. apply emp_empty_mem_only in H5. subst. rewrite mem_union_empty_mem'. auto. cbv [cache_ptsto ptsto or]. left. intuition (destruct addr_eq_dec); eauto; congruence. Unshelve. exact item0. Qed. Lemma cache_ptsto_upd : forall i v0 v m, cache_ptsto i v0 m -> cache_ptsto i v (Mem.upd m i v). Proof. cbv [cache_ptsto or]. intros. left. intuition auto. pose proof (@ptsto_upd _ addr_eq_dec _ i v v0 emp). eapply pimpl_trans; try apply H; try pred_apply; cancel. pose proof (@ptsto_upd_disjoint _ addr_eq_dec _ emp i v). eapply pimpl_trans; try apply H; try pred_apply; try cancel. cbv in *; auto. Qed. Lemma cache_rep_updN : forall items cache i v, i < length items -> cache_rep items cache -> cache_rep (updN items i v) (Cache.add i v cache). Proof. unfold cache_rep in *. intros. rewrite M.mm_add_upd. generalize dependent (M.mm _ cache). clear cache. intros. edestruct arrayN_isolate as [H' _]; eauto; apply H' in H0; clear H'. edestruct arrayN_isolate as [_ H']; [| apply H'; clear H']. rewrite length_updN; eauto. simpl in *. rewrite selN_updN_eq by auto. rewrite firstn_updN_oob by auto. rewrite skipn_updN by auto. revert H0. unfold_sep_star. intuition repeat deex. assert (mem_disjoint m0 (Mem.upd m3 i v)). cbv [cache_ptsto or ptsto] in H6. cbv [mem_disjoint Mem.upd] in *. intuition repeat deex. destruct addr_eq_dec; subst; eauto 10. destruct addr_eq_dec; subst; eauto 10. erewrite arrayN_cache_ptsto_oob in H6; eauto; try congruence. rewrite firstn_length_l; omega. apply mem_disjoint_union in H0 as ?. assert (mem_disjoint (Mem.upd m3 i v) m2). cbv [cache_ptsto or ptsto] in H6. cbv [mem_disjoint Mem.upd] in *. intuition repeat deex. destruct addr_eq_dec; subst; eauto 10. destruct addr_eq_dec; subst; eauto 10. erewrite arrayN_cache_ptsto_oob in H9; eauto; try congruence; omega. repeat eexists; try eapply cache_ptsto_upd; eauto. rewrite mem_union_comm with (m1 := m0) by auto. repeat rewrite <- mem_union_upd. f_equal. apply mem_union_comm, mem_disjoint_comm; auto. apply mem_disjoint_mem_union_split_l; auto. apply mem_disjoint_comm. eapply mem_disjoint_union_2. apply mem_disjoint_comm. eauto. Unshelve. all : eauto. Qed. Theorem get_array_ok : forall lxp xp ix cache ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ ix < length items ]] * [[[ m ::: Fm * rep xp items cache ]]] POST:hm' RET:^(cache', ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[[ m ::: Fm * rep xp items cache' ]]] * [[ r = selN items ix item0 ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} get_array lxp xp ix cache ms. 
lookup_singleton | set_solver]. } unfold txnmap_ptstos. rewrite big_sepM_singleton. done. Qed.Theorem wp_WriteReservedKey (txn : loc) (v : u64) Œ≥ : ‚ä¢ {{{ own_txn_uninit txn Œ≥ }}} <<< ‚àÄ‚àÄ (r : dbmap), ‚åúP_WriteReservedKey r‚åù ‚àó dbmap_ptstos Œ≥ 1 r >>> WriteReservedKey #txn #v @ ‚ÜëmvccN <<< ‚àÉ‚àÉ (ok : bool) (w : dbmap), if ok then ‚åúQ_WriteReservedKey v r w‚åù ‚àó dbmap_ptstos Œ≥ 1 w else dbmap_ptstos Œ≥ 1 r >>> {{{ RET #ok; own_txn_uninit txn Œ≥ }}}. Proof. iIntros "!>". iIntros (Œ¶) "Htxn HAU". wp_call. wp_apply (wp_txn__DoTxn_xres _ _ _ (Q_WriteReservedKey v) with "[$Htxn]"). { unfold Q_WriteReservedKey. apply _. } { unfold spec_body. iIntros (tid r œÑ Œ¶') "HP HŒ¶'". wp_pures. iApply (wp_WriteReservedKeySeq with "HP HŒ¶'"). } done. Qed.Definition P_WriteFreeKey (r : dbmap) := dom r = {[ (U64 1) ]}. Definition Q_WriteFreeKey (v : u64) (r w : dbmap) := w !! (U64 1) = Some (Value v).Theorem wp_WriteFreeKeySeq txn (v : u64) tid r Œ≥ œÑ : {{{ own_txn txn tid r Œ≥ œÑ ‚àó ‚åúP_WriteFreeKey r‚åù ‚àó txnmap_ptstos œÑ r }}} WriteFreeKeySeq #txn #v {{{ (ok : bool), RET #ok; own_txn txn tid r Œ≥ œÑ ‚àó if ok then ‚àÉ w, ‚åúQ_WriteFreeKey v r w ‚àß dom r = dom w‚åù ‚àó txnmap_ptstos œÑ w else True }}}. Proof. iIntros (Œ¶) "(Htxn & %Hdom & Hpts) HŒ¶". wp_call. assert (Helem : (U64 1) ‚àà dom r) by set_solver. rewrite elem_of_dom in Helem. destruct Helem as [u Hlookup]. wp_apply (wp_txn__Put with "[$Htxn Hpts]"). { iDestruct (big_sepM_lookup with "Hpts") as "Hpts"; [apply Hlookup | iFrame]. } iIntros "[Htxn Hpts]". wp_pures. iModIntro. iApply "HŒ¶". iFrame "Htxn". iExists {[ (U64 1) := (Value v) ]}. iSplit. { iPureIntro. unfold Q_WriteFreeKey. split; [by rewrite lookup_singleton | set_solver]. } unfold txnmap_ptstos. rewrite big_sepM_singleton. done. Qed.Theorem wp_WriteFreeKey (txn : loc) (v : u64) Œ≥ : ‚ä¢ {{{ own_txn_uninit txn Œ≥ }}} <<< ‚àÄ‚àÄ (r : dbmap), ‚åúP_WriteFreeKey r‚åù ‚àó dbmap_ptstos Œ≥ 1 r >>> WriteFreeKey #txn #v @ ‚ÜëmvccN <<< ‚àÉ‚àÉ (ok : bool) (w : dbmap), if ok then ‚åúQ_WriteFreeKey v r w‚åù ‚àó dbmap_ptstos Œ≥ 1 w else dbmap_ptstos Œ≥ 1 r >>> {{{ RET #ok; own_txn_uninit txn Œ≥ }}}. Proof. iIntros "!>". iIntros (Œ¶) "Htxn HAU". wp_call. wp_apply (wp_txn__DoTxn_xres _ _ _ (Q_WriteFreeKey v) with "[$Htxn]"). { unfold Q_WriteFreeKey. apply _. } { unfold spec_body. iIntros (tid r œÑ Œ¶') "HP HŒ¶'". wp_pures. iApply (wp_WriteFreeKeySeq with "HP HŒ¶'"). } done. Qed. Theorem wp_InitializeData (txnmgr : loc) Œ≥ : is_txnmgr txnmgr Œ≥ -‚àó {{{ dbmap_ptstos Œ≥ 1 (gset_to_gmap Nil keys_all) }}} InitializeData #txnmgr {{{ (v : dbval), RET #(); dbmap_ptsto Œ≥ (U64 0) (1 / 2)%Qp v ‚àó mvcc_inv_app Œ≥ }}}. 
sum_is_inv x y } := Ring.sum_neg_strong ring. Definition sum_neg : E -> E := Ring.sum_neg ring.Notation "{-}" := (sum_neg) : commutative_ring_scope.Notation "- x" := (sum_neg x) : commutative_ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Ring.sum_neg_def ring. Theorem sum_neg_inj : is_injective E E sum_neg. Proof Ring.sum_neg_inj ring. Theorem sum_cancel_neg : forall x : E, sum_neg (- x) = x. Proof Ring.sum_cancel_neg ring. Theorem sum_neg_onto : is_onto E E sum_neg. Proof Ring.sum_neg_onto ring. Theorem sum_neg_bijective : is_bijective E E sum_neg. Proof Ring.sum_neg_bijective ring. Theorem sum_neg_rev : forall x y : E, - x = y -> - y = x. Proof Ring.sum_neg_rev ring. Theorem sum_neg_distrib_inv_l : forall x y : E, sum_is_inv_l (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_l ring. Theorem sum_neg_distrib_inv_r : forall x y : E, sum_is_inv_r (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_r ring. Theorem sum_neg_distrib_inv : forall x y : E, sum_is_inv (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv ring. Theorem sum_neg_distrib : forall x y : E, - (x + y) = - y + - x. Proof Ring.sum_neg_distrib ring. Theorem sum_0_neg : - 0 = 0. Proof Ring.sum_0_neg ring. Theorem sum_neg_0 : forall x : E, - x = 0 -> x = 0. Proof Ring.sum_neg_0 ring. Theorem sum_neg_0_uniq : unique (fun x => - x = 0) 0. Proof Ring.sum_neg_0_uniq ring. Theorem prod_id : prod_is_id 1. Proof Ring.prod_id ring. Theorem prod_id_l_uniq : forall x : E, (Monoid.is_id_l E {#} x) -> x = 1. Proof Ring.prod_id_l_uniq ring. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E {#} x) -> x = 1. Proof Ring.prod_id_r_uniq ring. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E {#} x) -> x = 1. Proof Ring.prod_id_uniq ring. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. Proof Ring.prod_intro_l ring. Theorem prod_intro_r : forall x y z : E, x = y -> x # z = y # z. Proof Ring.prod_intro_r ring. Definition prod_is_inv_l := Ring.prod_is_inv_l ring. Definition prod_is_inv_r := Ring.prod_is_inv_r ring. Definition prod_is_inv := Ring.prod_is_inv ring. Definition prod_has_inv_l := Ring.prod_has_inv_l ring. Definition prod_has_inv_r := Ring.prod_has_inv_r ring. Definition prod_has_inv := Ring.prod_has_inv ring. Theorem prod_is_inv_lr : forall x y : E, prod_is_inv_l x y -> prod_is_inv_r x y. Proof fun x y H => H || a = 1 @a by prod_is_comm x y. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. 
: nat, 1 < n -> (1 < INR n)%R. replace 1%R with (INR 1); auto with real. Qed. Hint Resolve Rlt_INR1: real. Theorem NEq_INR : forall n m : nat, n <> m -> INR n <> INR m. intros n m H'; (case (le_or_lt n m); intros H'1). case (le_lt_or_eq _ _ H'1); intros H'2. apply Rlt_dichotomy_converse; auto with real. Contradict H'; auto. apply Compare.not_eq_sym; apply Rlt_dichotomy_converse; auto with real. Qed. Hint Resolve NEq_INR: real. Theorem NEq_INRO : forall n : nat, n <> 0 -> INR n <> 0%R. replace 0%R with (INR 0); auto with real. Qed. Hint Resolve NEq_INRO: real. Theorem NEq_INR1 : forall n : nat, n <> 1 -> INR n <> 1%R. replace 1%R with (INR 1); auto with real. Qed. Hint Resolve NEq_INR1: real. Theorem not_O_lt : forall n : nat, n <> 0 -> 0 < n. intros n; elim n; simpl in |- *; auto with arith. Qed. Hint Resolve not_O_lt: arith. Theorem NEq_IZRO : forall n : Z, n <> 0%Z -> IZR n <> 0%R. intros n H; Contradict H. apply IZR_zero_r; auto. Qed. Hint Resolve NEq_IZRO: real. Theorem Rlt_IZR : forall p q : Z, (p < q)%Z -> (IZR p < IZR q)%R. intros p q H; case (Rle_or_lt (IZR q) (IZR p)); auto. intros H1; Contradict H; apply Zle_not_lt. apply le_IZR; auto. Qed. Hint Resolve Rlt_IZR: real. Theorem Rle_IZR : forall x y : Z, (x <= y)%Z -> (IZR x <= IZR y)%R. intros x y H'. case (Zle_lt_or_eq _ _ H'); clear H'; intros H'. apply Rlt_le; auto with real. rewrite <- H'; auto with real. Qed. Hint Resolve Rle_IZR: real. Theorem Rlt_IZRO : forall p : Z, (0 < p)%Z -> (0 < IZR p)%R. intros p H; replace 0%R with (IZR 0); auto with real. Qed. Hint Resolve Rlt_IZRO: real. Theorem Rle_IZRO : forall x y : Z, (0 <= y)%Z -> (0 <= IZR y)%R. intros; replace 0%R with (IZR 0); auto with real. Qed. Hint Resolve Rle_IZRO: real. Theorem Rlt_IZR1 : forall p q : Z, (1 < q)%Z -> (1 < IZR q)%R. intros; replace 1%R with (IZR 1); auto with real. Qed. Hint Resolve Rlt_IZR1: real. Theorem Rle_IZR1 : forall x y : Z, (1 <= y)%Z -> (1 <= IZR y)%R. intros; replace 1%R with (IZR 1); auto with real. Qed. Hint Resolve Rle_IZR1: real. Theorem lt_Rlt : forall n m : nat, (INR n < INR m)%R -> n < m. 
-> T -> Prop. Inductive runF {T} (f:Œ£ -> Œ£ * T): t T := | runF_runs : forall s s' v, f s = (s', v) -> runF f s s' v. Theorem runF_runs_to {T} (f: Œ£ -> Œ£ * T) s : runF f s (fst (f s)) (snd (f s)). Proof. econstructor. destruct (f s); auto. Qed. Inductive suchThatBool {T} (b: Œ£ -> T -> bool): t T := | suchThatBool_runs : forall s x, b s x = true -> suchThatBool b s s x . Inductive suchThat {T} (pred: Œ£ -> T -> Prop): t T := | suchThat_runs : forall s x, pred s x -> suchThat pred s s x . Inductive bind {T1 T2} (r: t T1) (rx: T1 -> t T2): t T2 := | bind_runs : forall s1 s2 x s3 x', r s1 s2 x -> (rx x) s2 s3 x' -> bind r rx s1 s3 x' . Definition ret {T} (v:T): t T := runF (fun s => (s, v)). Theorem inv_runF {T} (f:Œ£ -> Œ£*T) : forall s1 s2 v', runF f s1 s2 v' -> s2 = fst (f s1) /\ v' = snd (f s1). Proof. intros. inversion H; subst. destruct (f s1); inversion H0; subst; auto. Qed. Theorem inv_ret {T} (v:T) : forall s1 s2 v', ret v s1 s2 v' -> s2 = s1 /\ v' = v. Proof. intros. apply inv_runF in H; intuition subst. Qed. Theorem inv_suchThatBool {T} (b:Œ£ -> T -> bool) : forall s1 s2 v', suchThatBool b s1 s2 v' -> s2 = s1 /\ b s1 v' = true. Proof. intros. inversion H; subst; eauto. Qed. Theorem inv_suchThat {T} (pred:Œ£ -> T -> Prop) : forall s1 s2 v', suchThat pred s1 s2 v' -> s2 = s1 /\ pred s1 v'. Proof. intros. inversion H; subst; eauto. Qed. Definition fmap {T1 T2} (f: T1 -> T2) (r: t T1): t T2 := bind r (fun x => ret (f x)). Fixpoint denote {T} (tr: transition Œ£ T): t T := match tr with | Transitions.runF f => runF f | Transitions.suchThat pred => suchThat pred | Transitions.suchThatBool b => suchThatBool b | Transitions.bind r rx => bind (denote r) (fun x => denote (rx x)) end. Theorem inv_undefined {T} s1 s2 (x: T): denote undefined s1 s2 x -> False. Proof. by inversion 1. Qed. Theorem inv_bind_undefined T (r: unit -> t T) : forall s1 s2 v, bind (denote undefined) r s1 s2 v -> False. 
castI j))). have rowU i: (nz_row (U i) :=: U i)%MS. apply/eqmxP; rewrite -(geq_leqif (mxrank_leqif_eq (nz_row_sub _))) linU. by rewrite lt0n mxrank_eq0 (nz_row_mxsimple (simU i)). have unitB: B \in unitmx. rewrite -row_full_unit -sub1mx -W1; apply/sumsmx_subP=> i _. pose j := cast_ord (esym castI) (enum_rank i). by rewrite (submx_trans _ (row_sub j B)) // rowK cast_ordKV enum_rankK rowU. pose e := \row_j row j (B *m rG x *m invmx B) 0 j. have rGx: rG x = invmx B *m diag_mx e *m B. rewrite -mulmxA; apply: canRL (mulKmx unitB) _. apply/row_matrixP=> j; rewrite 2!row_mul; set u := row j B. have /sub_rVP[a def_ux]: (u *m rG x <= u)%MS. rewrite /u rowK rowU (eqmxMr _ (rowU _)). exact: (mxmoduleP (mxsimple_module (simU _))). rewrite def_ux [u]rowE scalemxAl; congr (_ *m _). apply/rowP=> k; rewrite 5!mxE !row_mul def_ux [u]rowE scalemxAl mulmxK //. by rewrite !mxE !eqxx !mulr_natr eq_sym. have exp_e j: e 0 j ^+ #[x] = 1. suffices: (diag_mx e j j) ^+ #[x] = (B *m rG (x ^+ #[x])%g *m invmx B) j j. by rewrite expg_order repr_mx1 mulmx1 mulmxV // [e]lock !mxE eqxx. elim: #[x] => [|n IHn]; first by rewrite repr_mx1 mulmx1 mulmxV // !mxE eqxx. rewrite expgS repr_mxM ?groupX // {1}rGx -!mulmxA mulKVmx //. by rewrite mul_diag_mx mulmxA [M in _ = M]mxE -IHn exprS {1}mxE eqxx. have norm1_e j: `|e 0 j| = 1. by apply/eqP; rewrite -(@pexpr_eq1 _ _ #[x]) // -normrX exp_e normr1. exists e; split=> //; first by exists B. rewrite cfRepr1 !cfunE Gx rGx mxtrace_mulC mulKVmx // mxtrace_diag. split=> //=; apply: (le_trans (ler_norm_sum _ _ _)). by rewrite (eq_bigr _ (in1W norm1_e)) sumr_const card_ord lexx. rewrite !cfunE groupV !mulrb Gx rGx mxtrace_mulC mulKVmx //. rewrite -trace_map_mx map_diag_mx; set d' := diag_mx _. rewrite -[d'](mulKVmx unitB) mxtrace_mulC -[_ *m _](repr_mxK rG Gx) rGx. rewrite -!mulmxA mulKVmx // (mulmxA d'). suffices->: d' *m diag_mx e = 1%:M by rewrite mul1mx mulKmx. rewrite mulmx_diag -diag_const_mx; congr diag_mx; apply/rowP=> j. by rewrite [e]lock !mxE mulrC -normCK -lock norm1_e expr1n. Qed.Variables (A : {group aT}) (G : {group gT}). Lemma char_inv (chi : 'CF(G)) x : chi \is a character -> chi x^-1%g = (chi x)^*. Proof. case Gx: (x \in G); last by rewrite !cfun0 ?rmorph0 ?groupV ?Gx. by case/char_reprP=> rG ->; have [e [_ _ _]] := repr_rsim_diag rG Gx. Qed.Lemma irr_inv i x : 'chi[G]_i x^-1%g = ('chi_i x)^*. Proof. exact/char_inv/irr_char. Qed. Theorem generalized_orthogonality_relation y (i j : Iirr G) : #|G|%:R^-1 * (\sum_(x in G) 'chi_i (x * y)%g * 'chi_j x^-1%g) = (i == j)%:R * ('chi_i y / 'chi_i 1%g). 
with | [|- context[occurs_free_ctx (Econstr_c _ _ _ _)]] => rewrite occurs_free_Econstr_c | [|- context[occurs_free_ctx (Eproj_c _ _ _ _ _)]] => rewrite occurs_free_Eproj_c | [|- context[occurs_free_ctx (Eletapp_c _ _ _ _ _)]] => rewrite occurs_free_Eletapp_c | [|- context[occurs_free_ctx (Ecase_c _ _ _ _ _ )]] => rewrite occurs_free_Ecase_c | [|- context[occurs_free_ctx (Efun1_c _ _)]] => rewrite occurs_free_Efun1_c | [|- context[occurs_free_ctx (Efun2_c _ _)]] => rewrite occurs_free_Efun2_c | [|- context[occurs_free_ctx (Eprim_c _ _ _ _)]] => rewrite occurs_free_Eprim_c | [|- context[occurs_free_fundefs_ctx (Fcons1_c _ _ _ _ _)]] => rewrite occurs_free_fundefs_Fcons1_c | [|- context[occurs_free_fundefs_ctx (Fcons2_c _ _ _ _ _)]] => rewrite occurs_free_fundefs_Fcons2_c | [|- context[occurs_free_ctx (Hole_c)]] => rewrite occurs_free_Hole_c end.Ltac normalize_occurs_free_ctx_in_ctx := match goal with | [ H : context[occurs_free_ctx (Econstr_c _ _ _ _)] |- _ ] => rewrite occurs_free_Econstr_c | [ H : context[occurs_free_ctx (Eproj_c _ _ _ _ _)] |- _ ] => rewrite occurs_free_Eproj_c | [ H : context[occurs_free_ctx (Eletapp_c _ _ _ _ _)] |- _ ] => rewrite occurs_free_Eletapp_c | [ H : context[occurs_free_ctx (Ecase_c _ _ _ _ _ )] |- _ ] => rewrite occurs_free_Ecase_c | [ H : context[occurs_free_ctx (Efun1_c _ _)] |- _ ] => rewrite occurs_free_Efun1_c | [ H : context[occurs_free_ctx (Efun2_c _ _)] |- _ ] => rewrite occurs_free_Efun2_c | [ H : context[occurs_free_ctx (Eprim_c _ _ _ _)] |- _ ] => rewrite occurs_free_Eprim_c | [ H : context[occurs_free_fundefs_ctx (Fcons1_c _ _ _ _ _)] |- _ ] => rewrite occurs_free_fundefs_Fcons1_c | [ H : context[occurs_free_fundefs_ctx (Fcons2_c _ _ _ _ _)] |- _ ] => rewrite occurs_free_fundefs_Fcons2_c | [ H : context[occurs_free_ctx (Hole_c)] |- _ ] => rewrite occurs_free_Hole_c end. Definition closed_ctx := fun c => Empty_set var <--> occurs_free_ctx c. Definition closed_fundefs_ctx := fun cf => Empty_set var <--> occurs_free_fundefs_ctx cf. Theorem fun_names_not_free_in_fundefs_ctx : forall x f7, names_in_fundefs_ctx f7 x -> ~ occurs_free_fundefs_ctx f7 x. Proof. induction f7; intros; intro. inv H; inv H0; auto. inv H1; auto. inv H1; auto. revert H7. apply fun_names_not_free_in_fundefs. auto. inv H; inv H0; auto. inv H1; auto. inv H1; auto. revert H7. apply IHf7; auto. Qed. Lemma occurs_free_included_ctx_mut: forall e, (forall c, Included _ (occurs_free_ctx c) (occurs_free (c|[e]|))) /\ (forall fc, Included _ (occurs_free_fundefs_ctx fc) (occurs_free_fundefs (fc <[ e ]>))). Proof. intro e; exp_fundefs_ctx_induction IHc IHf; intros; repeat normalize_occurs_free_ctx; simpl; repeat normalize_occurs_free; eauto with Ensembles_DB. rewrite <- name_in_fundefs_ctx_ctx. eauto with Ensembles_DB. rewrite <- name_in_fundefs_ctx_ctx. eauto with Ensembles_DB. Qed. Theorem occurs_free_included_ctx: forall e, (forall c, Included _ (occurs_free_ctx c) (occurs_free (c|[e]|))). 
(k, rename_all_ns (M.set x y (M.empty M.elt)) e0)) l) v. Proof. induction l. reflexivity. simpl. destruct a. unfold dec_census. rewrite (proj1 update_census_join_mut). rewrite IHl. reflexivity. Qed. Lemma dec_census_case_sub sig l x y v c : dec_census_case (M.set x (apply_r sig y) sig) l v c = dec_census_case sig (map (fun (p : ctor_tag * exp) => let (k, e0) := p in (k, rename_all_ns (M.set x y (M.empty M.elt)) e0)) l) v c. Proof. induction l. reflexivity. simpl. destruct a. rewrite <- !IHl. rewrite <- !dec_census_all_case_sub. unfold dec_census. rewrite (proj1 update_census_join_mut). reflexivity. Qed. Lemma dec_census_all_case_Prop sig sig' l v : map_get_r _ sig sig' -> dec_census_all_case sig l v = dec_census_all_case sig' l v. Proof. induction l. intros Hc. reflexivity. intros Hc. simpl. destruct a. unfold dec_census. erewrite (proj1 update_census_Prop); [| eassumption ]. rewrite IHl. reflexivity. eassumption. Qed. Lemma dec_census_case_Prop sig sig' l v c : map_get_r _ sig sig' -> dec_census_case sig l v c = dec_census_case sig' l v c. Proof. intros Hc. induction l. reflexivity. simpl. destruct a. rewrite <- !IHl; eauto. (erewrite (dec_census_all_case_Prop sig sig'); eauto). (erewrite <- (dec_census_all_case_Prop sig sig'); eauto). unfold dec_census. erewrite (proj1 update_census_Prop). reflexivity. eassumption. Qed. Definition bv_map (sub : ctx_map) := (fun x => exists f ft xs e, sub ! f = Some (SVfun ft xs e) /\ x \in FromList xs :|: bound_var e). Lemma bv_map_set_Vconstr sub x c l : bv_map (M.set x (SVconstr c l) sub) \subset bv_map sub. Proof. intros z (f & ft & xs & e & Hget & Hin). do 4 eexists; split; eauto. rewrite M.gso in Hget. eassumption. intros Hc; subst. rewrite M.gss in Hget. congruence. Qed. Lemma bv_map_get_SVfun f sub ft xs e : M.get f sub = Some (SVfun ft xs e) -> FromList xs :|: bound_var e \subset bv_map sub. Proof. intros Hget x Hin. do 4 eexists; split; eauto. Qed. Lemma bv_map_set_SVfun sub x ft xs e : bv_map (M.set x (SVfun ft xs e) sub) \subset FromList xs :|: bound_var e :|: bv_map sub. Proof. intros z (f & ft' & xs' & e' & Hget & Hin). destruct (peq x f); subst. - rewrite M.gss in Hget. inv Hget. now left. - right. do 4 eexists; split; eauto. rewrite M.gso in Hget; eauto. Qed. Definition map_eq_ren {A} f (m1 m2 : M.t A) := forall v : positive, m1 ! v = m2 ! (f v). Theorem set_list_set {A} a (v : A) lx ly sig : ~ a \in FromList lx -> M.set a v (set_list (combine lx ly) sig) =mg= set_list (combine lx ly) (M.set a v sig). 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). 
(x || y || z). setoid_replace (x || y || z || z) with (x || y || (z || z)). setoid_rewrite Or_idem. setoid_reflexivity. repeat setoid_rewrite <- Or_assoc. setoid_reflexivity. setoid_rewrite Or_assoc. setoid_replace (z || y) with (y || z). setoid_rewrite Or_comm. setoid_reflexivity. eapply Or_comm. setoid_replace (x || y) with y. setoid_reflexivity. auto. Qed.Lemma includes_left_Or_monotone : forall x y z, x <= y -> (z || x) <= (z || y). Proof. intros x y z Hxy. unfold includes in *. repeat setoid_rewrite <- Or_assoc. setoid_replace (z || x || z) with (z || x). setoid_rewrite Or_assoc. setoid_rewrite Hxy. setoid_reflexivity. setoid_rewrite Or_assoc. setoid_replace (x || z) with (z || x). setoid_rewrite <- Or_assoc. setoid_rewrite Or_idem. setoid_reflexivity. eapply Or_comm. Qed.Lemma includes_right_Cat_monotone : forall x y z, x <= y -> (x ++ z) <= (y ++ z). Proof. intros x y z Hxy. unfold includes in *. erewrite <- Cat_right_distr. setoid_rewrite Hxy. setoid_reflexivity. Qed.Lemma includes_left_Cat_monotone : forall x y z, x <= y -> (z ++ x) <= (z ++ y). Proof. intros x y z Hxy. unfold includes in *. erewrite <- Cat_left_distr. setoid_rewrite Hxy. setoid_reflexivity. Qed.Lemma includes_Star_monotone : forall x y, x <= y -> (Star x) <= (Star y). Proof. intros x y Hxy. specialize(includes_to_implies x y Hxy). intro H01. assert(H1: forall s, Star x ~== s -> Star y ~== s). intros s HSx. specialize(Star_to_list s x HSx). intros H. destruct H as [ss [Ha [Hb Hc]]]. assert(H1': forall zs, forallb (fun s : string => x ~= s) zs = true -> forallb (fun s : string => y ~= s) zs = true). induction zs. simpl. intro H. auto. simpl. intro H. case_eq(x ~= a); case_eq(forallb (fun s : string => x ~= s) zs); intros H' H''; rewrite H' in H; rewrite H'' in H; simpl in H; try discriminate H. replace (y ~= a) with true. erewrite (IHzs H'). auto. symmetry. eapply H01. auto. specialize(H1' ss Ha). specialize(list_to_Star ss y H1'). intros H. erewrite Hb in H. auto. assert(H02: forall s, y ~!= s -> x ~!= s). intros s Hy. specialize(Hxy s). erewrite matches_Or in Hxy. rewrite Hy in Hxy. destruct(x ~= s). simpl in Hxy. discriminate Hxy. auto. unfold includes. unfold re_eq. intro s. erewrite matches_Or. case_eq (Star x ~= s); case_eq (Star y ~= s); simpl; intros H' H''; try reflexivity. specialize(H1 s H''). rewrite H' in H1. discriminate H1. Qed. Theorem Star_right : forall r, (Eps || (r ++ Star r)) <= Star r. 
WfBaseMod_inlineAll_Rules. Qed. Definition inlineAll_Rules_BaseModuleWf {ty} (m : BaseModuleWf ty) := Build_BaseModuleWf (WfBaseMod_inlineAll_Rules (wfBaseModule m)). Definition inlineAll_Rules_BaseModuleWf_new {ty} (m : BaseModuleWf_new ty) := Build_BaseModuleWf_new (WfBaseMod_inlineAll_Rules_new (wfBaseModule_new m)). Lemma TraceInclusion_inlineAll_pos_Rules_Wf (m : BaseModuleWf type) : TraceInclusion m (inlineAll_Rules_BaseModuleWf m). Proof. specialize (TraceInclusion_flatten_r m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineAll_pos_Rules P2) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_Wf_new (m : BaseModuleWf_new type) : TraceInclusion m (inlineAll_Rules_BaseModuleWf_new m). Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (TraceInclusion_inlineAll_pos_Rules_Wf m'). Qed. Lemma TraceInclusion_inlineSingle_pos_Meths regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> forall n, (WfMod type (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n)))) /\ TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n))). Proof. intros WfH n. unfold inlineSingle_Meths_pos. case_eq (nth_error meths n); intros sth; [intros sthEq|split; [assumption | apply TraceInclusion_refl]]. split. - apply nth_error_In in sthEq. pose proof (WfMod_inline_all_Meth sth (seq 0 (length meths)) sthEq WfH). repeat rewrite map_fold_right_eq in *. assumption. - apply TraceInclusion_inline_BaseModule_meths; auto. eapply nth_error_In; eauto. Qed. Theorem TraceInclusion_inlineSingle_pos_Meths_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> forall n, (WfMod_new type (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n)))) /\ TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n))). Proof. intros. rewrite WfMod_new_WfMod_iff in *. apply TraceInclusion_inlineSingle_pos_Meths; auto. Qed. Lemma WfBaseMod_inlineSingle_Meths_pos ty m n: WfBaseModule ty m -> WfBaseModule ty (BaseMod (getRegisters m) (getRules m) (inlineSingle_Meths_pos (getMethods m) n)). Proof. intros. assert (WfMod ty m) as P1;[constructor; auto|apply WfMod_getFlat in P1]. unfold getFlat in P1; simpl in *. unfold inlineSingle_Meths_pos; destruct nth_error eqn:G; auto. apply nth_error_In in G. pose proof (WfMod_inline_all_Meth d (seq 0 (length (getMethods m))) G P1). repeat rewrite map_fold_right_eq in *. inv H0; assumption. Qed. Lemma WfBaseMod_inlineSingle_Meths_pos_new ty m n: WfBaseModule_new ty m -> WfBaseModule_new ty (BaseMod (getRegisters m) (getRules m) (inlineSingle_Meths_pos (getMethods m) n)). Proof. repeat rewrite <- WfBaseModule_WfBaseModule_new_iff. apply WfBaseMod_inlineSingle_Meths_pos. Qed. Definition inlineSingle_Meths_pos_BaseModuleWf {ty} (m : BaseModuleWf ty) n := Build_BaseModuleWf (WfBaseMod_inlineSingle_Meths_pos n (wfBaseModule m)). Definition inlineSingle_Meths_pos_BaseModuleWf_new {ty} (m : BaseModuleWf_new ty) n := Build_BaseModuleWf_new (WfBaseMod_inlineSingle_Meths_pos_new n (wfBaseModule_new m)). Lemma TraceInclusion_inlineSingle_pos_Meths_Wf (m : BaseModuleWf type) n : TraceInclusion m (inlineSingle_Meths_pos_BaseModuleWf m n). Proof. specialize (TraceInclusion_flatten_r m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineSingle_pos_Meths P2 n) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineSingle_pos_Meths_Wf_new (m : BaseModuleWf_new type) n : TraceInclusion m (inlineSingle_Meths_pos_BaseModuleWf_new m n). 
Theorem FboundedMboundPos : forall z m : Z, (0 <= m)%Z -> (m <= Zpower_nat radix precision)%Z -> (- dExp b <= z)%Z -> exists c : float, Fbounded b c /\ c = (m * powerRZ radix z)%R :>R. intros z m H' H'0 H'1; case (Zle_lt_or_eq _ _ H'0); intros H'2. exists (Float m z); split; auto with zarith. repeat split; simpl in |- *; auto with zarith. rewrite Zabs_eq; auto; rewrite pGivesBound; auto. case (FboundNext (Float (Zpred (Zpos (vNum b))) z)); auto with float. intros f' (H1, H2); exists f'; split; auto. rewrite H2; rewrite pGivesBound. unfold FtoRradix, FtoR in |- *; simpl in |- *; auto. rewrite <- Zsucc_pred; rewrite <- H'2; auto; ring. Qed. Theorem FboundedMbound : forall z m : Z, (Zabs m <= Zpower_nat radix precision)%Z -> (- dExp b <= z)%Z -> exists c : float, Fbounded b c /\ c = (m * powerRZ radix z)%R :>R. intros z m H H0. case (Zle_or_lt 0 m); intros H1. case (FboundedMboundPos z (Zabs m)); auto; try rewrite Zabs_eq; auto. intros f (H2, H3); exists f; split; auto. case (FboundedMboundPos z (Zabs m)); auto; try rewrite Zabs_eq_opp; auto with zarith. intros f (H2, H3); exists (Fopp f); split; auto with float. rewrite (Fopp_correct radix); auto with arith; fold FtoRradix in |- *; rewrite H3. rewrite Ropp_Ropp_IZR; ring. Qed. Theorem FnormalPrecision : forall p : float, Fnormal p -> Fdigit radix p = precision. intros p H; apply le_antisym; auto with float. apply pGivesDigit; auto with float. apply le_S_n. rewrite <- digitVNumiSPrecision. unfold Fdigit in |- *. replace (S (digit radix (Fnum p))) with (digit radix (Fnum p) + 1). rewrite <- digitAdd; auto with zarith. apply digit_monotone; auto with float. rewrite (fun x => Zabs_eq (Zpos x)); auto with float zarith. rewrite Zmult_comm; rewrite Zpower_nat_1; auto with float zarith. red in |- *; intros H1; case H. intros H0 H2; Contradict H2; rewrite H1. replace (Zabs (radix * 0)) with 0%Z; auto with zarith. rewrite Zmult_comm; simpl in |- *; auto. rewrite plus_comm; simpl in |- *; auto. Qed. Hint Resolve FnormalPrecision: float. Theorem FnormalUnique : forall p q : float, Fnormal p -> Fnormal q -> p = q :>R -> p = q. intros p q H' H'0 H'1. apply (FdigitEq radix); auto. apply FnormalNotZero; auto. apply trans_equal with (y := precision); auto with float. apply sym_equal; auto with float. Qed. Theorem FnormalLtPos : forall p q : float, Fnormal p -> Fnormal q -> (0 <= p)%R -> (p < q)%R -> (Fexp p < Fexp q)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z. 
H. assert (H2 := H del1 (cond_pos del1)). elim H2; intros del2 H3. elim H3; intros. exists (disc x (mkposreal del2 H4)). intros; unfold included in H1; split. unfold neighbourhood, disc. exists (mkposreal del2 H4). unfold included; intros; assumption. intros; apply H1; unfold disc; case (Req_dec y x); intro. rewrite H7; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0; apply (cond_pos del1). apply H5; split. unfold D_x, no_cond; split. trivial. apply (not_eq_sym (A:=R)); apply H7. unfold disc in H6; apply H6. intros; unfold continuity_pt; unfold continue_in; unfold limit1_in; unfold limit_in; intros. assert (H1 := H (disc (f x) (mkposreal eps H0))). cut (neighbourhood (disc (f x) (mkposreal eps H0)) (f x)). intro; assert (H3 := H1 H2). elim H3; intros D H4; elim H4; intros; unfold neighbourhood in H5; elim H5; intros del1 H7. exists (pos del1); split. apply (cond_pos del1). intros; elim H8; intros; simpl in H10; unfold R_dist in H10; simpl; unfold R_dist; apply (H6 _ (H7 _ H10)). unfold neighbourhood, disc; exists (mkposreal eps H0); unfold included; intros; assumption. Qed.Definition image_rec (f:R -> R) (D:R -> Prop) (x:R) : Prop := D (f x). Lemma continuity_P2 : forall (f:R -> R) (D:R -> Prop), continuity f -> open_set D -> open_set (image_rec f D). Proof. intros; unfold open_set in H0; unfold open_set; intros; assert (H2 := continuity_P1 f x); elim H2; intros H3 _; assert (H4 := H3 (H x)); unfold neighbourhood, image_rec; unfold image_rec in H1; assert (H5 := H4 D (H0 (f x) H1)); elim H5; intros V0 H6; elim H6; intros; unfold neighbourhood in H7; elim H7; intros del H9; exists del; unfold included in H9; unfold included; intros; apply (H8 _ (H9 _ H10)). Qed. Lemma continuity_P3 : forall f:R -> R, continuity f <-> (forall D:R -> Prop, open_set D -> open_set (image_rec f D)). Proof. intros; split. intros; apply continuity_P2; assumption. intros; unfold continuity; unfold continuity_pt; unfold continue_in; unfold limit1_in; unfold limit_in; simpl; unfold R_dist; intros; cut (open_set (disc (f x) (mkposreal _ H0))). intro; assert (H2 := H _ H1). unfold open_set, image_rec in H2; cut (disc (f x) (mkposreal _ H0) (f x)). intro; assert (H4 := H2 _ H3). unfold neighbourhood in H4; elim H4; intros del H5. exists (pos del); split. apply (cond_pos del). intros; unfold included in H5; apply H5; elim H6; intros; apply H8. unfold disc; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0; apply H0. apply disc_P1. Qed. Theorem Rsepare : forall x y:R, x <> y -> exists V : R -> Prop, (exists W : R -> Prop, neighbourhood V x /\ neighbourhood W y /\ ~ (exists y : R, intersection_domain V W y)). 
x' : X , paths x x' . Proof. intros . unfold isaprop in is . unfold isofhlevel in is . apply ( pr1 ( is x x' ) ). Defined. Lemma invproofirrelevance ( X : UU ) ( ee : forall x x' : X , paths x x' ) : isaprop X. Proof. intros . unfold isaprop. unfold isofhlevel . intro x . assert ( is1 : iscontr X ). split with x. intro t . apply ( ee t x). assert ( is2 : isaprop X). apply isapropifcontr. assumption. unfold isaprop in is2. unfold isofhlevel in is2. apply (is2 x). Defined. Lemma isweqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) : isweq f. Proof. intros. assert (isx0: forall x:X, paths (g (f x)) x). intro. apply proofirrelevance . apply isx . assert (isy0 : forall y : Y, paths (f (g y)) y). intro. apply proofirrelevance . apply isy . apply (gradth f g isx0 isy0). Defined. Definition weqimplimpl { X Y : UU } ( f : X -> Y ) ( g : Y -> X ) ( isx : isaprop X ) ( isy : isaprop Y ) := weqpair _ ( isweqimplimpl f g isx isy ) .Theorem isapropempty: isaprop empty. Proof. unfold isaprop. unfold isofhlevel. intros x x' . destruct x. Defined. Theorem isapropifnegtrue { X : UU } ( a : X -> empty ) : isaprop X . Proof . intros . set ( w := weqpair _ ( isweqtoempty a ) ) . apply ( isofhlevelweqb 1 w isapropempty ) . Defined . Axiom funextempty : forall ( X : UU ) ( f g : X -> empty ) , paths f g . Theorem isapropneg (X:UU): isaprop (X -> empty). Proof. intro. apply invproofirrelevance . intros x x' . apply ( funextempty X x x' ) . Defined . Corollary isapropdneg (X:UU): isaprop (dneg X). Proof. intro. apply (isapropneg (neg X)). Defined. Definition isaninvprop (X:UU) := isweq (todneg X).Definition invimpl (X:UU) (is: isaninvprop X) : (dneg X) -> X:= invmap ( weqpair (todneg X) is ) . Lemma isapropaninvprop (X:UU): isaninvprop X -> isaprop X. Proof. intros X X0. apply (isofhlevelweqb (S O) ( weqpair (todneg X) X0 ) (isapropdneg X)). Defined. Theorem isaninvpropneg (X:UU): isaninvprop (neg X). 
(Rle_dec r1 r2); auto with real. Qed. Theorem RmaxLess2 : forall r1 r2 : R, (r2 <= Rmax r1 r2)%R. intros r1 r2; unfold Rmax in |- *; case (Rle_dec r1 r2); auto with real; intros; apply Ropp_le_cancel; auto with real. Qed. Theorem RmaxSym : forall p q : R, Rmax p q = Rmax q p. intros p q; unfold Rmax in |- *. case (Rle_dec p q); case (Rle_dec q p); auto; intros H1 H2; apply Rle_antisym; auto. case (Rle_or_lt p q); auto; intros H'0; Contradict H1; apply Rlt_le; auto. case (Rle_or_lt q p); auto; intros H'0; Contradict H2; apply Rlt_le; auto. Qed. Theorem RmaxAbs : forall p q r : R, (p <= q)%R -> (q <= r)%R -> (Rabs q <= Rmax (Rabs p) (Rabs r))%R. intros p q r H' H'0; case (Rle_or_lt 0 p); intros H'1. repeat rewrite Rabs_right; auto with real. apply Rle_trans with r; auto with real. apply RmaxLess2; auto. apply Rge_trans with p; auto with real; apply Rge_trans with q; auto with real. apply Rge_trans with p; auto with real. rewrite (Rabs_left p); auto. case (Rle_or_lt 0 q); intros H'2. repeat rewrite Rabs_right; auto with real. apply Rle_trans with r; auto. apply RmaxLess2; auto. apply Rge_trans with q; auto with real. rewrite (Rabs_left q); auto. case (Rle_or_lt 0 r); intros H'3. repeat rewrite Rabs_right; auto with real. apply Rle_trans with (- p)%R; auto with real. apply RmaxLess1; auto. rewrite (Rabs_left r); auto. apply Rle_trans with (- p)%R; auto with real. apply RmaxLess1; auto. Qed. Theorem Rabsolu_Zabs : forall z : Z, Rabs (IZR z) = IZR (Zabs z). intros z; case z; simpl in |- *; auto with real. apply Rabs_right; auto with real. intros p0; apply Rabs_right; auto with real zarith. intros p0; unfold IZR; rewrite <- INR_IPR; rewrite Rabs_Ropp. apply Rabs_right; auto with real zarith. Qed. Theorem RmaxRmult : forall p q r : R, (0 <= r)%R -> Rmax (r * p) (r * q) = (r * Rmax p q)%R. intros p q r H; unfold Rmax in |- *. case (Rle_dec p q); case (Rle_dec (r * p) (r * q)); auto; intros H1 H2; auto. case H; intros E1. case H1; auto with real. rewrite <- E1; repeat rewrite Rmult_0_l; auto. case H; intros E1. case H2; auto with real. apply Rmult_le_reg_l with (r := r); auto. rewrite <- E1; repeat rewrite Rmult_0_l; auto. Qed. Theorem Rle_R0_Ropp : forall p : R, (p <= 0)%R -> (0 <= - p)%R. 
l0 v0 -> Disjoint _ (FromList (apply_r_list sig l)) (FromList l0) -> (forall x n, FromList l0 x -> num_occur (rename_all_ns sig e) x n -> get_c x count = n) -> sum_range_n l0 (apply_r_list sig l) (rename_all_ns sig e) v0 n -> NoDup l0 -> (get_c v0 (update_count_inlined (apply_r_list sig l) l0 count ) = get_c v0 count + n - num_occur_list (apply_r_list sig l) v0). Proof. induction l; intros. - inv H3. simpl. lia. - inv H3. + simpl in H. simpl. destruct (cps_util.var_dec (apply_r sig a) (apply_r sig a)). 2: exfalso; auto. rewrite IHl with (n := n0); eauto. rewrite gdss. apply H2 in H12. rewrite H12. lia. constructor; auto. rewrite gdss. lia. intro; apply H0. constructor 2; auto. eapply Disjoint_Included. 3: apply H1. intro; intro; constructor 2; auto. intro; intro; constructor 2; auto. intros. rewrite gdso. rewrite gdso. apply H2; eauto. constructor 2; auto. intro. inv H4; auto. intro. inv H1. specialize (H7 (apply_r sig a)). apply H7. split. constructor; auto. constructor 2; auto. inv H4; auto. + simpl. simpl in H. destruct ( cps_util.var_dec v0 (apply_r sig a)). exfalso; auto. rewrite IHl with (n := n). rewrite gdso by auto. rewrite gdso. reflexivity. intro; apply H0. constructor; auto. rewrite gdso by auto. rewrite gdso. simpl in H. auto. intro; apply H0. constructor; auto. intro; apply H0. constructor 2; auto. eapply Disjoint_Included. 3: apply H1. intro; intro; constructor 2; auto. intro; intro; constructor 2; auto. intros. rewrite gdso. rewrite gdso. apply H2. constructor 2; auto. auto. inv H4. intro; subst; auto. intro. inv H1. specialize (H7 (apply_r sig a)). apply H7. split. constructor. auto. constructor 2. auto. auto. inv H4; auto. Qed. Definition set_list_r {A:Type} (l : list (M.elt * A)) (map: M.t A) : M.t A := fold_left (fun cmap xv => M.set (fst xv) (snd xv) cmap ) l map. Theorem num_occur_set_arl_s: forall x y sig, x <> y -> ~ Dom_map sig x -> forall l, num_occur_list (apply_r_list (M.set x y sig) l) y = num_occur_list (apply_r_list sig l) y + num_occur_list l x. Proof. induction l. auto. simpl. destruct (cps_util.var_dec x a). - subst. rewrite apply_r_set1. destruct (cps_util.var_dec y y). 2:{ exfalso. apply n; auto. } rewrite Disjoint_apply_r. destruct (cps_util.var_dec y a). exfalso; auto. lia. split. intro. intro. inv H1. inv H2. apply H0. exists x0. inv H3; auto. - rewrite apply_r_set2 by auto. destruct (cps_util.var_dec y (apply_r sig a)); lia. Qed. Theorem num_occur_rename_all_set_x: forall x y sig, x <> y -> ~ Dom_map sig x -> (forall e n m, num_occur e x n -> num_occur (rename_all_ns sig e) y m -> num_occur (rename_all_ns (M.set x y sig) e) y (n+m)) /\ (forall fds n m, num_occur_fds fds x n -> num_occur_fds (rename_all_fun_ns sig fds) y m -> num_occur_fds (rename_all_fun_ns (M.set x y sig) fds) y (n+m)). 
Require Import List. From Huffman Require Import Permutation. From Huffman Require Import Ordered. From Huffman Require Import sTactic. Section ISortExample. Variable A : Type. Variable order : A -> A -> Prop. Variable order_fun : A -> A -> bool. Hypothesis order_fun_true : forall a b : A, order_fun a b = true -> order a b. Hypothesis order_fun_false : forall a b : A, order_fun a b = false -> order b a. Fixpoint insert (a : A) (l : list A) {struct l} : list A := match l with | nil => a :: nil | b :: l1 => match order_fun a b with | true => a :: l | false => b :: insert a l1 end end. Theorem insert_ordered : forall l : list A, ordered order l -> forall a : A, ordered order (insert a l). Proof using order_fun_false order_fun_true. intros l H'; elim H'; clear H' l; auto. simpl in |- *; auto. intros a b; simpl in |- *. generalize (refl_equal (order_fun b a)); pattern (order_fun b a) at -1 in |- *; case (order_fun b a); intros Eq0; auto. intros a b l H'0 H'1 H'2 a0. simpl in |- *. generalize (refl_equal (order_fun a0 a)); pattern (order_fun a0 a) at -1 in |- *; case (order_fun a0 a); intros Eq0; auto. generalize (H'2 a0); simpl in |- *. generalize (refl_equal (order_fun a0 b)); pattern (order_fun a0 b) at -1 in |- *; case (order_fun a0 b); intros Eq1; auto. Qed. Theorem insert_permutation : forall (L : list A) (a : A), permutation (a :: L) (insert a L). Proof using. intros L; elim L; simpl in |- *; auto. intros b l H' a. CaseEq (order_fun a b); intros H1; auto. apply permutation_trans with (l2 := b :: a :: l); auto. Qed. Hint Resolve insert_ordered insert_permutation : core. Fixpoint isort (l : list A) : list A := match l with | nil => nil | b :: l1 => insert b (isort l1) end. Theorem isort_ordered : forall l : list A, ordered order (isort l). 
"Hg") as "$". { apply step_count_next_incr. } iMod (na_heap_alloc_list tls _ l (Block_to_vals b) (Reading O) with "HœÉ") as "(HœÉ & Hblock & Hl)". { rewrite length_Block_to_vals. rewrite /block_bytes. lia. } { destruct H1 as (?&?); eauto. } { destruct H1 as (H'&?); eauto. eapply H'. } { destruct H1 as (H'&?); eauto. destruct (H' 0) as (?&Hfresh). by rewrite (loc_add_0) in Hfresh. } { eauto. } iModIntro; iSplit; first done. iFrame. iApply "HŒ¶". iFrame. { rewrite /mapsto_block. iApply seq_mapsto_to_heap_array. iApply (big_sepL_mono with "Hl"). iIntros (k x Heq) "(Hli&Hmt)". iApply (na_mapsto_to_heap with "Hli"). destruct H1 as (H'&?). eapply H'. } Qed. Definition bindex_of_Z (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : fin block_bytes. cut (Z.to_nat i < 4096)%nat. { apply nat_to_fin. } change 4096%nat with (Z.to_nat 4096%Z). abstract (apply Z2Nat.inj_lt; auto; vm_compute; inversion 1). Defined. Theorem block_byte_index {ext: ffi_syntax} (b: Block) (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : Block_to_vals b !! Z.to_nat i = Some (LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi). Proof. unfold Block_to_vals. rewrite ?list_lookup_fmap. unfold bindex_of_Z. destruct (vlookup_lookup' b (Z.to_nat i) (b !!! bindex_of_Z i Hlow Hhi)) as [H _]. rewrite H; eauto. Qed. Theorem mapsto_block_extract i l q b : (0 <= i)%Z -> (i < 4096)%Z -> ‚ä¢ mapsto_block l q b -‚àó ‚àÉ v, (l +‚Çó i) ‚Ü¶{q} v ‚àó ‚åúBlock_to_vals b !! Z.to_nat i = Some v‚åù. Proof. unfold mapsto_block; intros Hlow Hhi. iIntros "Hm". pose proof (block_byte_index b i ltac:(auto) ltac:(auto)) as Hi. assert (heap_array l (Block_to_vals b) !! (l +‚Çó i) = Some $ LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi) as Hha. { apply heap_array_lookup. eexists; intuition eauto. } iDestruct (big_sepM_lookup_acc _ _ _ _ Hha with "Hm") as "(Hmi&_)". iExists _. iFrame "Hmi". destruct_with_eqn (Block_to_vals b !! Z.to_nat i); auto. Qed. Theorem heap_valid_block l b q œÉ : na_heap.na_heap_ctx tls œÉ -‚àó mapsto_block l q b -‚àó ‚åú (forall (i:Z), (0 <= i)%Z -> (i < 4096)%Z -> match œÉ !! (l +‚Çó i) with | Some (Reading _, v) => Block_to_vals b !! Z.to_nat i = Some v | _ => False end) ‚åù. Proof. iIntros "HœÉ Hm". iIntros (i Hbound1 Hbound2). iDestruct (mapsto_block_extract i with "Hm") as (v) "[Hi %]"; eauto. iDestruct (heap_mapsto_na_acc with "Hi") as "[Hi Hi_rest]". iDestruct (@na_heap.na_heap_read with "HœÉ Hi") as %(lk&?&Hlookup&Hlock). destruct lk; inversion Hlock; subst. rewrite Hlookup //. Qed. Theorem Block_to_vals_ext_eq b1 b2 : (forall (i:Z), (0 <= i)%Z -> (i < 4096)%Z -> Block_to_vals b1 !! Z.to_nat i = Block_to_vals b2 !! Z.to_nat i) -> b1 = b2. 
Require Export Arith. Require Export ArithRing. Require Export Lia. Ltac CaseEq f := generalize (refl_equal f); pattern f at -1 in |- *; case f. Fixpoint div4 (n:nat) : nat * nat := match n with | S (S (S (S p))) => let (q, r) := div4 p in (S q, r) | a => (0, a) end.Fixpoint bsqrt (n b:nat) {struct b} : nat * nat := match b with | O => (0, 0) | S b' => match div4 n with | (O, O) => (0, 0) | (O, S p) => (1, p) | (q, r0) => let (s', r') := bsqrt q b' in match le_gt_dec (4 * s' + 1) (4 * r' + r0) with | left _ => (2 * s' + 1, 4 * r' + r0 - (4 * s' + 1)) | right _ => (2 * s', 4 * r' + r0) end end end. Theorem div4_ind : forall P:nat -> Prop, P 0 -> P 1 -> P 2 -> P 3 -> (forall n:nat, P n -> P (S (S (S (S n))))) -> forall n:nat, P n. 
-> list (Term A n) -> Prop := | ltPO : forall x p, ltP pO (pX x p) | ltP_hd : forall x y p q, ltT x y -> ltP (pX x p) (pX y q) | ltP_tl : forall x y p q, eqT x y -> ltP p q -> ltP (pX x p) (pX y q). Set Strict Implicit. Unset Implicit Arguments. Lemma fltP : forall p q, ltP p q -> Ltl _ ltM (fP p) (fP q). intros p q H'; elim H'; auto. simpl in |- *; intros; apply (Lt_nil (mon n)); auto. simpl in |- *; intros; apply (Lt_hd (mon n)); auto. simpl in |- *; unfold eqT in |- *; (intros x y p1 q1 H; rewrite H). simpl in |- *; intros; apply (Lt_tl (mon n)); auto. Qed. Hint Resolve fltP. Theorem ltp_not_refl : forall x, ~ ltP x x. intros x; elim x. red in |- *; intros H'; inversion H'. intros a l H'; red in |- *; intros H'0; simple inversion H'0. discriminate H. injection H1. injection H0. intros H'1 H'2 H'3 H'4; rewrite H'2; rewrite H'4; intros H'5. apply (ltT_not_refl a); auto. injection H1; injection H2. intros H'1 H'2 H'3 H'4; rewrite H'1; rewrite H'3; auto. Qed. Hint Resolve ltPO. Theorem ltP_trans : forall x y z, ltP x y -> ltP y z -> ltP x z. intros x y z H'; generalize z; clear z; elim H'. intros x0 p z; case z; auto. intros H'0; inversion H'0. intros x0 y0 p q H'0 z H'1; simple inversion H'1. discriminate H. rewrite <- H1. intros H'2; try assumption. apply ltP_hd; auto. apply ltT_trans with (y := y0); auto. injection H0. intros H'3 H'4; rewrite <- H'4; auto. rewrite <- H2. intros H'2 H'3; apply ltP_hd; auto. apply ltT_eqTl with (a := x1); auto. injection H1. intros H'4 H'5; rewrite H'5; auto. intros x0 y0 p q H'0 H'1 H'2 z H'3; simple inversion H'3. discriminate H. rewrite <- H1; auto. intros H'4; apply ltP_hd; auto. apply ltT_eqTr with (a := y0). apply (eqT_sym A n); auto. injection H0. intros H'5 H'6; rewrite <- H'6; auto. rewrite <- H2. intros H'4 H'5; apply ltP_tl; auto. apply (eqT_trans A n) with (y := x1); auto. injection H1. intros H'6 H'7; rewrite H'7; auto. apply H'2; auto. injection H1. intros H'6; rewrite <- H'6; auto. Qed. Theorem olist_pX_ltP : forall a p, olist (pX a p) -> ltP p (pX a pO). 
eqA ltM q -> exists p1 : list (Term A n), (exists q1 : list (Term A n), reduceplus Q p p1 /\ reduceplus Q q q1 /\ eqP A eqA n s (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p1 q1)). intros Q p q s H' H'0 H'1. elim (rep_plus_reduce Q p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) s); [ intros p1 E; elim E; intros q1 E0; elim E0; intros H'9 H'10; elim H'10; intros H'11 H'12; clear H'10 E0 E | idtac | idtac | idtac ]; auto. exists p1; exists (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q1); split; [ idtac | split ]; auto. apply reduceplus_mults_invr; auto. cut (canonical A0 eqA ltM p1); [ intros Cp1 | idtac ]. cut (canonical A0 eqA ltM q1); [ intros Cq1 | idtac ]. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p1 q1); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p1 (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q1))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p1 (mults (A:=A) multA (n:=n) (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (invTerm (A:=A) invA (n:=n) (T1 A1 n))) q1)); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p1 (mults (A:=A) multA (n:=n) (T1 A1 n) q1)); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply canonical_reduceplus with (Q := Q) (p := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q); auto. apply canonical_reduceplus with (Q := Q) (p := p); auto. apply reduce_eqp_com with (1 := cs) (p := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (q := s); auto. Qed. Theorem rep_plus_zero_reduce : forall (Q : list (poly A0 eqA ltM)) (s t : list (Term A n)), reduceplus Q s t -> canonical A0 eqA ltM s -> forall p q : list (Term A n), eqP A eqA n s (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p q) -> canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqP A eqA n t (pO A n) -> exists r1 : list (Term A n), reduceplus Q p r1 /\ reduceplus Q q (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) r1). 
inum off v mscs. Proof. unfold dwrite, rep. intros. prestep. norml. rewrite subtree_extract in * by eauto. cbn [tree_pred] in *. destruct_lifts. cancel. eapply list2nmem_inbound; eauto. prestep. norm. cancel. intuition auto; msalloc_eq. pred_apply; cancel. rewrite <- subtree_absorb by eauto. cancel. auto. eapply dirlist_safe_subtree; eauto. apply dirtree_safe_file. Qed. Theorem datasync_ok : forall fsxp inum mscs, {< F ds sm pathname Fm Ftop tree f ilist frees, PRE:hm LOG.rep fsxp.(FSXPLog) F (LOG.ActiveTxn ds ds!!) (MSLL mscs) sm hm * [[[ ds!! ::: Fm * rep fsxp Ftop tree ilist frees mscs sm ]]] * [[ find_subtree pathname tree = Some (TreeFile inum f) ]] * [[ PredCrash.sync_invariant F ]] POST:hm' RET:mscs' exists ds' sm' tree' al, LOG.rep fsxp.(FSXPLog) F (LOG.ActiveTxn ds' ds'!!) (MSLL mscs') sm' hm' * [[ tree' = update_subtree pathname (TreeFile inum (synced_dirfile f)) tree ]] * [[ ds' = dssync_vecs ds al ]] * [[[ ds'!! ::: (Fm * rep fsxp Ftop tree' ilist frees mscs' sm') ]]] * [[ MSAlloc mscs' = MSAlloc mscs ]] * [[ MSCache mscs' = MSCache mscs ]] * [[ MSAllocC mscs' = MSAllocC mscs ]] * [[ MSIAllocC mscs' = MSIAllocC mscs ]] * [[ length al = length (DFData f) /\ forall i, i < length al -> BFILE.block_belong_to_file ilist (selN al i 0) inum i ]] * [[ dirtree_safe ilist (BFILE.pick_balloc frees (MSAlloc mscs')) tree ilist (BFILE.pick_balloc frees (MSAlloc mscs')) tree' ]] CRASH:hm' LOG.recover_any fsxp.(FSXPLog) F ds hm' >} datasync fsxp inum mscs. Proof. unfold datasync, rep. intros. prestep. norml. rewrite subtree_extract in * by eauto. cbn [tree_pred] in *. destruct_lifts. cancel. step; msalloc_eq. cancel. rewrite <- subtree_absorb by eauto. pred_apply. cancel. eapply dirlist_safe_subtree; eauto. apply dirtree_safe_file. Qed. Theorem sync_ok : forall fsxp mscs, {< F ds sm Fm Ftop tree ilist frees, PRE:hm LOG.rep fsxp.(FSXPLog) F (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: Fm * rep fsxp Ftop tree ilist frees mscs sm ]]] * [[ PredCrash.sync_invariant F ]] POST:hm' RET:mscs' LOG.rep fsxp.(FSXPLog) F (LOG.NoTxn (ds!!, nil)) (MSLL mscs') sm hm' * [[ MSCache mscs' = MSCache mscs ]] * [[ MSAlloc mscs' = negb (MSAlloc mscs) ]] * [[ MSIAllocC mscs' = MSIAllocC mscs ]] * [[ MSAllocC mscs' = MSAllocC mscs ]] * [[ MSICache mscs' = MSICache mscs ]] * [[ MSDBlocks mscs' = MSDBlocks mscs ]] XCRASH:hm' LOG.recover_any fsxp.(FSXPLog) F ds hm' >} sync fsxp mscs. Proof. unfold sync, rep. hoare. Qed. Theorem sync_noop_ok : forall fsxp mscs, {< F ds sm Fm Ftop tree ilist frees, PRE:hm LOG.rep fsxp.(FSXPLog) F (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: Fm * rep fsxp Ftop tree ilist frees mscs sm ]]] * [[ PredCrash.sync_invariant F ]] POST:hm' RET:mscs' LOG.rep fsxp.(FSXPLog) F (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[ MSCache mscs' = MSCache mscs ]] * [[ MSAlloc mscs' = negb (MSAlloc mscs) ]] XCRASH:hm' LOG.recover_any fsxp.(FSXPLog) F ds hm' >} sync_noop fsxp mscs. 
auto; rewrite Nat.add_1_r; constructor. - destruct l; try discriminate. simpl. destruct p. destruct p. simpl. destruct b, b0, b1; try rewrite 2 circuit'_individual_qubit_non_meas_same_base_true; auto; try rewrite 2 circuit'_individual_qubit_non_meas_diff_base_true; auto; try rewrite 2 circuit'_individual_qubit_non_meas_same_base_false; auto; try rewrite 2 circuit'_individual_qubit_non_meas_diff_base_false; auto; simpl; try (rewrite <- Nat.add_succ_l; replace (S i) with (S i + 0)%nat by lia; rewrite <- Nat.add_assoc; apply plus_lt_compat_l; simpl; auto); remember (hadamard √ó œÉx) as hx; repeat rewrite unfold_pad; auto with wf_db; replace (S (S n)) with (1 + (S n))%nat by lia; simpl; try rewrite i_1_i_S; replace (S (i + S (S n))) with (S (S i) + (S n))%nat by lia; rewrite IHn; auto; replace (S (S n)) with (1 + (S n))%nat by lia; rewrite IHn; auto with wf_db; replace (2 ^ i + (2 ^ i + 0))%nat with (2 ^ (S i))%nat; try (rewrite Nat.add_0_r; rewrite double_mult; rewrite Nat.pow_succ_r; try reflexivity; try apply Nat.le_0_l); replace ((i + (1 + S n) - (i + 1)))%nat with (S n) by lia; replace (2 ^ n + (2 ^n +0))%nat with (2 ^ (S n))%nat; try (rewrite Nat.add_0_r; rewrite double_mult; rewrite Nat.pow_succ_r; try reflexivity; try apply Nat.le_0_l); restore_dims; repeat rewrite kron_1_l; auto with wf_db; repeat rewrite kron_1_r; auto with wf_db; simpl; replace (2 ^ i + (2 ^ i + 0))%nat with (2 ^ (S i))%nat; try (rewrite Nat.add_0_r; rewrite double_mult; rewrite Nat.pow_succ_r; try reflexivity; try apply Nat.le_0_l); try rewrite kron_mixed_prod; try rewrite kron_dist_mult_id; restore_dims; repeat (rewrite <- kron_assoc; auto with wf_db); try rewrite id_kron; replace ((2 * 2 ^ i + (2 * 2 ^ i + 0)))%nat with (2 * 2 ^ i * 2)%nat; try (restore_dims; reflexivity); try ( rewrite Nat.add_0_r; rewrite double_mult; repeat rewrite <- Nat.pow_succ_r'; rewrite mult_comm; repeat rewrite <- Nat.pow_succ_r'; reflexivity ); try (rewrite Heqhx; auto with wf_db); try ( repeat rewrite Nat.add_0_r; repeat rewrite double_mult; rewrite id_kron; repeat rewrite <- Nat.pow_succ_r'; repeat rewrite <- Nat.pow_add_r; rewrite mult_comm; repeat rewrite <- Nat.pow_succ_r'; replace (S (S i) + (S n))%nat with (S i + S (S n))%nat by lia; reflexivity ). Qed.Theorem circuit'_helper_growth: forall n l, (length l = S n) -> uc_eval(circuit'_helper l (S (S n)) 1) = I 2 ‚äó uc_eval (circuit'_helper l (S n) 0). Proof. intros. replace (S (S n)) with (1+(S n))%nat. - rewrite (circuit'_helper_growth_i n l O). + reflexivity. + assumption. - auto. Qed.Local Hint Resolve eq_add_S : length_db. Local Hint Resolve combine_same_length : length_db. Theorem circuit'_output_correct: forall n data ab bb, (length data = S n) -> (length ab = S n) -> (length bb = S n) -> (uc_eval (circuit' data ab bb (S n))) √ó initial_state (S n) = output_state (S n) (combine (combine data ab) bb). 
Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. intros. apply PTree.gro. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply grs. apply gro; auto. Qed. Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq. Theorem beq_sound: forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A), beq eqA t1 t2 = true -> forall (x: elt), match get x t1, get x t2 with | None, None => True | Some y1, Some y2 => eqA y1 y2 = true | _, _ => False end. Proof. unfold beq, get. intros. rewrite PTree.beq_correct in H. apply H. Qed. Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine. Theorem gcombine: forall (A B C: Type) (f: option A -> option B -> option C), f None None = None -> forall (m1: t A) (m2: t B) (i: elt), get i (combine f m1 m2) = f (get i m1) (get i m2). 
L in E. inversion E. pose proof (toList_queueGet _ _ _ _ L). rewrite Q in H1. simpl in H1. destruct H1. destruct e. inversion H1; subst. simpl. omega. - auto. Qed.Definition first_two (l: list Node) : option (Node * Node) := match l with | x :: y :: t => Some (y,x) | _ => None end.Lemma bfenInternal_pred: forall g q q', (forall x, In x q -> first_two x <> None) -> map first_two q = map Some q' -> map first_two (bf' (q, g)) = map Some (bfenInternal' (q', g)). Proof. intros. remember (q, g) as x. generalize dependent q. revert q'. revert g. induction (x) as [y IH] using (well_founded_induction (well_founded_bf_measure_list _)). intros. destruct y. inversion Heqx. subst. clear Heqx. rewrite unfold_bfenInternal'. rewrite unfold_bf'. simpl. destruct q; destruct q'. reflexivity. simpl in H0. inversion H0. simpl in H0. inversion H0. simpl in H0. inversion H0. destruct l. inversion H2. simpl in H2. destruct l. inversion H2. simpl in H2. inversion H2. destruct p. inversion H4; subst. clear H4. destruct (isEmpty g) eqn : E. reflexivity. destruct (match_ n2 g) eqn : M. destruct m. - simpl. erewrite IH. reflexivity. apply lex1. unfold natNodes_lt. eapply match_decr_size. symmetry. apply M. 3: { reflexivity. } intros. intro. apply in_app_or in H1. destruct H1. apply (H x). right. assumption. assumption. apply in_map_iff in H1. destruct H1. destruct H1. subst. simpl in H4. inversion H4. rewrite map_app. rewrite map_app. rewrite H3. unfold outU. unfold out'. unfold suc'. destruct c. destruct p. destruct p. unfold Base.map. unfold Base.op_z2218U__. rewrite snd_equiv. rewrite map_map. rewrite map_map. rewrite map_map. rewrite map_map. simpl. rewrite filter_equiv. unfold Base.op_z2218U__ . rewrite snd_equiv. assert (map (fun x : b * Node => Some (n2, snd x)) (a0 ++ filter (fun x : b * Node => Base.op_zeze__ (snd x) n) a2) = map (fun x : b * Node => Some (toEdge (let '(l0, w) := x in (n, w, l0)))) (a0 ++ filter (fun x : b * Node => Base.op_zeze__ (snd x) n) a2)). induction (a0 ++ filter (fun x : b * Node => Base.op_zeze__ (snd x) n) a2); simpl. reflexivity. rewrite IHl0. destruct a3. simpl. eapply match_context in M. destruct M. subst. reflexivity. rewrite H1. reflexivity. - erewrite IH. reflexivity. apply lex2. unfold natNodes_eq. symmetry. eapply match_none_size. apply M. unfold list_length_lt. simpl. omega. 3: { reflexivity. } intros. apply H. right. assumption. assumption. Qed. Theorem bfe_pred: forall v (g: gr a b) h t, vIn g v = true -> bft v g = h :: t -> map Some (bfe v g) = Some (v,v) :: map first_two t. 
n -> Odd (Zsucc n). intros n H'; case H'; intros m H'1; exists m. rewrite H'1; unfold Zsucc in |- *; ring. Qed. Hint Resolve OddSEven EvenSOdd: zarith. Theorem OddSEvenInv : forall n : Z, Odd (Zsucc n) -> Even n. intros n H'; case H'; intros m H'1; exists m. apply Zsucc_inj; rewrite H'1; (unfold Zsucc in |- *; ring). Qed. Theorem EvenSOddInv : forall n : Z, Even (Zsucc n) -> Odd n. intros n H'; case H'; intros m H'1; exists (Zpred m). apply Zsucc_inj; rewrite H'1; (unfold Zsucc, Zpred in |- *; ring). Qed. Theorem EvenO : Even 0. exists 0%Z; simpl in |- *; auto. Qed. Hint Resolve EvenO: zarith. Theorem Odd1 : Odd 1. exists 0%Z; simpl in |- *; auto. Qed. Hint Resolve Odd1: zarith. Theorem OddOpp : forall z : Z, Odd z -> Odd (- z). intros z H; case H; intros z1 H1; exists (- Zsucc z1)%Z; rewrite H1. unfold Zsucc in |- *; ring. Qed. Theorem EvenOpp : forall z : Z, Even z -> Even (- z). intros z H; case H; intros z1 H1; exists (- z1)%Z; rewrite H1; ring. Qed. Hint Resolve OddOpp EvenOpp: zarith. Theorem OddEvenDec : forall n : Z, {Odd n} + {Even n}. intros z; case z; simpl in |- *; auto with zarith. intros p; case p; simpl in |- *; auto with zarith. intros p1; left; exists (Zpos p1); rewrite Zplus_comm; simpl in |- *; auto. intros p1; right; exists (Zpos p1); simpl in |- *; auto. change (forall p : positive, {Odd (- Zpos p)} + {Even (- Zpos p)}) in |- *. intros p; case p; auto with zarith. intros p1; left; apply OddOpp; exists (Zpos p1); rewrite Zplus_comm; simpl in |- *; auto. intros p1; right; apply EvenOpp; exists (Zpos p1); simpl in |- *; auto. Qed. Theorem OddNEven : forall n : Z, Odd n -> ~ Even n. intros n H1; red in |- *; intros H2; case H1; case H2; intros z1 Hz1 z2 Hz2. absurd (n = n); auto. pattern n at 1 in |- *; rewrite Hz1; rewrite Hz2; repeat rewrite (fun x => Zplus_comm x 1). case z1; case z2; simpl in |- *; try (intros; red in |- *; intros; discriminate). intros p p0; case p; simpl in |- *; try (intros; red in |- *; intros; discriminate). Qed. Theorem EvenNOdd : forall n : Z, Even n -> ~ Odd n. 
b c : Term A n, eqT b c -> ltT b a -> ltT c a. unfold eqT in |- *; unfold ltT in |- *; intros a b c H; rewrite H; auto. Qed. Theorem eqT_dec : forall x y : Term A n, {eqT x y} + {~ eqT x y}. intros x y; unfold eqT in |- *; simpl in |- *; auto. apply eqmon_dec. Qed. Theorem ltT_dec : forall x y : Term A n, {ltT x y} + {ltT y x} + {eqT x y}. intros x y; exact (ltM_dec (T2M x) (T2M y)). Qed. Lemma ltT_not_eqT : forall x y : Term A n, eqT x y -> ~ ltT x y. unfold eqT, ltT in |- *; simpl in |- *; intros x y H; rewrite H; auto. apply ltM_nonrefl with (1 := os). Qed. Lemma eqT_not_ltT : forall x y : Term A n, ltT x y -> ~ eqT x y. unfold eqT, ltT, not in |- *; simpl in |- *; intros x y H Q; absurd (ltM (T2M x) (T2M y)); auto; rewrite Q; auto. apply ltM_nonrefl with (1 := os). Qed. Theorem ltT_not_refl : forall x : Term A n, ~ ltT x x. intros x; unfold ltT in |- *; apply ltM_nonrefl with (1 := os). Qed. Hint Resolve ltT_not_eqT eqT_not_ltT ltT_not_refl. Lemma ltT_not_ltT : forall x y : Term A n, ltT x y -> ~ ltT y x. intros x y H'; red in |- *; intros H'0; absurd (ltT x x); auto. apply ltT_trans with (y := y); auto. Qed. Hint Resolve ltT_not_ltT. Lemma ltT_eqT : forall a b c d : Term A n, eqT a b -> eqT c d -> ltT a c -> ltT b d. unfold eqT, ltT in |- *; intros a b c d R1 R2; rewrite R1; rewrite R2; auto. Qed. Let eqT_refl := eqT_refl A n. Lemma ltT_eqTr : forall a b c : Term A n, eqT a b -> ltT a c -> ltT b c. intros a b c H' H'0; apply ltT_eqT with (a := a) (c := c); auto. Qed. Lemma ltT_eqTl : forall a b c : Term A n, eqT a b -> ltT c a -> ltT c b. intros a b c H' H'0; apply ltT_eqT with (a := c) (c := a); auto. Qed. Theorem multTerm_ltT_l : forall m1 m2 m3, ltT m1 m2 -> ltT (multTerm multA m3 m1) (multTerm multA m3 m2). 
(y := spminusf (plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b)) c nZc (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)) r); [ auto | idtac ]. apply eqp_spminusf_com; auto. apply divP_eqTerm_comp with (a := minusTerm (A:=A) minusA (n:=n) a b) (1 := cs); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (spminusf a c nZc p r) (spminusf (invTerm (A:=A) invA (n:=n) b) c nZc (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) r)); [ auto | idtac ]. apply spminusf_plusTerm; auto. apply (eqT_trans A n) with (1 := H'4); auto. apply nzeroP_comp_eqTerm with (1 := cs) (a := minusTerm (A:=A) minusA (n:=n) a b); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (spminusf a c nZc p r) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (spminusf b c nZc q r))); [ auto | idtac ]. apply eqp_pluspf_com with (1 := cs); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := spminusf (multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) b) c nZc (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) r); [ auto | idtac ]. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := spminusf (invTerm (A:=A) invA (n:=n) (multTerm (A:=A) multA (n:=n) (T1 A1 n) b)) c nZc (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) r); [ auto | auto ]. apply eqTerm_spminusf_com; auto. apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := b); auto. apply divTerm_multTermr with (1 := cs); auto. inversion H'3; auto. apply eqTerm_spminusf_com; auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (divP_trans _ _ _ _ _ _ _ _ _ cs n) with (y := b); auto. inversion H'3; auto. Qed. Theorem spminusf_minusTerm_z : forall (a b c : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> divP A A0 eqA multA divA n a c -> divP A A0 eqA multA divA n b c -> eqT a b -> zeroP (A:=A) A0 eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) -> eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf a c nZc p r) (spminusf b c nZc q r)). 
using (well_founded_ind (Zwf_well_founded 0)). intros Hle; destruct (Zle_lt_or_eq _ _ Hle). - destruct (H (x-1)). + unfold Zwf; lia. + lia. + exists (x*x0); apply Pfact1; auto with zarith. - subst x; exists 1; constructor.Qed.Section little_semantics. Variables Var aExp bExp : Set. Inductive inst : Set := | Skip : inst | Assign : Var->aExp->inst | Sequence : inst->inst->inst | WhileDo : bExp->inst->inst. Variables (state : Set) (update : state->Var->Z -> option state) (evalA : state->aExp -> option Z) (evalB : state->bExp -> option bool). Inductive exec : state->inst->state->Prop := | execSkip : forall s:state, exec s Skip s | execAssign : forall (s s1:state)(v:Var)(n:Z)(a:aExp), evalA s a = Some n -> update s v n = Some s1 -> exec s (Assign v a) s1 | execSequence : forall (s s1 s2:state)(i1 i2:inst), exec s i1 s1 -> exec s1 i2 s2 -> exec s (Sequence i1 i2) s2 | execWhileFalse : forall (s:state)(i:inst)(e:bExp), evalB s e = Some false -> exec s (WhileDo e i) s | execWhileTrue : forall (s s1 s2:state)(i:inst)(e:bExp), evalB s e = Some true -> exec s i s1 -> exec s1 (WhileDo e i) s2 -> exec s (WhileDo e i) s2. Theorem HoareWhileRule : forall (P:state->Prop)(b:bExp)(i:inst)(s s':state), (forall s1 s2:state, P s1 -> evalB s1 b = Some true -> exec s1 i s2 -> P s2)-> P s -> exec s (WhileDo b i) s' -> P s' /\ evalB s' b = Some false. Proof. intros P b i s s' H. cut (forall i':inst, exec s i' s' -> i' = WhileDo b i -> P s -> P s' /\ evalB s' b = Some false); eauto. intros i' Hexec; elim Hexec; try (intros; discriminate). intros s0 i0 e Heval Heq; injection Heq; intros H1 H2. match goal with | id:(e = b) |- _ => rewrite <- id; auto end. intros; match goal with | id:(_ = _) |- _ => injection id; intros H' H'' end. subst i0 b;eauto. Qed.End little_semantics.Open Scope nat_scope.Inductive is_0_1 : nat->Prop := is_0 : is_0_1 0 | is_1 : is_0_1 1.#[export] Hint Resolve is_0 is_1 : core.Lemma sqr_01 : forall x:nat, is_0_1 x -> is_0_1 (x * x). Proof. induction 1; simpl; auto. Qed.Theorem elim_example : forall n:nat, n <= 1 -> n*n <= 1. Proof. intros n H. destruct (sqr_01 n); auto. inversion_clear H; auto. inversion_clear H0; auto. Qed. Theorem not_even_1 : ~even 1. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. Admitted. Theorem leb_refl : forall n:nat, true = leb n n. Admitted. Theorem zero_nbeq_S : forall n:nat, beq_nat 0 (S n) = false. 
zarith. replace 1%R with (INR 1); auto with real arith. unfold Zpred in |- *; auto with zarith. rewrite FPredDiff1; auto with arith. unfold FtoR in |- *; simpl in |- *; rewrite Rmult_1_l; auto with real. apply FcanonicBound with (1 := H'). Qed. Theorem FulpPred : forall p : float, Fbounded b p -> (p - FNPred b radix precision p <= Fulp p)%R. intros p H'. replace (Fulp p) with (Fulp (Fnormalize radix b precision p)). replace (FtoRradix p) with (FtoRradix (Fnormalize radix b precision p)). unfold FNPred in |- *; apply FulpPredCan; auto with float arith. unfold FtoRradix in |- *; apply FnormalizeCorrect; auto. apply FulpComp; auto with float arith. unfold FtoRradix in |- *; apply FnormalizeCorrect; auto. Qed. Theorem FSuccDiffPos : forall x : float, (0 <= x)%R -> Fminus radix (FSucc b radix precision x) x = Float 1%nat (Fexp x) :>R. intros x H. unfold FtoRradix in |- *; apply FSuccDiff1; auto with arith. Contradict H; unfold FtoRradix, FtoR in |- *; simpl in |- *; rewrite H. apply Rlt_not_le. replace 0%R with (0 * powerRZ radix (Fexp x))%R; [ idtac | ring ]. apply Rlt_monotony_exp; auto with real arith. generalize (nNormPos _ radixMoreThanOne precision); replace 0%R with (IZR (- 0%nat)); auto with real zarith arith. Qed. Theorem FulpFPredGePos : forall f : float, Fbounded b f -> Fcanonic radix b f -> (0 < f)%R -> (Fulp (FPred b radix precision f) <= Fulp f)%R. intros f Hf1 Hf2 H. apply LeFulpPos; auto with zarith float; unfold FtoRradix in |- *. apply R0RltRlePred; auto with arith. apply Rlt_le; apply FPredLt; auto with arith. Qed. Theorem CanonicFulp : forall p : float, Fcanonic radix b p -> Fulp p = Float 1%nat (Fexp p). intros p H; unfold Fulp in |- *. rewrite FcanonicFnormalizeEq; auto with arith. unfold FtoRradix, FtoR in |- *; simpl in |- *; ring. Qed. Theorem FSuccUlpPos : forall x : float, Fcanonic radix b x -> (0 <= x)%R -> Fminus radix (FSucc b radix precision x) x = Fulp x :>R. intros x H H0; rewrite CanonicFulp; auto. apply FSuccDiffPos; auto. Qed. Theorem FNSuccUlpPos : forall x : float, Fcanonic radix b x -> (0 <= x)%R -> Fminus radix (FNSucc b radix precision x) x = Fulp x :>R. intros x H H0. unfold FNSucc in |- *. rewrite FcanonicFnormalizeEq; auto with arith. apply FSuccUlpPos; auto. Qed. Theorem FulpFabs : forall f : float, Fulp f = Fulp (Fabs f) :>R. 
apply Zlt_reg_mult_l. Flip. assumption. ring. ring. replace (c * b * f)%Z with (f * (c * b))%Z. replace (d * (a * f))%Z with (f * (a * d))%Z. apply Zlt_gt. apply Zlt_reg_mult_l. Flip. assumption. ring. ring. Qed. Lemma square_pos : forall a : Z, a <> 0%Z -> (0 < a * a)%Z. Proof. intros [| p| p]; intros; [ Falsum | constructor | constructor ]. Qed. Hint Resolve square_pos: zarith. Definition Z2positive (z : Z) := match z with | Zpos p => p | Zneg p => p | Z0 => 1%positive end. Lemma ZL9 : forall p : positive, Z_of_nat (nat_of_P p) = Zpos p. Proof. intro. cut (exists h : nat, nat_of_P p = S h). intro. case H. intros. unfold Z_of_nat in |- *. rewrite H0. apply f_equal with (A := positive) (B := Z) (f := Zpos). cut (P_of_succ_nat (nat_of_P p) = P_of_succ_nat (S x)). intro. rewrite P_of_succ_nat_o_nat_of_P_eq_succ in H1. cut (Ppred (Psucc p) = Ppred (P_of_succ_nat (S x))). intro. rewrite Ppred_succ in H2. simpl in H2. rewrite Ppred_succ in H2. apply sym_eq. assumption. apply f_equal with (A := positive) (B := positive) (f := Ppred). assumption. apply f_equal with (f := P_of_succ_nat). assumption. apply ZL4. Qed.Coercion Z_of_nat : nat >-> Z.Lemma ZERO_lt_POS : forall p : positive, (0 < Zpos p)%Z. Proof. intros. constructor. Qed. Lemma POS_neq_ZERO : forall p : positive, Zpos p <> 0%Z. Proof. intros. apply sym_not_eq. apply Zorder.Zlt_not_eq. apply ZERO_lt_POS. Qed.Lemma NEG_neq_ZERO : forall p : positive, Zneg p <> 0%Z. Proof. intros. apply Zorder.Zlt_not_eq. unfold Zlt in |- *. constructor. Qed. Lemma POS_resp_eq : forall p0 p1 : positive, Zpos p0 = Zpos p1 -> p0 = p1. Proof. intros. injection H. trivial. Qed.Lemma nat_nat_pos : forall m n : nat, ((m + 1) * (n + 1) > 0)%Z. Proof. intros. apply Zlt_gt. cut (Z_of_nat m + 1 > 0)%Z. intro. cut (0 < Z_of_nat n + 1)%Z. intro. cut ((Z_of_nat m + 1) * 0 < (Z_of_nat m + 1) * (Z_of_nat n + 1))%Z. rewrite Zmult_0_r. intro. assumption. apply Zlt_reg_mult_l. assumption. assumption. change (0 < Zsucc (Z_of_nat n))%Z in |- *. apply Zle_lt_succ. change (Z_of_nat 0 <= Z_of_nat n)%Z in |- *. apply Znat.inj_le. apply le_O_n. apply Zlt_gt. change (0 < Zsucc (Z_of_nat m))%Z in |- *. apply Zle_lt_succ. change (Z_of_nat 0 <= Z_of_nat m)%Z in |- *. apply Znat.inj_le. apply le_O_n. Qed. Theorem S_predn : forall m : nat, m <> 0 -> S (pred m) = m. 
(num_occur_list [x] v + n) | Ub_app: forall f t ys v, num_binding_e (Eapp f t ys) v 0 | Ub_case: forall l v n y, num_binding_l l v n -> num_binding_e (Ecase y l ) v n | Ub_fun: forall fds v n m e, num_binding_f fds v n -> num_binding_e e v m -> num_binding_e (Efun fds e) v (n+m) | Ub_halt: forall v v', num_binding_e (Ehalt v) v' 0 with num_binding_l: list (ctor_tag*exp) -> var -> nat -> Prop := | Ub_cons: forall e l v n m k, num_binding_e e v n -> num_binding_l l v m -> num_binding_l ((k,e)::l) v (n+m) | Ub_nil: forall v, num_binding_l [] v 0 with num_binding_f : fundefs -> var -> nat -> Prop := | Ub_fcons: forall e v n fds v' t ys m, num_binding_e e v n -> num_binding_f fds v m -> num_binding_f (Fcons v' t ys e fds) v (num_occur_list (v'::ys) v+n+m) | Ub_fnil: forall v, num_binding_f Fnil v 0. Scheme nbe_ind := Induction for num_binding_e Sort Prop with nbl_ind := Induction for num_binding_l Sort Prop with nbf_ind:= Induction for num_binding_f Sort Prop. Theorem e_num_binding : forall v e, exists n, num_binding_e e v n with e_num_binding_f : forall v fds, exists n, num_binding_f fds v n. Proof. - induction e; destructAll. + exists (num_occur_list [v0] v + x); constructor; auto. + assert (exists n, num_binding_l l v n). { induction l. exists 0; constructor. destruct a. specialize (e_num_binding v e). destructAll. eexists; constructor; eauto. } destruct H. exists x; constructor; auto. + exists (num_occur_list [v0] v + x); constructor; auto. + exists (num_occur_list [v0] v + x). constructor; auto. + specialize (e_num_binding_f v f). destructAll. eexists; constructor; eauto. + exists 0; constructor. + exists (num_occur_list [v0] v + x); constructor; auto. + exists 0; constructor. - induction fds. + specialize (e_num_binding v e). destructAll. eexists; constructor; eauto. + exists 0; constructor. Qed.Definition unique_bindings' e: Prop := forall v, exists n, num_binding_e e v n /\ n <= 1.Definition unique_binding_f' fds:Prop := forall v, exists n, num_binding_f fds v n /\ n <= 1. Theorem num_occur_n: forall e x n m, num_occur e x n -> n = m -> num_occur e x m. Proof. intros; subst. apply H. Qed.Theorem num_occur_fds_n: forall f x n m, num_occur_fds f x n -> n = m -> num_occur_fds f x m. Proof. intros; subst. apply H. Qed. Theorem num_occur_app_case: forall l' x l n, num_occur_case (l ++ l') x n <-> exists n1 n2, num_occur_case l x n1 /\ num_occur_case l' x n2 /\ n1 + n2 = n. 
smsi lmi. intros. invcs H0; simpl in *; try match goal with | _ : key_in_output_trace _ _ [] |- _ => unfold key_in_output_trace in *; break_exists; simpl in *; intuition end. - unfold key_in_output_trace in *. break_exists; simpl in *; intuition. find_inversion. unfold in_applied_entries in *. simpl in *. unfold RaftNetHandler in *. repeat break_let. repeat find_inversion. simpl in *. find_eapply_lem_hyp RIR_handleMessage; eauto. find_apply_lem_hyp key_in_output_list_split. find_copy_apply_lem_hyp doLeader_key_in_output_list. intuition. match goal with | H : doLeader ?st ?h = _ |- _ => replace st with ((update name_eq_dec (nwState net) h st) h) in H; [|rewrite_update; auto] end. find_eapply_lem_hyp RIR_doLeader; eauto. simpl in *. match goal with | _ : raft_intermediate_reachable ?net' |- context [update _ (nwState net) ?h ?d] => remember net' as n; assert ((update name_eq_dec (nwState net) h d) = (update name_eq_dec (nwState n) h d)) by (subst; simpl in *; repeat rewrite update_overwrite; auto) end. unfold raft_data in *. simpl in *. unfold raft_data in *. simpl in *. repeat find_rewrite. eapply doGenericServer_key_in_output_list; eauto. simpl in *. rewrite_update; eauto. - unfold key_in_output_trace in *. break_exists; simpl in *; intuition. find_inversion. unfold in_applied_entries in *. simpl in *. unfold RaftInputHandler in *. repeat break_let. repeat find_inversion. simpl in *. find_copy_eapply_lem_hyp RIR_handleInput; eauto. find_apply_lem_hyp key_in_output_list_split. intuition; [exfalso; eapply handleInput_key_in_output_list; eauto|]. find_apply_lem_hyp key_in_output_list_split. intuition; [exfalso; eapply doLeader_key_in_output_list; eauto|]. match goal with | H : doLeader ?st ?h = _ |- _ => replace st with ((update name_eq_dec (nwState net) h st) h) in H; [|rewrite_update; auto] end. find_eapply_lem_hyp RIR_doLeader; eauto. simpl in *. match goal with | _ : raft_intermediate_reachable ?net' |- context [update _ (nwState net) ?h ?d] => remember net' as n; assert ((update name_eq_dec (nwState net) h d) = (update name_eq_dec (nwState n) h d)) by (subst; simpl in *; repeat rewrite update_overwrite; auto) end. unfold raft_data in *. simpl in *. unfold raft_data in *. simpl in *. repeat find_rewrite. eapply doGenericServer_key_in_output_list; eauto. simpl in *. rewrite_update; eauto. Qed. Program Instance TR : TraceRelation step_failure := { init := step_failure_init; T := key_in_output_trace client id ; T_dec := key_in_output_trace_dec client id ; R := fun s => in_applied_entries client id (snd s) }. Next Obligation. unfold in_applied_entries in *. break_exists; eexists; intuition eauto. eapply applied_entries_monotonic; eauto. eauto using refl_trans_1n_n1_trace, step_failure_star_raft_intermediate_reachable. Defined. Next Obligation. unfold key_in_output_trace in *. intuition. break_exists; intuition. Defined. Next Obligation. simpl in *. find_apply_lem_hyp step_failure_star_raft_intermediate_reachable. find_apply_lem_hyp in_output_changed; auto. eauto using output_implies_in_applied_entries. Defined. Theorem output_implies_applied : forall failed net tr, step_failure_star step_failure_init (failed, net) tr -> key_in_output_trace client id tr -> in_applied_entries client id net. 
: Z, Odd n -> Odd m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1 + 1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus1 : forall n m : Z, Odd n -> Even m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus2 : forall n m : Z, Even n -> Odd m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Hint Resolve EvenPlus1 EvenPlus2 OddPlus1 OddPlus2: zarith. Theorem EvenPlusInv1 : forall n m : Z, Even (n + m) -> Even n -> Even m. intros n m H H0; replace m with (n + m + - n)%Z; auto with zarith. Qed. Theorem EvenPlusInv2 : forall n m : Z, Even (n + m) -> Odd n -> Odd m. intros n m H H0; replace m with (n + m + - n)%Z; auto with zarith. Qed. Theorem OddPlusInv1 : forall n m : Z, Odd (n + m) -> Odd m -> Even n. intros n m H H0; replace n with (n + m + - m)%Z; auto with zarith. Qed. Theorem OddPlusInv2 : forall n m : Z, Odd (n + m) -> Even m -> Odd n. intros n m H H0; replace n with (n + m + - m)%Z; auto with zarith. Qed. Theorem EvenMult1 : forall n m : Z, Even n -> Even (n * m). intros n m H; case H; intros z1 Hz1; exists (z1 * m)%Z; rewrite Hz1; ring. Qed. Theorem EvenMult2 : forall n m : Z, Even m -> Even (n * m). intros n m H; case H; intros z1 Hz1; exists (z1 * n)%Z; rewrite Hz1; ring. Qed. Hint Resolve EvenMult1 EvenMult2: zarith. Theorem OddMult : forall n m : Z, Odd n -> Odd m -> Odd (n * m). intros n m H1 H2; case H1; case H2; intros z1 Hz1 z2 Hz2; exists (2 * z1 * z2 + z1 + z2)%Z; rewrite Hz1; rewrite Hz2; ring. Qed. Hint Resolve OddMult: zarith. Theorem EvenMultInv : forall n m : Z, Even (n * m) -> Odd n -> Even m. 
{A : Type} (x : A) (l : list A) : Prop := match l with | [] => False | x' :: l' => x' = x \/ In x l' end.Lemma In_map : forall (A B : Type) (f : A -> B) (l : list A) (x : A), In x l -> In (f x) (map f l). Admitted. Lemma In_map_iff : forall (A B : Type) (f : A -> B) (l : list A) (y : B), In y (map f l) <-> exists x, f x = y /\ In x l. Admitted. Lemma in_app_iff : forall A l l' (a:A), In a (app l l') <-> In a l \/ In a l'. Admitted. Lemma plus_comm3 : forall n m p, n + (m + p) = (p + m) + n. Admitted. Lemma plus_comm3_take2 : forall n m p, n + (m + p) = (p + m) + n. Admitted. Lemma plus_comm3_take3 : forall n m p, n + (m + p) = (p + m) + n. Admitted. Fixpoint rev_append {X} (l1 l2 : list X) : list X := match l1 with | [] => l2 | x :: l1' => rev_append l1' (x :: l2) end.Definition tr_rev {X} (l : list X) : list X := rev_append l [].Lemma tr_rev_correct : forall X, @tr_rev X = @rev X. Admitted. Theorem evenb_double : forall k, evenb (double k) = true. Admitted. Theorem evenb_double_conv : forall n, exists k, n = if evenb n then double k else S (double k). Admitted. Theorem even_bool_prop : forall n, evenb n = true <-> exists k, n = double k. Admitted. Lemma andb_true_iff : forall b1 b2:bool, b1 && b2 = true <-> b1 = true /\ b2 = true. Admitted. Lemma orb_true_iff : forall b1 b2, b1 || b2 = true <-> b1 = true \/ b2 = true. Admitted. Theorem beq_nat_false_iff : forall x y : nat, beq_nat x y = false <-> x <> y. Admitted. Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool := match l with | [] => true | x :: l' => andb (test x) (forallb test l') end.Definition excluded_middle := forall P : Prop, P \/ ~ P.Theorem restricted_excluded_middle : forall P b, (P <-> b = true) -> P \/ ~ P. Admitted. Theorem restricted_excluded_middle_eq : forall (n m : nat), n = m \/ n <> m. 
Theorem not_False : ~ False. 
Require Import Coq.Logic.ProofIrrelevance. Require Import Main.Tactics.#[local] Set Universe Polymorphism.Record category := newCategory { object : Type; arrow : object -> object -> Type; compose {x y z} : arrow y z -> arrow x y -> arrow x z; id {x}: arrow x x; cAssoc {w x y z} (f : arrow w x) (g : arrow x y) (h : arrow y z) : compose h (compose g f) = compose (compose h g) f; cIdentLeft {x y} (f : arrow x y) : compose id f = f; cIdentRight {x y} (f : arrow x y) : compose f id = f; }.Arguments arrow {_}. Arguments compose {_} {_} {_} {_}. Arguments id {_} {_}. Arguments cAssoc {_} {_} {_} {_} {_}. Arguments cIdentLeft {_} {_} {_}. Arguments cIdentRight {_} {_} {_}.#[export] Hint Resolve cAssoc : main. #[export] Hint Resolve cIdentLeft : main. #[export] Hint Rewrite @cIdentLeft : main. #[export] Hint Resolve cIdentRight : main. #[export] Hint Rewrite @cIdentRight : main.#[local] Theorem opCAssoc {C} (w x y z : object C) (f : arrow x w) (g : arrow y x) (h : arrow z y) : compose (compose f g) h = compose f (compose g h). Proof. magic. Qed.#[local] Theorem opCIdentLeft {C} (x y : object C) (f : arrow y x) : compose f id = f. Proof. magic. Qed.#[local] Theorem opCIdentRight {C} (x y : object C) (f : arrow y x) : compose id f = f. 
‚à∑ ‚åúlength inode_refs = num_inodes‚åù ‚àó "Hro_state" ‚à∑ dir_state l alloc_ref inode_refs ‚àó "#Hinodes" ‚à∑ ([‚àó list] i ‚Ü¶ inode_ref ‚àà inode_refs, is_inode inodeN inode_ref (Pinode Œ≥blocks Œ≥used i) (U64 (Z.of_nat i))) ‚àó "#Halloc" ‚à∑ is_allocator (Palloc Œ≥used) allocŒ® allocN alloc_ref (rangeSet num_inodes (sz-num_inodes)) Œ≥alloc ‚àó "#Hinv" ‚à∑ ncinv dirN (‚àÉ œÉ, dir_inv Œ≥blocks œÉ ‚àó P œÉ) . Definition dir_cinv sz œÉ (post_crash: bool) : iProp Œ£ := ‚àÉ Œ≥blocks Œ≥used, "Hinodes" ‚à∑ (‚àÉ s_inodes, "%Hinode_len" ‚à∑ ‚åúlength s_inodes = num_inodes‚åù ‚àó "Hinodes" ‚à∑ ([‚àó list] i‚Ü¶s_inode ‚àà s_inodes, "Hinode_cinv" ‚à∑ (if post_crash then inode_cinv_postcrash (U64 (Z.of_nat i)) s_inode else inode_cinv_precrash (U64 (Z.of_nat i)) s_inode) ‚àó "HPinode" ‚à∑ Pinode Œ≥blocks Œ≥used i s_inode)) ‚àó "Halloc" ‚à∑ alloc_crash_cond_no_later (Palloc Œ≥used) allocŒ® (rangeSet num_inodes (sz-num_inodes)) post_crash ‚àó "Hs_inode" ‚à∑ dir_inv Œ≥blocks œÉ . Lemma dir_cinv_post_crash sz œÉ : dir_cinv sz œÉ true -‚àó dir_cinv sz œÉ false. Proof. iNamed 1. iExists _, _; iFrame. iSplitR "Halloc"; last first. { iApply alloc_crash_cond_no_later_from_post_crash; auto. } iNamed "Hinodes". iExists _. iSplit; first eauto. iApply (big_sepL_mono with "Hinodes"). iIntros (?? Hlook). iNamed 1. iFrame. rewrite /inode_cinv_postcrash. iDestruct "Hinode_cinv" as (?) "H". by iApply inode_durable_to_cinv. Qed. Definition pre_dir l (sz: Z) dir : iProp Œ£ := ‚àÉ alloc_ref inode_refs Œ≥blocks Œ≥used, "%Hlen" ‚à∑ ‚åúlength inode_refs = num_inodes‚åù ‚àó "Hro_state" ‚à∑ dir_state l alloc_ref inode_refs ‚àó "Hd_inv" ‚à∑ dir_inv Œ≥blocks dir ‚àó "Hinodes" ‚à∑ (‚àÉ s_inodes, [‚àó list] i‚Ü¶inode_ref;s_inode ‚àà inode_refs;s_inodes, pre_inode inode_ref (U64 (Z.of_nat i)) s_inode ‚àó Pinode Œ≥blocks Œ≥used i s_inode) ‚àó "Halloc" ‚à∑ (‚àÉ s_alloc, "Halloc_mem" ‚à∑ is_allocator_mem_pre alloc_ref s_alloc ‚àó "%Halloc_dom" ‚à∑ ‚åúalloc.domain s_alloc = rangeSet num_inodes (sz-num_inodes)‚åù ‚àó "Hunused" ‚à∑ ([‚àó set] k ‚àà alloc.unused s_alloc, allocŒ® k) ‚àó "HPalloc" ‚à∑ Palloc Œ≥used s_alloc) . Theorem big_sepM_const_seq {PROP:bi} {A} start sz (def: A) (Œ¶: nat ‚Üí A ‚Üí PROP) : ([‚àó map] i‚Ü¶x ‚àà gset_to_gmap def (set_seq start sz), Œ¶ i x) -‚àó ([‚àó list] i ‚àà seq start sz, Œ¶ i def). Proof. (iInduction sz as [|sz] "IH" forall (start)). - rewrite gset_to_gmap_empty big_sepM_empty /=. auto. - simpl. rewrite gset_to_gmap_union_singleton. rewrite big_sepM_insert; last first. { apply lookup_gset_to_gmap_None. rewrite elem_of_set_seq. lia. } iIntros "[$ Hm]". iApply ("IH" with "Hm"). Qed. Lemma seq_S : forall len start, seq start (S len) = seq start len ++ [start + len]. Proof. intros len start. change [start + len] with (seq (start + len) 1). rewrite <- seq_app. rewrite <- plus_n_Sm, <- plus_n_O; reflexivity. Qed. Theorem init_dir {E} (sz: Z) : (num_inodes ‚â§ sz < 2^64)%Z ‚Üí ([‚àó list] i ‚àà seqZ 0 sz, i d‚Ü¶[block0] block0) ={E}=‚àó let œÉ0 := dir.mk $ gset_to_gmap [] $ set_seq 0 num_inodes in dir_cinv sz œÉ0 true. 
Variables. eauto. Qed. Theorem G2_eq_Gi_0 : Pr[G2] == Pr[Gi 0%nat]. unfold G2, Gi. fcf_skip. fcf_simp. fcf_to_prhl_eq. comp_skip. eapply (fcf_oracle_eq (fun a b => a = fst b)); trivial; intuition; subst. unfold Oi. comp_simp. destruct (ge_dec n 0). simpl. fcf_ident_expand_l. comp_skip. eapply comp_spec_ret; intuition. omega. simpl in H1. intuition; subst. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_close : | Pr[G1] - Pr[G2] | <= (q / 1) * k. rewrite G1_eq_Gi_q. rewrite G2_eq_Gi_0. rewrite ratDistance_comm. specialize (distance_le_prod_f (fun i => Pr[Gi i])); intuition. Qed.End OracleHybrid.Require Import FCF.CompFold. Require Import FCF.OracleCompFold. Require Import FCF.PRF.Section OracleMapHybrid. Variable A B C State S_A : Set. Variable b : B. Hypothesis eqdA : EqDec A. Hypothesis eqdB : EqDec B. Hypothesis eqdState : EqDec State. Hypothesis eqdS_A : EqDec S_A. Variable A1 : Comp (State * (list A * S_A)). Variable A2 : S_A -> list B -> Comp bool. Hypothesis A1_wf : well_formed_comp A1. Hypothesis A2_wf : forall s_A lsb, well_formed_comp (A2 s_A lsb). Variable q : nat. Variable k : Rat. Hypothesis max_queries : forall ls s s_A, In (s, (ls, s_A)) (getSupport A1) -> (length ls <= q)%nat. Variable O1 O2 : State -> A -> Comp (B * State). Hypothesis O1_wf : forall s a, well_formed_comp (O1 s a). Hypothesis O2_wf : forall s a, well_formed_comp (O2 s a). Definition OMH_G O := [s, p] <-$2 A1; [lsa, s_A] <-2 p; [lsb, _] <-$2 oracleMap _ _ O s lsa; A2 s_A lsb. Definition OMH_G_i i := [s, p] <-$2 A1; [lsa, s_A] <-2 p; [lsb1, s'] <-$2 oracleMap _ _ O1 s (firstn i lsa); [lsb2, _] <-$2 oracleMap _ _ O2 s' (skipn i lsa); A2 s_A (lsb1 ++ lsb2). Hypothesis adjacent_close : forall i, | Pr[OMH_G_i i] - Pr[OMH_G_i (S i)] | <= k. Definition OMH_G_oc (p : list A * S_A) := [lsa, s_A] <-2 p; lsb <--$ oc_compMap _ (fun a => OC_Query _ a) lsa; $ A2 s_A lsb. Theorem OMH_G_oc_wf : forall p, well_formed_oc (OMH_G_oc p). intuition. econstructor. apply oc_compMap_wf. intuition. econstructor. intuition. econstructor. auto. Qed. Theorem OMH_G_oc_equiv : forall O, Pr[OMH_G O] == Pr[ [s, s_A] <-$2 A1; [b, _] <-$2 (OMH_G_oc s_A) _ _ O s; ret b ]. intuition. unfold OMH_G, OMH_G_oc. fcf_skip. fcf_simp. fcf_to_prhl_eq. simpl. fcf_inline_first. fcf_skip. apply compFold_oc_equiv. subst. fcf_inline_first. fcf_ident_expand_l. fcf_skip. fcf_simp. fcf_spec_ret. Qed. Definition OMH_G1 := OMH_G O1. Definition OMH_G2 := OMH_G O2. Theorem OMH_G1_equiv: Pr[OMH_G1] == Pr[G1 _ O1 A1 OMH_G_oc]. 
Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba) ===> llist b n fr ba. Axiom llist_end_bwd : forall (ba : W) n (fr : W) b, fr <> 0 -> focusOnBack -> (Ex v1, Ex v2, Ex v1', Ex v2', Ex n', Ex p, [| n = S (S n') |] * [| (v1', v2') %in b |] * [| (v1, v2) %in b %- (v1', v2')|] * lseg (b %- (v1, v2) %- (v1', v2')) n' fr p * [| p <> 0 |] * [| freeable p 3 |] * (p ==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. End QUEUE.Module Queue : QUEUE. Open Scope Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). destruct n; reflexivity. Qed. Theorem queue_extensional : forall b p, HProp_extensional (queue b p). reflexivity. Qed. Theorem lseg_extensional' : forall ba n b b' fr, b %= b' -> lseg b n fr ba ===> lseg b' n fr ba. 
y2 => beqA y1 y2 = true | _, _ => False end). Proof. induction m1; intros. - simpl. rewrite bempty_correct. split; intros. rewrite gleaf. rewrite H. auto. generalize (H x). rewrite gleaf. destruct (get x m2); tauto. - destruct m2. + unfold beq. rewrite bempty_correct. split; intros. rewrite H. rewrite gleaf. auto. generalize (H x). rewrite gleaf. destruct (get x (Node m1_1 o m1_2)); tauto. + simpl. split; intros. * destruct (andb_prop _ _ H). destruct (andb_prop _ _ H0). rewrite IHm1_1 in H3. rewrite IHm1_2 in H1. destruct x; simpl. apply H1. apply H3. destruct o; destruct o0; auto || congruence. * apply andb_true_intro. split. apply andb_true_intro. split. generalize (H xH); simpl. destruct o; destruct o0; tauto. apply IHm1_1. intros; apply (H (xO x)). apply IHm1_2. intros; apply (H (xI x)). Qed. End BOOLEAN_EQUALITY. Fixpoint prev_append (i j: positive) {struct i} : positive := match i with | xH => j | xI i' => prev_append i' (xI j) | xO i' => prev_append i' (xO j) end. Definition prev (i: positive) : positive := prev_append i xH. Lemma prev_append_prev i j: prev (prev_append i j) = prev_append j i. Proof. revert j. unfold prev. induction i as [i IH|i IH|]. 3: reflexivity. intros j. simpl. rewrite IH. reflexivity. intros j. simpl. rewrite IH. reflexivity. Qed. Lemma prev_involutive i : prev (prev i) = i. Proof (prev_append_prev i xH). Lemma prev_append_inj i j j' : prev_append i j = prev_append i j' -> j = j'. Proof. revert j j'. induction i as [i Hi|i Hi|]; intros j j' H; auto; specialize (Hi _ _ H); congruence. Qed. Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive) {struct m} : t B := match m with | Leaf => Leaf | Node l o r => Node (xmap f l (xO i)) (match o with None => None | Some x => Some (f (prev i) x) end) (xmap f r (xI i)) end. Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH. Lemma xgmap: forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A), get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Theorem gmap: forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A), get i (map f m) = option_map (f i) (get i m). 
Fact chain_list_chain l x y : chain_list l x y -> chain (length l) x y. Proof. induction 1 as [ ? | ? ? y ]; simpl; try constructor. constructor 2 with y; auto. Qed. Fact chain_list_app l x y m z : chain_list l x y -> chain_list m y z -> chain_list (l++m) x z. Proof. induction 1 as [ | l x y ]; simpl; auto. constructor 2 with y; auto. Qed. Lemma chain_list_inv l x y : chain_list l x y -> l = nil /\ x = y \/ exists k l', l = x::l' /\ R x k /\ chain_list l' k y. Proof. intros [|]; firstorder. Qed. Corollary chain_list_nil_inv x y : chain_list nil x y -> x = y. Proof. intros H; apply chain_list_inv in H. destruct H as [ (_ & ->) | (? & ? & ? & _) ]; auto; discriminate. Qed. Corollary chain_list_cons_inv x l y z : chain_list (x::l) y z -> x = y /\ exists k, R x k /\ chain_list l k z. Proof. intros H. apply chain_list_inv in H. destruct H as [ (? & _) | (k & l' & H & ? & ?) ]; try discriminate. inversion H; firstorder. Qed. Lemma chain_list_app_inv l m x z : chain_list (l++m) x z -> exists y, chain_list l x y /\ chain_list m y z. Proof. revert x; induction l as [ | a l IHl ]; intros x. + exists x; simpl; split; auto; constructor. + simpl; intros H; apply chain_list_cons_inv in H. destruct H as (-> & b & H1 & H2). apply IHl in H2; destruct H2 as (y & H2 & H3). exists y; split; auto; constructor 2 with b; auto. Qed. Lemma Acc_chains k x : (forall n y, chain n y x -> n <= k) -> Acc R x. Proof. revert x. induction k as [ | k IHk ]; intros x Hx. + constructor 1; intros y Hy. assert (chain 1 y x) as C. { constructor 2 with x. + trivial. + constructor 1. } apply Hx in C; lia. + constructor 1; intros y Hy. apply IHk; intros n z Hn. apply le_S_n. apply (Hx _ z). apply chain_snoc with y; auto. Qed. Hypothesis (HR : forall x, exists k, forall n y, chain n y x -> n <= k). Theorem wf_chains : well_founded R. 
in AC2. apply (domain_of_surjection_dominate_range AC2 _ _ f). apply meta_surjection. - intros x Hx. eapply ReplI... - intros y Hy. apply ReplAx... Qed. Lemma cntinf_ord_neq_0 : ‚àÄŒ± ‚ãµ ùêéùêç, |Œ±| = ‚Ñµ‚ÇÄ ‚Üí Œ± ‚â 0. Proof. intros Œ± HŒ± Hcinf H0. subst. symmetry in Hcinf. rewrite pred, card_of_empty, card_eq_0 in Hcinf; nauto. Qed. Local Hint Resolve cntinf_ord_neq_0 : core. Lemma ord_lt_cnt_cnt : ‚àÄŒ± ‚ãµ ùêéùêç, countable Œ± ‚Üí ‚àÄŒ≤ ‚àà Œ±, countable Œ≤. Proof with eauto. intros Œ± HoŒ± Hcnt Œ≤ HŒ≤. assert (HoŒ≤: Œ≤ ‚ãµ ùêéùêç). apply (ord_is_ords Œ±)... eapply dominate_trans. apply dominate_sub. apply ord_lt_iff_psub; revgoals... apply Hcnt. Qed. Theorem ord_suc_cntinf : AC_II ‚Üí ‚àÄŒ± ‚ãµ ùêéùêç, |Œ±| = ‚Ñµ‚ÇÄ ‚Üí |Œ±‚Å∫| = ‚Ñµ‚ÇÄ. Proof with neauto. intros AC2 Œ± HŒ± Hcinf. apply add_countably_many_members_to_cntinf... apply countableI1. apply single_finite. Qed. Theorem ord_sum_cntinf : AC_II ‚Üí ‚àÄŒ± ‚ãµ ùêéùêç, |Œ±| = ‚Ñµ‚ÇÄ ‚Üí ‚àÄŒ≤ ‚ãµ ùêéùêç, countable Œ≤ ‚Üí |Œ± + Œ≤| = ‚Ñµ‚ÇÄ. Proof with neauto. intros AC2 Œ± HŒ± Hcinf. ord_induction. intros Œ≤ HŒ≤ IH Hcnt. ord_destruct Œ≤. - subst. rewrite ordAdd_0_r... - destruct Hsuc as [Œ≥ [HŒ≥ Heq]]. subst. destruct (classic (Œ≥ = 0)) as [|HŒ≥0]. { subst. rewrite ordAdd_1_r... apply ord_suc_cntinf... } rewrite ordAdd_suc... apply ord_suc_cntinf... apply IH... rewrite <- (add_one_member_then_remove Œ≥ Œ≥). apply remove_members_from_cnt... apply ord_irrefl... - rewrite ordAdd_limit... apply countable_union_of_cntinf... + exists Œ±. apply ReplAx. exists 0. split. apply ord_neq_0_gt_0... rewrite ordAdd_0_r... + apply repl_of_cnt_cnt... + intros A H. apply ReplAx in H as [Œ≥ [HŒ≥ H]]. subst. apply IH... eapply ord_lt_cnt_cnt... Qed. Theorem ord_prd_cntinf : AC_II ‚Üí ‚àÄŒ± ‚ãµ ùêéùêç, |Œ±| = ‚Ñµ‚ÇÄ ‚Üí ‚àÄŒ≤ ‚ãµ ùêéùêç, Œ≤ ‚â 0 ‚Üí countable Œ≤ ‚Üí |Œ± ‚ã Œ≤| = ‚Ñµ‚ÇÄ. Proof with neauto. intros AC2 Œ± HŒ± Hcinf. ord_induction. intros Œ≤ HŒ≤ IH HŒ≤0 Hcnt. ord_destruct Œ≤. - exfalso... - destruct Hsuc as [Œ≥ [HŒ≥ Heq]]. subst. destruct (classic (Œ≥ = 0)) as [|HŒ≥0]. { subst. rewrite ordMul_1_r... } rewrite ordMul_suc... apply ord_sum_cntinf... + apply IH... rewrite <- (add_one_member_then_remove Œ≥ Œ≥). apply remove_members_from_cnt... apply ord_irrefl... + apply countableI2. apply CardAx1... - clear H0. rewrite ordMul_limit... apply (add_one_member_to_funion 0). rewrite ordMul_0_r... apply countableI1... apply countable_union_of_cntinf... + exists Œ±. apply ReplAx. exists 1. split. 2: rewrite ordMul_1_r... apply SepI... apply sucord_in_limord... apply SingNI... + apply repl_of_cnt_cnt, remove_members_from_cnt... + intros A H. apply ReplAx in H as [Œ≥ [HŒ≥ H]]. subst. apply SepE in HŒ≥ as [HŒ≥ HŒ≥0]. apply SingNE in HŒ≥0. apply IH... eapply ord_lt_cnt_cnt... Qed. Theorem ord_pow_cntinf : AC_II ‚Üí ‚àÄŒ± ‚ãµ ùêéùêç, |Œ±| = ‚Ñµ‚ÇÄ ‚Üí ‚àÄŒ≤ ‚ãµ ùêéùêç, Œ≤ ‚â 0 ‚Üí countable Œ≤ ‚Üí |Œ± ^ Œ≤| = ‚Ñµ‚ÇÄ. 
Require Import List Arith Max Lia Wellfounded Bool Eqdep_dec.From Undecidability.Shared.Libs.DLW.Utils Require Import list_focus utils_tac utils_list.Set Implicit Arguments.Section le_lt_pirr. Scheme le_indd := Induction for le Sort Prop. Theorem le_pirr x y (H1 H2 : x <= y) : H1 = H2. 
-> parallel A O O E -> A ** O / O ** E = 2. Proof. area_method. Qed. Theorem Prop54Hartsshorne : forall A B C D E F G : Point, is_midpoint D A B -> is_midpoint E A C -> is_midpoint F B C -> inter_ll G E B C D -> Col A G F. Proof. area_method. Qed.Theorem Exo55Hartsshorne : forall A B C D I J K L, is_midpoint I A B -> is_midpoint J B C -> is_midpoint K C D -> is_midpoint L D A -> parallel I J K L /\ parallel I L J K. Proof. area_method. Qed.Theorem th6_42 : forall A B C L M N P K : Point, is_midpoint M A B -> is_midpoint N A C -> is_midpoint K B C -> is_midpoint L A K -> on_inter_parallel_parallel P A C M K B N -> P<>A -> (2 + 2) * S A K P = (1 + 2) * S A B C. Proof. am_before_field. intuition. field_and_conclude. Qed.Theorem th6_43 : forall A B C F N K : Point, is_midpoint F A B -> is_midpoint N C F -> inter_ll K B C A N -> K <> C -> parallel B K K C -> B ** K / K ** C = 2. Proof. area_method. Qed.Theorem Conversemenelaus : forall (A B C D E G : Point) (r1 r2 : F), mratio D B C r1 -> mratio E C A r2 -> inter_ll G D E A B -> G <> A -> parallel B G G A -> B ** G / G ** A = - r1 * r2. Proof. area_method. Qed.Theorem MenelausQuadri : forall A B C D X Y A1 B1 C1 D1 : Point, inter_ll A1 A B X Y -> inter_ll B1 B C X Y -> inter_ll C1 C D X Y -> inter_ll D1 A D X Y -> B <> A1 -> C <> B1 -> D <> C1 -> A <> D1 -> parallel A A1 B A1 -> parallel B B1 C B1 -> parallel C C1 D C1 -> parallel D D1 A D1 -> A ** A1 / B ** A1 * (B ** B1 / C ** B1 * (C ** C1 / D ** C1 * (D ** D1 / A ** D1))) = 1. Proof. area_method. Qed. Theorem ConverseMenelauseQuadri : forall (A B C D A1 B1 C1 D1 : Point) (r1 r2 : F), mratio B1 B C r1 -> mratio C1 C D r2 -> inter_ll D1 D A B1 C1 -> inter_ll A1 A B B1 C1 -> A1 <> A -> D1 <> A -> parallel B A1 A1 A -> parallel D D1 D1 A -> B ** A1 / A1 ** A = r1 * (r2 * (D ** D1 / D1 ** A)). 
(51 + off)) by lia. bsm sss POP empty with ZERO (75 + off) (75 + off). replace (75 + off) with (24 + (51 + off)) by lia. bsm sss POP empty with ZERO (j + c * !q') (j + c * !q'). bsm sss stop. + change (j + 76 * !i) with off. bsm sss POP empty with ZERO END END. bsm sss stop. Qed. Fixpoint sim (n : nat) (H : n <= S (num_states M)) : list (bsm_instr 4). Proof using j. destruct n. - exact []. - refine (sim n _ ++ _). abstract lia. assert (Hn : n < S (num_states M)) by abstract lia. refine (PROG (Fin.of_nat_lt Hn)). Defined. Definition SIM : list (bsm_instr 4). refine (@sim (S (num_states M)) _). Proof using M j. abstract lia. Defined. Lemma sim_length (n : nat) (H : n <= S (num_states M)) : @length (bsm_instr 4) (@sim n H) = c * n. Proof. induction n. - unfold sim. cbn. lia. - unfold sim. fold sim. rewrite app_length. rewrite PROG_length. rewrite IHn. lia. Qed. Lemma SIM_length : length SIM = c * (S (num_states M)). Proof. unfold SIM. rewrite sim_length. lia. Qed. Arguments sim _ _ : clear implicits. Lemma of_nat_lt_0 n (H : 0 < S n) : Fin.of_nat_lt H = @Fin.F1 n. Proof. unfold Fin.of_nat_lt. reflexivity. Qed. Arguments Fin.of_nat_lt _ {_} _. Lemma PROG_sim_sc q n (H : n <= S (num_states M)) : ! q < n -> (j + 76 * ! q, PROG q) <sc (j, sim n H). Proof. revert q. induction n as [n IH] using lt_wf_ind; intros q. destruct n. - intros. lia. - intros H0. eapply le_lt_or_eq in H0 as [H0 | H0]. + unfold sim. fold sim. eapply subcode_app_end. eapply IH. lia. lia. + inversion H0. subst. clear H0. unfold sim. fold sim. revert H IH. eapply (Fin.caseS' q). * intros H IH. cbn [Fin.to_nat proj1_sig sim]. rewrite of_nat_lt_0. cbn - [PROG]. eexists [], []. split. rewrite app_nil_r. reflexivity. reflexivity. * clear q. intros q H IH. erewrite Fin.of_nat_ext. rewrite Fin.of_nat_to_nat_inv. eapply subcode_right. rewrite sim_length. pose proof (Fin.R_sanity 1 q). clear IH. cbn - [mult] in *. destruct (Fin.to_nat q). cbn - [mult] in *. inversion H0. reflexivity. Qed. Lemma PROG_sc q : (j + 76 * ! q, PROG q) <sc (j, SIM). Proof. eapply PROG_sim_sc. destruct (Fin.to_nat q). cbn. lia. Qed. Theorem SIM_computes q t q' t' : SBTM.eval M q t q' t' -> (j,SIM) // (j + c * !q, enc_tape t) ->> (END, enc_tape t'). 
P e). Proof. intros. apply (isweqtransportf _ (pathsinv0 e)). Defined. Lemma unitl0: paths tt tt -> coconustot _ tt. Proof. intros X. apply (coconustotpair _ X). Defined.Lemma unitl1: coconustot _ tt -> paths tt tt. Proof. intro X. destruct X as [ x t ]. destruct x. assumption. Defined.Lemma unitl2: forall e: paths tt tt, paths (unitl1 (unitl0 e)) e. Proof. intros. unfold unitl0. simpl. apply idpath. Defined.Lemma unitl3: forall e:paths tt tt, paths e (idpath tt). Proof. intros. assert (e0: paths (unitl0 (idpath tt)) (unitl0 e)). eapply connectedcoconustot. assert (e1:paths (unitl1 (unitl0 (idpath tt))) (unitl1 (unitl0 e))). apply (maponpaths unitl1 e0). assert (e2: paths (unitl1 (unitl0 e)) e). eapply unitl2. assert (e3: paths (unitl1 (unitl0 (idpath tt))) (idpath tt)). eapply unitl2. destruct e1. clear e0. destruct e2. assumption. Defined. Theorem iscontrunit: iscontr (unit). Proof. assert (pp:forall x:unit, paths x tt). intros. destruct x. apply (idpath _). apply (tpair (fun cntr:unit => forall t:unit, paths t cntr) tt pp). Defined. Theorem iscontrpathsinunit ( x x' : unit ) : iscontr ( paths x x' ) . Proof. intros . assert (c:paths x x'). destruct x. destruct x'. apply idpath. assert (X: forall g:paths x x', paths g c). intro. assert (e:paths c c). apply idpath. destruct c. destruct x. apply unitl3. apply (iscontrpair c X). Defined. Lemma ifcontrthenunitl0 ( e1 e2 : paths tt tt ) : paths e1 e2. Proof. intros. assert (e3: paths e1 (idpath tt) ). apply unitl3. assert (e4: paths e2 (idpath tt)). apply unitl3. destruct e3. destruct e4. apply idpath. Defined. Lemma isweqcontrtounit { T : UU } (is : iscontr T) : (isweq (fun t:T => tt)). Proof. intros T X. unfold isweq. intro y. destruct y. assert (c: hfiber (fun x:T => tt) tt). destruct X as [ t x0 ]. eapply (hfiberpair _ t (idpath tt)). assert (e: forall d: (hfiber (fun x:T => tt) tt), paths d c). intros. destruct c as [ t x] . destruct d as [ t0 x0 ]. assert (e': paths x x0). apply ifcontrthenunitl0 . assert (e'': paths t t0). destruct X as [t1 x1 ]. assert (e''': paths t t1). apply x1. assert (e'''': paths t0 t1). apply x1. destruct e''''. assumption. destruct e''. destruct e'. apply idpath. apply (iscontrpair c e). Defined. Definition weqcontrtounit { T : UU } ( is : iscontr T ) := weqpair _ ( isweqcontrtounit is ) . Theorem iscontrifweqtounit { X : UU } ( w : weq X unit ) : iscontr X. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.SpecLemmas.Require Import VerdiRaft.TermSanityInterface. Require Import VerdiRaft.SortedInterface.Section SortedProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {tsi : term_sanity_interface}. Theorem logs_sorted_init : raft_net_invariant_init logs_sorted. 
(A B: Type) (f: B -> positive -> A -> B) m i v l, List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) = List.fold_left (fun a p => f a (fst p) (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. apply fold1_xelements with (l := @nil (positive * A)). Qed.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. 
let u' := match u with | context C [ ?y _ ] => constr:(y) end in try (eqdec_loop t' u') in match goal with | [ H : forall z, sum (Id _ z) _ |- _ ] => case (H y); [good|contrad] | _ => case (eq_dec x y); [good|contrad] end) || idtac.Ltac eqdec_proof := try red; intros; match goal with | |- sum (Id ?x ?y) _ => revert y; induction x; intros until y; depelim y; match goal with |- sum (Id ?x ?y) _ => eqdec_loop x y end end.Section EqdepDec. Universe i. Context {A : Type@{i}} `{EqDec A}. Let comp {x y y':A} (eq1:x = y) (eq2:x = y') : y = y' := Id_rect _ _ (fun a _ => a = y') eq2 _ eq1. Remark trans_sym_eq : forall (x y:A) (u:x = y), comp u u = id_refl y. Proof. intros. case u; compute. apply id_refl. Defined. Variable x : A. Let nu {y:A} (u:x = y) : x = y := match eq_dec x y with | inl eqxy => eqxy | inr neqxy => Empty_rect (fun _ => _) (neqxy u) end. Let nu_constant : forall (y:A) (u v:x = y), nu u = nu v. intros. unfold nu in |- *. case (eq_dec x y); intros. reflexivity. case e; trivial. Defined. Let nu_inv {y:A} (v:x = y) : x = y := comp (nu (id_refl x)) v. Remark nu_left_inv : forall (y:A) (u:x = y), nu_inv (nu u) = u. Proof. intros. case u; unfold nu_inv in |- *. apply trans_sym_eq. Defined. Theorem eq_proofs_unicity : forall (y:A) (p1 p2:x = y), p1 = p2. Proof. intros. elim nu_left_inv with (u := p1). elim nu_left_inv with (u := p2). elim nu_constant with y p1 p2. reflexivity. Defined. Theorem K_dec : forall P:x = x -> Type@{i}, P (id_refl x) -> forall p:x = x, P p. Proof. intros. elim eq_proofs_unicity with x (id_refl x) p. trivial. Defined. Lemma eq_dec_refl : eq_dec x x = inl (id_refl x). Proof. case eq_dec; intros. apply ap. apply eq_proofs_unicity. elim e. apply id_refl. Defined. Let projs {P:A -> Type@{i}} (exP:sigma P) (def:P x) : P x := match exP with | sigmaI _ x' prf => match eq_dec x' x with | inl eqprf => Id_rect _ x' (fun x _ => P x) prf x eqprf | _ => def end end. Theorem inj_right_sigma {P : A -> Type@{i}} {y y':P x} : (x, y) = (x, y') -> y = y'. 
Require Import Undecidability.Synthetic.Undecidability.Require Import Undecidability.SemiUnification.SemiU.Require Undecidability.SemiUnification.Reductions.CSSM_UB_to_SSemiU. Require Undecidability.SemiUnification.Reductions.SSemiU_to_RU2SemiU. Require Undecidability.SemiUnification.Reductions.RU2SemiU_to_LU2SemiU. Require Undecidability.SemiUnification.Reductions.RU2SemiU_to_SemiU. Require Import Undecidability.StackMachines.SSM_undec. Theorem SSemiU_undec : undecidable SSemiU. Proof. apply (undecidability_from_reducibility CSSM_UB_undec). exact CSSM_UB_to_SSemiU.reduction. Qed. Theorem RU2SemiU_undec : undecidable RU2SemiU. 
freeable p 3 /\ t = Node t1 t2 /\ v %in s |]) ===> bst' s t p. End BST.Module Bst : BST. Open Scope Sep_scope. Fixpoint bst' (s : set) (t : tree) (p : W) : HProp := match t with | Leaf => [| p = 0 /\ s %= empty |] | Node t1 t2 => [| p <> 0 /\ freeable p 3 |] * Ex p1, Ex v, Ex p2, (p ==*> p1, v, p2) * bst' (s %< v) t1 p1 * bst' (s %> v) t2 p2 * [| v %in s |] end. Definition bst (s : set) (p : W) := [| freeable p 2 |] * Ex t, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * bst' s t r. Theorem bst'_extensional : forall s t p, HProp_extensional (bst' s t p). destruct t; reflexivity. Qed. Theorem bst_extensional : forall s p, HProp_extensional (bst s p). reflexivity. Qed. Theorem bst'_set_extensional : forall t s s' p, s %= s' -> bst' s t p ===> bst' s' t p. induction t; sepLemma. Qed. Theorem bst_fwd : forall s p, bst s p ===> [| freeable p 2 |] * Ex t, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * bst' s t r. unfold bst; sepLemma. Qed. Theorem bst_bwd : forall s p, ([| freeable p 2 |] * Ex t, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * bst' s t r) ===> bst s p. unfold bst; sepLemma. Qed. Theorem nil_fwd : forall s t (p : W), p = 0 -> bst' s t p ===> [| s %= empty /\ t = Leaf |]. destruct t; sepLemma. Qed. Theorem nil_bwd : forall s t (p : W), p = 0 -> [| s %= empty /\ t = Leaf |] ===> bst' s t p. destruct t; sepLemma. Qed. Theorem cons_fwd : forall s t (p : W), p <> 0 -> bst' s t p ===> Ex t1, Ex t2, Ex p1, Ex v, Ex p2, (p ==*> p1, v, p2) * bst' (s %< v) t1 p1 * bst' (s %> v) t2 p2 * [| freeable p 3 /\ t = Node t1 t2 /\ v %in s |]. destruct t; sepLemma. Qed. Theorem cons_bwd : forall s t (p : W), p <> 0 -> (Ex t1, Ex t2, Ex p1, Ex v, Ex p2, (p ==*> p1, v, p2) * bst' (s %< v) t1 p1 * bst' (s %> v) t2 p2 * [| freeable p 3 /\ t = Node t1 t2 /\ v %in s |]) ===> bst' s t p. 
) . apply ( isofhlevelweqb n w ( isf z ) ) . Defined . Theorem isofhlevelffromXY ( n : nat ) { X Y : UU } ( f : X -> Y ) : isofhlevel n X -> isofhlevel (S n) Y -> isofhlevelf n f. Proof. intro. induction n as [ | n IHn ] . intros X Y f X0 X1. assert (is1: isofhlevel O Y). split with ( f ( pr1 X0 ) ) . intro t . unfold isofhlevel in X1 . set ( is := X1 t ( f ( pr1 X0 ) ) ) . apply ( pr1 is ). apply (isweqcontrcontr f X0 is1).intros X Y f X0 X1. unfold isofhlevelf. simpl. assert (is1: forall x' x:X, isofhlevel n (paths x' x)). simpl in X0. assumption. assert (is2: forall y' y:Y, isofhlevel (S n) (paths y' y)). simpl in X1. simpl. assumption. assert (is3: forall (y:Y)(x:X)(xe': hfiber f y), isofhlevelf n (d2g f x xe')). intros. apply (IHn _ _ (d2g f x xe') (is1 (pr1 xe') x) (is2 (f x) y)). assert (is4: forall (y:Y)(x:X)(xe': hfiber f y)(e: paths (f x) y), isofhlevel n (paths (hfiberpair f x e) xe')). intros. apply (isofhlevelweqb n ( ezweq3g f x xe' e) (is3 y x xe' e)). intros y xe xe' . destruct xe as [ t x ]. apply (is4 y t xe' x). Defined.Theorem isofhlevelXfromfY ( n : nat ) { X Y : UU } ( f : X -> Y ) : isofhlevelf n f -> isofhlevel n Y -> isofhlevel n X. Proof. intro. induction n as [ | n IHn ] . intros X Y f X0 X1. apply (iscontrweqb ( weqpair f X0 ) X1). intros X Y f X0 X1. simpl. assert (is1: forall (y:Y)(xe xe': hfiber f y), isofhlevel n (paths xe xe')). intros. apply (X0 y). assert (is2: forall (y:Y)(x:X)(xe': hfiber f y), isofhlevelf n (d2g f x xe')). intros. unfold isofhlevel. intro y0. apply (isofhlevelweqf n ( ezweq3g f x xe' y0 ) (is1 y (hfiberpair f x y0) xe')). assert (is3: forall (y' y : Y), isofhlevel n (paths y' y)). simpl in X1. assumption. intros x' x . set (y:= f x'). set (e':= idpath y). set (xe':= hfiberpair f x' e'). apply (IHn _ _ (d2g f x xe') (is2 y x xe') (is3 (f x) y)). Defined. Theorem isofhlevelffib ( n : nat ) { X : UU } ( P : X -> UU ) ( x : X ) ( is : forall x':X, isofhlevel n (paths x' x) ) : isofhlevelf n ( tpair P x ) . 
as Q; [ | specialize (H Q); clear Q ] end end.Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.Tactic Notation "solve" "list" "eq" := solve_list_eq.Tactic Notation "solve_list_eq" "in" hyp(H) := generalize H; clear H; solve_list_eq; intro H. Tactic Notation "solve" "list" "eq" "in" hyp(H) := let Q := fresh in match goal with |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q end.Ltac msplit n := match n with | 0 => idtac | S ?n => split; [ | msplit n ] end.Tactic Notation "define" ident(f) "of" hyp(n) hyp(m) "as" uconstr(t) := match type of n with ?N => match type of m with ?M => pose (f (n:N) (m:M) := t) end end.Tactic Notation "induction" "on" hyp(x) hyp(y) "as" ident(IH) "with" "measure" uconstr(f) := generalize I; intro IH; let mes := fresh "measure" in let rel := fresh "relation" in let loop := fresh "loop" in let u := fresh "u" in let u' := fresh x in let Hu := fresh "Hu" in let v := fresh "v" in let v' := fresh y in let Hv := fresh "Hv" in clear IH; define mes of x y as (f : nat); set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel; pattern x, y; match goal with |- ?T _ _ => refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _); [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH; [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ] | unfold rel; apply wf_inverse_image, lt_wf ] end.Section forall_equiv. Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n). Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n). Proof. split; intros H n Hn; generalize (H _ Hn); apply HPQ; auto. Qed.End forall_equiv.Section exists_equiv. Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n). Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n). 
intuition. eapply synced_list_ipack_length_ok; eauto. Qed. Lemma items_valid_length_eq : forall xp a b, items_valid xp a -> items_valid xp b -> length (ipack a) = length (ipack b). Proof. unfold items_valid; intuition. eapply ipack_length_eq; eauto. Qed. Theorem get_ok : forall lxp xp ix ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ ix < length items ]] * [[[ m ::: Fm * rep xp items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[ r = selN items ix item0 ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} get lxp xp ix ms. Proof. unfold get, rep. safestep. rewrite synced_list_length, ipack_length. apply div_lt_divup; auto. safestep. subst; rewrite synced_list_selN; simpl. erewrite selN_val2block_equiv. apply ipack_selN_divmod; auto. apply list_chunk_wellformed; auto. unfold items_valid in *; intuition; auto. apply Nat.mod_upper_bound; auto. Qed. Theorem put_ok : forall lxp xp ix e ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ ix < length items /\ Rec.well_formed e ]] * [[[ m ::: Fm * rep xp items ]]] POST:hm' RET:ms' exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms' sm hm' * [[[ m' ::: Fm * rep xp (updN items ix e) ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} put lxp xp ix e ms. Proof. unfold put, rep. hoare; subst. rewrite synced_list_length, ipack_length; apply div_lt_divup; auto. rewrite synced_list_length, ipack_length; apply div_lt_divup; auto. unfold items_valid in *; intuition auto. apply arrayN_unify. rewrite synced_list_selN, synced_list_updN; f_equal; simpl. rewrite block2val_updN_val2block_equiv. apply ipack_updN_divmod; auto. apply list_chunk_wellformed. unfold items_valid in *; intuition; auto. apply Nat.mod_upper_bound; auto. apply items_valid_updN; auto. Qed. Theorem read_ok : forall lxp xp nblocks ms, {< F Fm m0 sm m items, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ nblocks <= RALen xp ]] * [[[ m ::: Fm * rep xp items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' * [[ r = firstn (nblocks * items_per_val) items ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} read lxp xp nblocks ms. Proof. unfold read, rep. hoare. rewrite synced_list_length, ipack_length. unfold items_valid in *; intuition. substl (length items); rewrite divup_mul; auto. subst; rewrite synced_list_map_fst. unfold items_valid in *; intuition. eapply iunpack_ipack_firstn; eauto. Qed. Theorem write_ok : forall lxp xp items ms, {< F Fm m0 sm m old, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[ items_valid xp items ]] * [[[ m ::: Fm * rep xp old ]]] POST:hm' RET:ms' exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') ms' sm hm' * [[[ m' ::: Fm * rep xp items ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} write lxp xp items ms. 
length vv. Let w : vec eill_vars n := proj1_sig (list_vec_full vv). Let Hw : vec_list w = vv. Proof. apply (proj2_sig (list_vec_full vv)). Qed. Let w_surj : forall u, In u vars -> exists p, u = vec_pos w p. Proof. intros u Hu. apply Hvv2 in Hu; rewrite <- Hw in Hu. revert Hu; apply vec_list_inv. Qed. Variables (x : eill_vars) (Hvalid : forall n s, @ill_sequent_tps n s (map (fun c => !‚¶ëc‚¶í) Œ£ ++ map ¬£ Œì) (¬£ x) vec_zero). Theorem G_eill_complete : Œ£; Œì ‚ä¶ x. Proof using Hvalid. apply G_eill_complete_bound with (1 := w_surj), Hvalid. Qed.End g_eill_complete.From Undecidability.ILL Require Import CLL ill_cll schellinx.Fact eill_no_bot c : ~ ill_has_bot ‚¶ë c ‚¶í. Proof. induction c; simpl; tauto. Qed.Section correctness_results_for_the_reduction. Variables (Œ£ : list eill_cmd) (Œì : list eill_vars) (u : nat). Notation Œ£i := (map (fun c => ill_ban ‚¶ëc‚¶í) Œ£). Notation Œìi := (map ill_var Œì). Notation ui := (ill_var u). Notation Œ£c := (map (fun c => cll_una cll_bang [‚¶ëc‚¶í]) Œ£). Notation Œìc := (map cll_var Œì). Notation uc := (cll_var u). Theorem G_eill_correct : (Œ£; Œì ‚ä¶ u -> S_ill_restr (Œ£i++Œìi) ui) /\ (S_ill_restr (Œ£i++Œìi) ui -> S_ill_restr_wc (Œ£i++Œìi) ui) /\ (S_ill_restr (Œ£i++Œìi) ui -> S_ill (Œ£i++Œìi) ui) /\ (S_ill_restr_wc (Œ£i++Œìi) ui -> S_ill_wc (Œ£i++Œìi) ui) /\ (S_ill (Œ£i++Œìi) ui -> S_ill_wc (Œ£i++Œìi) ui) /\ (S_ill_wc (Œ£i++Œìi) ui -> Œ£; Œì ‚ä¶ u). Proof. msplit 5. + apply G_eill_sound. + apply S_ill_restr_restr_wc. + apply S_ill_restr_full. + apply S_ill_restr_full_wc. + apply S_ill_full_wc. + intro; apply G_eill_complete. intros; now apply ill_tps_sound. Qed. Tactic Notation "solve" "with" int(i) int(j) := let H := fresh in split; [ intro; now do i apply G_eill_correct | intros H; now do j apply G_eill_correct in H ]. Corollary G_eill_S_ill_restr : Œ£; Œì ‚ä¶ u <-> S_ill_restr (Œ£i++Œìi) ui. Proof. solve with 1 3. Qed. Corollary G_eill_S_ill_restr_wc : Œ£; Œì ‚ä¶ u <-> S_ill_restr_wc (Œ£i++Œìi) ui. Proof. solve with 2 2. Qed. Corollary G_eill_S_ill : Œ£; Œì ‚ä¶ u <-> S_ill (Œ£i++Œìi) ui. Proof. solve with 2 2. Qed. Corollary G_eill_S_ill_wc : Œ£; Œì ‚ä¶ u <-> S_ill_wc (Œ£i++Œìi) ui. Proof. solve with 3 1. Qed. Let not_bot f : In f (ui :: Œ£i ++ Œìi) -> ~ ill_has_bot f. Proof. simpl; rewrite in_app_iff, !in_map_iff. intros [ <- | [ (? & <- & ?) | (? & <- & ?) ] ]; simpl; auto; apply eill_no_bot. Qed. Theorem G_eill_S_cll : Œ£; Œì ‚ä¶ u <-> S_cll (Œ£c++Œìc) (uc::nil). 
(compose C u (fst x), snd x) |} . End PMCM_PreSheaf_representing_d. Context {G : PreSheaf C} (N : @Monic (PShCat C) F G) (c : C). Section PreSheaf_Monic_components_Monic_is_Monic. Context (d : Type) (g h : d ‚Üí (F _o)%object c) (H : (fun x => Trans (mono_morphism N) c (g x)) = (fun x => Trans (mono_morphism N) c (h x))). Local Hint Extern 1 => match goal with [|- context [(F _a)%morphism (?A ‚àò ?B)%morphism] ] => cbn_rewrite (F_compose F A B) end : core. Program Definition PMCM_PreSheaf_morph_of_function (f : d ‚Üí (F _o)%object c) : (PMCM_PreSheaf_representing_d c d --> F)%nattrans := {| Trans := fun o x => (F _a (fst x))%morphism (f (snd x)) |}. Theorem PMCM_N_co_equalizes : ((mono_morphism N) ‚àò (PMCM_PreSheaf_morph_of_function g))%nattrans = ((mono_morphism N) ‚àò (PMCM_PreSheaf_morph_of_function h))%nattrans. Proof. apply NatTrans_eq_simplify. extensionality x. extensionality y. destruct y as [y1 y2]. cbn in *. set (W := equal_f (Trans_com (mono_morphism N) y1)). cbn in W. do 2 rewrite W. rewrite (equal_f H). trivial. Qed. Theorem PreSheaf_Monic_components_is_Monic : g = h. Proof. extensionality m. assert (W := f_equal (fun w : (PMCM_PreSheaf_representing_d c d --> F)%nattrans => Trans w c (id, m)) (mono_morphism_monomorphic N _ _ _ PMCM_N_co_equalizes) ). cbn in W. rewrite (F_id F) in W. trivial. Qed. End PreSheaf_Monic_components_Monic_is_Monic. Definition PreSheaf_Monic_components_Monic_Monic : Monic (F _o c)%object (G _o c)%object := {| mono_morphism := Trans (mono_morphism N) c; mono_morphism_monomorphic := PreSheaf_Monic_components_is_Monic |}. End PreSheaf_Monic_components_Monic. Section PreSheaf_Epic_components_Epic. Context {C : Category} {F G : PreSheaf C} (N : @Epic (PShCat C) F G) (c : C). Section PreSheaf_Epic_components_is_Epic. Context (d : Type) (g h : (G _o)%object c ‚Üí d) (H : (fun x => g (Trans (mono_morphism N) c x)) = (fun x => h (Trans (mono_morphism N) c x))). Local Hint Extern 1 => progress cbn : core. Local Hint Extern 1 => rewrite assoc : core. Program Definition PECE_PreSheaf_representing_d : PreSheaf C := {| FO := fun c' => (((Hom C c c') ‚Üí d))%object%morphism%type; FA := fun o o' u x y => (x (compose C y u)) |} . Local Hint Extern 1 => match goal with [|- context [(G _a)%morphism (?A ‚àò ?B)%morphism] ] => cbn_rewrite (F_compose G A B) end : core. Program Definition PECE_PreSheaf_morph_of_function (f : (G _o)%object c ‚Üí d) : (G --> PECE_PreSheaf_representing_d)%nattrans := {| Trans := fun o x y => f ((G _a y)%morphism x) |}. Theorem PECE_N_co_equalizes : ((PECE_PreSheaf_morph_of_function g) ‚àò (mono_morphism N))%nattrans = ((PECE_PreSheaf_morph_of_function h) ‚àò (mono_morphism N))%nattrans. 
| List.cons kh ktl => match index start kh fullname with | Some n => contains (n + length kh) ktl fullname | None => false end | List.nil => true end. Fixpoint eqb (a b : t) : bool := match a , b with | EmptyString , EmptyString => true | String x xs , String y ys => if ByteCompare.eqb x y then eqb xs ys else false | _ , _ => false end. Fixpoint compare (xs ys : t) : comparison := match xs , ys with | EmptyString , EmptyString => Eq | EmptyString , _ => Lt | _ , EmptyString => Gt | String x xs , String y ys => match ByteCompare.compare x y with | Eq => compare xs ys | x => x end end. Lemma eqb_compare xs ys : eqb xs ys = match compare xs ys with Eq => true | _ => false end. Proof. induction xs in ys |- *; destruct ys => /= //. rewrite ByteCompareSpec.eqb_compare. destruct ByteCompare.compare => //. Qed. Fixpoint concat (sep : t) (s : list t) : t := match s with | nil => EmptyString | cons s nil => s | cons s xs => s ++ sep ++ concat sep xs end.End String.Definition bs := String.t. Notation string := String.t.Bind Scope bs_scope with bs.String Notation String.t String.parse String.print : bs_scope.Notation "x ++ y" := (String.append x y) : bs_scope. Import String. Require Import Orders Coq.Structures.OrderedType.Lemma to_N_inj : forall x y, Byte.to_N x = Byte.to_N y <-> x = y. Proof. split. 2: destruct 1; reflexivity. intros. assert (Some x = Some y). { do 2 rewrite <- Byte.of_to_N. destruct H. reflexivity. } injection H0. auto. Qed.Module OT_byte <: OrderedType.OrderedType with Definition t := Byte.byte. Definition t := Byte.byte. Definition eq := @Logic.eq t. Definition lt := fun l r => ByteCompare.compare l r = Lt. Theorem eq_refl : forall x : t, eq x x. Proof. intros; apply eq_refl. Qed. Theorem eq_sym : forall x y : t, eq x y -> eq y x. Proof. apply eq_sym. Qed. Theorem eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z. Proof. apply eq_trans. Qed. Theorem lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z. Proof. exact ByteCompareSpec.lt_trans. Qed. Theorem lt_not_eq : forall x y : t, lt x y -> not (eq x y). 
BFILE.MSCache. Notation MSIAllocC := BFILE.MSIAllocC. Notation MSDBlocks := BFILE.MSDBlocks. Definition ifind lxp ixp inum (cond : item -> addr -> bool) ms0 := let^ (ms, nr) <- BFILE.getlen lxp ixp inum ms0; let^ (ms, ret) <- ForN i < nr Hashmap hm Ghost [ bxp F Fm Fi crash m0 sm m flist f items ilist frees ] Loopvar [ ms ret ] Invariant LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] * [[ ret = None -> forall ix, ix < i * items_per_val -> cond (selN items ix item0) ix = false ]] * [[ forall st, ret = Some st -> cond (snd st) (fst st) = true /\ (fst st) < length items /\ snd st = selN items (fst st) item0 ]] * [[ MSAlloc ms = MSAlloc ms0 ]] * [[ MSCache ms = MSCache ms0 ]] * [[ MSIAllocC ms = MSIAllocC ms0 ]] * [[ MSAllocC ms = MSAllocC ms0 ]] * [[ MSDBlocks ms = MSDBlocks ms0 ]] OnCrash crash Begin If (is_some ret) { Ret ^(ms, ret) } else { let^ (ms, v) <- BFILE.read_array lxp ixp inum 0 i ms; let r := ifind_block cond (val2block v) (i * items_per_val) in match r with | None => Ret ^(ms, None) | Some ifs => Ret ^(ms, Some ifs) end } Rof ^(ms, None); Ret ^(ms, ret). Local Hint Resolve items_per_val_not_0 items_per_val_gt_0 items_per_val_gt_0'. Lemma items_valid_updN : forall xp items a v, items_valid xp items -> Rec.well_formed v -> items_valid xp (updN items a v). Proof. unfold items_valid; intuition. rewrite length_updN; auto. apply Forall_wellformed_updN; auto. Qed. Lemma ifind_length_ok : forall xp i items, i < RALen xp -> items_valid xp items -> i < length (synced_list (ipack items)). Proof. unfold items_valid; intuition. eapply synced_list_ipack_length_ok; eauto. Qed. Lemma items_valid_length_eq : forall xp a b, items_valid xp a -> items_valid xp b -> length (ipack a) = length (ipack b). Proof. unfold items_valid; intuition. eapply ipack_length_eq; eauto. Qed. Hint Extern 0 (okToUnify (BFILE.rep _ _ _ _ _ _ _ _ _ _) (BFILE.rep _ _ _ _ _ _ _ _ _ _)) => setoid_rewrite <- surjective_pairing : okToUnify. Theorem get_ok : forall lxp ixp bxp inum ix ms, {< F Fm Fi m0 sm m flist f items ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[ ix < length items ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * [[ r = selN items ix item0 ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] * [[ MSAllocC ms' = MSAllocC ms]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} get lxp ixp inum ix ms. 
Require Import Util Option AllInRel Get Setoid. Require Export paco2. Require Import Coq.Logic.FunctionalExtensionality ClassicalFacts.Axiom propositional_extensionality : prop_extensionality.Notation "p =2= q" := (forall x0 x1, p x0 x1 <-> (q x0 x1:Prop)) (at level 50, no associativity). Lemma pred2_extensionality A B (R R' : A -> B -> Prop) : R =2= R' -> R = R'. Proof. intros. do 2 (eapply functional_extensionality; intros). eapply propositional_extensionality. eauto. Qed.Set Implicit Arguments.Section Tower2. Variables A B : Type. Variable f : (A -> B -> Prop) -> (A -> B -> Prop). Definition inf2 I (F: I -> A -> B -> Prop) : A -> B -> Prop := fun a b => forall i:I, F i a b. Inductive T2 : (A -> B -> Prop) -> Prop := | T2_step R : T2 R -> T2 (f R) | T2_lim I (F : I -> A -> B -> Prop) : (forall i, T2 (F i)) -> T2 (inf2 F). Definition companion2 (R : A -> B -> Prop) : A -> B -> Prop := fun a b => forall S, T2 S -> R <2= S -> S a b. Notation "'„öò'" := companion2 (at level 0). Lemma T_companion2 x : T2 (companion2 x). repeat (eapply T2_lim; intros). eauto. Qed. Lemma companion2_monotone : monotone2 companion2. hnf; intros. hnf; intros. eapply IN; eauto. Qed. Lemma companion2_inc R : R <2= companion2 R. intros; hnf; eauto. Qed. Lemma companion2_idem x : companion2 (companion2 x) = companion2 x. eapply pred2_extensionality; split. - intros H; eapply H; eauto using T_companion2. - eapply companion2_inc. Qed. Lemma companion2_img x : T2 x -> companion2 x = x. intros. eapply pred2_extensionality. split; intros; eauto using companion2_inc. - eapply H0; eauto. Qed. Definition inf2_closed (P: (A -> B -> Prop) -> Prop) := forall I (F : I -> A -> B -> Prop), (forall i, P (F i)) -> P (inf2 F). Theorem tower_ind2 P : inf2_closed P -> (forall x, P (companion2 x) -> P (f (companion2 x))) -> forall x, P (companion2 x). 
Node (c l1 l2) (f1 x1) (c1 r1) | Node111 l1 x1 r1, Node101 l2 r2 => Node (c l1 l2) (f1 x1) (c r1 r2) | Node111 l1 x1 r1, Node110 l2 x2 => Node (c l1 l2) (f' x1 x2) (c1 r1) | Node111 l1 x1 r1, Node111 l2 x2 r2 => Node (c l1 l2) (f' x1 x2) (c r1 r2) end. Lemma gcombine'_l: forall m i, get i (combine'_l m) = f (get' i m) None. Proof using A B C f f_None_None. intros. unfold combine'_l. rewrite gmap_filter'. destruct (get' i m); auto. Qed. Lemma gcombine'_r: forall m i, get i (combine'_r m) = f None (get' i m). Proof using A B C f f_None_None. intros. unfold combine'_r. rewrite gmap_filter'. destruct (get' i m); auto. Qed. Lemma gcombine'_direct: forall m1 m2 i, get i (combine'_direct m1 m2) = f (get' i m1) (get' i m2). Proof using A B C f f_None_None. induction m1; destruct m2; intros; simpl; rewrite gNode; destruct i; simpl; auto using gcombine'_l, gcombine'_r. Qed. Fixpoint combine'_by_tac (m1: tree' A) (m2: tree' B) {struct m1} : tree C. Proof using A B C f. destruct m1 as [ r1 | x1 | x1 r1 | l1 | l1 r1 | l1 x1 | l1 x1 r1 ]; destruct m2 as [ r2 | x2 | x2 r2 | l2 | l2 r2 | l2 x2 | l2 x2 r2 ]; (apply Node; [ solve [ exact (combine'_by_tac l1 l2) | exact (combine'_l l1) | exact (combine'_r l2) | exact Empty] | solve [ exact (f (Some x1) (Some x2)) | exact (f None (Some x2)) | exact (f (Some x1) None) | exact None] | solve [ exact (combine'_by_tac r1 r2) | exact (combine'_l r1) | exact (combine'_r r2) | exact Empty ] ]). Defined. Lemma gcombine'_by_tac: forall m1 m2 i, get i (combine'_by_tac m1 m2) = f (get' i m1) (get' i m2). Proof using A B C f f_None_None. induction m1; destruct m2; intros; simpl; rewrite gNode; destruct i; simpl; auto using gcombine'_l, gcombine'_r. Qed. Lemma combine'_by_tac_eq: combine'_by_tac = combine'_direct. Proof using Type. reflexivity. Qed. Definition combine (m1: tree A) (m2: tree B) : tree C := match m1, m2 with | Empty, Empty => Empty | Empty, Nodes m2 => combine'_r m2 | Nodes m1, Empty => combine'_l m1 | Nodes m1, Nodes m2 => combine'_by_tac m1 m2 end. Theorem gcombine: forall (m1: tree A) (m2: tree B) (i: positive), get i (combine m1 m2) = f (get i m1) (get i m2). 
Require Export Bool Arith Vector Lia. Import Vector VectorNotations.Arguments cons {A} _ {n} _ . Arguments nil {A}.Definition Vid {A : Type} {n:nat} : t A n -> t A n := match n with 0 => fun v => [] | S p => fun v => hd v :: tl v end.Lemma Vid_eq : forall (n:nat) (A:Type)(v:t A n), v = Vid v. Proof. destruct v; reflexivity. Defined. Theorem t_0_nil : forall (A:Type) (v:t A 0), v = nil. Proof. intros. change (nil (A:=A)) with (@Vid _ 0 v). apply Vid_eq. Defined. Theorem decomp : forall (A : Type) (n : nat) (v : t A (S n)), v = cons (hd v) (tl v). 
with (y := a); auto. apply eqT_compat_ltTl. apply eqT_sym; trivial. Qed. Hint Resolve ltP_order_comp. Set Implicit Arguments. Unset Strict Implicit. Definition nZterm : list (Term A n) -> Prop. intros H'; elim H'. exact True. intros a P1 Rec. exact (Rec /\ ~ zeroP (A:=A) A0 eqA (n:=n) a). Defined. Definition canonical (a : list (Term A n)) : Prop := olist a /\ nZterm a. Set Strict Implicit. Unset Implicit Arguments. Theorem canonical_imp_olist : forall a, canonical a -> olist a. intros a H'; elim H'; auto. Qed. Hint Resolve canonical_imp_olist. Theorem canonical0 : forall a b, ltT b a -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX a (pX b pO)). intros a b H' H'0 H'1; simpl in |- *; auto. split; simpl in |- *; auto. Qed. Theorem canonical_ltT : forall l a b, canonical (l ++ pX a (pX b pO)) -> ltT b a. intros l a b H'; auto. apply olist_ltT with (l := l); auto. Qed. Theorem canonical_nzeroP : forall a p, canonical (pX a p) -> ~ zeroP (A:=A) A0 eqA (n:=n) a. intros a p H'; red in |- *; intros H'0; inversion H'. generalize H0; simpl in |- *; intuition; auto. Qed. Theorem canonical_cons : forall l a b, ltT b a -> ~ zeroP (A:=A) A0 eqA (n:=n) a -> canonical (pX b l) -> canonical (pX a (pX b l)). intros l a b H' H'0 H'1; split; simpl in |- *; auto. apply olist_cons; auto. repeat split; auto. inversion H'1; simpl in H0; intuition. apply canonical_nzeroP with (p := l); auto. Qed. Theorem canonical_pX_eqT : forall a b p, canonical (pX a p) -> eqT a b -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> canonical (pX b p). intros a b p H' H'0 H'1. split; auto. apply olist_pX_eqT with (a := a); auto. simpl in |- *; split; auto. case H'; simpl in |- *; intuition. Qed. Theorem canonical_pX_order : forall l a b, canonical (pX a (pX b l)) -> ltT b a. intros l a b H'; auto. apply olist_pX_order with (l := l); auto. Qed. Theorem canonical_imp_canonical : forall l a, canonical (pX a l) -> canonical l. intros l a H'. split; auto. apply olist_X with (a := a); auto. elim H'; simpl in |- *; intuition. Qed. Theorem canonical_skip_fst : forall l a b, canonical (pX a (pX b l)) -> canonical (pX a l). 
: KV) (n : nat) : Comp (list (Bvector eta) * KV) := [k, v] <-2 state; v' <- f k (to_list v); [bits, v''] <-2 Gen_loop k v' n; k' <- f k (to_list v'' ++ zeroes); ret (bits, (k', v'')). Definition Generate_noV (state : KV) (n : nat) : Comp (list (Bvector eta) * KV) := [k, v] <-2 state; [bits, v'] <-2 Gen_loop k v n; k' <- f k (to_list v' ++ zeroes); ret (bits, (k', v')). Fixpoint Gen_loop_rb_intermediate (k : Bvector eta) (v : Bvector eta) (n : nat) : Comp (list (Bvector eta) * Bvector eta) := match n with | O => ret (nil, v) | S n' => v' <-$ {0,1}^eta; [bits, v''] <-$2 Gen_loop_rb_intermediate k v' n'; ret (v' :: bits, v'') end. Fixpoint Gen_loop_rb (n : nat) : Comp (list (Bvector eta)) := match n with | O => ret nil | S n' => v' <-$ {0,1}^eta; bits <-$ Gen_loop_rb n'; ret (v' :: bits) end.Definition Generate_rb_intermediate (state : KV) (n : nat) : Comp (list (Bvector eta) * KV) := [k, v] <-2 state; v' <-$ {0,1}^eta; [bits, v''] <-$2 Gen_loop_rb_intermediate k v' n; ret (bits, (k, v'')).Definition Generate_rb_oracle (tt : unit) (n : nat) : Comp (list (Bvector eta) * unit) := bits <-$ Gen_loop_rb n; ret (bits, tt).Definition Generate_rb (n : nat) : Comp (list (Bvector eta)) := bits <-$ Gen_loop_rb n; ret bits. Variable A : list (list (Bvector eta)) -> Comp bool. Hypothesis A_wf : forall ls, well_formed_comp (A ls).Variable blocksPerCall : nat. Variable numCalls : nat. Variable H_numCalls : numCalls > 0. Variable H_blocksPerCall : blocksPerCall > 0.Definition requestList : list nat := replicate numCalls blocksPerCall.Definition G1_prg : Comp bool := [k, v] <-$2 Instantiate; [head_bits, state'] <-$2 Generate_noV (k, v) blocksPerCall; [tail_bits, _] <-$2 oracleMap _ _ Generate_v state' (tail requestList); A (head_bits :: tail_bits). [k, v] <-$2 Instantiate; [head_bits, state'] <-$2 Generate_noV (k, v) (head blocksForEachCall); [tail_bits, state''] <-$2 oracleMap _ _ Generate_v state' (tail blocksForEachCall); [k', v'] <-$ UpdateV state''; A2 (head_bits :: tail_bits, (k', v')). *) Definition G_real : Comp bool := [k, v] <-$2 Instantiate; [bits, _] <-$2 oracleMap _ _ Generate (k, v) requestList; A bits. Definition G_real_split : Comp bool := [k, v] <-$2 Instantiate; [head_bits, state'] <-$2 Generate (k, v) blocksPerCall; [tail_bits, _] <-$2 oracleMap _ _ Generate state' (tail requestList); A (head_bits :: tail_bits). Theorem compFold_acc : forall numCalls0 bits acc state, comp_spec (fun x y : list (list (Bvector eta)) * KV => hd_error (fst x) = Some bits /\ tl (fst x) = fst y) (compFold (pair_EqDec (list_EqDec (list_EqDec eqdbv)) eqDecState) (fun (acc : list (list (Bvector eta)) * KV) (d : nat) => [rs, s]<-2 acc; z <-$ Generate s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (bits :: acc, state) (replicate numCalls0 blocksPerCall)) (compFold (pair_EqDec (list_EqDec (list_EqDec eqdbv)) eqDecState) (fun (acc : list (list (Bvector eta)) * KV) (d : nat) => [rs, s]<-2 acc; z <-$ Generate s d; [r, s0]<-2 z; ret (rs ++ r :: nil, s0)) (acc, state) (replicate numCalls0 blocksPerCall)). 
Require Export FSucc. Section pred. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition FPred (x : float) := match Z_eq_bool (Fnum x) (- pPred (vNum b)) with | true => Float (- nNormMin radix precision) (Zsucc (Fexp x)) | false => match Z_eq_bool (Fnum x) (nNormMin radix precision) with | true => match Z_eq_bool (Fexp x) (- dExp b) with | true => Float (Zpred (Fnum x)) (Fexp x) | false => Float (pPred (vNum b)) (Zpred (Fexp x)) end | false => Float (Zpred (Fnum x)) (Fexp x) end end. Theorem FPredSimpl1 : forall x : float, Fnum x = (- pPred (vNum b))%Z -> FPred x = Float (- nNormMin radix precision) (Zsucc (Fexp x)). intros x H'; unfold FPred in |- *. generalize (Z_eq_bool_correct (Fnum x) (- pPred (vNum b))); case (Z_eq_bool (Fnum x) (- pPred (vNum b))); auto. intros H'0; Contradict H'0; auto. Qed. Theorem FPredSimpl2 : forall x : float, Fnum x = nNormMin radix precision -> Fexp x <> (- dExp b)%Z -> FPred x = Float (pPred (vNum b)) (Zpred (Fexp x)). 
Trace imp oImp lsImp -> exists (oSpec : RegsT) (lsSpec : list (list FullLabel)), Trace spec oSpec lsSpec /\ Datatypes.length lsImp = Datatypes.length lsSpec /\ nthProp2 WeakInclusion lsImp lsSpec /\ simRel oImp oSpec. Proof. induction 1; subst; simpl; auto; intros. - pose proof (initRel HUpdRegs) as [rspec rspecProp]. exists rspec, []; repeat split; dest; auto. + econstructor 1; eauto. + unfold nthProp2; intros. destruct (nth_error [] i); auto. repeat split; intros; tauto. - dest. destruct l. + simpl in *. exists x, ([] :: x0); repeat split; simpl in *; auto. * constructor 2 with (o := x) (ls := x0) (l := []); simpl; auto. -- eapply Trace_Step_empty; eauto. -- clear. unfold UpdRegs; split; intros; try tauto. right; split; try intro; dest; auto. * rewrite nthProp2_cons; split; simpl; auto; repeat split; dest; simpl in *; try tauto. * pose proof (Trace_NoDup H NoDupRegs) as sth. pose proof (UpdRegs_nil_upd sth HUpdRegs); subst; auto. + specialize (stepSimulationNonZero HStep ltac:(intro; discriminate) HUpdRegs H3). destruct stepSimulationNonZero as [lSpec [oSpec' [stepSpec [updSpec [sim lSpecProp]]]]]. exists oSpec', (lSpec :: x0); repeat split; simpl in *; auto. * econstructor 2; eauto. * simpl. rewrite nthProp2_cons; split; auto. Qed. Theorem StepSimulation: TraceInclusion imp spec. Proof. unfold TraceInclusion; intros. eapply StepSimulation' in H. dest. exists x, x0. repeat split; auto. Qed. End StepSimulation.Lemma NoMeths_Substeps m o ls: getMethods m = [] -> Substeps m o ls -> ls = nil \/ exists u rl cs, ls = (u, (Rle rl, cs)) :: nil. Proof. intros nilMeths substeps. induction substeps; intros; auto; subst. - destruct IHsubsteps; subst. + right. repeat eexists; eauto. + dest; subst. specialize (HNoRle _ (or_introl eq_refl)); simpl in *. tauto. - rewrite nilMeths in *. simpl in *. tauto. Qed. Section SimulationZero. Variable imp spec: BaseModule. Variable simRel: RegsT -> RegsT -> Prop. Variable initRel: forall rimp, Forall2 regInit rimp (getRegisters imp) -> exists rspec, Forall2 regInit rspec (getRegisters spec) /\ simRel rimp rspec. Variable NoDupRegs: NoDup (map fst (getRegisters imp)). Variable NoMeths: getMethods imp = []. Variable NoMethsSpec: getMethods spec = []. Variable simulation: forall oImp uImp rleImp csImp oImp', Substeps imp oImp [(uImp, (Rle rleImp, csImp))] -> UpdRegs [uImp] oImp oImp' -> forall oSpec, simRel oImp oSpec -> ((getKindAttr oSpec = getKindAttr (getRegisters spec) /\ simRel oImp' oSpec /\ csImp = []) \/ (exists uSpec rleSpec oSpec', Substeps spec oSpec [(uSpec, (Rle rleSpec, csImp))] /\ UpdRegs [uSpec] oSpec oSpec' /\ simRel oImp' oSpec')). Theorem simulationZero: TraceInclusion (Base imp) (Base spec). 
An n <> 0) -> Un_cv (fun n:nat => Rabs (An (S n) / An n)) 0 -> { l:R | Pser An x l }. Proof. intros; set (Bn := fun i:nat => An i * x ^ i). cut (forall n:nat, Bn n <> 0). intro; cut (Un_cv (fun n:nat => Rabs (Bn (S n) / Bn n)) 0). intro; destruct (Alembert_C2 Bn H2 H3) as (x0,H4). exists x0; unfold Bn in H4; apply tech12; assumption. unfold Un_cv; intros; unfold Un_cv in H1; cut (0 < eps / Rabs x). intro; elim (H1 (eps / Rabs x) H4); intros. exists x0; intros; unfold R_dist; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r; rewrite Rabs_Rabsolu; unfold Bn; replace (An (S n) * x ^ S n / (An n * x ^ n)) with (An (S n) / An n * x). rewrite Rabs_mult; apply Rmult_lt_reg_l with (/ Rabs x). apply Rinv_0_lt_compat; apply Rabs_pos_lt; assumption. rewrite <- (Rmult_comm (Rabs x)); rewrite <- Rmult_assoc; rewrite <- Rinv_l_sym. rewrite Rmult_1_l; rewrite <- (Rmult_comm eps); unfold Rdiv in H5; replace (Rabs (An (S n) / An n)) with (R_dist (Rabs (An (S n) * / An n)) 0). apply H5; assumption. unfold R_dist; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r; rewrite Rabs_Rabsolu; unfold Rdiv; reflexivity. apply Rabs_no_R0; assumption. replace (S n) with (n + 1)%nat; [ idtac | ring ]; rewrite pow_add; unfold Rdiv; rewrite Rinv_mult_distr. replace (An (n + 1)%nat * (x ^ n * x ^ 1) * (/ An n * / x ^ n)) with (An (n + 1)%nat * x ^ 1 * / An n * (x ^ n * / x ^ n)); [ idtac | ring ]; rewrite <- Rinv_r_sym. simpl; ring. apply pow_nonzero; assumption. apply H0. apply pow_nonzero; assumption. unfold Rdiv; apply Rmult_lt_0_compat; [ assumption | apply Rinv_0_lt_compat; apply Rabs_pos_lt; assumption ]. intro; unfold Bn; apply prod_neq_R0; [ apply H0 | apply pow_nonzero; assumption ]. Defined.Lemma AlembertC3_step2 : forall (An:nat -> R) (x:R), x = 0 -> { l:R | Pser An x l }. Proof. intros; exists (An 0%nat). unfold Pser; unfold infinite_sum; intros; exists 0%nat; intros; replace (sum_f_R0 (fun n0:nat => An n0 * x ^ n0) n) with (An 0%nat). unfold R_dist; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0; assumption. induction n as [| n Hrecn]. simpl; ring. rewrite tech5; rewrite Hrecn; [ rewrite H; simpl; ring | unfold ge; apply le_O_n ]. Qed. Theorem Alembert_C3 : forall (An:nat -> R) (x:R), (forall n:nat, An n <> 0) -> Un_cv (fun n:nat => Rabs (An (S n) / An n)) 0 -> { l:R | Pser An x l }. 
first by lia. - move=> nt IH k /=. rewrite Cantor.cancel_of_to => ?. have ? := Cantor.to_nat_non_decreasing (S (term_to_nat nt)) 0. have -> : k = S (k - 1) by lia. by rewrite IH; first by lia. Qed.Lemma term_to_nat_pos t : term_to_nat t = S (Nat.pred (term_to_nat t)). Proof. by case: t. Qed.Opaque nat_to_term term_to_nat. Fixpoint term_to_msetcs (t: mset_term) : list msetc := match t with | mset_term_zero => [msetc_zero (term_to_nat t)] | mset_term_var x => [] | mset_term_plus u v => [msetc_sum (term_to_nat t) (term_to_nat u) (term_to_nat v)] ++ (term_to_msetcs u) ++ (term_to_msetcs v) | mset_term_h u => [msetc_h (term_to_nat t) (term_to_nat u)] ++ (term_to_msetcs u) end.Definition encode_eq (t u: mset_term) := [(msetc_sum 0 0 0); (msetc_sum (term_to_nat t) 0 (term_to_nat u))]. Definition encode_problem (msetcs : list constraint) : list msetc := flat_map (fun '(t, u) => (encode_eq t u) ++ term_to_msetcs t ++ term_to_msetcs u) msetcs.Lemma completeness {l} : FMsetTC_SAT l -> FMsetC_SAT (encode_problem l). Proof. move=> [œÜ] HœÜ. pose œà x := if x is 0 then [] else mset_sem œÜ (nat_to_term x). have H'œà (A) : œà (term_to_nat A) = mset_sem œÜ A. { by rewrite /œà nat_term_cancel term_to_nat_pos. } have Hœà (A) : Forall (msetc_sem œà) (term_to_msetcs A). { elim: A. - by constructor. - by rewrite /term_to_msetcs. - move=> A IHA B IHB /=. constructor; last by apply /Forall_app. by rewrite /msetc_sem !H'œà. - move=> A IH /=. constructor; last done. by rewrite /msetc_sem !H'œà. } exists œà. rewrite -Forall_forall /encode_problem Forall_flat_map. apply: Forall_impl; last eassumption. move=> [A B] HœÜAB. apply /Forall_app. split; last by apply /Forall_app. constructor; [done|constructor;[|done]]. rewrite /msetc_sem !H'œà. by apply /Permutation_count_occ. Qed.Lemma soundness {l} : FMsetC_SAT (encode_problem l) -> FMsetTC_SAT l. Proof. move=> [œà]. rewrite -Forall_forall Forall_flat_map => Hœà. pose œÜ x := œà (term_to_nat (mset_term_var x)). exists œÜ. apply: Forall_impl; last by eassumption. move=> [t u] /Forall_app [/Forall_cons_iff [+] /Forall_cons_iff [+ _]] /Forall_app [] => /=. move=> /Permutation_count_occ /(Permutation_app_inv_r _ []) /Permutation_nil -> /=. move=> /Permutation_count_occ Hœàtu. have HœÜ (s) : Forall (msetc_sem œà) (term_to_msetcs s) -> Permutation (mset_sem œÜ s) (œà (term_to_nat s)). { clear. elim: s. - by move=> /Forall_cons_iff /= [] /Permutation_count_occ ->. - done. - move=> t IHt u IHu /= /Forall_cons_iff /= [/Permutation_count_occ ->]. by move=> /Forall_app [/IHt -> /IHu ->]. - move=> t IH /= /Forall_cons_iff /= [/Permutation_count_occ ->]. by move=> /IH /Permutation_map. } by move=> /HœÜ -> /HœÜ ->. Qed.End Argument. Theorem reduction : FMsetTC_SAT ‚™Ø FMsetC_SAT. 
in |- *; case (Rle_dec r1 r2); auto with real; intros; apply Ropp_le_cancel; auto with real. Qed. Theorem RmaxSym : forall p q : R, Rmax p q = Rmax q p. intros p q; unfold Rmax in |- *. case (Rle_dec p q); case (Rle_dec q p); auto; intros H1 H2; apply Rle_antisym; auto. case (Rle_or_lt p q); auto; intros H'0; Contradict H1; apply Rlt_le; auto. case (Rle_or_lt q p); auto; intros H'0; Contradict H2; apply Rlt_le; auto. Qed. Theorem RmaxAbs : forall p q r : R, (p <= q)%R -> (q <= r)%R -> (Rabs q <= Rmax (Rabs p) (Rabs r))%R. intros p q r H' H'0; case (Rle_or_lt 0 p); intros H'1. repeat rewrite Rabs_right; auto with real. apply Rle_trans with r; auto with real. apply RmaxLess2; auto. apply Rge_trans with p; auto with real; apply Rge_trans with q; auto with real. apply Rge_trans with p; auto with real. rewrite (Rabs_left p); auto. case (Rle_or_lt 0 q); intros H'2. repeat rewrite Rabs_right; auto with real. apply Rle_trans with r; auto. apply RmaxLess2; auto. apply Rge_trans with q; auto with real. rewrite (Rabs_left q); auto. case (Rle_or_lt 0 r); intros H'3. repeat rewrite Rabs_right; auto with real. apply Rle_trans with (- p)%R; auto with real. apply RmaxLess1; auto. rewrite (Rabs_left r); auto. apply Rle_trans with (- p)%R; auto with real. apply RmaxLess1; auto. Qed. Theorem Rabsolu_Zabs : forall z : Z, Rabs (IZR z) = IZR (Zabs z). intros z; case z; simpl in |- *; auto with real. apply Rabs_right; auto with real. intros p0; apply Rabs_right; auto with real zarith. intros p0; unfold IZR; rewrite <- INR_IPR; rewrite Rabs_Ropp. apply Rabs_right; auto with real zarith. Qed. Theorem RmaxRmult : forall p q r : R, (0 <= r)%R -> Rmax (r * p) (r * q) = (r * Rmax p q)%R. intros p q r H; unfold Rmax in |- *. case (Rle_dec p q); case (Rle_dec (r * p) (r * q)); auto; intros H1 H2; auto. case H; intros E1. case H1; auto with real. rewrite <- E1; repeat rewrite Rmult_0_l; auto. case H; intros E1. case H2; auto with real. apply Rmult_le_reg_l with (r := r); auto. rewrite <- E1; repeat rewrite Rmult_0_l; auto. Qed. Theorem Rle_R0_Ropp : forall p : R, (p <= 0)%R -> (0 <= - p)%R. intros p H; rewrite <- Ropp_0; auto with real. Qed. Theorem Rlt_R0_Ropp : forall p : R, (p < 0)%R -> (0 < - p)%R. 
Require Import Le. Require Import Lt. Require Import Plus. Require Import Gt. Require Import Minus. Require Import Mult. Require Import TS. Require Import sigma_lift. Require Import comparith.Definition e_P2 (b : wsort) (U : TS b) : nat := (fix F (w : wsort) (t : TS w) {struct t} : nat := match t with | var _ => 1 | app t0 t1 => S (F wt t0 + F wt t1) | lambda t0 => 2 * F wt t0 | env t0 t1 => F wt t0 * S (F ws t1) | id => 1 | shift => 1 | cons t0 t1 => S (F wt t0 + F ws t1) | comp t0 t1 => F ws t0 * S (F ws t1) | lift t0 => 4 * F ws t0 | meta_X _ => 1 | meta_x _ => 1 end) b U. Notation P2 := (e_P2 _) (only parsing). Theorem P2_pos : forall (b : wsort) (M : TS b), e_P2 _ M > 0. 
From RecordUpdate Require Import RecordSet.From Tactical Require Import SimplMatch.From Perennial.program_proof Require Import disk_lib. From Perennial.program_proof Require Import wal.invariant wal.common_proof.Section goose_lang. Context `{!heapGS Œ£}. Context `{!walG Œ£}.Implicit Types (v:val) (z:Z). Implicit Types (Œ≥: wal_names). Implicit Types (s: log_state.t) (memLog: slidingM.t) (txns: list (u64 * list update.t)). Implicit Types (pos: u64) (txn_id: nat).Context (P: log_state.t -> iProp Œ£). Let N := walN. Let innerN := walN .@ "wal". Let circN := walN .@ "circ".Hint Unfold slidingM.memEnd : word. Hint Unfold slidingM.endPos : word. Hint Unfold slidingM.wf : word. Hint Unfold slidingM.numMutable : word.Theorem wp_WalogState__updatesOverflowU64 st œÉ (newUpdates: u64) : {{{ wal_linv_fields st œÉ }}} WalogState__updatesOverflowU64 #st #newUpdates {{{ (overflow:bool), RET #overflow; ‚åúoverflow = bool_decide (slidingM.memEnd œÉ.(memLog) + int.Z newUpdates >= 2^64)‚åù ‚àó wal_linv_fields st œÉ }}}. Proof. iIntros (Œ¶) "Hfields HŒ¶". iNamed "Hfields". iNamed "Hfield_ptsto". wp_call. rewrite /WalogState__memEnd. wp_loadField. wp_apply (wp_sliding__end with "His_memLog"); iIntros "His_memLog". wp_apply util_proof.wp_SumOverflows. iIntros (?) "->". iApply "HŒ¶". iSplit. { iPureIntro. apply bool_decide_ext. word. } iFrame. iExists _; by iFrame "# ‚àó". Qed.Theorem wp_WalogState__memLogHasSpace st œÉ (newUpdates: u64) : slidingM.memEnd œÉ.(memLog) + int.Z newUpdates < 2^64 -> {{{ wal_linv_fields st œÉ }}} WalogState__memLogHasSpace #st #newUpdates {{{ (has_space:bool), RET #has_space; ‚åúhas_space = bool_decide (slidingM.memEnd œÉ.(memLog) - int.Z œÉ.(diskEnd) + int.Z newUpdates ‚â§ LogSz)‚åù ‚àó wal_linv_fields st œÉ }}}. Proof. iIntros (Hnon_overflow Œ¶) "Hfields HŒ¶". iNamed "Hfields". iNamed "Hfield_ptsto". wp_call. rewrite /WalogState__memEnd. wp_loadField. wp_apply (wp_sliding__end with "His_memLog"); iIntros "His_memLog". wp_loadField. wp_pures. change (int.Z $ word.divu (word.sub 4096 8) 8) with LogSz. iAssert (wal_linv_fields st œÉ) with "[-HŒ¶]" as "Hfields". { iFrame. iExists _; by iFrame "# ‚àó". } wp_if_destruct; iApply "HŒ¶"; iFrame; iPureIntro. - symmetry; apply bool_decide_eq_false. revert Heqb; repeat word_cleanup. - symmetry; apply bool_decide_eq_true. revert Heqb; repeat word_cleanup. Qed. Theorem wp_WalogState__doMemAppend l q_b memLog bufs upds : {{{ "His_memLog" ‚à∑ is_sliding l q_b memLog ‚àó "Hupds" ‚à∑ updates_slice_frag' bufs 1 q_b upds ‚àó "%Hoverflow" ‚à∑ ‚åúslidingM.memEnd memLog + length upds < 2 ^ 64‚åù }}} doMemAppend #l (slice_val bufs) {{{ RET #(slidingM.endPos (memWrite memLog upds)); "His_memLog" ‚à∑ is_sliding l q_b (memWrite memLog upds) }}}. 
(Int.ltu n Int.iwordsize) eqn:?; simpl. destruct (shrimm_match a); intros. InvEval. simpl; rewrite Heqb. TrivialExists. destruct (Int.ltu (Int.add n n1) Int.iwordsize) eqn:?. InvEval. subst x. exists (Val.shr v1 (Vint (Int.add n n1))); split. EvalOp. simpl. rewrite mk_shift_amount_eq; auto. destruct v1; simpl; auto. rewrite s_range. simpl. rewrite Heqb. rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shr_shr; auto. apply s_range. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Theorem eval_shruimm: forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val.shru x (Vint n)). Proof. red; intros until x. unfold shruimm. predSpec Int.eq Int.eq_spec n Int.zero. intros; subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shru_zero; auto. destruct (Int.ltu n Int.iwordsize) eqn:?; simpl. destruct (shruimm_match a); intros. InvEval. simpl; rewrite Heqb. TrivialExists. destruct (Int.ltu (Int.add n n1) Int.iwordsize) eqn:?. InvEval. subst x. exists (Val.shru v1 (Vint (Int.add n n1))); split. EvalOp. simpl. rewrite mk_shift_amount_eq; auto. destruct v1; simpl; auto. destruct (Int.ltu n1 Int.iwordsize) eqn:?; simpl; auto. rewrite Heqb; rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shru_shru; auto. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\ Val.lessdef (Val.mul x (Vint n)) v). TrivialExists. econstructor. EvalOp. simpl; eauto. econstructor. eauto. constructor. rewrite Val.mul_commut. auto. generalize (Int.one_bits_decomp n). generalize (Int.one_bits_range n). destruct (Int.one_bits n). intros. auto. destruct l. intros. rewrite H1. simpl. rewrite Int.add_zero. replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul. apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib. destruct l. intros. rewrite H1. simpl. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exploit (eval_add (x :: le)). eexact A1. eexact A2. intros [v [A B]]. exists v; split. econstructor; eauto. rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. eapply Val.lessdef_trans. 2: eauto. apply Val.add_lessdef; auto. simpl. repeat rewrite H0; auto with coqlib. intros. auto. Qed. Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). 
Require Import Fcore_defs. Require Import Fcore_rnd. Require Import Fcore_generic_fmt. Require Import Fcore_float_prop.Section Fcore_ulp.Variable beta : radix.Notation bpow e := (bpow beta e).Variable fexp : Z -> Z.Lemma Z_le_dec_aux: forall x y : Z, (x <= y)%Z \/ ~ (x <= y)%Z. Proof. intros. destruct (Z_le_dec x y). now left. now right. Qed. Definition negligible_exp: option Z := match (LPO_Z _ (fun z => Z_le_dec_aux z (fexp z))) with | inleft N => Some (proj1_sig N) | inright _ => None end. Inductive negligible_exp_prop: option Z -> Prop := | negligible_None: (forall n, (fexp n < n)%Z) -> negligible_exp_prop None | negligible_Some: forall n, (n <= fexp n)%Z -> negligible_exp_prop (Some n). Lemma negligible_exp_spec: negligible_exp_prop negligible_exp. Proof. unfold negligible_exp; destruct LPO_Z as [(n,Hn)|Hn]. now apply negligible_Some. apply negligible_None. intros n; specialize (Hn n); omega. Qed.Lemma negligible_exp_spec': (negligible_exp = None /\ forall n, (fexp n < n)%Z) \/ exists n, (negligible_exp = Some n /\ (n <= fexp n)%Z). Proof. unfold negligible_exp; destruct LPO_Z as [(n,Hn)|Hn]. right; simpl; exists n; now split. left; split; trivial. intros n; specialize (Hn n); omega. Qed.Context { valid_exp : Valid_exp fexp }.Lemma fexp_negligible_exp_eq: forall n m, (n <= fexp n)%Z -> (m <= fexp m)%Z -> fexp n = fexp m. Proof. intros n m Hn Hm. case (Zle_or_lt n m); intros H. apply valid_exp; omega. apply sym_eq, valid_exp; omega. Qed.Definition ulp x := match Req_bool x 0 with | true => match negligible_exp with | Some n => bpow (fexp n) | None => 0%R end | false => bpow (canonic_exp beta fexp x) end.Lemma ulp_neq_0 : forall x:R, (x <> 0)%R -> ulp x = bpow (canonic_exp beta fexp x). Proof. intros x Hx. unfold ulp; case (Req_bool_spec x); trivial. intros H; now contradict H. Qed.Notation F := (generic_format beta fexp).Theorem ulp_opp : forall x, ulp (- x) = ulp x. Proof. intros x. unfold ulp. case Req_bool_spec; intros H1. rewrite Req_bool_true; trivial. rewrite <- (Ropp_involutive x), H1; ring. rewrite Req_bool_false. now rewrite canonic_exp_opp. intros H2; apply H1; rewrite H2; ring. Qed.Theorem ulp_abs : forall x, ulp (Rabs x) = ulp x. Proof. intros x. unfold ulp; case (Req_bool_spec x 0); intros H1. rewrite Req_bool_true; trivial. now rewrite H1, Rabs_R0. rewrite Req_bool_false. now rewrite canonic_exp_abs. now apply Rabs_no_R0. Qed.Theorem ulp_ge_0: forall x, (0 <= ulp x)%R. Proof. intros x; unfold ulp; case Req_bool_spec; intros. case negligible_exp; intros. apply bpow_ge_0. apply Rle_refl. apply bpow_ge_0. Qed. Theorem ulp_le_id: forall x, (0 < x)%R -> F x -> (ulp x <= x)%R. 
Require Import Verdi.GhostSimulations. Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems. Require Import VerdiRaft.OneLeaderPerTermInterface.Require Import VerdiRaft.CandidateEntriesInterface. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.VotesCorrectInterface. Require Import VerdiRaft.CroniesCorrectInterface. Require Import VerdiRaft.RefinementCommonTheorems.Require Import VerdiRaft.LeaderSublogInterface.#[global] Hint Extern 4 (@BaseParams) => apply base_params : typeclass_instances. #[global] Hint Extern 4 (@MultiParams _) => apply multi_params : typeclass_instances. #[global] Hint Extern 4 (@FailureParams _ _) => apply failure_params : typeclass_instances.Section LeaderSublogProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {cei : candidate_entries_interface}. Context {vci : votes_correct_interface}. Context {cci : cronies_correct_interface}. Context {olpti : one_leader_per_term_interface}. Ltac prove_in := match goal with | [ _ : nwPackets ?net = _, _ : In (?p : packet) _ |- _] => assert (In p (nwPackets net)) by (repeat find_rewrite; do_in_app; intuition) | [ _ : nwPackets ?net = _, _ : pBody ?p = _ |- _] => assert (In p (nwPackets net)) by (repeat find_rewrite; intuition) end. Notation is_append_entries m := (exists t n prevT prevI entries c, m = AppendEntries t n prevT prevI entries c). Lemma leader_sublog_invariant_same_state : forall net net', leader_sublog_host_invariant net -> (forall h, log (nwState net h) = log (nwState net' h)) -> (forall h, type (nwState net' h) = Leader -> type (nwState net h) = Leader /\ currentTerm (nwState net h) = currentTerm (nwState net' h)) -> leader_sublog_host_invariant net'. Proof using. unfold leader_sublog_host_invariant in *. intros. specialize (H leader e h). forward H; [apply H1; auto|]. intuition. rewrite H0 in *. specialize (H1 leader). intuition. rewrite H7 in *; auto. rewrite H0 in *. auto. Qed. Lemma leader_sublog_invariant_subset : forall net net', leader_sublog_invariant net -> (forall p, is_append_entries (pBody p) -> In p (nwPackets net') -> In p (nwPackets net)) -> (forall h, log (nwState net h) = log (nwState net' h)) -> (forall h, type (nwState net' h) = Leader -> type (nwState net h) = Leader /\ currentTerm (nwState net h) = currentTerm (nwState net' h)) -> leader_sublog_invariant net'. Proof using. unfold leader_sublog_invariant in *. intros; intuition. - eauto using leader_sublog_invariant_same_state. - unfold leader_sublog_nw_invariant in *. intros. pose proof H1 leader. pose proof H2 leader; concludes. pose proof H3 leader. intuition. symmetry in H13. repeat find_rewrite. eapply H11; simpl in *; repeat find_rewrite; eauto. assert (is_append_entries (pBody p)) by (repeat eexists; eauto). eauto. Qed. Theorem leader_sublog_do_leader : raft_net_invariant_do_leader leader_sublog_invariant. 
Require Import Arith List Permutation Omega. Require Import SortSpec.Require Import Tactics.Crush. Require Import Tactics.PermutationSolver. Require Import Tactics.Tactics.Module SelectSort <: Sorting.Lemma Forall_Permutation : forall A (l l' : list A) P, Forall P l -> Permutation l l' -> Forall P l'. Proof. intros. apply Forall_forall. intros. apply Permutation_sym in H0. eapply Permutation_in in H0; eauto. rewrite Forall_forall in H. apply H. apply H0. Qed.Definition AllLe (x : nat) (l : list nat) : Prop := Forall (fun y => x <= y) l.Definition lengthOrder (l1 l2 : list nat) := length l1 < length l2.Lemma lengthOrder_wf' : forall len l, length l <= len -> Acc lengthOrder l. Proof. unfold lengthOrder; induction len; intros; constructor; intros. + destruct l; crush. + apply IHlen; crush. Qed. Theorem lengthOrder_wf : well_founded lengthOrder. 
Require Import Undecidability.Synthetic.Definitions Undecidability.Synthetic.ReducibilityFacts.Require Import Undecidability.TM.TM. Require Import Undecidability.PCP.PCP.Require Undecidability.PCP.Reductions.HaltTM_1_to_PCP. Require Import Undecidability.PCP.Reductions.PCP_to_PCPb. Require Import Undecidability.PCP.Reductions.PCPb_iff_iPCPb. Theorem reduction : HaltTM 1 ‚™Ø iPCPb. 
_ _ _ _ _ _ _ cs) with (y := multA (plusA (divA a2 a0 nZc) (divA a1 a0 nZc)) (divA a0 a0 nZc)); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA (multA a0 (plusA (divA a2 a0 nZc) (divA a1 a0 nZc))) a0 nZc); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA (divA a0 a0 nZc) (plusA (divA a2 a0 nZc) (divA a1 a0 nZc))); auto. apply divA_multA_comp_r with (1 := cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA (plusA (divA a2 a0 nZc) (divA a1 a0 nZc)) A1); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply multA_eqA_comp with (1 := cs); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply divA_A1 with (1 := cs); auto. apply multA_A1_r with (1 := cs); auto. Qed. Theorem divTerm_invTerm_l : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) -> eqTerm (A:=A) eqA (n:=n) (divTerm (invTerm (A:=A) invA (n:=n) b) nZa) (invTerm (A:=A) invA (n:=n) (divTerm b nZa)). intros a b; case a; case b; simpl in |- *; auto. intros d c A0' c0 nZA2 H'0; split; auto. case H'0; intros H'1 H'2; clear H'0. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA (invA (multA (divA d A0' nZA2) A0')) A0' nZA2); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA (multA (invA (divA d A0' nZA2)) A0') A0' nZA2); auto. apply divA_eqA_comp with (1 := cs); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); apply multA_invA_com_l with (1 := cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA (invA (divA d A0' nZA2)) (divA A0' A0' nZA2)); auto. apply divA_multA_comp_l with (1 := cs). apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA (invA (divA d A0' nZA2)) A1); auto. apply multA_eqA_comp with (1 := cs); auto. apply divA_A1 with (1 := cs). apply multA_A1_r with (1 := cs). Qed. Theorem divTerm_invTerm_r : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZia : ~ zeroP (A:=A) A0 eqA (n:=n) (invTerm (A:=A) invA (n:=n) a)), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) -> eqTerm (A:=A) eqA (n:=n) (divTerm b nZia) (invTerm (A:=A) invA (n:=n) (divTerm b nZa)). 
in Eq0; rewrite <- Eq0; auto. apply (MaxUniqueP r); auto. Qed. Theorem ToInfinityUniqueP : UniqueP ToInfinityP. red in |- *. intros r p q H' H'0. inversion H'; inversion H'0; elim H0; elim H; clear H0 H; intros H'1 H'2 H'3 H'4. apply (MinUniqueP r); auto. cut (r = Fzero (- dExp b) :>R); [ intros Eq0 | apply Rle_antisym; unfold FtoRradix, Fzero, FtoR in |- *; simpl in |- * ]; try rewrite Rmult_0_l; auto with real. apply trans_eq with (FtoRradix (Fzero (- dExp b))). apply sym_eq; unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. cut (r = Fzero (- dExp b) :>R); [ intros Eq0 | apply Rle_antisym; unfold FtoRradix, Fzero, FtoR in |- *; simpl in |- * ]; try rewrite Rmult_0_l; auto with float. apply trans_eq with (FtoRradix (Fzero (- dExp b))). apply sym_eq; unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. apply (MaxUniqueP r); auto. Qed. Theorem MinOrMaxRep : forall P, MinOrMaxP P -> forall p q : float, P p q -> exists m : Z, q = Float m (Fexp p) :>R. intros P H' p q H'0; case (H' p q); auto; intros H'1. apply FminRep with (3 := pGivesBound); auto with arith. apply FmaxRep with (3 := pGivesBound); auto with arith. Qed. Theorem RoundedModeRep : forall P, RoundedModeP P -> forall p q : float, P p q -> exists m : Z, q = Float m (Fexp p) :>R. intros P H' p q H'0. apply MinOrMaxRep with (P := P); auto with inv. Qed. Definition SymmetricP (P : R -> float -> Prop) := forall (r : R) (p : float), P r p -> P (- r)%R (Fopp p). Theorem ToZeroSymmetric : SymmetricP ToZeroP. red in |- *; intros r p H'; case H'; clear H'; intros H'; case H'; intros H'1 H'2. right; split; auto. replace 0%R with (-0)%R; auto with real. apply MinOppMax; auto. left; split; auto. replace 0%R with (-0)%R; auto with real. apply MaxOppMin; auto. Qed. Theorem ToInfinitySymmetric : SymmetricP ToInfinityP. 
x) || a # x = 0 # x @a by (sum_id_l 0) || a = 0 # x @a by <- prod_sum_distrib_r x 0 0 || (0 # x) + (0 # x) = a @a by sum_id_r (0 # x) in sum_cancel_l (0 # x) 0 (0 # x) H. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof fun x => let H : (x # 0) + (x # 0) = 0 + (x # 0) := eq_refl (x # 0) || x # a = x # 0 @a by sum_id_r 0 || a = x # 0 @a by <- prod_sum_distrib_l x 0 0 || (x # 0) + (x # 0) = a @a by sum_id_l (x # 0) in sum_cancel_r (x # 0) 0 (x # 0) H. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof ex_ind (fun x (H : x # 0 = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_r x)). Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof ex_ind (fun x (H : 0 # x = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_l x)). Theorem prod_0_inv : ~ prod_has_inv 0. Proof ex_ind (fun x H => prod_0_inv_l (ex_intro (fun x => prod_is_inv_l 0 x) x (proj1 H))). Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof fun x y H (H0 : y = 0) => distinct_0_1 (proj1 H || a # x = 1 @a by <- H0 || a = 1 @a by <- prod_0_l x). Definition E_n1_strong : { x : E | sum_is_inv 1 x } := constructive_definite_description (sum_is_inv 1) (sum_inv_uniq_ex 1). Definition E_n1 : E := proj1_sig E_n1_strong. Notation "{-1}" := E_n1 : ring_scope. Theorem E_n1_def : sum_is_inv 1 {-1}. Proof proj2_sig E_n1_strong. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof proj1 E_n1_def. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof proj2 E_n1_def. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof fun x => sum_inv_uniq 1 {-1} x E_n1_def. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). Proof fun x => prod_0_l x || a # x = 0 @a by E_n1_inv_l || a = 0 @a by <- prod_sum_distrib_r x {-1} 1 || ({-1} # x) + a = 0 @a by <- prod_id_l x. Theorem prod_x_n1_inv_l : forall x : E, sum_is_inv_l x (x # {-1}). 
auto. + repeat find_rewrite. exfalso. eapply leaderLogs_candidate_entries_rvr; eauto; eauto using leaderLogs_candidate_entries_invariant, votes_correct_invariant, cronies_correct_invariant. congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * eauto. * subst. unfold raft_data in *. repeat find_rewrite. eapply lifted_leader_sublog_host; eauto. + eauto. - repeat update_destruct_max_simplify. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. eauto. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. discriminate. + eauto. Qed. Theorem leaderLogs_sublog_do_leader : refined_raft_net_invariant_do_leader leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_leader, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doLeader_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doLeader_same_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_do_generic_server : refined_raft_net_invariant_do_generic_server leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_generic_server, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doGenericServer_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doGenericServer_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset leaderLogs_sublog. 
Require Import Undecidability.Synthetic.Undecidability.Require Import Undecidability.StackMachines.SMN.Require Undecidability.StackMachines.Reductions.CM1_HALT_to_SMNdl_UB. Require Import Undecidability.CounterMachines.CM1_undec. Theorem SMNdl_UB_undec : undecidable SMNdl_UB. 
From iris.algebra Require Export big_op. From iris.proofmode Require Import tactics. From Perennial.base_logic Require Import ncfupd.Set Default Proof Using "Type". Set Default Goal Selector "!". Section filter. Context `{Countable K}. Context {A B : Type}. Theorem map_filter_lookup_key_in (m : gmap K A) (P : K -> Prop) (_ : ‚àÄ (ka : K * A), Decision (P ka.1)) i : P i -> filter (Œª x, P x.1) m !! i = m !! i. Proof. destruct (m !! i) eqn:He; intros. - rewrite map_filter_lookup_Some; eauto. - rewrite map_filter_lookup_None; eauto. Qed. Theorem map_filter_lookup_key_notin (m : gmap K A) (P : K -> Prop) (_ : ‚àÄ (ka : K * A), Decision (P ka.1)) i : ~ P i -> filter (Œª x, P x.1) m !! i = None. 
(51 + off)) by lia. bsm sss POP empty with ZERO (75 + off) (75 + off). replace (75 + off) with (24 + (51 + off)) by lia. bsm sss POP empty with ZERO (j + c * !q') (j + c * !q'). bsm sss stop. + change (j + 76 * !i) with off. bsm sss POP empty with ZERO END END. bsm sss stop. Qed. Fixpoint sim (n : nat) (H : n <= S (num_states M)) : list (bsm_instr 4). Proof using j. destruct n. - exact []. - refine (sim n _ ++ _). abstract lia. assert (Hn : n < S (num_states M)) by abstract lia. refine (PROG (Fin.of_nat_lt Hn)). Defined. Definition SIM : list (bsm_instr 4). refine (@sim (S (num_states M)) _). Proof using M j. abstract lia. Defined. Lemma sim_length (n : nat) (H : n <= S (num_states M)) : @length (bsm_instr 4) (@sim n H) = c * n. Proof. induction n. - unfold sim. cbn. lia. - unfold sim. fold sim. rewrite app_length. rewrite PROG_length. rewrite IHn. lia. Qed. Lemma SIM_length : length SIM = c * (S (num_states M)). Proof. unfold SIM. rewrite sim_length. lia. Qed. Arguments sim _ _ : clear implicits. Lemma of_nat_lt_0 n (H : 0 < S n) : Fin.of_nat_lt H = @Fin.F1 n. Proof. unfold Fin.of_nat_lt. reflexivity. Qed. Arguments Fin.of_nat_lt _ {_} _. Lemma PROG_sim_sc q n (H : n <= S (num_states M)) : ! q < n -> (j + 76 * ! q, PROG q) <sc (j, sim n H). Proof. revert q. induction n as [n IH] using lt_wf_ind; intros q. destruct n. - intros. lia. - intros H0. eapply le_lt_or_eq in H0 as [H0 | H0]. + unfold sim. fold sim. eapply subcode_app_end. eapply IH. lia. lia. + inversion H0. subst. clear H0. unfold sim. fold sim. revert H IH. eapply (Fin.caseS' q). * intros H IH. cbn [Fin.to_nat proj1_sig sim]. rewrite of_nat_lt_0. cbn - [PROG]. eexists [], []. split. rewrite app_nil_r. reflexivity. reflexivity. * clear q. intros q H IH. erewrite Fin.of_nat_ext. rewrite Fin.of_nat_to_nat_inv. eapply subcode_right. rewrite sim_length. pose proof (Fin.R_sanity 1 q). clear IH. cbn - [mult] in *. destruct (Fin.to_nat q). cbn - [mult] in *. inversion H0. reflexivity. Qed. Lemma PROG_sc q : (j + 76 * ! q, PROG q) <sc (j, SIM). Proof. eapply PROG_sim_sc. destruct (Fin.to_nat q). cbn. lia. Qed. Theorem SIM_computes q t q' t' : KOSBTM.eval M q t q' t' -> (j,SIM) // (j + c * !q, enc_tape t) ->> (END, enc_tape t'). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.PRF. Require Import hmacfcf.splitVector.Require Import hmacfcf.HMAC_spec.Section RelatedKeyAttack. Variable K D R Phi_s : Set. Variable K_EqDec : EqDec K. Variable D_EqDec : EqDec D. Variable R_EqDec : EqDec R. Variable RndK : Comp K. Variable RndR : Comp R. Variable f : K -> D -> R. Variable Phi : Phi_s -> K -> K. Variable A : OracleComp (Phi_s * D) R bool. Definition RKA_F k (s : unit) p := [phi_s, x] <-2 p; ret (f (Phi phi_s k) x, tt). Definition RKA_randomFunc := @randomFunc (K * D) R RndR _. Definition RKA_R k s p := [phi_s, x] <-2 p; (RKA_randomFunc s (Phi phi_s k, x)). Definition RKA_G0 := k <-$ RndK; [b, _] <-$2 A _ _ (RKA_F k) tt; ret b. Definition RKA_G1 := k <-$ RndK; [b, _] <-$2 A _ _ (RKA_R k) nil; ret b. Definition RKA_Advantage := | Pr[RKA_G0] - Pr[RKA_G1] |.End RelatedKeyAttack.Definition dual_f (A B C : Set)(f : A -> B -> C) : B -> A -> C := fun b a => f a b.Section NMAC_to_HMAC. Variable c p : nat. Definition b := @b c p. Variable h : Bvector c -> Bvector b -> Bvector c. Variable iv : Bvector c. Variable fpad : Bvector c -> Bvector p. Definition GHMAC_2K := GHMAC_2K h iv fpad. Variable opad ipad : Bvector b. Hypothesis opad_ne_ipad : opad <> ipad. Definition GHMAC := GHMAC h iv fpad opad ipad. Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Definition app_fpad := @app_fpad c p fpad. Definition h_star := h_star p h. Definition GNMAC := GNMAC h fpad. Definition A_NMAC := x <-$ {0, 1}^(c + c); [b, _] <-$2 A _ _ (f_oracle GNMAC _ x) tt; ret b. Definition A_HMAC := x <-$ {0, 1}^b; [b, _] <-$2 A _ _ (f_oracle GHMAC _ x) tt; ret b. Theorem GHMAC_2K_GNMAC_equiv : forall k ls, let (k_Out, k_In) := splitVector b b k in let k' := Vector.append (h iv k_Out) (h iv k_In) in GHMAC_2K k ls = GNMAC k' ls. 
p)))). apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply eqp_pluspf_com with (1 := cs); auto. apply canonical_mults with (1 := cs); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec r (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=b) nZb) q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec r (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=a) nZa) p))); auto; apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem eqTerm_spolyf_red3 : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX a p)) (Cpxb : canonical A0 eqA ltM (pX b q)), canonical A0 eqA ltM r -> eqP A eqA n (spolyf (pX a p) (pX b q) Cpxa Cpxb) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (ppc (A:=A) A1 (n:=n) a b) b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (ppc (A:=A) A1 (n:=n) a b) a nZa r p)). intros a b nZa nZb p q r Cpxa Cpxb H'1. cut (~ zeroP (A:=A) A0 eqA (n:=n) (ppc (A:=A) A1 (n:=n) a b)); [ intros nZppab | auto ]. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) (T1 A1 n) (spolyf (pX a p) (pX b q) Cpxa Cpxb)). apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a b) (b:=ppc (A:=A) A1 (n:=n) a b) nZppab) (spolyf (pX a p) (pX b q) Cpxa Cpxb)). apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply eqTerm_spolyf_red2; auto. Qed. Theorem spoly_is_minus : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX a p)) (Cpxb : canonical A0 eqA ltM (pX b q)), eqP A eqA n (spolyf (pX a p) (pX b q) Cpxa Cpxb) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a b) (b:=a) nZa) (pX a p)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a b) (b:=b) nZb) (pX b q))). 
From mathcomp Require Import ssreflect.Module LogicPrimer. Print True.Theorem true_is_true: True.Proof. exact: I.Qed.Definition true_is_true': True := I.Eval compute in true_is_true. Eval compute in true_is_true'. Print False.Check False_ind.Theorem one_eq_two: False -> 1 = 2. Proof.exact: (False_ind (1 = 2)).Undo.apply: False_ind.Undo.case.Undo.exact: (fun (f: False) => match f with end).Qed.Theorem imp_trans: forall P Q R: Prop, (P -> Q) -> (Q -> R) -> P -> R. Proof.move=> A B C. move=> H1 H2 a. exact: (H2 (H1 a)).Undo.apply: H2. apply: H1. exact: a. Qed.Print imp_trans. Theorem imp_trans' (P Q R: Prop) : (Q -> R) -> (P -> Q) -> P -> R. 
v e, correct_envs cenv ienv crep rho e -> correct_cenv_of_val cenv v -> correct_envs cenv ienv crep (M.set x v rho) e. Proof. intros. inv H. inv H2. inv H3. split; auto. split; auto. intro; intros. destruct (var_dec x0 x). - subst. rewrite M.gss in H3. inv H3. auto. - rewrite M.gso in H3 by auto. eapply H; eauto. Qed. Definition correct_tinfo: program -> Z -> temp_env -> mem -> Prop := fun p max_alloc lenv m => exists alloc_b alloc_ofs limit_ofs args_b args_ofs tinf_b tinf_ofs, M.get allocIdent lenv = Some (Vptr alloc_b alloc_ofs) /\ (align_chunk int_chunk | Ptrofs.unsigned alloc_ofs)%Z /\ Mem.range_perm m alloc_b (Ptrofs.unsigned alloc_ofs) (Ptrofs.unsigned limit_ofs) Cur Writable /\ M.get limitIdent lenv = Some (Vptr alloc_b limit_ofs) /\ (int_size*max_alloc <= (Ptrofs.unsigned limit_ofs - Ptrofs.unsigned alloc_ofs) <= gc_size)%Z /\ M.get argsIdent lenv = Some (Vptr args_b args_ofs) /\ args_b <> alloc_b /\ ((Ptrofs.unsigned args_ofs)+ int_size * max_args <= Ptrofs.max_unsigned)%Z /\ (forall i, 0 <= i < max_args -> Mem.valid_access m int_chunk args_b (Ptrofs.unsigned (Ptrofs.add args_ofs (Ptrofs.mul (Ptrofs.repr int_size) (Ptrofs.repr i)))) Writable)%Z /\ M.get tinfIdent lenv = Some (Vptr tinf_b tinf_ofs) /\ tinf_b <> args_b /\ tinf_b <> alloc_b /\ (forall i, 0 <= i < 4 -> Mem.valid_access m int_chunk tinf_b (Ptrofs.unsigned (Ptrofs.add tinf_ofs (Ptrofs.repr (int_size*i)))) Writable)%Z /\ deref_loc (Tarray uval maxArgs noattr) m tinf_b (Ptrofs.add tinf_ofs (Ptrofs.repr (int_size*3))) (Vptr args_b args_ofs) /\ (forall x b, Genv.find_symbol (globalenv p) x = Some b -> b <> args_b /\ b <> alloc_b /\ b <> tinf_b /\ (exists chunk, Mem.valid_access m chunk b 0%Z Nonempty)). Theorem range_perm_to_valid_access: forall alloc_b alloc_ofs limit_ofs size m, Mem.range_perm m alloc_b alloc_ofs limit_ofs Cur Writable -> forall ofs, (align_chunk size | ofs)%Z -> (alloc_ofs <= ofs)%Z -> (ofs + size_chunk size <= limit_ofs)%Z -> Mem.valid_access m size alloc_b ofs Writable. Proof. intros. constructor; auto. intro. intro. eapply H. omega. Qed. Theorem correct_tinfo_mono: forall p z lenv m, correct_tinfo p z lenv m -> forall z', (0 <= z' <= z)%Z -> correct_tinfo p z' lenv m. Proof. intros. inv H; destructAll. do 7 eexists. repeat (split; eauto). unfold int_size in *. chunk_red; omega. Qed. Theorem correct_tinfo_proper: forall p z lenv m lenv', correct_tinfo p z lenv m -> map_get_r_l _ [argsIdent; limitIdent; allocIdent; tinfIdent] lenv lenv' -> correct_tinfo p z lenv' m. Proof. intros. inv H; destructAll. exists x, x0, x1, x2, x3, x4, x5. repeat (split; auto; try (rewrite <- H0; auto; inList)). Qed. Theorem correct_tinfo_not_protected: forall p z lenv m, correct_tinfo p z lenv m -> forall x v, ~ is_protected_tinfo_id_thm x -> x <> tinfIdent -> correct_tinfo p z (M.set x v lenv) m. 
- change (Zpos p~0) with (2*Zpos p). now rewrite Z.log2_up_double, IHp. - reflexivity. Qed. Hint Resolve Z.le_trans: zarith. Theorem log_inf_correct : forall x:positive, 0 <= log_inf x /\ two_p (log_inf x) <= Zpos x < two_p (Z.succ (log_inf x)). Proof. simple induction x; intros; simpl; [ elim H; intros Hp HR; clear H; split; [ auto with zarith | rewrite two_p_S with (x := Z.succ (log_inf p)) by (apply Z.le_le_succ_r; trivial); rewrite two_p_S by trivial; rewrite two_p_S in HR by trivial; rewrite (BinInt.Pos2Z.inj_xI p); omega ] | elim H; intros Hp HR; clear H; split; [ auto with zarith | rewrite two_p_S with (x := Z.succ (log_inf p)) by (apply Z.le_le_succ_r; trivial); rewrite two_p_S by trivial; rewrite two_p_S in HR by trivial; rewrite (BinInt.Pos2Z.inj_xO p); omega ] | unfold two_power_pos; unfold shift_pos; simpl; omega ]. Qed. Definition log_inf_correct1 (p:positive) := proj1 (log_inf_correct p). Definition log_inf_correct2 (p:positive) := proj2 (log_inf_correct p). Opaque log_inf_correct1 log_inf_correct2. Hint Resolve log_inf_correct1 log_inf_correct2: zarith. Lemma log_sup_correct1 : forall p:positive, 0 <= log_sup p. Proof. simple induction p; intros; simpl; auto with zarith. Qed. Theorem log_sup_log_inf : forall p:positive, IF Zpos p = two_p (log_inf p) then Zpos p = two_p (log_sup p) else log_sup p = Z.succ (log_inf p). Proof. simple induction p; intros; [ elim H; right; simpl; rewrite (two_p_S (log_inf p0) (log_inf_correct1 p0)); rewrite BinInt.Pos2Z.inj_xI; unfold Z.succ; omega | elim H; clear H; intro Hif; [ left; simpl; rewrite (two_p_S (log_inf p0) (log_inf_correct1 p0)); rewrite (two_p_S (log_sup p0) (log_sup_correct1 p0)); rewrite <- (proj1 Hif); rewrite <- (proj2 Hif); auto | right; simpl; rewrite (two_p_S (log_inf p0) (log_inf_correct1 p0)); rewrite BinInt.Pos2Z.inj_xO; unfold Z.succ; omega ] | left; auto ]. Qed. Theorem log_sup_correct2 : forall x:positive, two_p (Z.pred (log_sup x)) < Zpos x <= two_p (log_sup x). Proof. intro. elim (log_sup_log_inf x). intros [E1 E2]; rewrite E2. split; [ apply two_p_pred; apply log_sup_correct1 | apply Z.le_refl ]. intros [E1 E2]; rewrite E2. rewrite (Z.pred_succ (log_inf x)). generalize (log_inf_correct2 x); omega. Qed. Lemma log_inf_le_log_sup : forall p:positive, log_inf p <= log_sup p. Proof. simple induction p; simpl; intros; omega. Qed. Lemma log_sup_le_Slog_inf : forall p:positive, log_sup p <= Z.succ (log_inf p). Proof. simple induction p; simpl; intros; omega. Qed. Fixpoint log_near (x:positive) : Z := match x with | xH => 0 | xO xH => 1 | xI xH => 2 | xO y => Z.succ (log_near y) | xI y => Z.succ (log_near y) end. Theorem log_near_correct1 : forall p:positive, 0 <= log_near p. 
Require Export Plus. Require Export Mult. Require Import Minus. Require Export Lt. Require Export Le. Require Export Gt. Lemma plus_n_SO : forall x : nat, x + 1 = S x. intros; rewrite plus_comm; auto with arith. Qed. Hint Resolve plus_n_SO.Lemma plus_permute2 : forall x y z : nat, x + y + z = x + z + y. intros. rewrite (plus_comm x y). rewrite (plus_comm x z). rewrite plus_comm. symmetry in |- *. rewrite plus_comm. rewrite plus_permute. auto with arith. Qed. Hint Resolve plus_permute2.Lemma mult_sym : forall a b : nat, a * b = b * a. intros a b; elim a; simpl in |- *; auto with arith. intros y H. replace (y * b) with (b * y). elim (mult_n_Sm b y). apply plus_comm. Qed. Hint Resolve mult_sym.Lemma mult_permute : forall a b c : nat, a * b * c = a * c * b. intros. rewrite mult_assoc_reverse. rewrite mult_assoc_reverse. replace (c * b) with (b * c); auto with arith. Qed. Hint Resolve mult_permute.Lemma plus_O_O : forall n m : nat, n + m = 0 -> n = 0. simple induction n. intros. trivial with arith. intros. inversion H0. Qed.Lemma mult_plus_distr2 : forall n m p : nat, n * (m + p) = n * m + n * p. intros. rewrite mult_sym. rewrite mult_plus_distr_r. rewrite mult_sym. replace (p * n) with (n * p). trivial with arith. apply mult_sym. Qed. Fixpoint power2 (n : nat) : nat := match n with | O => 1 | S x => power2 x + power2 x end.Lemma power2_eq2 : forall x : nat, power2 (S x) = power2 x + power2 x. Proof. auto with arith. Qed.Lemma power2_plus : forall x y : nat, power2 (x + y) = power2 x * power2 y. simple induction x. intros. simpl in |- *. elim plus_n_O; auto with arith. intros. simpl in |- *. rewrite H. rewrite mult_plus_distr_r. trivial with arith. Qed. Theorem le_plus_n_m : forall n m : nat, n <= m -> n + n <= m + m. 
append_all in H. apply in_map_iff in H as [[a b][H1 H2]]. cbn in H1. exists (M_enc_card a b). split; try now apply enc_stack_el. exists (M_enc_string a), (M_enc_string b). split; trivial. assert (u = s++a) as -> by congruence. assert (v = t++b) as -> by congruence. now rewrite !M_prep_enc. - intros (u&H&a&b&->&->). apply enc_stack_el' in H as [u[v[H1 H2]]]. apply opair_inj in H2 as [-> ->]. rewrite !M_prep_enc. apply enc_stack_el. apply in_map_iff. now exists (u, v). Qed. Lemma M_combinations_step B C : M_combinations B (M_enc_stack C) (M_enc_stack (derivation_step B C)). Proof using VIEQ M_ZF. induction B as [|[s t] B IH]; cbn; trivial. exists (M_enc_stack (derivation_step B C)), (M_enc_stack (append_all C (s, t))). rewrite M_enc_stack_app. split; trivial. split; trivial. apply comb_rel_rep. Qed. Lemma solutions_derivations B f n k : M_solutions B f (numeral n) -> k <= n -> M_opair (numeral k) (M_enc_stack (derivations B k)) ‚àà f. Proof using VIEQ M_ZF. intros H Hk; induction k; cbn. - apply H. - assert (Hk' : k <= n) by lia. specialize (IHk Hk'). destruct H as [_ H]. eapply H in IHk; eauto. + now apply numeral_lt. + apply M_combinations_step. Qed. Lemma derivations_derivable B n s t : (s, t) el derivations B n -> derivable B s t. Proof. induction n in s,t|-*; cbn. - now constructor. - unfold derivation_step. intros [[u v][H1 H2]] % in_flat_map. unfold append_all in H2. apply in_map_iff in H2 as [[a b][H2 H3]]. cbn in H2. assert (s = u++a) as -> by congruence. assert (t = v++b) as -> by congruence. constructor 2; trivial. apply IHn, H3. Qed. Definition M_function f := forall x y y', M_opair x y ‚àà f -> M_opair x y' ‚àà f -> y = y'. Definition standard := forall x, x ‚àà œâ -> exists n, x ‚â° numeral n. Lemma M_solutions_el B f k X p : standard -> k ‚àà œâ -> M_function f -> M_solutions B f k -> M_opair k X ‚àà f -> p ‚àà X -> exists u v, p = M_enc_card u v /\ derivable B u v. Proof using VIEQ M_ZF. intros HS HO Hf Hk HX Hp. destruct (HS k HO) as [n -> % VIEQ]. pose proof (H := solutions_derivations Hk (le_n n)). rewrite (Hf _ _ _ HX H) in Hp. apply enc_stack_el' in Hp as (s&t&H'&->). exists s, t. split; trivial. eapply derivations_derivable; eauto. Qed. Theorem PCP_ZF2 B rho : standard -> rho ‚ä® solvable B -> exists s, derivable B s s. 
H'6; clear H'2 H'0. apply pX_inj; auto. apply Induc with (y := (l1, pX n2 l2)); auto. red in |- *; red in |- *; simpl in |- *; auto. elim H'1; intros H' H'2; clear H'1. elim H'0; intros H'1 H'3; clear H'0. absurd (ltT ltM n1 n2); auto. elim H'1; intros H' H'2; clear H'1. elim H'0; intros H'1 H'3; clear H'0. absurd (eqT n2 n1); auto. apply (eqT_sym A n); auto. elim H'1; intros H' H'2; clear H'1. elim H'0; intros H'1 H'3; clear H'0. absurd (ltT ltM n1 n2); auto. elim H'1; intros H' H'2; elim H'2; intros H'3 H'4; rewrite H'4; clear H'2 H'1. elim H'0; intros H'1 H'2; elim H'2; intros H'5 H'6; rewrite H'6; clear H'2 H'0. apply pX_inj; auto. apply Induc with (y := (pX n1 l1, l2)); auto; red in |- *; simpl in |- *; auto. rewrite <- plus_n_Sm; auto. elim H'1; intros H' H'2; clear H'1. elim H'0; intros H'1 H'3; clear H'0. absurd (eqT n1 n2); auto. elim H'1; intros H' H'2; clear H'1. elim H'0; intros H'1 H'3; clear H'0. absurd (eqT n2 n1); auto. apply (eqT_sym A n); auto. elim H'1; intros H' H'2; clear H'1. elim H'0; intros H'1 H'3; clear H'0. absurd (eqT n1 n2); auto. elim H'1; intros H' H'2; elim H'2; [ intros H'3; clear H'2 H'1 | intros H'3; elim H'3; intros H'4 H'5; elim H'5; intros H'6 H'7; rewrite H'7; clear H'5 H'3 H'2 H'1 ]. elim H'0; intros H'1 H'2; elim H'2; [ intros H'4; clear H'2 H'0 | intros H'4; elim H'4; intros H'5 H'6; apply H'5 || elim H'5; try assumption; clear H'4 H'2 H'0 ]. elim H'4; intros H'0 H'2; clear H'4. elim H'3; intros H'4 H'5; clear H'3. apply Induc with (y := (l1, l2)); auto. red in |- *; red in |- *; simpl in |- *; rewrite <- plus_n_Sm; auto. elim H'3; intros H'0 H'2; clear H'3; auto. elim H'0; intros H'1 H'2; elim H'2; [ intros H'3; clear H'2 H'0 | intros H'3; elim H'3; intros H'5 H'8; elim H'8; intros H'9 H'10; rewrite H'10; clear H'8 H'3 H'2 H'0 ]. elim H'3; intros H'0 H'2; clear H'3. apply H'4 || elim H'4; auto. apply pX_inj; auto. apply Induc with (y := (l1, l2)); auto. red in |- *; red in |- *; simpl in |- *; rewrite <- plus_n_Sm; auto. Qed. Theorem minuspf_is_minusP : forall l1 l2 : list (Term A n), minusP l1 l2 (minuspf l1 l2). 
rewrite <- Heqz. trivial. subst. eauto. eapply arrayLookup_Some_In_split. eauto. assert (l = (fst (split x2))). rewrite <- Heqz. trivial. subst. unfold funcCollision in *. simpl in *. unfold collidesWith. destruct (findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. trivial. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq in H2; eauto. inversion H2; clear H2; subst. intuition. unfold funcCollision, collidesWith in *. simpl in *. assert (l = fst (split x2)). rewrite <- Heqz. trivial. subst. destruct (findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. trivial. comp_irr_l. eapply comp_spec_ret; intuition. simpl in *. remember (split x2) as z. destruct z. simpl. trivial. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq in H2; eauto. discriminate. assert (l = fst (split x2)). rewrite <- Heqz. trivial. subst. eapply funcCollision_false_impl_collidesWith_false. unfold funcCollision in *. simpl in *. destruct ( findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. eauto. eapply arrayLookup_Some_In_split. eauto. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq in H2; eauto. discriminate. assert (l = fst (split x2)). rewrite <- Heqz. trivial. subst. eapply funcCollision_false_impl_collidesWith_false. unfold funcCollision in *. simpl in *. destruct ( findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. eauto. eapply arrayLookup_Some_In_split. eauto. case_eq (arrayLookup_f (Bvector_EqDec b) x2 (F x a)); intuition. comp_irr_r. eapply comp_spec_ret; intuition. simpl. remember (split x2) as z. destruct z. simpl. trivial. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq_f in H; eauto. discriminate. unfold funcCollision, collidesWith in *. simpl in *. assert (l = (fst (split x2))). rewrite <- Heqz. trivial. subst. destruct (findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. trivial. simpl in *. remember (split x2) as z. destruct z. simpl in *. erewrite arrayLookup_noCollision_eq_f in H; eauto. discriminate. unfold funcCollision, collidesWith in *. simpl in *. assert (l = (fst (split x2))). rewrite <- Heqz. trivial. subst. destruct (findCollision_1 (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b) (fst (split x2)) a (F x a)). discriminate. trivial. comp_skip. apply (oneVector c). apply (oneVector c). eapply comp_spec_ret; intuition. intros. eapply F_randomFunc_preserves_coll; eauto. intuition. eapply randomFunc_mem_preserves_coll; eauto. trivial. trivial. intuition. simpl in *; subst. destruct b1; trivial. Unshelve. trivial. Qed. Theorem G2_3_4_bad_eq : Pr[x <-$ G2_3; ret (snd x)] == Pr[x <-$ G2_4; ret (snd x)]. 
ring_simplify. now apply ln_beta_le_Zpower. Qed.Theorem FLT_format_generic : forall x, generic_format beta FLT_exp x -> FLT_format x. Proof. intros x. unfold generic_format. set (ex := canonic_exp beta FLT_exp x). set (mx := Ztrunc (scaled_mantissa beta FLT_exp x)). intros Hx. rewrite Hx. eexists ; repeat split ; simpl. apply lt_Z2R. rewrite Z2R_Zpower. 2: now apply Zlt_le_weak. apply Rmult_lt_reg_r with (bpow ex). apply bpow_gt_0. rewrite <- bpow_plus. change (F2R (Float beta (Zabs mx) ex) < bpow (prec + ex))%R. rewrite F2R_Zabs. rewrite <- Hx. destruct (Req_dec x 0) as [Hx0|Hx0]. rewrite Hx0, Rabs_R0. apply bpow_gt_0. unfold canonic_exp in ex. destruct (ln_beta beta x) as (ex', He). simpl in ex. specialize (He Hx0). apply Rlt_le_trans with (1 := proj2 He). apply bpow_le. cut (ex' - prec <= ex)%Z. omega. unfold ex, FLT_exp. apply Zle_max_l. apply Zle_max_r. Qed. Theorem FLT_format_bpow : forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e). Proof. intros e He. apply generic_format_bpow; unfold FLT_exp. apply Z.max_case; try assumption. unfold Prec_gt_0 in prec_gt_0_; omega. Qed. Theorem FLT_format_satisfies_any : satisfies_any FLT_format. Proof. refine (satisfies_any_eq _ _ _ (generic_format_satisfies_any beta FLT_exp)). intros x. split. apply FLT_format_generic. apply generic_format_FLT. Qed.Theorem canonic_exp_FLT_FLX : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> canonic_exp beta FLT_exp x = canonic_exp beta (FLX_exp prec) x. Proof. intros x Hx. assert (Hx0: x <> 0%R). intros H1; rewrite H1, Rabs_R0 in Hx. contradict Hx; apply Rlt_not_le, bpow_gt_0. unfold canonic_exp. apply Zmax_left. destruct (ln_beta beta x) as (ex, He). unfold FLX_exp. simpl. specialize (He Hx0). cut (emin + prec - 1 < ex)%Z. omega. apply (lt_bpow beta). apply Rle_lt_trans with (1 := Hx). apply He. Qed. Theorem generic_format_FLT_FLX : forall x : R, (bpow (emin + prec - 1) <= Rabs x)%R -> generic_format beta (FLX_exp prec) x -> generic_format beta FLT_exp x. Proof. intros x Hx H. destruct (Req_dec x 0) as [Hx0|Hx0]. rewrite Hx0. apply generic_format_0. unfold generic_format, scaled_mantissa. now rewrite canonic_exp_FLT_FLX. Qed.Theorem generic_format_FLX_FLT : forall x : R, generic_format beta FLT_exp x -> generic_format beta (FLX_exp prec) x. Proof. clear prec_gt_0_. intros x Hx. unfold generic_format in Hx; rewrite Hx. apply generic_format_F2R. intros _. rewrite <- Hx. unfold canonic_exp, FLX_exp, FLT_exp. apply Zle_max_l. Qed.Theorem round_FLT_FLX : forall rnd x, (bpow (emin + prec - 1) <= Rabs x)%R -> round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x. intros rnd x Hx. unfold round, scaled_mantissa. rewrite canonic_exp_FLT_FLX ; trivial. Qed. Theorem canonic_exp_FLT_FIX : forall x, x <> 0%R -> (Rabs x < bpow (emin + prec))%R -> canonic_exp beta FLT_exp x = canonic_exp beta (FIX_exp emin) x. 
Z.mod_bound_pos. omega. compute. reflexivity. destruct H0. split; auto. eapply OrdersEx.Z_as_OT.lt_le_incl. eapply OrdersEx.Z_as_DT.lt_le_trans. eauto. compute. intro. inv H2. omega. } { unfold Int.and. rewrite Int.unsigned_repr with (z := h) by (archi_red; solve_uint_range; omega). rewrite Int.unsigned_repr with (z := 255%Z) by (archi_red; solve_uint_range; omega). rewrite Int.unsigned_repr. reflexivity. replace 255%Z with (Z.ones 8) by reflexivity. rewrite Z.land_ones. unfold Int.max_unsigned in *; simpl in *. assert ( (0 <= h mod Z.pow_pos 2 8 < Z.pow_pos 2 8)%Z). apply Z.mod_bound_pos. omega. compute. reflexivity. destruct H0. split; auto. eapply OrdersEx.Z_as_OT.lt_le_incl. eapply OrdersEx.Z_as_DT.lt_le_trans. eauto. compute. intro. inv H2. omega. } Qed. Theorem sem_switch_arg_1: forall n, (0 <= n <= Ptrofs.max_unsigned)%Z -> sem_switch_arg (int_shru n 1) uval = Some (Z.shiftr n 1). Proof. intros. rewrite ptrofs_mu in H. unfold sem_switch_arg. unfold int_shru. destruct Archi.ptr64 eqn:Harchi; archi_red; unfold classify_shift; simpl. { rewrite Int64.shru_div_two_p. rewrite Int64.Zshiftr_div_two_p by omega. rewrite Int64.unsigned_repr with (z := n) by (archi_red; solve_uint_range; omega). rewrite Int64.unsigned_repr with (z := 1%Z) by (archi_red; solve_uint_range; omega). rewrite Int64.unsigned_repr. reflexivity. unfold Int64.max_unsigned; solve_uint_range. unfold Zpower.two_power_pos. simpl. inv H. split. apply Z.div_pos; omega. apply OrdersEx.Z_as_OT.div_le_upper_bound. omega. omega. } { rewrite Int.shru_div_two_p. rewrite Int.Zshiftr_div_two_p by omega. rewrite Int.unsigned_repr with (z := n) by (archi_red; solve_uint_range; omega). rewrite Int.unsigned_repr with (z := 1%Z) by (archi_red; solve_uint_range; omega). rewrite Int.unsigned_repr. reflexivity. unfold Int.max_unsigned; solve_uint_range. unfold Zpower.two_power_pos. simpl. inv H. split. apply Z.div_pos; omega. apply OrdersEx.Z_as_OT.div_le_upper_bound. omega. omega. } Qed.Theorem disjoint_ord: forall {cenv ienv c c' namec namec' namei namei' i a a' ord ord'}, correct_ienv_of_cenv cenv ienv -> M.get c cenv = Some (Build_ctor_ty_info namec namei i a ord) -> M.get c' cenv = Some (Build_ctor_ty_info namec' namei' i a' ord') -> (c <> c' <-> ord <> ord'). Proof. intros. apply H in H0. apply H in H1. destructAll. rewrite H1 in H0. inv H0. split; intro; intro; subst. - apply H7. exists namec', c', a'. split. intro. inv H8. apply H0; auto. auto. - apply H6. exists ord', namec', a'. split. intro. inv H8. apply H0; auto. auto. Qed.Theorem pos_iter_injective: forall A f, (forall a b, f a = f b -> a = b) -> forall p (a b:A), Pos.iter f a p = Pos.iter f b p -> a = b. Proof. induction p; intros. simpl in H0. apply H in H0. apply IHp in H0. apply IHp in H0. auto. simpl in H0. apply IHp in H0. apply IHp; auto. simpl in H0. apply H; auto. Qed. Theorem shiftl_injective: forall c a b, (0 <= c)%Z -> Z.shiftl a c = Z.shiftl b c -> a = b. 
st where " t '/' st '===>' t' '/' st' " := (cstep (t,st) (t',st')).Definition cmultistep := multi cstep.Notation " t '/' st '===>*' t' '/' st' " := (multi cstep (t,st) (t',st')) (at level 40, st at level 39, t' at level 39). Definition par_loop : com := PAR Y ::= ANum 1 WITH WHILE BEq (AId Y) (ANum 0) DO X ::= APlus (AId X) (ANum 1) END END.Example par_loop_example_0: exists st', par_loop / empty_state ===>* SKIP / st' /\ st' X = 0. Proof. eapply ex_intro. split. unfold par_loop. eapply multi_step. apply CS_Par1. apply CS_Ass. eapply multi_step. apply CS_Par2. apply CS_While. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq. simpl. eapply multi_step. apply CS_Par2. apply CS_IfFalse. eapply multi_step. apply CS_ParDone. eapply multi_refl. reflexivity. Qed.Example par_loop_example_2: exists st', par_loop / empty_state ===>* SKIP / st' /\ st' X = 2. Proof. eapply ex_intro. split. eapply multi_step. apply CS_Par2. apply CS_While. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq. simpl. eapply multi_step. apply CS_Par2. apply CS_IfTrue. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_AssStep. apply AS_Plus1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_AssStep. apply AS_Plus. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_Ass. eapply multi_step. apply CS_Par2. apply CS_SeqFinish. eapply multi_step. apply CS_Par2. apply CS_While. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq. simpl. eapply multi_step. apply CS_Par2. apply CS_IfTrue. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_AssStep. apply AS_Plus1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_AssStep. apply AS_Plus. eapply multi_step. apply CS_Par2. apply CS_SeqStep. apply CS_Ass. eapply multi_step. apply CS_Par1. apply CS_Ass. eapply multi_step. apply CS_Par2. apply CS_SeqFinish. eapply multi_step. apply CS_Par2. apply CS_While. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq1. apply AS_Id. eapply multi_step. apply CS_Par2. apply CS_IfStep. apply BS_Eq. simpl. eapply multi_step. apply CS_Par2. apply CS_IfFalse. eapply multi_step. apply CS_ParDone. eapply multi_refl. reflexivity. Qed. Lemma par_body_n__Sn : forall n st, st X = n /\ st Y = 0 -> par_loop / st ===>* par_loop / (t_update st X (S n)). Proof. Admitted.Lemma par_body_n : forall n st, st X = 0 /\ st Y = 0 -> exists st', par_loop / st ===>* par_loop / st' /\ st' X = n /\ st' Y = 0. Proof. Admitted. Theorem par_loop_any_X: forall n, exists st', par_loop / empty_state ===>* SKIP / st' /\ st' X = n. 
(1 + p); [ rewrite Zpower_nat_is_exp | auto with zarith ]. rewrite Zpower_nat_1; auto with zarith. apply Zmult_gt_0_lt_compat_r; auto with zarith. apply Zlt_gt; auto with zarith. Qed. Theorem Zpower_nat_monotone_lt : forall p q : nat, p < q -> (Zpower_nat n p < Zpower_nat n q)%Z. intros p q H'; elim H'; simpl in |- *; auto. apply Zpower_nat_monotone_S. intros m H H0; apply Zlt_trans with (1 := H0). apply Zpower_nat_monotone_S. Qed. Hint Resolve Zpower_nat_monotone_lt: zarith. Theorem Zpower_nat_anti_monotone_lt : forall p q : nat, (Zpower_nat n p < Zpower_nat n q)%Z -> p < q. intros p q H'. case (le_or_lt q p); auto; (intros H'1; generalize H'; case H'1). intros H'0; Contradict H'0; auto with zarith. intros m H'0 H'2; Contradict H'2; auto with zarith. Qed. Theorem Zpower_nat_monotone_le : forall p q : nat, p <= q -> (Zpower_nat n p <= Zpower_nat n q)%Z. intros p q H'; case (le_lt_or_eq _ _ H'); auto with zarith. intros H1; rewrite H1; auto with zarith. Qed. Theorem Zpower_nat_anti_monotone_le : forall p q : nat, (Zpower_nat n p <= Zpower_nat n q)%Z -> p <= q. intros p q H'; case (le_or_lt p q); intros H'0; auto with arith. Contradict H'; auto with zarith. Qed. Theorem Zpower_nat_anti_eq : forall p q : nat, Zpower_nat n p = Zpower_nat n q -> p = q. intros p q H'; apply le_antisym; apply Zpower_nat_anti_monotone_le; rewrite H'; auto with zarith. Qed. Fixpoint digitAux (v r : Z) (q : positive) {struct q} : nat := match q with | xH => 0 | xI q' => match (n * r)%Z with | r' => match (r ?= v)%Z with | Datatypes.Gt => 0 | _ => S (digitAux v r' q') end end | xO q' => match (n * r)%Z with | r' => match (r ?= v)%Z with | Datatypes.Gt => 0 | _ => S (digitAux v r' q') end end end. Definition digit (q : Z) := match q with | Z0 => 0 | Zpos q' => digitAux (Zabs q) 1 (xO q') | Zneg q' => digitAux (Zabs q) 1 (xO q') end. Hint Unfold digit. Theorem digitAux1 : forall p r, (Zpower_nat n (S p) * r)%Z = (Zpower_nat n p * (n * r))%Z. intros p r; replace (S p) with (1 + p); [ rewrite Zpower_nat_is_exp | auto with arith ]. rewrite Zpower_nat_1; ring. Qed. Theorem Zcompare_correct : forall p q : Z, match (p ?= q)%Z with | Datatypes.Gt => (q < p)%Z | Datatypes.Lt => (p < q)%Z | Datatypes.Eq => p = q end. 
Require Export Preduce. Section Preduceplus. Load "hCoefStructure". Load "hOrderStructure". Load "hReduce". Inductive reduceplus (Q : list (poly A0 eqA ltM)) : list (Term A n) -> list (Term A n) -> Prop := | Rstar_0 : forall x y : list (Term A n), eqP A eqA n x y -> reduceplus Q x y | Rstar_n : forall x y z : list (Term A n), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z. Hint Resolve Rstar_0. Theorem reduceplus_eqp_com : forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduceplus Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduceplus Q r s. intros Q p q r s H'; generalize r s; clear r s; elim H'; auto. intros x y H'0 r s H'1 H'2 H'3. apply Rstar_0; auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := y); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := x); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. intros x y z H'0 H'1 H'2 r s H'3 H'4 H'5. apply Rstar_n with (y := y); auto. apply reduce_eqp_com with (1 := cs) (p := x) (q := y); auto. apply H'2; auto. apply canonical_reduce with (1 := cs) (3 := H'0); auto. Qed. Theorem reduceplus_trans : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduceplus Q x y -> canonical A0 eqA ltM x -> reduceplus Q y z -> reduceplus Q x z. 
H; subst. generalize dependent st'. induction l; intros. + simpl in *. congruence. + destruct st'; try solve [ simpl in *; congruence ]. destruct p. unfold find_subtree_helper in H2 at 1. destruct a0. simpl in H2. destruct (string_dec s0 a). * subst. edestruct IHfnlist. 2: apply H2. inversion H6; eauto. eexists. intuition eauto. inversion H4; subst. simpl; destruct (string_dec s s); try congruence. * edestruct IHl. eauto. eauto. all: try solve [ inversion H4; exact H5 ]. all: try solve [ inversion H6; eauto ]. constructor. inversion H4; eauto. inversion H. inversion H8; eauto. exists x. intuition. simpl. inversion H4; subst. destruct (string_dec s a); try congruence. apply H3. Qed. Theorem tree_crash_find_none : forall fnlist t t', tree_crash t t' -> find_subtree fnlist t = None -> find_subtree fnlist t' = None. Proof. induction fnlist. - simpl; intros. congruence. - intros. inversion H0. rewrite H2. destruct t; inversion H; subst. eauto. generalize dependent st'. induction l; intros. + destruct st'; simpl in *; try congruence. + destruct st'; try solve [ simpl in *; congruence ]. destruct p. unfold find_subtree_helper in H2 at 1. destruct a0. simpl in H2. destruct (string_dec s0 a). * subst. edestruct IHfnlist. 2: apply H2. inversion H6; eauto. inversion H4; subst. simpl; destruct (string_dec s s); try congruence. * edestruct IHl. eauto. eauto. all: try solve [ inversion H4; exact H5 ]. all: try solve [ inversion H6; eauto ]. constructor. inversion H4; eauto. inversion H. inversion H8; eauto. simpl. inversion H4; subst. destruct (string_dec s a); try congruence. Qed. Lemma tree_crash_find_subtree_root: forall t t' inum, tree_crash t t' -> (exists elem, find_subtree [] t = Some (TreeDir inum elem)) -> (exists elem', find_subtree [] t' = Some (TreeDir inum elem')). Proof. intros. destruct t. - destruct H0. inversion H0. - destruct H0. unfold find_subtree in *. simpl in *. destruct t'. inversion H0. inversion H0. subst; simpl. exfalso. inversion H. inversion H0. subst; simpl. inversion H. subst; simpl; eauto. Qed. Lemma tree_crash_find_name_root: forall t t' inum, tree_crash t t' -> find_name [] t = Some (inum, true) -> find_name [] t' = Some (inum, true). Proof. intros. destruct t. - unfold find_name in H0; subst; simpl. unfold find_subtree in H0. inversion H0. - destruct t'. unfold find_name in H0. destruct (find_subtree [] (TreeDir n l)). destruct d. inversion H0. inversion H0. subst; simpl. exfalso. inversion H. congruence. inversion H. subst; simpl; eauto. Qed. Theorem file_crash_exists : forall file, exists file', BFILE.file_crash file file'. 
apply Rmult_le_neg_compat_l; auto with real. Qed.Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real. Qed.Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R. intros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R. intros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real. Qed.Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z). intros x y z H; rewrite H; auto. Qed.Theorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y). intros x y z H1 H2; red; apply Rge_trans with z; auto. Qed. Theorem Z2R_correct: forall p, (Z2R p) = (IZR p). 
Require Export ZFC.Lib.Relation. Definition is_nat := Œª n, ‚àÄ A, inductive A ‚Üí n ‚àà A.Theorem œâ_exists : ‚àÉ œâ, ‚àÄ n, n ‚àà œâ ‚Üî is_nat n. Proof with auto. exists {n ‚àä ùêà | is_nat n}. split. - intros Hn A HA. apply SepE in Hn as [_ H]. apply H in HA... - intros Hn. apply SepI. apply Hn. apply InfAx. intros A HA. apply Hn in HA... Qed.Definition œâ := {n ‚àä ùêà | is_nat n}.Lemma œâ_has_0 : ‚à ‚àà œâ. Proof with auto. apply SepI... apply InfAx. intros x []... Qed.Lemma œâ_neq_0 : œâ ‚â ‚à . Proof. intros H. assert (‚à ‚àà œâ). apply œâ_has_0. rewrite H in H0. exfalso0. Qed. Theorem œâ_inductive : inductive œâ. Proof with auto. split. apply œâ_has_0. intros a Ha. apply SepE in Ha as [_ H]. apply SepI. - apply InfAx. apply H. apply InfAx. - intros A HA. apply H in HA as Ha. destruct HA as [_ H1]. apply H1... Qed. Theorem œâ_sub_inductive : ‚àÄ A, inductive A ‚Üí œâ ‚äÜ A. 
=> T E x v E | T a y v' b => if x <? y then T (insert x v a) y v' b else if y <? x then T a y v' (insert x v b) else T a x v b end.Fixpoint elements' (s: tree) (base: list (key*V)) : list (key * V) := match s with | E => base | T a k v b => elements' a ((k,v) :: elements' b base) end.Definition elements (s: tree) : list (key * V) := elements' s nil. Section EXAMPLES. Variables v2 v4 v5 : V. Eval compute in insert 5 v5 (insert 2 v2 (insert 4 v5 empty_tree)). Eval compute in lookup 5 (T (T E 2 v2 E) 4 v5 (T E 5 v5 E)). Eval compute in lookup 3 (T (T E 2 v2 E) 4 v5 (T E 5 v5 E)). Eval compute in elements (T (T E 2 v2 E) 4 v5 (T E 5 v5 E)). End EXAMPLES. Check t_update_eq. Check t_update_neq. Check t_update_shadow. Check t_update_same. Check t_update_permute. Check t_apply_empty. Definition example_tree (v2 v4 v5 : V) := T (T E 2 v2 E) 4 v4 (T E 5 v5 E). Definition example_map (v2 v4 v5: V) : total_map V . Admitted. Definition combine {A} (pivot: key) (m1 m2: total_map A) : total_map A := fun x => if x <? pivot then m1 x else m2 x.Inductive Abs: tree -> total_map V -> Prop := | Abs_E: Abs E (t_empty default) | Abs_T: forall a b l k v r, Abs l a -> Abs r b -> Abs (T l k v r) (t_update (combine k a b) k v). Lemma check_example_map: forall v2 v4 v5, Abs (example_tree v2 v4 v5) (example_map v2 v4 v5). Proof. intros. unfold example_tree. evar (m: total_map V). replace (example_map v2 v4 v5) with m; subst m. repeat constructor. extensionality x. Admitted.Lemma check_too_clever: forall v2 v4 v5: V, True. Proof. intros. evar (m: total_map V). assert (Abs (example_tree v2 v4 v5) m). repeat constructor. (change m with (example_map v2 v4 v5) in H || auto);fail "Did you use copy-and-paste, from your check_example_map proof, into your example_map definition? If so, very clever. Please try it again with an example_map definition that you make up from first principles. Or, to skip that, uncomment the above.". Qed.Theorem empty_tree_relate: Abs empty_tree (t_empty default). Proof. constructor. Qed. Theorem lookup_relate: forall k t cts , Abs t cts -> lookup k t = cts k. 
Require Import Unicode.Utf8. Require Import Classical_Prop. Require Import ClassicalFacts. Require Import PropExtensionality.Module No1.Import Unicode.Utf8. Import ClassicalFacts. Import Classical_Prop. Import PropExtensionality. Theorem Impl1_01 : ‚àÄ P Q : Prop, (P ‚Üí Q) = (¬¨P ‚à® Q). Proof. intros P Q. apply propositional_extensionality. split. apply imply_to_or. apply or_to_imply. Qed. Theorem MP1_1 : ‚àÄ P Q : Prop, (P ‚Üí Q) ‚Üí P ‚Üí Q. Proof. intros P Q. intros iff_refl. apply iff_refl. Qed. Theorem Taut1_2 : ‚àÄ P : Prop, P ‚à® P ‚Üí P. Proof. intros P. apply imply_and_or. apply iff_refl. Qed.Theorem Add1_3 : ‚àÄ P Q : Prop, Q ‚Üí P ‚à® Q. Proof. intros P Q. apply or_intror. Qed.Theorem Perm1_4 : ‚àÄ P Q : Prop, P ‚à® Q ‚Üí Q ‚à® P. Proof. intros P Q. apply or_comm. Qed. Theorem Assoc1_5: ‚àÄ P Q R : Prop, P ‚à® (Q ‚à® R) ‚Üí Q ‚à® (P ‚à® R). 
‚ä iA n = MZ_one. Proof using Hb_nat. generalize (alpha_Pell n); unfold Pell; intros H. apply M22_equal; try ring; simpl; rewrite alpha_fix_3, <- H; ring. Qed. Fact iA_A n : iA n ‚ä A n = MZ_one. Proof using Hb_nat. generalize (alpha_Pell n); unfold Pell; intros H. apply M22_equal; try ring; simpl; rewrite alpha_fix_3, <- H; ring. Qed. Fact A_minus u v : (v <= u)%nat -> A (u-v)%nat = A u ‚ä iA v. Proof using Hb_nat. intros H. rewrite <- (MZ_expo_A u). replace u with (u-v+v)%nat at 2 by lia. rewrite mscal_plus; auto. do 2 rewrite MZ_expo_A. rewrite <- M22mult_assoc with (1 := Zring). rewrite A_iA. rewrite M22mult_one_r with (1 := Zring). trivial. Qed. Section alpha_nat_coprime. Let A_eq_3_12 n : exists u v, u*Œ± (S n) + v*Œ± n = 1. Proof. generalize (alpha_Pell n); unfold Pell; intros H. exists (Œ± (S n)-b*Œ± n), (Œ± n). rewrite <- H; ring. Qed. Lemma alpha_nat_coprime n : is_gcd (alpha_nat (S n)) (alpha_nat n) 1. Proof using Hb_nat. apply Z_coprime, (A_eq_3_12 (S n)). Qed. Corollary alpha_nat_odd n : (rem (alpha_nat (S n)) 2 = 1 \/ rem (alpha_nat n) 2 = 1)%nat. Proof using Hb_nat. destruct rem_2_is_0_or_1 with (x := alpha_nat (S n)) as [ H1 | ]; auto. destruct rem_2_is_0_or_1 with (x := alpha_nat n) as [ H2 | ]; auto. exfalso; generalize (alpha_nat_coprime n); intros (_ & _ & H3). destruct (H3 2%nat) as (? & ?); try lia; apply divides_rem_eq; auto. Qed. End alpha_nat_coprime. End Pell_inner. Theorem find_odd_alpha u : exists n, (u <= alpha_nat (S n) /\ rem (alpha_nat (S n)) 2 = 1)%nat. Proof using Hb_nat. destruct (alpha_nat_odd (S u)) as [ H | H ]; [ exists (S u) | exists u ]; split; auto; apply le_trans with (1 := alpha_nat_ge_n _), alpha_nat_mono; lia. Qed. Theorem find_odd_alpha' u : exists n, (u <= alpha_nat n /\ rem (alpha_nat n) 2 = 1)%nat. Proof using Hb_nat. destruct (find_odd_alpha u) as (n & ?); exists (S n); auto. Qed. Notation expoZ := (mscal Zmult 1). Fact expoZ_power n x : expoZ n (Z.of_nat x) = Z.of_nat (power n x). Proof. symmetry; apply mscal_morph; auto. intros; apply Nat2Z.inj_mul. Qed. Fact mscal_Zplus n : mscal Zplus 0 n 1 = Z.of_nat n. Proof. induction n as [ | n IHn ]. + rewrite mscal_0; auto. + rewrite mscal_S, IHn. rewrite Nat2Z.inj_succ; ring. Qed. Notation "‚àë" := (msum MZ_plus MZ_zero). Theorem MA_expo_A_binomial m k l : (m = l * k)%nat -> A m = ‚àë (S l) (fun i => MZ_scal ( expoZ (l-i) (-1) * Z.of_nat (binomial l i) * expoZ i (Œ± (S k)) * expoZ (l-i) (Œ± k) ) (MZ_expo i B)). 
eapply cons_synced_up_to_n. rewrite length_updN. omega. Qed. Lemma treeseq_one_upd_noop : forall t pathname off v inum f def, tree_names_distinct (TStree t) -> find_subtree pathname (TStree t) = Some (TreeFile inum f) -> off < Datatypes.length (DFData f) -> selN (DFData f) off def = v -> t = treeseq_one_upd t pathname off v. Proof. unfold treeseq_one_upd; intros. rewrite H0. destruct t; simpl in *; f_equal. rewrite update_subtree_same; eauto. rewrite H0. f_equal. f_equal. destruct f; simpl in *. f_equal. rewrite <- H2. rewrite updN_selN_eq; eauto. Qed. Fixpoint treeseq_one_file_sync_alt_helper (t : treeseq_one) (pathname : list string) off fdata := match off with | O => t | S off' => let t' := treeseq_one_upd t pathname off' (selN fdata off' $0, nil) in treeseq_one_file_sync_alt_helper t' pathname off' fdata end. Definition treeseq_one_file_sync_alt (t : treeseq_one) (pathname : list string) := match find_subtree pathname (TStree t) with | None => t | Some (TreeDir _ _) => t | Some (TreeFile inum f) => treeseq_one_file_sync_alt_helper t pathname (length (DFData f)) (map fst (DFData f)) end. Lemma treeseq_one_file_sync_alt_equiv : forall t pathname, tree_names_distinct (TStree t) -> treeseq_one_file_sync t pathname = treeseq_one_file_sync_alt t pathname. Proof. unfold treeseq_one_file_sync, treeseq_one_file_sync_alt; intros. case_eq (find_subtree pathname (TStree t)); eauto. destruct d; eauto. intros. rewrite synced_file_alt_equiv. unfold synced_file_alt. remember (@Datatypes.length datatype (DFData d)) as synclen; intros. assert (synclen <= Datatypes.length (DFData d)) by simplen. clear Heqsynclen. remember (map fst (DFData d)) as synced_blocks. generalize dependent synced_blocks. generalize dependent t. generalize dependent d. induction synclen; intros. - simpl. destruct t; destruct d; simpl in *; f_equal. eapply update_subtree_same; eauto. - simpl. erewrite <- IHsynclen. f_equal. + unfold treeseq_one_upd. rewrite H0; simpl. rewrite update_update_subtree_same. reflexivity. + unfold treeseq_one_upd. rewrite H0. destruct t; eauto. + unfold treeseq_one_upd. rewrite H0. destruct t; eauto. + simpl. rewrite length_updN. omega. + unfold treeseq_one_upd. rewrite H0. simpl. eapply tree_names_distinct_update_subtree. eauto. constructor. + subst; simpl. unfold treeseq_one_upd. rewrite H0; simpl. erewrite selN_map. erewrite find_update_subtree; eauto. unfold datatype in *; omega. + subst; simpl. rewrite map_updN; simpl. erewrite selN_eq_updN_eq; eauto. erewrite selN_map; eauto. Grab Existential Variables. exact $0. Qed. Lemma treeseq_one_file_sync_alt_equiv_d_map : forall pathname ts, NEforall (fun t => tree_names_distinct (TStree t)) ts -> d_map (fun t => treeseq_one_file_sync t pathname) ts = d_map (fun t => treeseq_one_file_sync_alt t pathname) ts. Proof. unfold d_map; destruct ts; intros. f_equal; simpl. - eapply treeseq_one_file_sync_alt_equiv. eapply H. - eapply map_ext_in; intros. eapply treeseq_one_file_sync_alt_equiv. destruct H; simpl in *. eapply Forall_forall in H1; eauto. Qed. Theorem dirtree_update_safe_pathname_vssync_vecs_file: forall pathname f tree fsxp F F0 ilist freeblocks mscs sm inum m al, let tree_newest := update_subtree pathname (TreeFile inum (synced_dirfile f)) tree in find_subtree pathname tree = Some (TreeFile inum f) -> Datatypes.length al = Datatypes.length (DFData f) -> (forall i, i < length al -> BFILE.block_belong_to_file ilist (selN al i 0) inum i) -> (F0 * rep fsxp F tree ilist freeblocks mscs sm)%pred (list2nmem m) -> (F0 * rep fsxp F tree_newest ilist freeblocks mscs sm)%pred (list2nmem (vssync_vecs m al)). 
:= Ring.prod_monoid ring. Theorem distinct_1_0 : E_1 (c := r) <> E_0 (c := r). Proof fun H : E_1 = E_0 => distinct_0_1 (eq_sym H). Definition nonzero : E -> Prop := Ring.nonzero ring. Theorem sum_id_r : sum_is_id_r 0. Proof Ring.sum_id_r ring. Theorem sum_id : sum_is_id 0. Proof Ring.sum_id ring. Definition sum_is_inv_l := Ring.sum_is_inv_l ring. Definition sum_is_inv_r := Ring.sum_is_inv_r ring. Definition sum_is_inv := Ring.sum_is_inv ring. Definition sum_has_inv_l := Ring.sum_has_inv_l ring. Definition sum_has_inv_r := Ring.sum_has_inv_r ring. Definition sum_has_inv := Ring.sum_has_inv ring. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Ring.sum_inv_r_ex ring. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Ring.sum_id_l_uniq ring. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Ring.sum_id_r_uniq ring. Theorem sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Ring.sum_id_uniq ring. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Ring.sum_inv_l_r_eq ring. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Ring.sum_inv_sym ring. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Ring.sum_inv_uniq ring. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Ring.sum_inv_ex ring. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. Proof Ring.sum_inv_uniq_ex ring. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Ring.sum_intro_l ring. Theorem sum_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Ring.sum_intro_r ring. Theorem sum_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Ring.sum_cancel_l ring. Theorem sum_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Ring.sum_cancel_r ring. Theorem sum_inv_l_uniq : forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y. Proof Ring.sum_inv_l_uniq ring. Theorem sum_inv_r_uniq : forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Ring.sum_inv_r_uniq ring. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Ring.sum_0_inv_l ring. Theorem sum_0_inv_r : sum_is_inv_r 0 0. 
<= fexp ex)%Z -> (0 < x * bpow (- fexp ex) < 1)%R. Proof. intros x ex Hx He. split. apply Rmult_lt_0_compat. apply Rlt_le_trans with (2 := proj1 Hx). apply bpow_gt_0. apply bpow_gt_0. apply Rmult_lt_reg_r with (bpow (fexp ex)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l. rewrite Rmult_1_r, Rmult_1_l. apply Rlt_le_trans with (1 := proj2 Hx). now apply bpow_le. Qed.Theorem scaled_mantissa_lt_1 : forall x ex, (Rabs x < bpow ex)%R -> (ex <= fexp ex)%Z -> (Rabs (scaled_mantissa x) < 1)%R. Proof. intros x ex Ex He. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, scaled_mantissa_0, Rabs_R0. now apply IZR_lt. rewrite <- scaled_mantissa_abs. unfold scaled_mantissa. rewrite cexp_abs. unfold cexp. destruct (mag beta x) as (ex', Ex'). simpl. specialize (Ex' Zx). apply (mantissa_small_pos _ _ Ex'). assert (ex' <= fexp ex)%Z. apply Z.le_trans with (2 := He). apply bpow_lt_bpow with beta. now apply Rle_lt_trans with (2 := Ex). now rewrite (proj2 (proj2 (valid_exp _) He)). Qed.Theorem scaled_mantissa_lt_bpow : forall x, (Rabs (scaled_mantissa x) < bpow (mag beta x - cexp x))%R. Proof. intros x. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, scaled_mantissa_0, Rabs_R0. apply bpow_gt_0. apply Rlt_le_trans with (1 := bpow_mag_gt beta _). apply bpow_le. unfold scaled_mantissa. rewrite mag_mult_bpow with (1 := Zx). apply Z.le_refl. Qed.Theorem mag_generic_gt : forall x, (x <> 0)%R -> generic_format x -> (cexp x < mag beta x)%Z. Proof. intros x Zx Gx. apply Znot_ge_lt. unfold cexp. destruct (mag beta x) as (ex,Ex) ; simpl. specialize (Ex Zx). intros H. apply Z.ge_le in H. generalize (scaled_mantissa_lt_1 x ex (proj2 Ex) H). contradict Zx. rewrite Gx. replace (Ztrunc (scaled_mantissa x)) with Z0. apply F2R_0. cut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z. clear ; zify ; omega. apply lt_IZR. rewrite abs_IZR. now rewrite <- scaled_mantissa_generic. Qed.Lemma mantissa_DN_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> Zfloor (x * bpow (- fexp ex)) = Z0. Proof. intros x ex Hx He. apply Zfloor_imp. simpl. assert (H := mantissa_small_pos x ex Hx He). split ; try apply Rlt_le ; apply H. Qed.Lemma mantissa_UP_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> Zceil (x * bpow (- fexp ex)) = 1%Z. Proof. intros x ex Hx He. apply Zceil_imp. simpl. assert (H := mantissa_small_pos x ex Hx He). split ; try apply Rlt_le ; apply H. Qed. Theorem generic_format_discrete : forall x m, let e := cexp x in (F2R (Float beta m e) < x < F2R (Float beta (m + 1) e))%R -> ~ generic_format x. 
p, s === s' -> lset' s n p ===> lset' s' n p. End ADT.Module Adt : ADT. Open Scope Sep_scope. Fixpoint lset' (s : Ensemble W) (n : nat) (p : W) : HProp := match n with | O => [| p = 0 |] * [| s === %0 |] | S n' => [| p <> 0 |] * [| freeable p 2 |] * Ex x, [| s %has x |] * Ex p', (p ==*> x, p') * lset' (s %- x) n' p' end. Definition lset (s : Ensemble W) (c : W) : HProp := [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * Ex n, lset' s n p. Theorem lset_fwd : forall s c, lset s c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * Ex n, lset' s n p. unfold lset; sepLemma. Qed. Theorem lset_bwd : forall s (c : W), ([| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * Ex n, lset' s n p) ===> lset s c. unfold lset; sepLemma. Qed. Theorem lset'_empty_fwd : forall s n (c : W), c = 0 -> lset' s n c ===> [| n = O |] * [| s === %0 |]. destruct n; sepLemma. Qed. Theorem lset'_empty_bwd : forall s n (c : W), c = 0 -> [| n = O |] * [| s === %0 |] ===> lset' s n c. destruct n; sepLemma. Qed. Theorem lset'_nonempty_fwd : forall s n (c : W), c <> 0 -> lset' s n c ===> Ex n', [| n = S n' |] * [| freeable c 2 |] * Ex x, [| s %has x |] * Ex p', (c ==*> x, p') * lset' (s %- x) n' p'. destruct n; sepLemma. Qed. Theorem lset'_nonempty_bwd : forall s n (c : W), c <> 0 -> (Ex n', [| n = S n' |] * [| freeable c 2 |] * Ex x, [| s %has x |] * Ex p', (c ==*> x, p') * lset' (s %- x) n' p') ===> lset' s n c. destruct n; sepLemma. injection H0; sepLemma. Qed. Theorem lset'_monotone : forall n s s' p, s === s' -> lset' s n p ===> lset' s' n p. 
H : context[ if ?c then _ else _ ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ |- context[ match ?c with Some _ => _ | None => _ end ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ match ?c with Some _ => _ | None => _ end ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ H : (?x <? ?y) = true |- _ ] => rewrite Nat.ltb_lt in H | [ H : (?x <? ?y) = false |- _ ] => rewrite Nat.ltb_nlt in H end; subst; auto.Lemma heap_extensionality : forall (h1 h2 : heap), h1 = h2 -> forall (x : nat), h1 x = h2 x. Proof. crush. Qed.Module SeparationProperty. Theorem pt2same_sep : forall (p x y : exp), p |-> x ** p |-> y ==> hlift False. Proof. hsimpl; intros; firstorder; subst. specialize (H (eval p v)). hsolver; crush. Qed. Theorem pt2same_sep' : forall (p q x y : exp), p |-> x ** q |-> y ==> (fun v h => eval p v <> eval q v). Proof. hsimpl; intros; firstorder; subst. intros contra; subst. specialize (H (eval q v)); repeat hsolver; crush. Qed. Theorem pt2same_and : forall (p x y : exp), p |-> x /~\ p |-> y ==> (fun v h => eval x v = eval y v). Proof. hsimpl; intros; intuition; subst. pose proof (@heap_extensionality _ _ H1 (eval p v)); crush. hsolver; crush. Qed. Theorem pt_and_empty : forall (p x : exp), p |-> x /~\ hemp ==> hlift False. Proof. hsimpl; intros; intuition; subst. eapply heap_extensionality in H1. hsolver; crush. Qed. Theorem emp_unit : forall (P : assertion), hemp ** P <==> P /\ P ** hemp <==> P. Proof. hsimpl; intros; firstorder. + assert (h = x0); crush. + exists empty_heap, h. crush. + assert (h = x); crush. extensionality k; hsolver. + exists h, empty_heap. unfold empty_heap. crush. extensionality k; hsolver. Qed. Theorem hstar_commut : forall (P Q : assertion), P ** Q <==> Q ** P. Proof. hsimpl; intros; intuition; destruct H as [h1 [h2 H]]; intuition; exists h2, h1; intuition; try extensionality k; pose proof (H k); try tauto; pose proof (heap_extensionality H2 k); simpl in H4; intuition; repeat hsolver; crush. Qed. Theorem hstar_assoc : forall (P Q R : assertion), P ** (Q ** R) <==> (P ** Q) ** R. 
l l0); intuition. rewrite eqb_leibniz in H4. intuition. simpl. assert (forall a b, In (a, b) (fst (split l1)) -> b = F x a). intuition. eapply (@oc_comp_invariant _ _ _ _ _ (fun l1 => forall a b, In (a, b) (fst (split l1)) -> b = F x a)) in H0. eauto. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. intuition. simpl in *. intuition. trivial. assert (b0 = F x l). eapply H6. trivial. eapply H6 in H5. subst. rewrite H7. rewrite eqbBvector_complete. trivial. comp_simp. rewrite eqb_refl. simpl. eapply comp_spec_eq_refl. Qed. Theorem G2_3_4_close : | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <= Adv_WCR _ _ F (Rnd k) au_F_A. eapply leRat_trans. eapply fundamental_lemma_h. eapply G2_3_4_bad_eq . eapply G2_3_4_eq_until_bad. rewrite G2_3_bad_equiv. rewrite G2_3_bad_small. intuition. Qed. Definition G2_5 := [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil; ret b. Theorem G2_4_5_equiv : Pr[x <-$ G2_4; ret fst x] == Pr[G2_5]. unfold G2_4, G2_5. inline_first. comp_irr_l. wftac. inline_first. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a (z, (F x z)) = arrayLookup _ b z)). intuition. intuition. unfold randomFunc_mem. rewrite H0. case_eq ( arrayLookup (list_EqDec (Bvector_EqDec b)) x2 a); intuition. eapply comp_spec_ret; intuition. simpl in *. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H3. subst. rewrite eqbBvector_complete. trivial. simpl. eauto. comp_skip. apply (oneVector c). apply (oneVector c). eapply comp_spec_ret; intuition. simpl. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H5. subst. rewrite eqbBvector_complete. trivial. simpl. trivial. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G2_5_equiv : Pr[G2_5] == Pr[G2]. unfold G2_5, G2. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a z = arrayLookup _ b z)). intuition. intuition. eapply randomFunc_mem_spec. intuition. simpl in *. intuition. subst. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_equiv : | Pr[G1] - Pr[G2] | <= Adv_WCR _ _ F (Rnd k) au_F_A. 
l. intros a1 a2 a3 a4; red in |- *; intros H; inversion H. intros a; case a. intros l H a1 a2 a3 a4; red in |- *; intros H0; case (H a1 a2 a3 empty). inversion H0; auto. intros l H a1 a2 a3 a4; red in |- *; intros H0; case (H a1 a2 a3 empty). inversion H0; auto. Qed. Theorem inpbleaf_eq : forall a1 a2 a3 l, inpb (pbleaf a1) (pbadd a2 (pbleaf a3) l) -> a1 = a2. Proof using. intros a1 a2 a3 l; generalize a1 a2 a3; elim l; simpl in |- *; auto; clear a1 a2 a3 l. intros a1 a2 a3 H; inversion H; auto. intros a; case a. intros l H a1 a2 a3 H0; apply (H a1 a2 empty). inversion H0; auto. intros l H a1 a2 a3 H0; apply (H a1 a2 empty). inversion H0; auto. Qed. Theorem inpbleaf_pbadd_inv : forall a1 a2 a3 l, inpb (pbleaf a1) (pbadd a2 a3 l) -> a1 = a2 \/ inpb (pbleaf a1) a3. Proof using. intros a1 a2 a3 l; generalize a1 a2 a3; elim l; simpl in |- *; auto; clear a1 a2 a3 l. intros a1 a2 a3 H0; inversion H0; auto. intros a; case a. intros l H a1 a2 a3; case a3; auto. intros a0 H0; left; apply (inpbleaf_eq a1 a2 empty l); auto. inversion H0; auto. intros p H1; inversion H1; auto. left; apply (inpbleaf_eq a1 a2 empty l); auto. intros p H0; case (H a1 a2 p); auto. inversion H0; auto. intros p p0 H1; inversion H1; auto. case (H a1 a2 p0); auto. intros l H a1 a2 a3; case a3; auto. intros a0 H1; left; apply (inpbleaf_eq a1 a2 empty l); auto. inversion H1; auto. intros p H1; case (H a1 a2 p); auto. inversion H1; auto. intros p H1; inversion H1. left; apply (inpbleaf_eq a1 a2 empty l); auto. case H0; auto. intros p p0 H1; inversion H1. case (H a1 a2 p); auto. case H0; auto. Qed. Theorem inpb_pbadd : forall a1 l1 t1, inpb (pbleaf a1) (pbadd a1 t1 l1). Proof using. intros a1 l1; elim l1; simpl in |- *; auto. intros b; case b; simpl in |- *; auto. intros l H t1; (case t1; simpl in |- *; auto). intros l H t1; (case t1; simpl in |- *; auto). Qed. Hint Resolve inpb_pbadd : core. Theorem inpb_pbadd_ex : forall a1 l1 t1 t, inpb t (pbadd a1 t1 l1) -> inpb (pbleaf a1) t \/ inpb t t1. 
\\ st').Theorem skip_left: forall c, cequiv (SKIP;; c) c. Proof. intros c st st'. split; intros H. - inversion H. subst. inversion H2. subst. assumption. - apply E_Seq with st. apply E_Skip. assumption. Qed. Theorem skip_right: forall c, cequiv (c ;; SKIP) c. Proof. Admitted. Theorem IFB_true_simple: forall c1 c2, cequiv (IFB BTrue THEN c1 ELSE c2 FI) c1. Proof. intros c1 c2. split; intros H. - inversion H; subst. assumption. inversion H5. - apply E_IfTrue. reflexivity. assumption. Qed.Theorem IFB_true: forall b c1 c2, bequiv b BTrue -> cequiv (IFB b THEN c1 ELSE c2 FI) c1. Proof. intros b c1 c2 Hb. split; intros H. - inversion H; subst. + assumption. + unfold bequiv in Hb. simpl in Hb. rewrite Hb in H5. inversion H5. - apply E_IfTrue; try assumption. unfold bequiv in Hb. simpl in Hb. rewrite Hb. reflexivity. Qed. Theorem IFB_false: forall b c1 c2, bequiv b BFalse -> cequiv (IFB b THEN c1 ELSE c2 FI) c2. Proof. Admitted.Theorem swap_if_branches: forall b e1 e2, cequiv (IFB b THEN e1 ELSE e2 FI) (IFB BNot b THEN e2 ELSE e1 FI). Proof. Admitted. Theorem WHILE_false : forall b c, bequiv b BFalse -> cequiv (WHILE b DO c END) SKIP. Proof. intros b c Hb. split; intros H. - inversion H; subst. + apply E_Skip. + rewrite Hb in H2. inversion H2. - inversion H; subst. apply E_WhileEnd. rewrite Hb. reflexivity. Qed.[] *)Lemma WHILE_true_nonterm : forall b c st st', bequiv b BTrue -> ~( (WHILE b DO c END) / st \\ st' ). Proof. intros b c st st' Hb. intros H. remember (WHILE b DO c END) as cw eqn:Heqcw. induction H; inversion Heqcw; subst; clear Heqcw. - unfold bequiv in Hb. rewrite Hb in H. inversion H. - apply IHceval2. reflexivity. Qed.*)Theorem WHILE_true: forall b c, bequiv b BTrue -> cequiv (WHILE b DO c END) (WHILE BTrue DO SKIP END). Proof. Admitted. Theorem loop_unrolling: forall b c, cequiv (WHILE b DO c END) (IFB b THEN (c ;; WHILE b DO c END) ELSE SKIP FI). Proof. intros b c st st'. split; intros Hce. - inversion Hce; subst. + apply E_IfFalse. assumption. apply E_Skip. + apply E_IfTrue. assumption. apply E_Seq with (st' := st'0). assumption. assumption. - inversion Hce; subst. + inversion H5; subst. apply E_WhileLoop with (st' := st'0). assumption. assumption. assumption. + inversion H5; subst. apply E_WhileEnd. assumption. Qed. Theorem seq_assoc : forall c1 c2 c3, cequiv ((c1;;c2);;c3) (c1;;(c2;;c3)). 
rewrite <- surjective_pairing. auto. Qed. Lemma in_contradicting_leader_logs_on_leader_in_leaderLog : forall ll t e t' l, In (t', l) (contradicting_leader_logs_on_leader ll t e) -> In (t', l) ll. Proof using. induction ll; intros; simpl in *; intuition. repeat break_match; simpl in *; intuition eauto. Qed. Lemma in_contradicting_leader_logs_on_leader_not_in_log : forall t' l ll t e, In (t', l) (contradicting_leader_logs_on_leader ll t e) -> In e l -> False. Proof using. induction ll; intros; simpl in *; intuition. repeat break_match; simpl in *; intuition eauto. find_inversion. auto. Qed. Lemma in_contradicting_leader_logs_on_leader_term_lt : forall t' l ll t e, In (t', l) (contradicting_leader_logs_on_leader ll t e) -> t < t'. Proof using. induction ll; intros; simpl in *; intuition. repeat break_match; simpl in *; intuition; repeat find_inversion; eauto. Qed. Lemma contradicting_leader_logs_on_leader_complete : forall t e t' l ll, In (t', l) ll -> t < t' -> ~ In e l -> In (t', l) (contradicting_leader_logs_on_leader ll t e). Proof using. induction ll; intros; simpl in *; intuition; repeat break_match; repeat find_inversion; simpl in *; intuition. Qed. Lemma contradicting_leader_logs_complete : forall net nodes h t e l t', In h nodes -> In (t', l) (contradicting_leader_logs_on_leader (leaderLogs (fst (nwState net h))) t e) -> In (t', h, l) (contradicting_leader_logs net nodes t e). Proof using. induction nodes; intros; simpl in *; intuition. apply in_or_app. subst. left. apply in_map_iff. eexists. intuition eauto. simpl. auto. Qed. Lemma minimal_contradicting_leader_log_elim : forall net t e t' h l, minimal_contradicting_leader_log net t e = Some (t', h, l) -> (t < t' /\ In (t', l) (leaderLogs (fst (nwState net h))) /\ ~ In e l /\ (forall h' t'' l', In (t'', l') (leaderLogs (fst (nwState net h'))) -> (t'' <= t \/ t'' >= t' \/ In e l'))). Proof using. unfold minimal_contradicting_leader_log. intros. find_apply_lem_hyp argmin_elim. intuition. - eauto using in_contradicting_leader_logs_on_leader_term_lt, in_contradicting_leader_logs. - eauto using in_contradicting_leader_logs, in_contradicting_leader_logs_on_leader_in_leaderLog. - eauto using in_contradicting_leader_logs, in_contradicting_leader_logs_on_leader_not_in_log. - destruct (le_lt_dec t'' t); auto. destruct (le_lt_dec t' t''); auto. destruct (in_dec entry_eq_dec e l'); auto. find_eapply_lem_hyp contradicting_leader_logs_on_leader_complete; eauto. find_eapply_lem_hyp contradicting_leader_logs_complete; [|solve [apply all_fin_all]]. find_apply_hyp_hyp. simpl in *. omega. Qed. Lemma maxTerm_zero_or_entry : forall l, maxTerm l = 0 \/ exists e, In e l /\ eTerm e = maxTerm l. Proof using. destruct l; simpl; eauto. Qed. Lemma maxIndex_zero_or_entry : forall l, maxIndex l = 0 \/ exists e, In e l /\ eIndex e = maxIndex l. Proof using. destruct l; simpl; eauto. Qed. Theorem leader_completeness_directly_committed_invariant : forall net, refined_raft_intermediate_reachable net -> leader_completeness_directly_committed net. 
Require Export ZFC.Axiom.ZFC0. Definition Doubleton : set := ùí´ ùí´ ‚à .Lemma DoubletonI1 : ‚à ‚àà Doubleton. Proof. apply PowerAx. intros x Hx. exfalso0. Qed.Lemma DoubletonI2 : ùí´ ‚à ‚àà Doubleton. Proof. apply PowerAx. intros x Hx. apply only_empty_in_power_empty in Hx. subst. apply empty_in_all_power. Qed. Definition PairRepl : set ‚Üí set ‚Üí set ‚Üí set := Œª a b x, match (ixm (‚à ‚àà x)) with | inl _ => b | inr _ => a end. Definition Pair := Œª x y, {PairRepl x y w | w ‚àä Doubleton}. Notation "{ x , y }" := (Pair x y) : set_scope.Lemma PairI1 : ‚àÄ x y, x ‚àà {x, y}. Proof. intros. apply ReplAx. exists ‚à . split. - apply DoubletonI1. - unfold PairRepl. destruct (ixm (‚à ‚àà ‚à )). + exfalso0. + reflexivity. Qed.Lemma PairI2 : ‚àÄ x y, y ‚àà {x, y}. Proof. intros. apply ReplAx. exists (ùí´ ‚à ). split. - apply DoubletonI2. - unfold PairRepl. destruct (ixm (‚à ‚àà ùí´ ‚à )). + reflexivity. + exfalso. apply n. apply empty_in_all_power. Qed.Lemma PairE : ‚àÄ x y, ‚àÄw ‚àà {x, y}, w = x ‚à® w = y. Proof. intros x y w Hw. apply ReplAx in Hw as [z [_ Heq]]. unfold PairRepl in Heq. destruct (ixm (‚à ‚àà z)). - subst. right. reflexivity. - subst. left. reflexivity. Qed. Theorem pair_ordering_agnostic : ‚àÄ a b, {a, b} = {b, a}. 
Fbounded b p. intros p H; case H; auto. Qed. Theorem FsubnormalFexp : forall p : float, Fsubnormal p -> Fexp p = (- dExp b)%Z. intros p H; case H; auto. intros H1 H2; case H2; auto. Qed. Theorem FsubnormalBound : forall p : float, Fsubnormal p -> (Zabs (radix * Fnum p) < Zpos (vNum b))%Z. intros p H; case H; auto. intros H1 H2; case H2; auto. Qed. Hint Resolve FsubnormalFbounded FsubnormalBound FsubnormalFexp: float. Theorem FsubnormFopp : forall p : float, Fsubnormal p -> Fsubnormal (Fopp p). intros p H'; repeat split; simpl in |- *; auto with zarith float. rewrite Zabs_Zopp; auto with float. rewrite <- Zopp_mult_distr_r; rewrite Zabs_Zopp; auto with float. Qed. Theorem FsubnormFabs : forall p : float, Fsubnormal p -> Fsubnormal (Fabs p). intros p; case p; intros a e H; split; auto with float. simpl in |- *; split; auto with float. case H; intros H1 (H2, H3); auto. rewrite <- (Zabs_eq radix); auto with zarith. rewrite <- Zabs_Zmult. rewrite (fun x => Zabs_eq (Zabs x)); auto with float zarith. case H; intros H1 (H2, H3); auto. Qed. Theorem FsubnormalUnique : forall p q : float, Fsubnormal p -> Fsubnormal q -> p = q :>R -> p = q. intros p q H' H'0 H'1. apply FtoREqInv2 with (radix := radix); auto. generalize H' H'0; unfold Fsubnormal in |- *; auto with zarith. Qed. Theorem FsubnormalLt : forall p q : float, Fsubnormal p -> Fsubnormal q -> (p < q)%R -> (Fnum p < Fnum q)%Z. intros p q H' H'0 H'1. apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with zarith. apply trans_equal with (- dExp b)%Z. case H'; auto. intros H1 H2; case H2; auto. apply sym_equal; case H'0; auto. intros H1 H2; case H2; auto. Qed. Theorem LtFsubnormal : forall p q : float, Fsubnormal p -> Fsubnormal q -> (Fnum p < Fnum q)%Z -> (p < q)%R. intros p q H' H'0 H'1. case (Rtotal_order p q); auto; intros Test; case Test; clear Test; intros Test; Contradict H'1. unfold FtoRradix in Test; rewrite sameExpEq with (2 := Test); auto. auto with zarith. apply trans_equal with (- dExp b)%Z. case H'; auto. intros H1 H2; case H2; auto. apply sym_equal; case H'0. intros H1 H2; case H2; auto. apply Zle_not_lt. apply Zlt_le_weak. apply FsubnormalLt; auto. Qed. Definition Fcanonic (a : float) := Fnormal a \/ Fsubnormal a. Theorem FcanonicBound : forall p : float, Fcanonic p -> Fbounded b p. 
H0 H1 t0 l0 H2. apply cover_node with (l2 := l2 ++ l0) (t1 := t1) (t2 := t2); auto. apply permutation_trans with ((t1 :: t2 :: l2) ++ l0); auto. Qed. Theorem cover_number_of_nodes : forall t l, cover l t -> number_of_nodes t = fold_left (fun x y => x + number_of_nodes y) l 0 + pred (length l). Proof using. intros t l H; elim H; clear H t l; simpl in |- *; auto. intros l1 l2 t1 t2 t3 H H0 H1. apply trans_equal with (1 := H1). rewrite fold_left_permutation with (2 := H); simpl in |- *; auto. rewrite permutation_length with (1 := H); simpl in |- *; auto. rewrite fold_left_init with (h := S); simpl in |- *; auto. intros a b1 b2; repeat rewrite plus_assoc_reverse. apply f_equal2 with (f := plus); auto; apply plus_comm. Qed. Fixpoint all_cover_aux (l : list (btree A)) (n : nat) {struct n} : list (btree A) := match n with | O => nil | S n1 => flat_map (fun l1 => match l1 with | nil => nil | a :: nil => a :: nil | a :: b :: l2 => all_cover_aux (node a b :: l2) n1 end) (all_permutations l) end. Definition all_cover l := all_cover_aux l (length l). Theorem all_cover_aux_cover : forall (n : nat) l t, n = length l -> In t (all_cover_aux l n) -> cover l t. Proof using. intros n; elim n; simpl in |- *; auto. intros l t H H0; elim H0. intros n0 H l t H0 H1. case in_flat_map_ex with (1 := H1); clear H1. intros x; case x; clear x. simpl in |- *; intros (H1, H2); case H2. intros b x; case x; clear x. simpl in |- *; intros (H1, [H2| H2]). rewrite <- H2. rewrite permutation_one_inv with (a := b) (l := l); auto. apply all_permutations_permutation; auto. case H2. intros b1 l1 (H1, H2). apply cover_node with (l2 := l1) (t1 := b) (t2 := b1); auto. apply permutation_sym; apply all_permutations_permutation; auto. apply H; auto. apply eq_add_S; apply trans_equal with (1 := H0). apply trans_equal with (length (b :: b1 :: l1)); auto. apply permutation_length. apply permutation_sym; apply all_permutations_permutation; auto. Qed. Theorem all_cover_cover : forall l t, In t (all_cover l) -> cover l t. Proof using. intros l t H; apply all_cover_aux_cover with (n := length l); auto. Qed. Theorem cover_all_cover_aux : forall (n : nat) l t, n = length l -> cover l t -> In t (all_cover_aux l n). 
H3); intros. rewrite Z.mul_1_l in H7. specialize (Zmul_sub H0 H1 H3); intros. specialize (Zpow_add_sub H0 H1); intros. rewrite H9. lia. Qed.Lemma Nat_mod_factor a b c: b <> 0 -> c <> 0 -> (a mod (b * c)) mod b = a mod b. Proof. intros. pose proof (Nat.mod_mul_r a _ _ H H0). rewrite H1. rewrite Nat.add_mod_idemp_l by auto. rewrite Nat.add_mod by auto. assert (sth: b * ((a/b) mod c) = (a/b) mod c * b) by (apply Nat.mul_comm). rewrite sth. rewrite Nat.mod_mul by auto. rewrite Nat.add_0_r. rewrite Nat.mod_mod by auto. auto. Qed.Lemma Nat_mod_factor' a b c d: b <> 0 -> c <> 0 -> d = b * c -> (a mod d) mod b = a mod b. Proof. pose proof (@Nat_mod_factor a b c). intros. subst. eapply H; eauto. Qed.Lemma mod_sub a b c: c > 0 -> a >= b * c -> (a - b * c) mod c = a mod c. Proof. intros. assert (sth: a - b * c + b * c = a) by lia. rewrite <- sth at 2. rewrite Nat.mod_add by lia. auto. Qed.Fixpoint mod2 (n : nat) : bool := match n with | 0 => false | 1 => true | S (S n') => mod2 n' end.Ltac rethink := match goal with | [ H : ?f ?n = _ |- ?f ?m = _ ] => replace m with n; simpl; auto end.Theorem mod2_S_double : forall n, mod2 (S (2 * n)) = true. induction n; simpl; intuition; rethink. Qed.Theorem mod2_double : forall n, mod2 (2 * n) = false. induction n; simpl; intuition; rewrite <- plus_n_Sm; rethink. Qed.Theorem div2_double : forall n, Nat.div2 (2 * n) = n. Proof. induction n; simpl; intuition; rewrite <- plus_n_Sm; f_equal; rethink. Qed.Theorem div2_S_double : forall n, Nat.div2 (S (2 * n)) = n. induction n; simpl; intuition; f_equal; rethink. Qed.Fixpoint Npow2 (n : nat) : N := match n with | O => 1 | S n' => 2 * Npow2 n' end%N.Theorem untimes2 : forall n, n + (n + 0) = 2 * n. auto. Qed.Section strong. Variable P : nat -> Prop. Hypothesis PH : forall n, (forall m, m < n -> P m) -> P n. Lemma strong' : forall n m, m <= n -> P m. induction n; simpl; intuition; apply PH; intuition. elimtype False; omega. Qed. Theorem strong : forall n, P n. 
Require Import Utf8. Set Implicit Arguments. Require Import Equalities. Require Import CoreGenericEnv. Require List. Require Sets.Image.Module GenericEnvironmentType (VarType : UsualDecidableType) (CoreGE : CoreGenericEnvironmentType (VarType)).Import List.Import VarType CoreGE. Definition eq_var_dec := VarType.eq_dec.Local Open Scope gen_env_scope.Section ExtendedDefinitions.Variable A : Type. Definition binds (x : TVar) (v : A) (E : gen_env A) := get x E = Some v. Definition all_binds (E F : gen_env A) := forall x v, binds x v E -> binds x v F. Definition eq (E F : gen_env A) := all_binds E F ‚àß all_binds F E.End ExtendedDefinitions.Notation "x '‚àπ' v '‚ã≤' E" := (binds x v E) (at level 65) : gen_env_scope.Notation "E '‚äè' F" := (all_binds E F) (at level 65) : gen_env_scope.Notation "E '‚âç' F" := (eq E F) (at level 68) : gen_env_scope.Bind Scope gen_env_scope with gen_env. Delimit Scope gen_env_scope with gen_env. Local Open Scope gen_env_scope. Section Properties. Implicit Types x y : TVar. Implicit Types xs ys : list TVar.Theorem ok_dom : forall A (E : gen_env A), List.NoDup (dom E) -> ok E. Proof. induction E using env_ind; intro H_NoDup. apply ok_empty. rewrite dom_concat in H_NoDup. rewrite dom_single in H_NoDup. simpl in H_NoDup. inversion H_NoDup. apply ok_cons; split; auto. apply notin_dom_inv; auto. Qed.Theorem ok_dom_inv : forall A (E : gen_env A), ok E -> List.NoDup (dom E). Proof. induction E using env_ind; intro Hok. rewrite dom_empty. apply List.NoDup_nil. apply ok_concat_inv in Hok. destruct Hok as [ HokE Hok ] ; destruct Hok as [ Hokx Hdoms ]. destruct Hdoms as [ Hdom1 Hdom2 ]. rewrite dom_concat. rewrite dom_single in *. simpl. apply List.NoDup_cons; auto. apply all_notin_notin in Hdom2. destruct Hdom2. apply notin_dom; auto. Qed. Theorem ok_NoDup_dom_eq : forall A (E : gen_env A), ok E <-> List.NoDup (dom E). 
H'1; clear H'; exact H'0. Qed.Theorem or_commutative : forall A B : Prop, A \/ B -> B \/ A. intros A B h; elim h; [ intro H'; clear h; try exact H' | clear h; intro H' ]. right; assumption. left; assumption. Qed.Theorem mp : forall A B : Prop, A -> (A -> B) -> B. intros A B H' H'0. apply H'0. exact H'. Qed.Theorem S : forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C. intros A B C H' H'0 H'1. apply H'. exact H'1. apply H'0. exact H'1. Qed.Theorem Praeclarum : forall x y z t : Prop, (x -> z) /\ (y -> t) -> x /\ y -> z /\ t. intros x y z t h; elim h; intros H' H'0; clear h. intro h; elim h; intros H'1 H'2; clear h. split. apply H'; assumption. apply H'0; assumption. Qed.Theorem resolution : forall (p q : Type -> Prop) (a : Type), p a -> (forall x : Type, p x -> q x) -> q a. intros p q a H' H'0. apply H'0. exact H'. Qed.Theorem Witnesses : forall (a b : Type) (p : Type -> Prop), p a \/ p b -> exists x : Type, p x. intros a b p h; elim h; intro H'; clear h. exists a; assumption. exists b; assumption. Qed.Theorem Simple : forall (A : Set) (R : A -> A -> Prop), (forall x y z : A, R x y /\ R y z -> R x z) -> (forall x y : A, R x y -> R y x) -> forall x : A, (exists y : A, R x y) -> R x x. intros A R H' H'0 x h; elim h; intros y E; clear h. apply H' with y. split; [ assumption | idtac ]. apply H'0; assumption. Qed.Theorem not_not : forall a : Prop, a -> ~ ~ a. intros a H'; red in |- *; intro H'0; elim H'0; assumption. Qed.Theorem mini_cases : forall x y : Prop, (x \/ ~ y) /\ y -> x. intros x y h; elim h; intros h0 H'; elim h0; [ intro H'0; clear h h0; try exact H'0 | clear h h0; intro H'0 ]. elim H'0; try assumption. Qed.Require Import Classical. Theorem not_not_converse : forall a : Prop, ~ ~ a -> a. 
‚àó R }}}. Proof. iIntros (? Œ¶) "#Hl HŒ¶". iL√∂b as "IH". wp_rec. wp_apply (try_acquire_spec with "Hl"); auto. iIntros ([]). - iIntros "[Hlked HR]". wp_if. iApply "HŒ¶"; by iFrame. - iIntros "_". wp_if. iApply ("IH" with "[HŒ¶]"). auto. Qed. Lemma acquire_spec lk R : {{{ is_lock lk R }}} lock.acquire lk {{{ RET #(); locked lk ‚àó R }}}. Proof. eapply acquire_spec'; auto. Qed. Lemma release_spec' stk E lk R : ‚ÜëN ‚äÜ E ‚Üí {{{ is_lock lk R ‚àó locked lk ‚àó ‚ñ∑ R }}} lock.release lk @ stk; E {{{ RET #(); True }}}. Proof. iIntros (? Œ¶) "(Hlock & Hlocked & HR) HŒ¶". iDestruct "Hlock" as (l ->) "#Hinv". rewrite /lock.release /=. wp_lam. wp_bind (CmpXchg _ _ _). iInv N as (b) "[>Hl _]". iDestruct (locked_loc with "Hlocked") as "Hl2". iDestruct (heap_mapsto_agree with "[$Hl $Hl2]") as %->. iCombine "Hl Hl2" as "Hl". rewrite Qp.quarter_three_quarter. wp_cmpxchg_suc. iModIntro. iSplitR "HŒ¶"; last by wp_seq; iApply "HŒ¶". iEval (rewrite -Qp.quarter_three_quarter) in "Hl". iDestruct (fractional.fractional_split_1 with "Hl") as "[Hl1 Hl2]". iNext. iExists false. iFrame. Qed. Lemma release_spec lk R : {{{ is_lock lk R ‚àó locked lk ‚àó ‚ñ∑ R }}} lock.release lk {{{ RET #(); True }}}. Proof. eapply release_spec'; auto. Qed. Lemma release_spec'' lk R : is_lock lk R -‚àó {{{ locked lk ‚àó ‚ñ∑ R }}} lock.release lk {{{ RET #(); True }}}. Proof. iIntros "#Hlock !# %Œ¶ [??] HŒ¶". iApply (release_spec with "[-HŒ¶]"); by iFrame. Qed. Definition is_cond (c: loc) (lk : val) : iProp Œ£ := readonly (c ‚Ü¶ lk). Global Instance is_cond_persistent c lk : Persistent (is_cond c lk) := _. Theorem wp_newCond' lk : {{{ is_free_lock lk }}} lock.newCond #lk {{{ (c: loc), RET #c; is_free_lock lk ‚àó is_cond c #lk }}}. Proof. rewrite /is_cond. iIntros (Œ¶) "Hl HŒ¶". wp_call. wp_apply wp_alloc_untyped; [ auto | ]. iIntros (c) "Hc". iMod (readonly_alloc_1 with "Hc") as "Hcond". wp_pures. iApply "HŒ¶". by iFrame. Qed. Theorem wp_newCond lk R : {{{ is_lock lk R }}} lock.newCond lk {{{ (c: loc), RET #c; is_cond c lk }}}. Proof. rewrite /is_cond. iIntros (Œ¶) "Hl HŒ¶". wp_call. iDestruct (is_lock_flat with "Hl") as %[l ->]. wp_apply wp_alloc_untyped; [ auto | ]. iIntros (c) "Hc". iMod (readonly_alloc_1 with "Hc") as "Hcond". wp_pures. by iApply "HŒ¶". Qed. Theorem wp_condSignal c lk : {{{ is_cond c lk }}} lock.condSignal #c {{{ RET #(); True }}}. Proof. iIntros (Œ¶) "Hc HŒ¶". wp_call. iApply ("HŒ¶" with "[//]"). Qed. Theorem wp_condBroadcast c lk : {{{ is_cond c lk }}} lock.condBroadcast #c {{{ RET #(); True }}}. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor. From Categories Require Import Cat.Cat.Section NatTrans. Context {C C' : Category}. Record NatTrans (F F' : (C ‚Äì‚âª C')%functor) := { Trans (c : C) : ((F _o c) ‚Äì‚âª (F' _o c))%object%morphism; Trans_com {c c' : C} (h : (c ‚Äì‚âª c')%morphism) : ((Trans c') ‚àò F _a h = F' _a h ‚àò (Trans c))%morphism; Trans_com_sym {c c' : C} (h : (c ‚Äì‚âª c')%morphism) : (F' _a h ‚àò (Trans c) = (Trans c') ‚àò F _a h)%morphism }. Notation "F ‚Äì‚âª F'" := (NatTrans F F') : nattrans_scope. Lemma NatTrans_eq_simplify {F F' : (C ‚Äì‚âª C')%functor} (N N' : (F ‚Äì‚âª F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'. Proof. destruct N; destruct N'. basic_simpl. ElimEq. PIR; trivial. Qed.End NatTrans.Arguments Trans {_ _ _ _} _ _. Arguments Trans_com {_ _ _ _} _ {_ _} _. Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.Bind Scope nattrans_scope with NatTrans.Notation "F ‚Äì‚âª F'" := (NatTrans F F') : nattrans_scope.Local Open Scope nattrans_scope.Section NatTrans_Compose. Context {C C' : Category}. Program Definition NatTrans_compose {F F' F'' : (C ‚Äì‚âª C')%functor} (tr : F ‚Äì‚âª F') (tr' : F' ‚Äì‚âª F'') : (F ‚Äì‚âª F'')%nattrans := {| Trans := fun c : Obj => ((Trans tr' c) ‚àò (Trans tr c)) % morphism |}. Next Obligation. Proof. rewrite assoc. rewrite Trans_com. rewrite assoc_sym. rewrite Trans_com; auto. Qed. Next Obligation. Proof. symmetry. apply NatTrans_compose_obligation_1. Qed.End NatTrans_Compose.Notation "N ‚àò N'" := (NatTrans_compose N' N) : nattrans_scope.Section NatTrans_Props. Context {C C' : Category}. Theorem NatTrans_compose_assoc {F G H I : (C ‚Äì‚âª C')%functor} (N : F ‚Äì‚âª G) (N' : G ‚Äì‚âª H) (N'' : H ‚Äì‚âª I) : ((N'' ‚àò N') ‚àò N = N'' ‚àò (N' ‚àò N))%nattrans . Proof. apply NatTrans_eq_simplify; cbn; auto. Qed. Program Definition NatTrans_id (F : (C ‚Äì‚âª C')%functor) : F ‚Äì‚âª F := {| Trans := fun x : Obj => id |}. Theorem NatTrans_id_unit_left {F G : (C ‚Äì‚âª C')%functor} (N : F ‚Äì‚âª G) : (NatTrans_id G) ‚àò N = N. 
m. + rewrite lb_plus_fix_0, lb_succ_spec, lb_nat_fix_0; omega. + destruct m as [ | y m ]. * rewrite lb_plus_fix_1, lb_succ_spec, lb_nat_fix_0; omega. * rewrite lb_plus_fix_2, lb_nat_fix_3, lb_nat_fix_3. destruct a; destruct x; destruct y; simpl; rewrite IHl; simpl; omega. Qed. Local Infix "‚äï" := (lb_plus ‚üò ) (at level 41, left associativity). Fact lb_plus_spec_0 l m : ‚ü¶l‚äïm‚üß = ‚ü¶l‚üß + ‚ü¶m‚üß. Proof. rewrite lb_plus_spec; simpl; auto. Qed. Add Parametric Morphism a: (lb_plus a) with signature (lbeq) ==> (lbeq) ==> (lbeq) as lb_plus_eq. Proof. intros x1 y1 E1 x2 y2 E2; revert E1 E2. do 3 rewrite lb_mask_equiv_equal. do 2 rewrite lb_plus_spec. intros; f_equal; auto. Qed. Fact lb_ortho_plus l m : l ‚üÇ m <-> l ‚™Ø l‚äïm. Proof. split. + induction 1 as [ l | l | x y l m [ H1 | H1 ] H2 IH2 ]. * constructor. * rewrite lb_plus_fix_1. rewrite lb_mask_eq_binary_le, lb_succ_spec; simpl. rewrite <- lb_mask_eq_binary_le; apply lb_mask_refl. * rewrite lb_plus_fix_2. subst x; rewrite bin_add_eq_00x. destruct y; constructor; auto. * rewrite lb_plus_fix_2. subst y; rewrite bin_add_eq_0x0. destruct x; constructor; auto. + revert m; induction l as [ | x l IHl ]. * intros; constructor. * intros [ | y m ] H. - constructor. - rewrite lb_plus_fix_2 in H. destruct x; destruct y; simpl in H; try (apply lb_mask_inv_cons_cons in H; tauto); apply lb_mask_inv_cons, proj2 in H; constructor; auto. Qed. Fact lb_ortho_plus_join x y : x ‚üÇ y -> x‚äïy ‚âÇ x‚Üëy. Proof. induction 1 as [ m | l | x y l m H1 H2 IH2 ]. + rewrite lb_plus_fix_0, lb_join_right; apply lb_succ_bot. + rewrite lb_plus_fix_1, lb_join_left; apply lb_succ_bot. + rewrite lb_join_cons. apply lb_mask_equiv_equal. rewrite lb_plus_spec_0. do 3 rewrite lb_nat_fix_3. rewrite lb_mask_equiv_equal in IH2. rewrite <- IH2. rewrite lb_plus_spec_0. destruct x; destruct y; simpl; try ring. destruct H1; discriminate. Qed. Fact lb_ortho_plus_id a x y : a ‚üÇ x -> a ‚üÇ y -> x ‚üÇ y <-> (a‚äïx)‚Üì(a‚äïy) ‚âÇ a. Proof. intros H1 H2. do 2 (rewrite lb_ortho_plus_join; auto). rewrite <- lb_join_meet_distr, lb_ortho_meet_nil. split. + intros H3; rewrite H3, lb_join_left; auto. + intros H3; apply lb_ortho_mask_nil with a. * revert H1; apply lb_ortho_anti; auto. * rewrite <- H3, lb_join_comm; auto. Qed. Fact lb_minus_plus a b : a ‚™Ø b -> exists x, b ‚âÇ a‚äïx /\ a ‚™Ø a‚äïx. Proof. intros H. destruct lb_minus with (1 := H) as (x & H1 & H2). exists x; rewrite lb_ortho_plus_join; auto. Qed. Theorem lb_meet_dio a b c : a ‚âÇ b‚Üìc <-> exists x y, b ‚âÇ a‚äïx /\ c ‚âÇ a‚äïy /\ a ‚™Ø a‚äïx /\ a ‚™Ø a‚äïy /\ x ‚™Ø x‚äïy. 
intros. apply typ_weak with e d e; auto with arith pts. Qed. Theorem thinning_n : forall (n : nat) (e f : env), trunc n e f -> forall t T : term, typ f t T -> wf e -> typ e (lift n t) (lift n T). simple induction n. intros. rewrite lift0. rewrite lift0. replace e with f; auto with arith pts. inversion_clear H; auto with arith pts.do 8 intro. inversion_clear H0. intro. rewrite simpl_lift; auto with arith pts. pattern (lift (S n0) T) in |- *. rewrite simpl_lift; auto with arith pts. inversion_clear H0. change (typ (Ax T0 :: e0) (lift 1 (lift n0 t)) (lift 1 (lift n0 T))) in |- *. apply thinning; auto with arith pts. apply H with f; auto with arith pts. apply typ_wf with T0 (Srt s); auto with arith pts.apply wf_var with s; auto with arith pts.change (typ (Def t0 T0 :: e0) (lift 1 (lift n0 t)) (lift 1 (lift n0 T))) in |- *. apply thinning; auto with arith pts. apply H with f; auto with arith pts. apply typ_wf with t0 T0; auto with arith pts.apply wf_cst with s; auto with arith pts. Qed. Theorem wf_sort_lift : forall (n : nat) (e : env) (t : term), wf e -> item_lift t e n -> exists s : sort, typ e t (Srt s). simple induction n. simple destruct e; intros. elim H0; intros. inversion_clear H2.elim H0; intros. rewrite H1. inversion_clear H2. elim inv_wf_sort with l d; intros; auto with arith pts. exists x0. replace (Srt x0) with (lift 1 (Srt x0)); auto with arith pts. apply thinning; auto with arith pts.intros. elim H1; intros. rewrite H2. generalize H0. inversion_clear H3; intros. rewrite simpl_lift; auto with arith pts. elim H with l (lift (S n0) (typ_of_decl x)); intros; auto with arith pts. exists x0. replace (Srt x0) with (lift 1 (Srt x0)); auto with arith pts. apply thinning; auto with arith pts.apply inv_wf with y; auto with arith pts.exists x; auto with arith pts. Qed. Theorem definition_lift : forall (e : env) (n : nat) (t T : term), item (Def t T) e n -> wf e -> typ e (lift (S n) t) (lift (S n) T). intros. elim item_trunc with (1 := H); intros. apply thinning_n with x; auto with arith pts. apply wf_definition with (1 := H); trivial with arith pts. Qed. Theorem typ_sub : forall (g : env) (x : term) (d : decl), typ g x (typ_of_decl d) -> forall (e : env) (u U : term), typ e u U -> forall (f : env) (n : nat), sub_in_env g d x n e f -> wf f -> typ f (subst_rec x u n) (subst_rec x U n). 
cs; Ret cs. Definition sync xp cs := cs <- BUFCACHE.sync (LAHdr xp) cs; Ret cs. Definition sync_now xp cs := cs <- BUFCACHE.begin_sync cs; cs <- BUFCACHE.sync (LAHdr xp) cs; cs <- BUFCACHE.end_sync cs; Ret cs. Definition init xp cs := h <- Hash default_valu; cs <- BUFCACHE.write (LAHdr xp) (hdr2val (mk_header ((0, 0), (0, 0), (h, h)))) cs; cs <- BUFCACHE.begin_sync cs; cs <- BUFCACHE.sync (LAHdr xp) cs; cs <- BUFCACHE.end_sync cs; Ret cs. Local Hint Unfold rep state_goodSize : hoare_unfold. Theorem write_ok : forall xp n cs, {< F d old, PRE:hm BUFCACHE.rep cs d * [[ hdr_goodSize n ]] * [[ previous_length n = current_length old \/ previous_length old = current_length n ]] * [[ (F * rep xp (Synced old))%pred d ]] POST:hm' RET: cs exists d', BUFCACHE.rep cs d' * [[ (F * rep xp (Unsync n old))%pred d' ]] XCRASH:hm' exists cs' d', BUFCACHE.rep cs' d' * [[ (F * rep xp (Unsync n old))%pred d' ]] >} write xp n cs. Proof. unfold write. step. step. xcrash. step. xcrash. Qed. Theorem read_ok : forall xp cs, {< F d n, PRE:hm BUFCACHE.rep cs d * [[ (F * rep xp (Synced n))%pred d ]] POST:hm' RET: ^(cs, r) BUFCACHE.rep cs d * [[ (F * rep xp (Synced n))%pred d ]] * [[ r = n ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d >} read xp cs. Proof. unfold read. hoare. subst; rewrite val2hdr2val; simpl. unfold hdr_goodSize in *; intuition. repeat rewrite wordToNat_natToWord_idempotent'; auto. destruct n; auto. destruct p as (p1 , p2); destruct p1, p2, p0; auto. Qed. Theorem sync_ok : forall xp cs, {< F d0 d n old, PRE:hm BUFCACHE.synrep cs d0 d * [[ (F * rep xp (Unsync n old))%pred d ]] * [[ sync_invariant F ]] POST:hm' RET: cs exists d', BUFCACHE.synrep cs d0 d' * [[ (F * rep xp (Synced n))%pred d' ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d0 >} sync xp cs. Proof. unfold sync. step. step. Qed. Theorem sync_now_ok : forall xp cs, {< F d n old, PRE:hm BUFCACHE.rep cs d * [[ (F * rep xp (Unsync n old))%pred d ]] * [[ sync_invariant F ]] POST:hm' RET: cs exists d', BUFCACHE.rep cs d' * [[ (F * rep xp (Synced n))%pred d' ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d >} sync_now xp cs. Proof. unfold sync_now; intros. hoare. Qed. Theorem init_ok : forall xp cs, {< F d v0, PRE:hm BUFCACHE.rep cs d * [[ (F * (LAHdr xp) |+> v0)%pred d ]] * [[ sync_invariant F ]] POST:hm' RET: cs exists d', BUFCACHE.rep cs d' * [[ (F * rep xp (Synced ((0, 0), (0, 0), (hash_fwd default_valu, hash_fwd default_valu))))%pred d' ]] CRASH:hm' any >} init xp cs. 
Require Import Arith. Require Export Euclid. Require Import ZArith. Theorem lt_mult_right : forall x y z t : nat, x < z -> y < t -> x * y < z * t. intros x y z t; case x; case z. intros H'; inversion H'. simpl in |- *; intros n H'; case t; auto with arith. intros H'0; inversion H'0. intros n H'; inversion H'. intros n n0 H'; case t. intros H'0; inversion H'0. intros n1 H'0; apply lt_trans with (m := S n0 * S n1). apply mult_S_lt_compat_l; auto. rewrite (mult_comm (S n0)); rewrite (mult_comm (S n)); auto. apply mult_S_lt_compat_l; auto. Qed. Theorem le_mult_right : forall x y : nat, 0 < y -> x <= x * y. 
lseg b n fr ba ===> lseg b' n fr ba. induction n; sepLemma. Qed. Theorem llist_extensional' : forall ba n b b' fr, b %= b' -> llist b n fr ba ===> llist b' n fr ba. induction n; sepLemma. Qed. Theorem queue_fwd : forall b p, queue b p ===> Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. unfold queue; sepLemma. Qed. Theorem queue_bwd : forall b p, (Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba) ===> queue b p. unfold queue; sepLemma. Qed. Theorem llist_empty_fwd : forall b n (fr : W) ba, fr = 0 -> llist b n fr ba ===> [| b %= empty |] * [| n = O |]. destruct n; sepLemma. Qed. Theorem llist_empty_bwd : forall b n (fr : W) ba, fr = 0 -> [| b %= empty |] * [| n = O |] ===> llist b n fr ba. destruct n; sepLemma. Qed. Theorem llist_nonempty_fwd : forall ba n (fr : W) b, fr <> 0 -> focusOnFront -> llist b n fr ba ===> Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * [| freeable fr 3 |] * (fr ==*> v1, v2, p) * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba. destruct n; sepLemma. Qed. Theorem llist_end_fwd : forall ba n (fr : W) b, fr <> 0 -> focusOnBack -> llist b n fr ba ===> Ex n', Ex v1, Ex v2, [| n = S n' |] * [| (v1, v2) %in b |] * lseg (b %- (v1, v2)) n' fr ba * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1, v2, $0). induction n. sepLemma. sepLemmaLhsOnly. destruct n. specialize (H4 (refl_equal _)); subst. sepLemma. sepLemma. clear H4. transitivity ([| x <> 0 |] * llist (b %- (x1, x0)) (S n) x ba * SEP.ST.star (fr =*> x1) (SEP.ST.star ((fr ^+ $4) =*> x0) ((fr ^+ $8) =*> x))). sepLemma. remember (S n). sepLemmaLhsOnly. etransitivity. eapply himp_star_frame; [ auto | reflexivity ]. sepLemma. sepLemma. injection H4; clear H4; intros; subst. apply lseg_extensional'; bags. Qed. Theorem llist_nonempty_fwd_b : forall b n (fr : W) ba, ~(b %= empty) -> focusOnFront -> llist b n fr ba ===> [| fr <> 0 |] * Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba. 
From iris.algebra Require Import gmap. From iris.proofmode Require Import tactics. From iris.bi.lib Require Import fractional. From Perennial.base_logic.lib Require Import iprop. From Perennial.Helpers Require Import Qextra.Section bi. Context {PROP:bi} `{!BiAffine PROP}. Set Default Proof Using "All". Implicit Types (P:PROP) (Œ¶: Qp ‚Üí PROP) (q: Qp). Theorem fractional_weaken Œ¶ `{fractional.Fractional _ Œ¶} q1 q2 : (q1 ‚â§ q2)%Qp -> Œ¶ q2 -‚àó Œ¶ q1. 
(f : ((√ó·∂ ‚Åø·∂ú C) _o (z, c))%object ‚Äì‚âª d) (u u' : z ‚Äì‚âª exponential), f = (eval ‚àò ((√ó·∂ ‚Åø·∂ú C) @_a (_, _) (_, _) (u, id c)))%morphism ‚Üí f = (eval ‚àò ((√ó·∂ ‚Åø·∂ú C) @_a (_, _) (_, _) (u', id c)))%morphism ‚Üí u = u' }.Coercion exponential : Exponential >-> Obj.Arguments Exponential _ {_} _ _, {_ _} _ _.Arguments exponential {_ _ _ _} _, {_ _} _ _ {_}. Arguments eval {_ _ _ _} _, {_ _} _ _ {_}. Arguments Exp_morph_ex {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _. Arguments Exp_morph_com {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _. Arguments Exp_morph_unique {_ _ _ _} _ _ _ _ _ _ _, {_ _} _ _ {_} _ _ _ _ _ _.Notation "a ‚áë b" := (Exponential a b) : object_scope. Theorem Exponential_iso {C : Category} {HP : Has_Products C} (c d : C) (E E' : (c ‚áë d)%object) : (E ‚âÉ E')%isomorphism. Proof. eapply ( Build_Isomorphism _ _ _ (Exp_morph_ex E' _ (eval E)) (Exp_morph_ex E _ (eval E')) ); eapply Exp_morph_unique; eauto; simpl_ids; match goal with [|- (_ ‚àò ?M)%morphism = _] => match M with (?U _a (?A ‚àò ?B, ?C))%morphism => assert (M = (U @_a (_, _) (_, _) (A, C)) ‚àò (U @_a (_, _) (_, _) (B, C)))%morphism as HM; [simpl_ids; rewrite <- F_compose; simpl; simpl_ids; trivial|rewrite HM] end end; rewrite <- assoc; repeat rewrite <- Exp_morph_com; auto. Qed.Definition Has_Exponentials (C : Category) {HP : Has_Products C} := ‚àÄ a b, (a ‚áë b)%object.Existing Class Has_Exponentials.Section Curry_UnCurry. Context (C : Category) {HP : Has_Products C} {HE : Has_Exponentials C}. Definition curry : forall {a b c : C}, (((√ó·∂ ‚Åø·∂ú C) _o (a, b))%object ‚Äì‚âª c) ‚Üí (a ‚Äì‚âª (HE b c)) := fun {a b c : C} (f : ((√ó·∂ ‚Åø·∂ú C) _o (a, b))%object ‚Äì‚âª c) => Exp_morph_ex (HE b c) _ f. Definition uncurry : forall {a b c : C}, (a ‚Äì‚âª (HE b c)) ‚Üí (((√ó·∂ ‚Åø·∂ú C) _o (a, b))%object ‚Äì‚âª c) := fun {a b c : C} (f : a ‚Äì‚âª (HE b c)) => ((eval (HE b c)) ‚àò ((√ó·∂ ‚Åø·∂ú C) @_a (_, _) (_, _) (f, id C b)))%morphism. Section inversion. Context {a b c : C}. Theorem curry_uncurry (f : a ‚Äì‚âª (HE b c)) : curry (uncurry f) = f. 
Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.EchoServer Bedrock.Platform.Bootstrap. Module Type S. Parameter heapSize : nat. Parameters port numWorkers : W. End S.Module Make(M : S). Import M.Module M'. Definition globalSched : W := ((heapSize + 50) * 4)%nat. Definition globalSock : W := globalSched ^+ $4. Definition port := M.port. Definition numWorkers := M.numWorkers. Definition inbuf_size := 40. Theorem inbuf_size_lower : (inbuf_size >= 2)%nat. 
st b = true -> c1 / st \\ st' -> (IFB b THEN c1 ELSE c2 FI) / st \\ st' | E_IfFalse : forall st st' b c1 c2, beval st b = false -> c2 / st \\ st' -> (IFB b THEN c1 ELSE c2 FI) / st \\ st' | E_WhileFalse : forall b st c, beval st b = false -> (WHILE b DO c END) / st \\ st | E_WhileTrue : forall st st' st'' b c, beval st b = true -> c / st \\ st' -> (WHILE b DO c END) / st' \\ st'' -> (WHILE b DO c END) / st \\ st'' where "c1 '/' st '\\' st'" := (ceval c1 st st').Example ceval_example1: (X ::= ANum 2;; IFB BLe (AId X) (ANum 1) THEN Y ::= ANum 3 ELSE Z ::= ANum 4 FI) / empty_state \\ (t_update (t_update empty_state X 2) Z 4). Proof. apply E_Seq with (t_update empty_state X 2). - apply E_Ass. reflexivity. - apply E_IfFalse. reflexivity. apply E_Ass. reflexivity. Qed. Example ceval_example2: (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state \\ (t_update (t_update (t_update empty_state X 0) Y 1) Z 2). Proof. Admitted.Definition pup_to_n : com . Admitted.Theorem pup_to_2_ceval : pup_to_n / (t_update empty_state X 2) \\ t_update (t_update (t_update (t_update (t_update (t_update empty_state X 2) Y 0) Y 2) X 1) Y 3) X 0. Proof. Admitted.Theorem ceval_deterministic: forall c st st1 st2, c / st \\ st1 -> c / st \\ st2 -> st1 = st2. Proof. intros c st st1 st2 E1 E2. generalize dependent st2. induction E1; intros st2 E2; inversion E2; subst. - reflexivity. - reflexivity. - assert (st' = st'0) as EQ1. { apply IHE1_1; assumption. } subst st'0. apply IHE1_2. assumption. - apply IHE1. assumption. - rewrite H in H5. inversion H5. - rewrite H in H5. inversion H5. - apply IHE1. assumption. - reflexivity. - rewrite H in H2. inversion H2. - rewrite H in H4. inversion H4. - assert (st' = st'0) as EQ1. { apply IHE1_1; assumption. } subst st'0. apply IHE1_2. assumption. Qed. Theorem plus2_spec : forall st n st', st X = n -> plus2 / st \\ st' -> st' X = n + 2. Proof. intros st n st' HX Heval. inversion Heval. subst. clear Heval. simpl. apply t_update_eq. Qed. Theorem loop_never_stops : forall st st', ~(loop / st \\ st'). 
|- *; auto. intros tmp; Contradict tmp; auto with arith. intros n H2; generalize Hb. case (nat_of_P base); simpl in |- *; auto. intros tmp; Contradict tmp; auto with arith. intros base'; case base'; simpl in |- *; auto with arith. intros tmp; Contradict tmp; auto with arith. intros o2; case o2; simpl in |- *; auto with arith. intros o2' (Ho1, Ho2); repeat (split; auto with arith). rewrite mult_comm; simpl in |- *; auto with arith. intros bound' H H0; Contradict Ho2. apply le_not_lt. rewrite <- Ho1. generalize H; case bound'. rewrite mult_comm; simpl in |- *; auto. intros Eq2; generalize (lt_O_nat_of_P bound); rewrite Eq2; intros tmp; Contradict tmp; auto with arith. intros n Eq2; apply le_trans with (nat_of_P bound); auto with arith. rewrite Eq2; auto with arith. rewrite mult_comm; simpl in |- *; auto with arith. intros (Ho1, Ho2); generalize (lt_O_nat_of_P p); rewrite Ho1; intros tmp; Contradict tmp; auto with arith. Qed. Definition PdivBound bound p base := Pdivless bound p base p. Theorem PdivBound_correct : forall bound p base, 1 < nat_of_P base -> nat_of_P p = oZ (fst (fst (PdivBound bound p base))) * exp (nat_of_P base) (snd (PdivBound bound p base)) + oZ (snd (fst (PdivBound bound p base))) /\ (oZ (fst (fst (PdivBound bound p base))) < nat_of_P bound /\ oZ (snd (fst (PdivBound bound p base))) < exp (nat_of_P base) (snd (PdivBound bound p base))) /\ (forall bound', nat_of_P bound = nat_of_P base * bound' -> nat_of_P bound <= nat_of_P p -> nat_of_P bound <= nat_of_P base * oZ (fst (fst (PdivBound bound p base)))). intros; unfold PdivBound in |- *; apply Pdivless_correct; auto. Qed. Theorem PdivBound_correct1 : forall bound p base, 1 < nat_of_P base -> nat_of_P p = oZ (fst (fst (PdivBound bound p base))) * exp (nat_of_P base) (snd (PdivBound bound p base)) + oZ (snd (fst (PdivBound bound p base))). intros bound p base H; generalize (PdivBound_correct bound p base); intuition. Qed. Theorem PdivBound_correct2 : forall bound p base, 1 < nat_of_P base -> oZ (fst (fst (PdivBound bound p base))) < nat_of_P bound. intros bound p base H; generalize (PdivBound_correct bound p base); intuition. Qed. Theorem PdivBound_correct3 : forall bound p base, nat_of_P p < nat_of_P bound -> PdivBound bound p base = (Some _ p, None _, 0). intros bound p base H; (unfold PdivBound in |- *; apply Pdivless1; auto). apply nat_of_P_gt_Gt_compare_complement_morphism; auto with arith. Qed. Theorem PdivBound_correct4 : forall bound p base bound', 1 < nat_of_P base -> nat_of_P bound = nat_of_P base * bound' -> nat_of_P bound <= nat_of_P p -> nat_of_P bound <= nat_of_P base * oZ (fst (fst (PdivBound bound p base))). 
bool) (t: Tree) (p_ch p_fa: val) : mpred := match d with | true => EX p_oppo: val, tree_rep t p_fa p_ch p_oppo | false => EX p_oppo: val, tree_rep t p_fa p_oppo p_ch end. Lemma tree_rep_saturate_local: forall t p p_lch p_rch, tree_rep t p p_lch p_rch |-- !! is_pointer_or_null p. Proof. destruct t; simpl; intros. entailer!. Intros p_lch_l p_lch_r p_rch_l p_rch_r. entailer!. Qed. #[export] Hint Resolve tree_rep_saturate_local: saturate_local.Lemma tree_rep_valid_pointer: forall t p p_lch p_rch, tree_rep t p p_lch p_rch |-- valid_pointer p. Proof. intros. destruct t. - simpl. entailer!. - simpl; normalize; auto with valid_pointer. Qed. #[export] Hint Resolve tree_rep_valid_pointer: valid_pointer.Definition bool2int (d: bool) : Z := match d with | true => 1 | false => 0 end. Definition get_branch_spec := DECLARE _get_branch WITH t: Tree, d: bool, p_fa: val, p: val PRE [ tptr t_struct_tree, tptr t_struct_tree ] PROP (p_fa <> nullval; p <> nullval) PARAMS (p; p_fa) SEP (fa_rep d t p p_fa) POST [ tint ] PROP () RETURN (Vint (Int.repr (bool2int d))) SEP (fa_rep d t p p_fa).Definition Gprog : funspecs := ltac:(with_library prog [get_branch_spec]). Theorem body_get_branch_old_fashion: semax_body Vprog Gprog f_get_branch get_branch_spec. Proof. start_function. destruct t. { destruct d; simpl fa_rep; Intros a; apply H in H1; destruct H1. } destruct d. { simpl fa_rep. Intros p_oppo p_lch_l p_lch_r p_rch_l p_rch_r. forward. forward_if. { forward. simpl. Exists p_oppo p_lch_l p_lch_r p_rch_l p_rch_r. entailer!. } { contradiction. } } { simpl fa_rep. Intros p_oppo p_lch_l p_lch_r p_rch_l p_rch_r. forward. forward_if. { destruct t1; destruct t2; simpl; Intros; subst; try contradiction. simpl tree_rep. Intros p_lch_l0 p_lch_r0 p_rch_l0 p_rch_r0. Intros p_lch_l1 p_lch_r1 p_rch_l1 p_rch_r1. pose proof (data_at_conflict Tsh t_struct_tree (Vint (Int.repr k0), (p_lch_l, p_lch_r)) (Vint (Int.repr k1), (p_rch_l, p_rch_r)) p_oppo top_share_nonidentity). sep_apply H1. sep_apply FF_local_facts. Intros. destruct H2. } { forward. simpl. Exists p_oppo p_lch_l p_lch_r p_rch_l p_rch_r. entailer!. } } Qed.Lemma tree_rep_conflict : forall p t1 t2 p_ll p_lr p_rl p_rr, p <> nullval -> tree_rep t1 p p_ll p_lr * tree_rep t2 p p_rl p_rr |-- !! False. Proof. intros. destruct t1. { simpl. Intros. apply H in H0. destruct H0. } destruct t2. { simpl. Intros. apply H in H0. destruct H0. } simpl tree_rep. Intros p_lch_l0 p_lch_r0 p_rch_l0 p_rch_r0. Intros p_lch_l1 p_lch_r1 p_rch_l1 p_rch_r1. data_at_conflict p. Qed.Ltac tree_rep_conflict := try (sep_apply tree_rep_conflict; Intros; exfalso; assumption).Ltac show_the_way d := destruct d; simpl fa_rep; Intros p_oppo p_lch_l p_lch_r p_rch_l p_rch_r; forward; forward_if; subst; try tree_rep_conflict. Theorem body_get_branch_new_fashion: semax_body Vprog Gprog f_get_branch get_branch_spec. 
].Ltac link_simp := simpl Imports; simpl Exports; cbv beta iota zeta delta [importsOk LabelMap.fold LabelMap.Raw.fold LabelMap.this importsMap fold_left LabelMap.add LabelMap.Raw.add LabelMap.empty LabelMap.Raw.empty LabelKey.compare LabelKey.compare' string_lt fst snd string_dec sumbool_rec sumbool_rect Ascii.N_of_ascii Ascii.N_of_digits N.compare Pos.compare string_rec string_rect Ascii.ascii_dec LabelMap.find LabelMap.Raw.find Nplus Nmult Pos.compare_cont Pos.add Pos.mul Ascii.ascii_rec Ascii.ascii_rect Bool.bool_dec bool_rec bool_rect eq_rec_r eq_rec eq_rect eq_sym label'_lt label'_eq label'_rec label'_rect LabelMap.Raw.bal LabelMap.Raw.create Int.Z_as_Int.gt_le_dec Int.Z_as_Int.plus Int.Z_as_Int.ge_lt_dec LabelMap.Raw.height ZArith_dec.Z_gt_le_dec Int.Z_as_Int._0 BinInt.Z.add Int.Z_as_Int._1 Int.Z_as_Int._2 ZArith_dec.Z_gt_dec ZArith_dec.Z_ge_lt_dec Int.Z_as_Int.max BinInt.Z.max BinInt.Z.compare BinInt.Z.ltb union ZArith_dec.Z_ge_dec diff LabelMap.mem LabelMap.Raw.mem LabelMap.is_empty LabelMap.Raw.is_empty Pos.succ].Ltac link m1 m2 := apply linkOk; [ apply m1 | apply m2 | exact (refl_equal true) | link_simp; tauto | link_simp; tauto | link_simp; tauto ].Lemma specs_cong : forall (specs : codeSpec W (settings * state)) x p, specs x = p -> forall y, x = y -> specs y = p. congruence. Qed.Implicit Arguments specs_cong [specs x p y].Hint Extern 1 (?specs _ = Some _) => match goal with | [ H : specs _ = Some _ |- _ ] => apply (specs_cong H); congruence end.Lemma use_himp : forall pc state specs (P Q : hprop pc state nil), himp specs P Q -> forall s m, interp specs (P s m) -> interp specs (Q s m). intros; apply (Imply_sound (H _ _)); auto. Qed.Lemma Imply_refl : forall pc state specs (P : PropX pc state), interp specs (P ---> P). intros; apply Imply_I; apply Env; simpl; auto. Qed.Section PropX. Variables pc state : Type. Variable P : PropX pc state. Variable specs : codeSpec pc state. Open Scope PropX_scope. Theorem injL : forall (p : Prop), (p -> interp specs P) -> interp specs ([| p |] ---> P). intros. apply Imply_I. eapply Inj_E. eauto. auto. Qed. Theorem cptrL : forall i a, (specs i = Some (fun x => a x) -> interp specs P) -> interp specs (Cptr i a ---> P). intros. apply Imply_I. eapply Cptr_E. eauto. eauto. Qed. Theorem andL : forall Q R, interp specs (Q ---> (R ---> P)) -> interp specs (Q /\ R ---> P). intros. apply Imply_I. eapply Imply_E. eapply Imply_E. eauto. eapply And_E1. eauto. eapply And_E2. eauto. Qed. Ltac hyp := eapply Env; simpl; eauto. Theorem existsL : forall A (p : A -> _), (forall x, interp specs (p x ---> P)) -> interp specs ((Exists p) ---> P). intros. apply Imply_I. eapply Exists_E. eauto. intros. eapply Imply_E. eauto. hyp. Qed. Theorem injR : forall (p : Prop), p -> interp specs (P ---> [| p |]). 
y ) x ) . Definition ezmappr1 { Z : UU } ( P : Z -> UU ) ( z : Z ) : P z -> hfiber ( @pr1 Z P ) z := fun p : P z => tpair _ ( tpair _ z p ) ( idpath z ).Definition invezmappr1 { Z : UU } ( P : Z -> UU) ( z : Z ) : hfiber ( @pr1 Z P ) z -> P z := fun te : hfiber ( @pr1 Z P ) z => match te with tpair _ t e => transportf P e ( pr2 t ) end.Definition isweqezmappr1 { Z : UU } ( P : Z -> UU ) ( z : Z ) : isweq ( ezmappr1 P z ). Proof. intros. assert ( egf : forall x: P z , paths (invezmappr1 _ z ((ezmappr1 P z ) x)) x). intro. unfold ezmappr1. unfold invezmappr1. simpl. apply idpath. assert ( efg : forall x: hfiber (@pr1 Z P) z , paths (ezmappr1 _ z (invezmappr1 P z x)) x). intros. destruct x as [ x t0 ]. destruct t0. simpl in x. simpl. destruct x. simpl. unfold transportf. unfold ezmappr1. apply idpath. apply (gradth _ _ egf efg ). Defined. Definition ezweqpr1 { Z : UU } ( P : Z -> UU ) ( z : Z ) := weqpair _ ( isweqezmappr1 P z ) .Lemma isfibseqpr1 { Z : UU } ( P : Z -> UU ) ( z : Z ) : isfibseq (fun p : P z => tpair _ z p) ( @pr1 Z P ) z (fun p: P z => idpath z ). Proof. intros. unfold isfibseq. unfold ezmap. apply isweqezmappr1. Defined.Definition fibseqpr1 { Z : UU } ( P : Z -> UU ) ( z : Z ) : fibseqstr (fun p : P z => tpair _ z p) ( @pr1 Z P ) z := fibseqstrpair _ _ _ _ ( isfibseqpr1 P z ) . Definition ezweq1pr1 { Z : UU } ( P : Z -> UU ) ( z : Z ) ( zp : total2 P ) : weq ( paths ( pr1 zp) z ) ( hfiber ( tpair P z ) zp ) := ezweq1 _ _ z ( fibseqpr1 P z ) zp . Theorem isfibseqg { Y Z : UU } (g:Y -> Z) (z:Z) : isfibseq (hfiberpr1 g z) g z (fun ye: _ => pr2 ye). 
(existT P s' Ps') with (existT _ (projT1 (existT P s' Ps')) (projT2 (existT P s' Ps'))). rewrite <- H'. clear H'. destruct H. trivial. Qed. Section Adjunct_Between_Compose_assoc. Context {B C D E : Category} (adj : Adjunct_Between B C) (adj' : Adjunct_Between C D) (adj'' : Adjunct_Between D E). Theorem Adjunct_Between_Compose_assoc : Adjunct_Between_Compose adj (Adjunct_Between_Compose adj' adj'') = Adjunct_Between_Compose (Adjunct_Between_Compose adj adj') adj''. Proof. destruct adj as [[F G] adjb]; destruct adj' as [[F' G'] adjb']; destruct adj'' as [[F'' G''] adjb'']. set (W := Functor_assoc (fst (F, G)) (fst (F', G')) (fst (F'', G''))). set (W' := eq_sym (Functor_assoc (snd (F'', G'')) (snd (F', G')) (snd (F, G)))). match type of W with ?A = ?B => match type of W' with ?A' = ?B' => match goal with [|- ?X = ?Z] => set (H := match W in _ = Y return (A, _) = (Y, _) with eq_refl => match W' in _ = Y return (_, A') = (_, Y) with eq_refl => eq_refl (A, A') end end : projT1 X = projT1 Z) end end end. apply (sigT_eq_simplify _ _ H). etransitivity; [|apply Adjunct_Compose_assoc]. unfold W, W' in H; clear W W'; unfold H; clear H. cbn. destruct (Functor_assoc F F' F''). destruct (eq_sym (Functor_assoc G'' G' G)). trivial. Qed.End Adjunct_Between_Compose_assoc.Section Adjunct_Between_Id_unit_left. Context {B C: Category} (adj : Adjunct_Between B C). Theorem Adjunct_Between_Id_unit_left : Adjunct_Between_Compose adj (Adjunct_Between_Id C) = adj. Proof. destruct adj as [[F G] adjb]. set (W := (Functor_id_unit_left _ _ (fst (F, G)))). set (W' := (Functor_id_unit_right _ _ (snd (F, G)))). match type of W with ?A = ?B => match type of W' with ?A' = ?B' => match goal with [|- ?X = ?Z] => set (H := match W in _ = Y return (A, _) = (Y, _) with eq_refl => match W' in _ = Y return (_, A') = (_, Y) with eq_refl => eq_refl (A, A') end end : projT1 X = projT1 Z) end end end. apply (sigT_eq_simplify _ _ H). match type of (@Adjunct_Id_unit_left _ _ _ _ adjb) with ?A = ?B => transitivity A; [|apply (@Adjunct_Id_unit_left _ _ _ _ adjb)] end. unfold W, W' in H; clear W W'; unfold H; clear H. cbn. destruct (Functor_id_unit_left _ _ F). destruct (Functor_id_unit_right _ _ G). trivial. Qed.End Adjunct_Between_Id_unit_left.Section Adjunct_Between_Id_unit_right. Context {B C: Category} (adj : Adjunct_Between B C). Theorem Adjunct_Between_Id_unit_right : Adjunct_Between_Compose (Adjunct_Between_Id B) adj = adj. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. Admitted. Theorem leb_refl : forall n:nat, true = leb n n. Admitted. Theorem zero_nbeq_S : forall n:nat, beq_nat 0 (S n) = false. Admitted. Theorem andb_false_r : forall b : bool, andb b false = false. Admitted. Derive ArbitrarySizedSuchThat for (fun m => le n m). Derive SizeMonotonicSuchThatOpt for (fun m => le n m). Derive GenSizedSuchThatSizeMonotonicOpt for (fun m => le n m). Derive SizedProofEqs for (fun m => le n m). Derive GenSizedSuchThatCorrect for (fun m => le n m).Theorem plus_ble_compat_l : forall n m p : nat, leb n m = true -> leb (p + n) (p + m) = true. Admitted.Theorem S_nbeq_0 : forall n:nat, beq_nat (S n) 0 = false. Admitted. Theorem mult_1_l : forall n:nat, 1 * n = n. 
(n:=n) a (b:=b) nZb)); [ intros tmp; case tmp; clear tmp | idtac ]; intros H'2; auto. apply ltT_not_ltT; auto. apply ltT_eqTl with (a := multTerm (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b); auto. apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA); auto. apply ltT_eqTr with (a := multTerm (A:=A) multA (n:=n) (T1 A1 n) b); auto. apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA); apply T1_multTerm_l with (1 := cs); auto. apply multTerm_ltT_r with (1 := os); auto. elim (T1_is_min_ltT A A1) with (a := divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) (1 := os); auto. apply ltT_not_eqT; auto. apply (eqT_trans A n) with (y := multTerm (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b); auto. apply (eqTerm_imp_eqT A eqA); auto. apply (eqT_trans A n) with (y := multTerm (A:=A) multA (n:=n) (T1 A1 n) b); auto. apply (eqT_sym A n); auto. apply (eqT_sym A n); apply (eqTerm_imp_eqT A eqA); auto. Qed. Hint Resolve divP_is_not_order. Theorem divP_ltT_comp : forall (a b : Term A n) (p : list (Term A n)), canonical A0 eqA ltM (pX b p) -> divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX a p). intros a b p; case p; auto. intros H' H'0. change (canonical A0 eqA ltM (pX a (pO A n))) in |- *; apply canonicalp1; auto. apply divP_inv1 with (1 := H'0); auto. intros a0 l H' H'0; change (canonical A0 eqA ltM (pX a (pX a0 l))) in |- *; apply canonical_cons; auto. case (ltT_dec A n ltM ltM_dec a b); [ intros tmp; case tmp; clear tmp | idtac ]; intros H'2; auto. elim (divP_is_not_order a b); auto. apply (ltT_trans A _ _ os) with (y := b); auto. apply (canonical_pX_order _ A0 eqA) with (l := l); auto. apply eqT_compat_ltTr with (b := b); auto. apply (eqT_sym A n); auto. apply (canonical_pX_order _ A0 eqA) with (l := l); auto. apply divP_inv1 with (1 := H'0); auto. apply canonical_imp_canonical with (a := b); auto. Qed. Definition spminusf (a b : Term A n) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q : list (Term A n)) := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) q). Theorem sp_rew : forall (a b : Term A n) (nZ1 nZ2 : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q : list (Term A n)), spminusf a b nZ1 p q = spminusf a b nZ2 p q. 
destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. right. intro Hc. apply Hnin. inv Hc. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. assert (Hn := Decidable_name_in_fundefs f). destruct Hn as [Decf]. destruct (Decf x); eauto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. assert (Hf := Decidable_name_in_fundefs_ctx f). destruct Hf as [Decf]. destruct (Decf x); eauto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. destruct (in_dec var_dec x l); auto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. Qed. Lemma bound_stem_fundefs_ctx_dec: (forall c, Decidable (bound_stem_fundefs_ctx c)). Proof. eapply ctx_fundefs_mut' with (P := fun c => Decidable (bound_stem_ctx c)); split; intro x. - right; intro; inv H. - destruct H as [Dec]; destruct (Dec x); auto. destruct (var_dec v x); subst; auto. right; intro Hbv; inv Hbv; auto. - destruct H as [Dec]; destruct (Dec x); auto. destruct (var_dec v x); subst; auto. right; intro Hbv; inv Hbv; auto. - destruct H as [Dec]; destruct (Dec x); auto. destruct (var_dec v x); subst; auto. right; intro Hbv; inv Hbv; auto. - destruct H as [Dec]; destruct (Dec x); auto. destruct (var_dec v x); subst; auto. right; intro Hbv; inv Hbv; auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. right. intro Hc. apply Hnin. inv Hc. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. assert (Hn := Decidable_name_in_fundefs f). destruct Hn as [Decf]. destruct (Decf x); eauto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. assert (Hf := Decidable_name_in_fundefs_ctx f). destruct Hf as [Decf]. destruct (Decf x); eauto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. destruct (in_dec var_dec x l); auto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. auto. - destruct H as [Dec]; destruct (Dec x) as [Hin | Hnin]; auto. right. intro Hc. apply Hnin. inv Hc. exfalso; auto. Qed. Theorem bound_stem_comp_ctx_mut: forall c', (forall c, (bound_stem_ctx c :|: bound_stem_ctx c') <--> (bound_stem_ctx (comp_ctx_f c c'))) /\ (forall fc, (bound_stem_fundefs_ctx fc :|: bound_stem_ctx c') <--> (bound_stem_fundefs_ctx (comp_f_ctx_f fc c'))). 
Require Import missing. Require Import division. Require Import gcd. Require Import primes. Require Import power.Unset Standard Proposition Elimination Names. Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)). intros. intro. assert (divides a p). apply prime_square;trivial. exists (k*(square b)). rewrite <- H2;ring. elim H3;intro n_a;intro. rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2. assert (k*(b*b)=p*(n_a*n_a)). apply mult_lemma6 with p. intro H5;rewrite H5 in H;apply not_prime_zero;trivial. rewrite mult_assoc;rewrite H2;ring. assert (divides b p). apply prime_square;trivial;unfold square. apply gauss with k. apply rel_prime_sym;trivial. exists (n_a*n_a);trivial. assert (p=1). unfold rel_prime in H1. elim H1;intros. apply divides_antisym;try (apply one_min_div). apply H8;red;tauto. elim H;tauto. Qed. Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)). 
@lsubst_aux_sub_filter. rw <- Xsf1eta. rw @lsubst_aux_sub_filter. apply alpha_eq3_sym. unfold var_ren in XX;sp. * introv Hin. apply free_vars_lsubst_aux2 in Hin. simpl_sub. dorn Hin;exrepnd; auto;[]. apply in_var_ren in Hin0. exrepnd. subst. allsimpl. dorn Hin1;subst;try(sp;fail);[]. apply Hfresh10;sp. unfold disjoint_bv_sub. rw @disjoint_sub_as_flat_map. spcls. disjoint_reasoningv. * introv Hin. apply free_vars_lsubst_aux2 in Hin. simpl_sub. dorn Hin;exrepnd; auto;[]. apply in_var_ren in Hin0. exrepnd. subst. allsimpl. dorn Hin1;subst;try(sp;fail);[]. apply Hfresh2;sp. unfold disjoint_bv_sub. rw @disjoint_sub_as_flat_map. spcls. disjoint_reasoningv. Qed.Theorem lsubst_alpha3_congr_auxp {p} : forall t1 t2 lvi lnt1 lnt2, @alpha_eq3 p [] t1 t2 -> length lvi = length lnt1 -> length lvi = length lnt2 -> disjoint (flat_map free_vars lnt1) (bound_vars t1) -> disjoint (flat_map free_vars lnt2) (bound_vars t2) -> bin_rel_nterm (alpha_eq3 [] ) lnt1 lnt2 -> alpha_eq3 [] (lsubst_aux t1 (combine lvi lnt1)) (lsubst_aux t2 (combine lvi lnt2)). Proof. nterm_ind1s t1 as [v1| f1 ind1 | o1 lbt1 Hind] Case; introv Hal H1len H2len H1dis H2dis Hall; inverts Hal as Hlen Hal. - Case "vterm". simpl. destructrn (sub_find (combine lvi lnt1) v1) as [s1s|n1n] H1sn; destructrn (sub_find (combine lvi lnt2) v1) as [s2s|n2n] H2sn; allsimpl;sp. + symmetry in HeqH2sn. symmetry in HeqH1sn. eapply sub_find_some2_first in HeqH1sn; eauto. exrepnd. repnud Hall. repnud Hall. assert(n < length lnt1) as Hlt by congruence. pose proof (Hall _ Hlt). rewrite nth_indep with (d' := default_nterm) in HeqH1sn0; try(congruence). rewrite nth_indep with (d' := default_nterm) in HeqH1sn4; try(congruence). + provefalse. symmetry in HeqH1sn. eapply sub_find_some_none_contra in HeqH1sn ; eauto. + provefalse. symmetry in HeqH2sn. eapply @sub_find_some_none_contra with(lnt2:=lnt1) in HeqH2sn; eauto. - Case "sterm". simpl; auto. - Case "oterm". simpl. constructor; repeat(rewrite map_length); auto. introv Hlt. rewrite selectbt_map; auto. duplicate Hlt. rewrite Hlen in Hlt0. rewrite selectbt_map; auto. fold @lsubst_bterm_aux. applydup Hal in Hlt. clear Hal. pose proof (selectbt_in2 n lbt1 Hlt) as [bt99 pp]. exrepnd. destruct bt99 as [blv1 bnt1]. rewrite pp. rewrite pp in Hlt1. pose proof (selectbt_in2 n lbt2 Hlt0) as [bt99 p2p]. exrepnd. destruct bt99 as [blv2 bnt2]. rewrite p2p. rewrite p2p in Hlt1. eapply (@disjoint_lbt_bt2 p) in H1dis; eauto. repnd. eapply (@disjoint_lbt_bt2 p) in H2dis; eauto. repnd. apply lsubst_alphabt3_congr_auxp_osize; allsimpl; spc; disjoint_reasoningv;[]. introv. intros. eapply Hind with (nt:=bnt1); eauto. Qed. Lemma bin_rel_list_le: forall {T} (R1 R2: bin_rel T) (def:T), (le_bin_rel R1 R2) -> le_bin_rel (binrel_list def R1) (binrel_list def R2). Proof. introv HR. intros la lb Hb1. repnud Hb1. split; sp. Qed.Lemma alpha3_le {p} : forall lv, le_bin_rel alpha_eq (@alpha_eq3 p lv). Proof. introv. unfold le_bin_rel. intros. apply alpha_eq3_if;sp. Qed. Theorem lsubst_aux_alpha_congr {p} : forall t1 t2 lvi lnt1 lnt2, @alpha_eq p t1 t2 -> length lvi = length lnt1 -> length lvi = length lnt2 -> disjoint (flat_map free_vars lnt1) (bound_vars t1) -> disjoint (flat_map free_vars lnt2) (bound_vars t2) -> bin_rel_nterm alpha_eq lnt1 lnt2 -> alpha_eq (lsubst_aux t1 (combine lvi lnt1)) (lsubst_aux t2 (combine lvi lnt2)). 
(maxIndex (log st') = maxIndex (log st) /\ matchIndex st' = matchIndex st) \/ matchIndex st' = assoc_set name_eq_dec (matchIndex st) h (maxIndex (log st')) /\ maxIndex (log st') = S (maxIndex (log st)). Proof using. unfold handleClientRequest. intros. repeat break_match; repeat find_inversion; auto. Qed. Lemma tryToBecomeLeader_matchIndex_preserved : forall n st out st' ms, tryToBecomeLeader n st = (out, st', ms) -> matchIndex_preserved st st'. Proof using. unfold tryToBecomeLeader. intros. find_inversion. simpl; intros; auto; congruence. Qed. Lemma handleRequestVote_matchIndex_preserved : forall n st t c li lt st' ms, handleRequestVote n st t c li lt = (st', ms) -> matchIndex_preserved st st'. Proof using. unfold handleRequestVote, advanceCurrentTerm. intros. repeat (break_match; try discriminate; repeat (find_inversion; simpl in *)); auto. Qed. Lemma doGenericServer_matchIndex_preserved : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> matchIndex_preserved st st'. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleRequestVoteReply_matchIndex : forall n st src t v, type (handleRequestVoteReply n st src t v) = Leader -> (type st = Leader /\ matchIndex (handleRequestVoteReply n st src t v) = matchIndex st) \/ (assoc_default name_eq_dec (matchIndex (handleRequestVoteReply n st src t v)) n 0 = maxIndex (log (handleRequestVoteReply n st src t v))). Proof using. unfold handleRequestVoteReply. intros. repeat break_match; simpl; auto using advanceCurrentTerm_matchIndex_preserved; simpl in *; try congruence. unfold assoc_default. simpl. repeat break_match; simpl in *; try congruence; find_inversion; auto. Qed. Lemma doLeader_matchIndex_preserved : forall st h os st' ms, doLeader st h = (os, st', ms) -> matchIndex_preserved st st'. Proof using. intros. unfold doLeader in *. simpl; intros. repeat break_match; find_inversion; auto; congruence. Qed. Lemma doLeader_lastApplied : forall st h os st' ms, doLeader st h = (os, st', ms) -> lastApplied st' = lastApplied st. Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; auto. Qed. Lemma handleRequestVote_no_append_entries : forall st h h' t lli llt st' m, handleRequestVote h st t h' lli llt = (st', m) -> ~ is_append_entries m. Proof using. intros. unfold handleRequestVote, advanceCurrentTerm in *. repeat break_match; find_inversion; subst; auto; intuition; break_exists; congruence. Qed. Theorem handleClientRequest_no_append_entries : forall h st client id c out st' ps m, handleClientRequest h st client id c = (out, st', ps) -> In m ps -> ~ is_append_entries (snd m). Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; subst; auto; intuition; break_exists; congruence. Qed. Theorem handleClientRequest_packets : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> ps = []. 
map_map in H. do 2 rewrite mm2_mma_mm2_state in H. eq goal H; do 2 f_equal. rewrite <- (map_id P) at 2. apply map_ext, mm2_mma_mm2_instr. Qed. Local Fact mma_mm2_terminates_zero_equiv P s : (1,P) /A/ s ‚Ü (0,vec_zero) <-> map mma_mm2_instr P /2/ mma_mm2_state s ‚Ü (0,(0,0)). Proof. apply mma_mm2_compute_equiv. Qed. Fact mma_mm2_terminates P s : (1,P) /A/ s ‚Üì -> map mma_mm2_instr P /2/ mma_mm2_state s ‚Üì. Proof. intros (y & H1 & H2). exists (mma_mm2_state y); split. + apply mma_mm2_compute_equiv; auto. + intros z H. rewrite <- (mma_mm2_mma_state z) in H. rewrite <- mma_mm2_step_equiv in H. revert H. apply sss_out_step_stall with (1 := H2). Qed. Fact mm2_mma_terminates P s : P /2/ s ‚Üì -> (1,map mm2_mma_instr P) /A/ mm2_mma_state s ‚Üì. Proof. intros (y & H1 & H2). exists (mm2_mma_state y); split. + apply mm2_mma_compute; auto. + destruct y as (i,(a,b)); simpl fst. red in H2. destruct (in_out_code_dec i (1, map mm2_mma_instr P)) as [ H3 | ] ; auto. destruct in_code_subcode with (1 := H3) as (rho & H4); exfalso; revert H4. rewrite <- (mm2_mma_mm2_instr rho). generalize (mma_mm2_instr rho); clear rho; intros rho. intros H4. destruct (mma_sss_total (mm2_mma_instr rho) (i,a##b##vec_nil)) as (w & Hw). apply mma_mm2_atom in Hw. apply (H2 (mma_mm2_state w)). rewrite mma_mm2_mma_instr in Hw. exists rho; split; auto; simpl. destruct H4 as (l & r & H4 & H5). exists (map mma_mm2_instr l), (map mma_mm2_instr r); split; rew length; try lia. apply f_equal with (f := map mma_mm2_instr) in H4. rewrite map_map, map_app in H4; simpl in H4. rewrite mma_mm2_mma_instr in H4. rewrite <- H4, <- (map_id P) at 1. apply map_ext; intros; rewrite mma_mm2_mma_instr; auto. Qed. Theorem mma_mma2_reduction P s : (1,P) /A/ s ‚Üì <-> map mma_mm2_instr P /2/ mma_mm2_state s ‚Üì. Proof. split. + apply mma_mm2_terminates. + intros H. apply mm2_mma_terminates in H. rewrite map_map, mm2_mma_mm2_state in H. eq goal H; do 2 f_equal. rewrite <- (map_id P) at 2. apply map_ext, mm2_mma_mm2_instr. Qed. Theorem mma_mma2_zero_reduction P s : (1,P) /A/ s ~~> (0,vec_zero) <-> map mma_mm2_instr P /2/ mma_mm2_state s ‚Ü (0,(0,0)). Proof. rewrite <- mma_mm2_terminates_zero_equiv; split. + intros []; auto. + intros H; split; auto; simpl; lia. Qed.End MMA2_to_MM2.Section MMA2_MM2. Let f : MMA2_PROBLEM -> MM2_PROBLEM. Proof. intros (P & v). exact (map mma_mm2_instr P, vec_pos v pos0, vec_pos v pos1). Defined. Theorem MMA2_MM2_HALTING : MMA2_HALTING ‚™Ø MM2_HALTING. Proof. exists f. intros (P & v); simpl; unfold MMA2_HALTING. apply mma_mma2_reduction. Qed. Theorem MMA2_MM2_HALTS_ON_ZERO : MMA2_HALTS_ON_ZERO ‚™Ø MM2_HALTS_ON_ZERO. 
rel_dec _ _ _ !x !y.Class RelDec_Correct T (equ : T -> T -> Prop) (ED : RelDec equ) : Prop := { rel_dec_correct : forall x y : T, rel_dec x y = true <-> equ x y }.Notation "a ?[ r ] b" := (@rel_dec _ r _ a b) (at level 30, b at next level).Definition eq_dec {T : Type} {ED : RelDec (@eq T)} := rel_dec.Section neg_rel_dec_correct. Context {T} {R:T -> T -> Prop} {RD:RelDec R} {RDC:RelDec_Correct RD}. Definition neg_rel_dec_correct : forall {x y}, ~R x y <-> rel_dec x y = false. Proof. intros x y. destruct (bool_dec (rel_dec x y) true) ; constructor ; intros ; repeat match goal with | [ |- ~ _ ] => unfold not ; intros | [ H1 : ?P, H2 : ~?P |- _ ] => specialize (H2 H1) ; contradiction | [ H1 : ?P = true, H2 : ?P = false |- _ ] => rewrite H1 in H2 ; discriminate | [ H1 : ?P <> true |- ?P = false ] => apply not_true_is_false ; exact H1 | [ H1 : ?rel_dec ?a ?b = true, H2 : ~?R ?a ?b |- _ ] => apply rel_dec_correct in H1 | [ H1 : ?rel_dec ?a ?b = false, H2 : ?R ?a ?b |- _ ] => apply rel_dec_correct in H2 end. Qed. End neg_rel_dec_correct.Section rel_dec_p. Context {T} {R:T -> T -> Prop} {RD:RelDec R} {RDC:RelDec_Correct RD}. Definition rel_dec_p (x:T) (y:T) : {R x y} + {~R x y}. Proof. destruct (bool_dec (rel_dec x y) true) as [H | H]. apply rel_dec_correct in H ; eauto. apply not_true_is_false in H ; apply neg_rel_dec_correct in H ; eauto. Qed. Definition neg_rel_dec_p (x:T) (y:T) : {~R x y} + {R x y}. Proof. destruct (rel_dec_p x y) ; [ right | left ] ; auto. Qed. End rel_dec_p.Section lemmas. Variable T : Type. Variable eqt : T -> T -> Prop. Variable r : RelDec eqt. Variable rc : RelDec_Correct r. Theorem rel_dec_eq_true : forall x y, eqt x y -> rel_dec x y = true. Proof. intros. eapply rel_dec_correct in H. assumption. Qed. Theorem rel_dec_neq_false : forall x y, ~eqt x y -> rel_dec x y = false. Proof. intros. remember (x ?[ eqt ] y). symmetry in Heqb. destruct b; try reflexivity. exfalso. eapply (@rel_dec_correct _ _ _ rc) in Heqb. auto. Qed. Theorem rel_dec_sym : Symmetric eqt -> forall x y, x ?[ eqt ] y = y ?[ eqt ] x. 
RIneq.Rle_not_lt. apply round_DN_pt... now apply Rlt_le. Qed.Theorem pred_UP_le_DN : forall x, (pred (round beta fexp Zceil x) <= round beta fexp Zfloor x)%R. Proof with auto with typeclass_instances. intros x. destruct (generic_format_EM beta fexp x) as [Fx|Fx]. rewrite !round_generic... apply pred_le_id. case (Req_dec (round beta fexp Zceil x) 0); intros Zx. rewrite Zx; unfold pred; rewrite Ropp_0. unfold succ; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l; unfold ulp; rewrite Req_bool_true; trivial. case negligible_exp_spec'. intros (H1,H2). contradict Zx; apply round_neq_0_negligible_exp... intros L; apply Fx; rewrite L; apply generic_format_0. intros (n,(H1,Hn)); rewrite H1. case (Rle_or_lt (- bpow (fexp n)) (round beta fexp Zfloor x)); trivial; intros K. absurd (round beta fexp Zceil x <= - bpow (fexp n))%R. apply Rlt_not_le. rewrite Zx, <- Ropp_0. apply Ropp_lt_contravar, bpow_gt_0. apply round_UP_le_gt_DN; try assumption. apply generic_format_opp, generic_format_bpow. now apply valid_exp. assert (let u := round beta fexp Zceil x in pred u < u)%R as Hup. now apply pred_lt_id. apply le_round_DN_lt_UP... apply generic_format_pred... now apply round_UP_pt. Qed.Theorem pred_UP_eq_DN : forall x, ~ F x -> (pred (round beta fexp Zceil x) = round beta fexp Zfloor x)%R. Proof with auto with typeclass_instances. intros x Fx. apply Rle_antisym. now apply pred_UP_le_DN. apply le_pred_lt; try apply generic_format_round... pose proof round_DN_UP_lt _ _ _ Fx as HE. now apply Rlt_trans with (1 := proj1 HE) (2 := proj2 HE). Qed.Theorem succ_DN_eq_UP : forall x, ~ F x -> (succ (round beta fexp Zfloor x) = round beta fexp Zceil x)%R. Proof with auto with typeclass_instances. intros x Fx. rewrite <- pred_UP_eq_DN; trivial. rewrite succ_pred; trivial. apply generic_format_round... Qed.Theorem round_DN_eq_betw: forall x d, F d -> (d <= x < succ d)%R -> round beta fexp Zfloor x = d. Proof with auto with typeclass_instances. intros x d Fd (Hxd1,Hxd2). generalize (round_DN_pt beta fexp x); intros (T1,(T2,T3)). apply sym_eq, Rle_antisym. now apply T3. destruct (generic_format_EM beta fexp x) as [Fx|NFx]. rewrite round_generic... apply succ_le_inv; try assumption. apply succ_le_lt; try assumption. apply generic_format_succ... apply succ_le_inv; try assumption. rewrite succ_DN_eq_UP; trivial. apply round_UP_pt... apply generic_format_succ... now left. Qed. Theorem round_UP_eq_betw: forall x u, F u -> (pred u < x <= u)%R -> round beta fexp Zceil x = u. Proof with auto with typeclass_instances. intros x u Fu Hux. rewrite <- (Ropp_involutive (round beta fexp Zceil x)). rewrite <- round_DN_opp. rewrite <- (Ropp_involutive u). apply f_equal. apply round_DN_eq_betw; try assumption. now apply generic_format_opp. split;[now apply Ropp_le_contravar|idtac]. rewrite succ_opp. now apply Ropp_lt_contravar. Qed. Theorem round_N_le_midp: forall choice u v, F u -> (v < (u + succ u)/2)%R -> (round beta fexp (Znearest choice) v <= u)%R. 
(x = x'). Proof. intros. apply isdecpropif. - apply isaproppathsfromisolated. assumption. - apply (is x'). Defined.Lemma isdecproppathstoisolated (X : UU) (x : X) (is : isisolated X x) (x' : X) : isdecprop (x' = x). Proof. intros. apply (isdecpropweqf (weqpathsinv0 x x') (isdecproppathsfromisolated X x is x')). Defined. Definition isdecincl {X Y : UU} (f : X -> Y) := ‚àè y : Y, isdecprop (hfiber f y). Lemma isdecincltoisincl {X Y : UU} (f : X -> Y) : isdecincl f -> isincl f. Proof. intros is y. apply (isdecproptoisaprop _ (is y)). Defined. Coercion isdecincltoisincl : isdecincl >-> isincl.Lemma isdecinclfromisweq {X Y : UU} (f : X -> Y) : isweq f -> isdecincl f. Proof. intros iswf. intro y. apply (isdecpropfromiscontr (iswf y)). Defined.Lemma isdecpropfromdecincl {X Y : UU} (f : X -> Y) : isdecincl f -> isdecprop Y -> isdecprop X. Proof. intros isf isy. induction (pr1 isy) as [ y | n ]. - assert (w : weq (hfiber f y) X) by apply (weqhfibertocontr f y (iscontraprop1 (isdecproptoisaprop _ isy) y)). apply (isdecpropweqf w (isf y)). - apply isdecpropif. apply (isapropinclb _ isf isy). apply (ii2 (negf f n)). Defined. Lemma isdecinclii1 (X Y : UU) : isdecincl (@ii1 X Y). Proof. intros. intro y. induction y as [ x | y ]. - apply (isdecpropif _ (isinclii1 X Y (ii1 x)) (ii1 (make_hfiber (@ii1 _ _) x (idpath _)))). - apply (isdecpropif _ (isinclii1 X Y (ii2 y)) (ii2 (neghfiberii1y X Y y))). Defined. Lemma isdecinclii2 (X Y : UU) : isdecincl (@ii2 X Y). Proof. intros. intro y. induction y as [ x | y ]. - apply (isdecpropif _ (isinclii2 X Y (ii1 x)) (ii2 (neghfiberii2x X Y x))). - apply (isdecpropif _ (isinclii2 X Y (ii2 y)) (ii1 (make_hfiber (@ii2 _ _) y (idpath _)))). Defined. Lemma isdecinclpr1 {X : UU} (P : X -> UU) (is : ‚àè x : X, isdecprop (P x)) : isdecincl (@pr1 _ P). Proof. intros. intro x. assert (w : weq (P x) (hfiber (@pr1 _ P) x)) by apply ezweqpr1. apply (isdecpropweqf w (is x)). Defined. Theorem isdecinclhomot {X Y : UU} (f g : X -> Y) (h : ‚àè x : X, paths (f x) (g x)) (is : isdecincl f) : isdecincl g. Proof. intros. intro y. apply (isdecpropweqf (weqhfibershomot f g h y) (is y)). Defined. Theorem isdecinclcomp {X Y Z : UU} (f : X -> Y) (g : Y -> Z) (isf : isdecincl f) (isg : isdecincl g) : isdecincl (Œª x : X, g (f x)). 
forall s, cardinal s = 0 -> Empty s. Proof. intros; rewrite cardinal_Empty; auto. Qed. Hint Resolve cardinal_inv_1. Lemma cardinal_inv_2 : forall s n, cardinal s = S n -> { x : elt | In x s }. Proof. intros; rewrite M.cardinal_1 in H. generalize (elements_2 (s:=s)). destruct (elements s); try discriminate. exists e; auto. Qed. Lemma cardinal_inv_2b : forall s, cardinal s <> 0 -> { x : elt | In x s }. Proof. intro; generalize (@cardinal_inv_2 s); destruct cardinal; [intuition|eauto]. Qed. Lemma Equal_cardinal : forall s s', s[=]s' -> cardinal s = cardinal s'. Proof. symmetry. remember (cardinal s) as n; symmetry in Heqn; revert s s' Heqn H. induction n; intros. apply cardinal_1; rewrite <- H; auto. destruct (cardinal_inv_2 Heqn) as (x,H2). revert Heqn. rewrite (cardinal_2 (s:=remove x s) (s':=s) (x:=x)); auto with set. rewrite (cardinal_2 (s:=remove x s') (s':=s') (x:=x)); eauto with set. Qed. Add Morphism cardinal with signature (Equal ==> Logic.eq) as cardinal_m. Proof. exact Equal_cardinal. Qed. Hint Resolve Add_add Add_remove Equal_remove cardinal_inv_1 Equal_cardinal. Lemma empty_cardinal : cardinal empty = 0. Proof. rewrite cardinal_fold; apply fold_1; auto with set. Qed. Hint Immediate empty_cardinal cardinal_1 : set. Lemma singleton_cardinal : forall x, cardinal (singleton x) = 1. Proof. intros. rewrite (singleton_equal_add x). replace 0 with (cardinal empty); auto with set. apply cardinal_2 with x; auto with set. Qed. Hint Resolve singleton_cardinal: set. Lemma diff_inter_cardinal : forall s s', cardinal (diff s s') + cardinal (inter s s') = cardinal s . Proof. intros; do 3 rewrite cardinal_fold. rewrite <- fold_plus. apply fold_diff_inter with (eqA:=@Logic.eq nat); auto. Qed. Lemma union_cardinal: forall s s', (forall x, ~(In x s/\In x s')) -> cardinal (union s s')=cardinal s+cardinal s'. Proof. intros; do 3 rewrite cardinal_fold. rewrite <- fold_plus. apply fold_union; auto. Qed. Lemma subset_cardinal : forall s s', s[<=]s' -> cardinal s <= cardinal s' . Proof. intros. rewrite <- (diff_inter_cardinal s' s). rewrite (inter_sym s' s). rewrite (inter_subset_equal H); auto with arith. Qed. Lemma subset_cardinal_lt : forall s s' x, s[<=]s' -> In x s' -> ~In x s -> cardinal s < cardinal s'. Proof. intros. rewrite <- (diff_inter_cardinal s' s). rewrite (inter_sym s' s). rewrite (inter_subset_equal H). generalize (@cardinal_inv_1 (diff s' s)). destruct (cardinal (diff s' s)). intro H2; destruct (H2 Logic.eq_refl x). set_iff; auto. intros _. change (0 + cardinal s < S n + cardinal s). apply Plus.plus_lt_le_compat; auto with arith. Qed. Theorem union_inter_cardinal : forall s s', cardinal (union s s') + cardinal (inter s s') = cardinal s + cardinal s' . 
try (rewrite sem_undef; auto). rewrite sem_eq. destruct (Int.eq (Int.and i n1) Int.zero); auto. TrivialExists. simpl. rewrite sem_default. auto. destruct (Int.eq_dec n2 Int.zero). InvEval; subst. econstructor; split. EvalOp. simpl; eauto. destruct v1; simpl; try (rewrite sem_undef; auto). rewrite sem_ne. destruct (Int.eq (Int.and i n1) Int.zero); auto. TrivialExists. simpl. rewrite sem_default. auto. TrivialExists. simpl. rewrite sem_default. auto. Qed.Hypothesis sem_swap: forall c x y, sem (swap_comparison c) x y = sem c y x.Lemma eval_compimm_swap: forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\ Val.lessdef (sem c (Vint n2) x) v. Proof. intros. rewrite <- sem_swap. eapply eval_compimm; eauto. Qed.End COMP_IMM.Theorem eval_comp: forall c, binary_constructor_sound (comp c) (Val.cmp c). Proof. intros; red; intros until y. unfold comp; case (comp_match a b); intros; InvEval. eapply eval_compimm_swap; eauto. intros. unfold Val.cmp. rewrite Val.swap_cmp_bool; auto. eapply eval_compimm; eauto. TrivialExists. Qed.Theorem eval_compu: forall c, binary_constructor_sound (compu c) (Val.cmpu (Mem.valid_pointer m) c). Proof. intros; red; intros until y. unfold compu; case (compu_match a b); intros; InvEval. eapply eval_compimm_swap; eauto. intros. unfold Val.cmpu. rewrite Val.swap_cmpu_bool; auto. eapply eval_compimm; eauto. TrivialExists. Qed.Theorem eval_compf: forall c, binary_constructor_sound (compf c) (Val.cmpf c). Proof. intros; red; intros. unfold compf. TrivialExists. Qed.Theorem eval_compfs: forall c, binary_constructor_sound (compfs c) (Val.cmpfs c). Proof. intros; red; intros. unfold compfs. replace (Val.cmpfs c x y) with (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y)). TrivialExists. constructor. EvalOp. simpl; reflexivity. constructor. EvalOp. simpl; reflexivity. constructor. auto. destruct x; auto. destruct y; auto. unfold Val.cmpf, Val.cmpfs; simpl. rewrite Float32.cmp_double. auto. Qed.Theorem eval_cast8signed: unary_constructor_sound cast8signed (Val.sign_ext 8). Proof. red; intros until x. unfold cast8signed. destruct (cast8signed_match a); intros. InvEval; TrivialExists. TrivialExists. Qed.Theorem eval_cast8unsigned: unary_constructor_sound cast8unsigned (Val.zero_ext 8). Proof. red; intros. unfold cast8unsigned. rewrite Val.zero_ext_and. apply eval_andimm; auto. lia. Qed.Theorem eval_cast16signed: unary_constructor_sound cast16signed (Val.sign_ext 16). Proof. red; intros until x. unfold cast16signed. destruct (cast16signed_match a); intros. InvEval; TrivialExists. TrivialExists. Qed.Theorem eval_cast16unsigned: unary_constructor_sound cast16unsigned (Val.zero_ext 16). Proof. red; intros. unfold cast16unsigned. rewrite Val.zero_ext_and. apply eval_andimm; auto. lia. Qed.Theorem eval_singleoffloat: unary_constructor_sound singleoffloat Val.singleoffloat. Proof. red; intros. unfold singleoffloat. TrivialExists. Qed.Theorem eval_floatofsingle: unary_constructor_sound floatofsingle Val.floatofsingle. Proof. red; intros. unfold floatofsingle. TrivialExists. Qed.Theorem eval_intoffloat: forall le a x y, eval_expr ge sp e m le a x -> Val.intoffloat x = Some y -> exists v, eval_expr ge sp e m le (intoffloat a) v /\ Val.lessdef y v. Proof. intros; unfold intoffloat. TrivialExists. Qed. Theorem eval_intuoffloat: forall le a x y, eval_expr ge sp e m le a x -> Val.intuoffloat x = Some y -> exists v, eval_expr ge sp e m le (intuoffloat a) v /\ Val.lessdef y v. 
l)). replace lxs with (lxs ++ []). by apply fromDList_Denotes. by rewrite app_nil_r. done. Qed.Theorem reify_P {A} (dxs : DList A) (lxs : list A) (P : list A -> Prop) : Denotes dxs lxs -> P lxs -> P (reify dxs). Proof. intros. apply Denotes_reify in H. by rewrite H. Qed.Theorem reify_Denotes {A} (dxs : DList A) (lxs : list A) : WF dxs -> reify dxs = lxs -> Denotes dxs lxs. Proof. intros. rewrite -H0. inversion H. eapply reify_P. apply H1. done. Qed.Notation "x 'in' y" := (In x (reify y)) (at level 61). Notation "x =l y" := (reify x = reify y) (at level 62). Notation "'len' x" := (Datatypes.length (reify x)) (at level 61).Theorem append_singletons {A} (x y : A) : toList (append (singleton x) (singleton y)) = [x; y]. Proof. done. Qed.Theorem toList_cons_ {A} (x : A) (dxs : DList A) : toList (cons_ x dxs) = x :: toList dxs. Proof. by move: dxs => [fxs] /=. Qed. Theorem appendA {A} : associative (@append A). Proof. by move=> [fxs] [fys] [fzs] /=. Qed.Hint Resolve empty_WF. Hint Resolve singleton_WF. Hint Resolve cons__WF. Hint Resolve append_WF.Hint Resolve reify_Denotes.Ltac apply_reify := match goal with | [ |- context[reify _]] => eapply reify_P; [match goal with | [ H: Denotes ?x _ |- Denotes ?x _ ] => apply H | [ |- Denotes empty _ ] => by apply emptyD | [ |- Denotes (singleton ?x) _ ] => by apply singletonD | [ H: Denotes ?l ?x |- Denotes (cons_ ?a ?l) _] => eapply (consD _ x a); apply H | [ |- Denotes (cons_ ?a ?l) _] => eapply (consD _ (reify l) a); eauto | [ H1: Denotes ?x _, H2: Denotes ?y _ |- Denotes (append ?x ?y) _] => eapply (appendD x _ y _); [apply H1 | apply H2 ] | [ |- Denotes (append ?x ?y) _] => eapply (appendD x (reify x) y (reify y)); [auto | auto ] end | idtac] end; try solve [auto]; try done.Ltac solve_by_reify := repeat apply_reify. Section ListTheorems. Variable A : Type. Variable x : A. Variable l r : DList A. Context {WFl : WF l} {WFr : WF r}. Theorem nil_cons : ~ ([] =l x ::: l). Proof. inversion WFl. solve_by_reify. Qed. Theorem in_eq : x in (x ::: l). Proof. inversion WFl. solve_by_reify. apply List.in_eq. Qed. Theorem app_comm_cons : x ::: (l +++ r) =l x ::: l +++ r. 
:: G) -> seq G Q | _ => True end. Proof. outerPredicative. Qed. Lemma outer_Exists : forall PG Q, seq PG Q -> forall G A p, seq G (Exists p) -> (forall (a : A) (PG0 : list PropX) (Q0 : PropX), seq PG0 Q0 -> forall G0 : list (propX nil), incl PG0 (p a :: G0) -> seq G0 (p a) -> seq G0 Q0) -> incl PG (Exists p :: G) -> seq G Q. Proof. intros; specialize (outer_Exists' H H0); eauto. Qed. Lemma outer_ForallX' : forall PG Q, seq PG Q -> forall G P, seq G P -> match P with | ForallX _ A p => incl PG (P :: G) -> seq G Q | _ => True end. Proof. outerPredicative. Qed. Lemma outer_ForallX : forall PG Q, seq PG Q -> forall G A (p : propX (A :: _)), seq G (ForallX p) -> incl PG (ForallX p :: G) -> seq G Q. Proof. intros; specialize (outer_ForallX' H H0); eauto. Qed. Lemma outer_ExistsX' : forall PG Q, seq PG Q -> forall G P, seq G P -> match P with | ExistsX _ A p => incl PG (P :: G) -> seq G Q | _ => True end. Proof. outerPredicative. Qed. Lemma outer_ExistsX : forall PG Q, seq PG Q -> forall G A (p : propX (A :: _)), seq G (ExistsX p) -> incl PG (ExistsX p :: G) -> seq G Q. Proof. intros; specialize (outer_ExistsX' H H0); eauto. Qed. Hint Immediate outer_Inj outer_Cptr outer_And outer_Or outer_Imply outer_Forall outer_Exists outer_ForallX outer_ExistsX. Lemma cut_admissibility' : forall GG (P : propX GG), match GG return propX GG -> Prop with | _ :: _ => fun _ => True | nil => fun P => forall PG Q, seq PG Q -> forall G, incl PG (P :: G) -> seq G P -> seq G Q end P. Proof. induction P; destruct G; intuition eauto. Qed. Theorem cut_admissibility : forall P G Q, seq G P -> seq (P :: G) Q -> seq G Q. Proof. intros; eapply (@cut_admissibility' nil); eauto. Qed. Hint Resolve cut_admissibility. Theorem cut_elimination : forall G P, seqP G P -> seq G P. Proof. induction 1; eauto; doLeft. Qed. Lemma seqP_complete' : forall G P, normalP G P -> seqP G P. Proof. generalize seqP_complete; firstorder. Qed. Theorem normalization : forall G P, valid G P -> normal G P. 
(ppc a b)), eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZa) a) -> eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZb) b) -> eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZppab) (ppc a b)). intros a b c; case a; case b; case c; simpl in |- *; auto. intros a0 m a1 m0 a2 m1 nZa nZb nZppab H H0; split; auto. apply divA_is_multA with (1 := cs); auto. apply ppcm_mom_is_ppcm; intuition. Qed. Theorem divTerm_ppcl : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (ppc a b) (multTerm (A:=A) multA (n:=n) (divTerm (ppc a b) nZa) a). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 nZa H; split; auto. apply divA_is_multA with (1 := cs); auto. apply ppcm_prop_l. Qed. Theorem divTerm_ppcr : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqTerm (A:=A) eqA (n:=n) (ppc a b) (multTerm (A:=A) multA (n:=n) (divTerm (ppc a b) nZb) b). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 H nZb; split; auto. apply divA_is_multA with (1 := cs); auto. apply ppcm_prop_r. Qed. Theorem ppc_nZ : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b). intros a b; case a; case b; simpl in |- *; auto. Qed. Theorem divTerm_rew : forall (a b : Term A n) (nZ1 nZ2 : ~ zeroP (A:=A) A0 eqA (n:=n) b), divTerm a nZ1 = divTerm a nZ2. intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 nZ1 nZ2. rewrite divA_rew with (1 := cs) (nZ2 := nZ2); auto. Qed. Inductive divP : Term A n -> Term A n -> Prop := divTerm_def : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b) -> divP a b. Theorem divP_inv1 : forall a b : Term A n, divP a b -> ~ zeroP (A:=A) A0 eqA (n:=n) a. 
(Same_set U). Proof. generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H'; auto. Qed. Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U). Proof. elim Same_set_equivalence; auto. Qed. Hint Resolve Same_set_reflexive. Theorem Power_set_PO : PO (Ensemble U). Proof. apply Definition_of_PO with (Power_set A) (Included U); auto. Defined. Theorem Union_minimal : forall a b X : Ensemble U, Included U a X -> Included U b X -> Included U (Union U a b) X. Proof. intros a b X H' H'0; red in |- *; (intros x H'1; elim H'1); auto. Qed. Hint Resolve Union_minimal. Theorem Intersection_maximal : forall a b X : Ensemble U, Included U X a -> Included U X b -> Included U X (Intersection U a b). Proof. auto. Qed. Theorem Union_increases_l : forall a b : Ensemble U, Included U a (Union U a b). Proof. auto. Qed. Theorem Union_increases_r : forall a b : Ensemble U, Included U b (Union U a b). Proof. auto. Qed. Theorem Intersection_decreases_l : forall a b : Ensemble U, Included U (Intersection U a b) a. Proof. intros a b; red in |- *; auto. intros x H'; elim H'; auto. Qed. Theorem Intersection_decreases_r : forall a b : Ensemble U, Included U (Intersection U a b) b. Proof. intros a b; red in |- *; auto. intros x H'; elim H'; auto. Qed. Hint Resolve Union_increases_l Union_increases_r Intersection_decreases_l Intersection_decreases_r. Theorem Empty_set_is_Bottom : Bottom (Ensemble U) Power_set_PO (Empty_set U). Proof. apply Bottom_definition; simpl in |- *; auto. Qed. Hint Resolve Empty_set_is_Bottom. Theorem Union_is_Lub : forall a b : Ensemble U, Included U a A -> Included U b A -> Lub (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Union U a b). Proof. intros a b H' H'0. apply Lub_definition; simpl in |- *. apply Upper_Bound_definition; simpl in |- *. auto. intros y H'1; elim H'1; auto. intros y H'1; elim H'1; simpl in |- *; auto. Qed. Theorem Intersection_is_Glb : forall a b : Ensemble U, Included U a A -> Included U b A -> Glb (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Intersection U a b). Proof. intros a b H' H'0. apply Glb_definition. apply Lower_Bound_definition; simpl in |- *. apply Definition_of_Power_set; auto. generalize Inclusion_is_transitive; intro IT; red in IT; apply IT with a; auto. intros y H'1; elim H'1; auto. intros y H'1; elim H'1; simpl in |- *; auto. Qed. Theorem Empty_set_zero : forall X : Ensemble U, Union U (Empty_set U) X = X. 
a b) b. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. intros a0 l a1 l0 H' H'0 H'1 H'2. apply divP_ppcr with (1 := cs); auto. apply canonical_nzeroP with (ltM := ltM) (p := l); auto. apply canonical_nzeroP with (ltM := ltM) (p := l0); auto. Qed. Theorem divp_nzeropl : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop a. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. Qed. Theorem divp_nzeropr : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop b. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. Qed. Hint Resolve pO_irreducible. Theorem reducetopO_pO : forall Q : list (poly A0 eqA ltM), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pO A n) (pO A n). intros Q; apply reducestar0; auto. apply Rstar_0; auto. Qed. Hint Resolve reducetopO_pO. Theorem zerop_red_spoly_l : forall a b : poly A0 eqA ltM, zerop a -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. intros c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto. intros a0 l c2 c3 H'; elim H'. intros a0 l c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto. intros a0 l a1 l0 c2 c3 H'; elim H'. Qed. Theorem zerop_red_spoly_r : forall a b : poly A0 eqA ltM, zerop b -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. intros c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto. intros a0 l c2 c3 H' Q; unfold red in |- *; simpl in |- *; auto. intros a0 l c2 c3 H'; elim H'. intros a0 l a1 l0 c2 c3 H'; elim H'. Qed. Theorem divP_ppc : forall a b c : poly A0 eqA ltM, divp a b -> divp a c -> divp a (ppcp b c). 
u_ro) - 1)%R /\ x = (rx * (1 + eps))%R. Proof. intros x rx (d, (Bd, Hd)). assert (H := Rabs_le_inv _ _ Bd). assert (H' := om1ds1p2u_ro_le_u_rod1pu_ro). assert (H'' := u_rod1pu_ro_le_u_ro beta prec). assert (H''' := u_ro_lt_1 beta prec prec_gt_0_). assert (Hpos := s1p2u_rom1_pos). destruct (Req_dec rx 0) as [Zfx|Nzfx]. { exists 0%R; split; [now rewrite Rabs_R0|]. rewrite Rplus_0_r, Rmult_1_r, Zfx; rewrite Zfx in Hd. destruct (Rmult_integral _ _ (sym_eq Hd)); lra. } destruct (Req_dec x 0) as [Zx|Nzx]. { now exfalso; revert Hd; rewrite Zx; rewrite Rmult_0_l. } set (d' := ((x - rx) / rx)%R). assert (Hd' : (Rabs d' <= sqrt (1 + 2 * u_ro) - 1)%R). { unfold d'; rewrite Hd. replace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra]. unfold Rdiv; rewrite Rabs_mult, Rabs_Ropp. rewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra]. apply (Rmult_le_reg_r (1 + d)); [lra|]. rewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra]. apply (Rle_trans _ _ _ Bd). apply (Rle_trans _ ((sqrt (1 + 2 * u_ro) - 1) * (1/sqrt (1 + 2 * u_ro)))); [right; field|apply Rmult_le_compat_l]; lra. } now exists d'; split; [exact Hd'|]; unfold d'; field. Qed. Theorem sqrt_error_N_FLX_round_ex : forall x, format x -> exists eps, (Rabs eps <= sqrt (1 + 2 * u_ro) - 1)%R /\ sqrt x = (round beta (FLX_exp prec) (Znearest choice) (sqrt x) * (1 + eps))%R. Proof. now intros x Fx; apply sqrt_error_N_round_ex_derive, sqrt_error_N_FLX_ex. Qed.Variable emin : Z. Hypothesis Hemin : (emin <= 2 * (1 - prec))%Z.Theorem sqrt_error_N_FLT_ex : forall x, generic_format beta (FLT_exp emin prec) x -> exists eps, (Rabs eps <= 1 - 1 / sqrt (1 + 2 * u_ro))%R /\ round beta (FLT_exp emin prec) (Znearest choice) (sqrt x) = (sqrt x * (1 + eps))%R. Proof. intros x Fx. assert (Heps := u_ro_pos). assert (Pb := om1ds1p2u_ro_pos). destruct (Rle_or_lt x 0) as [Nx|Px]. { exists 0%R; split; [now rewrite Rabs_R0|]. now rewrite (sqrt_neg x Nx), round_0, Rmult_0_l; [|apply valid_rnd_N]. } assert (Fx' := generic_format_FLX_FLT _ _ _ _ Fx). destruct (sqrt_error_N_FLX_ex _ Fx') as (d, (Bd, Hd)). exists d; split; [exact Bd|]; rewrite <-Hd; apply round_FLT_FLX. apply (Rle_trans _ (bpow (emin / 2)%Z)). { apply bpow_le, Z.div_le_lower_bound; lia. } apply (Rle_trans _ _ _ (sqrt_bpow_ge _ _)). rewrite Rabs_pos_eq; [|now apply sqrt_pos]; apply sqrt_le_1_alt. revert Fx; apply generic_format_ge_bpow; [|exact Px]. intro e; unfold FLT_exp; apply Z.le_max_r. Qed. Theorem sqrt_error_N_FLT_round_ex : forall x, generic_format beta (FLT_exp emin prec) x -> exists eps, (Rabs eps <= sqrt (1 + 2 * u_ro) - 1)%R /\ sqrt x = (round beta (FLT_exp emin prec) (Znearest choice) (sqrt x) * (1 + eps))%R. 
[ addr_dec ?A ?B ] ] => destruct (addr_dec A B); subst | [ H : match ?X with | Some _ => _ | None => _ end = _ |- _ ] => generalize dependent H; case_eq X; intros | [ H : match ?X with | Some _ => _ | None => _ end |- _ ] => generalize dependent H; case_eq X; intros | [ H : satisfies' (_ :: _) ?M _ |- _ ] => match M with | HCons _ _ => fail 1 | _ => rewrite (hlist_eta _ M) in H end | [ |- satisfies' (_ :: _) ?M _ ] => match M with | HCons _ _ => fail 1 | _ => rewrite (hlist_eta _ M) end | [ H : smem' nil |- _ ] => rewrite (hlist_nil_only _ H) in * | [ H : exists x, _ |- _ ] => destruct H | [ H : _ /\ _ |- _ ] => destruct H | [ |- _ ] => congruence | [ |- _ ] => ext end; simpl in *); eauto 10 with memory. Theorem satisfies_get : forall m m', satisfies m m' -> forall p v, smem_get p m = Some v -> mem_get m' p = Some v. Proof. unfold satisfies, smem_get, smem. induction all_addr; simp intuition. Qed. Lemma satisfies_set_not_in : forall l m sm p v, satisfies' l sm m -> ~In p l -> forall m', mem_set m p v = Some m' -> satisfies' l sm m'. Proof. induction l; try solve [ simp intuition ]. simp auto. destruct (addr_dec a p); destruct (in_dec addr_dec p l); subst; try solve [ intuition ]. split; eauto. erewrite mem_get_set_neq; eauto. split; eauto. eapply mem_set_perm; eauto. Qed. Local Hint Resolve mem_set_perm satisfies_set_not_in : memory. Theorem satisfies_set : forall sm m, satisfies sm m -> forall p v sm', smem_set p v sm = Some sm' -> exists m', mem_set m p v = Some m' /\ satisfies sm' m'. Proof. unfold satisfies, smem_set, smem_get, smem, relevant. generalize NoDup_all_addr. induction all_addr; simp auto. destruct (proj1 (mem_set_acc _ _) H2 v). rewrite H3. eexists; split; eauto. erewrite mem_get_set_eq; eauto with memory. Focus. eapply IHl in H1; eauto. destruct H1; eexists; intuition; eauto with memory. erewrite mem_get_set_neq; eauto. Focus. eapply IHl in H1; eauto. destruct H1; eexists; intuition eauto. Qed. Theorem satisfies_get_word : forall i m m', satisfies m m' -> forall p v, smem_get_word i p m = Some v -> mem_get_word addr mem footprint_w mem_get i p m' = Some v. 
y z : E, x = y -> x + z = y + z. Proof Monoid.op_intro_r op_monoid. Definition op_is_inv := Monoid.op_is_inv op_monoid. Definition has_inv_l := Monoid.has_inv_l op_monoid. Definition has_inv_r := Monoid.has_inv_r op_monoid. Definition has_inv := Monoid.has_inv op_monoid. Theorem op_inv_l_r_eq : forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z. Proof Monoid.op_inv_l_r_eq op_monoid. Theorem op_inv_sym : forall x y : E, op_is_inv x y <-> op_is_inv y x. Proof Monoid.op_inv_sym op_monoid. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. Proof fun x : E => ex_ind (fun y H => ex_ind (fun z H0 => let H1 : op_is_inv_r x y := H0 || op_is_inv_r x a @a by op_inv_l_r_eq x y H z H0 in ex_intro (fun a => op_is_inv x a) y (conj H H1)) (op_inv_r_ex x)) (op_inv_l_ex x). Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof fun x y z H => Monoid.op_cancel_l op_monoid x y z (op_inv_l_ex z) H. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof fun x y z => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z). Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof fun x => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x). Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof fun x => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x). Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Monoid.op_inv_uniq op_monoid. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof fun x => ex_ind (fun y (H : op_is_inv x y) => ex_intro (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z) y (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0)))) (op_inv_ex x). Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Monoid.op_inv_0_l op_monoid. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Monoid.op_inv_0_r op_monoid. Theorem op_inv_0 : op_is_inv 0 0. Proof Monoid.op_inv_0 op_monoid. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Monoid.op_has_inv_l_0 op_monoid. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Monoid.op_has_inv_r_0 op_monoid. Theorem op_has_inv_0 : has_inv 0. 
|- *; apply FulpLe; auto. 2: apply RoundedModeBounded with (radix := radix) (P := Closest b radix) (r := (p + q)%R); auto. 2: apply ClosestRoundedModeP with (precision := precision); auto. cut (x = 0%R :>R); [ unfold FtoRradix in |- *; intros Eq1 | idtac ]. replace (FtoR radix r) with (FtoR radix r + 0)%R; [ idtac | ring ]. rewrite <- Eq1. rewrite H'4; ring. apply (is_Fzero_rep1 radix). case (Z_zerop (Fnum x)); simpl in |- *; auto. intros H'3; Contradict Rl1. apply Rgt_not_le. red in |- *; apply Rle_lt_trans with (Rabs (FtoR radix x)). unfold FtoRradix, FtoR in |- *; simpl in |- *; auto. rewrite Rabs_mult. apply Rmult_le_compat; auto with real arith. generalize H'3; case (Fnum x); simpl in |- *; auto with real zarith. intros H'5; case H'5; auto. intros p0 H'5; rewrite Rabs_right; auto with real. replace 1%R with (INR 1); unfold IZR; repeat rewrite <- INR_IPR; auto with real arith. intros p0 H'5; rewrite Faux.Rabsolu_left1; auto. unfold IZR; rewrite Ropp_involutive. repeat rewrite <- INR_IPR; simpl; replace 1%R with (INR 1); auto with real arith. unfold IZR; repeat rewrite <- INR_IPR; replace 0%R with (- 0%nat)%R; auto with real. rewrite Rabs_right; auto with real arith. apply Rle_powerRZ; auto with real arith. auto with zarith. apply Rle_ge; cut (1 < radix)%Z; auto with float real zarith. cut (forall r : R, (2%nat * r)%R = (r + r)%R); [ intros tmp; rewrite tmp; clear tmp | intros f; simpl in |- *; ring ]. pattern (Rabs (FtoR radix x)) at 1 in |- *; replace (Rabs (FtoR radix x)) with (Rabs (FtoR radix x) + 0)%R; [ idtac | ring ]. apply Rplus_lt_compat_l; auto. case (Rabs_pos (FtoR radix x)); auto. rewrite <- Fabs_correct; auto with arith. intros H'5; Contradict H'3. cut (Fnum (Fabs x) = 0%Z). unfold Fabs in |- *; simpl in |- *; case (Fnum x); simpl in |- *; auto; intros; discriminate. change (is_Fzero (Fabs x)) in |- *. apply (is_Fzero_rep2 radix); auto with arith. Qed. Theorem plusExact1bis : forall p q r : float, Fbounded b p -> Fbounded b q -> Closest b radix (p + q) r -> r <> (p + q)%R :>R -> (Zmin (Fexp p) (Fexp q) < Fexp r)%Z. intros p0 q0 r0 H' H'0 H'1 H'2; case (Zle_or_lt (Fexp r0) (Zmin (Fexp p0) (Fexp q0))); auto. intros H'3; Contradict H'2. apply plusExact1; auto. Qed. Theorem plusExact2Aux : forall p q r : float, (0 <= p)%R -> Fcanonic radix b p -> Fbounded b q -> Closest b radix (p + q) r -> (Fexp r < Zpred (Fexp p))%Z -> r = (p + q)%R :>R. 
arith pts. apply type_prod with s1 s2; auto with arith pts. replace (Ax (subst_rec x T n)) with (subst_decl x (Ax T) n); auto with arith pts.apply wf_var with s1; auto with arith pts.apply type_conv with (subst_rec x U0 n) s; auto with arith pts. apply le_type_subst with g d e0; auto with arith pts.apply type_conv_srt with (subst_rec x U0 n); auto with arith pts. fold (subst_rec x (Srt s) n) in |- *. apply le_type_subst with g d e0; auto with arith pts. Qed. Theorem substitution : forall (e : env) (d t u U : term), typ (Ax t :: e) u U -> typ e d t -> typ e (subst d u) (subst d U). intros. unfold subst in |- *. apply typ_sub with e (Ax t) (Ax t :: e); auto with arith pts. apply typ_wf with d t; auto with arith pts. Qed. Theorem subtype_in_env : forall (e : env) (t T : term), typ e t T -> forall f : env, R_in_env ge_type e f -> wf f -> typ f t T. simple induction 1; auto with arith pts; intros. inversion_clear H1. rewrite H4. elim red_item with ge_type v x e0 f; intros; auto with arith pts. apply type_var; auto with arith pts. exists x; auto with arith pts.elim item_trunc with decl v e0 x; auto with arith pts; intros. elim H1 with x0; auto with arith pts; intros. inversion_clear H7. elim wf_sort with (1 := H5) (3 := H6); auto with arith pts; intros. apply type_conv with (lift (S v) (typ_of_decl x1)) x2; auto with arith pts. apply type_var; auto with arith pts. exists x1; auto with arith pts.apply iter_R_lift with x0; auto with arith pts. elim H9; auto with arith pts.replace (Srt x2) with (lift (S v) (Srt x2)); auto with arith pts. apply thinning_n with x0; auto with arith pts.apply type_abs with s; auto with arith pts. apply H3; auto with arith pts. Inversion_typ (H1 _ H4 H5). apply wf_var with s1; auto with arith pts.apply type_app with V; auto with arith pts.apply type_prod with s1 s2; auto with arith pts. apply H3; auto with arith pts. apply wf_var with s1; auto with arith pts.apply type_conv with U s; auto with arith pts. apply (le_type_stable ge_type e0); auto with arith pts.apply type_conv_srt with U; auto with arith pts. apply le_type_stable with ge_type e0; auto with arith pts. Qed. Theorem typ_conv_wf : forall (e : env) (t T U : term), typ e t T -> wf_type e U -> le_type e T U -> typ e t U. 
wrbuf (key : u64) (val : u64) m : {{{ own_wrbuf_xtpls wrbuf m }}} WrBuf__Put #wrbuf #key #val {{{ RET #(); own_wrbuf_xtpls wrbuf (<[ key := Value val ]> m) }}}. Proof. iIntros (Œ¶) "Hwrbuf HŒ¶". wp_call. iNamed "Hwrbuf". wp_loadField. wp_apply (wp_search with "HentsS"). iIntros (pos found) "[HentsS %Hsearch]". wp_pures. iDestruct (is_slice_small_acc with "HentsS") as "[HentsS HentsC]". wp_if_destruct. { wp_loadField. wp_lam. wp_pures. unfold spec_search in Hsearch. destruct Hsearch as (ent & Hlookup & Hkey). wp_apply (wp_slice_len). iDestruct (is_slice_small_sz with "HentsS") as "%HentsSz". rewrite fmap_length in HentsSz. wp_if_destruct; first last. { destruct Heqb0. apply lookup_lt_Some in Hlookup. rewrite HentsSz in Hlookup. word. } wp_apply (wp_slice_ptr). wp_pures. unfold is_slice_small. iDestruct "HentsS" as "[HentsA [%HentsLen %HentsCap]]". iDestruct (update_array (off:=int.nat pos) with "HentsA") as "[HentsP HentsA]". { by rewrite list_lookup_fmap Hlookup. } iDestruct (struct_fields_split with "HentsP") as "HentsP". iNamed "HentsP". wp_apply (wp_storeField with "[val]"); first auto. { iNext. iExactEq "val". do 3 f_equal. word. } iIntros "val". wp_pures. wp_apply (wp_storeField with "[wr]"); first auto. { iNext. iExactEq "wr". do 3 f_equal. word. } iIntros "wr". word_cleanup. set entR := (entsS.(Slice.ptr) +‚Çó[_] (int.Z pos)). set ent' := (ent.1.1.1, val, true, ent.2). iDestruct (struct_fields_split entR 1%Qp WrEnt (wrent_to_val ent') with "[key val wr tpl]") as "HentsP". { rewrite /struct_fields. by iFrame. } iDestruct ("HentsA" with "HentsP") as "HentsA". iDestruct ("HentsC" with "[HentsA]") as "HentsS". { iFrame. iPureIntro. by rewrite -HentsLen insert_length. } wp_pures. iApply "HŒ¶". iModIntro. unfold own_wrbuf_xtpls. do 2 iExists _. iFrame. iSplit; first by rewrite -list_fmap_insert. iPureIntro. split. { do 3 rewrite list_fmap_insert. subst ent'. simpl. replace (<[ _ := _ ]> ents.*1.*1.*1) with ents.*1.*1.*1; first done. symmetry. apply list_insert_id. do 3 rewrite list_lookup_fmap. by rewrite Hlookup. } { rewrite Hmods. rewrite list_fmap_insert. subst ent' key. unfold wrent_to_key_dbval. simpl. apply list_to_map_insert with (to_dbval ent.1.2 ent.1.1.2); first by apply NoDup_wrent_to_key_dbval. by rewrite list_lookup_fmap Hlookup. } } wp_pures. wp_loadField. iDestruct ("HentsC" with "HentsS") as "HentsS". wp_apply (wp_SliceAppend' with "[HentsS]"); [by auto 10 | by auto 10 | iFrame |]. iIntros (entsS') "HentsS". wp_storeField. iModIntro. iApply "HŒ¶". unfold spec_search in Hsearch. set ents' := (ents ++ [(key, val, true, null)]). unfold own_wrbuf_xtpls. iExists _, ents'. iFrame. iSplit; first by rewrite fmap_app. iPureIntro. split. { do 3 rewrite fmap_app. simpl. apply NoDup_app_comm. apply NoDup_app. split; first by apply NoDup_singleton. split; last done. intros x H. apply elem_of_list_singleton in H. by subst x. } { symmetry. rewrite Hmods. subst ents'. rewrite fmap_app. apply list_to_map_snoc. by rewrite wrent_to_key_dbval_key_fmap. } Qed. Theorem wp_wrbuf__Delete wrbuf (key : u64) m : {{{ own_wrbuf_xtpls wrbuf m }}} WrBuf__Delete #wrbuf #key {{{ RET #(); own_wrbuf_xtpls wrbuf (<[ key := Nil ]> m) }}}. 
[c2 m2]. destruct s1' as [c1' m1']. simpl in *. destruct H2 as [j [InjJ MCJ]]. inv H1. assert (DD := @Forward_simulation_inj.core_diagram _ _ _ _ _ Sem1 Sem2 (Genv.globalenv P1) (Genv.globalenv P2) epts R _ _ _ _ H5 _ _ _ _ MCJ). destruct DD as [c2' [m2' [d' [j' [InjJ' [Sep [MC' myStep]]]]]]]. exists d'. exists (c2', m2'); simpl. split; auto. destruct myStep as [H2 | [H2 H3]]. left. apply corestep_plus_plus_step; eauto. right. split; auto. apply corestep_star_star_step; eauto. exists j'; split; auto. eapply inject_incr_trans. apply InjJ. apply InjJ'. destruct (@Forward_simulation_inj.core_at_external _ _ _ _ _ Sem1 Sem2 (Genv.globalenv P1) (Genv.globalenv P2) epts R _ _ _ _ _ _ _ _ _ MCJ H7) as[INJ [jPG [args2 [LD [TP AtExt2]]]]]. apply forall_inject_val_list_inject in LD. assert (ZZ:= @external_call_mem_inject ef _ _ (Genv.globalenv P1) _ _ _ _ _ j _ _ jPG H8 INJ LD). destruct ZZ as [j' [ret2 [m2' [extCall2 [RetInj [MInj2 [Munch1 [Munch2 [InjJ' Sep']]]]]]]]]. assert (extCall2Genv2 : external_call ef (Genv.globalenv P2) args2 m2 t ret2 m2'). eapply external_call_symbols_preserved_gen. apply HypGenv. apply HypVolatile. solve[apply extCall2]. clear extCall2. assert (DD := @Forward_simulation_inj.core_after_external _ _ _ _ _ Sem1 Sem2 (Genv.globalenv P1) (Genv.globalenv P2) epts R i j). assert (RetTp:= external_call_well_typed _ _ _ _ _ _ _ H8). assert (RetInjOpt: val_inject_opt j' (Some ret) (Some ret2)) by auto. destruct (DD j' _ _ _ _ _ _ _ _ _ _ (ef_sig ef) INJ MCJ H7 jPG InjJ' Sep' MInj2 RetInjOpt) as [d' [c1'' [c2' [AftExt1 [AftExt2 Match2]]]]]; clear DD. eapply external_call_mem_forward; eauto. apply mem_unchanged_on_sub with (Q := loc_unmapped j); auto. eapply external_call_mem_forward; eauto. apply mem_unchanged_on_sub with (Q := loc_out_of_reach j m1); auto. eapply external_call_well_typed; eauto. rewrite AftExt1 in H9. inv H9. exists d'. exists (c2', m2'). split. left. apply plus_one. eapply (step_ext_step _ _ _ _ _ _ _ _ _ _ _ _ _ AtExt2 extCall2Genv2 AftExt2). exists j'; simpl. split;eauto. eapply inject_incr_trans. apply InjJ. apply InjJ'. simpl. apply HypGenv. assert (MM: prog_main P1 = prog_main P2) by (eapply CompilerCorrectness.corec_main; eauto). spec IHX1. apply H. spec IHX1. apply MM. spec IHX2. rewrite MM in H. apply H. spec IHX2. eapply CompilerCorrectness.corec_main; eauto. clear X1 X2. eapply compose_forward_simulation; eauto. Qed.End CompilerCorrectness_implies_forward_simulation.Lemma transl_program_block_volatile: forall {F FF V} (P: AST.program F V) (transf: F -> FF) b, block_is_volatile (Genv.globalenv (AST.transform_program transf P)) b = block_is_volatile (Genv.globalenv P) b. Proof. intros. unfold block_is_volatile. rewrite Genv.find_var_info_transf. trivial. Qed.Module CompilerCorrectnessT_implies_forward_simulation. Theorem CoreCorrectnessT_implies_CompcertForwardSimulation: forall F1 C1 V1 F2 C2 (Sem1: CoreSemantics (Genv.t F1 V1) C1 mem) (Sem2: CoreSemantics (Genv.t F2 V1) C2 mem) P1 P2 ExternIdents epts (EXT: In (P1.(prog_main), CompilerCorrectness.extern_func main_sig) ExternIdents), CompilerCorrectness.core_correctnessT (fun F C V Sem P => True) ExternIdents epts F1 C1 V1 F2 C2 Sem1 Sem2 P1 P2 -> forward_simulation (mk_semantics F1 C1 V1 Sem1 P1) (mk_semantics F2 C2 V1 Sem2 P2). 
: UU } ( f : X -> Z ) ( g : Y -> Z ) ( noi : forall ( x : X ) ( y : Y ) , neg ( paths ( f x ) ( g y ) ) ) ( z : Z ) : hfiber f z -> hfiber g z -> empty . Proof. intros X Y Z f g noi z hfz hgz . destruct hfz as [ x fe ] . destruct hgz as [ y ge ] . apply ( noi x y ( pathscomp0 fe ( pathsinv0 ge ) ) ) . Defined . Lemma weqhfibernoi1 { X Y Z : UU } ( f : X -> Z ) ( g : Y -> Z ) ( noi : forall ( x : X ) ( y : Y ) , neg ( paths ( f x ) ( g y ) ) ) ( z : Z ) ( xe : hfiber f z ) : weq ( hfiber ( sumofmaps f g ) z ) ( hfiber f z ) . Proof. intros . set ( w1 := invweq ( weqhfibersofsumofmaps f g z ) ) . assert ( a : neg ( hfiber g z ) ) . intro ye . apply ( noil1 f g noi z xe ye ) . set ( w2 := invweq ( weqii1withneg ( hfiber f z ) a ) ) . apply ( weqcomp w1 w2 ) . Defined . Lemma weqhfibernoi2 { X Y Z : UU } ( f : X -> Z ) ( g : Y -> Z ) ( noi : forall ( x : X ) ( y : Y ) , neg ( paths ( f x ) ( g y ) ) ) ( z : Z ) ( ye : hfiber g z ) : weq ( hfiber ( sumofmaps f g ) z ) ( hfiber g z ) . Proof. intros . set ( w1 := invweq ( weqhfibersofsumofmaps f g z ) ) . assert ( a : neg ( hfiber f z ) ) . intro xe . apply ( noil1 f g noi z xe ye ) . set ( w2 := invweq ( weqii2withneg ( hfiber g z ) a ) ) . apply ( weqcomp w1 w2 ) . Defined . Theorem isofhlevelfsumofmapsnoi ( n : nat ) { X Y Z : UU } ( f : X -> Z ) ( g : Y -> Z ) ( isf : isofhlevelf n f ) ( isg : isofhlevelf n g ) ( noi : forall ( x : X ) ( y : Y ) , neg ( paths ( f x ) ( g y ) ) ) : isofhlevelf n ( sumofmaps f g ) . 
: „ÄòA (2*m)„Äô= ‚äü„ÄòMZ_one„Äô. Proof. rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A; auto. rewrite mscal_S, mscal_1; auto. rewrite MU22_morph with (1 := Z2Zp_morph). rewrite Am_iAm_mod at 1. do 2 rewrite <- MI22_morph with (1 := Z2Zp_morph). rewrite <- MU22_morph with (1 := Z2Zp_morph). f_equal. rewrite M22_opp_mult_l with (1 := Zring); f_equal. apply iA_A. Qed. Fact A2lm_mod : „ÄòA (2*l*m)„Äô= „ÄòMZ_scal (mscal Zmult 1 l (-1)) MZ_one„Äô. Proof. replace (2*l*m)%nat with (l*(2*m))%nat by ring. rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A; auto. rewrite expo22_morph with (1 := Z2Zp_morph). rewrite A2m_mod. rewrite <- MI22_morph with (1 := Z2Zp_morph). rewrite <- expo22_morph with (1 := Z2Zp_morph). f_equal. rewrite <- M22scal_MI22 with (1 := Zring). change (-(1)) with (-1). rewrite expo22_scal with (1 := Zring); f_equal. rewrite mscal_of_unit; auto. Qed. Let expoZ_opp1 i : expoZ i (-1) = 1 \/ expoZ i (-1) = -1. Proof. induction i as [ | i IHi ]. + rewrite mscal_0; auto. + rewrite mscal_S; lia. Qed. Variable (j : nat) (Hl : (l <> 0)%nat) (Hj : (j <= m)%nat). Fact alpha_2lm_plus_j :„ÄöŒ± (S (2*l*m+j))„Äõ=„ÄöexpoZ l (-1)*Œ± (S j)„Äõ. Proof. generalize (A_plus (2*l*m) j); intros H. apply f_equal with (f := morph22 f) in H. rewrite MU22_morph with (1 := Z2Zp_morph) in H. rewrite A2lm_mod in H. rewrite <- MU22_morph with (1 := Z2Zp_morph) in H. apply M22_proj12 in H. rewrite Z.mul_0_r, Z.mul_0_l, Z.mul_1_r, Z.add_0_l in H. apply H. Qed. Let Hj' : (j <= 2*l*m)%nat. Proof. apply le_trans with (1*m)%nat; try lia. apply mult_le_compat; lia. Qed. Fact alpha_2lm_minus_j :„ÄöŒ± (S (2*l*m-j))„Äõ=„ÄöexpoZ (S l) (-1)*Œ± (S j)„Äõ. Proof using Hl Hj. generalize (A_minus Hj'); intros H. apply f_equal with (f := morph22 f) in H. rewrite MU22_morph with (1 := Z2Zp_morph) in H. rewrite A2lm_mod in H. rewrite <- MU22_morph with (1 := Z2Zp_morph) in H. apply M22_proj12 in H. rewrite Z.mul_0_r, Z.mul_0_l, Z.mul_1_r, Z.add_0_l in H. unfold plus in H; rewrite H; f_equal. rewrite mscal_S; ring. Qed. Theorem alpha_nat_2lm_plus_j : nat2Zp Hv' (alpha_nat (2*l*m+j)) = nat2Zp Hv' (alpha_nat j) \/ nat2Zp Hv' (alpha_nat (2*l*m+j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)). Proof. generalize (alpha_2lm_plus_j). destruct (expoZ_opp1 l) as [ E | E ]; rewrite E; intros H; [ left | right ]. + repeat rewrite alpha_Z_S in H. rewrite Z2Zp_of_nat, Z.mul_1_l, Z2Zp_of_nat in H; auto. + repeat rewrite alpha_Z_S in H. change (-1) with (-(1)) in H. rewrite Z.mul_opp_l, Z.mul_1_l, Z2Zp_opp in H. repeat rewrite Z2Zp_of_nat in H; auto. Qed. Theorem alpha_nat_2lm_minus_j : nat2Zp Hv' (alpha_nat (2*l*m-j)) = nat2Zp Hv' (alpha_nat j) \/ nat2Zp Hv' (alpha_nat (2*l*m-j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)). 
im). + auto. + simpl. rewrite IHfds. auto. - auto. Qed. Theorem update_count_inlined_unaffected: forall v0 lx ly count, ~FromList lx v0 -> ~FromList ly v0 -> get_c v0 (update_count_inlined ly lx count) = get_c v0 count. Proof. induction lx; intros. destruct ly; simpl; auto. destruct ly. simpl. auto. simpl. erewrite IHlx. rewrite gdso. rewrite gdso. auto. intro; apply H. constructor; auto. intro; apply H0. constructor; auto. intro; apply H. constructor 2; auto. intro; apply H0. constructor 2; auto. Qed. Theorem update_count_inlined_dom: forall v0 lx ly count, List.length lx = List.length ly -> FromList lx v0 -> Disjoint _ (FromList ly) (FromList lx) -> get_c v0 (update_count_inlined ly lx count) = 0. Proof. induction lx; intros. inv H0. destruct ly; inv H. simpl. assert (Hlx := Decidable_FromList lx). inv Hlx. specialize (Dec v0). inv Dec. eapply IHlx. auto. auto. split; intro. intro. inv H1. specialize (H4 x). apply H4. inv H2. split; constructor 2; auto. inv H0. rewrite update_count_inlined_unaffected. rewrite gdso. rewrite gdss. auto. inv H1. specialize (H0 v0). intro; subst. apply H0. split; constructor; auto. auto. inv H1. specialize (H0 v0). intro; apply H0. split. constructor 2; auto. constructor. auto. exfalso; auto. Qed. Theorem dead_occur_fds_le_antimon: forall im im' : b_map, b_map_le im im' -> forall (f : var) (f4 : fundefs), num_occur_fds (inlined_fundefs_f f4 im) f 0 -> num_occur_fds (inlined_fundefs_f f4 im') f 0. Proof. intros. assert (exists n, num_occur_fds (inlined_fundefs_f f4 im') f n) by apply e_num_occur_fds. destruct H1. assert (x <= 0). eapply num_occur_fds_le_antimon; eauto. apply le_n_0_eq in H2. subst; auto. Qed. Inductive sum_range_n: list var -> list var -> exp -> var -> nat -> Prop := | SRN_cons1: forall lx ly e v0 n m x, sum_range_n lx ly e v0 n -> num_occur e x m -> sum_range_n (x::lx) (v0::ly) e v0 (m+n) | SRN_cons2: forall lx ly e v n y x, sum_range_n lx ly e v n -> y <> v -> sum_range_n (x::lx) (y::ly) e v n | SRN_nil: forall e v, sum_range_n nil nil e v 0. Theorem e_sum_range_n: forall e v lx ly, List.length lx = List.length ly -> exists n, sum_range_n lx ly e v n. Proof. induction lx; intros; destruct ly; inv H. exists 0; constructor. apply IHlx in H1. inv H1. destruct (var_dec v0 v). subst. assert (exists n, num_occur e a n) by apply e_num_occur. destruct H0. exists (x0+x). constructor; auto. exists x. constructor; auto. Qed. Theorem update_count_sum_range: forall v0 e sig l l0 count n, num_occur_list (apply_r_list sig l) v0 <= get_c v0 count -> ~ FromList l0 v0 -> Disjoint _ (FromList (apply_r_list sig l)) (FromList l0) -> (forall x n, FromList l0 x -> num_occur (rename_all_ns sig e) x n -> get_c x count = n) -> sum_range_n l0 (apply_r_list sig l) (rename_all_ns sig e) v0 n -> NoDup l0 -> (get_c v0 (update_count_inlined (apply_r_list sig l) l0 count ) = get_c v0 count + n - num_occur_list (apply_r_list sig l) v0). 
rel_dec _ _ _ !x !y.Class RelDec_Correct T (equ : T -> T -> Prop) (ED : RelDec equ) : Prop := { rel_dec_correct : forall x y : T, rel_dec x y = true <-> equ x y }.Notation "a ?[ r ] b" := (@rel_dec _ r _ a b) (at level 30, b at next level).Definition eq_dec {T : Type} {ED : RelDec (@eq T)} := rel_dec.Section neg_rel_dec_correct. Context {T} {R:T -> T -> Prop} {RD:RelDec R} {RDC:RelDec_Correct RD}. Definition neg_rel_dec_correct : forall {x y}, ~R x y <-> rel_dec x y = false. Proof. intros x y. destruct (bool_dec (rel_dec x y) true) ; constructor ; intros ; repeat match goal with | [ |- ~ _ ] => unfold not ; intros | [ H1 : ?P, H2 : ~?P |- _ ] => specialize (H2 H1) ; contradiction | [ H1 : ?P = true, H2 : ?P = false |- _ ] => rewrite H1 in H2 ; discriminate | [ H1 : ?P <> true |- ?P = false ] => apply not_true_is_false ; exact H1 | [ H1 : ?rel_dec ?a ?b = true, H2 : ~?R ?a ?b |- _ ] => apply rel_dec_correct in H1 | [ H1 : ?rel_dec ?a ?b = false, H2 : ?R ?a ?b |- _ ] => apply rel_dec_correct in H2 end. Qed. End neg_rel_dec_correct.Section rel_dec_p. Context {T} {R:T -> T -> Prop} {RD:RelDec R} {RDC:RelDec_Correct RD}. Definition rel_dec_p (x:T) (y:T) : {R x y} + {~R x y}. Proof. destruct (bool_dec (rel_dec x y) true) as [H | H]. apply rel_dec_correct in H ; eauto. apply not_true_is_false in H ; apply neg_rel_dec_correct in H ; eauto. Qed. Definition neg_rel_dec_p (x:T) (y:T) : {~R x y} + {R x y}. Proof. destruct (rel_dec_p x y) ; [ right | left ] ; auto. Qed. End rel_dec_p.Section lemmas. Variable T : Type. Variable eqt : T -> T -> Prop. Variable r : RelDec eqt. Variable rc : RelDec_Correct r. Theorem rel_dec_eq_true : forall x y, eqt x y -> rel_dec x y = true. Proof. intros. eapply rel_dec_correct in H. assumption. Qed. Theorem rel_dec_neq_false : forall x y, ~eqt x y -> rel_dec x y = false. Proof. intros. remember (x ?[ eqt ] y). symmetry in Heqb. destruct b; try reflexivity. exfalso. eapply (@rel_dec_correct _ _ _ rc) in Heqb. auto. Qed. Theorem rel_dec_sym : Symmetric eqt -> forall x y, x ?[ eqt ] y = y ?[ eqt ] x. 
Require Import GeoCoq.Axioms.continuity_axioms. Require Export GeoCoq.Axioms.parallel_postulates. Require Export GeoCoq.Meta_theory.Parallel_postulates.SPP_tarski. Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_consecutive_interior_angles. Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_playfair_bis. Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_triangle. Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_proclus. Require Export GeoCoq.Meta_theory.Parallel_postulates.bachmann_s_lotschnittaxiom_legendre_s_parallel_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.bachmann_s_lotschnittaxiom_weak_inverse_projection_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.bachmann_s_lotschnittaxiom_weak_triangle_circumscription_principle. Require Export GeoCoq.Meta_theory.Parallel_postulates.consecutive_interior_angles_alternate_interior_angles. Require Export GeoCoq.Meta_theory.Parallel_postulates.existential_playfair_rah. Require Export GeoCoq.Meta_theory.Parallel_postulates.existential_saccheri_rah. Require Export GeoCoq.Meta_theory.Parallel_postulates.inverse_projection_postulate_proclus_bis. Require Export GeoCoq.Meta_theory.Parallel_postulates.legendre. Require Export GeoCoq.Meta_theory.Parallel_postulates.midpoint_playfair. Require Export GeoCoq.Meta_theory.Parallel_postulates.original_euclid_original_spp. Require Export GeoCoq.Meta_theory.Parallel_postulates.original_spp_inverse_projection_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_2_par_par_perp_perp. Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_perp_par_perp_2_par. Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_perp_playfair. Require Export GeoCoq.Meta_theory.Parallel_postulates.par_trans_playfair. Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_existential_playfair. Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_midpoint. Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_par_trans. Require Export GeoCoq.Meta_theory.Parallel_postulates.posidonius_postulate_rah. Require Export GeoCoq.Meta_theory.Parallel_postulates.proclus_aristotle. Require Export GeoCoq.Meta_theory.Parallel_postulates.proclus_bis_proclus. Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_existential_saccheri. Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_rectangle_principle. Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_similar. Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_thales_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_posidonius_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.rectangle_existence_rah. Require Export GeoCoq.Meta_theory.Parallel_postulates.rectangle_principle_rectangle_existence. Require Export GeoCoq.Meta_theory.Parallel_postulates.similar_rah. Require Export GeoCoq.Meta_theory.Parallel_postulates.tarski_playfair. Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_converse_postulate_thales_existence. Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_converse_postulate_weak_triangle_circumscription_principle. Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_existence_rah. Require Export GeoCoq.Meta_theory.Parallel_postulates.thales_postulate_thales_converse_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_inverse_projection_postulate_bachmann_s_lotschnittaxiom. Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_inverse_projection_postulate_weak_tarski_s_parallel_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_tarski_s_parallel_postulate_weak_inverse_projection_postulate. Require Export GeoCoq.Meta_theory.Parallel_postulates.weak_triangle_circumscription_principle_bachmann_s_lotschnittaxiom. Require Export GeoCoq.Tarski_dev.Annexes.saccheri. Require Export GeoCoq.Tarski_dev.Annexes.perp_bisect. Require Export GeoCoq.Tarski_dev.Annexes.quadrilaterals. Require Export GeoCoq.Tarski_dev.Ch13_1.Require Import GeoCoq.Utils.all_equiv.Require Import Rtauto.Section Euclid.Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.Theorem equivalent_postulates_without_decidability_of_intersection_of_lines : all_equiv (alternate_interior_angles_postulate:: alternative_playfair_s_postulate:: consecutive_interior_angles_postulate:: midpoint_converse_postulate:: perpendicular_transversal_postulate:: playfair_s_postulate:: universal_posidonius_postulate:: postulate_of_parallelism_of_perpendicular_transversals:: postulate_of_transitivity_of_parallelism:: nil). Proof. assert (K:=alternate_interior__consecutive_interior). assert (L:=alternate_interior__playfair_bis). assert (M:=consecutive_interior__alternate_interior). assert (N:=midpoint_converse_postulate_implies_playfair). assert (O:=par_perp_perp_implies_par_perp_2_par). assert (P:=par_perp_perp_implies_playfair). assert (Q:=par_perp_2_par_implies_par_perp_perp). assert (R:=par_trans_implies_playfair). assert (S:=playfair_bis__playfair). assert (T:=playfair_implies_par_trans). assert (U:=playfair_s_postulate_implies_midpoint_converse_postulate). assert (V:=playfair__alternate_interior). assert (W:=playfair__universal_posidonius_postulate). assert (X:=universal_posidonius_postulate__perpendicular_transversal_postulate). apply all_equiv__equiv; unfold all_equiv'; simpl; repeat (split; tauto). Qed.Theorem equivalent_postulates_without_any_continuity : all_equiv (existential_thales_postulate:: posidonius_postulate:: postulate_of_existence_of_a_right_lambert_quadrilateral:: postulate_of_existence_of_a_right_saccheri_quadrilateral:: postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights:: postulate_of_existence_of_similar_triangles:: postulate_of_right_lambert_quadrilaterals:: postulate_of_right_saccheri_quadrilaterals:: thales_postulate:: thales_converse_postulate:: triangle_postulate:: nil). Proof. intros. assert (H:=existential_saccheri__rah). assert (I:=existential_triangle__rah). assert (J:=posidonius_postulate__rah). assert (K:=rah__existential_saccheri). assert (L:=rah__rectangle_principle). assert (M:=rah__similar). assert (N:=rah__thales_postulate). assert (O:=rah__triangle). assert (P:=rah__posidonius). assert (Q:=rectangle_existence__rah). assert (R:=rectangle_principle__rectangle_existence). assert (S:=similar__rah). assert (T:=thales_converse_postulate__thales_existence). assert (U:=thales_existence__rah). assert (V:=thales_postulate__thales_converse_postulate). assert (W:=triangle__existential_triangle). apply all_equiv__equiv; unfold all_equiv'; simpl; repeat (split; tauto). Qed.Theorem equivalent_postulates_with_decidability_of_intersection_of_lines : decidability_of_intersection -> all_equiv (alternate_interior_angles_postulate:: alternative_playfair_s_postulate:: alternative_proclus_postulate:: alternative_strong_parallel_postulate:: consecutive_interior_angles_postulate:: euclid_5:: euclid_s_parallel_postulate:: inverse_projection_postulate:: midpoint_converse_postulate:: perpendicular_transversal_postulate:: playfair_s_postulate:: universal_posidonius_postulate:: postulate_of_parallelism_of_perpendicular_transversals:: postulate_of_transitivity_of_parallelism:: proclus_postulate:: strong_parallel_postulate:: tarski_s_parallel_postulate:: triangle_circumscription_principle:: nil). Proof. intro HID. assert (L:=euclid_5__original_euclid). assert (M:=inter_dec_plus_par_perp_perp_imply_triangle_circumscription HID); clear HID. assert (O:=inverse_projection_postulate__proclus_bis). assert (P:=original_euclid__original_spp). assert (Q:=original_spp__inverse_projection_postulate). assert (R:=proclus_bis__proclus). assert (S:=proclus_s_postulate_implies_strong_parallel_postulate). assert (T:=strong_parallel_postulate_implies_tarski_s_euclid). assert (U:=tarski_s_euclid_implies_euclid_5). assert (V:=tarski_s_euclid_implies_playfair). assert (W:=triangle_circumscription_implies_tarski_s_euclid). assert (X:=equivalent_postulates_without_decidability_of_intersection_of_lines). apply all_equiv__equiv; unfold all_equiv, all_equiv' in *; simpl in *. repeat (split; try rtauto; try (intro Z; assert (HP:playfair_s_postulate) by (try rtauto; let A := type of Z in (apply -> (X A); try assumption; tauto)); assert (J:perpendicular_transversal_postulate) by (let A := type of HP in (apply -> (X A); try assumption; tauto)); try rtauto; let A := type of HP in (apply -> (X A); try assumption; tauto))). Qed. Theorem equivalent_postulates_without_decidability_of_intersection_of_lines_bis : all_equiv (alternative_strong_parallel_postulate:: alternative_proclus_postulate:: euclid_5:: euclid_s_parallel_postulate:: inverse_projection_postulate:: proclus_postulate:: strong_parallel_postulate:: tarski_s_parallel_postulate:: triangle_circumscription_principle:: nil). 
reflexivity. + intros ? ? ? Heq‚ÇÅ Heq‚ÇÇ ?. rewrite Heq‚ÇÅ, Heq‚ÇÇ. reflexivity. Qed.Definition incl {A : Type} dom‚ÇÅ dom‚ÇÇ (m‚ÇÅ : t A dom‚ÇÅ) (m‚ÇÇ : t A dom‚ÇÇ) := forall x v, find x m‚ÇÅ = Some v -> find x m‚ÇÇ = Some v.Instance incl_refl : forall A dom (m : t A dom), Reflexive (@incl A dom dom). Proof. repeat intro. assumption. Qed.Lemma incl_trans : forall A dom‚ÇÅ dom‚ÇÇ dom3 (m‚ÇÅ : t A dom‚ÇÅ) (m‚ÇÇ : t A dom‚ÇÇ) (m3 : t A dom3), incl m‚ÇÅ m‚ÇÇ -> incl m‚ÇÇ m3 -> incl m‚ÇÅ m3. Proof. repeat intro. auto. Qed.Instance incl_preorder : forall A dom, PreOrder (@incl A dom dom). Proof. split. + repeat intro; assumption. + intros ? ? ? Hle‚ÇÅ Hle‚ÇÇ ? ? ?. now apply Hle‚ÇÇ, Hle‚ÇÅ. Qed.Instance eq_incl_compat : forall A dom, PartialOrder (@eq A dom dom) (@incl A dom dom). Proof. intros A dom m‚ÇÅ m‚ÇÇ. split; intro Heq. + split; intros x v Hin. - now rewrite <- Heq. - now rewrite Heq. + intro x. destruct (find x m‚ÇÅ) as [v‚ÇÅ |] eqn:Hin‚ÇÅ, (find x m‚ÇÇ) as [v‚ÇÇ |] eqn:Hin‚ÇÇ. - apply Heq in Hin‚ÇÅ. rewrite Hin‚ÇÅ in Hin‚ÇÇ. assumption. - apply Heq in Hin‚ÇÅ. rewrite Hin‚ÇÅ in Hin‚ÇÇ. discriminate Hin‚ÇÇ. - apply Heq in Hin‚ÇÇ. rewrite Hin‚ÇÇ in Hin‚ÇÅ. discriminate Hin‚ÇÅ. - reflexivity. Qed.Instance mem_compat (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@mem A dom). Proof. intros x y Hxy m‚ÇÅ m‚ÇÇ Heq. destruct (mem y m‚ÇÇ) eqn:Hmem. + rewrite mem_spec in *. destruct Hmem as [v Hmem]. exists v. rewrite Heq. now rewrite (find_elt_compat _ Hxy). + destruct (mem x m‚ÇÅ) eqn:Hmem'; trivial. rewrite mem_spec in *. destruct Hmem' as [v Hmem']. rewrite Heq, (find_elt_compat _ Hxy) in Hmem'. assert (Hex : exists v, find y m‚ÇÇ = Some v) by now exists v. rewrite <- mem_spec, Hmem in Hex. discriminate Hex. Qed.Theorem find_compat : forall A x y dom‚ÇÅ dom‚ÇÇ (m‚ÇÅ : t A dom‚ÇÅ) (m‚ÇÇ : t A dom‚ÇÇ), X.eq x y -> eq m‚ÇÅ m‚ÇÇ -> find x m‚ÇÅ = find y m‚ÇÇ. Proof. intros * Hxy Heq. rewrite Heq. apply find_elt_compat. assumption. Qed.Instance find_compat2 (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@find A dom). Proof. repeat intro. apply find_compat; assumption. Qed.Arguments set {A} {dom} x v m _. Theorem set_compat : forall A x y v dom‚ÇÅ dom‚ÇÇ (m‚ÇÅ : t A dom‚ÇÅ) (m‚ÇÇ : t A dom‚ÇÇ) (Hin‚ÇÅ : Dom.In x dom‚ÇÅ) (Hin‚ÇÇ : Dom.In y dom‚ÇÇ), X.eq x y -> eq m‚ÇÅ m‚ÇÇ -> eq (set x v m‚ÇÅ Hin‚ÇÅ) (set y v m‚ÇÇ Hin‚ÇÇ). 
Add LoadPath "/home/blaine/lab/cpdtlib" as Cpdt. Set Implicit Arguments. Set Asymmetric Patterns. Require Import List String Cpdt.CpdtTactics Coq.Program.Wf. From stdpp Require Import base fin vector options. Import ListNotations. Require Import theorems.utils. Section Sized. Context {size: nat}. Notation register := (fin size). Record MachineState := machine_state { counter: nat; registers: (vec nat size); program_memory: list Instruction }. Inductive Operand: Type := | Literal (n: nat) | Register (r: register) . Definition eval_operand (cur: MachineState) (operand: Operand) : nat := match operand with | Literal n => n | Register r => (cur.(registers) !!! r) end . Inductive Instruction := | InstExit | InstMov (src: Operand) (dest: register) | InstAdd (val: Operand) (dest: register) . Hint Constructors Instruction: core. Notation Within cur := (cur.(counter) < (length cur.(program_memory))) (only parsing). Notation cur_instr cur := (lookup cur.(counter) cur.(program_memory)) (only parsing). Notation get_instr cur := (@safe_lookup _ cur.(counter) cur.(program_memory) _) (only parsing). Notation get cur reg := (cur.(registers) !!! reg) (only parsing). Notation update cur dest val := (vinsert dest val cur.(registers)) (only parsing). Notation incr cur := (S cur.(counter)) (only parsing). Inductive Step: MachineState -> MachineState -> Prop := | Step_Mov: forall cur src dest, (cur_instr cur) = Some (InstMov src dest) -> Step program cur (machine_state (incr cur) (update cur dest (eval_operand cur src)) ) | Step_Add: forall cur val dest, (cur_instr cur) = Some (InstAdd val dest) -> Step program cur (machine_state (incr cur) (update cur dest ((eval_operand cur val) + (get cur dest))) ) . Hint Constructors Step: core. Theorem Step_always_Within program cur next: Step program cur next -> Within program cur. 
unfold doLeader in *. repeat break_match; find_inversion; subst; simpl in *; intuition. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. apply subseq_findGtIndex. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. find_apply_lem_hyp findGtIndex_necessary; intuition. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. break_match; intuition. find_apply_lem_hyp findGtIndex_necessary; intuition. find_apply_lem_hyp findAtIndex_elim. simpl in *. intuition. repeat find_rewrite. eapply sorted_index_term; eauto. omega. Qed. Theorem logs_sorted_do_leader : raft_net_invariant_do_leader logs_sorted. Proof using. unfold raft_net_invariant_do_leader. unfold logs_sorted. intuition; simpl in *. - unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp doLeader_log. repeat find_higher_order_rewrite. break_match; subst; try find_rewrite; eauto. - unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; intuition; eauto using sorted_subseq. - unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; [idtac|idtac|idtac|eauto]; intuition eauto. - unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; [idtac|idtac|idtac|eauto]; intuition eauto. Qed. Lemma doGenericServer_packets : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> ps = []. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; subst; auto. Qed. Theorem logs_sorted_do_generic_server : raft_net_invariant_do_generic_server logs_sorted. Proof using. unfold raft_net_invariant_do_generic_server. unfold logs_sorted. intuition; simpl in *. - subst. unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp doGenericServer_log. repeat find_higher_order_rewrite. break_match; try find_rewrite; eauto. - find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. eauto using logs_sorted_nw_packets_unchanged. - find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. eauto using packets_gt_prevIndex_packets_unchanged. - find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. eauto using packets_ge_prevTerm_packets_unchanged. Qed. Theorem logs_sorted_state_same_packet_subset : raft_net_invariant_state_same_packet_subset logs_sorted. Proof using. unfold raft_net_invariant_state_same_packet_subset, logs_sorted. intuition; simpl in *. - unfold logs_sorted_host in *. intros. find_reverse_higher_order_rewrite. eauto. - eapply logs_sorted_nw_packets_unchanged with (st' := (nwState net')); eauto. - eapply packets_gt_prevIndex_packets_unchanged with (st' := (nwState net')); eauto. - eapply packets_ge_prevTerm_packets_unchanged with (st' := (nwState net')); eauto. Qed. Theorem logs_sorted_reboot : raft_net_invariant_reboot logs_sorted. Proof using. unfold raft_net_invariant_reboot, logs_sorted, reboot. intuition; simpl in *. - unfold logs_sorted_host in *. intros. repeat find_higher_order_rewrite. simpl in *. break_match; subst; eauto. - subst. eapply logs_sorted_nw_packets_unchanged with (st' := nwState net') (ps' := nwPackets net') ; eauto. find_rewrite. intuition. - subst. eapply packets_gt_prevIndex_packets_unchanged with (st' := nwState net') (ps' := nwPackets net') ; eauto. find_rewrite. intuition. - subst. eapply packets_ge_prevTerm_packets_unchanged with (st' := nwState net') (ps' := nwPackets net') ; eauto. find_rewrite. intuition. Qed. Theorem logs_sorted_invariant : forall net, raft_intermediate_reachable net -> logs_sorted net. 
-> (forall x, In x (map fst l1) -> x <> v') -> ~In v' (map fst (get_dists s)) -> done s' = true -> In (v', d') (get_dists s'). Proof. intros. destruct (done s) eqn : D. - assert (s = s'). eapply done_unique. apply H. assumption. assumption. assumption. subst. unfold done in D. rewrite H1 in D. rewrite orb_true_iff in D. destruct D. destruct l1; simpl in H5; inversion H5. rewrite isEmpty_def in H5. assert (vIn (get_graph s') v' = true). destruct (vIn (get_graph s') v') eqn : V. reflexivity. eapply graph_iff_not_output in V. contradiction. apply H. eapply queue_in_graph. apply H. rewrite H1. rewrite map_app. simpl. solve_in. rewrite H5 in H6. inversion H6. assumption. - pose proof (multi_done _ _ _ _ H H0 D H4). pose proof (first_queue_contant_multi _ _ _ _ _ _ _ _ H H1 H2 H3 H5). destruct H6. assumption. destruct_all. unfold done in H4. rewrite H7 in H4. rewrite orb_true_iff in H4. destruct H4. destruct x; simpl in H4; inversion H4. rewrite isEmpty_def in H4. destruct (vIn (get_graph s') v') eqn : V. rewrite H4 in V. inversion V. eapply graph_iff_not_output in V. contradiction. apply H0. eapply queue_in_graph. apply H. rewrite H1. rewrite map_app; simpl; solve_in. assumption. Qed.Lemma queue_smaller_than_dists: forall s g v, valid s g v -> (forall n, In n (map snd (get_queue s)) -> (forall m, In m (map snd (get_dists s)) -> (m <= n)%Z)). Proof. intros. generalize dependent n. generalize dependent m. induction H; intros. unfold start in *; simpl in *. destruct H1. inversion H0; subst; simpl in *. - rewrite map_app in *. apply in_app_or in H1. apply in_app_or in H2. destruct H2. destruct H1. apply IHvalid. assumption. right. assumption. simpl in H1. destruct H1. subst. pose proof (queue_structure _ _ _ v0 m vs H) . assert (get_queue (g0, (v0, m) :: vs, d) = (v0, m) :: vs) by reflexivity. specialize (H1 H5); clear H5. destruct H1. simpl in H1. apply Sorted_StronglySorted in H1. inversion H1; subst. rewrite Forall_forall in H9. apply H9. assumption. unfold Relations_1.Transitive. intros. omega. destruct H1. rewrite in_map_iff in H2. destruct H2. destruct x. simpl in *. destruct H2. subst. rewrite (suci_def n0 n _ c v0 g0 g' H4) in H5. destruct H5. subst. destruct H1. assert ( (m<=j)%Z). apply IHvalid. assumption. left. reflexivity. omega. destruct H1. subst. omega. destruct H1. - apply IHvalid. assumption. right. assumption. Qed. Theorem dists_sorted: forall s g v, valid s g v -> Sorted Z.le (map snd (get_dists s)). 
eapply case_size; eauto. - apply dsubterm_fds_size in H0. simpl. lia. - simpl. lia. Defined. Theorem subterm_size : forall e e', subterm_e e' e -> (term_size e' < term_size e)%nat. Proof. intros. induction H. - apply dsubterm_size; auto. - eapply transitivity; eauto. Defined. Theorem subterm_fds_size: forall e fds, subterm_fds_e e fds -> (term_size e < funs_size fds)%nat. Proof. intros. induction H. - apply subterm_size in H. simpl. lia. - simpl. lia. Defined. Theorem subterm_or_eq_size: forall e e', subterm_or_eq e e' -> (term_size e <= term_size e')%nat. Proof. intros. induction H. apply dsubterm_size in H; lia. reflexivity. etransitivity; eauto. Defined. Theorem subfds_or_eq_size: forall fds fds', subfds_or_eq fds fds' -> (funs_size fds <= funs_size fds')%nat. Proof. destruct fds; intros; inversion H; try (subst; reflexivity). - apply subfds_fds_size in H0. lia. - inversion H0; subst. simpl; lia. simpl; lia. Defined. Corollary subfds_e_size: forall fds e, subfds_e fds e -> (funs_size fds < term_size e)%nat. Proof. intros. inversion H. destructAll. apply subfds_or_eq_size in H1. apply subterm_or_eq_size in H0. simpl in H0. lia. Defined. Definition b_map_le: b_map -> b_map -> Prop := fun inl inl_r => forall v, get_b v inl = true -> get_b v inl_r = true. Theorem b_map_le_refl: forall i, b_map_le i i. Proof. intros; intro; intros. assumption. Defined. Theorem b_map_le_trans: forall i i' i'', b_map_le i i' -> b_map_le i' i'' -> b_map_le i i''. Proof. intros; intro; intros. apply H in H1. apply H0 in H1. assumption. Defined. Theorem b_map_le_true : forall v i, b_map_le i (M.set v true i). Proof. intros. intro. intros. destruct (var_dec v0 v); subst. - apply gdss. - rewrite gdso by auto. apply H. Defined. Theorem svalue_inl_b_map_le : forall inl inl', b_map_le inl inl' -> forall v, svalue_inl_size v inl' <= svalue_inl_size v inl. Proof. intros. unfold svalue_inl_size. destruct v; simpl. destruct (get_b p inl) eqn:gbp. apply H in gbp. rewrite gbp; auto. destruct (get_b p inl'); lia. Qed. Theorem sub_size_le : forall sub inl inl', b_map_le inl inl' -> sub_inl_size sub inl' <= sub_inl_size sub inl. Proof. intros. do 2 (rewrite sub_inl_proof). remember (M.elements sub) as l. clear Heql. induction l. reflexivity. unfold list_inl_size in *. simpl. assert ( svalue_inl_size a inl' <= svalue_inl_size a inl) by (apply svalue_inl_b_map_le; auto). lia. Qed. Inductive b_map_le_i : b_map -> b_map -> Prop := | ble_refl: forall b, b_map_le_i b b | ble_add : forall b b' v, b_map_le_i b b' -> b_map_le_i b (M.set v true b'). Theorem b_map_le_c : forall b b', b_map_le_i b b' -> b_map_le b b'. 
* (1 + eps))%R. Proof with auto with typeclass_instances. intros m x. apply relative_error_lt_conversion... apply bpow_gt_0. now apply relative_error_F2R_emin. Qed.Theorem relative_error_round : (0 < p)%Z -> forall x, (bpow emin <= Rabs x)%R -> (Rabs (round beta fexp rnd x - x) < bpow (-p + 1) * Rabs (round beta fexp rnd x))%R. Proof with auto with typeclass_instances. intros Hp x Hx. assert (Hx': (x <> 0)%R). intros T; contradict Hx; rewrite T, Rabs_R0. apply Rlt_not_le, bpow_gt_0. apply Rlt_le_trans with (ulp beta fexp x)%R. now apply error_lt_ulp. rewrite ulp_neq_0; trivial. unfold canonic_exp. destruct (ln_beta beta x) as (ex, He). simpl. specialize (He Hx'). assert (He': (emin < ex)%Z). apply (lt_bpow beta). apply Rle_lt_trans with (2 := proj2 He). exact Hx. apply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R. rewrite <- bpow_plus. apply bpow_le. generalize (Hmin ex). omega. apply Rmult_le_compat_l. apply bpow_ge_0. generalize He. apply round_abs_abs... clear rnd valid_rnd x Hx Hx' He. intros rnd valid_rnd x _ Hx. rewrite <- (round_generic beta fexp rnd (bpow (ex - 1))). now apply round_le. apply generic_format_bpow. ring_simplify (ex - 1 + 1)%Z. generalize (Hmin ex). omega. Qed.Theorem relative_error_round_F2R_emin : (0 < p)%Z -> forall m, let x := F2R (Float beta m emin) in (x <> 0)%R -> (Rabs (round beta fexp rnd x - x) < bpow (-p + 1) * Rabs (round beta fexp rnd x))%R. Proof. intros Hp m x Hx. apply relative_error_round. exact Hp. unfold x. rewrite <- F2R_Zabs. apply bpow_le_F2R. apply F2R_lt_reg with beta emin. rewrite F2R_0, F2R_Zabs. now apply Rabs_pos_lt. Qed.Variable choice : Z -> bool.Theorem relative_error_N : forall x, (bpow emin <= Rabs x)%R -> (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * bpow (-p + 1) * Rabs x)%R. Proof. intros x Hx. apply Rle_trans with (/2 * ulp beta fexp x)%R. now apply error_le_half_ulp. rewrite Rmult_assoc. apply Rmult_le_compat_l. apply Rlt_le. apply Rinv_0_lt_compat. now apply (Z2R_lt 0 2). assert (Hx': (x <> 0)%R). intros H. apply Rlt_not_le with (2 := Hx). rewrite H, Rabs_R0. apply bpow_gt_0. rewrite ulp_neq_0; trivial. unfold canonic_exp. destruct (ln_beta beta x) as (ex, He). simpl. specialize (He Hx'). apply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R. rewrite <- bpow_plus. apply bpow_le. assert (emin < ex)%Z. apply (lt_bpow beta). apply Rle_lt_trans with (2 := proj2 He). exact Hx. generalize (Hmin ex). omega. apply Rmult_le_compat_l. apply bpow_ge_0. apply He. Qed. Theorem relative_error_N_ex : forall x, (bpow emin <= Rabs x)%R -> exists eps, (Rabs eps <= /2 * bpow (-p + 1))%R /\ round beta fexp (Znearest choice) x = (x * (1 + eps))%R. 
+ n = n. Admitted. Theorem plus_1_l : forall n:nat, 1 + n = S n. Admitted. Theorem mult_0_l : forall n:nat, 0 * n = 0. Admitted. Theorem plus_0_example: forall n, n = 17 -> n = 42. Admitted. Conjecture plus_id_example : forall n m : nat, n = m -> n + n = m + 0. QuickChick plus_id_example. | or_intror Hl0 => False_ind _ Hl0 end) (fun size0 IHs x (input0_ : A) hin => match hin with | or_introl Hr1 => _ | or_intror Hl1 => False_ind _ Hl1 end) s x input0_ Hin end end) _). - inversion Hr0; auto. - inversion Hr1; auto. - intros H; symmetry in H; move: H. apply eq_ind. eapply (ex_intro input0_). Defined. Defined. admit. Admitted. refine ((fun x' => ex_intro _ _) _). refine (ex_intro _). refine (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) _ x input0_). (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_). Definition s A (input0_ : A) := (fun x => conj (fun Hin => match Hin with | ex_intro s Hc => match Hc with | conj Hl Hin => nat_ind (fun n => forall x (input0_ : A), Basics.impl ((let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) x) ((@eq A) x input0_)) (fun x (input0_ : A) hin => match hin with | or_introl Hr0 => eq_ind _ _ (eq_refl _) _ Hr0 | or_intror Hl0 => False_ind _ Hl0 end) (fun size0 IHs x (input0_ : A) hin => match hin with | or_introl Hr1 => eq_ind _ _ (eq_refl _) _ Hr1 | or_intror Hl1 => False_ind _ Hl1 end) s x input0_ Hin end end) (eq_ind (fun _gen (input0_ : A) => bigcup setT (fun n => let fix aux_iter size0 (input0_ : A) := match size0 with | O => setU (set1 input0_) set0 | S size' => setU (set1 input0_) set0 end in aux_iter n input0_) _gen) (fun x => ex_intro _ (Coq.Init.Datatypes.S 0) (conj I (or_introl (Logic.eq_refl _)))) x input0_)). *) Theorem plus_id_exercise : forall n m o : nat, n = m -> m = o -> n + m = m + o. 
-> logs_sorted_nw (mkNetwork l st') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem logs_sorted_nw_no_append_entries : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. eapply logs_sorted_nw_only_new_packets_matter; eauto. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem logs_sorted_nw_not_append_entries : forall net ps' p' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold logs_sorted_nw in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_only_new_packets_matter : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_gt_prevIndex (mkNetwork l st') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_no_append_entries : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. intros. eapply packets_gt_prevIndex_only_new_packets_matter; eauto. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_not_append_entries : forall net ps' p' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. intros. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold packets_gt_prevIndex in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_ge_prevTerm_only_new_packets_matter : forall net ps' l st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_ge_prevTerm (mkNetwork l st') -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_ge_prevTerm_no_append_entries : forall net ps' l st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_ge_prevTerm (mkNetwork ps' st'). 
col_par_4 : forall A B C, Col A B C -> parallel B A B C. Proof. intros. unfold parallel, S4, Col in *. basic_simpl. uniformize_signed_areas. rewrite H. ring. Qed.Hint Resolve col_par_1 col_par_2 col_par_3 col_par_4 : Geom. Lemma par_col_col_1 : forall A B C D, parallel A B C D -> Col A B C -> Col A B D. Proof. intros. unfold parallel,S4,Col in *. uniformize_signed_areas. RewriteVar (S A B D) H. replace (- (1) * S A C B) with (- S A C B) by ring. auto. Qed.Lemma par_col_col_2 : forall A B C D, parallel A B C D -> Col A B D -> Col A B C. Proof. intros. assert (parallel A B D C). Geometry. eapply par_col_col_1;eauto. Qed.Lemma par_col_col_3 : forall A B C D, parallel A B C D -> Col A C D -> Col B C D. Proof with Geometry. intros. cut (Col C D B). Geometry. assert (parallel C D A B). Geometry. eapply par_col_col_1;eauto... Qed.Lemma par_col_col_4 : forall A B C D, parallel A B C D -> Col B C D -> Col A C D. Proof. intros. cut (Col C D A). Geometry. assert (parallel C D B A). Geometry. eapply par_col_col_1;eauto. Geometry. Qed.Theorem common_point_not_par : forall A B C D Y : Point, Col Y A B -> Col Y C D -> A <> B -> C <> D -> ~ Col Y A C -> ~ parallel A B C D. Proof with Geometry. intros. cases_col D A B. unfold parallel, S4 in |- *. cut (Y = D). intro. assert (S A B D = S D A B)... rewrite H6. rewrite H4. unfold not in |- *. intro. NormalizeRing H7. clear H H0. rewrite H5 in H3. clear H5. clear H6. assert (Col A B D)... assert (Col A B C)... assert (Col A D C); eauto with Geom. assert (Col A B Y)... assert (Col A B D)... assert (Col A Y D); eauto with Geom. assert (A <> Y); eauto with Geom. cases_equality Y D. auto. assert (Col Y D A)... assert (Col Y D C)... assert (Col Y A C); eauto with Geom. intuition. eapply common_point_not_par_aux; apply H || auto. Qed.Definition parallelogram (A B C D : Point) : Prop := parallel A B C D /\ parallel B C A D /\ ~ Col A B C. Theorem l1_24 : forall A B C D O : Point, parallelogram A B C D -> Col A C O -> Col B D O -> A ** O = O ** C. 
H'2; intros H'3 H'4; try exact H'4; clear H'2 E H'0 H' ]. case (Rle_or_lt a r); intros H'1. right; exists a; repeat split; auto. intros f H'; elim H'; [ intros H'2; rewrite <- H'2; clear H' | intros H'2; clear H' ]; auto with real. intros H'; Contradict H'; auto with real. apply Rlt_not_le; auto with real. left; intros f H'; elim H'; [ intros H'2; rewrite <- H'2; clear H' | intros H'2; clear H' ]; auto. case (Rle_or_lt a min); intros H'5. right; exists min; repeat split; auto. intros f H'; elim H'; [ intros H'0; rewrite <- H'0; clear H' | intros H'0; clear H' ]; auto. case (Rle_or_lt a r); intros H'6. right; exists a; repeat split; auto. intros f H'; elim H'; [ intros H'0; rewrite <- H'0; clear H' | intros H'0; clear H' ]; auto with real. intros H'; apply Rle_trans with (FtoRradix min); auto with real. right; exists min; split; auto; split; auto. intros f H'; elim H'; [ intros H'0; elim H'0; clear H' | intros H'0; clear H' ]; auto. intros H'; Contradict H'6; auto with real. apply Rle_not_lt; auto. Qed. Theorem MinEx : forall r : R, exists min : float, isMin r min. intros r. case (MinExList r (mBFloat r)). intros H'0; absurd (Fopp (boundR r) <= r)%R; auto. apply Rlt_not_le. apply H'0. apply mBFadic_correct3; auto.apply Rlt_le. apply boundRCorrect2; auto. intros H'0; elim H'0; intros min E; elim E; intros H'1 H'2; elim H'2; intros H'3 H'4; clear H'2 E H'0. exists min; split; auto. apply mBPadic_Fbounded with (r := r); auto. split; auto. intros f H'0 H'2. case (Req_dec f 0); intros H'6. replace (FtoRradix f) with (FtoRradix (Float 0%nat (- dExp b))). apply H'4; auto. apply mBFadic_correct4; auto. replace (FtoRradix (Float 0%nat (- dExp b))) with (FtoRradix f); auto. rewrite H'6. unfold FtoRradix, FtoR in |- *; simpl in |- *; auto with real. rewrite H'6. unfold FtoRradix, FtoR in |- *; simpl in |- *; auto with real. case (Rle_or_lt f (Fopp (boundR r))); intros H'5. apply Rle_trans with (FtoRradix (Fopp (boundR r))); auto. apply H'4; auto. apply mBFadic_correct3; auto. apply Rlt_le. apply boundRCorrect2; auto. case (Rle_or_lt (boundR r) f); intros H'7. Contradict H'2; apply Rlt_not_le. apply Rlt_le_trans with (FtoRradix (boundR r)); auto. apply boundRCorrect1; auto. apply H'4; auto. apply mBFadic_correct1; auto. Contradict H'6; unfold FtoRradix in |- *; apply is_Fzero_rep1; auto. Qed. Theorem MaxEx : forall r : R, exists max : float, isMax r max. 
H1; auto. Qed. Theorem FboundedExp : forall (b : Fbound) (p : float), Fbounded b p -> (- dExp b <= Fexp p)%Z. intros b p H; case H; auto. Qed. Hint Resolve FboundedNum FboundedExp: float. Theorem isBounded : forall (b : Fbound) (p : float), {Fbounded b p} + {~ Fbounded b p}. intros b p; case (Z_le_gt_dec (Zpos (vNum b)) (Zabs (Fnum p))); intros H'. right; red in |- *; intros H'3; Contradict H'; auto with float zarith. case (Z_le_gt_dec (- dExp b) (Fexp p)); intros H'1. left; repeat split; auto with zarith. right; red in |- *; intros H'3; Contradict H'1; auto with float zarith. Qed. Theorem FzeroisZero : forall b : Fbound, Fzero (- dExp b) = 0%R :>R. intros b; unfold FtoRradix, FtoR in |- *; simpl in |- *; auto with real. Qed. Theorem FboundedFzero : forall b : Fbound, Fbounded b (Fzero (- dExp b)). intros b; repeat (split; simpl in |- *). replace 0%Z with (- 0%nat)%Z; [ idtac | simpl in |- *; auto ]. apply Zeq_le; auto with arith. Qed. Hint Unfold Fbounded. Theorem FboundedZeroSameExp : forall (b : Fbound) (p : float), Fbounded b p -> Fbounded b (Fzero (Fexp p)). intros b p H'; (repeat split; simpl in |- *; auto with float zarith). Qed. Theorem FBoundedScale : forall (b : Fbound) (p : float) (n : nat), Fbounded b p -> Fbounded b (Float (Fnum p) (Fexp p + n)). intros b p n H'; repeat split; simpl in |- *; auto with float. apply Zle_trans with (Fexp p); auto with float. pattern (Fexp p) at 1 in |- *; (replace (Fexp p) with (Fexp p + 0%nat)%Z; [ idtac | simpl in |- *; ring ]). apply Zplus_le_compat_l. apply inj_le; auto with arith. Qed. Theorem FvalScale : forall (b : Fbound) (p : float) (n : nat), Float (Fnum p) (Fexp p + n) = (powerRZ radix n * p)%R :>R. intros b p n; unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite powerRZ_add; auto with real zarith. ring. Qed. Theorem oppBounded : forall (b : Fbound) (x : float), Fbounded b x -> Fbounded b (Fopp x). intros b x H'; repeat split; simpl in |- *; auto with float zarith. replace (Zabs (- Fnum x)) with (Zabs (Fnum x)); auto with float. case (Fnum x); simpl in |- *; auto. Qed. Theorem oppBoundedInv : forall (b : Fbound) (x : float), Fbounded b (Fopp x) -> Fbounded b x. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main. Class Terminal (C : Category) : Type := { terminal : C; t_morph : ‚àÄ (d : Obj), (d --> terminal)%morphism; t_morph_unique : ‚àÄ (d : Obj) (f g : (d --> terminal)%morphism), f = g }.Arguments terminal {_} _. Arguments t_morph {_} _ _. Arguments t_morph_unique {_} _ _ _ _.Coercion terminal : Terminal >-> Obj.Notation "ùüô_ C" := (Terminal C) (at level 75) : object_scope. Theorem Terminal_iso {C : Category} (T T' : (ùüô_ C)%object) : (T ‚âÉ T')%isomorphism. 
Instance _eta : Settable t := settable! mk <blocks>. Global Instance _witness : Inhabited t := populate!. End s_inode.Section goose. Context `{!heapGS Œ£}. Context `{!allocG Œ£}. Context `{!stagedG Œ£}. Context `{!ghost_varG Œ£ (list Block)}. Implicit Types (l:loc) (œÉ: s_inode.t) (Œ≥: gname). Context (N: namespace). Let s_inodeN := N.@"single_inode". Let allocN := N.@"allocator". Let inodeN := N.@"inode". Context (P: s_inode.t ‚Üí iProp Œ£). Local Definition Pinode Œ≥blocks Œ≥used (s: inode.t): iProp Œ£ := "Hownblocks" ‚à∑ ghost_var Œ≥blocks (1/2) s.(inode.blocks) ‚àó "Hused1" ‚à∑ ghost_var Œ≥used (1/2) (s.(inode.addrs)). Local Definition Palloc Œ≥used (s: alloc.t): iProp Œ£ := "Hused2" ‚à∑ ghost_var Œ≥used (1/2) (alloc.used s). Definition s_inode_inv Œ≥blocks (blocks: s_inode.t): iProp Œ£ := "HŒ≥blocks" ‚à∑ ghost_var Œ≥blocks (1/2) (blocks.(s_inode.blocks)). Definition s_inode_state l (inode_ref alloc_ref: loc) : iProp Œ£ := "#i" ‚à∑ readonly (l ‚Ü¶[SingleInode :: "i"] #inode_ref) ‚àó "#alloc" ‚à∑ readonly (l ‚Ü¶[SingleInode :: "alloc"] #alloc_ref). Local Definition allocŒ® (a: u64): iProp Œ£ := ‚àÉ b, int.Z a d‚Ü¶ b. Definition pre_s_inode l (sz: Z) œÉ : iProp Œ£ := ‚àÉ inode_ref alloc_ref Œ≥used Œ≥blocks, "#Hstate" ‚à∑ s_inode_state l inode_ref alloc_ref ‚àó "Hs_inv" ‚à∑ s_inode_inv Œ≥blocks œÉ ‚àó "Hinode" ‚à∑ (‚àÉ s_inode, "Hpre_inode" ‚à∑ pre_inode inode_ref (U64 0) s_inode ‚àó "HPinode" ‚à∑ Pinode Œ≥blocks Œ≥used s_inode) ‚àó "Halloc" ‚à∑ (‚àÉ s_alloc, "Halloc_mem" ‚à∑ is_allocator_mem_pre alloc_ref s_alloc ‚àó "%Halloc_dom" ‚à∑ ‚åúalloc.domain s_alloc = rangeSet 1 (sz-1)‚åù ‚àó "Hunused" ‚à∑ ([‚àó set] k ‚àà alloc.unused s_alloc, allocŒ® k) ‚àó "HPalloc" ‚à∑ Palloc Œ≥used s_alloc). Definition is_single_inode l (sz: Z) : iProp Œ£ := ‚àÉ (inode_ref alloc_ref: loc) Œ≥alloc Œ≥used Œ≥blocks, "Hro_state" ‚à∑ s_inode_state l inode_ref alloc_ref ‚àó "#Hinode" ‚à∑ is_inode inodeN inode_ref (Pinode Œ≥blocks Œ≥used) (U64 0) ‚àó "#Halloc" ‚à∑ is_allocator (Palloc Œ≥used) allocŒ® allocN alloc_ref (rangeSet 1 (sz-1)) Œ≥alloc ‚àó "#Hinv" ‚à∑ ncinv s_inodeN (‚àÉ œÉ, s_inode_inv Œ≥blocks œÉ ‚àó P œÉ) . Definition s_inode_cinv sz œÉ (post_crash: bool) : iProp Œ£ := ‚àÉ Œ≥blocks Œ≥used, "Hinode" ‚à∑ (‚àÉ s_inode, "Hinode_cinv" ‚à∑ inode_cinv (U64 0) s_inode ‚àó "HPinode" ‚à∑ Pinode Œ≥blocks Œ≥used s_inode) ‚àó "Halloc" ‚à∑ alloc_crash_cond (Palloc Œ≥used) allocŒ® (rangeSet 1 (sz-1)) post_crash ‚àó "Hs_inode" ‚à∑ s_inode_inv Œ≥blocks œÉ . Local Hint Extern 1 (environments.envs_entails _ (s_inode_cinv _ _ _)) => unfold s_inode_cinv : core. Theorem s_inode_cinv_post_crash sz œÉ : s_inode_cinv sz œÉ true -‚àó s_inode_cinv sz œÉ false. Proof. iNamed 1. iExists _, _; iFrame. iApply (alloc_crash_cond_from_post_crash with "[$]"). Qed. Instance s_inode_inv_Timeless Œ≥blocks blocks : Timeless (s_inode_inv Œ≥blocks blocks). Proof. apply _. Qed. Theorem init_single_inode {E} (sz: Z) : (1 ‚â§ sz < 2^64)%Z ‚Üí ([‚àó list] i ‚àà seqZ 0 sz, i d‚Ü¶ block0) ={E}=‚àó let œÉ0 := s_inode.mk [] in s_inode_cinv sz œÉ0 true. 
Inductive day : Type := | monday : day | tuesday : day | wednesday : day | thursday : day | friday : day | saturday : day | sunday : day .Definition tomorrow (d: day) : day := match d with | monday => tuesday | tuesday => wednesday | wednesday => thursday | thursday => friday | friday => saturday | saturday => sunday | sunday => monday end.Theorem test_tomorrow: tomorrow saturday = sunday. Proof. simpl. reflexivity. Qed. Inductive natlist : Type := | nil : natlist | cons : nat -> natlist -> natlist .Definition empty_list := nil.Definition singleton_list := cons 42 nil.Definition one_two_three := cons 1 (cons 2 (cons 3 nil)).Fixpoint concat (l1 l2 : natlist) : natlist := match l1 with | nil => l2 | cons h t => cons h (concat t l2) end.Theorem test_concat1: concat (cons 1 (cons 2 nil)) (cons 3 (cons 4 nil)) = (cons 1 (cons 2 (cons 3 (cons 4 nil)))). Proof. simpl. reflexivity. Qed. Theorem concat_nil_left : forall l : natlist, concat nil l = l. Proof. Qed.Theorem concat_nil_right : forall l : natlist, concat l nil = l. Proof. Qed. Theorem concat_associativity : forall l2 l1 l3 : natlist, concat (concat l1 l2) l3 = concat l1 (concat l2 l3). Proof. Qed. Fixpoint snoc (l: natlist) (v: nat) : natlist := match l with | nil => cons v nil | cons h t => cons h (snoc t v) end. Fixpoint rev (l: natlist) : natlist := match l with | nil => nil | cons h t => snoc (rev t) h end. Theorem rev_snoc : forall x l, rev (snoc l x) = cons x (rev l). 
suffices: (p %| 1)%C by rewrite (dvdC_nat p 1) dvdn1 -(subnKC (prime_gt1 p_pr)). rewrite unfold_in (negPf nz_p). rewrite Cint_rat_Aint ?rpred_div ?rpred1 ?rpred_nat //. rewrite -rpredN // -mulNr -Dalpha rpred_sum // => i /andP[/dvdCP[c Zc ->] _]. by rewrite mulfK // rpredM ?Aint_irr ?Aint_Cint. Qed.End IntegralChar.Section MoreIntegralChar.Implicit Type gT : finGroupType. Theorem Burnside_p_a_q_b gT (G : {group gT}) : (size (primes #|G|) <= 2)%N -> solvable G. Proof. move: {2}_.+1 (ltnSn #|G|) => n; elim: n => // n IHn in gT G *. rewrite ltnS => leGn piGle2; have [simpleG | ] := boolP (simple G); last first. rewrite negb_forall_in => /exists_inP[N sNG]; rewrite eq_sym. have [-> | ] := altP (N =P G). rewrite groupP /= genGid normG andbT eqb_id negbK => /eqP->. exact: solvable1. rewrite [N == G]eqEproper sNG eqbF_neg !negbK => ltNG /and3P[grN]. case/isgroupP: grN => {N}N -> in sNG ltNG *; rewrite /= genGid => ntN nNG. have nsNG: N <| G by apply/andP. have dv_le_pi m: (m %| #|G| -> size (primes m) <= 2)%N. move=> m_dv_G; apply: leq_trans piGle2. by rewrite uniq_leq_size ?primes_uniq //; apply: pi_of_dvd. rewrite (series_sol nsNG) !IHn ?dv_le_pi ?cardSg ?dvdn_quotient //. by apply: leq_trans leGn; apply: ltn_quotient. by apply: leq_trans leGn; apply: proper_card. have [->|[p p_pr p_dv_G]] := trivgVpdiv G; first exact: solvable1. have piGp: p \in \pi(G) by rewrite mem_primes p_pr cardG_gt0. have [P sylP] := Sylow_exists p G; have [sPG pP p'GP] := and3P sylP. have ntP: P :!=: 1%g by rewrite -rank_gt0 (rank_Sylow sylP) p_rank_gt0. have /trivgPn[g /setIP[Pg cPg] nt_g]: 'Z(P) != 1%g. by rewrite center_nil_eq1 // (pgroup_nil pP). apply: abelian_sol; have: (size (primes #|g ^: G|) <= 1)%N. rewrite -ltnS -[_.+1]/(size (p :: _)) (leq_trans _ piGle2) //. rewrite -index_cent1 uniq_leq_size // => [/= | q]. rewrite primes_uniq -p'natEpi ?(pnat_dvd _ p'GP) ?indexgS //. by rewrite subsetI sPG sub_cent1. by rewrite inE => /predU1P[-> // |]; apply: pi_of_dvd; rewrite ?dvdn_indexg. rewrite leqNgt; apply: contraR => /primes_class_simple_gt1-> //. by rewrite !inE classG_eq1 nt_g mem_classes // (subsetP sPG). Qed. Theorem dvd_irr1_cardG gT (G : {group gT}) i : ('chi[G]_i 1%g %| #|G|)%C. Proof. rewrite unfold_in -if_neg irr1_neq0 Cint_rat_Aint //=. by rewrite rpred_div ?rpred_nat // rpred_Cnat ?Cnat_irr1. rewrite -[n in n / _]/(_ *+ true) -(eqxx i) -mulr_natr. rewrite -first_orthogonality_relation mulVKf ?neq0CG //. rewrite sum_by_classes => [|x y Gx Gy]; rewrite -?conjVg ?cfunJ //. rewrite mulr_suml rpred_sum // => K /repr_classesP[Gx {1}->]. by rewrite !mulrA mulrAC rpredM ?Aint_irr ?Aint_class_div_irr1. Qed. Theorem dvd_irr1_index_center gT (G : {group gT}) i : ('chi[G]_i 1%g %| #|G : 'Z('chi_i)%CF|)%C. 
Hole_c fds2)) e)). rewrite comp_ctx_f_assoc. simpl. auto. - apply H. destructAll. apply comp_ctx_split in H0. destruct H0. + destructAll. destruct x2; inv H0. eauto. + destructAll. destruct x3; inv H2. apply fundex_ctx_comp_f_ctx in H1. inv H1. - apply H in H0. destructAll. exists x. exists (comp_ctx_f x0 (Efun2_c (fundefs_ctx_append fds1 (Fcons1_c v f l Hole_c fds2)) e)). exists x1, x2. rewrite comp_ctx_f_assoc. auto. - apply H. destructAll. apply comp_ctx_split in H0. destruct H0. + destructAll. destruct x3; inv H0. eauto. + destructAll. destruct x4; inv H2. apply fundex_ctx_comp_f_ctx in H1. inv H1. Qed. Theorem cmap_view_constr: forall {sub c} x t xs, cmap_view_ctx sub c -> M.get x sub = None -> cmap_view_ctx (M.set x (SVconstr t xs) sub) (comp_ctx_f c (Econstr_c x t xs Hole_c)). Proof. intros; split; intros; split; intros. - destruct (var_dec x0 x). + exists c, Hole_c. subst. rewrite M.gss in H1. inv H1. auto. + rewrite M.gso in H1 by auto. apply H in H1. destructAll. exists x1, (comp_ctx_f x2 (Econstr_c x t xs Hole_c)). rewrite comp_ctx_f_assoc. simpl. auto. - destructAll. apply comp_ctx_split in H1. destruct H1. + destructAll. destruct x3; inv H1. * rewrite M.gss. auto. * rewrite M.gso. 2:{ intro. subst. destruct H. specialize (H x c l). assert ((exists c' c'' : exp_ctx, comp_ctx_f x1 (Econstr_c x c l x3) = comp_ctx_f c' (Econstr_c x c l c''))) by eauto. apply H in H2. rewrite H0 in H2. inv H2. } apply H. eauto. + destructAll. destruct x4; inv H3. * rewrite M.gss; auto. * destruct x4; inv H6. - rewrite M.gso in H1. apply H in H1. destructAll. exists x0. exists (comp_ctx_f x1 (Econstr_c x t xs Hole_c)). rewrite comp_ctx_f_assoc. simpl. eauto. intro. subst. rewrite M.gss in H1. inv H1. - destructAll. rewrite M.gso. apply H. apply comp_ctx_split in H1. destruct H1. + destructAll; subst. destruct x4; inv H1. eauto. + destructAll. destruct x5; inv H3. destruct x5; inv H6. + intro; subst. apply comp_ctx_split in H1. destruct H1. * destructAll; subst. destruct x4; inv H1. destruct H. specialize (H1 x t0 ys e). assert (exists (c' c'' : exp_ctx) (B1 B2 : fundefs), comp_ctx_f x0 (Efun1_c (fundefs_append x2 (Fcons x t0 ys e x3)) x4) = comp_ctx_f c' (Efun1_c (fundefs_append B1 (Fcons x t0 ys e B2)) c'')) by eauto. apply H1 in H2. rewrite H0 in H2. inv H2. * destructAll. destruct x5; inv H3. destruct x5; inv H6. Qed. Theorem cmap_view_prim: forall sub c v p l, cmap_view_ctx sub c -> cmap_view_ctx sub (comp_ctx_f c (Eprim_c v p l Hole_c)). 
Require Import Coq.Sets.Ensembles Bedrock.Platform.AutoSep.Require Import Bedrock.Platform.Malloc Bedrock.Platform.Facade.examples.SeqF. Module Type ADT. Parameter lseq : list W -> W -> HProp. Parameter lseq' : list W -> W -> HProp. Axiom lseq_fwd : forall ls c, lseq ls c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p. Axiom lseq_bwd : forall ls (c : W), ([| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p) ===> lseq ls c. Axiom lseq'_empty_fwd : forall ls (c : W), c = 0 -> lseq' ls c ===> [| ls = nil |]. Axiom lseq'_empty_bwd : forall ls (c : W), c = 0 -> [| ls = nil |] ===> lseq' ls c. Axiom lseq'_nonempty_fwd : forall ls (c : W), c <> 0 -> lseq' ls c ===> Ex x, Ex ls', [| ls = x :: ls' |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls' p'. Axiom lseq'_nonempty_bwd : forall ls (c : W), c <> 0 -> (Ex x, Ex ls', [| ls = x :: ls' |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls' p') ===> lseq' ls c. Axiom lseq'_cons_fwd : forall x ls (c : W), lseq' (x :: ls) c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls p'. End ADT.Module Adt : ADT. Open Scope Sep_scope. Fixpoint lseq' (ls : list W) (p : W) : HProp := match ls with | nil => [| p = 0 |] | x :: ls' => [| p <> 0 |] * [| freeable p 2 |] * Ex p', (p ==*> x, p') * lseq' ls' p' end. Definition lseq (ls : list W) (c : W) : HProp := [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p. Theorem lseq_fwd : forall ls c, lseq ls c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p. 
(x,y) => y end.Definition swap_pair (p : natprod) : natprod := match p with | (x,y) => (y,x) end.Theorem surjective_pairing' : forall (n m : nat), (n,m) = (fst (n,m), snd (n,m)). Admitted. Theorem surjective_pairing : forall (p : natprod), p = (fst p, snd p). Admitted. Theorem snd_fst_is_swap : forall (p : natprod), (snd p, fst p) = swap_pair p. Admitted. Theorem fst_swap_is_snd : forall (p : natprod), fst (swap_pair p) = snd p. Admitted. Inductive natlist : Type := | nil : natlist | cons : nat -> natlist -> natlist.Instance dec_natlist (p q : natlist) : Dec (p = q). Proof. constructor; unfold decidable; repeat decide equality. Defined. Derive Arbitrary for natlist. Derive Show for natlist. Derive Sized for natlist. Derive CanonicalSized for natlist. Derive SizeMonotonic for natlist using genSnatlist. Derive SizedMonotonic for natlist. Derive SizedCorrect for natlist using genSnatlist and SizeMonotonicnatlist.Notation "x :: l" := (cons x l) (at level 60, right associativity). Notation "[ ]" := nil. Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).Fixpoint repeat (n count : nat) : natlist := match count with | O => nil | S count' => n :: (repeat n count') end.Fixpoint length (l:natlist) : nat := match l with | nil => O | h :: t => S (length t) end.Fixpoint app (l1 l2 : natlist) : natlist := match l1 with | nil => l2 | h :: t => h :: (app t l2) end.Notation "x ++ y" := (app x y) (right associativity, at level 60).Definition hd (default:nat) (l:natlist) : nat := match l with | nil => default | h :: t => h end.Definition tl (l:natlist) : natlist := match l with | nil => nil | h :: t => t end.Theorem nil_app : forall l:natlist, [] ++ l = l. Admitted. Theorem tl_length_pred : forall l:natlist, pred (length l) = length (tl l). Admitted. Theorem app_assoc : forall l1 l2 l3 : natlist, (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3). Admitted. Fixpoint rev (l:natlist) : natlist := match l with | nil => nil | h :: t => rev t ++ [h] end.Theorem app_length : forall l1 l2 : natlist, length (l1 ++ l2) = (length l1) + (length l2). Admitted. Theorem rev_length : forall l : natlist, length (rev l) = length l. Admitted. Theorem app_nil_r : forall l : natlist, l ++ [] = l. 
pr1 (X0 x)). intro t . assert (s1: forall x:X, paths (t x) (pr1 (X0 x))). intro. apply proofirrelevancecontr. apply (X0 x). apply funextsec. assumption. intros X Y X0. simpl. assert (X1: X -> isofhlevel (S n) (X -> Y)). intro X1 . apply impred. assumption. intros x x' . assert (s1: isofhlevel n (forall xx:X, paths (x xx) (x' xx))). apply impred. intro t . apply (X0 t). assert (w: weq (forall xx:X, paths (x xx) (x' xx)) (paths x x')). apply (weqfunextsec _ x x' ). apply (isofhlevelweqf n w s1). Defined. Theorem iscontrfuntounit ( X : UU ) : iscontr ( X -> unit ) . Proof . intro . split with ( fun x : X => tt ) . intro f . apply funextfun . intro x . destruct ( f x ) . apply idpath . Defined .Theorem iscontrfuntocontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : iscontr ( X -> Y ) . Proof . intros . set ( w := weqcontrtounit is ) . set ( w' := weqffun X w ) . apply ( iscontrweqb w' ( iscontrfuntounit X ) ) . Defined . Lemma isapropimpl ( X Y : UU ) ( isy : isaprop Y ) : isaprop ( X -> Y ) . Proof. intros. apply impred. intro. assumption. Defined. Theorem isapropneg2 ( X : UU ) { Y : UU } ( is : neg Y ) : isaprop ( X -> Y ) . Proof . intros . apply impred . intro . apply ( isapropifnegtrue is ) . Defined . Theorem iscontriscontr { X : UU } ( is : iscontr X ) : iscontr ( iscontr X ). Proof. intros X X0 . assert (is0: forall (x x':X), paths x x'). apply proofirrelevancecontr. assumption.assert (is1: forall cntr:X, iscontr (forall x:X, paths x cntr)). intro. assert (is2: forall x:X, iscontr (paths x cntr)). assert (is2: isaprop X). apply isapropifcontr. assumption. unfold isaprop in is2. unfold isofhlevel in is2. intro x . apply (is2 x cntr). apply funcontr. assumption. set (f:= @pr1 X (fun cntr:X => forall x:X, paths x cntr)). assert (X1:isweq f). apply isweqpr1. assumption. change (total2 (fun cntr : X => forall x : X, paths x cntr)) with (iscontr X) in X1. apply (iscontrweqb ( weqpair f X1 ) ) . assumption. Defined. Theorem isapropiscontr (T:UU): isaprop (iscontr T). 
+ revert Hcv2 Hcb2. apply Ht. + revert Hcv0 Hcb0. apply Ht. - introv comp. apply Hab4 in comp; exrepnd. apply Hbc4 in comp1; exrepnd. eexists; dands; eauto. Qed.Lemma sqlen_n_trans {o} : forall lib n, trans_rel (@sqle_n o lib n). Proof. induction n; intros a b c Hab Hbc; invertsn Hab; invertsn Hbc; constructor; auto;[]. revert Hab Hbc. apply trans_rel_close_comput; eauto with respects. Qed.Lemma trans_rel_olift_sqlen {o} : forall lib n, trans_rel (lblift (olift (@sqle_n o lib n))). Proof. intros. apply trans_lblift; eauto with respects;[]. apply sqlen_n_trans. Qed.Theorem sqlen_closed {o} : forall lib n, is_rel_on_progs (@sqle_n o lib n). Proof. induction n as [| n Hind]; intros t1 t2 Hsq; invertsn Hsq; auto. rename Hsq into Hclose. unfold close_comput in Hclose. sp; auto. Qed.Definition sqle {o} lib (tl tr : @NTerm o) := forall n, sqle_n lib n tl tr. Definition sq_closure {o} lib := fun (R : @NTerm o -> @NTerm o -> [univ]) => is_rel_on_progs R # le_bin_rel R (close_comput lib R).Theorem sqle_ge_postfixpoint {o} : forall lib, is_ge_any_rel_sat (sqle lib) (@sq_closure o lib). Proof. unfold is_ge_any_rel_sat, le_bin_rel, sq_closure. auto. intros lib Rp Hsat a b Hrp n. gen a b. repnd. induction n; intros a b Hrp; constructor; try (apply Hsat0 in Hrp; sp; auto; fail). apply Hsat in Hrp. clear Hsat. allunfold @close_comput; repnd. repeat(split;auto). - intros c tl_subterms Hcv. apply Hrp2 in Hcv. exrepnd. exists tr_subterms. sp; auto. clear Hcv1. gen tl_subterms tr_subterms. fold (@le_bin_rel NTerm Rp (sqle_n lib n)) in IHn. fold (@le_bin_rel (list BTerm ) (lblift Rp) (lblift (sqle_n lib n)) ) . apply le_lblift. apply le_olift in IHn. auto. - introv ce. apply Hrp3 in ce; exrepnd. exists a' e'; auto. - introv comp. apply Hrp4 in comp; exrepnd. eexists; dands; eauto. Qed. Theorem close_comput_mono {o}: forall lib R1 R2, (le_bin_rel R1 R2) -> le_bin_rel (@close_comput o lib R1) (close_comput lib R2). Proof. intros ? ? ? Hle. intros ? ? Hcr1. allunfold @close_comput. repnd. repeat(split;auto). - intros ? ? Hcomp. apply Hcr3 in Hcomp. parallel tr_subterms Hrelbt. repnd. split;auto. allunfold @lblift. exrepnd. dands;sp. eapply le_blift_olift; eauto. - introv ce. apply Hcr4 in ce; exrepnd. exists a' e'; auto. - introv comp. apply Hcr5 in comp; exrepnd. eexists; dands; eauto. Qed.Definition nt_id_prog {o} := fun x y : @NTerm o => isprogram x # isprogram y # x = y. Theorem sqle_suff_necc: eq_bin_rel (close_comput sqle) (sqle). Proof. intros. split. apply sqle_suff. apply sqle_closure. Qed. Theorem id_sq_closure: sq_closure nt_id_prog. 
From RecordUpdate Require Import RecordSet. From Tactical Require Import SimplMatch.From Perennial.Helpers Require Export NamedProps List Integers Tactics.From Perennial.program_proof Require Import disk_prelude. From Perennial.program_proof Require Export wal.lib wal.highest. From Perennial.program_proof Require Export wal.boundaries.Set Default Goal Selector "!". Set Default Proof Using "Type".Module slidingM. Record t := mk { log: list update.t; start: u64; mutable: u64; }. Global Instance _eta : Settable _ := settable! mk <log; start; mutable>. Global Instance _witness : Inhabited t := populate!. Definition endPos (œÉ:t): u64 := word.add œÉ.(start) (U64 $ Z.of_nat $ length œÉ.(log)). Definition memEnd œÉ : Z := int.Z œÉ.(start) + length œÉ.(log). Definition numMutable (œÉ:t): u64 := word.sub œÉ.(mutable) œÉ.(start). Definition addrPosMap (œÉ:t): gmap u64 u64 := compute_memLogMap œÉ.(log) œÉ.(start). Definition logIndex (œÉ:t) (pos: u64) : nat := (int.nat pos - int.nat œÉ.(start))%nat. Definition wf (œÉ:t) := int.Z œÉ.(start) ‚â§ int.Z œÉ.(mutable) ‚àß int.Z œÉ.(start) + length œÉ.(log) < 2^64 ‚àß int.Z œÉ.(mutable) - int.Z œÉ.(start) <= length œÉ.(log). Theorem memEnd_ok œÉ : wf œÉ -> int.Z (endPos œÉ) = memEnd œÉ. 
-> B) l, map f (concat l) = concat (map (map f) l). Proof. intros A B f l; induction l as [|x l IH]; simpl. + reflexivity. + rewrite map_app, IH; reflexivity. Qed.Lemma map_id : forall (A :Type) (l : list A), map (fun x => x) l = l. Proof. induction l; simpl; auto; rewrite IHl; auto. Qed.Lemma map_map : forall (A B C:Type)(f:A->B)(g:B->C) l, map g (map f l) = map (fun x => g (f x)) l. Proof. induction l; simpl; auto. rewrite IHl; auto. Qed.Lemma map_ext_in : forall (A B : Type)(f g:A->B) l, (forall a, In a l -> f a = g a) -> map f l = map g l. Proof. induction l; simpl; auto. intros; rewrite H by intuition; rewrite IHl; auto. Qed.Lemma map_ext : forall (A B : Type)(f g:A->B), (forall a, f a = g a) -> forall l, map f l = map g l. Proof. intros; apply map_ext_in; auto. Qed. Section Fold_Left_Recursor. Variables (A : Type) (B : Type). Variable f : A -> B -> A. Fixpoint fold_left (l:list B) (a0:A) : A := match l with | nil => a0 | cons b t => fold_left t (f a0 b) end. Lemma fold_left_app : forall (l l':list B)(i:A), fold_left (l++l') i = fold_left l' (fold_left l i). Proof. induction l. simpl; auto. intros. simpl. auto. Qed.End Fold_Left_Recursor.Lemma fold_left_length : forall (A:Type)(l:list A), fold_left (fun x _ => S x) l 0 = length l. Proof. intros A l. enough (H : forall n, fold_left (fun x _ => S x) l n = n + length l) by exact (H 0). induction l; simpl; auto. intros; rewrite IHl. simpl; auto with arith. Qed.Section Fold_Right_Recursor. Variables (A : Type) (B : Type). Variable f : B -> A -> A. Variable a0 : A. Fixpoint fold_right (l:list B) : A := match l with | nil => a0 | cons b t => f b (fold_right t) end.End Fold_Right_Recursor. Lemma fold_right_app : forall (A B:Type)(f:A->B->B) l l' i, fold_right f i (l++l') = fold_right f (fold_right f i l') l. Proof. induction l. simpl; auto. simpl; intros. f_equal; auto. Qed. Lemma fold_left_rev_right : forall (A B:Type)(f:A->B->B) l i, fold_right f i (rev l) = fold_left (fun x y => f y x) l i. Proof. induction l. simpl; auto. intros. simpl. rewrite fold_right_app; simpl; auto. Qed. Theorem fold_symmetric : forall (A : Type) (f : A -> A -> A), (forall x y z : A, f x (f y z) = f (f x y) z) -> forall (a0 : A), (forall y : A, f a0 y = f y a0) -> forall (l : list A), fold_left f l a0 = fold_right f a0 l. 
(p&M). { split~. } { exists~ p. } Qed. Theorem state_star_pure_r: forall P H h, (H \* \[P]) h = (H h /\ P). Proof. intros. rewrite hstar_comm. rewrite state_star_pure_l. apply* prop_ext. Qed. Theorem himpl_state_star_pure_r: forall P H H', P -> (H ==> H') -> H ==> (\[P] \* H'). Proof. introv HP W. intros h K. rewrite* state_star_pure_l. Qed. Theorem state_pure_inv_hempty: forall P h, \[P] h -> P /\ \[] h. Proof. introv M. rewrite <- state_star_pure_l. rewrite~ hstar_hempty_r. Qed. Theorem state_pure_intro_hempty: forall P h, \[] h -> P -> \[P] h. Proof. introv M N. rewrite <- (hstar_hempty_l \[P]). rewrite~ state_star_pure_r. Qed. Theorem himpl_hempty_state_pure: forall P, P -> \[] ==> \[P]. Proof. introv HP. intros h Hh. applys* state_pure_intro_hempty. Qed. Theorem himpl_state_star_pure_l: forall P H H', (P -> H ==> H') -> (\[P] \* H) ==> H'. Proof. introv W Hh. rewrite state_star_pure_l in Hh. applys* W. Qed. Theorem hempty_eq_state_pure_true : \[] = \[True]. Proof. applys himpl_antisym; intros h M. { applys* state_pure_intro_hempty. } { forwards*: state_pure_inv_hempty M. } Qed. Theorem hfalse_hstar_any: forall H, \[False] \* H = \[False]. Proof. intros. applys himpl_antisym; intros h; rewrite state_star_pure_l; intros M. { false*. } { lets: state_pure_inv_hempty M. false*. } Qed. Theorem state_register_intro: forall register value, ($register == value) (machine_state empty {[ register := value ]}). Proof. intros; hnf; auto. Qed. Theorem state_register_inversion: forall register value state, ($register == value) state -> state = (machine_state empty {[ register := value ]}). Proof. intros ??? A; hnf in A; auto. Qed. Theorem state_star_register_same register v1 v2: ($register == v1) \* ($register == v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_register_inversion & ?%state_register_inversion & [] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_counter_intro: forall counter, (pc_at counter) (machine_state {[ 0%fin := counter ]} empty). Proof. intros; hnf; auto. Qed. Theorem state_counter_inversion: forall counter state, (pc_at counter) state -> state = (machine_state {[ 0%fin := counter ]} empty). Proof. intros ?? A; hnf in A; auto. Qed. Theorem state_star_counter v1 v2: (pc_at v1) \* (pc_at v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_counter_inversion & ?%state_counter_inversion & [? _] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_exists_intro: forall A (a: A) (P: A -> Assertion) state, P a state -> (\exists a, P a) state. Proof. intros; hnf; eauto. Qed. Theorem state_exists_inversion: forall X (P: X -> Assertion) state, (\exists x, P x) state -> exists x, P x state. 
: MultiParams) := { adjacent_to : relation name ; adjacent_to_dec : forall x y : name, {adjacent_to x y} + {~ adjacent_to x y} ; adjacent_to_symmetric : Symmetric adjacent_to ; adjacent_to_irreflexive : Irreflexive adjacent_to }.Class FailMsgParams `(P : MultiParams) := { msg_fail : msg }.Class NewMsgParams `(P : MultiParams) := { msg_new : msg }.Section StepRelations. Variable A : Type. Variable trace : Type. Definition step_relation := A -> A -> list trace -> Prop. Inductive refl_trans_1n_trace (step : step_relation) : step_relation := | RT1nTBase : forall x, refl_trans_1n_trace step x x [] | RT1nTStep : forall x x' x'' cs cs', step x x' cs -> refl_trans_1n_trace step x' x'' cs' -> refl_trans_1n_trace step x x'' (cs ++ cs'). Theorem refl_trans_1n_trace_trans : forall step (a b c : A) (os os' : list trace), refl_trans_1n_trace step a b os -> refl_trans_1n_trace step b c os' -> refl_trans_1n_trace step a c (os ++ os'). Proof using. intros. induction H; simpl; auto. concludes. rewrite app_ass. constructor 2 with x'; auto. Qed. Definition inductive (step : step_relation) (P : A -> Prop) := forall (a a': A) (os : list trace), P a -> step a a' os -> P a'. Theorem step_star_inductive : forall step P, inductive step P -> forall (a : A) a' os, P a -> (refl_trans_1n_trace step) a a' os -> P a'. Proof using. unfold inductive. intros. induction H1; auto. forwards; eauto. Qed. Definition inductive_invariant (step : step_relation) (init : A) (P : A -> Prop) := P init /\ inductive step P. Definition reachable step init a := exists out, refl_trans_1n_trace step init a out. Definition true_in_reachable step init (P : A -> Prop) := forall a, reachable step init a -> P a. Theorem true_in_reachable_reqs : forall (step : step_relation) init (P : A -> Prop), (P init) -> (forall a a' out, step a a' out -> reachable step init a -> P a -> P a') -> true_in_reachable step init P. Proof using. intros. unfold true_in_reachable, reachable in *. intros. break_exists. match goal with H : refl_trans_1n_trace _ _ _ _ |- _ => induction H end; intuition eauto. match goal with H : P _ -> _ |- _ => apply H end; intros; break_exists; match goal with H : forall _ _ _, step _ _ _ -> _ |- _ => eapply H end; eauto; eexists; econstructor; eauto. Qed. Theorem inductive_invariant_true_in_reachable : forall step init P, inductive_invariant step init P -> true_in_reachable step init P. 
in |- *; rewrite Hz1; rewrite Hz2; repeat rewrite (fun x => Zplus_comm x 1). case z1; case z2; simpl in |- *; try (intros; red in |- *; intros; discriminate). intros p p0; case p; simpl in |- *; try (intros; red in |- *; intros; discriminate). Qed. Theorem EvenNOdd : forall n : Z, Even n -> ~ Odd n. intros n H1; red in |- *; intros H2; case H1; case H2; intros z1 Hz1 z2 Hz2. absurd (n = n); auto. pattern n at 1 in |- *; rewrite Hz1; rewrite Hz2; repeat rewrite (fun x => Zplus_comm x 1). case z1; case z2; simpl in |- *; try (intros; red in |- *; intros; discriminate). intros p p0; case p0; simpl in |- *; try (intros; red in |- *; intros; discriminate). Qed. Hint Resolve OddNEven EvenNOdd: zarith. Theorem EvenPlus1 : forall n m : Z, Even n -> Even m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem EvenPlus2 : forall n m : Z, Odd n -> Odd m -> Even (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1 + 1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus1 : forall n m : Z, Odd n -> Even m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Theorem OddPlus2 : forall n m : Z, Even n -> Odd m -> Odd (n + m). intros n m H H0; case H; case H0; intros z1 Hz1 z2 Hz2. exists (z2 + z1)%Z; try rewrite Hz1; try rewrite Hz2; ring. Qed. Hint Resolve EvenPlus1 EvenPlus2 OddPlus1 OddPlus2: zarith. Theorem EvenPlusInv1 : forall n m : Z, Even (n + m) -> Even n -> Even m. intros n m H H0; replace m with (n + m + - n)%Z; auto with zarith. Qed. Theorem EvenPlusInv2 : forall n m : Z, Even (n + m) -> Odd n -> Odd m. intros n m H H0; replace m with (n + m + - n)%Z; auto with zarith. Qed. Theorem OddPlusInv1 : forall n m : Z, Odd (n + m) -> Odd m -> Even n. 
auto with zarith. apply mZlist_correct; auto. simpl in |- *; auto with zarith. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. apply Zle_trans with 0%Z; auto with zarith. case (dExp b); auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem mBPadic_Fbounded : forall (p : float) (r : R), In p (mBFloat r) -> Fbounded b p. intros p r H'; red in |- *; repeat (split; auto). apply Zpred_Zle_Zabs_intro. apply mZlist_correct_rev1 with (q := Zpred (Zpos (vNum b))); auto with real. apply mProd_correct_rev1 with (l2 := mZlist (- dExp b) (Fexp (boundR r))) (C := (Z * Z)%type) (b := Fexp p); auto. apply in_map_inv with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. intros a1 b1; case a1; case b1; simpl in |- *. intros z z0 z1 z2 H'0; inversion H'0; auto. generalize H'; case p; auto. apply mZlist_correct_rev2 with (p := (- Zpred (Zpos (vNum b)))%Z); auto. apply mProd_correct_rev1 with (l2 := mZlist (- dExp b) (Fexp (boundR r))) (C := (Z * Z)%type) (b := Fexp p); auto. apply in_map_inv with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. intros a1 b1; case a1; case b1; simpl in |- *. intros z z0 z1 z2 H'0; inversion H'0; auto. generalize H'; case p; auto. apply mZlist_correct_rev1 with (q := Fexp (boundR r)); auto. apply mProd_correct_rev2 with (l1 := mZlist (- pPred (vNum b)) (pPred (vNum b))) (C := (Z * Z)%type) (a := Fnum p); auto. apply in_map_inv with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. intros a1 b1; case a1; case b1; simpl in |- *. intros z z0 z1 z2 H'0; inversion H'0; auto. generalize H'; case p; auto. Qed. Definition ProjectorP (P : R -> float -> Prop) := forall p q : float, Fbounded b p -> P p q -> p = q :>R. Definition MonotoneP (P : R -> float -> Prop) := forall (p q : R) (p' q' : float), (p < q)%R -> P p p' -> P q q' -> (p' <= q')%R. Definition isMin (r : R) (min : float) := Fbounded b min /\ (min <= r)%R /\ (forall f : float, Fbounded b f -> (f <= r)%R -> (f <= min)%R). Theorem isMin_inv1 : forall (p : float) (r : R), isMin r p -> (p <= r)%R. 
x y, [|land x y|] = Z.land [|x|] [|y|]; spec_lxor : forall x y, [|lxor x y|] = Z.lxor [|x|] [|y|] }. End Specs. Arguments Specs {t} ops. Section WW. Context {t : Type}{ops : Ops t}{specs : Specs ops}. Let wB := base digits. Definition WO' (eq0:t->bool) zero h := if eq0 h then W0 else WW h zero. Definition WO := Eval lazy beta delta [WO'] in let eq0 := ZnZ.eq0 in let zero := ZnZ.zero in WO' eq0 zero. Definition OW' (eq0:t->bool) zero l := if eq0 l then W0 else WW zero l. Definition OW := Eval lazy beta delta [OW'] in let eq0 := ZnZ.eq0 in let zero := ZnZ.zero in OW' eq0 zero. Definition WW' (eq0:t->bool) zero h l := if eq0 h then OW' eq0 zero l else WW h l. Definition WW := Eval lazy beta delta [WW' OW'] in let eq0 := ZnZ.eq0 in let zero := ZnZ.zero in WW' eq0 zero. Lemma spec_WO : forall h, zn2z_to_Z wB to_Z (WO h) = (to_Z h)*wB. Proof. unfold zn2z_to_Z, WO; simpl; intros. case_eq (eq0 h); intros. rewrite (spec_eq0 _ H); auto. rewrite spec_0; auto with zarith. Qed. Lemma spec_OW : forall l, zn2z_to_Z wB to_Z (OW l) = to_Z l. Proof. unfold zn2z_to_Z, OW; simpl; intros. case_eq (eq0 l); intros. rewrite (spec_eq0 _ H); auto. rewrite spec_0; auto with zarith. Qed. Lemma spec_WW : forall h l, zn2z_to_Z wB to_Z (WW h l) = (to_Z h)*wB + to_Z l. Proof. unfold WW; simpl; intros. case_eq (eq0 h); intros. rewrite (spec_eq0 _ H); auto. fold (OW l). rewrite spec_OW; auto. simpl; auto. Qed. End WW. Section Of_Z. Context {t : Type}{ops : Ops t}{specs : Specs ops}. Notation "[| x |]" := (to_Z x) (at level 0, x at level 99). Theorem of_pos_correct: forall p, Zpos p < base digits -> [|(snd (of_pos p))|] = Zpos p. Proof. intros p Hp. generalize (spec_of_pos p). case (of_pos p); intros n w1; simpl. case n; auto with zarith. intros p1 Hp1; contradict Hp; apply Z.le_ngt. replace (base digits) with (1 * base digits + 0) by ring. rewrite Hp1. apply Z.add_le_mono. apply Z.mul_le_mono_nonneg; auto with zarith. case p1; simpl; intros; red; simpl; intros; discriminate. unfold base; auto with zarith. case (spec_to_Z w1); auto with zarith. Qed. Definition of_Z z := match z with | Zpos p => snd (of_pos p) | _ => zero end. Theorem of_Z_correct: forall p, 0 <= p < base digits -> [|of_Z p|] = p. 
NMap := IMap(NIndexed).Module Type EQUALITY_TYPE. Parameter t: Type. Parameter eq: forall (x y: t), {x = y} + {x <> y}. End EQUALITY_TYPE.Module EMap(X: EQUALITY_TYPE) <: MAP. Definition elt := X.t. Definition elt_eq := X.eq. Definition t (A: Type) := X.t -> A. Definition init (A: Type) (v: A) := fun (_: X.t) => v. Definition get (A: Type) (x: X.t) (m: t A) := m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. 
auto with real; apply Rlt_le; auto. apply RleRoundedLessR0 with (P := P) (r := p); auto; apply Rlt_le; auto. Qed. Theorem RoundAbsMonotonel : forall (P : R -> float -> Prop) (p : R) (q r : float), RoundedModeP b radix P -> Fbounded b r -> P p q -> (r <= Rabs p)%R -> (r <= Rabs q)%R. intros P p q r H' H'0 H'1 H'2. case (Rle_or_lt 0 p); intros Rl1. rewrite Rabs_right; auto. apply RleBoundRoundl with (P := P) (r := p); auto. rewrite <- (Rabs_right p); auto with real. apply Rle_ge; apply RleRoundedR0 with (P := P) (r := p); auto. rewrite Faux.Rabsolu_left1; auto. rewrite <- (Ropp_involutive r); apply Ropp_le_contravar. rewrite <- (Fopp_correct radix); auto. apply RleBoundRoundr with (P := P) (r := p); auto with float. rewrite (Fopp_correct radix); rewrite <- (Ropp_involutive p); rewrite <- (Faux.Rabsolu_left1 p); auto with real; apply Rlt_le; auto. apply RleRoundedLessR0 with (P := P) (r := p); auto; apply Rlt_le; auto. Qed. Theorem ZroundZ : forall (P : R -> float -> Prop) (z : Z) (p : float), RoundedModeP b radix P -> P z p -> exists z' : Z, p = z' :>R. intros P z p HP H'. case (RoundedModeRep b radix precision) with (P := P) (p := Float z 0%nat) (q := p); auto. cut (CompatibleP b radix P); [ intros Cp | apply RoundedModeP_inv2 with (1 := HP); auto ]; auto. apply Cp with (1 := H'); auto. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_r; auto. apply RoundedModeBounded with (P := P) (r := IZR z); auto. intros x H'0; exists x; auto. unfold FtoRradix in |- *; rewrite H'0. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Rmult_1_r; auto. Qed. Theorem NroundN : forall (P : R -> float -> Prop) (n : nat) (p : float), RoundedModeP b radix P -> P n p -> exists n' : nat, p = n' :>R. intros P n p HP H'. case (ZroundZ P (Z_of_nat n) p); auto. repeat rewrite <- INR_IZR_INZ; auto. intros x H'0; exists (Zabs_nat x). rewrite <- (inj_abs x) in H'0. rewrite H'0. repeat rewrite <- INR_IZR_INZ; auto. apply le_IZR; simpl in |- *. rewrite <- H'0; auto. apply RleRoundedR0 with (P := P) (r := INR n); auto. replace 0%R with (INR 0); auto with real arith. Qed. Theorem FUlp_Le_LSigB : forall x : float, Fbounded b x -> (Fulp x <= Float 1%nat (LSB radix x))%R. 
l)) r v' | false :: bs' => Node l (insert bs' v (new r)) v' end end.Fixpoint search (bs : bits) (t : trie) : option A := match t with | Leaf => None | Node l r v => match bs with | nil => v | true :: bs' => search bs' l | false :: bs' => search bs' r end end.Lemma new_is_node : forall (t : trie), exists l r v, new t = Node l r v. Proof. intro t. unfold new. destruct t; eauto. Qed.Lemma search_leaf : forall (bs : bits), search bs Leaf = None. Proof. intros. induction bs; unfold search; auto. Qed.Hint Resolve search_leaf.Inductive BitsEq : bits -> bits -> Prop := | eq_nil : BitsEq nil nil | eq_cons : forall (b : bool) (b1 b2 : bits), BitsEq b1 b2 -> BitsEq (b :: b1) (b :: b2).Ltac invert H := inversion H; clear H; subst.Ltac invert_new t := let H := fresh in assert (H: exists l r v, new t = Node l r v) by apply new_is_node; destruct H; destruct H; destruct H; rewrite H. Lemma bool_decidable : forall (a b : bool), Decidable.decidable (a = b). Proof. intros. unfold Decidable.decidable. assert ( {a = b} + {a <> b} ). { apply bool_dec. } destruct H; tauto. Qed.Lemma bool_neq_is_neg : forall (a b : bool), a <> b -> a = negb b. Proof. intros. destruct a; destruct b; auto. exfalso. apply H. auto. Qed. Lemma bits_neq_cons : forall a b bs1 bs2, ~ BitsEq (a :: bs1) (b :: bs2) -> a <> b \/ ~ BitsEq bs1 bs2. Proof. intros. apply Decidable.not_and. apply bool_decidable. intros [H1 H2]. subst. apply H. apply eq_cons. apply H2. Qed.Lemma bits_neq_nil : forall bs, ~ BitsEq nil bs -> exists b bs', bs = b :: bs'. Proof. intros. assert (bs <> nil). { intros contra. apply H. subst. constructor. } destruct bs. - exfalso. apply H0. auto. - eauto. Qed. Theorem insert_affact_eq_search : forall (bs1 bs2 : bits) (v : A) (t : trie), BitsEq bs1 bs2 -> search bs2 (insert bs1 v (new t)) = Some v. Proof. intro bs1. induction bs1; intros; invert H. - unfold search, insert, new. destruct t; auto. - unfold search, insert. invert_new t. fold search. fold insert. destruct a. + apply IHbs1. apply H3. + apply IHbs1; auto. Qed. Theorem insert_unaffect_neq_search : forall (bs1 bs2 : bits) (v : A) (t : trie), ~ (BitsEq bs1 bs2) -> search bs2 t = search bs2 (insert bs1 v (new t)). 
Q) -> P -> R. Proof. move=> H1 H2.move: (imp_trans P Q R)=> H. apply: H. done. done.Restart.move: (imp_trans P Q R)=> H H1 H2. apply: H; done.Restart. move=>H1 H2; apply: (imp_trans P Q R)=>//. Qed.Module Connectives. Variables P Q R: Prop.Locate "_ /\ _".Print and.Goal P -> R -> P /\ R. move=> p r. apply: conj=>//.Undo. constructor 1=>//.Undo. split=>//. Qed.Goal P /\ Q -> Q. Proof. case.done. Qed.Locate "_ \/ _".Print or.Goal Q -> P \/ Q \/ R. move=> q. by right; left. Qed.Goal P \/ Q -> Q \/ P. case=>x.by right.by left. Qed.Locate "~ _".Print not. Theorem absurd: P -> ~P -> Q. Proof. by move=>p H; move : (H p). Qed.Theorem contraP: (P -> Q) -> ~Q -> ~P.Proof. move=> H Hq. move /H. move /Hq. done. Qed.Locate "exists".Print ex.Theorem ex_imp_ex A (S T: A -> Prop): (exists a: A, S a) -> (forall x: A, S x -> T x) -> exists b: A, T b.Proof.case=>a Hs Hst. exists a.by apply: Hst.Qed.End Connectives.Require Import Classical_Prop. Check classic.Definition peirce_law := forall P Q: Prop, ((P -> Q) -> P) -> P.Check NNPP.Check imply_to_or.Set Printing Universes.Check bool.Check Set. Check Prop.Definition S := forall T: Set, list T. Check S.Definition R (A: Type) (x: A): A := x. Arguments R [A].Check R tt. Check R Type. Theorem all_imp_ist A (P Q: A -> Prop): (forall x: A, P x -> Q x) -> (forall y, P y) -> forall z, Q z. Proof.Admitted.Theorem or_distributes_over_and P Q R: P \/ (Q /\ R) <-> (P \/ Q) /\ (P \/ R). Proof.Admitted.Theorem or_distributes_over_and_2 P Q R : (P \/ Q) /\ (P \/ R) -> P \/ (Q /\ R). Proof.Admitted.Inductive my_ex A (S: A -> Prop) : Prop := my_ex_intro x of S x.Goal forall A (S: A -> Prop), my_ex A S <-> exists y: A, S y. Proof.Admitted. Theorem dist_exists_or (X : Type) (P Q : X -> Prop): (exists x, P x \/ Q x) <-> (exists x, P x) \/ (exists x, Q x). Proof.Admitted. Theorem two_is_three A: (exists x : A, (forall R : A -> Prop, R x)) -> 2 = 3. Proof.Admitted. Definition dys_imp (P Q: Prop) := (P -> Q) -> (Q -> P). Definition dys_contrap (P Q: Prop) := (P -> Q) -> (~P -> ~Q).Theorem di_false: (forall P Q: Prop, dys_imp P Q) -> False. Proof.Admitted. Theorem dc_false: (forall P Q: Prop, dys_contrap P Q) -> False. 
From Huffman Require Export Aux. From Huffman Require Export Permutation. From Huffman Require Export UList. From Huffman Require Export sTactic.Section UniqueKey. Variables (A : Type) (B : Type). Inductive unique_key : list (A * B) -> Prop := | unique_key_nil : unique_key nil | unique_key_cons : forall (a : A) (b : B) l, (forall b : B, ~ In (a, b) l) -> unique_key l -> unique_key ((a, b) :: l). Hint Constructors unique_key : core. Theorem unique_key_inv : forall a l, unique_key (a :: l) -> unique_key l. Proof using. intros a l H; inversion H; auto. Qed. Theorem unique_key_in : forall (a : A) (b1 b2 : B) l, unique_key ((a, b1) :: l) -> ~ In (a, b2) l. 
apply ( twooutof3c _ _ ( pr2 c' ) ( pr2 d' ) ) . assert ( is2 : isweq b0' ) . apply ( twooutof3b _ _ ( pr2 a' ) is1 ) . apply ( isweqtotaltofib _ _ _ is2 x' ) . Defined . Definition weqhfibersg'tof { X X' Y Z : UU } ( f : X -> Y ) ( f' : X' -> Y ) ( g : Z -> X ) ( g' : Z -> X' ) ( hf : hfsqstr f f' g g' ) ( x' : X' ) := weqpair _ ( isweqhfibersg'tof _ _ _ _ hf x' ) .Lemma ishfsqweqhfibersg'tof { X X' Y Z : UU } ( f : X -> Y ) ( f' : X' -> Y ) ( g : Z -> X ) ( g' : Z -> X' ) ( h : commsqstr g' f' g f ) ( is : forall x' : X' , isweq ( hfibersg'tof f f' g g' h x' ) ) : hfsqstr f f' g g' . Proof . intros . split with h . set ( a' := weqtococonusf g' ) . set ( c0' := commsqZtohfp f f' g g' h ) . set ( d' := weqhfptohfpoverX' f f' ) . set ( b' := weqfibtototal _ _ ( fun x' : X' => weqpair _ ( is x' ) ) ) . assert ( h1 : forall z : Z , paths ( d' ( c0' z ) ) ( b' ( a' z ) ) ) . intro . simpl . unfold b' . unfold a' . unfold weqtococonusf . unfold tococonusf . unfold totalfun . simpl . assert ( e : paths ( pathsinv0 ( h z ) ) ( pathscomp0 ( pathsinv0 (h z) ) (idpath (f' (g' z))) ) ) . apply ( pathsinv0 ( pathscomp0rid _ ) ) . destruct e . apply idpath . assert ( is1 : isweq ( fun z : _ => d' ( c0' z ) ) ) . apply ( isweqhomot _ _ ( fun z : Z => ( pathsinv0 ( h1 z ) ) ) ) . apply ( twooutof3c _ _ ( pr2 a' ) ( pr2 b' ) ) . apply ( twooutof3a _ _ is1 ( pr2 d' ) ) . Defined . Theorem transposhfpsqstr { X X' Y Z : UU } ( f : X -> Y ) ( f' : X' -> Y ) ( g : Z -> X ) ( g' : Z -> X' ) ( hf : hfsqstr f f' g g' ) : hfsqstr f' f g' g . 
?P ?p _ |- _ ] => apply inj_pair2 in H end.Ltac inv_step := match goal with | [ H: step _ _ _ _ _ _ _ _ |- _ ] => inversion H; repeat inj_existT; subst; clear H end.Ltac inv_fail_step := try match goal with | [ H: exec _ _ _ _ (Failed _) |- _ ] => inversion H; repeat inj_existT; subst; clear H end; match goal with | [ H: fail_step _ _ _ |- _ ] => inversion H; subst; clear H end.Ltac inv_crash_step := try match goal with | [ H: exec _ _ _ _ (Crashed _ _ _) |- _ ] => inversion H; repeat inj_existT; subst; clear H end; match goal with | [ H: crash_step _ |- _ ] => inversion H; subst; clear H end.Ltac inv_exec' H := inversion H; repeat inj_existT; subst; try inv_step; try inv_fail_step; try inv_crash_step; subst; clear H.Ltac inv_exec := lazymatch goal with | [ H: exec _ _ _ (Ret _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (AlertModified) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (Debug _ _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (Bind _ _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ _ _ |- _ ] => inv_exec' H end.Section MonadLaws. Definition prog_equiv T : prog T -> prog T -> Prop := fun p1 p2 => forall m vm hm out, exec m vm hm p1 out <-> exec m vm hm p2 out. Arguments prog_equiv {T} _ _. Infix "~=" := prog_equiv (at level 50, left associativity). Theorem bind_left_id : forall T T' v (p: T -> prog T'), Bind (Ret v) p ~= p v. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_left_alert_modified : forall T' (p: unit -> prog T'), Bind (AlertModified) p ~= p tt. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_left_debug : forall T' (p: unit -> prog T') s a, Bind (Debug s a) p ~= p tt. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_right_id : forall T (p: prog T), Bind p Ret ~= p. Proof. split; intros. - inv_exec; eauto. inv_exec; eauto. - destruct out; eauto. Qed. Theorem bind_assoc : forall T T' T'' (p1: prog T) (p2: T -> prog T') (p3: T' -> prog T''), Bind (Bind p1 p2) p3 ~= Bind p1 (fun x => Bind (p2 x) p3). 
y : E, sum y x = E_0; prod_is_assoc : Monoid.is_assoc E prod; prod_id_l : Monoid.is_id_l E prod E_1; prod_id_r : Monoid.is_id_r E prod E_1; prod_sum_distrib_l : is_distrib_l E prod sum; prod_sum_distrib_r : is_distrib_r E prod sum }.Arguments E_0 {r}.Arguments E_1 {r}.Arguments sum {r} x y.Arguments prod {r} x y.Arguments distinct_0_1 {r} _.Arguments sum_is_assoc {r} x y z.Arguments sum_is_comm {r} x y.Arguments sum_id_l {r} x.Arguments sum_inv_l_ex {r} x.Arguments prod_is_assoc {r} x y z.Arguments prod_id_l {r} x.Arguments prod_id_r {r} x.Arguments prod_sum_distrib_l {r} x y z.Arguments prod_sum_distrib_r {r} x y z.Notation "0" := E_0 : ring_scope.Notation "1" := E_1 : ring_scope.Notation "x + y" := (sum x y) (at level 50, left associativity) : ring_scope.Notation "{+}" := sum : ring_scope.Notation "x # y" := (prod x y) (at level 50, left associativity) : ring_scope.Notation "{#}" := prod : ring_scope.Open Scope ring_scope.Section Theorems. Variable r : Ring. Let E := E r. Definition nonzero (x : E) : Prop := x <> 0. Definition sum_is_id_l := Monoid.is_id_l E sum. Definition sum_is_id_r := Monoid.is_id_r E sum. Definition sum_is_id := Monoid.is_id E sum. Definition sum_abelian_group := Abelian_Group.abelian_group E 0 {+} sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex. Definition sum_group := Abelian_Group.op_group sum_abelian_group. Definition sum_monoid := Abelian_Group.op_monoid sum_abelian_group. Theorem sum_id_r : sum_is_id_r 0. Proof Abelian_Group.op_id_r sum_abelian_group. Theorem sum_id : sum_is_id 0. Proof Abelian_Group.op_id sum_abelian_group. Definition sum_is_inv_l := Abelian_Group.op_is_inv_l sum_abelian_group. Definition sum_is_inv_r := Abelian_Group.op_is_inv_r sum_abelian_group. Definition sum_is_inv := Abelian_Group.op_is_inv sum_abelian_group. Definition sum_has_inv_l := Abelian_Group.has_inv_l sum_abelian_group. Definition sum_has_inv_r := Abelian_Group.has_inv_r sum_abelian_group. Definition sum_has_inv := Abelian_Group.has_inv sum_abelian_group. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Abelian_Group.op_inv_r_ex sum_abelian_group. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Abelian_Group.op_id_l_uniq sum_abelian_group. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Abelian_Group.op_id_r_uniq sum_abelian_group. Theorem sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Abelian_Group.op_id_uniq sum_abelian_group. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Abelian_Group.op_inv_l_r_eq sum_abelian_group. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Abelian_Group.op_inv_sym sum_abelian_group. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Abelian_Group.op_inv_uniq sum_abelian_group. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Abelian_Group.op_inv_ex sum_abelian_group. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. 
(Int.ltu n Int.iwordsize) eqn:?; simpl. destruct (shrimm_match a); intros. InvEval. simpl; rewrite Heqb. TrivialExists. destruct (Int.ltu (Int.add n n1) Int.iwordsize) eqn:?. InvEval. subst x. exists (Val.shr v1 (Vint (Int.add n n1))); split. EvalOp. simpl. rewrite mk_shift_amount_eq; auto. destruct v1; simpl; auto. rewrite s_range. simpl. rewrite Heqb. rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shr_shr; auto. apply s_range. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Theorem eval_shruimm: forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val.shru x (Vint n)). Proof. red; intros until x. unfold shruimm. predSpec Int.eq Int.eq_spec n Int.zero. intros; subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shru_zero; auto. destruct (Int.ltu n Int.iwordsize) eqn:?; simpl. destruct (shruimm_match a); intros. InvEval. simpl; rewrite Heqb. TrivialExists. destruct (Int.ltu (Int.add n n1) Int.iwordsize) eqn:?. InvEval. subst x. exists (Val.shru v1 (Vint (Int.add n n1))); split. EvalOp. simpl. rewrite mk_shift_amount_eq; auto. destruct v1; simpl; auto. destruct (Int.ltu n1 Int.iwordsize) eqn:?; simpl; auto. rewrite Heqb; rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shru_shru; auto. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\ Val.lessdef (Val.mul x (Vint n)) v). TrivialExists. econstructor. EvalOp. simpl; eauto. econstructor. eauto. constructor. rewrite Val.mul_commut. auto. generalize (Int.one_bits_decomp n). generalize (Int.one_bits_range n). destruct (Int.one_bits n). intros. auto. destruct l. intros. rewrite H1. simpl. rewrite Int.add_zero. replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul. apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib. destruct l. intros. rewrite H1. simpl. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exploit (eval_add (x :: le)). eexact A1. eexact A2. intros [v [A B]]. exists v; split. econstructor; eauto. rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. eapply Val.lessdef_trans. 2: eauto. apply Val.add_lessdef; auto. simpl. repeat rewrite H0; auto with coqlib. intros. auto. Qed. Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). 
In_nats... Qed.Lemma In_ijs_inv n i j: List.In (i, j) (ijs n) -> (i < j < n)%nat. Proof with auto. unfold ijs. simpl. intros. destruct (In_concat_inv _ _ H). clear H. destruct H0. destruct (In_map_inv H0). clear H0. destruct H1. subst. destruct (In_map_inv H). clear H. destruct H0. inversion H. subst. split. destruct (In_nats_inv _ _ _ H0)... destruct (In_nats_inv _ _ _ H1)... Qed.Lemma expand_sumOver_ijs n (f: nat * nat -> R): RsumOver (ijs n) f = RsumOver (nats 0 n) (fun j => RsumOver (nats 0 j) (fun i => f (i, j))). Proof with auto with real. unfold ijs. intros. rewrite RsumOver_concat_map. unfold RsumOver. rewrite (map_ext (fun j => RsumOver (map (fun i => (i, j)) (nats 0 j)) f) (fun j => RsumOver (nats 0 j) (fun i => f (i, j))))... intro. unfold RsumOver. rewrite map_map... Qed.Require harmonic.Lemma sumOver_ijs_bound n: RsumOver (ijs n) (fun ij => 2 / INR (S (snd ij - fst ij))) <= 2 * INR n * INR (S (log2ceil n)). Proof with auto with real. rewrite expand_sumOver_ijs. simpl snd. simpl @fst. apply Rle_trans with (RsumOver (nats 0 n) (fun _ => 2 * INR (S (log2ceil n)))). apply RsumOver_le. intros. change (fun i => _) with (compose (fun i => 2 / INR (S i)) (minus x)). rewrite RsumOver_minus... rewrite plus_0_r. rewrite <- minus_n_n... apply Rle_trans with (RsumOver (nats 1 x) (fun i => 2 / INR i)). apply RsumOver_le. intros. unfold Rdiv. apply Rmult_le_compat_l... destruct (In_nats_inv _ _ _ H0). apply RIneq.Rle_Rinv... rewrite <- (RsumOver_mult_constant (fun i => / INR i) 2). apply Rmult_le_compat_l... apply Rle_trans with (RsumOver (nats 1 n) (Rinv ‚àò INR)). apply RsumOver_nats_le. destruct (In_nats_inv _ _ _ H)... intros. unfold Rdiv. destruct q. inversion H0. unfold compose. apply O_le_inv_INR_S. apply harmonic.upper_bound. fold (compose (Rmult 2) (fun _: nat => INR (S (log2ceil n)))). rewrite <- RsumOver_mult_constant. rewrite Rmult_assoc. unfold RsumOver. rewrite Rsum_constant with (INR (S (log2ceil n))) (map (fun _ => INR (S (log2ceil n))) (nats 0 n)). rewrite map_length. rewrite nats_length... intros. destruct (In_map_inv H). destruct H0... Qed.Require U. Require Import Le. Require Import Plus. Require Import Minus. Require Import Lt. Require Import Arith. Require Import monads. Require Import monoid_monad_trans. Require Import expec. Require Import monoid_expec. Require list_length_expec. Require qs_definitions. Require qs_parts. Require qs_sound_cmps. Require Import Rbase. Require qs_cmp_prob. Require qs_CM_U_expec_cost_eq. Require Import sort_order.Import qs_definitions.mon_nondet.Arguments length {A}.Section contents. Variables (ee: E) (ol: list ee). Theorem Umonoid_expec_qs_bounded_by_sumOver_ijs l: IndexSeq 0 l -> @monoid_expec U.monoid length _ (qs (@U.cmp ee ol) U.pick l) <= RsumOver (ijs (length l)) (fun ij => 2 / INR (S (snd ij - fst ij))). 
p ===> [| tss = nil |]. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_nil_bwd : forall len key tss (p : W), p = 0 -> [| tss = nil |] ===> stack len key tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_fwd : forall len key tss (p : W), p <> 0 -> stack len key tss p ===> Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p'. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_bwd : forall len key tss (p : W), p <> 0 -> (Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key sk ts tp * stack len key tss' p') ===> stack len key tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. injection H0; sepLemma; auto. injection H0; sepLemma. Qed. Theorem tuples1_fwd : forall len key ts c, tuples1 len key ts c ===> [| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]. Proof. unfold tuples1; sepLemma; eauto. Qed. Theorem tuples1_bwd : forall len key ts (c : W), ([| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]) ===> tuples1 len key ts c. Proof. unfold tuples1; sepLemma; eauto. Qed. Theorem tuples1_eq : forall len key ts c, tuples1 len key ts c = ([| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |])%Sep. Proof. auto. Qed. Theorem tree_Equiv : forall len key sk ts1 ts2 p, Equiv ts1 ts2 -> tree len key sk ts1 p ===> tree len key sk ts2 p. 
Require Import Verdi.GhostSimulations. Require Import VerdiRaft.Raft.Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.CroniesCorrectInterface. Require Import VerdiRaft.VotesCorrectInterface.Require Import VerdiRaft.OneLeaderPerTermInterface.Section OneLeaderPerTermProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Ltac copy_eapply_prop_hyp P H := match goal with | H' : P _ |- _ => let x := fresh in pose proof H as x; apply H' in x end. Context {rri : raft_refinement_interface}. Context {vci : votes_correct_interface}. Context {cci : cronies_correct_interface}. Lemma one_leader_per_term_invariant' : forall net, votes_correct net -> cronies_correct net -> one_leader_per_term (deghost net). Proof using rri. unfold votes_correct, cronies_correct, one_leader_per_term in *. intuition. repeat match goal with | H : context [ nwState (deghost _) _ ] |- _ => rewrite deghost_spec in H end. match goal with | h : type _ = _, h' : type _ = _ |- _ => copy_eapply_prop_hyp votes_received_leaders h; copy_eapply_prop_hyp votes_received_leaders h' end. match goal with | H : wonElection _ = _ |- _ => find_eapply_lem_hyp wonElection_one_in_common; [|clear H; eauto] end. break_exists; intuition. eapply_prop one_vote_per_term; eapply_prop cronies_votes; [eapply_prop votes_received_cronies|]; intuition eauto. unfold raft_data in *. unfold raft_refined_base_params, raft_refined_multi_params in *. repeat find_rewrite. eapply_prop votes_received_cronies; intuition eauto. Qed. Theorem one_leader_per_term_invariant : forall net, raft_intermediate_reachable net -> one_leader_per_term net. 
Require Import Coq.NArith.NArith Coq.Strings.String Coq.Lists.List.Require Import Bedrock.Nomega Bedrock.PropX Bedrock.PropXTac Bedrock.Word Bedrock.LabelMap Bedrock.IL Bedrock.XCAP.Set Implicit Arguments.Local Open Scope N_scope. Lemma nth_error_bound : forall A x (ls : list A) n, nth_error ls n = Some x -> (n < length ls)%nat. induction ls; destruct n; simpl; intuition; discriminate. Qed.Lemma nth_error_bound' : forall A x (ls : list A) n, nth_error ls (nat_of_N n) = Some x -> n < N_of_nat (length ls). intros; apply nth_error_bound in H; nomega. Qed.Section imports. Variable imports : LabelMap.t assert. Definition importsGlobal := forall k v, LabelMap.MapsTo k v imports -> exists s, snd k = Global s. Hypothesis imports_global : importsGlobal. Variable modName : string. Fixpoint imps (bls : list (assert * block)) (base exit : N) (post : assert) : LabelMap.t assert := match bls with | nil => LabelMap.add (modName, Local exit) post imports | (pre, _) :: bls' => LabelMap.add (modName, Local base) pre (imps bls' (Nsucc base) exit post) end. Inductive vcs : list Prop -> Prop := | VcsNil : vcs nil | VcsCons : forall (P : Prop) Ps, P -> vcs Ps -> vcs (P :: Ps). Implicit Arguments VcsCons [P Ps]. Hint Constructors vcs. Theorem vcs_app_fwd : forall Ps1 Ps2, vcs Ps1 -> vcs Ps2 -> vcs (Ps1 ++ Ps2). induction 1; simpl; auto. Qed. Theorem vcs_app_bwd1 : forall Ps1 Ps2, vcs (Ps1 ++ Ps2) -> vcs Ps1. induction Ps1; inversion 1; subst; eauto. Qed. Theorem vcs_app_bwd2 : forall Ps1 Ps2, vcs (Ps1 ++ Ps2) -> vcs Ps2. 
32). Defined. Definition word_nat_r : Repr Expr.type := Eval cbv beta iota zeta delta [ listToRepr ] in (listOptToRepr (Some bedrock_type_W :: None :: None :: None :: Some bedrock_type_nat :: nil) Expr.EmptySet_type). Definition natToW_r : signature (repr word_nat_r types'). refine {| Domain := natT :: nil; Range := tvWord |}. exact natToW. Defined. End typed_ext. Definition bedrock_funcs types' : functions (repr bedrock_types_r types') := let types := repr bedrock_types_r types' in wplus_r types :: wminus_r types :: wmult_r types :: Regs_r types :: wlt_r types :: natToW_r types :: nil. Definition bedrock_funcs_r types' : Repr (signature (repr bedrock_types_r types')) := Eval cbv beta iota zeta delta [ listToRepr bedrock_funcs ] in (listToRepr (bedrock_funcs types') (Default_signature _)).Section func_ext. Local Notation "'pcT'" := (tvType 0). Local Notation "'tvWord'" := (tvType 0). Local Notation "'stT'" := (tvType 1). Local Notation "'tvState'" := (tvType 2). Local Notation "'tvReg'" := (tvType 3). Local Notation "'natT'" := (tvType 4). Variable types' : list type. Definition types := repr bedrock_types_r types'. Variable funcs' : functions types. Definition funcs := repr (bedrock_funcs_r types') funcs'. Definition fPlus (l r : expr types) : expr types := Expr.Func 0 (l :: r :: nil). Definition fMinus (l r : expr types) : expr types := Expr.Func 1 (l :: r :: nil). Definition fMult (l r : expr types) : expr types := Expr.Func 2 (l :: r :: nil). Theorem fPlus_correct : forall l r uvars vars, match exprD funcs uvars vars l (tvType 0) , exprD funcs uvars vars r (tvType 0) with | Some lv , Some rv => exprD funcs uvars vars (fPlus l r) (tvType 0) = Some (wplus lv rv) | _ , _ => True end. Proof. intros; simpl; unfold eq_ind_r; simpl; repeat match goal with | [ |- match ?X with | Some _ => _ | None => _ end ] => destruct X end; auto. Qed. Theorem fMinus_correct : forall l r uvars vars, match exprD funcs uvars vars l tvWord , exprD funcs uvars vars r tvWord with | Some lv , Some rv => exprD funcs uvars vars (fMinus l r) tvWord = Some (wminus lv rv) | _ , _ => True end. Proof. intros; simpl; unfold eq_ind_r; simpl; repeat match goal with | [ |- match ?X with | Some _ => _ | None => _ end ] => destruct X end; auto. Qed. Theorem fMult_correct : forall l r uvars vars, match exprD funcs uvars vars l tvWord , exprD funcs uvars vars r tvWord with | Some lv , Some rv => exprD funcs uvars vars (fMult l r) tvWord = Some (wmult lv rv) | _ , _ => True end. 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.PRF. Require Import hmacfcf.splitVector.Require Import hmacfcf.HMAC_spec.Section RelatedKeyAttack. Variable K D R Phi_s : Set. Variable K_EqDec : EqDec K. Variable D_EqDec : EqDec D. Variable R_EqDec : EqDec R. Variable RndK : Comp K. Variable RndR : Comp R. Variable f : K -> D -> R. Variable Phi : Phi_s -> K -> K. Variable A : OracleComp (Phi_s * D) R bool. Definition RKA_F k (s : unit) p := [phi_s, x] <-2 p; ret (f (Phi phi_s k) x, tt). Definition RKA_randomFunc := @randomFunc (K * D) R RndR _. Definition RKA_R k s p := [phi_s, x] <-2 p; (RKA_randomFunc s (Phi phi_s k, x)). Definition RKA_G0 := k <-$ RndK; [b, _] <-$2 A _ _ (RKA_F k) tt; ret b. Definition RKA_G1 := k <-$ RndK; [b, _] <-$2 A _ _ (RKA_R k) nil; ret b. Definition RKA_Advantage := | Pr[RKA_G0] - Pr[RKA_G1] |.End RelatedKeyAttack.Definition dual_f (A B C : Set)(f : A -> B -> C) : B -> A -> C := fun b a => f a b.Section NMAC_to_HMAC. Variable c p : nat. Definition b := @b c p. Variable h : Bvector c -> Bvector b -> Bvector c. Variable iv : Bvector c. Variable fpad : Bvector c -> Bvector p. Definition GHMAC_2K := GHMAC_2K h iv fpad. Variable opad ipad : Bvector b. Hypothesis opad_ne_ipad : opad <> ipad. Definition GHMAC := GHMAC h iv fpad opad ipad. Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Definition app_fpad := @app_fpad c p fpad. Definition h_star := h_star p h. Definition GNMAC := GNMAC h fpad. Definition A_NMAC := x <-$ {0, 1}^(c + c); [b, _] <-$2 A _ _ (f_oracle GNMAC _ x) tt; ret b. Definition A_HMAC := x <-$ {0, 1}^b; [b, _] <-$2 A _ _ (f_oracle GHMAC _ x) tt; ret b. Theorem GHMAC_2K_GNMAC_equiv : forall k ls, let (k_Out, k_In) := splitVector b b k in let k' := Vector.append (h iv k_Out) (h iv k_In) in GHMAC_2K k ls = GNMAC k' ls. 
Require Export Relations.Require Export List.Module Type DEC_ORDER. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom ordered : order A le. Axiom lt_le_weak : forall a b:A, lt a b -> le a b. Axiom lt_diff : forall a b:A, lt a b -> a <> b. Axiom le_lt_or_eq : forall a b:A, le a b -> lt a b \/ a = b. Parameter lt_eq_lt_dec : forall a b:A, {lt a b} + {a = b} + {lt b a}. End DEC_ORDER.Module Type MORE_DEC_ORDERS. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom le_trans : transitive A le. Axiom le_refl : reflexive A le. Axiom le_antisym : antisymmetric A le. Axiom lt_irreflexive : forall a:A, ~ lt a a. Axiom lt_trans : transitive A lt. Axiom lt_not_le : forall a b:A, lt a b -> ~ le b a. Axiom le_not_lt : forall a b:A, le a b -> ~ lt b a. Axiom lt_intro : forall a b:A, le a b -> a <> b -> lt a b. Parameter le_lt_dec : forall a b:A, {le a b} + {lt b a}. Parameter le_lt_eq_dec : forall a b:A, le a b -> {lt a b} + {a = b}. End MORE_DEC_ORDERS. Module More_Dec_Orders (D: DEC_ORDER) : MORE_DEC_ORDERS with Definition A := D.A with Definition le := D.le with Definition lt := D.lt. Definition A := D.A. Definition le := D.le. Definition lt := D.lt. Theorem le_trans : transitive A le. Proof. case D.ordered; auto. Qed. Theorem le_refl : reflexive A le. Proof. case D.ordered; auto. Qed. Theorem le_antisym : antisymmetric A le. Proof. case D.ordered; auto. Qed. Theorem lt_intro : forall a b:A, le a b -> a <> b -> lt a b. Proof. intros a b H diff; case (D.le_lt_or_eq a b H); tauto. Qed. Theorem lt_irreflexive : forall a:A, ~ lt a a. Proof. intros a H. case (D.lt_diff _ _ H); trivial. Qed. Theorem lt_not_le : forall a b:A, lt a b -> ~ le b a. 
regs rules meths f: (WfMod type (Base (BaseMod regs rules meths))) -> In f meths -> TraceInclusion (Base (BaseMod regs rules meths)) (Base (inlineSingle_BaseModule f regs rules meths)). Proof. intros. unfold inlineSingle_BaseModule. specialize (TraceInclusion_inline_BaseModule_rules f H H0) as P1. specialize (WfMod_inline_all_Rule _ (seq 0 (length rules)) H0 H) as P2. specialize (TraceInclusion_inline_BaseModule_meths f P2 H0) as P3. repeat rewrite map_fold_right_eq in *. apply (TraceInclusion_trans P1 P3). Qed.Theorem TraceInclusion_inline_BaseModule_all_new regs rules meths f: (WfMod_new type (Base (BaseMod regs rules meths))) -> In f meths -> TraceInclusion (Base (BaseMod regs rules meths)) (Base (inlineSingle_BaseModule f regs rules meths)). Proof. rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inline_BaseModule_all. Qed.Lemma WfBaseMod_inlineSingle_BaseModule ty m f: In f (getMethods m) -> WfBaseModule ty m -> WfBaseModule ty (inlineSingle_BaseModule f (getRegisters m) (getRules m) (getMethods m)). Proof. intros. unfold inlineSingle_BaseModule. specialize (WfBaseMod_inline_BaseModule_Rules f H H0) as P1. assert (In f (getMethods ((BaseMod (getRegisters m) (map (inlineSingle_Rule f) (getRules m)) (getMethods m))))) as P2;[simpl; auto|]. apply (WfBaseMod_inline_BaseModule_Meths f P2 P1). Qed.Lemma WfBaseMod_inlineSingle_BaseModule_new ty m f: In f (getMethods m) -> WfBaseModule_new ty m -> WfBaseModule_new ty (inlineSingle_BaseModule f (getRegisters m) (getRules m) (getMethods m)). Proof. repeat rewrite <- WfBaseModule_WfBaseModule_new_iff. apply WfBaseMod_inlineSingle_BaseModule. Qed.Definition inlineSingle_BaseModuleWf {f} {ty} {m : BaseModuleWf ty} (inMeth : In f (getMethods m)):= Build_BaseModuleWf (WfBaseMod_inlineSingle_BaseModule _ inMeth (wfBaseModule m)).Definition inlineSingle_BaseModuleWf_new {f} {ty} {m : BaseModuleWf_new ty} (inMeth : In f (getMethods m)):= Build_BaseModuleWf_new (WfBaseMod_inlineSingle_BaseModule_new _ inMeth (wfBaseModule_new m)).Lemma TraceInclusion_inline_BaseModule_all_Wf {f} {m : BaseModuleWf type} (inMeth : In f (getMethods m)): TraceInclusion m (inlineSingle_BaseModuleWf inMeth). Proof. specialize (TraceInclusion_flatten_r m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inline_BaseModule_all _ P2 inMeth) as P3. eauto using TraceInclusion_trans. Qed.Theorem TraceInclusion_inline_BaseModule_all_Wf_new {f} {m : BaseModuleWf_new type} (inMeth : In f (getMethods m)): TraceInclusion m (inlineSingle_BaseModuleWf_new inMeth). Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. eapply (@TraceInclusion_inline_BaseModule_all_Wf f m'). Unshelve. exact inMeth. Qed.Section inline_all_all. Lemma TraceInclusion_inlineSingle_pos_Rules regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> forall n, (WfMod type (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths))) /\ TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths)). Proof. intros WfH n. unfold inlineSingle_Rules_pos. case_eq (nth_error meths n); intros sth; [intros sthEq|split; [assumption | apply TraceInclusion_refl]]. split. - apply nth_error_In in sthEq. pose proof (WfMod_inline_all_Rule sth (seq 0 (length rules)) sthEq WfH). repeat rewrite map_fold_right_eq in *. assumption. - apply TraceInclusion_inline_BaseModule_rules; auto. eapply nth_error_In; eauto. Qed. Theorem TraceInclusion_inlineSingle_pos_Rules_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> forall n, (WfMod_new type (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths))) /\ TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths)). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor. From Categories Require Import Cat.Cat.Section NatTrans. Context {C C' : Category}. Record NatTrans (F F' : (C --> C')%functor) := { Trans (c : C) : ((F _o c) --> (F' _o c))%object%morphism; Trans_com {c c' : C} (h : (c --> c')%morphism) : ((Trans c') ‚àò F _a h = F' _a h ‚àò (Trans c))%morphism; Trans_com_sym {c c' : C} (h : (c --> c')%morphism) : (F' _a h ‚àò (Trans c) = (Trans c') ‚àò F _a h)%morphism }. Notation "F --> F'" := (NatTrans F F') : nattrans_scope. Lemma NatTrans_eq_simplify {F F' : (C --> C')%functor} (N N' : (F --> F')%nattrans) : (@Trans _ _ N) = (@Trans _ _ N') -> N = N'. Proof. destruct N; destruct N'. basic_simpl. ElimEq. PIR; trivial. Qed.End NatTrans.Arguments Trans {_ _ _ _} _ _. Arguments Trans_com {_ _ _ _} _ {_ _} _. Arguments Trans_com_sym {_ _ _ _} _ {_ _} _.Bind Scope nattrans_scope with NatTrans.Notation "F --> F'" := (NatTrans F F') : nattrans_scope.Local Open Scope nattrans_scope.Section NatTrans_Compose. Context {C C' : Category}. Program Definition NatTrans_compose {F F' F'' : (C --> C')%functor} (tr : F --> F') (tr' : F' --> F'') : (F --> F'')%nattrans := {| Trans := fun c : Obj => ((Trans tr' c) ‚àò (Trans tr c)) % morphism |}. Next Obligation. Proof. rewrite assoc. rewrite Trans_com. rewrite assoc_sym. rewrite Trans_com; auto. Qed. Next Obligation. Proof. symmetry. apply NatTrans_compose_obligation_1. Qed.End NatTrans_Compose.Notation "N ‚àò N'" := (NatTrans_compose N' N) : nattrans_scope.Section NatTrans_Props. Context {C C' : Category}. Theorem NatTrans_compose_assoc {F G H I : (C --> C')%functor} (N : F --> G) (N' : G --> H) (N'' : H --> I) : ((N'' ‚àò N') ‚àò N = N'' ‚àò (N' ‚àò N))%nattrans . Proof. apply NatTrans_eq_simplify; cbn; auto. Qed. Program Definition NatTrans_id (F : (C --> C')%functor) : F --> F := {| Trans := fun x : Obj => id |}. Theorem NatTrans_id_unit_left {F G : (C --> C')%functor} (N : F --> G) : (NatTrans_id G) ‚àò N = N. 
decode_aux (c : code) (head m : list bool) {struct m} : list A := match m with | nil => match find_val head c with | Some a => a :: nil | None => nil end | a :: m1 => match find_val head c with | Some a1 => a1 :: decode_aux c (a :: nil) m1 | None => decode_aux c (head ++ a :: nil) m1 end end. Theorem decode_aux_correct : forall c : code, unique_prefix c -> not_null c -> forall (m1 m2 head : list bool) (a : A), find_val (head ++ m1) c = Some a -> decode_aux c head (m1 ++ m2) = a :: decode_aux c nil m2. Proof using. intros c Hc1 Hc2 m1; elim m1; simpl in |- *; auto. intros m2; case m2; simpl in |- *; auto. intros head a; rewrite <- app_nil_end. intros H1; rewrite H1; auto. rewrite not_null_find_val; auto. intros b l head a; rewrite <- app_nil_end. intros H1; rewrite H1; auto. rewrite not_null_find_val; auto. intros a l Rec m2 head a1 H2. rewrite <- Rec with (head := head ++ a :: nil). generalize (fun a => find_val_correct1 c a head). case (find_val head c); auto. intros a0 H; (cut (In (a0, head) c); [ intros Hin1 | auto ]). cut (In (a1, head ++ a :: l) c); [ intros Hin2 | apply find_val_correct1; auto ]. cut (a1 = a0); [ intros Heq | idtac ]. absurd (head ++ a :: l = head); auto. elim head; simpl in |- *; auto. red in |- *; intros; discriminate. intros a2 l0 H0; red in |- *; intros H1; case H0; auto. injection H1; auto. apply unique_key_in_inv with (l := c) (a := a1); auto. apply unique_prefix2; auto. rewrite Heq; auto. apply sym_equal; apply (unique_prefix1 c a0 a1 head (head ++ a :: l)); auto. elim head; simpl in |- *; auto. rewrite app_ass; auto. Qed. Definition decode (c : list (A * list bool)) (m : list bool) := decode_aux c nil m. Theorem decode_correct : forall c : code, unique_prefix c -> not_null c -> forall (m1 m2 : list bool) (a : A), find_val m1 c = Some a -> decode c (m1 ++ m2) = a :: decode c m2. Proof using. intros c H H0 m1 m2 a H1; unfold decode in |- *; apply decode_aux_correct; auto. Qed. Theorem correct_encoding : forall c : code, unique_prefix c -> not_null c -> forall m : list A, in_alphabet m c -> decode c (encode c m) = m. 
fexp x). now rewrite <- Fx. Qed. Lemma pred_pos_plus_ulp_aux2 : forall x, (0 < x)%R -> F x -> let e := ln_beta_val beta x (ln_beta beta x) in x = bpow (e - 1) -> (x - bpow (fexp (e-1)) <> 0)%R -> ((x - bpow (fexp (e-1))) + ulp (x - bpow (fexp (e-1))) = x)%R. Proof. intros x Zx Fx e Hxe Zp. replace (ulp (x - bpow (fexp (e - 1)))) with (bpow (fexp (e - 1))). ring. assert (He:(fexp (e-1) <= e-1)%Z). apply generic_format_bpow_inv with beta; trivial. rewrite <- Hxe; assumption. case (Zle_lt_or_eq _ _ He); clear He; intros He.rewrite ulp_neq_0; trivial. apply f_equal. unfold canonic_exp; apply f_equal. apply sym_eq. apply ln_beta_unique. rewrite Rabs_right. split. apply Rplus_le_reg_l with (bpow (fexp (e-1))). ring_simplify. apply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R. apply Rplus_le_compat; apply bpow_le; omega. apply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac]. apply Rle_trans with (bpow 1*bpow (e - 2))%R. apply Rmult_le_compat_r. apply bpow_ge_0. replace 2%R with (Z2R 2) by reflexivity. replace (bpow 1) with (Z2R beta). apply Z2R_le. apply <- Zle_is_le_bool. now destruct beta. simpl. unfold Zpower_pos; simpl. now rewrite Zmult_1_r. rewrite <- bpow_plus. replace (1+(e-2))%Z with (e-1)%Z by ring. now right. rewrite <- Rplus_0_r, Hxe. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0. apply Rle_ge; apply Rle_0_minus. rewrite Hxe. apply bpow_le. omega.contradict Zp. rewrite Hxe, He; ring. Qed.Lemma pred_pos_plus_ulp_aux3 : forall x, (0 < x)%R -> F x -> let e := ln_beta_val beta x (ln_beta beta x) in x = bpow (e - 1) -> (x - bpow (fexp (e-1)) = 0)%R -> (ulp 0 = x)%R. Proof. intros x Hx Fx e H1 H2. assert (H3:(x = bpow (fexp (e - 1)))). now apply Rminus_diag_uniq. assert (H4: (fexp (e-1) = e-1)%Z). apply bpow_inj with beta. now rewrite <- H1. unfold ulp; rewrite Req_bool_true; trivial. case negligible_exp_spec. intros K. specialize (K (e-1)%Z). contradict K; omega. intros n Hn. rewrite H3; apply f_equal. case (Zle_or_lt n (e-1)); intros H6. apply valid_exp; omega. apply sym_eq, valid_exp; omega. Qed. Theorem pred_pos_plus_ulp : forall x, (0 < x)%R -> F x -> (pred_pos x + ulp (pred_pos x) = x)%R. Proof. intros x Zx Fx. unfold pred_pos. case Req_bool_spec; intros H. case (Req_EM_T (x - bpow (fexp (ln_beta_val beta x (ln_beta beta x) -1))) 0); intros H1. rewrite H1, Rplus_0_l. now apply pred_pos_plus_ulp_aux3. now apply pred_pos_plus_ulp_aux2. now apply pred_pos_plus_ulp_aux1. Qed. Theorem ln_beta_plus_eps: forall x, (0 < x)%R -> F x -> forall eps, (0 <= eps < ulp x)%R -> ln_beta beta (x + eps) = ln_beta beta x :> Z. 
. Definition iscomprelfun2 { X Y : UU } ( R : hrel X ) ( f : X -> X -> Y ) := forall x x' x0 x0' : X , R x x' -> R x0 x0' -> paths ( f x x0 ) ( f x' x0' ) .Lemma iscomprelfun2if { X Y : UU } ( R : hrel X ) ( f : X -> X -> Y ) ( is1 : forall x x' x0 : X , R x x' -> paths ( f x x0 ) ( f x' x0 ) ) ( is2 : forall x x0 x0' : X , R x0 x0' -> paths ( f x x0 ) ( f x x0' ) ) : iscomprelfun2 R f . Proof . intros . intros x x' x0 x0' . intros r r' . set ( e := is1 x x' x0 r ) . set ( e' := is2 x' x0 x0' r' ) . apply ( pathscomp0 e e' ) . Defined . Lemma iscomprelfun2logeqf { X Y : UU } { L R : hrel X } ( lg : hrellogeq L R ) ( f : X -> X -> Y ) ( is : iscomprelfun2 L f ) : iscomprelfun2 R f . Proof . intros . intros x x' x0 x0' r r0 . apply ( is _ _ _ _ ( ( pr2 ( lg _ _ ) ) r ) ( ( pr2 ( lg _ _ ) ) r0 ) ) . Defined . Definition setquotuniv2 { X : UU } ( R : hrel X ) ( Y : hSet ) ( f : X -> X -> Y ) ( is : iscomprelfun2 R f ) ( c c0 : setquot R ) : Y . Proof. intros . set ( ff := fun xy : dirprod X X => f ( pr1 xy ) ( pr2 xy ) ) . set ( RR := hreldirprod R R ) . assert ( isff : iscomprelfun RR ff ) . intros xy x'y' . simpl . intro dp . destruct dp as [ r r'] . apply ( is _ _ _ _ r r' ) . apply ( setquotuniv RR Y ff isff ( dirprodtosetquot R R ( dirprodpair c c0 ) ) ) . Defined . Theorem setquotuniv2comm { X : UU } ( R : eqrel X ) ( Y : hSet ) ( f : X -> X -> Y ) ( is : iscomprelfun2 R f ) : forall x x' : X , paths ( setquotuniv2 R Y f is ( setquotpr R x ) ( setquotpr R x' ) ) ( f x x' ) . 
ms sm hm' * [[ r = firstn len (skipn start l) ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indread_range indlvl lxp ir start len ms. Proof. induction indlvl; cbn [indread_range]. + hoare. rewrite firstn_oob; indrep_n_tree_bound. rewrite indrep_n_helper_0 in *. destruct_lifts. rewrite skipn_repeat, firstn_repeat; auto. rewrite repeat_length in *; omega. rewrite indrep_n_helper_valid by auto. cancel. repeat f_equal. apply firstn_oob. indrep_n_tree_bound. + step; step. hoare. rewrite firstn_oob; indrep_n_tree_bound. step. step. erewrite indrep_n_tree_repeat_concat with (m := list2nmem m). 3: pred_apply; cancel. rewrite skipn_repeat, firstn_repeat; auto. indrep_n_tree_bound. match goal with H: _ + _ <= length ?l * _ |- _ => replace (length l) with NIndirect in *; indrep_n_tree_bound end. indrep_n_tree_bound. step. rewrite indrep_n_helper_valid by auto. cancel. rewrite firstn_oob by indrep_n_tree_bound. denote listmatch as Hl. pose proof Hl. step. indrep_n_extract. erewrite indrep_n_length_pimpl in *. destruct_lifts. hoare. erewrite skipn_hom_concat by eauto. rewrite firstn_app_l; auto. match goal with H: context [selN] |- _ => rename H into Hr end. autorewrite with core; rewrite Hr. omega. indrep_n_tree_bound. indrep_n_tree_bound. hoare. indrep_n_tree_bound. match goal with H: _ + _ <= length ?l * _ |- _ => replace (length l) with NIndirect in *; indrep_n_tree_bound end. Unshelve. apply emp. Qed. Local Hint Extern 1 ({{_}} Bind (indread_range _ _ _ _ _ _ ) _) => apply indread_range_ok : prog. Fixpoint indclear_all indlvl lxp bxp root ms := If (addr_eq_dec root 0) { Ret ms } else { let N := NIndirect ^ indlvl in ms <- match indlvl with | 0 => Ret ms | S indlvl' => let^ (lms, indbns) <- IndRec.read lxp root 1 (BALLOCC.MSLog ms); let msn := BALLOCC.upd_memstate lms ms in let^ (msn) <- ForEach bn indbns' indbns Hashmap hm Ghost [ F Fm Fs bxp crash m0 sm freelist l_part fsl ] Loopvar [ msn ] Invariant exists m freelist', LOG.rep lxp F (LOG.ActiveTxn m0 m) (BALLOCC.MSLog msn) sm hm * let n := length indbns - length indbns' in [[[ m ::: Fm * listmatch (fun x l' => indrep_n_tree indlvl' bxp (snd x) (# (fst x)) l') (combine (skipn n indbns) (skipn n fsl)) (skipn n l_part) * BALLOCC.rep bxp freelist' msn ]]] * [[ incl freelist freelist' ]] * [[ (Fs * pred_fold_left (skipn n fsl) * BALLOCC.smrep freelist')%pred sm ]] OnCrash crash Begin msn <- indclear_all indlvl' lxp bxp # bn msn; Ret ^(msn) Rof ^(msn); Ret msn end; BALLOCC.free lxp bxp root ms }. Theorem indclear_all_ok : forall indlvl lxp bxp ir ms, let N := NIndirect ^ indlvl in {< F Fm Fs IFS m0 sm m l freelist, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (BALLOCC.MSLog ms) sm hm * [[[ m ::: (Fm * indrep_n_tree indlvl bxp IFS ir l * BALLOCC.rep bxp freelist ms) ]]] * [[ (Fs * IFS * BALLOCC.smrep freelist)%pred sm ]] POST:hm' RET: ms exists m' freelist' l', LOG.rep lxp F (LOG.ActiveTxn m0 m') (BALLOCC.MSLog ms) sm hm' * [[[ m' ::: (Fm * indrep_n_tree indlvl bxp emp 0 l' * BALLOCC.rep bxp freelist' ms) ]]] * [[ (Fs * BALLOCC.smrep freelist')%pred sm ]] * [[ incl freelist freelist' ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indclear_all indlvl lxp bxp ir ms. 
RET LitV (LitLoc l); int.Z a d‚Ü¶{q}[aset] b ‚àó mapsto_block l 1 b }}}. Proof. iIntros (Œ¶) ">Ha HŒ¶". iApply wp_lift_atomic_head_step_no_fork; first by auto. iIntros (œÉ1 g1 ns mj D Œ∫ Œ∫s nt) "(HœÉ&Hd&Htr) Hg !>". cbv [ffi_local_ctx disk_interp]. iDestruct (@gen_heap_valid with "Hd Ha") as %?. iSplit. { iPureIntro. eexists _, _, _, _, _; simpl. constructor 1. rewrite /head_step /=. monad_simpl. simpl. monad_simpl. econstructor; [ eapply relation.suchThat_gen0; reflexivity | ]. monad_simpl. } iNext; iIntros (v2 œÉ2 g2 efs Hstep). apply head_step_atomic_inv in Hstep; [ | by inversion 1 ]. inv_head_step. monad_inv. iMod (global_state_interp_le with "Hg") as "$". { apply step_count_next_incr. } iMod (na_heap_alloc_list tls _ l (Block_to_vals b) (Reading O) with "HœÉ") as "(HœÉ & Hblock & Hl)". { rewrite length_Block_to_vals. rewrite /block_bytes. lia. } { destruct H1 as (?&?); eauto. } { destruct H1 as (H'&?); eauto. eapply H'. } { destruct H1 as (H'&?); eauto. destruct (H' 0) as (?&Hfresh). by rewrite (loc_add_0) in Hfresh. } { eauto. } iModIntro; iSplit; first done. iFrame. iApply "HŒ¶". iFrame. { rewrite /mapsto_block. iApply seq_mapsto_to_heap_array. iApply (big_sepL_mono with "Hl"). iIntros (k x Heq) "(Hli&Hmt)". iApply (na_mapsto_to_heap with "Hli"). destruct H1 as (H'&?). eapply H'. } Qed. Definition bindex_of_Z (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : fin block_bytes. cut (Z.to_nat i < 4096)%nat. { apply nat_to_fin. } change 4096%nat with (Z.to_nat 4096%Z). abstract (apply Z2Nat.inj_lt; auto; vm_compute; inversion 1). Defined. Theorem block_byte_index {ext: ffi_syntax} (b: Block) (i: Z) (Hlow: (0 <= i)%Z) (Hhi: (i < 4096)%Z) : Block_to_vals b !! Z.to_nat i = Some (LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi). Proof. unfold Block_to_vals. rewrite ?list_lookup_fmap. unfold bindex_of_Z. destruct (vlookup_lookup' b (Z.to_nat i) (b !!! bindex_of_Z i Hlow Hhi)) as [H _]. rewrite H; eauto. Qed. Theorem mapsto_block_extract i l q b : (0 <= i)%Z -> (i < 4096)%Z -> ‚ä¢ mapsto_block l q b -‚àó ‚àÉ v, (l +‚Çó i) ‚Ü¶{q} v ‚àó ‚åúBlock_to_vals b !! Z.to_nat i = Some v‚åù. Proof. unfold mapsto_block; intros Hlow Hhi. iIntros "Hm". pose proof (block_byte_index b i ltac:(auto) ltac:(auto)) as Hi. assert (heap_array l (Block_to_vals b) !! (l +‚Çó i) = Some $ LitV $ LitByte $ b !!! bindex_of_Z i Hlow Hhi) as Hha. { apply heap_array_lookup. eexists; intuition eauto. } iDestruct (big_sepM_lookup_acc _ _ _ _ Hha with "Hm") as "(Hmi&_)". iExists _. iFrame "Hmi". destruct_with_eqn (Block_to_vals b !! Z.to_nat i); auto. Qed. Theorem heap_valid_block l b q œÉ : na_heap.na_heap_ctx tls œÉ -‚àó mapsto_block l q b -‚àó ‚åú (forall (i:Z), (0 <= i)%Z -> (i < 4096)%Z -> match œÉ !! (l +‚Çó i) with | Some (Reading _, v) => Block_to_vals b !! Z.to_nat i = Some v | _ => False end) ‚åù. 
= 0). { apply and_exercise. apply H. } destruct H' as [Hn Hm]. rewrite Hn. reflexivity. Qed.Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Proof. intros P Q [HP HQ]. apply HP. Qed. Lemma proj2 : forall P Q : Prop, P /\ Q -> Q. Proof. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Proof. intros P Q [HP HQ]. split. - apply HQ. - apply HP. Qed. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Proof. intros P Q R [HP [HQ HR]]. Admitted. Check and.Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Proof. intros n m [Hn | Hm]. - rewrite Hn. reflexivity. - rewrite Hm. rewrite <- mult_n_O. reflexivity. Qed.Lemma or_intro : forall A B : Prop, A -> A \/ B. Proof. intros A B HA. left. apply HA. Qed.Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Proof. intros [|n]. - left. reflexivity. - right. reflexivity. Qed. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Proof. Admitted.Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Proof. Admitted.Module MyNot.Definition not (P:Prop) := P -> False.Notation "~ x" := (not x) : type_scope.Check not. End MyNot.Theorem ex_falso_quodlibet : forall (P:Prop), False -> P. Proof. intros P contra. destruct contra. Qed. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Proof. Admitted. Theorem zero_not_one : ~(0 = 1). Proof. intros contra. inversion contra. Qed.Check (0 <> 1). Theorem zero_not_one' : 0 <> 1. Proof. intros H. inversion H. Qed.Theorem not_False : ~ False. Proof. unfold not. intros H. destruct H. Qed.Theorem contradiction_implies_anything : forall P Q : Prop, (P /\ ~P) -> Q. Proof. intros P Q [HP HNA]. unfold not in HNA. apply HNA in HP. destruct HP. Qed.Theorem double_neg : forall P : Prop, P -> ~~P. Proof. intros P H. unfold not. intros G. apply G. apply H. Qed. Theorem contrapositive : forall (P Q : Prop), (P -> Q) -> (~Q -> ~P). Proof. Admitted.Theorem not_both_true_and_false : forall P : Prop, ~ (P /\ ~P). Proof. Admitted. Theorem not_true_is_false : forall b : bool, b <> true -> b = false. 
Require Import Koika.CompilerCorrectness.CircuitCorrectness Koika.CompilerCorrectness.LoweringCorrectness. Require Import Koika.Common Koika.Types Koika.Environments Koika.Logs. Require Import Koika.Lowering Koika.CircuitGeneration Koika.CircuitOptimization Koika.Compiler.Section Thm. Context {pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t: Type}. Context {eq_dec_var_t: EqDec var_t}. Context {R: reg_t -> type}. Context {Sigma: ext_fn_t -> ExternalSignature}. Context {FiniteType_reg_t: FiniteType reg_t}. Context {Show_var_t : Show var_t}. Context {Show_rule_name_t : Show rule_name_t}. Context (r: ContextEnv.(env_t) R). Context (sigma: forall f, Sig_denote (Sigma f)). Notation CR := (lower_R R). Notation CSigma := (lower_Sigma Sigma). Notation cr := (lower_r r). Notation csigma := (lower_sigma sigma). Context (lco: (@local_circuit_optimizer rule_name_t reg_t ext_fn_t CR CSigma (rwdata (rule_name_t := rule_name_t) CR CSigma) (lower_sigma sigma))). Section Standalone. Context (s: Syntax.scheduler pos_t rule_name_t). Context (rules: rule_name_t -> TypedSyntax.rule pos_t var_t fn_name_t R Sigma). Context (external: rule_name_t -> bool). Theorem compiler_correct: let spec_results := TypedSemantics.interp_cycle sigma rules s r in let circuits := compile_scheduler lco rules external s in forall reg, interp_circuit cr csigma (ContextEnv.(getenv) circuits reg) = bits_of_value (ContextEnv.(getenv) spec_results reg). 
Hin. apply isprogram_ot_iff in Hisp. repnd. assert (isprogram_bt (bterm lv nt1)) as Hass by (apply Hisp; auto). inverts Hass as Hass Hbt. inversion Hbt; auto. Qed.Lemma combine_vars_map_sp {p} : forall vars, combine vars (map vterm vars) = map (fun v => (v, @vterm p v)) vars. Proof. induction vars; simpl; sp. rewrite IHvars; sp. Qed.Lemma combine_vars_map : forall A, forall f : NVar -> A, forall vars, combine vars (map f vars) = map (fun v => (v, f v)) vars. Proof. induction vars; simpl; sp. rewrite IHvars; sp. Qed. Theorem in_selectbt {p} : forall (bt : @BTerm p) bts, LIn bt bts -> {n : nat $ n < length bts # selectbt bts n = bt}. Proof. intros ? ? Hin. induction bts. inverts Hin. invertsn Hin. - exists 0. split; simpl; auto. omega. - destruct IHbts; auto. exists (S x). repnd. split; simpl; try omega. auto. Qed. Theorem ntot_wf_iff {p} : forall o (bts : list (@BTerm p)), nt_wf (oterm o bts) <=> map num_bvars bts = OpBindings o # forall n : nat, n < length bts -> bt_wf (selectbt bts n). Proof. introv. sp_iff Case; introv H. Case "->". inverts H as Hbf Hmap. split; auto. introv Hlt. apply Hbf. apply selectbt_in; auto. Case "<-". repnd. constructor; auto. introv Hin. apply in_selectbt in Hin. exrepnd. rw <- Hin0;auto. Qed. Definition nvarxbt {p} : @BTerm p := bterm [] (vterm nvarx) .Lemma wf_cvterm {p} : forall vs : list NVar, forall t : @CVTerm p vs, wf_term (get_cvterm vs t). Proof. destruct t; simpl. rw @isprog_vars_eq in i; sp. rw @wf_term_eq; sp. Qed.Lemma isprogram_get_cterm {p} : forall a : @CTerm p, isprogram (get_cterm a). Proof. destruct a; sp; simpl. rw @isprogram_eq; sp. Qed.Hint Immediate isprogram_get_cterm.Lemma oterm_eq {p} : forall (o1 o2 : @Opid p) l1 l2, o1 = o2 -> l1 = l2 -> oterm o1 l1 = oterm o2 l2. Proof. sp; allrw; sp. Qed.Lemma bterm_eq {p} : forall l1 l2 (n1 n2 : @NTerm p), l1 = l2 -> n1 = n2 -> bterm l1 n1 = bterm l2 n2. Proof. sp; allrw; sp. Qed.Theorem selectbt_map {p} : forall lbt n (f: @BTerm p -> @BTerm p), n<length lbt -> selectbt (map f lbt) n = f (selectbt lbt n). Proof. induction lbt; introv Hlt. inverts Hlt. simpl. destruct n; subst. reflexivity. allunfold @selectbt. allsimpl. assert (n < (length lbt)) by omega. auto. Qed. Theorem eq_maps_bt {p} : forall (B : Type) (f : BTerm -> B) (g : BTerm -> B) (la lc : list (@BTerm p)), length la = length lc -> (forall n : nat, n < length la -> f (selectbt la n) = g (selectbt lc n)) -> map f la = map g lc. 
(Prod A U) T -> P | App u v => forall Ur V : term, typ e v V -> typ e u (Prod V Ur) -> le_type e (subst v Ur) T -> P | Prod A B => forall s1 s2 s3 : sort, rule s1 s2 s3 -> typ e A (Srt s1) -> typ (Ax A :: e) B (Srt s2) -> le_type e (Srt s3) T -> P end. Theorem inv_typ_conv : forall (e : env) (t U V : term), le_type e U V -> forall P : Prop, inv_typ e t V P -> inv_typ e t U P. do 5 intro. cut (forall x : term, le_type e x U -> le_type e x V). case t; simpl in |- *; intros. apply H1 with s2; auto with arith pts.apply H1 with x; auto with arith pts.apply H1 with s U0; auto with arith pts.apply H1 with Ur V0; auto with arith pts.apply H1 with s1 s2 s3; auto with arith pts.intros. apply le_type_trans with U; auto with arith pts. Qed. Theorem inversion_lemma : forall (e : env) (t T : term) (P : Prop), inv_typ e t T P -> typ e t T -> P. intros e t T P inv_P j. generalize P inv_P; clear inv_P P. elim j; simpl in |- *; intros. apply inv_P with s2; trivial with arith pts.inversion_clear H0. apply inv_P with x; trivial with arith pts. elim H1; trivial with arith pts.apply inv_P with s U; auto with arith pts.apply inv_P with Ur V; auto with arith pts.apply inv_P with s1 s2 s3; auto with arith pts.apply H0. apply inv_typ_conv with V; auto with arith pts.apply H0. apply inv_typ_conv with (Srt s); auto with arith pts. Qed. Ltac Inversion_typ T := let INVTYP := fresh "INVTYP" in (generalize T; intro INVTYP; inversion INVTYP using inversion_lemma; unfold inv_typ in |- *; clear INVTYP; intros). Lemma typ_free_db : forall (e : env) (t T : term), typ e t T -> free_db (length e) t. Proof. simple induction 1; intros; auto with pts. inversion_clear H1. constructor. elim H3; simpl in |- *; auto with arith.constructor; trivial. inversion_clear H1; trivial. Qed. Lemma wft_free_db : forall (e : env) (t : term), wf_type e t -> free_db (length e) t. simple destruct 1; try constructor; intros. apply typ_free_db with (1 := H0). Qed. Hint Resolve wft_free_db: pts. Theorem typ_weak : forall (g : env) (d : decl) (e : env) (t T : term), typ e t T -> forall (n : nat) (f : env), ins_in_env g d n e f -> wf f -> typ f (lift_rec 1 t n) (lift_rec 1 T n). 
<= 3 * sizeP P. Proof. induction P as [ | t P]. {now cbv. } setoid_rewrite encodeList_size_cons. rewrite IHP. unfold sizeP;cbn. setoid_rewrite size_sizeT_le. specialize (sizeT_ge_1 t). nia. Qed.Lemma size_L_enc_bools : (fun (bs:list bool) => L_facts.size (Extract.enc bs)) <=c (fun bs => length bs + 1). Proof. etransitivity. -eapply upToC_le with (F:= (fun bs => _ ));intros bs. rewrite Lists.size_list, sumn_le_bound. 2:{ intros ? (?&<-&?)%in_map_iff. rewrite LBool.size_bool. reflexivity. } rewrite map_length. reflexivity. -cbn. smpl_upToC_solve. Qed. Lemma M_init_one_Spec : { f : UpToC (fun '(bs,ter)=>length bs + L_facts.size ter + 1) & forall (bs:list bool) (ter : L.term), TripleT ‚âÉ‚âÉ([],[|Custom (eq (encBoolsTM s b bs));Contains _ (compile ter);Void;Void;Void;Void|]) (f (bs,ter)) M_init_one (fun _ => ‚âÉ‚âÉ([],[|Custom (eq (encBoolsTM s b bs));Contains _ (compile (L.app ter (encBoolsL bs)));Void;Void;Void;Void|])) }. Proof using H_disj. eexists_UpToC f. { [f]:refine (fun '(bs,ter) => _). intros bs ter. unfold M_init_one. hstep. { hsteps_cbn. cbn. eapply (projT2 (encBoolsTM2boollist.SpecT _ H_disj)). } cbn. intros _. hstep. { hsteps_cbn. cbn. tspec_ext. } 2:reflexivity. cbn. intros _. hstep. { hsteps_cbn. cbn. eapply ConsequenceT. eapply BoollistToEnc.SpecT with (bs:=rev bs). all:cbn. now tspec_ext. now rewrite rev_involutive. reflexivity. } 2:reflexivity. cbn. intros _. hsteps_cbn. now eapply (projT2 (APP_right_Spec)). 1,2:now cbn;tspec_ext. subst f. cbn beta. cbn beta iota. reflexivity. } etransitivity. { unfold f. eapply upToC_le with (F:=fun '(bs,ter) => _). intros [bs ter]. rewrite (correct__leUpToC (Rev_steps_nice _)). rewrite (correct__leUpToC (BoollistEnc.boollist_size)). do 3 rewrite (correct__leUpToC (correct__UpToC _)). rewrite rev_length. rewrite !size_le_sizeP. unfold sizeP;rewrite !sizeP_size. rewrite (correct__leUpToC size_L_enc_bools). reflexivity. } smpl_upToC_solve. Qed.End mk_init_one.Section mk_init. Variable Œ£ : finType. Variable s b : Œ£^+. Variable (H_disj : s <> b). Context (retr_pro : Retract sigPro Œ£) (retr_bools : Retract (sigList bool) Œ£). Variable m k : nat. Variable sim : term. Notation aux n := (Fin.L k (Fin.L m n)) (only parsing). Notation auxm n := (Fin.L k (Fin.R 6 n)) (only parsing). Notation auxk n := (Fin.R (6 + m) n) (only parsing). Fixpoint M_init' k' : (Vector.t (Fin.t k) k') -> pTM (Œ£) ^+ unit ((6 + m)+ k). Proof using m s retr_bools sim retr_pro. simple notypeclasses refine (match k' with 0 => fun _ => MK_isVoid_multi _ @ [|aux Fin1;aux Fin2;aux Fin3;aux Fin4; aux Fin5|];; WriteValue ( (compile sim)) ‚áë retr_pro @ [|aux Fin1|] | S k' => fun ren => _;;M_init_one s retr_pro retr_bools @ [|auxk (ren[@Fin0]);aux Fin1;aux Fin2;aux Fin3;aux Fin4;aux Fin5|] end). all:try exact _. 2:{apply (M_init' _ (Vector.tl ren)). } Defined. Theorem M_init'_SpecT k' (ren :Vector.t (Fin.t k) k') (v:Vector.t (list bool) k): { k & TripleT ‚âÉ‚âÉ([],Vector.const (Custom (eq niltape)) (6+m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v) k (M_init' ren) (fun _ => ‚âÉ‚âÉ([], ([|Custom (eq niltape); Contains retr_pro (compile (Vector.fold_right (fun l_i s => L.app s (encBoolsL l_i)) (select ren v) sim)) ;Void;Void;Void;Void|]++Vector.const (Custom (eq niltape)) m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v))}. 
fun ge fenv finfo_env m fds f t vs e => exists l locs finfo b, M.get f finfo_env = Some finfo /\ correct_fundef_info m f t vs e finfo /\ M.get t fenv = Some (l, locs) /\ l = N.of_nat (length vs) /\ Genv.find_symbol (globalenv p) f = Some b /\ repr_val_L6_L7 (cps.Vfun (M.empty cps.val) fds f) m (Vptr b Ptrofs.zero). Definition correct_environments_for_functions: fundefs -> genv -> fun_env -> M.t positive -> mem -> Prop := fun fds ge fenv finfo_env m => Forall_fundefs (correct_environments_for_function ge fenv finfo_env m fds) fds. Definition is_protected_id (id:positive) : Prop := List.In id protectedIdent.Definition is_protected_tinfo_id (id:positive) : Prop := id = allocIdent \/ id = limitIdent \/ id = argsIdent.Theorem is_protected_tinfo_weak: forall x, is_protected_tinfo_id x -> is_protected_id x. Proof. intros. repeat destruct H; subst; inList. Qed. Definition functions_not_bound (rho:L6.eval.env) (e:exp): Prop := (forall x, bound_var e x -> Genv.find_symbol (Genv.globalenv p) x = None)/\ (forall x y v, M.get y rho = Some v -> bound_notfun_val v x -> Genv.find_symbol (Genv.globalenv p) x = None).Inductive unique_bindings_val: L6.cps.val -> Prop := | UB_Vfun: forall rho fds f, unique_bindings_fundefs fds -> unique_bindings_val (Vfun rho fds f) | UB_Vconstr: forall c vs, Forall unique_bindings_val vs -> unique_bindings_val (Vconstr c vs) |UB_VInt: forall z, unique_bindings_val (cps.Vint z) . Definition unique_bindings_env (rho:L6.eval.env) (e:exp) : Prop := unique_bindings e /\ (forall x v, M.get x rho = Some v -> ~ bound_var e x /\ unique_bindings_val v). Theorem unique_bindings_env_prefix: forall e rho, unique_bindings_env rho e -> forall rho', prefix_ctx rho' rho -> unique_bindings_env rho' e. Proof. intros. inv H. split; auto. Qed. Theorem functions_not_bound_subterm: forall rho e, functions_not_bound rho e -> forall e', subterm_e e' e -> functions_not_bound rho e'. Proof. intros. split. intro; intros. apply H. eapply bound_var_subterm_e; eauto. apply H. Qed. Theorem functions_not_bound_set: forall rho e y v, functions_not_bound rho e -> (forall x, bound_notfun_val v x -> Genv.find_symbol (globalenv p) x = None) -> functions_not_bound (M.set y v rho) e. Proof. intros. split. apply H. intros. destruct (var_dec y0 y). - subst. rewrite M.gss in H1. inv H1. destruct H. apply H0. auto. - rewrite M.gso in H1 by auto. inv H. eapply H4; eauto. Qed. Definition protected_id_not_bound (rho:L6.eval.env) (e:exp) : Prop := (forall x y v, M.get x rho = Some v -> is_protected_id y -> ~ (x = y \/ bound_var_val v y) )/\ (forall y, is_protected_id y -> ~ bound_var e y). Theorem protected_id_not_bound_prefix: forall rho rho' e, protected_id_not_bound rho e -> prefix_ctx rho' rho -> protected_id_not_bound rho' e. 
Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). destruct n; reflexivity. Qed. Theorem queue_extensional : forall b p, HProp_extensional (queue b p). reflexivity. Qed. Theorem lseg_extensional' : forall ba n b b' fr, b %= b' -> lseg b n fr ba ===> lseg b' n fr ba. induction n; sepLemma. Qed. Theorem llist_extensional' : forall ba n b b' fr, b %= b' -> llist b n fr ba ===> llist b' n fr ba. induction n; sepLemma. Qed. Theorem queue_fwd : forall b p, queue b p ===> Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. unfold queue; sepLemma. Qed. Theorem queue_bwd : forall b p, (Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba) ===> queue b p. unfold queue; sepLemma. Qed. Theorem llist_empty_fwd : forall b n (fr : W) ba, fr = 0 -> llist b n fr ba ===> [| b %= empty |] * [| n = O |]. destruct n; sepLemma. Qed. Theorem llist_empty_bwd : forall b n (fr : W) ba, fr = 0 -> [| b %= empty |] * [| n = O |] ===> llist b n fr ba. 
Require Import Ensembles. Require Import Relations_1. Require Import podefs. Require Import podefs_1. Require Import ps.Section Lemmas_on_partial_orders. Variable U : Type. Variable B : Ensemble U. Variable D : PO U. Theorem Rel_of_reflexive : forall x : U, Rel_of U D x x. elim D; simpl in |- *; auto. intros C R H' H'0; elim H'0; auto 10. Qed. Hint Resolve Rel_of_reflexive. Theorem Rel_of_antisymmetric : Antisymmetric U (Rel_of U D). elim D; simpl in |- *; auto. intros C R H' H'0; elim H'0; auto 10. Qed. Hint Resolve Rel_of_antisymmetric. Theorem Rel_of_transitive : Transitive U (Rel_of U D). 
Require Import ZArith. Require Import Zquot.Section Zmissing. Theorem Zopp_le_cancel : forall x y : Z, (-y <= -x)%Z -> Zle x y. 
(pO A n)). intros a H; split; simpl in |- *; auto. red in |- *; simpl in |- *; apply Relation_Operators_compat.d_one. Qed. Hint Resolve canonicalp1 canonical0. Inductive eqP : list (Term A n) -> list (Term A n) -> Prop := | eqP0 : eqP (pO A n) (pO A n) | eqpP1 : forall ma mb p q, eqTerm (A:=A) eqA (n:=n) ma mb -> eqP p q -> eqP (pX ma p) (pX mb q). Hint Resolve eqP0 eqpP1. Theorem eqp_refl : reflexive _ eqP. red in |- *. intros x; elim x; auto. intros a l H; change (eqP (pX a l) (pX a l)) in |- *; apply eqpP1; auto. Qed. Theorem eqp_sym : symmetric _ eqP. red in |- *. intros x y H'; elim H'; auto. intros ma mb p q H H0 H1. apply eqpP1; auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Lemma eqp_inv1 : forall p, eqP (pO A n) p -> p = pO A n. unfold pO in |- *; intros p H'; inversion H'; auto. Qed. Theorem eqp_inv2 : forall p, eqP p (pO A n) -> p = pO A n. unfold pO in |- *; intros p H'; inversion H'; auto. Qed. Theorem eqp_inv3l : forall a b p q, eqP (pX a p) (pX b q) -> eqTerm (A:=A) eqA (n:=n) a b. intros a b p q H'; simple inversion H'; auto. unfold pO in H0; inversion H0. rewrite (pX_invl ma a p0 p); auto; rewrite (pX_invl mb b q0 q); auto. Qed. Theorem eqp_inv3r : forall a b p q, eqP (pX a p) (pX b q) -> eqP p q. intros a b p q H'; simple inversion H'; auto. unfold pO in H0; inversion H0. rewrite (pX_invr p0 p ma a); auto; rewrite (pX_invr q0 q mb b); auto. Qed. Theorem eqp_trans : transitive _ eqP. red in |- *. intros x; elim x; auto. intros y z H'; inversion_clear H'. intros H'0; inversion_clear H'0; auto. intros a l H' y z H'0; inversion_clear H'0. intros H4; inversion_clear H4. change (eqP (pX a l) (pX mb0 q0)) in |- *; apply eqpP1; eauto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := mb); auto. Qed. Hint Resolve eqp_refl. Let eqTerm_imp_eqT := eqTerm_imp_eqT A eqA n. Theorem ltP_refl_pX : forall (a : Term A n) (p : list (Term A n)), canonical A0 eqA ltM (pX a p) -> ltP (A:=A) (n:=n) ltM p (pX a p). 
index_instr as [index instr]; simpl in *; intros ???? Hsome Hcounter HStep; subst; try apply (stopping_stuck s Hsome) in HStep; destruct instr; inversion HStep; try contradiction; simpl in *; subst; lia. Defined. Definition execute_program_unknown_termination (program: list Instruction) (well_formed: WellFormed program) : nat -> forall cur, Within program cur -> option MachineState . refine (fix go steps cur _ := let (instr, _) := (get_instr cur program) in if (is_stopping instr) then Some cur else match steps with | 0 => None | S steps' => let (next, _) := (@execute_instruction instr cur _) in go steps' next _ end ); eauto. Defined. Section execute_program. Variable program: list Instruction. Variable well_formed: WellFormed program. Variable progression: MachineState -> MachineState -> Prop. Variable progression_wf: well_founded progression. Variable progress: forall cur next, Step program cur next -> progression next cur. Program Fixpoint execute_program cur (H: Within program cur) {wf progression cur} : MachineState := let (instr, _) := (get_instr cur program) in if (is_stopping instr) then cur else let (next, _) := (@execute_instruction instr cur _) in execute_program next _ . Solve All Obligations with eauto. End execute_program.End Sized.Notation Within program cur := (cur.(counter) < (length program)) (only parsing).Notation WellFormed program := (forall cur next, Step program cur next -> Within program next) (only parsing).Notation InstWellFormed len_program := (fun index instr => forall program cur next, len_program <= (length program) -> lookup (index%nat) program = Some instr -> cur.(counter) = (index%nat) -> Step program cur next -> Within program next ) (only parsing).Notation IndexPairsWellFormed program := (fun index_instr => InstWellFormed (length program) index_instr.1 index_instr.2) (only parsing).Ltac program_well_formed := match goal with | |- WellFormed ?program => let program_type := type of program in match program_type with | list (@Instruction ?size) => apply index_pairs_InstWellFormed_implies_WellFormed; find_obligations__helper (IndexPairsWellFormed program) (@check_instruction_well_formed size (length program)) (imap pair program) end end. Module redundant_additions. Definition program: list (@Instruction 1) := [ InstMov (Literal 0) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstAdd (Literal 1) (0%fin); InstExit ]. Theorem well_formed: WellFormed program. Proof. program_well_formed. Qed. Theorem within: Within program (state 0 [#0]). Proof. simpl; lia. Qed. Example test: execute_program_unknown_termination well_formed (length program) (state 0 [#0]) within = Some (state 6 [#5]). Proof. reflexivity. Qed. End redundant_additions.Module redundant_doubling. Definition program: list (@Instruction 1) := [ InstMov (Literal 1) (0%fin); InstAdd (Register 0%fin) (0%fin); InstAdd (Register 0%fin) (0%fin); InstAdd (Register 0%fin) (0%fin); InstExit ]. Theorem well_formed: WellFormed program. 
- destruct E as [a b]. unfold H10p_sem. cbn. now rewrite !nat_eval_poly. - intros. eapply (@sat_ext _ _ _ _ _ (rho >> @iŒº nat interp_nat)). intros x. change ((rho >> iŒº) x) with (@iŒº nat interp_nat (rho x)). induction (rho x). reflexivity. cbn. now rewrite IHn. eapply problem_to_model. apply nat_is_FA_model. assumption. Qed. Lemma nat_sat' E : (exists sigma, sat interp_nat sigma (embed_problem E)) <-> H10p E. Proof. split; intros [sigma ]; exists sigma; now apply nat_sat. Qed. Theorem H10p_to_FA_ext_sat E : H10p E <-> ext_entailment_PA (embed E). Proof. split. - intros [sigma HE]. intros D I rho Hext H. eapply subst_exist_sat. apply problem_to_ext_model. + apply Hext. + intros. apply H. now constructor. + apply HE. + rewrite <-exists_close_form; apply embed_is_closed. - intros H. specialize (H nat interp_nat id nat_extensional). unfold embed in *. apply subst_exist_sat2 in H. now apply nat_sat'. apply nat_is_PA_model. Qed. Theorem H10p_to_FA_sat E : H10p E <-> valid_ctx FAeq (embed E). Proof. split. - intros [sigma HE]. intros D I rho H. eapply subst_exist_sat. apply problem_to_model. + intros œÅ' ax Hax. eapply sat_closed. 2: now apply H. repeat (destruct Hax as [<- | Hax]; cbn; repeat solve_bounds; auto). inversion Hax. + apply HE. + rewrite <-exists_close_form; apply embed_is_closed. - intros H. specialize (H nat interp_nat id (nat_is_FA_model id)). unfold embed in *. apply subst_exist_sat2 in H. now apply nat_sat'. Qed. Theorem H10p_to_PA_sat E : H10p E <-> forall D (I : interp D) rho, (forall psi rho, PAeq psi -> rho ‚ä® psi) -> rho ‚ä® (embed E). Proof. split. - intros [sigma HE]. intros D I rho H. eapply subst_exist_sat. apply problem_to_model. + intros œÅ' ax Hax. apply sat_closed with rho. repeat (destruct Hax as [<- | Hax]; cbn; repeat solve_bounds; auto). 1:inversion Hax. apply H. now constructor. + apply HE. + rewrite <-exists_close_form; apply embed_is_closed. - intros H. specialize (H nat interp_nat id nat_is_PAeq_model). unfold embed in *. apply subst_exist_sat2 in H. now apply nat_sat'. Qed. Theorem H10p_to_FA_prv E : H10p E <-> FAeq ‚ä¢I embed E. Proof. split. - intros [sigma HE]. eapply subst_exist_prv. apply problem_to_prv, HE. rewrite <-exists_close_form; apply embed_is_closed. - intros H%soundness. now apply H10p_to_FA_sat. Qed. Theorem H10p_to_PA_prv E : H10p E <-> PAeq ‚ä¢TI embed E. Proof. split. - intros [sigma HE]. exists FAeq. split. intros. now constructor. apply H10p_to_FA_prv. now exists sigma. - intros H. apply nat_sat'. eapply subst_exist_sat2. apply (tsoundness H interp_nat id). intros. now apply nat_is_PAeq_model. Qed. Theorem H10_to_ext_entailment_PA : H10p ‚™Ø ext_entailment_PA. 
q2)%nat). intuition. eapply ratMult_leRat_compat; intuition. trivial. intuition. comp_inline_l. assert ( Pr [a1 <-$ (oc (fst (a, b)) a0) S0 eqds0 o (snd (a, b)); p <-$ ret (fst (fst a1), (snd (fst a1), snd a1)); ret evt (snd (snd p)) ] == Pr [a1 <-$ (oc (fst (a, b)) a0) S0 eqds0 o (snd (a, b)); ret evt (snd a1) ] ). comp_skip. simpl. intuition. rewrite H8. clear H8. simpl. eapply leRat_trans. eapply (@H1 ); intuition. reflexivity. intuition. repeat simp_in_support. destruct x. simpl in *. rewrite mult_comm. eapply qam_count_gen. eapply H0. intuition. eapply H5. eapply H7. eapply H8. simpl. rewrite <- ratMult_assoc. eapply ratMult_leRat_compat; intuition. eapply eqRat_impl_leRat. rewrite <- ratMult_num_den. eapply eqRat_terms; intuition. eapply H2. eapply plus_le_compat; intuition. rewrite <- mult_assoc. eapply mult_le_compat; intuition. rewrite mult_comm. intuition. rewrite IHqueries_at_most. eapply ratMult_leRat_compat; intuition. eapply leRat_terms; intuition. intuition. trivial. intuition. intuition. Grab Existential Variables. trivial. repeat econstructor; eauto.Qed.Theorem oc_eventProb_0_1 : forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat) (A B C : Set)(c : OracleComp A B C) n, queries_at_most c n -> forall (eqds : EqDec S)(o : S -> A -> Comp (B * S)) (s : S), (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) -> evt s = false -> (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) -> (forall s s' a b, In (b, s') (getSupport (o s a)) -> count s' <= 1 + (count s))%nat -> count s = 0%nat -> Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n). intuition. eapply leRat_trans. eapply oc_eventProb; intuition. eauto. rewrite H4. rewrite mult_1_l. rewrite plus_0_r. intuition. Qed.Local Open Scope nat_scope.Theorem qam_count : forall (A B C : Set)(c : OracleComp A B C)(q : nat), queries_at_most c q -> forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S), (forall a b x y, In (a, b) (getSupport (o x y)) -> count b <= 1 + (count x)) -> count s = 0 -> forall a b, In (a, b) (getSupport (c _ _ o s)) -> count b <= q. intuition. eapply le_trans. eapply qam_count_gen; eauto. omega.Qed.Local Transparent evalDist.Section RndInList. Variable eta : nat. Theorem RndInList_prob_h : forall (ls : list (Bvector eta)), (Pr[r <-$ {0, 1}^eta; ret (if (in_dec (EqDec_dec _) r ls) then true else false) ] <= (length ls) / 2 ^ eta)%rat. 
h' t r = st' -> st' = st \/ (type st' = Follower /\ currentTerm st' = t /\ log st' = log st) \/ (currentTerm st' = currentTerm st /\ log st' = log st /\ ((type st = Candidate /\ type st' = Leader /\ r = true /\ currentTerm st = t /\ wonElection (dedup name_eq_dec (h' :: votesReceived st)) = true) \/ type st' = type st)). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; try find_inversion; subst; simpl in *; intuition; do_bool; intuition; try right; congruence. Qed. Lemma contradict_leaderLogs_term_sanity : forall net h t ll e, refined_raft_intermediate_reachable net -> In (t, ll) (leaderLogs (fst (nwState net h))) -> In e ll -> eTerm e = currentTerm (snd (nwState net h)) -> False. Proof using lltsi. intros. find_copy_eapply_lem_hyp leaderLogs_term_sanity_invariant; eauto. find_eapply_lem_hyp leaderLogs_currentTerm_invariant; eauto. omega. Qed. Arguments dedup : simpl never. Lemma leaderLogs_candidate_entries_rvr : forall net, leaderLogs_candidateEntries net -> votes_correct net -> cronies_correct net -> forall p h t ll e, In (t, ll) (leaderLogs (fst (nwState net h))) -> In e ll -> In p (nwPackets net) -> pBody p = RequestVoteReply (eTerm e) true -> currentTerm (snd (nwState net (pDst p))) = eTerm e -> wonElection (dedup name_eq_dec (pSrc p :: votesReceived (snd (nwState net (pDst p))))) = true -> type (snd (nwState net (pDst p))) <> Candidate. Proof using. intros. eapply_prop_hyp leaderLogs_candidateEntries In; eauto. eapply wonElection_candidateEntries_rvr; auto. eauto. auto. auto. Qed. Theorem leaderLogs_sublog_request_vote_reply : refined_raft_net_invariant_request_vote_reply leaderLogs_sublog. Proof using vci cci llcei lltsi lsi rri. unfold refined_raft_net_invariant_request_vote_reply, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp handleRequestVoteReply_RVR_spec. intuition. - subst. repeat find_rewrite. repeat update_destruct_max_simplify; eauto; find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition eauto; unfold raft_data in *; congruence. - repeat update_destruct_max_simplify; try congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition eauto. subst_max. repeat find_rewrite. discriminate. + eauto. - repeat update_destruct_max_simplify. + repeat find_rewrite. find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * exfalso. eauto using contradict_leaderLogs_term_sanity. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. exfalso. eapply leaderLogs_candidate_entries_rvr; eauto; eauto using leaderLogs_candidate_entries_invariant, votes_correct_invariant, cronies_correct_invariant. congruence. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * eauto. * subst. unfold raft_data in *. repeat find_rewrite. eapply lifted_leader_sublog_host; eauto. + eauto. - repeat update_destruct_max_simplify. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. eauto. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. discriminate. + eauto. Qed. Theorem leaderLogs_sublog_do_leader : refined_raft_net_invariant_do_leader leaderLogs_sublog. 
(~ List.In v (f :: ys)). { intros Hc. eapply H0; eauto. } assert (~ (occurs_free e) v). { intro; apply H0. eapply Free_Eletapp2; eauto. } eapply H in H2. inv H2. left. apply not_occur_list_not_in in H1. eapply num_occur_n. constructor; eauto. lia. right. econstructor. eassumption. - assert ( ~ occurs_free_fundefs f2 v). intro. apply H1. apply Free_Efun2. auto. assert (Hf2 := Decidable_name_in_fundefs f2). destruct Hf2. specialize (Dec v). destruct Dec as [Hin | Hnin]. + right. constructor. apply name_in_fundefs_bound_var_fundefs. auto. + assert (~ occurs_free e v). intro. apply H1. constructor; auto. apply H0 in H3. apply H in H2. inv H3. inv H2. left. eapply num_occur_n. constructor; eauto. auto. right; auto. right; auto. - left. eapply num_occur_n. constructor. simpl. destruct (cps_util.var_dec v v0). exfalso; apply H; subst; auto. apply not_occur_list_not_in. intro; apply H. constructor. auto. - destruct (var_dec v0 v). + right. subst. constructor. + assert (~ List.In v l). intro; apply H0. constructor; auto. assert (~ (occurs_free e) v). intro; apply H0. apply Free_Eprim2; auto. apply H in H2. inv H2. left. apply not_occur_list_not_in in H1. eapply num_occur_n. constructor. apply H3. rewrite H1. auto. right. apply bound_var_Eprim. left; auto. - left. eapply num_occur_n. constructor. simpl. destruct (cps_util.var_dec v v0). exfalso; apply H; subst; auto. auto. - destruct (var_dec v0 v). right; subst; auto. assert (Hl := Decidable_FromList l). inv Hl. specialize (Dec v). inv Dec. right. constructor. right; auto. assert (Hf5 := Decidable_name_in_fundefs f5). destruct Hf5; specialize (Dec v); inv Dec. right. constructor 2. apply name_in_fundefs_bound_var_fundefs. auto. assert (~ occurs_free e v). intro; apply H1. constructor; auto. apply H in H4. assert (~ occurs_free_fundefs f5 v). intro; apply H1. constructor 2; auto. apply H0 in H5. destruct H4. destruct H5. left. eapply num_occur_fds_n. constructor; eauto. auto. right. constructor 2. auto. right. auto. - left; constructor. Qed. Theorem Disjoint_Setminus_swap: forall {A} s1 s2 s3, Disjoint A (Setminus _ s1 s2) s3 <-> Disjoint A s1 (Setminus _ s3 s2). Proof. intros. split; intro. - split; intro; intro. inv H. specialize (H1 x). apply H1. inv H0. inv H2. split; eauto with Ensembles_DB. split; auto. - split; intro; intro. inv H. inv H0. specialize (H1 x). inv H. apply H1. split. auto. split; auto. Qed. Theorem Disjoint_Dom_map_funs f2 sig s : Disjoint _ (Dom_map sig) (Setminus _ s (name_in_fundefs f2)) -> Disjoint M.elt (Dom_map (remove_all sig (all_fun_name f2))) s. Proof. intros. rewrite Dom_map_remove_all. apply Disjoint_Setminus_swap. rewrite Same_set_all_fun_name in H. auto. Qed. Theorem Disjoint_dom_rename_all: (forall e sig, Disjoint _ (Dom_map sig) (occurs_free e) -> rename_all sig e = e) /\ (forall f sig, Disjoint _ (Dom_map sig) (occurs_free_fundefs f :|: name_in_fundefs f) -> rename_all_fun sig f = f). 
decidable (T P). Proof. apply Dec. Qed. Theorem fa_fun_bool_decidable : decidable (forall P, K P). Proof using HK H2 H1 Dec. assert (H : decidable (forall P, T P)). { apply fa_fun_pos_bool_decidable; auto. } destruct H as [ H | H ]; [ left | right ]. + intros P. generalize (H (fun p => P (j p))). apply HK; intro; rewrite Hji; auto. + contradict H; intros P; apply H. Qed. Theorem ex_fun_bool_decidable : decidable (exists P, K P). Proof using HK H2 H1 Dec. assert (H : decidable (exists P, T P)). { apply ex_fun_pos_bool_decidable; auto. } destruct H as [ H | H ]; [ left | right ]. + destruct H as (P & H). exists (fun x => P (i x)); auto. + contradict H. destruct H as (P & H). exists (fun p => P (j p)). revert H; apply HK. intro; rewrite Hji; auto. Qed.End decidable_fun_finite_bool.Section decidable_upto. Variable (X : Type) (R : X -> X -> Prop) (P : X -> Prop) (HP : forall x, decidable (P x)) (HR : forall x y, R x y -> P x <-> P y). Theorem decidable_list_upto_fa l : (forall x, exists y, In y l /\ R x y) -> decidable (forall x, P x). Proof using HR HP. intros Hl. destruct list_dec with (P := fun x => ~ P x) (Q := P) (l := l) as [ (x & H1 & H2) | H ]. + intros x; generalize (HP x); unfold decidable; tauto. + right; contradict H2; auto. + left; intros x. destruct (Hl x) as (y & H1 & H2). generalize (H _ H1); apply (HR H2). Qed. Theorem decidable_list_upto_ex l : (forall x, exists y, In y l /\ R x y) -> decidable (exists x, P x). Proof using HR HP. intros Hl. destruct list_dec with (1 := HP) (l := l) as [ (x & H1 & H2) | H ]. + left; exists x; auto. + right; intros (x & Hx). destruct (Hl x) as (y & H1 & H2). apply (H _ H1). revert Hx; apply (HR H2). Qed.End decidable_upto.Definition fun_ext X Y (f g : X -> Y) := forall x, f x = g x. Definition prop_ext X (f g : X -> Prop) := forall x, f x <-> g x.Section fun_pos_finite_t_upto. Variable (X : Type) (HX : finite_t X). Theorem fun_pos_finite_t_upto n : finite_t_upto (pos n -> X) (@fun_ext _ _). 
Require Import Classical.Require Import Ensembles. Require Import Relations_1. Require Import Relations_1_facts. Require Import podefs. Require Import podefs_1.Section The_power_set_partial_order. Variable U : Type. Inductive Power_set (A : Ensemble U) : Ensemble (Ensemble U) := Definition_of_Power_set : forall X : Ensemble U, Included U X A -> In (Ensemble U) (Power_set A) X. Hint Resolve Definition_of_Power_set. Variable A : Ensemble U. Theorem Empty_set_minimal : forall X : Ensemble U, Included U (Empty_set U) X. Proof. red in |- *; intros X x H'; elim H'. Qed. Hint Resolve Empty_set_minimal. Theorem Power_set_non_empty : forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A). Proof. intro A'; apply Non_empty_intro with (Empty_set U); auto. Qed. Hint Resolve Power_set_non_empty. Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U). Proof. auto 8. Qed. Hint Resolve Inclusion_is_an_order. Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U). elim Inclusion_is_an_order; auto. Qed. Hint Resolve Inclusion_is_transitive. Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U). Proof. generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H'; auto. Qed. Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U). 
|- *; auto; intros; discriminate. rewrite HH2 in H8; injection H8; auto. generalize H6; rewrite HH3; case l0; simpl in |- *; auto; intros; discriminate. Qed. Theorem height_pred_shrink : forall (n a b : nat) (ln1 ln2 : list nat) (t t1 t2 : btree A) (l1 l2 : list (btree A)), height_pred n (ln1 ++ a :: b :: ln2) (l1 ++ t1 :: t2 :: l2) t -> (forall n1 : nat, In n1 ln1 -> n1 < a) -> (forall n1 : nat, In n1 (b :: ln2) -> n1 <= a) -> length ln1 = length l1 -> height_pred n (ln1 ++ pred a :: ln2) (l1 ++ node t1 t2 :: l2) t. Proof using. intros n a b ln1 ln2 t t1 t2 l1 l2 H H0 H1 H2; apply height_pred_shrink_aux with (1 := H) (b := b); auto. Qed. Theorem height_pred_compute_code : forall (n : nat) (t : btree A), height_pred n (map (fun x => length (snd x) + n) (compute_code t)) (map (fun x => leaf (fst x)) (compute_code t)) t. Proof using. intros n t; generalize n; elim t; clear t n; simpl in |- *; auto. intros b H b0 H0 n. repeat rewrite map_app. cut (forall (b : bool) l, map (fun x : A * list bool => length (snd x) + n) (map (fun v : A * list bool => let (a1, b1) := v in (a1, b :: b1)) l) = map (fun x : A * list bool => length (snd x) + S n) l); [ intros E1 | idtac ]. cut (forall b l, map (fun x : A * list bool => leaf (fst x)) (map (fun v : A * list bool => let (a1, b1) := v in (a1, b :: b1)) l) = map (fun x : A * list bool => leaf (fst x)) l); [ intros E2 | idtac ]. apply height_pred_node; repeat rewrite E1; repeat rewrite E2; auto. intros b1 l; elim l; simpl in |- *; auto. intros a; case a; simpl in |- *; auto. intros a0 l0 l1 H1; apply f_equal2 with (f := cons (A:=btree A)); auto. intros b1 l; elim l; simpl in |- *; auto. intros a; case a; simpl in |- *; auto. intros a0 l0 l1 H1; apply f_equal2 with (f := cons (A:=nat)); auto. Qed. Theorem weight_tree_compute : forall (m : list A) t, distinct_leaves t -> (forall a : A, f a = number_of_occurrences eqA_dec a m) -> length (encode eqA_dec (compute_code t) m) = weight_tree f t. 
Require Import Bedrock.LabelMap.Require Import Coq.Strings.Ascii Coq.NArith.NArith Coq.Strings.String Coq.Structures.OrderedType Coq.FSets.FSetAVL.Module StringKey. Definition t := string. Definition eq := @eq t. Definition lt (s1 s2 : t) := string_lt s1 s2 = true. Theorem eq_refl : forall x : t, eq x x. congruence. Qed. Theorem eq_sym : forall x y : t, eq x y -> eq y x. congruence. Qed. Theorem eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z. 
q = Float m (Fexp p) :>R. intros p q H'. replace (FtoRradix q) with (FtoRradix (Fnormalize radix b precision q)). 2: unfold FtoRradix in |- *; apply FnormalizeCorrect; auto. case (Zle_or_lt (Fexp (Fnormalize radix b precision q)) (Fexp p)); intros H'1. exists (Fnum p). unfold FtoRradix in |- *; apply FSuccZleEq with (3 := pGivesBound); auto.replace (Float (Fnum p) (Fexp p)) with p; [ idtac | case p ]; auto. replace (FtoR radix (Fnormalize radix b precision q)) with (FtoR radix q); [ idtac | rewrite FnormalizeCorrect ]; auto. apply isMin_inv1 with (1 := H'); auto. replace (FSucc b radix precision (Fnormalize radix b precision q)) with (FNSucc b radix precision q); [ idtac | case p ]; auto. replace (Float (Fnum p) (Fexp p)) with p; [ idtac | case p ]; auto. case (Req_dec p q); intros Eq0. unfold FtoRradix in Eq0; rewrite Eq0. apply FNSuccLt; auto. case (MinMax q p); auto. intros H'2 H'3; elim H'3; intros H'4 H'5; clear H'3. case H'4; auto. intros H'0; absurd (p <= q)%R; rewrite H'0; auto. apply Rlt_not_le; auto. unfold FtoRradix in |- *; apply FNSuccLt; auto. inversion H'. elim H0; intros H'3 H'6; apply H'6; clear H0; auto. rewrite <- H'0; auto with real. exists (Fnum (Fshift radix (Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (Fnormalize radix b precision q))). pattern (Fexp p) at 2 in |- *; replace (Fexp p) with (Fexp (Fshift radix (Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (Fnormalize radix b precision q))). unfold FtoRradix in |- *; rewrite <- FshiftCorrect with (n := Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (x := Fnormalize radix b precision q). case (Fshift radix (Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (Fnormalize radix b precision q)); auto. auto with arith. simpl in |- *; rewrite inj_abs; auto with zarith. Qed. Theorem MaxBinade : forall (r : R) (p : float), Fbounded b p -> (r <= p)%R -> (FNPred b radix precision p < r)%R -> isMax r p. intros r p H' H'0 H'1. rewrite <- (Ropp_involutive r). rewrite <- (Fopp_Fopp p). apply MinOppMax. apply MinBinade; auto with real float. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real.rewrite <- (Fopp_Fopp (FNSucc b radix precision (Fopp p))). rewrite <- FNPredFopFNSucc; auto. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real arith. Qed. Theorem MaxMin : forall (p : float) (r : R), isMax r p -> r <> p :>R -> isMin r (FNPred b radix precision p). 
H0 H1). split. exact (H8 x (Opp y) H0 H18). elim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18. pattern O at 1 in |- *; elim H20; elim H21; clear H20 H21. elim (H13 x y (Opp y)); intros; rewrite H0; clear H H0. elim (H13 x (Opp y) y); intros; rewrite H0; auto. Qed. Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y). intros. elim H; intros; elim H3; intros; elim H4; intros; elim H5; intros. elim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros. elim H17; intros; elim H19; intros. clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19. apply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)). unfold is_opposite in |- *; split. exact (H8 x y H0 H1). split. exact (H8 (Opp x) y H18 H1). elim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18. pattern O at 1 in |- *; elim H20; elim H21; clear H20 H21. elim (H13 x (Opp x) y); intros; rewrite H; clear H H0. elim (H13 (Opp x) x y); intros; rewrite H; auto. Qed. Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y. intros. elim H; intros; elim H3; intros; elim H4; intros; elim H5; intros. elim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros. elim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19. rewrite (mult_opp_r H (Opp x) y H18 H1). rewrite (mult_opp_l H x y H0 H1). symmetry in |- *. exact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)). Qed. Definition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}. Definition is_unitary_commutative_ring := is_ring /\ commutativity S Mult /\ neutral S A Mult I.Definition divide (a b : S) := A a /\ A b /\ (b = O \/ a <> O /\ (exists q : S, A q /\ b = Mult a q)). Theorem div_O_O : is_ring -> divide O O. 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.PRF. Require Import hmacfcf.splitVector. Require Import hmacfcf.cAU. Require Import FCF.CompFold.Local Open Scope list_scope.Section hF. Variable b k c : nat. Variable h : Bvector c -> Bvector b -> Bvector c. Variable F : Bvector k -> list (Bvector b) -> Bvector b. Definition hF key m := [k_Out, k_In] <-2 splitVector c k key; h k_Out (F k_In m). Variable A : OracleComp (list (Bvector b)) (Bvector c) bool. Hypothesis A_wf : well_formed_oc A. Definition G0 := k_in <-$ {0, 1}^k; k_out <-$ {0, 1}^c; [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Definition G1 := k_in <-$ {0, 1}^k; [b, _] <-$2 A _ _ (fun (s : list (Bvector b * Bvector c)) m => randomFunc ({0, 1}^c) _ s (F k_in m)) nil; ret b. Definition G2 := [b, _] <-$2 A _ _ (fun (s : list (list (Bvector b) * Bvector c)) m => randomFunc ({0, 1}^c) _ s m) nil; ret b. Definition G0_1 := [k_out, k_in] <-$2 ( key <-$ {0, 1}^(c + k); ret splitVector c k key); [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt; ret b. Theorem G0_1_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1]. unfold PRF_G_A, G0_1. inline_first. comp_skip. unfold f_oracle, hF. remember (splitVector c k x) as z. comp_simp. reflexivity. Qed. Require Import FCF.DetSem FCF.SemEquiv. Theorem G0_1_G0_equiv : Pr[G0_1] == Pr[G0]. unfold G0_1, G0. eapply eqRat_trans. eapply evalDist_seq_eq. eapply Rnd_split_equiv. intros. eapply eqRat_refl. inline_first. comp_swap_r. comp_skip. inline_first. comp_skip. Qed. Theorem G0_equiv : Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0]. 
Require Export Finite_sets. Require Export Constructive_sets. Require Export Classical. Require Export Classical_sets. Require Export Powerset. Require Export Powerset_facts. Require Export Powerset_Classical_facts. Require Export Gt. Require Export Lt.Section Finite_sets_facts. Variable U : Type. Lemma finite_cardinal : forall X:Ensemble U, Finite U X -> exists n : nat, cardinal U X n. Proof. induction 1 as [| A _ [n H]]. exists 0; auto with sets. exists (S n); auto with sets. Qed. Lemma cardinal_finite : forall (X:Ensemble U) (n:nat), cardinal U X n -> Finite U X. Proof. induction 1; auto with sets. Qed. Theorem Add_preserves_Finite : forall (X:Ensemble U) (x:U), Finite U X -> Finite U (Add U X x). 
mod m = (a + b) mod m + m. intros a b m H. rewrite Z_div_mod_eq with (a := a mod m + b mod m) (b := m). elim sum_r'_i with (a := a) (b := b) (m := m). intro H0. rewrite H0. left. rewrite <- Zmod_plus_distr_l. rewrite Zplus_comm with (n := a). rewrite <- Zmod_plus_distr_l. rewrite Zplus_comm with (m := a). ring. omega. omega. intro H0. rewrite H0. right. rewrite <- Zmod_plus_distr_l. rewrite Zplus_comm with (n := a). rewrite <- Zmod_plus_distr_l. rewrite Zplus_comm with (m := a). ring. omega. omega. omega. omega. Qed.Lemma div_m_1 : forall m : Z, 0 < m -> 2 ^ Zlog_sup m / m = 1. intros m H. elim (Zle_lt_or_eq 1 m). intro H0. replace (2 ^ Zlog_sup m) with (1 * m + (2 ^ Zlog_sup m - m)). apply Zdiv_mult_plus. omega. cut (m <= 2 ^ Zlog_sup m). omega. elim (Zlog_sup_correct2 m). tauto. assumption. cut (2 ^ Zlog_sup m < m + m). omega. apply Zlt_le_trans with (2 ^ (Zlog_sup m - 1) + 1 + (2 ^ (Zlog_sup m - 1) + 1)). replace (2 ^ (Zlog_sup m - 1) + 1 + (2 ^ (Zlog_sup m - 1) + 1)) with (2 ^ (Zlog_sup m - 1) + 2 ^ (Zlog_sup m - 1) + 2). rewrite Z_pow_plus. replace (Zlog_sup m - 1 + 1) with (Zlog_sup m). omega. ring. cut (1 <= Zlog_sup m). omega. replace 1 with (Zlog_sup 2). apply Zlog_sup_seq. omega. trivial. ring. apply Zplus_le_compat. cut (2 ^ (Zlog_sup m - 1) < m). omega. elim (Zlog_sup_correct2 m). tauto. assumption. cut (2 ^ (Zlog_sup m - 1) < m). omega. elim (Zlog_sup_correct2 m). tauto. assumption. ring. intro H0. rewrite <- H0. simpl. unfold Zdiv. trivial. omega. Qed.Lemma div_r'_i : forall a m : Z, 0 < m -> a mod 2 ^ Zlog_sup m / m = 0 \/ a mod 2 ^ Zlog_sup m / m = 1. intros a m H. cut (0 <= a mod 2 ^ Zlog_sup m / m). cut (a mod 2 ^ Zlog_sup m / m <= 1). omega. apply Zle_trans with (2 ^ Zlog_sup m / m). apply Zdiv_le. assumption. cut (a mod 2 ^ Zlog_sup m < 2 ^ Zlog_sup m). omega. apply Zmod_lt_z_m. apply lt_0_Zpow. apply Zlog_sup_correct1. assumption. rewrite div_m_1. omega. assumption. apply Zle_0_div. apply Zmod_le_0_z. apply lt_0_Zpow. apply Zlog_sup_correct1. assumption. assumption. Qed. Theorem approx_0_m2 : forall (y b : Zpls) (a : Z_ y) (x : Z_ (a * b + a)), x / y - 2 <= x / a * (a * b / y) / b <= x / y. 
:: xs)]] = {{pack #[[x]]}} ^| [[utila_expr_foldr (case f) _ xs]] := utila_expr_foldr_correct_cons (case f) ($0)%kami_expr x0 xs || _ = a ^| [[utila_expr_foldr (case f) _ xs]] @a by <- wor_wzero _ (if {{f #[[x0]]}} then {{pack #[[x0]]}} else (ZToWord _ 0)) || _ = (if a : bool then _ else _) ^| _ @a by <- fx0_true || _ = {{pack #[[a]]}} ^| _ @a by <- eq_x0_x in sumbool_ind (fun _ => [[utila_expr_foldr (case f) ($0)%kami_expr (x0 :: xs)]] = {{pack #[[x]]}}) (fun in_x_xs : In x xs => red0 || _ = _ ^| a @a by <- eq_pack_x in_x_xs || _ = a @a by <- wor_idemp _ {{pack #[[x]]}}) (fun not_in_x_xs : ~ In x xs => let eq_0 : [[utila_expr_foldr (case f) ($0)%kami_expr xs]] = {{$0}} := utila_expr_find_lm1 f ($0)%kami_expr xs (fun y (in_y_xs : In y xs) => not_true_is_false {{f #[[y]]}} (fun fy_true : {{f #[[y]]}} = true => not_in_x_xs (in_y_xs || In a xs @a by eq_x y (conj (or_intror _ in_y_xs) fy_true)))) in red0 || _ = _ ^| a @a by <- eq_0 || _ = a @a by <- wzero_wor _ {{pack #[[x]]}}) (kami_in_dec x xs)) (fun not_eq_x0_x : x0 <> x => let fx0_false : {{f #[[x0]]}} = false := not_true_is_false {{f #[[x0]]}} (fun fx0_true : {{f #[[x0]]}} = true => not_eq_x0_x (eq_sym (eq_x x0 (conj (or_introl _ eq_refl) fx0_true)))) in sumbool_ind (fun _ => [[utila_expr_foldr (case f) ($0) (x0 :: xs)]] = {{pack #[[x]]}}) (fun in_x_xs : In x xs => utila_expr_find_lm0 f ($0) x0 xs fx0_false || _ = a @a by <- eq_pack_x in_x_xs) (fun not_in_x_xs : ~ In x xs => False_ind _ (or_ind not_eq_x0_x not_in_x_xs (proj1 (proj1 H)))) (kami_in_dec x xs)) (kami_exprs_eq_dec x0 x))). Qed. Theorem utila_expr_find_correct : forall (k : Kind) (f : k @# type -> Bool @# type) (xs : list (k ## type)) (x : k ## type), (unique (fun y => In y xs /\ {{f #[[y]]}} = true) x) -> [[utila_expr_find f xs]] = [[x]]. Proof. (intros). (unfold utila_expr_find). (unfold evalLetExpr at 1). (fold evalLetExpr). replace (fun (x0 : Expr type (SyntaxKind k)) (acc : Expr type (SyntaxKind (Bit (size k)))) => (Kor ((IF f x0 then pack x0 else (Const type (natToWord _ 0))) :: acc :: nil))) with (case f). (rewrite (utila_expr_find_lm2 f xs H)). (apply unpack_pack). (unfold case). reflexivity. Qed. End utila_expr_find. Theorem utila_expr_find_pkt_correct : forall (k : Kind) (xs : list (Maybe k ## type)) (x : Maybe k ## type), (unique (fun y => In y xs /\ {{#[[y]] @% "valid"}} = true) x) -> [[utila_expr_find_pkt xs]] = [[x]]. 
: nat} : ¬¨ (n = m) <- n ‚â m. Proof. exact (pr2 (natneq_iff_neq n m)). Defined.Lemma nat_nopath_to_neq {n m : nat} : ¬¨ (n = m) -> n ‚â m. Proof. exact (pr1 (natneq_iff_neq n m)). Defined.Lemma natneq0sx (x : nat) : 0 ‚â S x. Proof. apply nat_nopath_to_neq, negpaths0sx. Defined.Lemma natneqsx0 (x : nat) : S x ‚â 0. Proof. apply nat_nopath_to_neq, negpathssx0. Defined.Lemma natneqinjS (x x' : nat) : x ‚â x' -> S x ‚â S x'. Proof. intros r. apply nat_nopath_to_neq, noeqinjS, nat_neq_to_nopath. assumption. Defined.Lemma isirrefl_natneq i : ¬¨ (i ‚â i). Proof. intros ne. apply (nat_neq_to_nopath ne). apply idpath. Defined.Lemma issymm_natneq i j : i ‚â j -> j ‚â i. Proof. intros ne. apply nat_nopath_to_neq. intro eq. induction eq. exact (isirrefl_natneq j ne). Defined. Definition isdeceqnat: isdeceq nat. Proof. unfold isdeceq. intro x. induction x as [ | x IHx ]. - intro x'. induction x'. + apply (ii1 (idpath O)). + apply (ii2 (negpaths0sx x')). - intro x'. induction x'. + apply (ii2 (negpathssx0 x)). + induction (IHx x') as [ p | e ]. * apply (ii1 (maponpaths S p)). * apply (ii2 (noeqinjS _ _ e)). Defined.Definition isisolatedn (n : nat) : isisolated _ n. Proof. unfold isisolated. intro x'. apply isdeceqnat. Defined.Theorem isasetnat: isaset nat. Proof. apply (isasetifdeceq _ isdeceqnat). Defined.Definition natset : hSet := make_hSet _ isasetnat.Lemma nat_eq_or_neq (m n : nat) : (m = n) ‚®ø (m ‚â n). Proof. revert m. induction n as [|n N]. - intro m. induction m as [|m _]. + apply ii1. apply idpath. + apply ii2. exact tt. - intro m. induction m as [|m _]. + apply ii2. exact tt. + induction (N m) as [eq|neq]. * apply ii1, maponpaths. assumption. * apply ii2. assumption. Defined.Definition isdecrel_natneq : isdecrel (Œª m n, m ‚â n). Proof. intros n. induction n as [|n N]. - intro m. induction m as [|m _]. + simpl. exact (ii2 (idfun ‚à )). + simpl. exact (ii1 tt). - intro m. induction m as [|m _]. + simpl. exact (ii1 tt). + exact (N m). Defined.Definition nateq (x y : nat) : hProp := make_hProp (x = y) (isasetnat _ _).Definition isdecrelnateq : isdecrel nateq := Œª a b, isdeceqnat a b.Definition natdeceq : decrel nat := make_decrel isdecrelnateq.Definition natdecneq : decrel nat := make_decrel isdecrel_natneq.Definition natboolneq : brel nat := decreltobrel natdecneq. Theorem isinclS : isincl S. 
l2) = fold_right g (fold_right g a l2) l1. Proof using. intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1. intros a l H a0 l2; rewrite H; auto. Qed. Theorem fold_left_init : (forall (a : A) (b : B), h (f a b) = f (h a) b) -> forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a). Proof using. intros H a l; generalize a; elim l; clear l a; simpl in |- *; auto. intros a l H0 a0. rewrite <- H; auto. Qed. End fold. Section List. Variables (A : Type) (B : Type) (C : Type). Variable f : A -> B. Theorem list_length_ind : forall P : list A -> Prop, (forall l1 : list A, (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) -> forall l : list A, P l. Proof using. intros P H l; apply well_founded_ind with (R := fun x y : list A => length x < length y); auto. apply wf_inverse_image with (R := lt); auto. apply lt_wf. Qed. Definition list_length_induction : forall P : list A -> Type, (forall l1 : list A, (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) -> forall l : list A, P l. intros P H l; apply well_founded_induction_type with (R := fun x y : list A => length x < length y); auto. apply wf_inverse_image with (R := lt); auto. apply lt_wf. Defined. Theorem in_ex_app : forall (a : A) (l : list A), In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2). Proof using. intros a l; elim l; clear l; simpl in |- *; auto. intros H; case H. intros a1 l H [H1| H1]; auto. exists (nil (A:=A)); exists l; simpl in |- *; auto. apply f_equal2 with (f := cons (A:=A)); auto. case H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2; simpl in |- *; auto. apply f_equal2 with (f := cons (A:=A)); auto. Qed. Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2. Proof using. intros l1; elim l1; simpl in |- *; auto. Qed. Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3. 
|- *; intros HH; inversion HH; auto; fail). intros a1; case (eqA_dec a1 a0); intros HH. left; rewrite HH; auto. right; Contradict HH; inversion HH; auto. intros p Hp; case Hp; auto; intros HH. case (pbtree_dec a (pbleft p)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize HH HH1; inversion HH2; auto. intros p Hp; case Hp; auto; intros HH. case (pbtree_dec a (pbright p)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize HH HH1; inversion HH2; auto. intros p H p0 H0. case H; auto; intros H1. case H0; auto; intros H2. case (pbtree_dec a (pbnode p p0)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize H1 H2 HH1; inversion HH2; auto. Defined. Theorem inpb_trans : forall t1 t2 t3, inpb t1 t2 -> inpb t2 t3 -> inpb t1 t3. Proof using. intros t1 t2 t3 H H1; generalize t1 H; elim H1; clear H H1 t1 t2 t3; auto. Qed. Theorem inpb_ex : forall t : pbtree, exists x : _, inpb (pbleaf x) t. Proof using. intros t; elim t; simpl in |- *; auto. intros a; exists a; auto. intros b (a, H); exists a; auto. intros b (a, H); exists a; auto. intros b (a, H) b0 H0; exists a; auto. Qed. Definition distinct_pbleaves (t : pbtree) : Prop := forall t0 t1 t2 : pbtree, inpb (pbnode t1 t2) t -> inpb t0 t1 -> inpb t0 t2 -> False. Theorem distinct_pbleaves_Leaf : forall a : A, distinct_pbleaves (pbleaf a). Proof using. intros a; red in |- *. intros a0 t1 t2 H; inversion H. Qed. Hint Resolve distinct_pbleaves_Leaf : core. Theorem distinct_pbleaves_l : forall t1 t2 : pbtree, distinct_pbleaves (pbnode t1 t2) -> distinct_pbleaves t1. Proof using. intros t1 t2 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem distinct_pbleaves_r : forall t1 t2 : pbtree, distinct_pbleaves (pbnode t1 t2) -> distinct_pbleaves t2. Proof using. intros t1 t2 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem distinct_pbleaves_pl : forall t1 : pbtree, distinct_pbleaves (pbleft t1) -> distinct_pbleaves t1. Proof using. intros t1 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem distinct_pbleaves_pr : forall t1 : pbtree, distinct_pbleaves (pbright t1) -> distinct_pbleaves t1. 
(n : nat) fd, fd = f d -> nth n (map f l) fd = f (nth n l d). Proof. intros; subst. apply map_nth. Qed.Lemma Ztest_Bytetest: forall a, Z.testbit (Byte.unsigned a) = Byte.testbit a. Proof. reflexivity. Qed. #[export] Hint Rewrite Ztest_Bytetest : testbit.Lemma nthD_1 {A B}: forall (f: A ->B) n l d fx dd, (n < length l)%nat -> nth n (map f l) d = fx -> exists x, In x l /\ nth n l dd = x /\ f x = fx. Proof. intros f n. induction n; simpl; intros. destruct l; simpl in *. lia. exists a; split. left; trivial. split; trivial. destruct l; simpl in *. lia. destruct (IHn l d fx dd) as [? [? [? ?]]]. lia. trivial. exists x; eauto. Qed.Lemma nth_repeat' {A}: forall (a d:A) k i (Hik: (i <k)%nat), nth i (repeat a k) d = a. Proof. intros a d k. induction k; simpl; trivial. intros. lia. intros. destruct i; simpl; trivial. rewrite IHk. trivial. lia. Qed.Lemma minus_lt_compat_r: forall n m p : nat, (n < m)%nat -> (p <= n)%nat -> (n - p < m - p)%nat. Proof. intros. unfold lt in *. lia. Qed.Lemma map_nth_error_inv {A B}: forall n (l:list A) (f: A -> B) fd, nth_error (map f l) n = Some fd -> exists d, nth_error l n = Some d /\ fd = f d. Proof. intros n. induction n; intros l. destruct l; simpl; intros. inversion H. inversion H. exists a. split; trivial. destruct l; simpl; intros. inversion H. eapply IHn. apply H. Qed.Lemma nth_error_app {A}: forall n (l:list A) d, nth_error l n = Some d -> forall ll, nth_error (l ++ ll) n = Some d. Proof. intros n. induction n; intros l. destruct l; simpl; intros. inversion H. trivial. destruct l; simpl; intros. inversion H. eapply IHn. apply H. Qed.Lemma Forall_app {A} p (l1 l2: list A): Forall p (l1 ++ l2) <-> (Forall p l1 /\ Forall p l2). Proof. intros. repeat rewrite Forall_forall. split; intros. split; intros; apply H; apply in_or_app. left; trivial. right; trivial. apply in_app_or in H0. destruct H. destruct H0; eauto. Qed.Lemma Zlength_nonneg {A}: forall (l:list A), 0 <= Zlength l. Proof. intros. rewrite Zlength_correct. induction l; simpl. lia. rewrite Zpos_P_of_succ_nat. lia. Qed.Lemma Zlength_max_zero {A} (l:list A): Z.max 0 (Zlength l) = Zlength l. Proof. rewrite Z.max_r. trivial. apply Zlength_nonneg. Qed. Theorem xor_inrange : forall (x y : Z), x = x mod Byte.modulus -> y = y mod Byte.modulus -> Z.lxor x y = (Z.lxor x y) mod Byte.modulus. 
// in Hlookup. inversion Hlookup; subst. eexists. rewrite lookup_insert //; split; eauto. rewrite log_heap.possible_async_put elem_of_app. left. edestruct H7 as (?&Hposs&Hlook'); eauto. rewrite Heq in Hlook'. inversion Hlook' => //=. * rewrite /head_step//= in Hstep. destruct_head. inversion Hstep; monad_inv. destruct_head. inversion H1; monad_inv; clear H1. do 3 eexists; split_and!; eauto. econstructor; eauto; repeat (econstructor; eauto). do 2 f_equal. erewrite state_compat_disk_size; eauto. * rewrite /head_step//= in Hstep. destruct_head. inversion Hstep; monad_inv. destruct_head. inversion H1; monad_inv; clear H1. destruct (decide (ADP.all_synced _)). ** monad_inv. do 3 eexists. split_and!. { repeat econstructor. } right. split_and!; eauto. eapply state_compat_all_synced_post_flush; eauto. ** monad_inv. do 3 eexists. split_and!. { repeat econstructor. } left. split_and!; eauto. - rewrite /head_step//= in Hstep. inversion Hstep; monad_inv. inversion H; monad_inv; clear H. inversion H0; monad_inv; clear H0. inversion H3; monad_inv; clear H3. eexists œÉ1. eexists ({| used_proph_id := _ |}). eexists. inversion H4. inversion H5. intuition. { simpl in *. repeat (econstructor; eauto). rewrite H6. done. } right. split_and!; eauto. { rewrite H16. done. } split_and!; eauto. rewrite /RecordSet.set//=. congruence. - rewrite /head_step//= in Hstep. destruct_head. do 3 eexists. intuition; eauto. repeat (econstructor; eauto). Qed. Theorem prim_step'_simulation_rev e1 pœÉ1 pg1 pœÉ2 pg2 œÉ1 g1 Œ∫ e2 efs : prim_step' e1 pœÉ1 pg1 Œ∫ e2 pœÉ2 pg2 efs ‚Üí state_compat œÉ1 pœÉ1 ‚Üí global_compat g1 pg1 ‚Üí ‚àÉ œÉ2 g2 e2', prim_step' e1 œÉ1 g1 Œ∫ e2' œÉ2 g2 efs ‚àß ((e2 = e1 ‚àß efs = [] ‚àß pœÉ2 = pœÉ1 ‚àß pg2 = pg1) ‚à® (e2 = e2' ‚àß state_compat œÉ2 pœÉ2 ‚àß global_compat g2 pg2)). Proof. intros Hprim. inversion Hprim; subst. intros. edestruct (head_step_simulation_rev) as (œÉ2&g2&e2alt'&Hstep&Hcases); eauto. do 3 eexists. split_and!; eauto. { econstructor; eauto. } { destruct Hcases as [Hleft|Hright]. { left. destruct Hleft as (->&->&->&->); eauto. } destruct Hright as (->&Hcompat&Hgcompat); eauto. } Qed. Lemma prim_step'_rtc_looping e1 pœÉ1 pg1 e2 pœÉ2 pg2 : prim_step'_barrier_looping e1 pœÉ1 pg1 ‚Üí rtc (Œª '(e, (s, g)) '(e', (s', g')), prim_step' e s g [] e' s' g' []) (e1, (pœÉ1, pg1)) (e2, (pœÉ2, pg2)) ‚Üí e2 = e1 ‚àß pœÉ2 = pœÉ1 ‚àß pg2 = pg1. Proof. intros Hlooping Hrtc. remember (e1, (pœÉ1, pg1)) as pœÅ1 eqn:HeqœÅ1. remember (e2, (pœÉ2, pg2)) as pœÅ2 eqn:HeqœÅ2. revert Hlooping. revert e1 pœÉ1 pg1 HeqœÅ1. revert e2 pœÉ2 pg2 HeqœÅ2. induction Hrtc; intros; subst. - inversion HeqœÅ1; subst; eauto. - destruct y as (e1'&pœÉ1'&pg1'). eapply Hlooping in H as (->&?&->&->). eapply IHHrtc; eauto. Qed. Theorem prim_step'_rtc_simulation_rev e1 pœÉ1 pg1 pœÉ2 pg2 œÉ1 g1 e2 : rtc (Œª '(e, (s, g)) '(e', (s', g')), prim_step' e s g [] e' s' g' []) (e1, (pœÉ1, pg1)) (e2, (pœÉ2, pg2)) ‚Üí state_compat œÉ1 pœÉ1 ‚Üí global_compat g1 pg1 ‚Üí ‚àÉ œÉ2 g2, rtc (Œª '(e, (s, g)) '(e', (s', g')), prim_step' e s g [] e' s' g' []) (e1, (œÉ1, g1)) (e2, (œÉ2, g2)) ‚àß (state_compat œÉ2 pœÉ2 ‚àß global_compat g2 pg2). 
apply bmoduleOk; [ exact (refl_equal false) | exact I | simpl; repeat (apply List.Forall_nil || apply List.Forall_cons); (simpl; propxFo; conditions) ].Fixpoint vcsImp (Ps : list Prop) (goal : Prop) : Prop := match Ps with | nil => goal | P :: Ps' => P -> vcsImp Ps' goal end.Local Hint Constructors vcs.Lemma vcsImp_correct' : forall Ps (goal : Prop), (vcs Ps -> goal) -> vcsImp Ps goal. induction Ps; simpl; auto. Qed.Theorem vcsImp_correct : forall Ps, vcsImp Ps (vcs Ps). intros; apply vcsImp_correct'; auto. Qed.Ltac structured_auto simp := apply bmoduleOk; [ exact (refl_equal false) | exact I | simp; simpl; match goal with | [ |- vcs ?Ps ] => apply (vcsImp_correct Ps) end ].Ltac link_simp := simpl Imports; simpl Exports; cbv beta iota zeta delta [importsOk LabelMap.fold LabelMap.Raw.fold LabelMap.this importsMap fold_left LabelMap.add LabelMap.Raw.add LabelMap.empty LabelMap.Raw.empty LabelKey.compare LabelKey.compare' string_lt fst snd string_dec sumbool_rec sumbool_rect Ascii.N_of_ascii Ascii.N_of_digits N.compare Pos.compare string_rec string_rect Ascii.ascii_dec LabelMap.find LabelMap.Raw.find Nplus Nmult Pos.compare_cont Pos.add Pos.mul Ascii.ascii_rec Ascii.ascii_rect Bool.bool_dec bool_rec bool_rect eq_rec_r eq_rec eq_rect eq_sym label'_lt label'_eq label'_rec label'_rect LabelMap.Raw.bal LabelMap.Raw.create Int.Z_as_Int.gt_le_dec Int.Z_as_Int.plus Int.Z_as_Int.ge_lt_dec LabelMap.Raw.height ZArith_dec.Z_gt_le_dec Int.Z_as_Int._0 BinInt.Z.add Int.Z_as_Int._1 Int.Z_as_Int._2 ZArith_dec.Z_gt_dec ZArith_dec.Z_ge_lt_dec Int.Z_as_Int.max BinInt.Z.max BinInt.Z.compare BinInt.Z.ltb union ZArith_dec.Z_ge_dec diff LabelMap.mem LabelMap.Raw.mem LabelMap.is_empty LabelMap.Raw.is_empty Pos.succ].Ltac link m1 m2 := apply linkOk; [ apply m1 | apply m2 | exact (refl_equal true) | link_simp; tauto | link_simp; tauto | link_simp; tauto ].Lemma specs_cong : forall (specs : codeSpec W (settings * state)) x p, specs x = p -> forall y, x = y -> specs y = p. congruence. Qed.Implicit Arguments specs_cong [specs x p y].Hint Extern 1 (?specs _ = Some _) => match goal with | [ H : specs _ = Some _ |- _ ] => apply (specs_cong H); congruence end.Lemma use_himp : forall pc state specs (P Q : hprop pc state nil), himp specs P Q -> forall s m, interp specs (P s m) -> interp specs (Q s m). intros; apply (Imply_sound (H _ _)); auto. Qed.Lemma Imply_refl : forall pc state specs (P : PropX pc state), interp specs (P ---> P). intros; apply Imply_I; apply Env; simpl; auto. Qed.Section PropX. Variables pc state : Type. Variable P : PropX pc state. Variable specs : codeSpec pc state. Open Scope PropX_scope. Theorem injL : forall (p : Prop), (p -> interp specs P) -> interp specs ([| p |] ---> P). intros. apply Imply_I. eapply Inj_E. eauto. auto. Qed. Theorem cptrL : forall i a, (specs i = Some (fun x => a x) -> interp specs P) -> interp specs (Cptr i a ---> P). 
intuition auto. + pred_apply. repeat rewrite Nat.div_mul by auto. cancel. + erewrite concat_hom_length by auto. autorewrite with lists. rewrite mult_comm with (m := _ * _ ^ _). rewrite <- plus_assoc, <- Nat.div_mod by auto. denote (concat _ = _) as Hc. apply f_equal with (f := @length _) in Hc. rewrite upd_range_length in *. repeat erewrite concat_hom_length in * by eauto. rewrite Nat.mul_cancel_r in * by mult_nonzero. destruct (addr_eq_dec (start mod (NIndirect * NIndirect ^ indlvl)) 0). - unfold roundup. rewrite divup_eq_div by auto. rewrite mul_div by mult_nonzero. autorewrite with core. congruence. - rewrite roundup_eq by auto. rewrite minus_plus. rewrite <- plus_assoc. autorewrite with core; solve [congruence | omega]. + autorewrite with core. auto. + autorewrite with lists in *. omega. + pred_apply; cancel. + step. rewrite concat_hom_upd_range in * by eauto. set (N := _ * _ ^ _) in *. rewrite le_plus_minus_r in * by auto. rewrite roundup_round in *. match goal with H: concat _ = _, H' : concat _ = _ |- _ => rewrite H, H' end. autorewrite with lists. rewrite mult_comm with (m := N), <- Nat.div_mod by mult_nonzero. erewrite <- le_plus_minus_r with (m := roundup start N) at 2. rewrite upd_range_upd_range. f_equal. destruct (addr_eq_dec (start mod N) 0). - unfold roundup. rewrite divup_eq_div by auto. rewrite mul_div by mult_nonzero. omega. - rewrite roundup_eq by mult_nonzero. autorewrite with core; omega. - auto. + cancel. Unshelve. all : solve [exact unit | exact nil]. Qed. Local Hint Extern 1 ({{_}} Bind (indclear_multiple_blocks _ _ _ _ _ _ _) _) => apply indclear_multiple_blocks_ok : prog. Fixpoint indclear indlvl lxp bxp (root : addr) start len ms := let N := NIndirect ^ indlvl in If (addr_eq_dec root 0) { Ret ^(ms, 0) } else { If (addr_eq_dec len 0) { Ret ^(ms, root) } else { let^ (lms, indbns) <- IndRec.read lxp root 1 (BALLOCC.MSLog ms); let ms := BALLOCC.upd_memstate lms ms in let^ (ms, indbns') <- match indlvl with | 0 => Ret ^(ms, upd_range indbns start len $0) | S indlvl' => If (le_lt_dec len (N - start mod N)) { let^ (ms, v) <- indclear indlvl' lxp bxp #(selN indbns (start / N) $0) (start mod N) len ms; Ret ^(ms, updN indbns (start / N) $ v) } else { indclear_multiple_blocks indlvl' lxp bxp indbns start len ms } end; update_block lxp bxp root indbns indbns' ms } }. Theorem indclear_ok : forall indlvl lxp bxp ir start len ms, {< F Fm Fs m0 sm m l freelist IFs, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (BALLOCC.MSLog ms) sm hm * [[[ m ::: (Fm * indrep_n_tree indlvl bxp IFs ir l * BALLOCC.rep bxp freelist ms) ]]] * [[ start + len <= length l ]] * [[ (Fs * IFs * BALLOCC.smrep freelist)%pred sm ]] POST:hm' RET:^(ms, ir') exists m' freelist' l' IFs', LOG.rep lxp F (LOG.ActiveTxn m0 m') (BALLOCC.MSLog ms) sm hm' * [[[ m' ::: (Fm * indrep_n_tree indlvl bxp IFs' ir' l' * BALLOCC.rep bxp freelist' ms) ]]] * [[ incl freelist freelist' ]] * [[ l' = upd_range l start len $0 ]] * [[ (Fs * IFs' * BALLOCC.smrep freelist')%pred sm ]] * ([[ ir = ir' ]] \/ [[ ir' = 0 ]]) CRASH:hm' LOG.intact lxp F m0 sm hm' >} indclear indlvl lxp bxp ir start len ms. 
qf' hshs hshs' Hcontains Huniq. - by comp_normalize => /bool_neq0_true; rewrite xpair_eqE=>/andP[/eqP -> _]; rewrite Hcontains. - move: Huniq => //= /andP[];rewrite in_cons Bool.negb_orb=>/andP[Hneq Hnin] /andP[Hninxs Huniqxs]. comp_normalize. exchange_big_outwards 2 => //=; comp_simplify_n 1. comp_possible_decompose. move=> hshs'' qf'' value' Haddm Hhash /bool_neq0_true/eqP Hqf. have H1: uniq (value :: xs); first by move=> //=; rewrite Hnin Huniqxs. move: Hhash (Hxs qf qf'' hshs hshs'' Hcontains H1 Haddm) ; clear H1 Hxs. rewrite/Hash.hash; case: (Hash.hashstate_find k x hshs'') => [v|] //=; comp_normalize. - by move=> /bool_neq0_true; rewrite xpair_eqE =>/andP[/eqP ->] //=. comp_simplify; comp_possible_decompose => ind /bool_neq0_true; rewrite xpair_eqE => /andP[/eqP -> _] _. rewrite/hashstate_find/hashstate_put. by apply fixmap_find_neq. Qed. Lemma quotientfilter_add_mutliple_query_preserve qf qf' v hashes xs hshs': (AMQ_query_internal qf v) -> ((d[ @AMQ_add_multiple k n hashes qf xs]) (hshs', qf')) != 0 -> (@AMQ_query_internal n k qf' v). Proof. elim: xs qf qf' hashes hshs' => [| x xs IHxs] qf qf' hashes hshs' Hqint//=; comp_normalize. - by move=>/bool_neq0_true; rewrite xpair_eqE =>/andP [_ /eqP ->]. - exchange_big_outwards 2 => //=; comp_simplify_n 1. comp_possible_decompose => i qf'' i1 Hi1 Hhash/bool_neq0_true /eqP ->. apply/quotientfilter_add_query_preserve. by apply (IHxs _ _ _ _ Hqint Hi1) => //=. Qed. Lemma quotientfilter_add_multiple_properties_preserve values l m qf qf' hshs hshs' (Huniq: uniq values) (Hlen: length values == l) (Hfree: @quotientfilter_has_free_spaces n ((l+m)) qf) (Hvalid: quotientfilter_valid qf) : ((d[ @AMQ_add_multiple k n hshs qf values]) (hshs', qf') != (0 %R)) -> AMQ_valid qf' && quotientfilter_has_free_spaces m qf'. Proof. move: values qf qf' hshs hshs' Huniq Hlen Hfree Hvalid. rewrite/AMQ_add_multiple/AMQHashKey/AMQ_add/AMQHash_hash/AMQ_add_internal/AMQHash_hashstate_available_capacity/AMQHash_hashstate_find/AMQHash/AMQState/AMQHashValue/AMQHashKey/AMQHash_hashstate_unseen/AMQ_valid/AMQ_available_capacity //=. move=> values qf qf' hshs hshs' Huniq Hlen Hfree Hvalid. move/eqP:Hlen Hfree => <-; clear l => Hfree . elim: values m qf qf' hshs hshs' Hvalid Hfree Huniq => [//=| x xs Hxs] m qf qf' hshs hshs' Hvalid Hfree Huniq. - by comp_normalize => /bool_neq0_true; rewrite xpair_eqE=>/andP[_ /eqP ->]; rewrite Hvalid //=. - comp_normalize. exchange_big_outwards 2 => //=; comp_simplify_n 1. comp_possible_decompose. move=> hshs'' qf'' value' Haddm Hhash /bool_neq0_true/eqP Hqf. have H1: quotientfilter_has_free_spaces (length xs + m.+1) qf; first by move: Hfree; rewrite/quotientfilter_has_free_spaces => /allP Hfree; apply/allP => v Hv; move: (Hfree v Hv) => //=; rewrite addSn -addnS. have H2: uniq xs; first by move: Huniq => //= /andP[]. move: (Hxs m.+1 qf qf'' hshs hshs'' Hvalid H1 H2 Haddm) => /andP [Hvalid' Hfree']; clear H1 H2. have H1: (0 < m.+1); first by []. move: (@QuotientFilterDefinitions.quotientfilter_add_preserve m.+1 n H1 qf'' qf' value' Hvalid' Hfree' Hqf) => //=. Qed. Theorem quotientfilter_no_false_negatives l hashes qf x xs : AMQ_valid qf -> AMQ_available_capacity n qf l.+1 -> uniq (x :: xs) -> length xs == l -> AMQHash_hashstate_available_capacity hashes (l.+1) -> all (fun x => AMQHash_hashstate_unseen hashes x) (x::xs) -> (d[ res1 <-$ AMQ_add qf hashes x; let '(hsh1, bf1) := res1 in res2 <-$ @AMQ_add_multiple _ n hsh1 bf1 xs; let '(hsh2, bf2) := res2 in res3 <-$ @AMQ_query k n bf2 hsh2 x; ret (snd res3) ] true) = (1 %R). 
_ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed.Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b. intros a b H' H'0; red in |- *; intros H'1. apply H'. apply zeroP_comp_eqTerm with (a := b); auto. apply eqTerm_sym; auto. Qed. Set Implicit Arguments. Unset Strict Implicit. Definition plusTerm : Term -> Term -> Term. intros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1 H2; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1 H2; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. Qed. Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. Qed. Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x). intros a b; case a; case b; simpl in |- *; auto. Qed. Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1. 
Require Import Classical.Require Import Ensembles. Require Import Relations_1. Require Import Relations_1_facts. Require Import podefs. Require Import podefs_1.Section The_power_set_partial_order. Variable U : Type. Inductive Power_set (A : Ensemble U) : Ensemble (Ensemble U) := Definition_of_Power_set : forall X : Ensemble U, Included U X A -> In (Ensemble U) (Power_set A) X. Hint Resolve Definition_of_Power_set. Variable A : Ensemble U. Theorem Empty_set_minimal : forall X : Ensemble U, Included U (Empty_set U) X. Proof. red in |- *; intros X x H'; elim H'. Qed. Hint Resolve Empty_set_minimal. Theorem Power_set_non_empty : forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A). Proof. intro A'; apply Non_empty_intro with (Empty_set U); auto. Qed. Hint Resolve Power_set_non_empty. Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U). Proof. auto 8. Qed. Hint Resolve Inclusion_is_an_order. Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U). elim Inclusion_is_an_order; auto. Qed. Hint Resolve Inclusion_is_transitive. Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U). Proof. generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H'; auto. Qed. Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U). Proof. elim Same_set_equivalence; auto. Qed. Hint Resolve Same_set_reflexive. Theorem Power_set_PO : PO (Ensemble U). 
Defined. Hint Resolve finite_t_bool : core. Let bool_prop (f : forall r, vec X (ar_rels Œ£ r) -> bool) : rels. Proof. exists (fun r v => f r v = true). intros; apply bool_dec. Defined. Let finite_t_rels : finite_t_upto rels Rr. Proof. destruct finite_t_model with (ar := ar_rels Œ£) (X := X) (Y := bool) (ls := lr) as (l & Hl) ; auto. { exact true. } exists (map bool_prop l). intros (f & Hf). set (g := fun r v => if Hf r v then true else false). destruct (Hl g) as (g' & H1 & H2). exists (bool_prop g'); split. + apply in_map_iff; exists g'; auto. + simpl; intros r Hr v. rewrite <- H2; auto. unfold g. destruct (Hf r v); split; auto; discriminate. Qed. Let model := { M : fo_model Œ£ X & { _ : nat -> X & fo_model_dec M } }. Local Definition FO_model_equiv : model -> model -> Prop. Proof using ls lr ln. intros ((s1,r1) & rho1 & H1 ) ((s2,r2) & rho2 & H2). exact ( (forall s, s ‚àä ls -> forall v, s1 s v = s2 s v) /\ (forall r, r ‚àä lr -> forall v, @r1 r v <-> r2 r v) /\ (forall n, n ‚àä ln -> rho1 n = rho2 n) ). Defined. Let combine : (funs * rels * (nat -> X)) -> model. Proof. intros ((f,(g & Hg)),rho). exists {| fom_syms := f; fom_rels := g |}, rho; auto. Defined. Local Theorem finite_t_model_upto : finite_t_upto _ FO_model_equiv. Proof using finite_t_rels finite_t_funs HŒ£2 HŒ£1 HX2 HX1. destruct finite_t_funs as (lf & H1). destruct finite_t_rels as (lg & H2). destruct finite_t_valuations with X ln as (lrho & H3); auto. exists (map combine (list_prod (list_prod lf lg) lrho)). intros ((f,g) & rho & Hg). destruct (H1 f) as (f' & G1 & G2). destruct (H2 (existT _ g Hg)) as ((g' & Hg') & G3 & G4). destruct (H3 rho) as (phi & G5 & G6). exists (existT _ {| fom_syms := f'; fom_rels := g' |} (existT _ phi Hg')); simpl; split. + apply in_map_iff. exists ((f',existT _ g' Hg'),phi); split; auto. apply list_prod_spec; split; auto. apply list_prod_spec; simpl; auto. + split; auto. Qed. Local Definition FO_sem : model -> fol_form Œ£ -> Prop. Proof. intros (M & rho & _) A. exact (fol_sem M rho A). Defined. Theorem FO_model_equiv_spec (M1 M2 : model) A : FO_model_equiv M1 M2 -> fol_vars A ‚äë ln -> fol_syms A ‚äë ls -> fol_rels A ‚äë lr -> FO_sem M1 A <-> FO_sem M2 A. 
H'. case (Rtotal_order (FtoRradix y) (FtoRradix x)); auto with real. intros H'0; elim H'0; clear H'0; intros H'1. Contradict H'. rewrite Fle_bool_correct_r; auto with real. red in |- *; intros H'; discriminate. red in |- *; rewrite H'1; auto with real. Contradict H'. rewrite Fle_bool_correct_r; auto with real. red in |- *; intros H'; discriminate. red in |- *; auto with real. Qed. Lemma Fle_Zle : forall n1 n2 d : Z, (n1 <= n2)%Z -> Fle (Float n1 d) (Float n2 d). intros; unfold Fle, FtoRradix, FtoR in |- *; simpl in |- *; auto. case Zle_lt_or_eq with (1 := H); intros H1. apply Rlt_le; auto with real. rewrite <- H1; auto with real. Qed. Lemma Flt_Zlt : forall n1 n2 d : Z, (n1 < n2)%Z -> Flt (Float n1 d) (Float n2 d). intros; unfold Flt, FtoRradix, FtoR in |- *; simpl in |- *; auto with real. Qed. Lemma Fle_Fge : forall x y : float, Fle x y -> Fge y x. unfold Fle, Fge in |- *; intros x y H'; auto with real. Qed. Lemma Fge_Zge : forall n1 n2 d : Z, (n1 >= n2)%Z -> Fge (Float n1 d) (Float n2 d). intros n1 n2 d H'; apply Fle_Fge; auto. apply Fle_Zle; auto. apply Zge_le; auto. Qed. Lemma Flt_Fgt : forall x y : float, Flt x y -> Fgt y x. unfold Flt, Fgt in |- *; intros x y H'; auto. Qed. Lemma Fgt_Zgt : forall n1 n2 d : Z, (n1 > n2)%Z -> Fgt (Float n1 d) (Float n2 d). intros n1 n2 d H'; apply Flt_Fgt; auto. apply Flt_Zlt; auto. apply Zgt_lt; auto. Qed. Lemma Fle_refl : forall x y : float, Feq x y -> Fle x y. unfold Feq in |- *; unfold Fle in |- *; intros. rewrite H; auto with real. Qed. Lemma Fle_trans : forall x y z : float, Fle x y -> Fle y z -> Fle x z. unfold Fle in |- *; intros. apply Rle_trans with (r2 := FtoR radix y); auto. Qed. Theorem Rlt_Fexp_eq_Zlt : forall x y : float, (x < y)%R -> Fexp x = Fexp y -> (Fnum x < Fnum y)%Z. intros x y H' H'0. apply lt_IZR. apply (Rlt_monotony_contra_exp radix) with (z := Fexp x); auto with real arith. pattern (Fexp x) at 2 in |- *; rewrite H'0; auto. Qed. Theorem Rle_Fexp_eq_Zle : forall x y : float, (x <= y)%R -> Fexp x = Fexp y -> (Fnum x <= Fnum y)%Z. 
;Void;Void;Void;Void|]++Vector.const (Custom (eq niltape)) m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v))}. Proof using All. induction ren. all:cbn [compile Vector.fold_left M_init' Vector.tl Vector.caseS]. { eexists. cbn. hstep. hsteps_cbn;cbn. exact (MK_isVoid_multi_SpecT 5). cbn;cleanupParamTM. 2:reflexivity. hsteps_cbn. reflexivity. cleanupParamTM. apply EntailsI. intros t H. eapply tspec_ext. eassumption. easy. intros i. clear - i. repeat (destruct (fin_destruct_S i) as [(i'&->) | ->];[rename i' into i;cbn| ]);try (intros H;exact H). } { eexists. cbn. hstep. 3:reflexivity. now apply (projT2 (IHren)). clear IHren. cbn. intros _. hstep. { cbn. rewrite Vector_nth_R,nth_map'. cbn. eapply (projT2 (M_init_one_Spec H_disj _ _)). } cbn;fold Nat.add;rewrite Nat.eqb_refl;cbn. intros _. apply EntailsI. intros t H. eapply tspec_ext. eassumption. easy. intros i. clear - i. repeat (destruct (fin_destruct_S i) as [(i'&->) | ->];[rename i' into i;cbn| ]);try (intros H;exact H). rewrite nth_tabulate. destruct (Fin.eqb _ _) eqn:H'. 2:tauto. cbn. eapply Fin.eqb_eq in H' as ->. rewrite Vector_nth_R,nth_map'. cbn. tauto. } Qed. Program Definition startRen := Vectors.tabulate (n:=k) (fun i => Fin.of_nat_lt (n:=k) (p:=k - 1 -proj1_sig (Fin.to_nat i)) _). Next Obligation. destruct Fin.to_nat;cbn. nia. Defined. Lemma startRen_spec A (v:Vector.t A _): select startRen v = Vector.rev v. Proof. unfold select. apply eq_nth_iff'. intros i. rewrite nth_map'. unfold startRen. unshelve erewrite nth_tabulate, vector_nth_rev. 1:abstract (inv i;nia). f_equal. eapply Fin.of_nat_ext. Qed. Import CasePair Code.CaseList. Definition M_init : pTM (Œ£) ^+ unit ((6 + m)+ k) := M_init' startRen. Theorem M_init_SpecT (v:Vector.t (list bool) k): { k & TripleT ‚âÉ‚âÉ([],Vector.const (Custom (eq niltape)) (6+m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v) k M_init (fun _ => ‚âÉ‚âÉ([], ([|Custom (eq niltape); Contains retr_pro (compile (Vector.fold_left (fun s l_i => L.app s (encBoolsL l_i)) sim v)); Void;Void;Void;Void|] ++Vector.const (Custom (eq niltape)) m) ++ Vector.map (fun bs => Custom (eq (encBoolsTM s b bs))) v))}. Proof using H_disj. eexists. unfold M_init. eapply ConsequenceT. eapply (projT2 (M_init'_SpecT _ _)). reflexivity. 2:reflexivity. cbn. intros _. rewrite vector_fold_left_right with (v:=v), <- (startRen_spec v). apply EntailsI. intros t H. eapply tspec_ext. eassumption. easy. intros i. clear - i. repeat (destruct (fin_destruct_S i) as [(i'&->) | ->];[rename i' into i;cbn| ]);try (intros H;exact H). Qed. End mk_init.From Undecidability Require Import Enc_to_Boollist.Section conv_output. Variable Œ£ : finType. Variable s b : Œ£^+. Variable (retr_pro : Retract sigPro Œ£). Variable (retr_list : Retract (sigList bool) Œ£). Definition M_out : pTM (Œ£) ^+ unit 4 := EncToBoollist.M _ _ @ [|Fin0;Fin2;Fin3|];; Boollist2encBoolsTM.M s b _ @ [|Fin2;Fin1;Fin3|]. Theorem M_out_SpecT bs: { k & TripleT ‚âÉ‚âÉ([],[|Contains _ (compile (encBoolsL bs));Custom (eq niltape);Void;Void|]) k M_out (fun _ => ‚âÉ‚âÉ([], ([|Custom (fun _ => True); Custom (eq (encBoolsTM s b bs)); Void;Void|])))}. 
monoid_rw. Local Infix "*" := dot. Local Infix "**" := power (at level 30, no associativity). Lemma power_x_plus : forall x n p, x ** (n + p) = x ** n * x ** p. Proof. induction n as [| p IHp];simpl. - intros; monoid_simpl;trivial. - intro q;rewrite (IHp q); monoid_simpl;trivial. Qed. Ltac power_simpl := repeat (monoid_rw || rewrite <- power_x_plus). Lemma power_commute : forall x n p, x ** n * x ** p = x ** p * x ** n. Proof. intros x n p;power_simpl; rewrite (plus_comm n p);trivial. Qed. Lemma power_commute_with_x : forall x n , x * x ** n = x ** n * x. Proof. induction n;simpl;power_simpl;trivial. repeat rewrite <- (@dot_assoc A dot one M); rewrite IHn; trivial. Qed. Lemma power_of_power : forall x n p, (x ** n) ** p = x ** (p * n). Proof. induction p;simpl;[| rewrite power_x_plus; rewrite IHp]; trivial. Qed. Lemma power_S : forall x n, x * x ** n = x ** S n. Proof. intros;simpl;auto. Qed.Lemma sqr : forall x, x ** 2 = x * x. Proof. simpl;intros;monoid_simpl;trivial. Qed.Ltac factorize := repeat ( rewrite <- power_commute_with_x || rewrite <- power_x_plus || rewrite <- sqr || rewrite power_S || rewrite power_of_power). Lemma power_of_square : forall x n, (x * x) ** n = x ** n * x ** n. induction n;simpl;monoid_simpl;trivial. repeat rewrite dot_assoc;rewrite IHn; repeat rewrite dot_assoc. factorize; simpl;trivial. Qed. Lemma binary_power_mult_ok : forall n a x, binary_power_mult M a x n = a * x ** n. Proof. intro n; pattern n;apply lt_wf_ind. clear n; intros n Hn; destruct n. intros;simpl; rewrite binary_power_mult_equation;monoid_simpl; trivial. intros; rewrite binary_power_mult_equation; destruct (Even.even_odd_dec (S n)). rewrite Hn, power_of_square; factorize. pattern (S n) at 3;replace (S n) with (div2 (S n) + div2 (S n))%nat;auto. generalize (even_double _ e);simpl;auto. apply lt_div2;auto with arith. rewrite Hn. rewrite power_of_square ; factorize. pattern (S n) at 3;replace (S n) with (S (div2 (S n) + div2 (S n)))%nat;auto. rewrite <- dot_assoc; factorize;auto. generalize (odd_double _ o);intro H;auto. apply lt_div2;auto with arith. Qed.Lemma binary_power_ok : forall (x:A) (n:nat), binary_power x n = x ** n. Proof. intros n x;unfold binary_power;rewrite binary_power_mult_ok; monoid_simpl;auto. Qed.End About_power. Class Abelian_Monoid `(M:Monoid ):= { dot_comm : forall x y, dot x y = dot y x}. Instance ZMult_Abelian : Abelian_Monoid ZMult. Proof. split; exact Zmult_comm. Qed. Section Power_of_dot. Context `{M: Monoid A} {AM:Abelian_Monoid M}. Theorem power_of_mult : forall n x y, power (dot x y) n = dot (power x n) (power y n). 
Theorem himpl_hempty_state_pure: forall P, P -> \[] ==> \[P]. Proof. introv HP. intros h Hh. applys* state_pure_intro_hempty. Qed. Theorem himpl_state_star_pure_l: forall P H H', (P -> H ==> H') -> (\[P] \* H) ==> H'. Proof. introv W Hh. rewrite state_star_pure_l in Hh. applys* W. Qed. Theorem hempty_eq_state_pure_true : \[] = \[True]. Proof. applys himpl_antisym; intros h M. { applys* state_pure_intro_hempty. } { forwards*: state_pure_inv_hempty M. } Qed. Theorem hfalse_hstar_any: forall H, \[False] \* H = \[False]. Proof. intros. applys himpl_antisym; intros h; rewrite state_star_pure_l; intros M. { false*. } { lets: state_pure_inv_hempty M. false*. } Qed. Theorem state_register_intro: forall register value, ($register == value) (machine_state empty {[ register := value ]}). Proof. intros; hnf; auto. Qed. Theorem state_register_inversion: forall register value state, ($register == value) state -> state = (machine_state empty {[ register := value ]}). Proof. intros ??? A; hnf in A; auto. Qed. Theorem state_star_register_same register v1 v2: ($register == v1) \* ($register == v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_register_inversion & ?%state_register_inversion & [] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_counter_intro: forall counter, (pc_at counter) (machine_state {[ 0%fin := counter ]} empty). Proof. intros; hnf; auto. Qed. Theorem state_counter_inversion: forall counter state, (pc_at counter) state -> state = (machine_state {[ 0%fin := counter ]} empty). Proof. intros ?? A; hnf in A; auto. Qed. Theorem state_star_counter v1 v2: (pc_at v1) \* (pc_at v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_counter_inversion & ?%state_counter_inversion & [? _] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_exists_intro: forall A (a: A) (P: A -> Assertion) state, P a state -> (\exists a, P a) state. Proof. intros; hnf; eauto. Qed. Theorem state_exists_inversion: forall X (P: X -> Assertion) state, (\exists x, P x) state -> exists x, P x state. Proof. intros ??? A; hnf in A; eauto. Qed. Theorem state_forall_intro: forall A (P: A -> Assertion) state, (forall a, P a state) -> (state_forall P) state. Proof. intros; hnf; assumption. Qed. Theorem state_forall_inversion: forall A (P: A -> Assertion) state, (state_forall P) state -> forall a, P a state. Proof. intros; hnf; trivial. Qed. Theorem state_implies_forall_r: forall A (P: A -> Assertion) H, (forall a, H **> P a) -> H **> (state_forall P). Proof. intros ??? M ???; apply M; assumption. Qed. Theorem state_implies_forall_l: forall A a (P: A -> Assertion) H, (P a **> H) -> (state_forall P) **> H. 
PG0 Q0 -> forall G0 : list (propX nil), incl PG0 (p a :: G0) -> seq G0 (p a) -> seq G0 Q0 | _ => fun _ => False end p -> incl PG (P :: G) -> seq G Q | _ => True end. Proof. outerPredicative. Qed. Lemma outer_Exists : forall PG Q, seq PG Q -> forall G A p, seq G (Exists p) -> (forall (a : A) (PG0 : list PropX) (Q0 : PropX), seq PG0 Q0 -> forall G0 : list (propX nil), incl PG0 (p a :: G0) -> seq G0 (p a) -> seq G0 Q0) -> incl PG (Exists p :: G) -> seq G Q. Proof. intros; specialize (outer_Exists' H H0); eauto. Qed. Lemma outer_ForallX' : forall PG Q, seq PG Q -> forall G P, seq G P -> match P with | ForallX _ A p => incl PG (P :: G) -> seq G Q | _ => True end. Proof. outerPredicative. Qed. Lemma outer_ForallX : forall PG Q, seq PG Q -> forall G A (p : propX (A :: _)), seq G (ForallX p) -> incl PG (ForallX p :: G) -> seq G Q. Proof. intros; specialize (outer_ForallX' H H0); eauto. Qed. Lemma outer_ExistsX' : forall PG Q, seq PG Q -> forall G P, seq G P -> match P with | ExistsX _ A p => incl PG (P :: G) -> seq G Q | _ => True end. Proof. outerPredicative. Qed. Lemma outer_ExistsX : forall PG Q, seq PG Q -> forall G A (p : propX (A :: _)), seq G (ExistsX p) -> incl PG (ExistsX p :: G) -> seq G Q. Proof. intros; specialize (outer_ExistsX' H H0); eauto. Qed. Hint Immediate outer_Inj outer_Cptr outer_And outer_Or outer_Imply outer_Forall outer_Exists outer_ForallX outer_ExistsX. Lemma cut_admissibility' : forall GG (P : propX GG), match GG return propX GG -> Prop with | _ :: _ => fun _ => True | nil => fun P => forall PG Q, seq PG Q -> forall G, incl PG (P :: G) -> seq G P -> seq G Q end P. Proof. induction P; destruct G; intuition eauto. Qed. Theorem cut_admissibility : forall P G Q, seq G P -> seq (P :: G) Q -> seq G Q. Proof. intros; eapply (@cut_admissibility' nil); eauto. Qed. Hint Resolve cut_admissibility. Theorem cut_elimination : forall G P, seqP G P -> seq G P. 
ps) -> In p (send_packets h ps) -> ~ is_append_entries (pBody p). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; simpl in *; eauto; repeat (do_in_map; subst; simpl in *); intuition; break_exists; congruence. Qed. Theorem logs_sorted_timeout : raft_net_invariant_timeout logs_sorted. Proof using. unfold raft_net_invariant_timeout. unfold logs_sorted. intuition. - unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp handleTimeout_log. find_higher_order_rewrite. break_match; repeat find_rewrite; eauto. - eapply logs_sorted_nw_no_append_entries; eauto. intros. eauto using handleTimeout_not_is_append_entries. - eapply packets_gt_prevIndex_no_append_entries; eauto. intros. eauto using handleTimeout_not_is_append_entries. - eapply packets_ge_prevTerm_no_append_entries; eauto. intros. eauto using handleTimeout_not_is_append_entries. Qed. Ltac find_eapply_hyp_goal := match goal with | H : _ |- _ => eapply H end. Theorem sorted_append : forall l l', sorted l -> sorted l' -> (forall e e', In e l -> In e' l' -> eIndex e > eIndex e') -> (forall e e', In e l -> In e' l' -> eTerm e >= eTerm e') -> sorted (l ++ l'). Proof using. induction l; intros; simpl in *; auto. intuition; do_in_app; intuition; find_apply_hyp_hyp; intuition. Qed. Theorem sorted_index_term : forall l e e', eIndex e <= eIndex e' -> sorted l -> In e l -> In e' l -> eTerm e <= eTerm e'. Proof using. induction l; intros; simpl in *; intuition. - subst_max. intuition. - subst. find_apply_hyp_hyp. intuition. - subst. find_apply_hyp_hyp. intuition. Qed. Lemma handleAppendEntries_logs_sorted : forall net p t n pli plt es ci st' m, raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st'). Proof using. intros. unfold logs_sorted in *. intuition. find_apply_lem_hyp handleAppendEntries_log. intuition. - find_rewrite; eauto. - subst. unfold logs_sorted_nw in *. simpl in *. find_eapply_hyp_goal; eauto. - find_rewrite. apply sorted_append; eauto using removeAfterIndex_sorted. + intros. find_apply_lem_hyp removeAfterIndex_In_le; eauto. unfold packets_gt_prevIndex in *. eapply gt_le_trans; [|eauto]. find_eapply_hyp_goal; [in_crush|eauto|eauto]. simpl in *. eauto. + intros. find_copy_apply_lem_hyp removeAfterIndex_In_le; eauto. find_apply_lem_hyp removeAfterIndex_in. break_exists. intuition. subst. match goal with | H : eIndex ?x <= eIndex ?x', _ : In ?x ?ll |- _ => apply sorted_index_term with (l := ll) (e := x) (e' := x') in H end; eauto. match goal with |- ?a >= ?b => cut (b <= a); [lia|] end. eapply le_trans; eauto. unfold packets_ge_prevTerm in *. find_eapply_hyp_goal; [in_crush|eauto|eauto]; simpl in *; eauto. Qed. Theorem logs_sorted_append_entries : raft_net_invariant_append_entries logs_sorted. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main.Local Open Scope morphism_scope.Section Equalizer. Context {C : Category} {a b : Obj} (f g : a --> b). Local Open Scope morphism_scope. Record Equalizer : Type := { equalizer : C; equalizer_morph : equalizer --> a; equalizer_morph_com : f ‚àò equalizer_morph = g ‚àò equalizer_morph; equalizer_morph_ex (e' : Obj) (eqm : e' --> a) : f ‚àò eqm = g ‚àò eqm ‚Üí e' --> equalizer; equalizer_morph_ex_com (e' : Obj) (eqm : e' --> a) (eqmc : f ‚àò eqm = g ‚àò eqm) : equalizer_morph ‚àò (equalizer_morph_ex e' eqm eqmc) = eqm; equalizer_morph_unique (e' : Obj) (eqm : e' --> a) (com : f ‚àò eqm = g ‚àò eqm) (u u' : e' --> equalizer) : equalizer_morph ‚àò u = eqm ‚Üí equalizer_morph ‚àò u' = eqm ‚Üí u = u' }. Coercion equalizer : Equalizer >-> Obj. Theorem Equalizer_iso (e1 e2 : Equalizer) : (e1 ‚âÉ e2)%isomorphism. 
z -> z = y. Proof Ring.prod_inv_l_uniq ring. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Ring.prod_inv_r_uniq ring. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Ring.prod_inv_uniq ring. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Ring.prod_inv_1 ring. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Ring.prod_has_inv_l_1 ring. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Ring.prod_has_inv_r_1 ring. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof Ring.prod_0_inv_r ring. Theorem prod_0_inv : ~ prod_has_inv 0. Proof Ring.prod_0_inv ring. Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof Ring.prod_inv_0 ring. Definition E_n1_strong : { x : E | sum_is_inv 1 x } := Ring.E_n1_strong ring. Definition E_n1 : E := Ring.E_n1 ring. Notation "{-1}" := E_n1 : commutative_ring_scope. Definition E_n1_def : sum_is_inv 1 {-1} := Ring.E_n1_def ring. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof Ring.E_n1_inv_l ring. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof Ring.E_n1_inv_r ring. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof Ring.E_n1_uniq ring. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). Proof Ring.prod_n1_x_inv_l ring. Theorem prod_x_n1_inv_l : forall x : E, sum_is_inv_l x (x # {-1}). Proof Ring.prod_x_n1_inv_l ring. Theorem prod_n1_x_inv_r : forall x : E, sum_is_inv_r x ({-1} # x). Proof Ring.prod_n1_x_inv_r ring. Theorem prod_x_n1_inv_r : forall x : E, sum_is_inv_r x (x # {-1}). Proof Ring.prod_x_n1_inv_r ring. Theorem prod_n1_x_inv : forall x : E, sum_is_inv x ({-1} # x). Proof Ring.prod_n1_x_inv ring. Theorem prod_x_n1_inv : forall x : E, sum_is_inv x (x # {-1}). 
Let bsm_state_equiv (v : vec _ m) (w : vec _ n) := w#>zero = 0 /\ forall p, w#>(reg p) = stack_enc (v#>p). Infix "‚ãà" := bsm_state_equiv (at level 70, no associativity). Section compiler. Implicit Type œÅ : bsm_instr m. Local Definition bsm_instr_compile lnk i œÅ := match œÅ with | PUSH s Zero => mma_push_Zero (reg s) zero (lnk i) | PUSH s One => mma_push_One (reg s) zero (lnk i) | POP s j k => mma_pop (reg s) zero (lnk i) (lnk j) (lnk (1+i)) (lnk k) end. Local Definition bsm_instr_compile_length œÅ := match œÅ with | PUSH _ Zero => 10 | PUSH _ One => 11 | POP _ _ _ => 19 end. Local Fact bsm_instr_compile_length_eq lnk i œÅ : length (bsm_instr_compile lnk i œÅ) = bsm_instr_compile_length œÅ. Proof. destruct œÅ as [ | ? [] ]; simpl; auto. Qed. Local Lemma bsm_instr_compile_sound : instruction_compiler_sound bsm_instr_compile (@bsm_sss _) (@mma_sss _) bsm_state_equiv. Proof. intros lnk œÅ i1 v1 i2 v2 w1 H; revert H w1. change v1 with (snd (i1,v1)) at 2. change i1 with (fst (i1,v1)) at 2 3 4 6 7 8. change v2 with (snd (i2,v2)) at 2. change i2 with (fst (i2,v2)) at 2. generalize (i1,v1) (i2,v2); clear i1 v1 i2 v2. induction 1 as [ i p j k v Hv | i p j k v ll Hll | i p j k v ll Hll | i p [] v ]; simpl; intros w1 H0 H; generalize H; intros (H1 & H2). + exists w1; split; auto. apply mma_pop_void_progress; auto. rewrite H2, Hv; auto. + exists (w1[(stack_enc ll)/reg p]); repeat split; auto; rew vec. * apply mma_pop_Zero_progress; auto. rewrite H2, Hll; auto. * intros q; dest p q; rew vec. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc ll)/reg p]); repeat split; auto; rew vec. * apply mma_pop_One_progress; auto. rewrite H2, Hll; auto. * intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc (One::v#>p))/reg p]); repeat split; auto; rew vec. * rewrite H0; apply mma_push_One_progress; auto. * intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc (Zero::v#>p))/reg p]); repeat split; auto; rew vec. * rewrite H0; apply mma_push_Zero_progress; auto. * intros q; dest p q. assert (reg p <> reg q); rew vec. Qed. Hint Resolve bsm_instr_compile_length_eq bsm_instr_compile_sound : core. Theorem bsm_mma_compiler : compiler_t (@bsm_sss _) (@mma_sss _) bsm_state_equiv. 
tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key1 key2 sk ts tp * stack len key1 key2 tss' p'. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_bwd : forall len key1 key2 tss (p : W), p <> 0 -> (Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key1 key2 sk ts tp * stack len key1 key2 tss' p') ===> stack len key1 key2 tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. injection H0; sepLemma; auto. injection H0; sepLemma. Qed. Theorem tuples2_fwd : forall len key1 key2 ts c, tuples2 len key1 key2 ts c ===> [| c <> 0 |] * [| freeable c 4 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key1, key2, p) * tree len key1 key2 sk ts p * [| key1 < len |] * [| key2 < len |]. Proof. unfold tuples2; sepLemma; eauto. Qed. Theorem tuples2_bwd : forall len key1 key2 ts (c : W), ([| c <> 0 |] * [| freeable c 4 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key1, key2, p) * tree len key1 key2 sk ts p * [| key1 < len |] * [| key2 < len |]) ===> tuples2 len key1 key2 ts c. Proof. unfold tuples2; sepLemma; eauto. Qed. Theorem tuples2_eq : forall len key1 key2 ts c, tuples2 len key1 key2 ts c = ([| c <> 0 |] * [| freeable c 4 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key1, key2, p) * tree len key1 key2 sk ts p * [| key1 < len |] * [| key2 < len |])%Sep. Proof. auto. Qed. Theorem tree_Equiv : forall len key1 key2 sk ts1 ts2 p, Equiv ts1 ts2 -> tree len key1 key2 sk ts1 p ===> tree len key1 key2 sk ts2 p. Proof. induction sk; sepLemma. Equiv. repeat apply himp_star_frame; eauto. eapply tuples1_Equiv; eauto. Qed. Theorem tree_leaf_fwd : forall len key1 key2 sk ts (p : W), p = 0 -> tree len key1 key2 sk ts p ===> [| sk = Leaf |] * [| empty ts |]. 
eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q))); apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem minuspf_zero : forall (a : Term A n) (p q : list (Term A n)), eqP A eqA n (minuspf (pX a p) (pX a q)) (minuspf p q). intros a p q; try assumption. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := minuspf p q); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n). apply minuspf_inv3a; auto. Qed. Hint Resolve canonical_minuspf. Theorem pluspf_minuspf_id : forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqP A eqA n (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (minuspf p q) q) p. intros p q H' H'0. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q)) q); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q) q)); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec q (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) q))); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec p (pO A n)); auto. Qed. Theorem minusP_pO_refl_eq : forall p q : list (Term A n), minusP p (pO A n) q -> p = q. unfold pO in |- *; intros p q H'; inversion H'; simpl in |- *; auto. Qed. Theorem minuspf_pO_refl_eq : forall p : list (Term A n), minuspf p (pO A n) = p. intros p. rewrite <- (minusP_pO_refl_eq p (minuspf p (pO A n))); auto. Qed. Theorem Opm_ind : forall (P : list (Term A n) -> list (Term A n) -> Prop) (p q : list (Term A n)), (forall p : list (Term A n), P (pO A n) p) -> (forall p : list (Term A n), P p (pO A n)) -> (forall (a b : Term A n) (p q : list (Term A n)), P (pX a p) q -> ltT ltM a b -> P (pX a p) (pX b q)) -> (forall (a b : Term A n) (p q : list (Term A n)), P p (pX b q) -> ltT ltM b a -> P (pX a p) (pX b q)) -> (forall (a b : Term A n) (p q : list (Term A n)), P p q -> eqT a b -> P (pX a p) (pX b q)) -> forall p q : list (Term A n), P p q. 
replace (Zabs (- Fnum x)) with (Zabs (Fnum x)); auto with float. case (Fnum x); simpl in |- *; auto. Qed. Theorem oppBoundedInv : forall (b : Fbound) (x : float), Fbounded b (Fopp x) -> Fbounded b x. intros b x H'; rewrite <- (Fopp_Fopp x). apply oppBounded; auto. Qed. Theorem FopRepAux : forall (b : Fbound) (z : Z) (p : R), ex (fun r : float => r = (- p)%R :>R /\ Fbounded b r /\ Fexp r = z) -> ex (fun r : float => r = p :>R /\ Fbounded b r /\ Fexp r = z). intros b z p H'; elim H'; intros r E; elim E; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'1 E H'. exists (Fopp r); split; auto. rewrite <- (Ropp_involutive p). rewrite <- H'0; auto. unfold FtoRradix in |- *; apply Fopp_correct; auto. split. apply oppBounded; auto. simpl in |- *; auto. Qed. Theorem absFBounded : forall (b : Fbound) (f : float), Fbounded b f -> Fbounded b (Fabs f). intros b f H'; repeat split; simpl in |- *; auto with float. replace (Zabs (Zabs (Fnum f))) with (Zabs (Fnum f)); auto with float. case (Fnum f); auto. Qed. Theorem FboundedEqExpPos : forall (b : Fbound) (p q : float), Fbounded b p -> p = q :>R -> (Fexp p <= Fexp q)%R -> (0 <= q)%R -> Fbounded b q. intros b p q H' H'0 H'1 H'2. cut (0 <= Fnum p)%Z; [ intros Z1 | apply (LeR0Fnum radix); auto with real arith; fold FtoRradix in |- *; rewrite H'0; auto ]. cut (0 <= Fnum q)%Z; [ intros Z2 | apply (LeR0Fnum radix); auto with real arith ]. split. apply Zle_lt_trans with (Zabs (Fnum p)); [ idtac | auto with float ]. repeat rewrite Zabs_eq; auto. apply Zle_trans with (Fnum (Fshift radix (Zabs_nat (Fexp q - Fexp p)) q)); auto. unfold Fshift in |- *; simpl in |- *; auto. pattern (Fnum q) at 1 in |- *; replace (Fnum q) with (Fnum q * 1)%Z; auto with zarith. apply (Rle_Fexp_eq_Zle radix); auto with real zarith. rewrite FshiftCorrect; auto with real zarith. unfold Fshift in |- *; simpl in |- *; rewrite inj_abs; try ring. apply Zle_Zminus_ZERO; apply le_IZR; auto with real arith. apply Zle_trans with (Fexp p). case H'; auto. apply le_IZR; auto with real arith. Qed. Theorem FboundedEqExp : forall (b : Fbound) (p q : float), Fbounded b p -> p = q :>R -> (Fexp p <= Fexp q)%R -> Fbounded b q. 
unfold not in |- *; intros. apply (H (Further s H0)). Qed. Theorem Equiv4 : forall (Sini : S) (P : Stream S -> Prop), SafePath Sini P <-> ~ Inevitable Sini (fun s : Stream S => ~ P s). Proof. unfold iff, Inevitable, not in |- *; intros; split. intro sp; inversion sp; intros. generalize H0; elim (H1 x H); intros. inversion_clear H3 in H2. apply (H2 H4). apply H3; inversion_clear H4; assumption. intro H; elim (not_all_ex_not (Stream S) (fun x : Stream S => isTraceFrom Sini x -> ExistsS (fun s : Stream S => P s -> False) x) H). intros. generalize (not_imply_elim2 (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0). generalize (not_imply_elim (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0); intros. apply safePath with (1 := H1). generalize H1; clear H1; generalize H2; clear H2. generalize x; generalize Sini; cofix u. simple destruct x0; intros; constructor. elim (classic (P (s ^ s0))); [ trivial | intro ]. elim (H2 (Here (P:=fun s : Stream S => ~ P s) H3)). apply u with (Sini := hd s0). generalize H2; clear H2; case s0; unfold not in |- *; intros. apply (not_EX H2 H3). elim H1; intros ig trace; inversion_clear trace. unfold isTraceFrom in |- *; split; trivial. unfold isTraceFrom in |- *; split; trivial. Qed. Theorem Mon_I_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ForAllS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ForAllS Pp x. Proof. cofix u; intro x; case x; intros. case H; constructor. apply (H0 (s1 ^ x0) H1). apply (u x0 Pg Pp H2 H0). Qed. Theorem Conj_S : forall (x : Stream S) (P1 P2 : Stream S -> Prop), ForAllS P1 x -> ForAllS P2 x -> ForAllS (fun s : Stream S => P1 s /\ P2 s) x. Proof. cofix u; intro x; case x; intros. inversion_clear H; inversion_clear H0. constructor; [ split | apply (u s0) ]; assumption. Qed. Theorem Mon_I_EX_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ExistsS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ExistsS Pp x. Proof. simple induction 1; intros. constructor 1; apply (H1 x0 H0). constructor 2; apply (H1 H2). Qed. Theorem OneStep_EX : forall (x : Stream S) (P : Stream S -> Prop), ExistsS P x -> forall s : S, ExistsS P (s ^ x). 
prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Ring.prod_inv_r_uniq ring. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Ring.prod_inv_uniq ring. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Ring.prod_inv_1_l ring. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Ring.prod_inv_1 ring. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Ring.prod_has_inv_l_1 ring. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Ring.prod_has_inv_r_1 ring. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Ring.prod_has_inv_1 ring. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Ring.prod_inv_1_eq_1 ring. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Ring.prod_inv_1_uniq ring. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Ring.recipr_1_l ring. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Ring.recipr_1_r ring. Theorem recipr_1 : prod_is_inv 1 1. Proof Ring.recipr_1 ring. Theorem prod_sum_distrib : Ring.is_distrib E {#} {+}. Proof Ring.prod_sum_distrib ring. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof Ring.prod_0_l ring. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof Ring.prod_0_r ring. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof Ring.prod_0_inv_l ring. Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof Ring.prod_0_inv_r ring. Theorem prod_0_inv : ~ prod_has_inv 0. Proof Ring.prod_0_inv ring. Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof Ring.prod_inv_0 ring. Definition E_n1_strong : { x : E | sum_is_inv 1 x } := Ring.E_n1_strong ring. Definition E_n1 : E := Ring.E_n1 ring. Notation "{-1}" := E_n1 : commutative_ring_scope. Definition E_n1_def : sum_is_inv 1 {-1} := Ring.E_n1_def ring. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof Ring.E_n1_inv_l ring. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof Ring.E_n1_inv_r ring. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof Ring.E_n1_uniq ring. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). Proof Ring.prod_n1_x_inv_l ring. Theorem prod_x_n1_inv_l : forall x : E, sum_is_inv_l x (x # {-1}). Proof Ring.prod_x_n1_inv_l ring. Theorem prod_n1_x_inv_r : forall x : E, sum_is_inv_r x ({-1} # x). Proof Ring.prod_n1_x_inv_r ring. Theorem prod_x_n1_inv_r : forall x : E, sum_is_inv_r x (x # {-1}). Proof Ring.prod_x_n1_inv_r ring. Theorem prod_n1_x_inv : forall x : E, sum_is_inv x ({-1} # x). Proof Ring.prod_n1_x_inv ring. Theorem prod_x_n1_inv : forall x : E, sum_is_inv x (x # {-1}). Proof Ring.prod_x_n1_inv ring. Theorem prod_n1_neg : {#} {-1} = sum_neg. 
m i a). Derive SizeMonotonicSuchThatOpt for (fun i => bind m i a). Derive GenSizedSuchThatSizeMonotonicOpt for (fun x => bind m x a). Instance adm_st m a : SuchThatCorrect (fun x => bind m x a) (genST (fun x => bind m x a)). Admitted.Instance bind_dec m x v : Dec (bind m x v) := {| dec := _ |}. Proof. move: x v. induction m => x v. - right => contra. inversion contra. - destruct a as [x' v']. destruct (eq_dec_id x x') as [[Eq | Neq]]. + destruct (eq_dec_ty v v') as [[EqV | NeqV]]. * subst; left ; constructor; eauto. * subst; right => Contra. inversion Contra; subst; eauto. + subst; specialize (IHm x v). destruct IHm as [L | R]. * left; constructor; eauto. * right => Contra; inversion Contra; subst; eauto. Defined.Reserved Notation "Gamma '|-' t '\typ' T" (at level 40).Inductive has_type : context -> trm -> ty -> Prop := | T_Var : forall Gamma i T, bind Gamma i T -> Gamma |- tvar i \typ T | T_Abs : forall Gamma i T11 T12 t12, cons (i, T11) Gamma |- t12 \typ T12 -> Gamma |- tabs i T11 t12 \typ TArrow T11 T12 | T_App : forall T11 T12 Gamma t1 t2, Gamma |- t1 \typ TArrow T11 T12 -> Gamma |- t2 \typ T11 -> Gamma |- tapp t1 t2 \typ T12 | T_True : forall Gamma, Gamma |- ttrue \typ TBool | T_False : forall Gamma, Gamma |- tfalse \typ TBool | T_If : forall t1 t2 t3 T Gamma, Gamma |- t1 \typ TBool -> Gamma |- t2 \typ T -> Gamma |- t3 \typ T -> Gamma |- tif t1 t2 t3 \typ Twhere "Gamma '|-' t '\typ' T" := (has_type Gamma t T).Hint Constructors has_type.Derive ArbitrarySizedSuchThat for (fun tm => has_type Gamma tm ty). Derive SizedProofEqs for (fun tm => value tm). Derive SizeMonotonicSuchThatOpt for (fun tm => value tm). Derive GenSizedSuchThatCorrect for (fun tm => value tm). Derive GenSizedSuchThatSizeMonotonicOpt for (fun tm => value tm).Instance has_type_gen_correct0 Gamma T : SuchThatCorrect (fun t => has_type Gamma t T) (@arbitraryST _ (fun t => has_type Gamma t T) _). Admitted.Fixpoint lookup (Gamma : context) (i : id) : option ty := match Gamma with | nil => None | cons (i',T) Gamma' => if beq_id i i' then Some T else lookup Gamma' i end. Theorem beq_id_true_iff : forall x y : id, beq_id x y = true <-> x = y. 
intros (n & E); exists n; rewrite <- E; auto. + intros (n & Hn); revert Hn. case_eq (g n); try discriminate. intros x E; inversion 1; exists x; split; auto. apply Hg; exists n; auto. Qed. Fact opt_enum_t_vec X n (P : X -> Prop) : opt_enum_t P -> opt_enum_t (fun v : vec X n => forall p, P (vec_pos v p)). Proof. intros HP. induction n as [ | n IHn ]. + exists (fun _ => Some vec_nil). intros v; vec nil v; split. * exists 0; auto. * intros _ p; invert pos p. + generalize (opt_enum_t_prod HP IHn). apply opt_enum_t_image with (f := fun p => vec_cons (fst p) (snd p)). intros v; split. * vec split v with x; intros H; exists (x,v); simpl; split; auto; split. - apply (H pos0). - intros p; apply (H (pos_nxt p)). * intros ((x,w) & (H1 & H2) & ->). simpl fst in *; simpl snd in *. intros p; invert pos p; auto. Qed. Fact opt_enum_t_list X (P : X -> Prop) : opt_enum_t P -> opt_enum_t (Forall P). Proof. intros H. generalize (opt_enum_t_dep_sum _ _ eq_nat_dec type_enum_t_nat (fun n => opt_enum_t_vec n H)). apply opt_enum_t_image with (f := fun p => match p with existT _ n v => vec_list v end). intros l; rewrite Forall_forall; split. + intros Hl; exists (existT _ (length l) (list_vec l)); simpl. split. * intros p; apply Hl. rewrite <- (list_vec_iso l) at 3. apply in_vec_list, in_vec_pos. * rewrite list_vec_iso; auto. + intros ((n&v) & H1 & ->); simpl in *. intros x Hx; apply vec_list_inv in Hx. destruct Hx as (p & ->); auto. Qed. Fact type_enum_t_vec X n : type_enum_t X -> type_enum_t (vec X n). Proof. intros HX. apply type_enum_opt_enum_t in HX. apply type_enum_opt_enum_t. generalize (opt_enum_t_vec n HX). apply opt_enum_t_image with (f := fun v => v). intros v; split; try tauto; exists v; auto. Qed. Fact type_enum_t_list X : type_enum_t X -> type_enum_t (list X). Proof. intros HX. apply type_enum_opt_enum_t in HX. apply type_enum_opt_enum_t. generalize (opt_enum_t_list HX). apply opt_enum_t_image with (f := fun v => v). intros v; split; try tauto; exists v; split; auto. apply Forall_forall; auto. Qed.End enum_ops.Section rec_enum_co_rec_enum. Variable (X : Type) (P : X -> Prop) (H1 : rec_enum_t P) (H2 : rec_enum_t (fun x => ~ P x)) (x : X) (Hx : P x \/ ~ P x). Theorem bi_rec_enum_t_dec : { P x } + { ~ P x }. 
: context [ Q ] |- _ ] => copy_eapply H H' end. Lemma entries_contiguous : forall net p t n pli plt es ci, refined_raft_intermediate_reachable net -> In p (nwPackets net) -> pBody p = AppendEntries t n pli plt es ci -> contiguous_range_exact_lo es pli. Proof using rlmli. intros. find_apply_lem_hyp entries_contiguous_nw_invariant. unfold entries_contiguous_nw in *. eauto. Qed. Lemma exists_deghosted_packet : forall net (p : packet (params := raft_refined_multi_params (raft_params := raft_params))), In p (nwPackets net) -> exists q, In q (nwPackets (deghost net)) /\ q = deghost_packet p. Proof using. unfold deghost. simpl. intros. eexists; intuition eauto. apply in_map_iff. eexists; eauto. Qed. Lemma network_host_entries : forall net p t n pli plt es ci h e e', refined_raft_intermediate_reachable net -> In p (nwPackets net) -> pBody p = AppendEntries t n pli plt es ci -> In e (log (snd (nwState net h))) -> In e' es -> eIndex e = eIndex e' -> eTerm e = eTerm e' -> In e es. Proof using uii lmi rri. intros. pose proof lift_uniqueIndices_log net h; intuition. find_copy_apply_lem_hyp lift_log_matching. unfold log_matching, log_matching_nw in *. intuition. find_apply_lem_hyp exists_deghosted_packet. break_exists. intuition. subst. destruct p; simpl in *; subst. eapply_prop_hyp In In; simpl; eauto. intuition. match goal with | H : forall _ _ _, _ |- _ => specialize (H h e' e) end; intuition. repeat break_match. simpl in *. repeat find_rewrite. simpl in *. intuition. match goal with | H : forall _, _ <= _ -> _ |- _ => specialize (H e'); conclude H ltac:(omega) end. intuition. eapply rachet; eauto. Qed. Lemma sorted_app_in_gt : forall l1 l2 e e', sorted (l1 ++ l2) -> In e l1 -> In e' l2 -> eIndex e' < eIndex e. Proof using. intros; induction l1; simpl in *; intuition. subst_max. specialize (H2 e'). assert (In e' (l1 ++ l2)) by auto with datatypes. concludes. intuition. Qed. Lemma Prefix_In : forall A (l : list A) l' x, Prefix l l' -> In x l -> In x l'. Proof using. induction l; intros; simpl in *; intuition; subst; break_match; intuition; subst; intuition. Qed. Ltac get_invariant i := match goal with | H : refined_raft_intermediate_reachable _ |- _ => copy_apply i H end. Lemma in_not_nil : forall A (l : list A) x, In x l -> l <> nil. Proof using. destruct l; simpl; intuition congruence. Qed. Set Bullet Behavior "Strict Subproofs". Theorem state_machine_safety_nw'_invariant : forall net, refined_raft_intermediate_reachable net -> state_machine_safety_nw' net. 
(w: word n), combine v w = w. Proof. intros. shatterer. Qed. Definition len_add {t n m} (v:word (len (ArrayF t n) + len (ArrayF t m))) : word (len (ArrayF t (n+m))). rewrite len_add' in v. exact v. Defined. Definition len_split {t n m} (v:word (len (ArrayF t (n+m)))) : word (len (ArrayF t n) + len (ArrayF t m)). rewrite <- len_add' in v. exact v. Defined. Lemma of_word_cons : forall t n (w: word (len (ArrayF t (S n)))), of_word w = (of_word (split1 (len t) (n * len t) w)) :: (@of_word (ArrayF t n) (split2 (len t) (n * len t) w)). Proof. intros. reflexivity. Qed. Theorem combine_app' : forall (t:type) (n m:nat) H (v : word (len (ArrayF t n))) (w : word (len (ArrayF t m))), app (of_word v) (of_word w) = of_word (eq_rect (len (ArrayF t n) + len (ArrayF t m)) (fun n => word n) (combine v w) (len (ArrayF t (n+m))) H). Proof. intros. induction n. simpl. rewrite <- (eq_rect_eq_dec eq_nat_dec). rewrite combine_0; reflexivity. simpl len in *. rewrite of_word_cons. simpl. erewrite IHn. rewrite of_word_cons. rewrite <- combine_split with (sz1:=len t) (sz2:=n * len t) (w := v). f_equal. rewrite split1_combine. erewrite combine_assoc. rewrite eq_rect_word_match. unfold eq_rec. rewrite eq_rect_nat_double. rewrite eq_rect_combine. rewrite split1_combine. reflexivity. rewrite split2_combine. erewrite combine_assoc. rewrite eq_rect_word_match. unfold eq_rec. rewrite eq_rect_nat_double. rewrite eq_rect_combine. rewrite split2_combine. f_equal. Grab Existential Variables. all: omega. Qed. Theorem combine_app : forall (t:type) (n m:nat) (v : word (len (ArrayF t n))) (w : word (len (ArrayF t m))), app (of_word v) (of_word w) = of_word (len_add (combine v w)). Proof. intros. unfold len_add. apply combine_app'. Qed. Theorem cons_to_word : forall (t:type) (n:nat) d v, @to_word (ArrayF t (S n)) (d :: v) = combine (to_word d) (@to_word (ArrayF t n) v). Proof. intros. inversion t; auto. Qed. Theorem split1_firstn : forall t n m (w: word (len (ArrayF t (n+m)))) Heq, firstn n (of_word w) = of_word (split1 (len (ArrayF t n)) (len (ArrayF t m)) (eq_rect _ word w _ Heq)). Proof. intros. induction n. simpl. reflexivity. simpl plus in *. rewrite of_word_cons. simpl. rewrite of_word_cons. unfold eq_rec_r in *. f_equal. erewrite split1_iter. rewrite eq_rect_word_match. rewrite eq_rect_nat_double. simpl in *. f_equal. erewrite eq_rect_split1_eq2. f_equal. erewrite IHn. rewrite eq_rect_split2. erewrite split1_split2. repeat f_equal. rewrite eq_rect_word_match. rewrite eq_rect_nat_double. unfold eq_rec. f_equal. apply proof_irrelevance. Grab Existential Variables. all: try omega. simpl. nia. Qed. Theorem split2_skipn : forall t n m (w: word (len (ArrayF t (n+m)))) Heq, skipn n (of_word w) = of_word (split2 (len (ArrayF t n)) (len (ArrayF t m)) (eq_rect _ word w _ Heq)). 
denote_bk := (denote_bk (E := E)). Notation denote_bks := (denote_bks (E := E)). Notation denote_asm := (denote_asm (E := E)). Lemma fmap_block_map: forall {L L'} b (f: fin L -> fin L'), denote_bk (fmap_block f b) ‚â ITree.map f (denote_bk b). Proof. induction b as [i b | br]; intros f. - cbn. rewrite map_bind. eapply eqit_bind; try reflexivity. intros []; apply IHb. - simpl. destruct br; simpl. + rewrite map_ret; reflexivity. + rewrite map_bind. eapply eqit_bind; try reflexivity. intros ?. destruct a; setoid_rewrite map_ret; reflexivity. + rewrite map_bind. eapply eqit_bind; try reflexivity. intros []. Qed. Definition denote_list: list instr -> itree E unit := traverse_ denote_instr. Lemma denote_after : forall {label} instrs (b: branch (fin label)), denote_bk (after instrs b) ‚â (denote_list instrs ;; denote_br b). Proof. induction instrs as [| i instrs IH]; intros b. - simpl; rewrite bind_ret_l; reflexivity. - simpl; rewrite bind_bind. eapply eqit_bind; try reflexivity. intros []; apply IH. Qed. Lemma denote_blk_append : forall lbl (l:list instr) (b:block (fin lbl)), denote_bk (blk_append l b) ‚âà (x <- denote_list l ;; denote_bk b). Proof. intros lbl. induction l; intros b; simpl. - rewrite bind_ret_l. reflexivity. - rewrite bind_bind. eapply eqit_bind'; try reflexivity. intros; apply IHl. Qed. Lemma denote_list_app: forall is1 is2, @denote_list (is1 ++ is2) ‚â (@denote_list is1;; denote_list is2). Proof. intros is1 is2; induction is1 as [| i is1 IH]; simpl; intros; [rewrite bind_ret_l; reflexivity |]. rewrite bind_bind; setoid_rewrite IH; reflexivity. Qed. Lemma unit_l'_id_sktree {n : nat} : (unit_l' (C := sub (ktree E) fin) (bif := Nat.add) (i := 0)) ‚©Ø id_ n. Proof. intros ?. tau_steps; symmetry; tau_steps. rewrite R_0_a. unfold id. reflexivity. Qed. Lemma unit_l_id_sktree {n : nat} : (unit_l (C := sub (ktree E) fin) (bif := Nat.add) (i := 0)) ‚©Ø id_ n. Proof. intros ?. tau_steps; symmetry; tau_steps. replace (fi' _) with a by (apply unique_fin; simpl; auto using Nat.sub_0_r). reflexivity. Qed. Lemma raw_asm_correct {A B} (b : bks A B) : denote_asm (raw_asm b) ‚©Ø (fun a => denote_bk (b a)). Proof. unfold denote_asm; cbn. rewrite loop_vanishing_1. rewrite unit_l'_id_sktree. rewrite unit_l_id_sktree. rewrite cat_id_l, cat_id_r. reflexivity. Qed. Lemma raw_asm_block_correct_lifted {A} (b : block (fin A)) : denote_asm (raw_asm_block b) ‚©Ø ((fun _ => denote_bk b) : sub (ktree _) fin _ _). Proof. unfold raw_asm_block. rewrite raw_asm_correct. reflexivity. Qed. Lemma raw_asm_block_correct {A} (b : block (fin A)) : (denote_asm (raw_asm_block b) f0) ‚âà (denote_bk b). Proof. apply raw_asm_block_correct_lifted. Qed. Theorem pure_asm_correct {A B} (f : sub Fun fin A B) : denote_asm (pure_asm f) ‚©Ø subpure f. 
lia. rewrite iter_plus. by apply: run_value_monotone. Qed.Lemma inc_value_mod {M : Cm1} {p: Config} : value p < value (step M p) -> exists t, nth_error M (state p) = Some t /\ ((value p) mod ((snd t)+1) = 0). Proof. rewrite /step. move: p => [i [|c]] /=; first by lia. case: (nth_error M i) => /=; last by lia. move=> [j n]. move Hr: (S c mod (n + 1)) => [|r] /=; last by lia. move=> _. by exists (j, n). Qed.Lemma step_progress (M : Cm1) (x: Config) : state x < length M -> 1 <= value x -> step M x = {| state := 1 + state x; value := value x |} \/ value x < value (step M x). Proof. move=> ? ?. rewrite /step. have ->: value x = S (value x - 1) by lia. move Ho: (nth_error M (state x)) => o. case: o Ho; first last. { move /nth_error_None. by lia. } move=> [j n] _. case H: (S (value x - 1) mod (n + 1)); last by left. right => /=. by apply: mod_frac_lt. Qed.Definition config_weight (M: Cm1) : Config -> nat := fun '{| state := p; value := v |} => p + length M * v. Lemma config_weight_step_monotone {M: Cm1} {x: Config} : not (halting M x) -> config_weight M x < config_weight M (step M x). Proof. move=> Hx. suff: not (config_weight M (step M x) <= config_weight M x) by lia. move: x Hx => [p v]. rewrite /config_weight /=. case: v => [|v]. { move=> + /ltac:(exfalso). by apply. } move Ho: (nth_error M p) => o. case: o Ho; first last. { move=> Hp + /ltac:(exfalso). apply. move=> /=. by rewrite Hp. } move=> [j n] Hp ?. case Hr: (S v mod (n + 1)); last by lia. have := mod_frac_lt Hr. have : p < length M. { apply /nth_error_Some. by rewrite Hp. } by nia. Qed.Lemma config_weight_run_monotone {M: Cm1} {x: Config} {n: nat} : not (halting M (Nat.iter n (step M) x)) -> config_weight M x < config_weight M (Nat.iter (1+n) (step M) x). Proof. elim: n; first by move /config_weight_step_monotone. move=> n IH HSn. have /IH : not (halting M (Nat.iter n (step M) x)). { move=> Hn. apply: HSn. move: Hn. apply: halting_monotone. by lia. } have := config_weight_step_monotone HSn. move=> /=. by lia. Qed. Theorem acyclicity {M: Cm1} {n: nat} {x: Config} : not (halting M (Nat.iter n (step M) x)) -> NoDup (map (fun i => Nat.iter i (step M) x) (seq 0 (2+n))). 
"Hfupd". iFrame. iSplitR "Hda". * iExists _. iFrame. iExists _, _, _. iFrame. iFrame "%". subst. eauto. * iLeft. iExists _, _. iFrame. } wpc_apply (wpc_Barrier1 with "[$Hhdr]"). iSplit. { iFrame. iLeft in "Hfupd". iFrame. iIntros "Hhdr". iSplitR "Hda". * iExists _. iFrame. iExists _, _, _. iFrame. iFrame "%". subst. eauto. * iLeft. iExists _, _. iFrame. } iNext. iIntros "[%Hfalso ?]". exfalso. congruence. } iRight in "Hfupd". iRight in "Hfupd". iSpecialize ("Hfupd" $! œÉ œÉ' a with "[% //] [% //]"). iMod (mark_used' _ _ _ _ _ (P œÉ' ‚àó (Œ¶c ‚àß Œ¶ #true))%I with "Hreserved [HP Hfupd]") as "Hget_used". { solve_ndisj. } { clear. iIntros (s Hreserved) "HPalloc". iMod ("Hfupd" with "[% //] [$HP $HPalloc]") as "(HP&HPalloc&HQ)". iFrame. eauto. } iModIntro. iDestruct "Hget_used" as "[ (HP&HQ) Hused]". iAssert (is_inode_durable addr (set inode.blocks (Œª bs : list Block, bs ++ [b0]) (set inode.addrs (union {[a]}) œÉ)) (addrs ++ [a])) with "[Hhdr Hdata Hda]" as "Hdurable". { iExists _; iFrame "‚àó %". iSplitR. { iPureIntro. rewrite /inode.wf /=. autorewrite with len; simpl. word. } iSplitR. { iPureIntro. simpl. rewrite list_to_set_app_L. simpl. set_solver. } simpl; auto. subst. iFrame. } iDestruct (is_inode_durable_wf with "Hdurable") as %Hwf'. iCache (Œ¶c)%I with "HQ". { by iLeft in "HQ". } match goal with | |- envs_entails _ ((?P ‚àó _) ‚àß _) => iCache (P)%I with "HQ HP Hdurable" end. { iLeft in "HQ". iFrame. iExists _; iFrame. iDestruct (inode_durable_to_cinv with "[$]") as "?". iFrame. } iCache (block_cinv Œ® Œ≥alloc a) with "Hused". { iApply block_cinv_from_used; iFrame. } iSplit. { iLeft in "HQ". iFrame. iExists _. iFrame. iDestruct (inode_durable_to_cinv with "[$]") as "?". iFrame. } iIntros "Hb". subst Œ¶'; cbv beta. wpc_pures. { iLeft in "HQ". iFrame. iExists _. iFrame. iDestruct (inode_durable_to_cinv with "[$]") as "?". iFrame. } wpc_apply (wpc_Barrier0); first done. iSplit. { iIntros. iLeft in "HQ". iFrame. iExists _. iFrame. iDestruct (inode_durable_to_cinv with "[$]") as "?". iFrame. } iNext. iIntros "_". wpc_pures. { iIntros. iLeft in "HQ". iFrame. iExists _. iFrame. iDestruct (inode_durable_to_cinv with "[$]") as "?". iFrame. } iModIntro. iSplitR "Hused"; last (iFromCache). iSplit. { iLeft in "HQ". iFrame. iExists _. iFrame. iDestruct (inode_durable_to_cinv with "[$]") as "?". iFrame. } iSplitR "HP Haddrs addrs Hdurable"; last first. { iExists _; iFrame. iModIntro. iExists _, _; iFrame "‚àó %". } iModIntro. iIntros "His_locked". iSplit; first iFromCache. wpc_pures. wpc_frame_seq. wp_loadField. wp_apply (crash_lock.release_spec with "His_locked"); auto. iNamed 1. wpc_pures. by iRight in "HQ". Qed. Theorem wpc_Inode__Append_triple {l P addr} {Palloc Œ≥alloc domain} (Q: iProp Œ£) (Qc: iProp Œ£) (alloc_ref: loc) q (b_s: Slice.t) (b0: Block) : inodeN ## allocN ‚Üí {{{ "Hinode" ‚à∑ is_inode l P addr ‚àó "Hbdata" ‚à∑ is_block b_s q b0 ‚àó "HQc" ‚à∑ (Q -‚àó Qc) ‚àó "#Halloc" ‚à∑ is_allocator Palloc Œ® allocN alloc_ref domain Œ≥alloc ‚àó "#Halloc_fupd" ‚à∑ ‚ñ° reserve_fupd (‚ä§ ‚àñ ‚ÜëallocN) Palloc ‚àó "#Hfree_fupd" ‚à∑ ‚ñ° (‚àÄ a, free_fupd (‚ä§ ‚àñ ‚ÜëallocN) Palloc a) ‚àó "Hfupd" ‚à∑ (Qc ‚àß (‚àÄ œÉ œÉ' addr', ‚åúœÉ' = set inode.blocks (Œª bs, bs ++ [b0]) (set inode.addrs ({[addr']} ‚à™.) œÉ)‚åù -‚àó ‚åúinode.wf œÉ‚åù -‚àó ‚àÄ s, ‚åús !! addr' = Some block_reserved‚åù -‚àó P œÉ ‚àó ‚ñ∑ Palloc s ={‚ä§ ‚àñ ‚ÜëallocN}=‚àó P œÉ' ‚àó ‚ñ∑ Palloc (<[addr' := block_used]> s) ‚àó Q)) }}} Inode__Append #l (slice_val b_s) #alloc_ref @ ‚ä§ {{{ (ok: bool), RET #ok; if ok then Q else emp }}} {{{ Qc }}}. 
as [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example2' : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Proof. intros n m [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Proof. intros n m Hn Hm. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example3 : forall n m : nat, n + m = 0 -> n * m = 0. Proof. intros n m H. assert (H' : n = 0 /\ m = 0). { apply and_exercise. apply H. } destruct H' as [Hn Hm]. rewrite Hn. reflexivity. Qed.Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Proof. intros P Q [HP HQ]. apply HP. Qed. Lemma proj2 : forall P Q : Prop, P /\ Q -> Q. Proof. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Proof. intros P Q [HP HQ]. split. - apply HQ. - apply HP. Qed. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Proof. intros P Q R [HP [HQ HR]]. Admitted. Check and.Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Proof. intros n m [Hn | Hm]. - rewrite Hn. reflexivity. - rewrite Hm. rewrite <- mult_n_O. reflexivity. Qed.Lemma or_intro : forall A B : Prop, A -> A \/ B. Proof. intros A B HA. left. apply HA. Qed.Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Proof. intros [|n]. - left. reflexivity. - right. reflexivity. Qed. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Proof. Admitted.Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Proof. Admitted.Module MyNot.Definition not (P:Prop) := P -> False.Notation "~ x" := (not x) : type_scope.Check not. End MyNot.Theorem ex_falso_quodlibet : forall (P:Prop), False -> P. Proof. intros P contra. destruct contra. Qed. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Proof. Admitted. Theorem zero_not_one : ~(0 = 1). Proof. intros contra. inversion contra. Qed.Check (0 <> 1). Theorem zero_not_one' : 0 <> 1. 
x, or zero x = x. Proof. intros. rewrite or_commut. apply or_zero. Qed.Theorem or_mone: forall x, or x mone = mone. Proof. bit_solve. Qed.Theorem or_idem: forall x, or x x = x. Proof. bit_solve. destruct (testbit x i); auto. Qed.Theorem and_or_distrib: forall x y z, and x (or y z) = or (and x y) (and x z). Proof. bit_solve. apply demorgan1. Qed.Corollary and_or_distrib_l: forall x y z, and (or x y) z = or (and x z) (and y z). Proof. intros. rewrite (and_commut (or x y)). rewrite and_or_distrib. f_equal; apply and_commut. Qed.Theorem or_and_distrib: forall x y z, or x (and y z) = and (or x y) (or x z). Proof. bit_solve. apply orb_andb_distrib_r. Qed.Corollary or_and_distrib_l: forall x y z, or (and x y) z = and (or x z) (or y z). Proof. intros. rewrite (or_commut (and x y)). rewrite or_and_distrib. f_equal; apply or_commut. Qed.Theorem and_or_absorb: forall x y, and x (or x y) = x. Proof. bit_solve. assert (forall a b, a && (a || b) = a) by destr_bool. auto. Qed.Theorem or_and_absorb: forall x y, or x (and x y) = x. Proof. bit_solve. assert (forall a b, a || (a && b) = a) by destr_bool. auto. Qed.Theorem xor_commut: forall x y, xor x y = xor y x. Proof. bit_solve. apply xorb_comm. Qed.Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z). Proof. bit_solve. apply xorb_assoc. Qed.Theorem xor_zero: forall x, xor x zero = x. Proof. bit_solve. apply xorb_false. Qed.Corollary xor_zero_l: forall x, xor zero x = x. Proof. intros. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_idem: forall x, xor x x = zero. Proof. bit_solve. apply xorb_nilpotent. Qed.Theorem xor_zero_one: xor zero one = one. Proof. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_one_one: xor one one = zero. Proof. apply xor_idem. Qed.Theorem xor_zero_equal: forall x y, xor x y = zero -> x = y. Proof. intros. apply same_bits_eq; intros. assert (xorb (testbit x i) (testbit y i) = false). rewrite <- bits_xor; auto. rewrite H. apply bits_zero. destruct (testbit x i); destruct (testbit y i); reflexivity || discriminate. Qed.Theorem xor_is_zero: forall x y, eq (xor x y) zero = eq x y. Proof. intros. predSpec eq eq_spec (xor x y) zero. - apply xor_zero_equal in H. subst y. rewrite eq_true; auto. - predSpec eq eq_spec x y. + elim H; subst y; apply xor_idem. + auto. Qed. Theorem and_xor_distrib: forall x y z, and x (xor y z) = xor (and x y) (and x z). 
l2) -> canonical A0 eqA ltM (pX a (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec l1 l2)). intros l1 l2 a H' H'0. apply order_plusP with (1 := os) (plusA := plusA) (l1 := l1) (l2 := l2); auto. apply pluspf_is_plusP; auto. apply canonical_pluspf; auto. apply canonical_imp_canonical with (a := a); auto. apply canonical_imp_canonical with (a := a); auto. Qed. Hint Resolve order_pluspf. Theorem order_minuspf : forall (l1 l2 : list (Term A n)) (a : Term A n), canonical A0 eqA ltM (pX a l1) -> canonical A0 eqA ltM (pX a l2) -> canonical A0 eqA ltM (pX a (minuspf l1 l2)). intros l1 l2 a H' H'0. apply eqp_imp_canonical with (1 := cs) (p := pX a (pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec l1 (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) l2))); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply order_pluspf; auto. apply canonical_pX_eqT with (a := multTerm (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) a); auto. change (canonical A0 eqA ltM (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (pX a l2))) in |- *; auto. apply (eqT_sym A n); auto. apply (canonical_nzeroP A A0 eqA n ltM) with (p := l1); auto. Qed. Theorem minusP_refl : forall p q r : list (Term A n), minusP p q r -> p = q -> r = pO A n. intros p q r H'; elim H'; auto. intros l1 H'0; rewrite <- H'0; simpl in |- *; auto. intros a1 a2 l1 l2 l3 H'0 H'1 H'2 H'3; generalize H'0. rewrite (pX_invl A n a1 a2 l1 l2); auto; intros Ord. absurd (ltT ltM a2 a2); auto. intros a1 a2 l1 l2 l3 H'0 H'1 H'2 H'3 H'4. apply H'1; auto. apply pX_invr with (a := a1) (b := a2); auto. intros a1 a2 l1 l2 l3 H'0 H'1 H'2 H'3 H'4; elim H'3; auto. rewrite (pX_invl A n a1 a2 l1 l2); auto. intros a1 a2 l1 l2 l3 H'0 H'1 H'2 H'3; generalize H'0. rewrite (pX_invl A n a1 a2 l1 l2); auto; intros Ord. absurd (ltT ltM a2 a2); auto. Qed. Theorem minuspf_refl_eq : forall p : list (Term A n), minuspf p p = pO A n. intros p; rewrite (minusP_refl p p (minuspf p p)); auto. Qed. Theorem minuspf_refl : forall p : list (Term A n), eqP A eqA n (minuspf p p) (pO A n). 
Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.Connect Bedrock.Platform.Bootstrap. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Module M'. Definition globalSched : W := ((heapSize + 50) * 4)%nat. Definition inbuf_size := 40. Theorem inbuf_size_lower : (inbuf_size >= 2)%nat. 
y. Proof. intros []; simpl. destruct (eq_X_dec x x) as [ | [] ]; auto. Qed. Fact list_assoc_neq x y l x' : x <> x' -> list_assoc x' ((x,y)::l) = list_assoc x' l. Proof. intros H; simpl. destruct (eq_X_dec x' x) as [ | ]; auto. destruct H; auto. Qed. Fact list_assoc_In x l : match list_assoc x l with | None => ~ In x (map fst l) | Some y => In (x,y) l end. Proof. induction l as [ | (x',y) l IHl ]; simpl; auto. destruct (eq_X_dec x x'); subst; auto. destruct (list_assoc x l); auto. intros [ ? | ]; subst; tauto. Qed. Fact In_list_assoc x l : In x (map fst l) -> { y | list_assoc x l = Some y /\ In (x,y) l }. Proof. intros H. generalize (list_assoc_In x l). destruct (list_assoc x l) as [ y | ]. exists y; auto. tauto. Qed. Fact not_In_list_assoc x l : ~ In x (map fst l) -> list_assoc x l = None. Proof. intros H. generalize (list_assoc_In x l). destruct (list_assoc x l) as [ y | ]; auto. intros H1; contradict H. apply in_map_iff. exists (x,y); simpl; auto. Qed. Fact list_assoc_app x ll mm : list_assoc x (ll++mm) = match list_assoc x ll with | None => list_assoc x mm | Some y => Some y end. Proof. induction ll as [ | (x',?) ]; simpl; auto. destruct (eq_X_dec x x'); auto. Qed.End list_assoc.Section list_first_dec. Variable (X : Type) (P : X -> Prop) (Pdec : forall x, { P x } + { ~ P x }). Theorem list_choose_dec ll : { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } } + { forall x, In x ll -> ~ P x }. Proof. induction ll as [ | a ll IH ]; [ | destruct (Pdec a) as [ Ha | Ha ]; [ | destruct IH as [ (l & x & r & H1 & H2 & H3) | H ]] ]. * right; intros _ []. * left; exists nil, a, ll; repeat split; auto. * left; exists (a::l), x, r; repeat split; subst; auto. intros ? [ | ]; subst; auto. * right; intros ? [ | ]; subst; auto. Qed. Theorem list_first_dec a ll : P a -> In a ll -> { l : _ & { x : _ & { r | ll = l++x::r /\ P x /\ forall y, In y l -> ~ P y } } }. 
a b) => pair (f a) (g b) end.Definition dup {A : Type} (x : A) : (A * A) := pair x x.Definition fan {A B C: Type} (f : A -> B) (g : A -> C) (x : A) : (B * C) := (par f g) (dup x).Definition nandb := fun x y => negb (andb x y).Require Import Program.About prod_curry. About andb. Check prod_curry andb. About id. Compute id 3. Fixpoint ceval {a b : Type} (circ : circuit a b) : a -> b := match circ with | Nand => (prod_curry nandb) | Dup => dup | Par f g => par (ceval f) (ceval g) | Id => fun x => x | Comp f g => compose (ceval f) (ceval g) | Fst => fst | Snd => snd end. Require Import Bool.Definition assoc {a b c : Type} : circuit ((a * b) * c) (a * (b * c)) := Comp (Par (Comp Fst Fst) (Par Snd Id)) Dup.Definition assoc' {a b c : Type} : circuit (a * (b * c)) ((a * b) * c) := Comp (Par (Par Id Fst) (Comp Snd Snd)) Dup.Fixpoint Bvector' (n : nat) : Type := match n with | S n' => bool * (Bvector' n') | Z => bool end.Fixpoint Btree (n : nat) : Type := match n with | S n' => (Btree n') * (Btree n') | Z => bool end. Compute Nat.shiftl 1 3. Compute Nat.pow 2 3.Fixpoint pow2 (n : nat) : nat := match n with | S n' => Nat.double (pow2 n') | Z => 1 end. Hint Resolve negb_involutive. Theorem emulate {A B C : Type} : forall x : A, forall f : circuit B C, forall g : circuit A B, ceval (Comp f g) x = (ceval f) ((ceval g) x). Proof. auto. Qed. Hint Resolve emulate. Definition nandc := Nand. Theorem nandb_equiv : forall (b1 b2 : bool), ceval nandc (pair b1 b2) = nandb b1 b2. Proof. auto. Qed.Hint Resolve nandb_equiv. Search (andb ?m ?m). Hint Rewrite andb_diag. Print andb_diag.Definition negc := Comp Nand Dup. Theorem negc_equiv : forall (b : bool), ceval negc b = negb b. Proof. destr_bool. Qed. Hint Rewrite negc_equiv.Search (negb (negb _)).Theorem dup_test: forall b : bool, dup b = (b , b). Proof. auto. Definition andc := Comp negc Nand. Theorem andc_equiv : forall (b1 b2 : bool), ceval andc (pair b1 b2) = andb b1 b2. 
set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. 
From Perennial.program_proof.mvcc Require Import tuple_prelude tuple_repr.Section program. Context `{!heapGS Œ£, !mvcc_ghostG Œ£}. Theorem wp_MkTuple (key : u64) Œ≥ p : mvcc_inv_gc Œ≥ -‚àó mvcc_inv_sst Œ≥ p -‚àó {{{ ptuple_auth Œ≥ (1/2) key [Nil; Nil] }}} MkTuple #() {{{ (tuple : loc), RET #tuple; is_tuple tuple key Œ≥ }}}. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat Coq_Cats.Type_Cat.Morphisms. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.Morphisms NatTrans.NatIso. From Categories Require Import Basic_Cons.Terminal. From Categories Require Import PreSheaf.PreSheaf PreSheaf.Terminal. From Categories Require Import Archetypal.Discr.Discr.Section PreSheaf_Monic_components_Monic. Context {C : Category} {F : PreSheaf C} . Section PMCM_PreSheaf_representing_d. Context (c : C) (d : Type). Local Hint Extern 1 => progress cbn : core. Program Definition PMCM_PreSheaf_representing_d : PreSheaf C := {| FO := fun c' => ((Hom C c' c) * d)%type; FA := fun o o' u x => (compose C u (fst x), snd x) |} . End PMCM_PreSheaf_representing_d. Context {G : PreSheaf C} (N : @Monic (PShCat C) F G) (c : C). Section PreSheaf_Monic_components_Monic_is_Monic. Context (d : Type) (g h : d ‚Üí (F _o)%object c) (H : (fun x => Trans (mono_morphism N) c (g x)) = (fun x => Trans (mono_morphism N) c (h x))). Local Hint Extern 1 => match goal with [|- context [(F _a)%morphism (?A ‚àò ?B)%morphism] ] => cbn_rewrite (F_compose F A B) end : core. Program Definition PMCM_PreSheaf_morph_of_function (f : d ‚Üí (F _o)%object c) : (PMCM_PreSheaf_representing_d c d --> F)%nattrans := {| Trans := fun o x => (F _a (fst x))%morphism (f (snd x)) |}. Theorem PMCM_N_co_equalizes : ((mono_morphism N) ‚àò (PMCM_PreSheaf_morph_of_function g))%nattrans = ((mono_morphism N) ‚àò (PMCM_PreSheaf_morph_of_function h))%nattrans. Proof. apply NatTrans_eq_simplify. extensionality x. extensionality y. destruct y as [y1 y2]. cbn in *. set (W := equal_f (Trans_com (mono_morphism N) y1)). cbn in W. do 2 rewrite W. rewrite (equal_f H). trivial. Qed. Theorem PreSheaf_Monic_components_is_Monic : g = h. 
=> (x, y) :: (combine tx ty) end.. Admitted. *)Inductive option (X:Type) : Type := | Some : X -> option X | None : option X.Arguments Some {X} _. Arguments None {X}.Instance dec_option' {A} (p q : option A) (D : forall (x y : A), Dec (x = y)) : Dec (p = q). Proof. constructor; unfold decidable. decide equality. apply D. Defined.Derive Arbitrary for option. Derive Show for option. Derive Sized for option. Derive CanonicalSized for option. Derive SizeMonotonic for option using genSoption. Derive SizedMonotonic for option. Derive SizedCorrect for option using genSoption and SizeMonotonicoption.Fixpoint nth_error {X : Type} (l : list X) (n : nat) : option X := match l with | [] => None | a :: l' => if beq_nat n O then Some a else nth_error l' (pred n) end.Fixpoint filter {X:Type} (test: X->bool) (l:list X) : (list X) := match l with | [] => [] | h :: t => if test h then h :: (filter test t) else filter test t end.Fixpoint map {X Y:Type} (f:X->Y) (l:list X) : (list Y) := match l with | [] => [] | h :: t => (f h) :: (map f t) end.From QuickChick Require Import CoArbitrary. Theorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X), map f (rev l) = rev (map f l). Admitted. Definition option_map {X Y : Type} (f : X -> Y) (xo : option X) : option Y := match xo with | None => None | Some x => Some (f x) end.Fixpoint fold {X Y:Type} (f: X->Y->Y) (l:list X) (b:Y) : Y := match l with | nil => b | h :: t => f h (fold f t b) end.Definition constfun {X: Type} (x: X) : nat->X := fun (k:nat) => x. Definition fold_length {X : Type} (l : list X) : nat := fold (fun _ n => S n) l 0.Theorem fold_length_correct : forall X (l : list X), fold_length l = length l. Admitted. Definition prod_curry {X Y Z : Type} (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).Definition prod_uncurry {X Y Z : Type} (f : X -> Y -> Z) (p : X * Y) : Z := let (x,y) := p in f x y. Theorem uncurry_curry : forall (X Y Z : Type) (f : X -> Y -> Z) x y, prod_curry (prod_uncurry f) x y = f x y. 
Equiv4_01. exact n3_47a. Qed.Theorem n4_86 : ‚àÄ P Q R : Prop, (P ‚Üî Q) ‚Üí ((P ‚Üî R) ‚Üî (Q ‚Üî R)). Proof. intros P Q R. specialize n4_22 with Q P R. intros n4_22a. specialize Exp3_3 with (Q‚ÜîP) (P‚ÜîR) (Q‚ÜîR). intros Exp3_3a. MP Exp3_3a n4_22a. specialize n4_22 with P Q R. intros n4_22b. specialize Exp3_3 with (P‚ÜîQ) (Q‚ÜîR) (P‚ÜîR). intros Exp3_3b. MP Exp3_3b n4_22b. specialize n4_21 with P Q. intros n4_21a. apply propositional_extensionality in n4_21a. replace (Q‚ÜîP) with (P‚ÜîQ) in Exp3_3a by now apply n4_21a. clear n4_22a. clear n4_22b. clear n4_21a. Conj Exp3_3a Exp3_3b Ca. specialize Comp3_43 with (P‚ÜîQ) ((P‚ÜîR)‚Üí(Q‚ÜîR)) ((Q‚ÜîR)‚Üí(P‚ÜîR)). intros Comp3_43a. MP Comp3_43a Ca. replace (((P‚ÜîR)‚Üí(Q‚ÜîR))‚àß((Q‚ÜîR)‚Üí(P‚ÜîR))) with ((P‚ÜîR)‚Üî(Q‚ÜîR)) in Comp3_43a by now rewrite Equiv4_01. exact Comp3_43a. Qed.Theorem n4_87 : ‚àÄ P Q R : Prop, (((P ‚àß Q) ‚Üí R) ‚Üî (P ‚Üí Q ‚Üí R)) ‚Üî ((Q ‚Üí (P ‚Üí R)) ‚Üî (Q ‚àß P ‚Üí R)). Proof. intros P Q R. specialize Exp3_3 with P Q R. intros Exp3_3a. specialize Imp3_31 with P Q R. intros Imp3_31a. Conj Exp3_3a Imp3_31a Ca. Equiv Ca. specialize Exp3_3 with Q P R. intros Exp3_3b. specialize Imp3_31 with Q P R. intros Imp3_31b. Conj Exp3_3b Imp3_31b Cb. Equiv Cb. specialize n4_21 with (Q‚ÜíP‚ÜíR) (Q‚àßP‚ÜíR). intros n4_21a. apply propositional_extensionality in n4_21a. replace ((Q‚àßP‚ÜíR)‚Üî(Q‚ÜíP‚ÜíR)) with ((Q‚ÜíP‚ÜíR)‚Üî(Q‚àßP‚ÜíR)) in Cb by now apply n4_21a. specialize Simp2_02 with ((P‚àßQ‚ÜíR)‚Üî(P‚ÜíQ‚ÜíR)) ((Q‚ÜíP‚ÜíR)‚Üî(Q‚àßP‚ÜíR)). intros Simp2_02a. MP Simp2_02a Cb. specialize Simp2_02 with ((Q‚ÜíP‚ÜíR)‚Üî(Q‚àßP‚ÜíR)) ((P‚àßQ‚ÜíR)‚Üî(P‚ÜíQ‚ÜíR)). intros Simp2_02b. MP Simp2_02b Ca. Conj Simp2_02a Simp2_02b Cc. Equiv Cc. exact Cc. Qed. End No4.Module No5.Import No1. Import No2. Import No3. Import No4.Theorem n5_1 : ‚àÄ P Q : Prop, (P ‚àß Q) ‚Üí (P ‚Üî Q). Proof. intros P Q. specialize n3_4 with P Q. intros n3_4a. specialize n3_4 with Q P. intros n3_4b. specialize n3_22 with P Q. intros n3_22a. Syll n3_22a n3_4b Sa. clear n3_22a. clear n3_4b. Conj n3_4a Sa C. specialize n4_76 with (P‚àßQ) (P‚ÜíQ) (Q‚ÜíP). intros n4_76a. apply propositional_extensionality in n4_76a. replace ((P‚àßQ‚ÜíP‚ÜíQ)‚àß(P‚àßQ‚ÜíQ‚ÜíP)) with (P ‚àß Q ‚Üí (P ‚Üí Q) ‚àß (Q ‚Üí P)) in C by now apply n4_76a. replace ((P‚ÜíQ)‚àß(Q‚ÜíP)) with (P‚ÜîQ) in C by now rewrite Equiv4_01. exact C. Qed. Theorem n5_11 : ‚àÄ P Q : Prop, (P ‚Üí Q) ‚à® (¬¨P ‚Üí Q). Proof. intros P Q. specialize n2_5 with P Q. intros n2_5a. specialize n2_54 with (P ‚Üí Q) (¬¨P ‚Üí Q). intros n2_54a. MP n2_54a n2_5a. exact n2_54a. Qed. Theorem n5_12 : ‚àÄ P Q : Prop, (P ‚Üí Q) ‚à® (P ‚Üí ¬¨Q). 
Require Import ZArith. Require Import Omega Ring InitialRing. Require Import Recdef. Require Import Tactics.CpdtTactics.Set Implicit Arguments. Section Matrix2. Variable A : Type. Variable zero one : A. Variable add mul sub : A -> A -> A. Variable opp : A -> A. Variable rt : ring_theory zero one add mul sub opp (@eq A). Add Ring Aring : rt. Notation "0" := (zero). Notation "1" := (one). Notation "x + y" := (add x y). Notation "x - y" := (sub x y). Notation "x * y" := (mul x y). Record Matrix : Type := { c00 : A; c01 : A; c10 : A; c11 : A; }. Definition Matrix2 := Matrix. Definition Unit2 : Matrix2 := {| c00 := 1; c01 := 0; c10 := 0; c11 := 1; |}. Definition Matrix2_mul (m n : Matrix2) : Matrix2 := {| c00 := c00 m * c00 n + c01 m * c10 n; c01 := c00 m * c01 n + c01 m * c11 n; c10 := c10 m * c00 n + c11 m * c10 n; c11 := c10 m * c01 n + c11 m * c11 n; |}. Theorem Matrix2_mul_assoc : forall (m n p : Matrix2), Matrix2_mul m (Matrix2_mul n p) = Matrix2_mul (Matrix2_mul m n) p. Proof. intros; destruct m, n, p. unfold Matrix2_mul; simpl; f_equal; ring. Qed. Theorem Matrix2_left_Unit : forall (m : Matrix2), Matrix2_mul Unit2 m = m. Proof. intros; destruct m. unfold Unit2, Matrix2_mul; simpl; f_equal; ring. Qed. Theorem Matrix2_right_Unit : forall (m : Matrix2), Matrix2_mul m Unit2 = m. Proof. intros; destruct m. unfold Unit2, Matrix2_mul; simpl; f_equal; ring. Qed. End Matrix2. Module ZMatrix2. Definition ZMatrix2 := Matrix2 Z. Definition ZMatrix2_mul := Matrix2_mul Z.add Z.mul. Definition ZUnit2 := Unit2 Z.zero Z.one. Theorem ZMatrix2_mul_assoc : forall (m n p : ZMatrix2), ZMatrix2_mul m (ZMatrix2_mul n p) = ZMatrix2_mul (ZMatrix2_mul m n) p. Proof. eapply Matrix2_mul_assoc; apply Zth. Qed. Theorem ZMatrix2_left_Unit : forall (m : ZMatrix2), ZMatrix2_mul ZUnit2 m = m. Proof. eapply Matrix2_left_Unit; apply Zth. Qed. Theorem ZMatrix2_right_Unit : forall (m : ZMatrix2), ZMatrix2_mul m ZUnit2 = m. 
Require Export Fmin. Section FOdd. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition Even (z : Z) : Prop := exists z1 : _, z = (2 * z1)%Z. Definition Odd (z : Z) : Prop := exists z1 : _, z = (2 * z1 + 1)%Z. Theorem OddSEven : forall n : Z, Odd n -> Even (Zsucc n). intros n H'; case H'; intros m H'1; exists (Zsucc m). rewrite H'1; unfold Zsucc in |- *; ring. Qed. Theorem EvenSOdd : forall n : Z, Even n -> Odd (Zsucc n). intros n H'; case H'; intros m H'1; exists m. rewrite H'1; unfold Zsucc in |- *; ring. Qed. Hint Resolve OddSEven EvenSOdd: zarith. Theorem OddSEvenInv : forall n : Z, Odd (Zsucc n) -> Even n. intros n H'; case H'; intros m H'1; exists m. apply Zsucc_inj; rewrite H'1; (unfold Zsucc in |- *; ring). Qed. Theorem EvenSOddInv : forall n : Z, Even (Zsucc n) -> Odd n. intros n H'; case H'; intros m H'1; exists (Zpred m). apply Zsucc_inj; rewrite H'1; (unfold Zsucc, Zpred in |- *; ring). Qed. Theorem EvenO : Even 0. exists 0%Z; simpl in |- *; auto. Qed. Hint Resolve EvenO: zarith. Theorem Odd1 : Odd 1. exists 0%Z; simpl in |- *; auto. Qed. Hint Resolve Odd1: zarith. Theorem OddOpp : forall z : Z, Odd z -> Odd (- z). intros z H; case H; intros z1 H1; exists (- Zsucc z1)%Z; rewrite H1. unfold Zsucc in |- *; ring. Qed. Theorem EvenOpp : forall z : Z, Even z -> Even (- z). 
propX G) -> Prop with | nil => fun a => specs f = Some (fun x => a x) | _ => fun _ => False end a | And G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 /\ interp P2 | _ => fun _ _ => False end P1 P2 | Or G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 \/ interp P2 | _ => fun _ _ => False end P1 P2 | Imply G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 -> interp P2 | _ => fun _ _ => False end P1 P2 | Forall G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => forall x, interp (P1 x) | _ => fun _ => False end P1 | Exists G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => exists x, interp (P1 x) | _ => fun _ => False end P1 | ForallX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => forall x, interp (Subst P1 x) | _ => fun _ => False end P1 | ExistsX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => exists x, interp (Subst P1 x) | _ => fun _ => False end P1 | _ => False end. intros ? H; apply normalization in H; inversion H; subst; clear H; try solve [ elimtype False; eauto ]; intuition eauto. Qed. Ltac sound := intros; match goal with | [ H : interp _ |- _ ] => solve [ apply interp_sound in H; auto ] end. Theorem Inj_sound : forall p, interp (Inj p) -> p. sound. Qed. Theorem Cptr_sound : forall f a, interp (Cptr f a) -> specs f = Some (fun x => a x). sound. Qed. Theorem And_sound : forall P Q, interp (And P Q) -> interp P /\ interp Q. sound. Qed. Theorem Or_sound : forall P Q, interp (Or P Q) -> interp P \/ interp Q. 
(nat*state_X) -> (nat*state_X) -> Prop) (step_Y : Y -> (nat*state_Y) -> (nat*state_Y) -> Prop). Notation "œÅ '/X/' s -1> t" := (step_X œÅ s t) (at level 70, no associativity). Notation "P '/X/' s '-[' k ']->' t" := (sss_steps step_X P k s t) (at level 70, no associativity). Notation "P '/X/' s '-+>' t" := (sss_progress step_X P s t) (at level 70, no associativity). Notation "P '/X/' s ->> t" := (sss_compute step_X P s t) (at level 70, no associativity). Notation "P '/X/' s '~~>' t" := (sss_output step_X P s t) (at level 70, no associativity). Notation "P '/X/' s ‚Üì" := (sss_terminates step_X P s)(at level 70, no associativity). Notation "œÅ '/Y/' s -1> t" := (step_Y œÅ s t) (at level 70, no associativity). Notation "P '/Y/' s '-[' k ']->' t" := (sss_steps step_Y P k s t) (at level 70, no associativity). Notation "P '/Y/' s '-+>' t" := (sss_progress step_Y P s t) (at level 70, no associativity). Notation "P '/Y/' s ->> t" := (sss_compute step_Y P s t) (at level 70, no associativity). Notation "P '/Y/' s '~~>' t" := (sss_output step_Y P s t) (at level 70, no associativity). Notation "P '/Y/' s ‚Üì" := (sss_terminates step_Y P s)(at level 70, no associativity). Hypothesis (step_X_tot : forall I st1, exists st2, I /X/ st1 -1> st2) (step_Y_fun : forall I st st1 st2, I /Y/ st -1> st1 -> I /Y/ st -1> st2 -> st1 = st2). Variable (simul : state_X -> state_Y -> Prop). Infix "‚ãà" := simul (at level 70, no associativity). Definition instruction_compiler_sound := forall lnk I i1 v1 i2 v2 w1, I /X/ (i1,v1) -1> (i2,v2) -> lnk (1+i1) = length (icomp lnk i1 I) + lnk i1 -> v1 ‚ãà w1 -> exists w2, (lnk i1,icomp lnk i1 I) /Y/ (lnk i1,w1) -+> (lnk i2,w2) /\ v2 ‚ãà w2. Hypothesis Hicomp : instruction_compiler_sound. Section correctness. Variables (linker : nat -> nat) (P : nat * list X) (Q : nat * list Y) (HPQ : forall i œÅ, (i,[œÅ]) <sc P -> (linker i, icomp linker i œÅ) <sc Q /\ linker (1+i) = ilen œÅ + linker i). Definition compiled_sound := forall i‚ÇÅ v‚ÇÅ i‚ÇÇ v‚ÇÇ w‚ÇÅ, v‚ÇÅ ‚ãà w‚ÇÅ /\ P /X/ (i‚ÇÅ,v‚ÇÅ) ->> (i‚ÇÇ,v‚ÇÇ) -> exists w‚ÇÇ, v‚ÇÇ ‚ãà w‚ÇÇ /\ Q /Y/ (linker i‚ÇÅ,w‚ÇÅ) ->> (linker i‚ÇÇ,w‚ÇÇ). Theorem compiler_sound : compiled_sound. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops. From Categories Require Import Cat.Cat. From Categories Require Import NatTrans.NatTrans.Local Open Scope nattrans_scope. Section Opposite_NatTrans. Context {C D : Category} {F F' : (C ‚Äì‚âª D)%functor} (N : (F ‚Äì‚âª F')%nattrans). Program Definition Opposite_NatTrans : F'^op ‚Äì‚âª F^op := {| Trans := Trans N; Trans_com := fun c c' h => (Trans_com_sym N h); Trans_com_sym := fun c c' h => (Trans_com N h) |}. End Opposite_NatTrans.Notation "N '^op'" := (Opposite_NatTrans N) : nattrans_scope. Section Compose_NOP. Context {C D : Category} {F F' F'' : (C ‚Äì‚âª D)%functor} (N : F ‚Äì‚âª F') (N' : F' ‚Äì‚âª F''). Theorem NatTrans_compose_Op : ((N' ‚àò N)^op = N^op ‚àò (N'^op))%nattrans. Proof. apply NatTrans_eq_simplify. trivial. Qed.End Compose_NOP. Section NatTrans_id_Op. Context {C D : Category} (F : (C ‚Äì‚âª D)%functor). Theorem NatTrans_id_Op : ((NatTrans_id F)^op)%nattrans = NatTrans_id (F^op)%functor. Proof. apply NatTrans_eq_simplify. trivial. Qed.End NatTrans_id_Op. Program Definition NatTrans_hor_comp {C D E : Category} {F G : (C ‚Äì‚âª D)%functor} {F' G' : (D ‚Äì‚âª E)%functor} (tr : F ‚Äì‚âª G) (tr' : F' ‚Äì‚âª G') : (F' ‚àò F) ‚Äì‚âª (G' ‚àò G) := {| Trans := fun c : Obj => ((G' _a (Trans tr c)) ‚àò (Trans tr' (F _o c)))%morphism |}.Next Obligation. Proof. rewrite assoc. rewrite Trans_com. rewrite assoc_sym. rewrite <- F_compose. rewrite Trans_com. rewrite F_compose. auto. Qed.Next Obligation. Proof. symmetry. apply NatTrans_hor_comp_obligation_1. Qed.Notation "N ‚àò_h N'" := (NatTrans_hor_comp N' N) : nattrans_scope. Section Hor_Compose_ids. Context {C D E : Category} (F : (C ‚Äì‚âª D)%functor) (G : (D ‚Äì‚âª E)%functor). Theorem NatTrans_hor_comp_ids : ((NatTrans_id G) ‚àò_h (NatTrans_id F))%nattrans = NatTrans_id (G ‚àò F). Proof. apply NatTrans_eq_simplify. cbn. extensionality c. rewrite F_id; simpl_ids; trivial. Qed.End Hor_Compose_ids. Section Hor_Compose_NOP. Context {C D E : Category} {F G : (C ‚Äì‚âª D)%functor} {F' G' : (D ‚Äì‚âª E)%functor} (N : F ‚Äì‚âª G) (N' : F' ‚Äì‚âª G'). Theorem NatTrans_hor_comp_Op : ((N' ‚àò_h N)^op = N'^op ‚àò_h N^op)%nattrans. 
Sig2_SigSSn1_encoding.Section Œ£2_Œ£SSn1_enc. Variable (n : nat) (A : fol_form Œ£2). Let d := S (lmax (fol_vars A)). Definition Œ£2_Œ£SSn1_enc := fol_lconj (map (PSSn1 n d) (fol_vars A)) ‚üë PSSn1 n d 0 ‚üë Œ£2_Œ£SSn1 n d A.End Œ£2_Œ£SSn1_enc.Section Œ£2_Œ£SSn1_enc_sound. Variable (n : nat) (A : fol_form Œ£2) (X : Type) (M2 : fo_model Œ£2 X) (œÜ : nat -> X) (HA : fol_sem M2 œÜ A). Let Y := (bool + X + X*X)%type. Let i := S (lmax (fol_vars A)). Let d : Y := inl (inl true). Let MSSn1 : fo_model (Œ£n1 (S (S n))) Y. Proof. split. + simpl; intros _ v. exact (match (vec_head v), (vec_head (vec_tail v)) with | inl (inl true), inl (inr x) => inl (inr x) | inl (inr x1), inl (inr x2) => inr (x1,x2) | _ , _ => inl (inl false) end). + simpl; intros _ v. exact (match vec_head v with | inl (inr _) => True | inr (x1,x2) => fom_rels M2 tt (x1##x2##√∏) | _ => False end). Defined. Let œà n : Y := if eq_nat_dec i n then d else inl (inr (œÜ n)). Let phi_i : œà i = d. Proof. unfold œà. destruct (eq_nat_dec i i) as [ | [] ]; auto. Qed. Let phi_x j : In j (fol_vars A) -> œà j = inl (inr (œÜ j)). Proof. intros H. assert (D : lmax (fol_vars A) < i). { apply le_refl. } unfold œà. destruct (eq_nat_dec i j); auto. apply lmax_prop in H; lia. Qed. Let R x (y : Y) := y = inl (inr x). Let sem_Œ£2_Œ£SSn1_enc : fol_sem MSSn1 œà (Œ£2_Œ£SSn1_enc n A). Proof. simpl; msplit 2. - rewrite fol_sem_lconj; intros ?; rewrite in_map_iff. intros (j & <- & Hj); simpl. fold i; rewrite phi_i; simpl. rewrite phi_x; auto. - fold i; rewrite phi_i; simpl; auto. - revert HA; apply Œ£2_Œ£SSn1_correct with (R := R). + intros x1 x2 y1 y2; unfold R; simpl; intros -> ->; tauto. + intros x; exists (inl (inr x)); split. * red; auto. * fold i; rewrite phi_i; unfold d; simpl; auto. + fold i; rewrite phi_i; intros [ [ [] | x ] | (x1,x2) ]; simpl; try tauto. exists x; red; auto. + intros j Hj; rewrite (phi_x _ Hj); red; auto. Qed. Hypothesis (HX : finite_t X) (M2_dec : fo_model_dec M2). Hint Resolve finite_t_sum finite_t_bool finite_t_prod : core. Theorem Œ£2_Œ£SSn1_enc_sound : fo_form_fin_dec_SAT (Œ£2_Œ£SSn1_enc n A). 
facts -> exprD funcs uvars vars pe ptrT = Some p -> exprD funcs uvars vars ve valT = Some v -> match applyD (@exprD _ funcs uvars vars) (SEP.SDomain Predicate) args _ (SEP.SDenotation Predicate) with | None => False | Some p => mem_satisfies cs (ST.star p Q) stn_st end -> match applyD (@exprD _ funcs uvars vars) (SEP.SDomain Predicate) args' _ (SEP.SDenotation Predicate) with | None => False | Some pr => match WriteWord stn_st p v with | None => False | Some sm' => mem_satisfies cs (ST.star pr Q) sm' end end ; sym_read_byte_correct : forall P (PE : ProverT_correct P funcs), forall args uvars vars cs facts pe p ve stn_st Q, pred_read_byte me P facts args pe = Some ve -> Valid PE uvars vars facts -> exprD funcs uvars vars pe ptrT = Some p -> match applyD (exprD funcs uvars vars) (SEP.SDomain Predicate) args _ (SEP.SDenotation Predicate) with | None => False | Some p => mem_satisfies cs (ST.star p Q) stn_st end -> match exprD funcs uvars vars ve valT with | Some v => ReadByte stn_st p = Some v | _ => False end ; sym_write_byte_correct : forall P (PE : ProverT_correct P funcs), forall args uvars vars cs facts pe p ve v stn_st args' Q, pred_write_byte me P facts args pe ve = Some args' -> Valid PE uvars vars facts -> exprD funcs uvars vars pe ptrT = Some p -> exprD funcs uvars vars ve valT = Some v -> match applyD (@exprD _ funcs uvars vars) (SEP.SDomain Predicate) args _ (SEP.SDenotation Predicate) with | None => False | Some p => mem_satisfies cs (ST.star p Q) stn_st end -> match applyD (@exprD _ funcs uvars vars) (SEP.SDomain Predicate) args' _ (SEP.SDenotation Predicate) with | None => False | Some pr => match WriteByte stn_st p v with | None => False | Some sm' => mem_satisfies cs (ST.star pr Q) sm' end end }. End typed. Section search_read_write. Variable types : list type. Variable T : Type. Variable F : exprs types -> option T. Variable F_upd : exprs types -> option (exprs types). Fixpoint fold_args (es : list (exprs types)) : option T := match es with | nil => None | a :: b => match F a with | None => fold_args b | Some r => Some r end end. Theorem fold_args_correct : forall es v, fold_args es = Some v -> exists k, In k es /\ F k = Some v. 
Require Import Arith Lia Wellfounded List Extraction.From Undecidability.Shared.Libs.DLW.Wf Require Import acc_irr.Set Implicit Arguments.Section measure_rect. Variable (X : Type) (m : X -> nat) (P : X -> Type). Hypothesis F : forall x, (forall x', m x' < m x -> P x') -> P x. Arguments F : clear implicits. Let R x y := m x < m y. Let Rwf : forall x : X, Acc R x. Proof. apply wf_inverse_image with (f := m), lt_wf. Qed. Let Fix_F : forall x : X, Acc R x -> P x. Proof. refine( fix Fix_F x (H : Acc R x) { struct H } := F x (fun x' (H' : R x' x) => Fix_F x' _) ). destruct H as [ G ]. apply G. trivial. Defined. Let Fix_F_fix x A : @Fix_F x A = F x (fun y H => Fix_F (Acc_inv A H)). Proof. destruct A; reflexivity. Qed. Definition measure_rect x : P x := Fix_F (Rwf x). Hypothesis F_ext : forall x f g, (forall y H, f y H = g y H) -> F x f = F x g. Let Fix_F_Acc_irr : forall x f g, @Fix_F x f = Fix_F g. Proof using F_ext. apply Acc_irrelevance. intros; apply F_ext; auto. Qed. Theorem measure_rect_fix x : measure_rect x = @F x (fun y _ => measure_rect y). Proof using F_ext. unfold measure_rect; rewrite Fix_F_fix. apply F_ext. intros; apply Fix_F_Acc_irr. Qed.End measure_rect.Tactic Notation "induction" "on" hyp(x) "as" ident(IH) "with" "measure" uconstr(f) := pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.Extraction Inline measure_rect.Section measure_double_rect. Variable (X Y : Type) (m : X -> Y -> nat) (P : X -> Y -> Type). Hypothesis F : (forall x y, (forall x' y', m x' y' < m x y -> P x' y') -> P x y). Let m' (c : X * Y) := match c with (x,y) => m x y end. Let R c d := m' c < m' d. Let Rwf : well_founded R. Proof. apply wf_inverse_image with (f := m'), lt_wf. Qed. Section measure_double_rect_paired. Let Q c := match c with (x,y) => P x y end. Theorem measure_double_rect_paired x y : P x y. 
simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold_spec: forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A), fold f m v = List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v. Proof. intros. unfold fold, elements. rewrite <- xfold_xelements. auto. Qed. Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B := match m with | Leaf => v | Node l None r => let v1 := fold1 f l v in fold1 f r v1 | Node l (Some x) r => let v1 := fold1 f l v in let v2 := f v1 x in fold1 f r v2 end. Lemma fold1_xelements: forall (A B: Type) (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) = List.fold_left (fun a p => f a (snd p)) (xelements m i l) v. Proof. induction m; intros. simpl. auto. destruct o; simpl. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. rewrite <- IHm1. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. apply fold1_xelements with (l := @nil (positive * A)). Qed.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. unfold init. unfold get. simpl. rewrite PTree.gempty. auto. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. 
: Z, Zabs (z1 * z2) = (Zabs z1 * Zabs z2)%Z. intros z1 z2; case z1; case z2; simpl in |- *; auto with zarith. Qed. Theorem Zle_Zmult_comp_r : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (x * z <= y * z)%Z. intros x y z H' H'0; case (Zle_lt_or_eq _ _ H'); intros Zlt1. apply Zmult_gt_0_le_compat_r; auto. apply Zlt_gt; auto. rewrite <- Zlt1; repeat rewrite <- Zmult_0_r_reverse; auto with zarith. Qed. Theorem Zle_Zmult_comp_l : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (z * x <= z * y)%Z. intros x y z H' H'0; repeat rewrite (Zmult_comm z); apply Zle_Zmult_comp_r; auto. Qed. Theorem NotZmultZero : forall z1 z2 : Z, z1 <> 0%Z -> z2 <> 0%Z -> (z1 * z2)%Z <> 0%Z. intros z1 z2; case z1; case z2; simpl in |- *; intros; auto; try discriminate. Qed. Hint Resolve NotZmultZero: zarith. Theorem IZR_zero : forall p : Z, p = 0%Z -> IZR p = 0%R. intros p H'; rewrite H'; auto. Qed. Hint Resolve not_O_INR: real. Theorem IZR_zero_r : forall p : Z, IZR p = 0%R -> p = 0%Z. intros p; case p; simpl in |- *; auto. intros p1 H'; Contradict H'; auto with real zarith. intros p1 H'; absurd (INR (nat_of_P p1) = 0%R); auto with real zarith. rewrite <- (Ropp_involutive (INR (nat_of_P p1))). unfold IZR in H'; rewrite <- INR_IPR in H'. rewrite H'; auto with real. Qed. Theorem INR_lt_nm : forall n m : nat, n < m -> (INR n < INR m)%R. intros n m H'; elim H'; auto. replace (INR n) with (INR n + 0)%R; auto with real; rewrite S_INR; auto with real. intros m0 H'0 H'1. replace (INR n) with (INR n + 0)%R; auto with real; rewrite S_INR; auto with real. Qed. Hint Resolve INR_lt_nm: real. Theorem Rlt_INR1 : forall n : nat, 1 < n -> (1 < INR n)%R. replace 1%R with (INR 1); auto with real. Qed. Hint Resolve Rlt_INR1: real. Theorem NEq_INR : forall n m : nat, n <> m -> INR n <> INR m. intros n m H'; (case (le_or_lt n m); intros H'1). case (le_lt_or_eq _ _ H'1); intros H'2. apply Rlt_dichotomy_converse; auto with real. Contradict H'; auto. apply Compare.not_eq_sym; apply Rlt_dichotomy_converse; auto with real. Qed. Hint Resolve NEq_INR: real. Theorem NEq_INRO : forall n : nat, n <> 0 -> INR n <> 0%R. 
eqn:Hx; subst; econstructor; eauto. Qed. Fixpoint Vint_or_Vptr (v:Values.val): bool := match v with | Vint _ => negb Archi.ptr64 | Vlong _ => Archi.ptr64 | Vptr _ _ => true | _ => false end.Inductive get_var_or_funvar (lenv: temp_env): positive -> Values.val -> Prop := |F_gVoF: forall b x, Genv.find_symbol (Genv.globalenv p) x = Some b -> get_var_or_funvar lenv x (Vptr b (Ptrofs.repr 0%Z)) | V_gVoF: forall x v, Genv.find_symbol (Genv.globalenv p) x = None -> M.get x lenv = Some v -> Vint_or_Vptr v = true -> get_var_or_funvar lenv x v. Fixpoint get_var_or_funvar_list (lenv:temp_env) (l:list positive): option (list (Values.val)) := match l with | nil => Some nil | x::ls => (match get_var_or_funvar_list lenv ls with | Some vs => (match Genv.find_symbol (Genv.globalenv p) x with | Some b => Some ((Vptr b Ptrofs.zero)::vs) | None => (match (M.get x lenv) with | Some v => (match v with | Vint _ => if Archi.ptr64 then None else Some (v::vs) | Vlong _ => if Archi.ptr64 then Some (v::vs) else None | Vptr _ _ => Some (v::vs) | _ => None end) | None => None end) end) | None => None end) end. Lemma get_var_or_funvar_list_correct1: forall lenv l vs, get_var_or_funvar_list lenv l = Some vs -> Forall2 (get_var_or_funvar lenv) l vs. Proof. induction l; intros. simpl in H. inv H. constructor. simpl in H. destruct (get_var_or_funvar_list lenv l) eqn:gvl. specialize (IHl l0 (eq_refl _)). destruct (Genv.find_symbol (Genv.globalenv p) a) eqn:gfpa. - inv H. constructor; auto. left; auto. - destruct (M.get a lenv) eqn:gal. destruct v; inv H. destruct (Archi.ptr64) eqn:Harch; constructor. right; auto. auto. constructor; auto. auto. constructor; auto. right; auto. inv H. - inv H. Qed.Theorem get_var_or_funvar_list_correct2: forall lenv l vs, Forall2 (get_var_or_funvar lenv) l vs -> get_var_or_funvar_list lenv l = Some vs. Proof. induction l; intros. - inv H. reflexivity. - inv H. apply IHl in H4. simpl. rewrite H4. inv H2. rewrite H. reflexivity. rewrite H. rewrite H0. destruct y; inv H1; auto. Qed.Theorem get_var_or_funvar_list_correct: forall lenv l vs, Forall2 (get_var_or_funvar lenv) l vs <-> get_var_or_funvar_list lenv l = Some vs. Proof. split. apply get_var_or_funvar_list_correct2. apply get_var_or_funvar_list_correct1. Qed. Theorem get_var_or_funvar_list_set: forall lenv x v l, ~ List.In x l -> get_var_or_funvar_list lenv l = get_var_or_funvar_list (M.set x v lenv) l. Proof. induction l; intros. - reflexivity. - simpl. rewrite M.gso. rewrite IHl. reflexivity. intro. apply H. constructor 2. auto. intro; apply H. constructor; auto. Qed. Theorem Forall2_length': forall A B (R:A -> B -> Prop) l l', Forall2 R l l' -> length l = length l'. 
induction (rev ls). apply H. simpl. auto. Qed.Section AllB. Universe u. Variable T : Type@{u}. Variable p : T -> bool. Fixpoint allb@{} (ls : list T) : bool := match ls with | nil => true | l :: ls => if p l then allb ls else false end. Fixpoint anyb@{} (ls : list T) : bool := match ls with | nil => false | l :: ls => if p l then true else anyb ls end. End AllB.Lemma Forall_map@{uT uU} : forall (T : Type@{uT}) (U : Type@{uU}) (f : T -> U) P ls, Forall P (List.map f ls) <-> Forall (fun x => P (f x)) ls. Proof. induction ls; simpl. { split; intros; constructor. } { split; inversion 1; intros; subst; constructor; auto. apply IHls. auto. apply IHls. auto. } Qed.Lemma Forall_cons_iff@{u} : forall (T : Type@{u}) (P : T -> Prop) a b, Forall P (a :: b) <-> (P a /\ Forall P b). Proof. clear. split. inversion 1; auto. destruct 1; constructor; auto. Qed.Lemma Forall_nil_iff@{u} : forall (T : Type@{u}) (P : T -> Prop), Forall P nil <-> True. Proof. clear. split; auto. Qed. Global Instance Foldable_list@{u} {T : Type@{u}} : Foldable (list T) T := fun _ f x ls => fold_right f x ls.Require Import ExtLib.Structures.Traversable. Require Import ExtLib.Structures.Functor. Require Import ExtLib.Structures.Monads. Require Import ExtLib.Structures.Applicative.Section traversable. Universe u v vF. Context {F : Type@{v} -> Type@{vF}}. Context {Applicative_F : Applicative F}. Context {A : Type@{u}} {B : Type@{v}}. Variable f : A -> F B. Fixpoint mapT_list@{} (ls : list A) : F (list B) := match ls with | nil => pure nil | l :: ls => ap (ap (pure (@cons B)) (f l)) (mapT_list ls) end. End traversable.Global Instance Traversable_list@{} : Traversable list := { mapT := @mapT_list }.Monomorphic Universe listU.Global Instance Monad_list@{} : Monad@{listU listU} list := { ret := fun _ x => x :: nil ; bind := fun _ _ x f => flat_map f x }.Global Instance MonadZero_list : MonadZero list := { mzero := @nil }.Global Instance MonadPlus_list : MonadPlus list := { mplus _A _B a b := List.map inl a ++ List.map inr b }.Section list. Inductive R_list_len@{u} {T : Type@{u}} : list T -> list T -> Prop := | R_l_len : forall n m, length n < length m -> R_list_len n m. Theorem wf_R_list_len@{u} (T : Type@{u}) : well_founded (@R_list_len T). 
Rgt_not_eq. rewrite Rabs_pos_eq. split. apply Rle_trans with (1 := proj1 Ex'). pattern x at 1 ; rewrite <- Rplus_0_r. apply Rplus_le_compat_l. apply ulp_ge_0. exact H. apply Rplus_le_le_0_compat. now apply Rlt_le. apply ulp_ge_0. rewrite H. apply generic_format_bpow. apply valid_exp. destruct (Zle_or_lt ex (fexp ex)) ; trivial. elim Rlt_not_le with (1 := Zx). rewrite Fx. replace (Ztrunc (scaled_mantissa beta fexp x)) with Z0. rewrite F2R_0. apply Rle_refl. unfold scaled_mantissa. rewrite canonic_exp_fexp with (1 := Ex). destruct (mantissa_small_pos beta fexp x ex) ; trivial. rewrite Ztrunc_floor. apply sym_eq. apply Zfloor_imp. split. now apply Rlt_le. exact H2. now apply Rlt_le. now apply Rlt_le. Qed.Theorem generic_format_pred_pos : forall x, F x -> (0 < x)%R -> F (pred_pos x). Proof. intros x Fx Zx. unfold pred_pos; case Req_bool_spec; intros H. now apply generic_format_pred_aux2. now apply generic_format_pred_aux1. Qed. Theorem generic_format_succ : forall x, F x -> F (succ x). Proof. intros x Fx. unfold succ; case Rle_bool_spec; intros Zx. destruct Zx as [Zx|Zx]. now apply generic_format_succ_aux1. rewrite <- Zx, Rplus_0_l. apply generic_format_ulp_0. apply generic_format_opp. apply generic_format_pred_pos. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem generic_format_pred : forall x, F x -> F (pred x). Proof. intros x Fx. unfold pred. apply generic_format_opp. apply generic_format_succ. now apply generic_format_opp. Qed.Theorem pred_pos_lt_id : forall x, (x <> 0)%R -> (pred_pos x < x)%R. Proof. intros x Zx. unfold pred_pos. case Req_bool_spec; intros H.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. apply bpow_gt_0.rewrite <- Rplus_0_r. apply Rplus_lt_compat_l. rewrite <- Ropp_0. apply Ropp_lt_contravar. rewrite ulp_neq_0; trivial. apply bpow_gt_0. Qed.Theorem succ_gt_id : forall x, (x <> 0)%R -> (x < succ x)%R. Proof. intros x Zx; unfold succ. case Rle_bool_spec; intros Hx. pattern x at 1; rewrite <- (Rplus_0_r x). apply Rplus_lt_compat_l. rewrite ulp_neq_0; trivial. apply bpow_gt_0. pattern x at 1; rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar. apply pred_pos_lt_id. now auto with real. Qed. Theorem pred_lt_id : forall x, (x <> 0)%R -> (pred x < x)%R. Proof. intros x Zx; unfold pred. pattern x at 2; rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar. apply succ_gt_id. now auto with real. Qed.Theorem succ_ge_id : forall x, (x <= succ x)%R. Proof. intros x; case (Req_dec x 0). intros V; rewrite V. unfold succ; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l; apply ulp_ge_0. intros; left; now apply succ_gt_id. Qed. Theorem pred_le_id : forall x, (pred x <= x)%R. Proof. intros x; unfold pred. pattern x at 2; rewrite <- (Ropp_involutive x). apply Ropp_le_contravar. apply succ_ge_id. Qed. Theorem pred_pos_ge_0 : forall x, (0 < x)%R -> F x -> (0 <= pred_pos x)%R. 
S \* 'C_R(S) = R. Proof. move=> pR sSR esS sSR_S'; have [[defPhi defS'] _] := esS. have [pS [sPS nPS]] := (pgroupS sSR pR, andP (Phi_normal S : 'Phi(S) <| S)). have{esS} oZS: #|'Z(S)| = p := card_center_extraspecial pS esS. have nSR: R \subset 'N(S) by rewrite -commg_subl (subset_trans sSR_S') ?der_sub. have nsCR: 'C_R(S) <| R by rewrite (normalGI nSR) ?cent_normal. have nCS: S \subset 'N('C_R(S)) by rewrite cents_norm // centsC subsetIr. rewrite cprodE ?subsetIr //= -{2}(quotientGK nsCR) normC -?quotientK //. congr (_ @*^-1 _); apply/eqP; rewrite eqEcard quotientS //=. rewrite -(card_isog (second_isog nCS)) setIAC (setIidPr sSR) /= -/'Z(S) -defPhi. rewrite -ker_conj_aut (card_isog (first_isog_loc _ nSR)) //=; set A := _ @* R. have{pS} abelSb := Phi_quotient_abelem pS; have [pSb cSSb _] := and3P abelSb. have [/= Xb defSb oXb] := grank_witness (S / 'Phi(S)). pose X := (repr \o val : coset_of _ -> gT) @: Xb. have sXS: X \subset S; last have nPX := subset_trans sXS nPS. apply/subsetP=> x; case/imsetP=> xb Xxb ->; have nPx := repr_coset_norm xb. rewrite -sub1set -(quotientSGK _ sPS) ?sub1set ?quotient_set1 //= sub1set. by rewrite coset_reprK -defSb mem_gen. have defS: <<X>> = S. apply: Phi_nongen; apply/eqP; rewrite eqEsubset join_subG sPS sXS -joing_idr. rewrite -genM_join sub_gen // -quotientSK ?quotient_gen // -defSb genS //. apply/subsetP=> xb Xxb; apply/imsetP; rewrite (setIidPr nPX). by exists (repr xb); rewrite /= ?coset_reprK //; apply: imset_f. pose f (a : {perm gT}) := [ffun x => if x \in X then x^-1 * a x else 1]. have injf: {in A &, injective f}. move=> _ _ /morphimP[y nSy Ry ->] /morphimP[z nSz Rz ->]. move/ffunP=> eq_fyz; apply: (@eq_Aut _ S); rewrite ?Aut_aut //= => x Sx. rewrite !norm_conj_autE //; apply: canRL (conjgKV z) _; rewrite -conjgM. rewrite /conjg -(centP _ x Sx) ?mulKg {x Sx}// -defS cent_gen -sub_cent1. apply/subsetP=> x Xx; have Sx := subsetP sXS x Xx. move/(_ x): eq_fyz; rewrite !ffunE Xx !norm_conj_autE // => /mulgI xy_xz. by rewrite cent1C inE conjg_set1 conjgM xy_xz conjgK. have sfA_XS': f @: A \subset pffun_on 1 X S^`(1). apply/subsetP=> _ /imsetP[_ /morphimP[y nSy Ry ->] ->]. apply/pffun_onP; split=> [|_ /imageP[x /= Xx ->]]. by apply/subsetP=> x; apply: contraNT => /[!ffunE]/negPf->. have Sx := subsetP sXS x Xx. by rewrite ffunE Xx norm_conj_autE // (subsetP sSR_S') ?mem_commg. rewrite -(card_in_imset injf) (leq_trans (subset_leq_card sfA_XS')) // defS'. rewrite card_pffun_on (card_pgroup pSb) -rank_abelem -?grank_abelian // -oXb. by rewrite -oZS ?leq_pexp2l ?cardG_gt0 ?leq_imset_card. Qed. Theorem extraspecial_structure S : p.-group S -> extraspecial S -> {Es | all (fun E => (#|E| == p ^ 3)%N && ('Z(E) == 'Z(S))) Es & \big[cprod/1%g]_(E <- Es) E \* 'Z(S) = S}. 
sum_is_inv x y. Proof Ring.sum_inv_ex ring. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. Proof Ring.sum_inv_uniq_ex ring. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Ring.sum_intro_l ring. Theorem sum_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Ring.sum_intro_r ring. Theorem sum_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Ring.sum_cancel_l ring. Theorem sum_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Ring.sum_cancel_r ring. Theorem sum_inv_l_uniq : forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y. Proof Ring.sum_inv_l_uniq ring. Theorem sum_inv_r_uniq : forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Ring.sum_inv_r_uniq ring. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Ring.sum_0_inv_l ring. Theorem sum_0_inv_r : sum_is_inv_r 0 0. Proof Ring.sum_0_inv_r ring. Theorem sum_0_inv : sum_is_inv 0 0. Proof Ring.sum_0_inv ring. Theorem sum_has_inv_l_0 : sum_has_inv_l 0. Proof Ring.sum_has_inv_l_0 ring. Theorem sum_has_inv_r_0 : sum_has_inv_r 0. Proof Ring.sum_has_inv_r_0 ring. Theorem sum_has_inv_0 : sum_has_inv 0. Proof Ring.sum_has_inv_0 ring. Theorem sum_inv_0_eq_0 : forall x : E, sum_is_inv x 0 -> x = 0. Proof Ring.sum_inv_0_eq_0 ring. Theorem sum_inv_0_uniq : unique (fun x => sum_is_inv x 0) 0. Proof Ring.sum_inv_0_uniq ring. Definition sum_neg_strong : forall x : E, { y | sum_is_inv x y } := Ring.sum_neg_strong ring. Definition sum_neg : E -> E := Ring.sum_neg ring.Notation "{-}" := (sum_neg) : commutative_ring_scope.Notation "- x" := (sum_neg x) : commutative_ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Ring.sum_neg_def ring. Theorem sum_neg_inj : is_injective E E sum_neg. Proof Ring.sum_neg_inj ring. Theorem sum_cancel_neg : forall x : E, sum_neg (- x) = x. Proof Ring.sum_cancel_neg ring. Theorem sum_neg_onto : is_onto E E sum_neg. Proof Ring.sum_neg_onto ring. Theorem sum_neg_bijective : is_bijective E E sum_neg. Proof Ring.sum_neg_bijective ring. Theorem sum_neg_rev : forall x y : E, - x = y -> - y = x. Proof Ring.sum_neg_rev ring. Theorem sum_neg_distrib_inv_l : forall x y : E, sum_is_inv_l (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_l ring. Theorem sum_neg_distrib_inv_r : forall x y : E, sum_is_inv_r (x + y) (- y + - x). Proof Ring.sum_neg_distrib_inv_r ring. Theorem sum_neg_distrib_inv : forall x y : E, sum_is_inv (x + y) (- y + - x). 
F tree ilist frees ms sm * [[ length ilist = ((INODE.IRecSig.RALen (FSXPInode fsxp)) * INODE.IRecSig.items_per_val)%nat ]])%pred. Proof. unfold rep; intros. norml; unfold stars; simpl. rewrite BFILE.rep_length_pimpl at 1. cancel. Qed. Theorem dirtree_update_free : forall tree fsxp F F0 ilist freeblocks ms sm v bn m flag, (F0 * rep fsxp F tree ilist freeblocks ms sm)%pred (list2nmem m) -> BFILE.block_is_unused (BFILE.pick_balloc freeblocks flag) bn -> (F0 * rep fsxp F tree ilist freeblocks ms sm)%pred (list2nmem (updN m bn v)). Proof. intros. unfold rep in *. destruct_lift H. eapply pimpl_apply; [ | eapply BFILE.rep_safe_unused; eauto; pred_apply; cancel ]. cancel. Qed. Theorem dirtree_rep_used_block_eq : forall pathname F0 tree fsxp F ilist freeblocks ms inum off bn m sm f, (F0 * rep fsxp F tree ilist freeblocks ms sm)%pred (list2nmem m) -> find_subtree pathname tree = Some (TreeFile inum f) -> BFILE.block_belong_to_file ilist bn inum off -> selN (DFData f) off ($0, nil) = selN m bn ($0, nil). Proof. intros. unfold rep in *. destruct_lift H. erewrite <- BFILE.rep_used_block_eq with (m := m). 2: pred_apply; cancel. 2: eauto. f_equal. f_equal. rewrite subtree_extract in * by eassumption. simpl in *. apply eq_sym. eapply BFILE.rep_used_block_eq_Some_helper. destruct_lifts. assert (inum < Datatypes.length dummy) as Hlt by ( eapply list2nmem_inbound; pred_apply; cancel ). pose proof (list2nmem_sel_inb dummy BFILE.bfile0 Hlt) as Hx. eapply pimpl_trans in H2; [ | apply pimpl_refl | ]. eapply ptsto_valid in H2. rewrite Hx in H2; clear Hx. 2: cancel. inversion H2; clear H2. rewrite H4; simpl. auto. Qed. Lemma tree_pred_ino_goodSize : forall F Fm xp tree m d frees prd allocc, (Fm * (IAlloc.rep BFILE.freepred xp frees prd allocc))%pred m -> (F * tree_pred xp tree)%pred d -> goodSize addrlen (dirtree_inum tree). Proof. induction tree using dirtree_ind2; simpl; intros. destruct_lift H0. eapply IAlloc.ino_valid_goodSize; eauto. unfold tree_dir_names_pred in H1; destruct_lift H1. eapply IAlloc.ino_valid_goodSize; eauto. Qed. Lemma find_subtree_inum_valid : forall F F' xp m s tree inum f, find_subtree s tree = Some (TreeFile inum f) -> (F * tree_pred xp tree * F')%pred m -> IAlloc.ino_valid xp inum. Proof. unfold rep; intros. destruct_lift H0. rewrite subtree_extract in H0 by eauto. simpl in H0; destruct_lift H0; auto. Qed. Theorem mscs_same_except_log_rep' : forall mscs1 mscs2 fsxp F tree ilist frees sm, BFILE.mscs_same_except_log mscs1 mscs2 -> rep fsxp F tree ilist frees mscs1 sm =p=> rep fsxp F tree ilist frees mscs2 sm. Proof. unfold BFILE.mscs_same_except_log; unfold rep; intros. intuition msalloc_eq. apply pimpl_refl. Qed. Theorem mscs_same_except_log_rep : forall mscs1 mscs2 fsxp F tree ilist frees sm, BFILE.mscs_same_except_log mscs1 mscs2 -> rep fsxp F tree ilist frees mscs1 sm <=p=> rep fsxp F tree ilist frees mscs2 sm. 
(swap_pair p) = snd p. Admitted. Inductive natlist : Type := | nil : natlist | cons : nat -> natlist -> natlist.Instance dec_natlist (p q : natlist) : Dec (p = q). Proof. constructor; unfold decidable; repeat decide equality. Defined. Derive Arbitrary for natlist. Derive Show for natlist. Derive Sized for natlist. Derive CanonicalSized for natlist. Derive SizeMonotonic for natlist using genSnatlist. Derive SizedMonotonic for natlist. Derive SizedCorrect for natlist using genSnatlist and SizeMonotonicnatlist.Notation "x :: l" := (cons x l) (at level 60, right associativity). Notation "[ ]" := nil. Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).Fixpoint repeat (n count : nat) : natlist := match count with | O => nil | S count' => n :: (repeat n count') end.Fixpoint length (l:natlist) : nat := match l with | nil => O | h :: t => S (length t) end.Fixpoint app (l1 l2 : natlist) : natlist := match l1 with | nil => l2 | h :: t => h :: (app t l2) end.Notation "x ++ y" := (app x y) (right associativity, at level 60).Definition hd (default:nat) (l:natlist) : nat := match l with | nil => default | h :: t => h end.Definition tl (l:natlist) : natlist := match l with | nil => nil | h :: t => t end.Theorem nil_app : forall l:natlist, [] ++ l = l. Admitted. Theorem tl_length_pred : forall l:natlist, pred (length l) = length (tl l). Admitted. Theorem app_assoc : forall l1 l2 l3 : natlist, (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3). Admitted. Fixpoint rev (l:natlist) : natlist := match l with | nil => nil | h :: t => rev t ++ [h] end.Theorem app_length : forall l1 l2 : natlist, length (l1 ++ l2) = (length l1) + (length l2). Admitted. Theorem rev_length : forall l : natlist, length (rev l) = length l. Admitted. Theorem app_nil_r : forall l : natlist, l ++ [] = l. Admitted. Theorem rev_app_distr: forall l1 l2 : natlist, rev (l1 ++ l2) = rev l2 ++ rev l1. Admitted. Theorem rev_involutive : forall l : natlist, rev (rev l) = l. Admitted. Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist, l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4. Admitted. Theorem ble_n_Sn : forall n, leb n (S n) = true. 
alpha_Z_ml_eq : „Äö alpha_Z b (S m) „Äõ = expoZp (l-1) „Äö-1„Äõ ‚äó nat2Zp Hak2 l ‚äó„Äö alpha_Z b (S k) „Äõ ‚äó expoZp (l-1)„Äö alpha_Z b k „Äõ. Proof using Hl Hm. generalize A_m_morph22; intros H. unfold morph22, A, B in H. unfold M22scal, PL22, MZp_I in H. apply M22_proj12 in H. unfold plus in H; rewrite H; clear H. rewrite Zp_mult_comm, Zp_mult_zero, Zp_plus_zero. rewrite Z2Zp_one, Zp_mult_comm, Zp_mult_one; auto. Qed. End in_Zp. Add Ring myring2 : (Zp_is_ring Hak2). Corollary alpha_square_nat : exists q, Zp_invertible Hak2 q /\ nat2Zp Hak2 (alpha_nat b m) = q ‚äó nat2Zp Hak2 l ‚äó nat2Zp Hak2 (alpha_nat b k). Proof using Hl Hm. exists (expoZp (l-1) (Z2Zp Hak2 (-1)) ‚äó expoZp (l-1) (Z2Zp Hak2 (alpha_Z b k))); split. + apply Zp_mult_invertible; apply Zp_expo_invertible. * apply Zp_opp_invertible. rewrite <- Z2Zp_opp. replace (- (-1))%Z with 1%Z by lia. rewrite Z2Zp_one. apply Zp_one_invertible. * destruct k; try lia; simpl. rewrite Z2Zp_of_nat. apply nat2Zp_invertible. unfold ak2. apply is_gcd_sym, is_rel_prime_mult; apply is_gcd_sym, alpha_nat_coprime; auto. + generalize alpha_Z_ml_eq; intros H. unfold alpha_Z in H at 1 2. do 2 rewrite Z2Zp_of_nat in H. rewrite H; ring. Qed. End equation. Theorem alpha_nat_divides_2_pos m : alpha_nat b k * alpha_nat b k ‚îÇ alpha_nat b m <-> k*alpha_nat b k ‚îÇ m. Proof using Hak. destruct m as [ | m ]. + simpl; split; intros; apply divides_0. + destruct (divides_dec (S m) k) as [ (l & Hl) | C ]. * apply Zp_alpha_congruence_2 with (1 := Hl) (H2 := Hak2); try lia. apply alpha_square_nat; auto. intro; subst; discriminate. * split; intros H; exfalso; apply C. - rewrite <- alpha_nat_divisibility_1 with (1 := Hb). apply divides_trans with (2 := H), divides_mult, divides_refl. - apply divides_trans with (2 := H). rewrite mult_comm. apply divides_mult, divides_refl. Qed.End divisibility_2.Theorem alpha_nat_divisibility_2 b k m : 2 <= b -> alpha_nat b k * alpha_nat b k ‚îÇ alpha_nat b m <-> k*alpha_nat b k ‚îÇ m. Proof. intros Hb. destruct k as [ | k ]. * simpl. destruct m as [ | m ]; try (simpl; tauto). split; intros H; apply divides_0_inv in H; try discriminate. contradict H; apply alpha_nat_gt_0; lia. * apply alpha_nat_divides_2_pos; lia. Qed.Section congruence_1. Variable (b1 b2 : nat) (Hb1 : 2 <= b1) (Hb2 : 2 <= b2) (q : nat) (Hq : q <> 0) (Hb : nat2Zp Hq b1 = nat2Zp Hq b2). Hint Resolve Zle_0_nat : core. Theorem alpha_Z_congr n : Z2Zp Hq (alpha_Z b1 n) = Z2Zp Hq (alpha_Z b2 n). 
q, Node110 l y => Node111 l y (set0 q x) | xI q, Node111 l y r => Node111 l y (set' q x r) end. Definition set {A} (p: positive) (x: A) (m: tree A) : tree A := match m with | Empty => Nodes (set0 p x) | Nodes m' => Nodes (set' p x m') end. Fixpoint rem' {A} (p: positive) (m: tree' A) : tree A := match p, m with | xH, Node001 r => Nodes m | xH, Node010 _ => Empty | xH, Node011 _ r => Nodes (Node001 r) | xH, Node100 l => Nodes m | xH, Node101 l r => Nodes m | xH, Node110 l _ => Nodes (Node100 l) | xH, Node111 l _ r => Nodes (Node101 l r) | xO q, Node001 r => Nodes m | xO q, Node010 y => Nodes m | xO q, Node011 y r => Nodes m | xO q, Node100 l => Node (rem' q l) None Empty | xO q, Node101 l r => Node (rem' q l) None (Nodes r) | xO q, Node110 l y => Node (rem' q l) (Some y) Empty | xO q, Node111 l y r => Node (rem' q l) (Some y) (Nodes r) | xI q, Node001 r => Node Empty None (rem' q r) | xI q, Node010 y => Nodes m | xI q, Node011 y r => Node Empty (Some y) (rem' q r) | xI q, Node100 l => Nodes m | xI q, Node101 l r => Node (Nodes l) None (rem' q r) | xI q, Node110 l y => Nodes m | xI q, Node111 l y r => Node (Nodes l) (Some y) (rem' q r) end. Definition remove' := Eval cbv [rem' Node] in @rem'. Definition remove {A} (p: positive) (m: tree A) : tree A := match m with | Empty => Empty | Nodes m' => remove' p m' end. Theorem gempty: forall (A: Type) (i: positive), get i (empty A) = None. Proof. reflexivity. Qed. Lemma gss0: forall {A} p (x: A), get' p (set0 p x) = Some x. Proof. induction p; simpl; auto. Qed. Lemma gso0: forall {A} p q (x: A), p<>q -> get' p (set0 q x) = None. Proof. induction p; destruct q; simpl; intros; auto; try apply IHp; congruence. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: tree A), get i (set i x m) = Some x. 
1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_sum_distrib : is_distrib E prod sum. Proof conj prod_sum_distrib_l prod_sum_distrib_r. Theorem prod_0_l : forall x : E, 0 # x = 0. Proof fun x => let H : (0 # x) + (0 # x) = (0 # x) + 0 := eq_refl (0 # x) || a # x = 0 # x @a by (sum_id_l 0) || a = 0 # x @a by <- prod_sum_distrib_r x 0 0 || (0 # x) + (0 # x) = a @a by sum_id_r (0 # x) in sum_cancel_l (0 # x) 0 (0 # x) H. Theorem prod_0_r : forall x : E, x # 0 = 0. Proof fun x => let H : (x # 0) + (x # 0) = 0 + (x # 0) := eq_refl (x # 0) || x # a = x # 0 @a by sum_id_r 0 || a = x # 0 @a by <- prod_sum_distrib_l x 0 0 || (x # 0) + (x # 0) = a @a by sum_id_l (x # 0) in sum_cancel_r (x # 0) 0 (x # 0) H. Theorem prod_0_inv_l : ~ prod_has_inv_l 0. Proof ex_ind (fun x (H : x # 0 = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_r x)). Theorem prod_0_inv_r : ~ prod_has_inv_r 0. Proof ex_ind (fun x (H : 0 # x = 1) => distinct_0_1 (H || a = 1 @a by <- prod_0_l x)). Theorem prod_0_inv : ~ prod_has_inv 0. Proof ex_ind (fun x H => prod_0_inv_l (ex_intro (fun x => prod_is_inv_l 0 x) x (proj1 H))). Theorem prod_inv_0 : forall x y : E, prod_is_inv x y -> nonzero y. Proof fun x y H (H0 : y = 0) => distinct_0_1 (proj1 H || a # x = 1 @a by <- H0 || a = 1 @a by <- prod_0_l x). Definition E_n1_strong : { x : E | sum_is_inv 1 x } := constructive_definite_description (sum_is_inv 1) (sum_inv_uniq_ex 1). Definition E_n1 : E := proj1_sig E_n1_strong. Notation "{-1}" := E_n1 : ring_scope. Theorem E_n1_def : sum_is_inv 1 {-1}. Proof proj2_sig E_n1_strong. Theorem E_n1_inv_l : sum_is_inv_l 1 {-1}. Proof proj1 E_n1_def. Theorem E_n1_inv_r : sum_is_inv_r 1 {-1}. Proof proj2 E_n1_def. Theorem E_n1_uniq : forall x : E, sum_is_inv 1 x -> x = {-1}. Proof fun x => sum_inv_uniq 1 {-1} x E_n1_def. Theorem prod_n1_x_inv_l : forall x : E, sum_is_inv_l x ({-1} # x). 
x hs' => cons x (hlist_erase hs') end.Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls. Proof. induction ls; simpl; intros; f_equal; auto. Qed. Section hlist_Forall. Variable A : Type. Variable P : A -> Prop. Fixpoint hlist_Forall ls (hs : hlist P ls) : Forall P ls := match hs with | Hnil => Forall_nil _ | Hcons _ _ H hs' => Forall_cons _ H (hlist_Forall hs') end.End hlist_Forall.Section hlist_rel. Variable A : Type. Variables F G : A -> Type. Variable R : forall x : A, F x -> G x -> Prop. Inductive hlist_hrel : forall ls, hlist F ls -> hlist G ls -> Prop := | hrel_Hnil : hlist_hrel Hnil Hnil | hrel_Hcons : forall t ts x y xs ys, @R t x y -> @hlist_hrel ts xs ys -> @hlist_hrel (t :: ts) (Hcons x xs) (Hcons y ys).End hlist_rel.Section hlist_rel_map. Variable A : Type. Variables F G F' G' : A -> Type. Variable R : forall x : A, F x -> G x -> Prop. Variable R' : forall x : A, F' x -> G' x -> Prop. Variable ff : forall x : A, F x -> F' x. Variable gg : forall x : A, G x -> G' x. Hypothesis R_ff_R' : forall t x y, @R t x y -> @R' t (ff x) (gg y). Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys). Proof. induction 1; simpl; constructor; eauto. Qed. Theorem hlist_hrel_cons : forall l ls x xs y ys, @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) -> @R l x y /\ @hlist_hrel A F G R ls xs ys. Proof. intros. refine match H in @hlist_hrel _ _ _ _ ls' xs' ys' return match ls' as ls' return hlist F ls' -> hlist G ls' -> Prop with | nil => fun _ _ => True | l' :: ls' => fun x y => R (hlist_hd x) (hlist_hd y) /\ hlist_hrel R (hlist_tl x) (hlist_tl y) end xs' ys' with | hrel_Hnil => I | hrel_Hcons _ _ _ _ _ _ pf pf' => conj pf pf' end. Qed. Theorem hlist_hrel_app : forall l ls x xs y ys, @hlist_hrel A F G R (l ++ ls) (hlist_app x xs) (hlist_app y ys) -> @hlist_hrel A F G R l x y /\ @hlist_hrel A F G R ls xs ys. 
arith. Qed. Hint Resolve convert_not_O: zarith arith. Hint Resolve Zlt_le_weak Zle_not_gt Zgt_irrefl Zlt_irrefl Zle_not_lt Zlt_not_le Zlt_asym inj_lt inj_le: zarith. Theorem inj_abs : forall x : Z, (0 <= x)%Z -> Z_of_nat (Zabs_nat x) = x. intros x; elim x; auto. unfold Zabs_nat in |- *. intros p. pattern p at 1 3 in |- *; rewrite <- (pred_o_P_of_succ_nat_o_nat_of_P_eq_id p). generalize (convert_not_O p); case (nat_of_P p); simpl in |- *; auto with arith. intros H'; case H'; auto. intros n H' H'0; rewrite Ppred_succ; auto. intros p H'; Contradict H'; auto. Qed. Theorem inject_nat_convert : forall (p : Z) (q : positive), p = Zpos q -> Z_of_nat (nat_of_P q) = p. intros p q H'; rewrite H'. CaseEq (nat_of_P q); simpl in |- *. elim q; unfold nat_of_P in |- *; simpl in |- *; intros; try discriminate. absurd (0%Z = Zpos p0); auto. red in |- *; intros H'0; try discriminate. apply H; auto. change (nat_of_P p0 = 0) in |- *. generalize H0; rewrite ZL6; case (nat_of_P p0); simpl in |- *; auto; intros; try discriminate. intros n; rewrite <- nat_of_P_o_P_of_succ_nat_eq_succ. intros H'0; apply f_equal with (f := Zpos). apply nat_of_P_inj; auto. Qed. Hint Resolve inj_le inj_lt: zarith. Theorem ZleLe : forall x y : nat, (Z_of_nat x <= Z_of_nat y)%Z -> x <= y. intros x y H'. case (le_or_lt x y); auto with arith. intros H'0; Contradict H'; auto with zarith. Qed. Theorem inject_nat_eq : forall x y : nat, Z_of_nat x = Z_of_nat y -> x = y. intros x y H'; apply le_antisym. apply ZleLe; auto. idtac; rewrite H'; auto with zarith. apply ZleLe; auto. idtac; rewrite H'; auto with zarith. Qed. Theorem Zcompare_EGAL : forall p q : Z, (p ?= q)%Z = Datatypes.Eq -> p = q. intros p q; case p; case q; simpl in |- *; auto with arith; try (intros; discriminate); intros q1 p1. intros H1; rewrite (Pcompare_Eq_eq p1 q1); auto. unfold Pos.compare. generalize (Pcompare_Eq_eq p1 q1); case (Pcompare p1 q1 Datatypes.Eq); simpl in |- *; intros H H1; try discriminate; rewrite H; auto. Qed. Theorem Zlt_Zopp : forall x y : Z, (x < y)%Z -> (- y < - x)%Z. intros x y; case x; case y; simpl in |- *; auto with zarith; intros p p0; unfold Zlt in |- *; simpl in |- *; unfold Pos.compare; rewrite <- ZC4; auto. Qed. Hint Resolve Zlt_Zopp: zarith. Theorem Zle_Zopp : forall x y : Z, (x <= y)%Z -> (- y <= - x)%Z. 
l1 + (size l2 + size l3) end. Definition lessP3 (m1 m2 : list (Term A n) * (list (Term A n) * list (Term A n))) := sizel3 m1 < sizel3 m2. Lemma wf_lessP3 : well_founded lessP3. red in |- *. cut (forall (m : nat) a, sizel3 a < m -> Acc lessP3 a). intros H' a. apply H' with (m := S (sizel3 a)); auto. intros m; elim m; clear m. intros a H; inversion H. intros p H' a H'0; apply Acc_intro. intros y H'1; apply H'. unfold lessP in H'1; apply lt_le_trans with (sizel3 a); auto with arith. Qed. Hint Resolve wf_lessP3. Set Implicit Arguments. Unset Strict Implicit. Definition eqPf : forall pq, {eqP (fst pq) (snd pq)} + {~ eqP (fst pq) (snd pq)}. intros pq; pattern pq in |- *; apply well_founded_induction with (R := lessP) (1 := wf_lessP); clear pq. intros pq; case pq; simpl in |- *; clear pq. intros p; case p; clear p. intros q; case q; clear q. intros H'; left; constructor. intros b q H'; right; red in |- *; intros H'0; inversion H'0. intros a p q; case q; clear q. intros H'; right; red in |- *; intros H'0; inversion H'0. intros b q Rec; case (eqTerm_dec _ _ eqA_dec n a b); simpl in Rec; intros eqTerm0. case (Rec (p, q)); unfold lessP in |- *; simpl in |- *; auto with arith. intros H'; left; auto. change (eqP (pX a p) (pX b q)) in |- *; auto. intros H'; right; red in |- *; intros H'0. apply H'. apply eqp_inv3r with (a := a) (b := b); auto. right; red in |- *; intros H'. apply eqTerm0. apply eqp_eqTerm with (p := p) (q := q); auto. Defined. Definition seqP : poly A0 eqA ltM -> poly A0 eqA ltM -> Prop. intros sp1 sp2; case sp1; case sp2. intros p1 H'1 p2 H'2; exact (eqP p1 p2). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem seqp_dec : forall p q : poly A0 eqA ltM, {seqP p q} + {~ seqP p q}. intros p q; case p; case q; simpl in |- *. intros x H' x0 H'0. apply (eqPf (x, x0)). Qed. Theorem seqp_refl : reflexive (poly A0 eqA ltM) seqP. red in |- *. intros p; case p; simpl in |- *. intros x H'. apply eqp_refl. Qed. Theorem seqp_sym : symmetric (poly A0 eqA ltM) seqP. 
l1)) -> b = F x a)) in H0. eauto. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. intuition. simpl in *. intuition. trivial. assert (b0 = F x l). eapply H6. trivial. eapply H6 in H5. subst. rewrite H7. rewrite eqbBvector_complete. trivial. comp_simp. rewrite eqb_refl. simpl. eapply comp_spec_eq_refl. Qed. Theorem G2_3_4_close : | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <= Adv_WCR _ _ F (Rnd k) au_F_A. eapply leRat_trans. eapply fundamental_lemma_h. eapply G2_3_4_bad_eq . eapply G2_3_4_eq_until_bad. rewrite G2_3_bad_equiv. rewrite G2_3_bad_small. intuition. Qed. Definition G2_5 := [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil; ret b. Theorem G2_4_5_equiv : Pr[x <-$ G2_4; ret fst x] == Pr[G2_5]. unfold G2_4, G2_5. inline_first. comp_irr_l. wftac. inline_first. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a (z, (F x z)) = arrayLookup _ b z)). intuition. intuition. unfold randomFunc_mem. rewrite H0. case_eq ( arrayLookup (list_EqDec (Bvector_EqDec b)) x2 a); intuition. eapply comp_spec_ret; intuition. simpl in *. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H3. subst. rewrite eqbBvector_complete. trivial. simpl. eauto. comp_skip. apply (oneVector c). apply (oneVector c). eapply comp_spec_ret; intuition. simpl. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H5. subst. rewrite eqbBvector_complete. trivial. simpl. trivial. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G2_5_equiv : Pr[G2_5] == Pr[G2]. unfold G2_5, G2. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a z = arrayLookup _ b z)). intuition. intuition. eapply randomFunc_mem_spec. intuition. simpl in *. intuition. subst. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_equiv : | Pr[G1] - Pr[G2] | <= Adv_WCR _ _ F (Rnd k) au_F_A. rewrite G2_1_equiv. rewrite G2_1_2_equiv. rewrite G2_2_3_equiv. rewrite <- G2_5_equiv. rewrite <- G2_4_5_equiv. eapply G2_3_4_close. Qed. Theorem G2_equiv : Pr[G2] == Pr[PRF_G_B ({0, 1}^c) _ _ A]. reflexivity. Qed. Theorem hF_PRF : PRF_Advantage ({0, 1}^(c + k)) ({0, 1}^c) hF _ _ A <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A + Adv_WCR _ _ F (Rnd k) au_F_A. 
//=. rewrite -H. eauto. } } repeat econstructor. ** simpl in * => //=. rewrite /state_init_heap/state_insert_list. rewrite /RecordSet.set //=. rewrite /state_match_curr//=. split_and!; eauto. apply match_curr_insert_hd; split; eauto. ** eauto. ** rewrite //=. intros Hsynced. split; last first. { right. eauto. } apply all_synced_insert_synced; auto. * rewrite /head_step//= in Hstep. destruct_head. inversion Hstep; monad_inv. destruct_head. inversion H; monad_inv; clear H. do 4 eexists; split_and!; eauto. econstructor; eauto; repeat (econstructor; eauto). do 2 f_equal. symmetry. erewrite state_match_curr_disk_size; eauto. * rewrite /head_step//= in Hstep. destruct_head. inversion Hstep; monad_inv. destruct_head. inversion H; monad_inv; clear H. destruct (decide (ADP.all_synced _)). ** monad_inv. destruct (decide (ADP.all_synced (world pœÉ1'))). *** do 4 eexists. split_and!. { repeat econstructor. rewrite decide_True //=. } { eauto. } { eauto. } intros; split; eauto. *** do 4 eexists. split_and!. { repeat econstructor. rewrite decide_False //=. } { eauto. } { eauto. } intros; intuition. ** monad_inv. destruct (decide (ADP.all_synced (world pœÉ1'))). *** do 4 eexists. split_and!. { repeat econstructor. rewrite decide_True //=. } { eauto. } { eauto. } intros; split; eauto. *** do 4 eexists. split_and!. { repeat econstructor. rewrite decide_False //=. } { eauto. } { eauto. } intros; intuition. - rewrite /head_step//= in Hstep. monad_inv; destruct_head. inversion H; monad_inv; clear H. inversion H0; monad_inv; clear H0. inversion H2; monad_inv; clear H2. eexists _, _, {| used_proph_id := _ |}, _. inversion Hmatch_curr. intuition. ** repeat (econstructor; eauto). rewrite H4. rewrite /RecordSet.set/= H13. done. ** split_and!; eauto. ** rewrite //=. - rewrite /head_step//= in Hstep. monad_inv; destruct_head. do 4 eexists. inversion Hmatch_curr. intuition. + repeat (econstructor; eauto). + split_and!; eauto. + done. Qed. Theorem prim_step'_compat_simulation e1 pœÉ1 pg1 pœÉ1' pg1' pœÉ2 pg2 Œ∫ e2 efs : prim_step' e1 pœÉ1 pg1 Œ∫ e2 pœÉ2 pg2 efs ‚Üí state_match_curr pœÉ1 pœÉ1' ‚Üí pg1 = pg1' ‚Üí (‚àÉ e2' pœÉ2' pg2' efs', prim_step' e1 pœÉ1' pg1' Œ∫ e2' pœÉ2' pg2' efs' ‚àß state_match_curr pœÉ2 pœÉ2' ‚àß pg2 = pg2' ‚àß (ADP.all_synced (world pœÉ1') ‚Üí ADP.all_synced (world pœÉ2') ‚àß ((e2 = e1 ‚àß efs = [] ‚àß pœÉ2 = pœÉ1 ‚àß pg2 = pg1) ‚à® (e2 = e2' ‚àß efs = efs')))). Proof. intros Hprim Hc <-. inversion Hprim; subst. intros. edestruct (head_step_compat_simulation) as (e2_s'&pœÉ2'&pg2'&efs'&Hstep'&Hcurr&Hg&Hifsynced); eauto. do 4 eexists; split_and!. { econstructor; eauto. } { eauto. } { eauto. } intros Hsynced. apply Hifsynced in Hsynced as (?&Hcases). split; auto. destruct Hcases as [Hcases1|Hcases2]. - left. intuition congruence. - right. intuition congruence. Qed. Theorem prim_step'_compat_rtc_simulation e1 pœÉ1 pg1 (pœÉ1' : pstate) pg1' pœÉ2 pg2 œÉ1 g1 e2 : ADP.all_synced (world pœÉ1') ‚Üí rtc (Œª '(e, (s, g)) '(e', (s', g')), prim_step' e s g [] e' s' g' []) (e1, (pœÉ1, pg1)) (e2, (pœÉ2, pg2)) ‚Üí state_compat œÉ1 pœÉ1 ‚Üí global_compat g1 pg1 ‚Üí state_compat œÉ1 pœÉ1' ‚Üí global_compat g1 pg1' ‚Üí ‚àÉ pœÉ2' pg2', rtc (Œª '(e, (s, g)) '(e', (s', g')), prim_step' e s g [] e' s' g' []) (e1, (pœÉ1', pg1')) (e2, (pœÉ2', pg2')) ‚àß (‚àÄ œÉ2, state_compat œÉ2 pœÉ2 ‚Üí state_compat œÉ2 pœÉ2') ‚àß (‚àÄ g2, global_compat g2 pg2 ‚Üí global_compat g2 pg2'). 
assert (efg : ‚àè xy : X ‚®ø Y, (f (g xy)) = xy). intro. induction xy as [ x | y ]. apply idpath. apply (fromempty (nf y)). apply (isweq_iso f g egf efg). Defined.Definition weqii1withneg (X : UU) {Y : UU} (nf : ¬¨ Y) := make_weq _ (isweqii1withneg X nf).Theorem isweqii2withneg {X : UU} (Y : UU) (nf : X -> empty) : isweq (@ii2 X Y). Proof. intros. set (f:= @ii2 X Y). set (g:= Œª xy : X ‚®ø Y, match xy with | ii1 x => fromempty (nf x) | ii2 y => y end). assert (egf : ‚àè y : Y, (g (f y)) = y). intro. apply idpath. assert (efg : ‚àè xy : X ‚®ø Y, (f (g xy)) = xy). intro. induction xy as [ x | y ]. apply (fromempty (nf x)). apply idpath. apply (isweq_iso f g egf efg). Defined.Definition weqii2withneg {X : UU} (Y : UU) (nf : ¬¨ X) := make_weq _ (isweqii2withneg Y nf).Definition coprodf {X Y X' Y' : UU} (f : X -> X') (g : Y-> Y') : X ‚®ø Y -> X' ‚®ø Y' := Œª xy: X ‚®ø Y, match xy with | ii1 x => ii1 (f x) | ii2 y => ii2 (g y) end.Definition coprodf1 {X Y X' : UU} : (X -> X') -> X ‚®ø Y -> X' ‚®ø Y. Proof. intros f. exact (coprodf f (idfun Y)). Defined.Definition coprodf2 {X Y Y' : UU} : (Y -> Y') -> X ‚®ø Y -> X ‚®ø Y'. Proof. intros g. exact (coprodf (idfun X) g). Defined.Definition homotcoprodfcomp {X X' Y Y' Z Z' : UU} (f : X -> Y) (f' : X' -> Y') (g : Y -> Z) (g' : Y' -> Z') : homot (funcomp (coprodf f f') (coprodf g g')) (coprodf (funcomp f g) (funcomp f' g')). Proof. intros. intro xx'. induction xx' as [ x | x' ]. apply idpath. apply idpath. Defined. Definition homotcoprodfhomot {X X' Y Y' : UU} (f g : X -> Y) (f' g' : X' -> Y') (h : homot f g) (h' : homot f' g') : homot (coprodf f f') (coprodf g g') := Œª xx' : _, match xx' with | ii1 x => maponpaths (@ii1 _ _) (h x) | ii2 x' => maponpaths (@ii2 _ _) (h' x') end. Theorem isweqcoprodf {X Y X' Y' : UU} (w : X ‚âÉ X') (w' : Y ‚âÉ Y') : isweq (coprodf w w'). 
destruct Hrt as [ret [Hst' [Hnoleak Hpost] ] ]. eapply make_map_related_make_heap_singleton in Hr. { destruct Hr as [Hh' [Hgs' Hdisj'] ]. exists ret. repeat try_split. - eauto. - eapply Hh'. - eauto. - eauto. } { instantiate (1 := ret). instantiate (1 := retvar). eauto. } { intros k Hnin. eauto. } { reflexivity. } { reflexivity. } { simpl. rewrite diff_same. rewrite diff_empty. reflexivity. } { eauto. } } { eapply submap_refl. } { eauto. } { eapply dfacade_safe; eauto. reflexivity. } Qed. Import Made. Definition output_module := bimport [[ (module_name!fun_name, spec_op_b) ]] bmodule export_module_name {{ bfunction fun_name(argvar1, argvar2, "R") [compileS pre_cond post_cond] "R" <-- Call module_name!fun_name(extra_stack, argvar1, argvar2) [PRE[_, R] Emp POST[R'] [| R' = R |] ];; Return "R" end }}. Require Import Bedrock.Platform.AutoSep. Require Import Bedrock.Platform.Cito.GeneralTactics3. Opaque mult. Import LinkMake.StubsMake.StubMake.LinkSpecMake2.CompileFuncSpecMake.InvMake. Require Import Bedrock.sep.Locals. Theorem is_state_in2 : forall vs sp args e_stack h F, locals ("rp" :: "extra_stack" :: args) vs e_stack sp * is_heap h * mallocHeap 0 * F ===> is_state sp (Locals.sel vs "rp") (wordToNat (Locals.sel vs "extra_stack")) e_stack args (vs, h) nil * mallocHeap 0 * F. intros; sepLemma. etransitivity; [ | apply is_state_in'' ]; auto. sepLemma. Qed. Theorem is_state_out'' sp rp args pairs vs e_stack e_stack' h : NoDup args -> ~List.In "rp" args -> ~List.In "extra_stack" args -> length args = length pairs -> is_state sp rp e_stack e_stack' nil (vs, h) (List.map fst pairs) ===> Ex vs', locals ("rp" :: "extra_stack" :: args) vs' e_stack' sp * is_heap h * [| sel vs' "extra_stack" = e_stack |] * [| saved_vars vs' args pairs |]. unfold is_state, locals, Inv.has_extra_stack; simpl. intros. apply Himp_ex_c. exists (upd (upd (zip_vals args pairs) "extra_stack" e_stack) "rp" rp). selify. replace (S (S (length args)) * 4)%nat with (8 + 4 * length args)%nat by omega. rewrite map_length. rewrite <- H2. rewrite natToWord_plus. eapply Himp_trans; [ | do 4 (apply Himp_star_frame; [ | apply Himp_refl ]); apply Himp_star_frame; [ apply Himp_refl | apply ptsto32m'_out ] ]. simpl. generalize (List.map fst pairs); intro. unfold array at 1; simpl. sepLemma. do 2 (apply saved_vars_irrel; auto). eauto using saved_vars_zip_vars. etransitivity; [ apply himp_star_comm | ]. apply himp_star_frame. etransitivity; [ | apply Arrays.ptsto32m'_in ]. etransitivity; [ | apply ptsto32m_shift_base ]. unfold array. instantiate (1 := 8). simpl. rewrite <- wplus_assoc. rewrite <- natToWord_plus. reflexivity. auto. rewrite <- wplus_assoc. rewrite <- natToWord_plus. unfold natToW. sepLemma. Qed. Require Import Coq.Arith.Mult. Require Import Bedrock.Platform.Cito.WordFacts. Theorem is_state_out''' sp rp args pairs vs h e_stack e_stack' : NoDup args -> ~List.In "rp" args -> ~List.In "extra_stack" args -> toArray args vs = List.map fst pairs -> is_state sp rp e_stack e_stack' args (vs, h) nil ===> Ex vs', locals ("rp" :: "extra_stack" :: args) vs' e_stack' sp * is_heap h * [| sel vs' "extra_stack" = e_stack |] * [| saved_vars vs' args pairs |]. 
Proof. intros x Fx Hx. rewrite pred_eq_pos;[idtac|now left]. rewrite succ_eq_pos. 2: now apply pred_pos_ge_0. now apply pred_pos_plus_ulp. Qed.Theorem pred_ulp_0 : pred (ulp 0) = 0%R. Proof. rewrite pred_eq_pos. 2: apply ulp_ge_0. unfold ulp; rewrite Req_bool_true; trivial. case negligible_exp_spec'.intros [H1 _]; rewrite H1. unfold pred_pos; rewrite Req_bool_false. 2: apply Rlt_not_eq, bpow_gt_0. unfold ulp; rewrite Req_bool_true; trivial. rewrite H1; ring.intros (n,(H1,H2)); rewrite H1. unfold pred_pos. rewrite ln_beta_bpow. replace (fexp n + 1 - 1)%Z with (fexp n) by ring. rewrite Req_bool_true; trivial. apply Rminus_diag_eq, f_equal. apply sym_eq, valid_exp; omega. Qed.Theorem succ_0 : succ 0 = ulp 0. Proof. unfold succ. rewrite Rle_bool_true. apply Rplus_0_l. apply Rle_refl. Qed.Theorem pred_0 : pred 0 = Ropp (ulp 0). Proof. rewrite <- succ_0. rewrite <- Ropp_0 at 1. apply pred_opp. Qed.Theorem pred_succ_aux : forall x, F x -> (0 < x)%R -> pred (succ x) = x. Proof. intros x Fx Hx. apply Rle_antisym. - apply Rnot_lt_le. intros H. apply succ_le_lt with (1 := Fx) in H. revert H. apply Rlt_not_le. apply pred_lt_id. apply Rgt_not_eq. apply Rlt_le_trans with (1 := Hx). apply succ_ge_id. now apply generic_format_pred, generic_format_succ. - apply le_pred_lt with (1 := Fx). now apply generic_format_succ. apply succ_gt_id. now apply Rgt_not_eq. Qed.Theorem succ_pred : forall x, F x -> succ (pred x) = x. Proof. intros x Fx. destruct (Rle_or_lt 0 x) as [[Hx|Hx]|Hx]. now apply succ_pred_aux. rewrite <- Hx. rewrite pred_0, succ_opp, pred_ulp_0. apply Ropp_0. rewrite pred_eq_opp_succ_opp, succ_opp. rewrite pred_succ_aux. apply Ropp_involutive. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem pred_succ : forall x, F x -> pred (succ x) = x. Proof. intros x Fx. rewrite <- (Ropp_involutive x). rewrite succ_opp, pred_opp. apply f_equal, succ_pred. now apply generic_format_opp. Qed.Theorem round_UP_pred_plus_eps : forall x, F x -> forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x) else (ulp (pred x)))%R -> round beta fexp Zceil (pred x + eps) = x. Proof. intros x Fx eps Heps. rewrite round_UP_plus_eps. now apply succ_pred. now apply generic_format_pred. unfold pred at 4. rewrite Ropp_involutive, pred_succ. rewrite ulp_opp. generalize Heps; case (Rle_bool_spec x 0); intros H1 H2. rewrite Rle_bool_false; trivial. case H1; intros H1'. apply Rlt_le_trans with (2:=H1). apply pred_lt_id. now apply Rlt_not_eq. rewrite H1'; unfold pred, succ. rewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l. rewrite <- Ropp_0; apply Ropp_lt_contravar. apply Rlt_le_trans with (1:=proj1 H2). apply Rle_trans with (1:=proj2 H2). rewrite Ropp_0, H1'. now right. rewrite Rle_bool_true; trivial. now apply pred_ge_0. now apply generic_format_opp. Qed. Theorem round_DN_minus_eps: forall x, F x -> forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x) else (ulp (pred x)))%R -> round beta fexp Zfloor (x - eps) = pred x. 
Require Export Fmin. Section FOdd. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition Even (z : Z) : Prop := exists z1 : _, z = (2 * z1)%Z. Definition Odd (z : Z) : Prop := exists z1 : _, z = (2 * z1 + 1)%Z. Theorem OddSEven : forall n : Z, Odd n -> Even (Zsucc n). 
From bedrock.lang.cpp.semantics Require Import genv. Definition GlobDecl_size_of (g : GlobDecl) : option N := match g with | Gstruct s => Some s.(s_size) | Gunion u => Some u.(u_size) | _ => None end. Definition GlobDecl_align_of (g : GlobDecl) : option N := match g with | Gstruct s => Some s.(s_alignment) | Gunion u => Some u.(u_alignment) | _ => None end. Variant Roption_leq {T} (R : T -> T -> Prop) : option T -> option T -> Prop := | Rleq_None {x} : Roption_leq R None x | Rleq_Some {x y} (_ : R x y) : Roption_leq R (Some x) (Some y). #[global] Instance proper_GlobDecl_size_of: Proper (GlobDecl_ler ==> Roption_leq eq) GlobDecl_size_of. Proof. rewrite /GlobDecl_size_of => x y Heq. repeat (case_match; try constructor); simplify_eq/= => //; apply require_eq_success in Heq; naive_solver. Qed. #[global] Instance proper_GlobDecl_align_of: Proper (GlobDecl_ler ==> Roption_leq eq) GlobDecl_align_of. Proof. rewrite /GlobDecl_align_of => x y Heq. repeat (case_match; try constructor); simplify_eq/= => //; apply require_eq_success in Heq; naive_solver. Qed.Fixpoint size_of (resolve : genv) (t : type) : option N := match t with | Tpointer _ => Some (pointer_size resolve) | Tref _ => None | Trv_ref _ => None | Tnum sz _ => Some (bytesN sz) | Tvoid => None | Tarray t n => N.mul n <$> size_of resolve t | Tnamed nm => glob_def resolve nm ‚â´= GlobDecl_size_of | Tfunction _ _ => None | Tbool => Some 1 | Tmember_pointer _ _ => None | Tqualified _ t => size_of resolve t | Tnullptr => Some (pointer_size resolve) | Tfloat sz => Some (bytesN sz) | Tarch sz _ => bytesN <$> sz end%N.#[global] Instance Proper_size_of : Proper (genv_leq ==> eq ==> Roption_leq eq) (@size_of). Proof. intros ?? Hle ? t ->; induction t; simpl; (try constructor) => //. all: try exact: pointer_size_proper. - by destruct IHt; constructor; subst. - move: Hle => [[ /(_ g) Hle _] _ _]. unfold glob_def. rewrite -tu_lookup_globals in Hle. destruct ((genv_tu x) !! g) as [g1| ]; last constructor. move: Hle => /(_ _ eq_refl). rewrite -tu_lookup_globals. move => [g2 [-> HH]] /=. exact: proper_GlobDecl_size_of. - by destruct o; constructor. Qed. Theorem size_of_int : forall {c : genv} s w, @size_of c (Tnum w s) = Some (bytesN w). Proof. reflexivity. Qed. Theorem size_of_char : forall {c : genv} s w, @size_of c (Tchar w s) = Some (bytesN w). Proof. reflexivity. Qed. Theorem size_of_bool : forall {c : genv}, @size_of c Tbool = Some 1%N. 
x. Proof Group.op_inv_sym op_group. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. Proof Group.op_inv_ex op_group. Theorem op_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof Group.op_neg_def op_group. Theorem op_neg_inj : is_injective E E op_neg. Proof Group.op_neg_inj op_group. Theorem op_cancel_neg : forall x : E, op_neg (- x) = x. Proof Group.op_cancel_neg op_group. Theorem op_neg_onto : is_onto E E op_neg. Proof Group.op_neg_onto op_group. Theorem op_neg_bijective : is_bijective E E op_neg. Proof Group.op_neg_bijective op_group. Theorem op_neg_rev : forall x y : E, - x = y -> - y = x. Proof Group.op_neg_rev op_group. Theorem op_neg_distrib_inv_l : forall x y : E, op_is_inv_l (x + y) (- y + - x). 
Require Export Theory. Set Implicit Arguments. Section RelaxedExpansion. Variables A X Y: Type. Variable TX: reduction_t A X. Variable TY: reduction_t A Y. Variable B: relation X. Hypothesis HB: wexpansion1 TX TX B. Let wexpansion1_ctrl_t: forall R, evolve_t TX TY R (comp (star B) R) -> simulation_t TX TY (comp (star B) R). Proof. intros R HR x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ]. cgen Hxx'; cgen x'; induction xRw as [ x | z x w xRz zRw IH ]; intros x' Hxx'. apply (HR _ _ _ Hxx' wRy). destruct (HB Hxx' xRz) as [ z' Hzz' x'Rz' ]. celim Hzz'; intro Hzz'. destruct Hzz'; exists y; auto; exists w; auto; apply star_trans with z; auto. destruct (IH wRy _ Hzz') as [ y' Hyy' z'Ry' ] ; destruct z'Ry' as [ w' ]. exists y'; auto; exists w'; auto; apply S_star with z'; auto. Qed. Theorem wexpansion1_ctrl: wexpansion1 TX TX B -> controlled TX TY B. 
Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, Q b -> prop a b)} : Checkable (forall a b, P a /\ Q b -> prop a b) := {| checker f := checker (fun a P b Q => f a b _ ) |}. Proof. split; auto. Defined.Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Admitted. Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Admitted. Instance testSuchThat_Disj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, prop a b)} `{Checkable (forall b, Q b -> forall a, prop a b)} : Checkable (forall a b, P a \/ Q b -> prop a b) := {| checker f := disjoin (Datatypes.cons (checker (fun a P b => f a b _ )) (Datatypes.cons (checker (fun b Q a => f a b _)) Datatypes.nil)) |}. Proof. - left; auto. - right; auto. Defined. Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Admitted. Lemma or_intro : forall A B : Prop, A -> A \/ B. Admitted. Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Admitted. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Admitted. Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Admitted. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Admitted. Theorem contradiction_implies_anything : forall P Q : Prop, (P /\ ~P) -> Q. Admitted. Theorem contrapositive : forall (P Q : Prop), (P -> Q) -> (~Q -> ~P). Admitted. Theorem not_both_true_and_false : forall P : Prop, ~ (P /\ ~P). Admitted. Theorem not_true_is_false : forall b : bool, b <> true -> b = false. 
: Type := exS_intro : forall X : Set, P X -> ex_Set P. Module Type Version1.Inductive comes_from_the_left (P Q:Prop): P \/ Q -> Prop := c1 : forall p, comes_from_the_left P Q (or_introl (A:=P) Q p).Goal (comes_from_the_left _ _ (or_introl True I)). split. Qed.Goal ~(comes_from_the_left _ _ (or_intror True I)). red;inversion 1. Abort.End Version1.Fail Definition comes_from_the_left (P Q:Prop)(H:P \/ Q): Prop := match H with | or_introl p => True | or_intror q => False end.Definition comes_from_the_left_sumbool (P Q:Prop)(x:{P}+{Q}): Prop := match x with | left p => True | right q => False end. Close Scope Z_scope.Theorem S_is_not_O : forall n, S n <> 0.Set Nested Proofs Allowed.Definition Is_zero (x:nat):= match x with | 0 => True | _ => False end. Lemma O_is_zero : forall m, m = 0 -> Is_zero m. Proof. intros m H; subst m. simpl;trivial. Qed. red; intros n Hn. apply O_is_zero with (m := S n). assumption. Qed.Theorem disc2 : forall n, S (S n) <> 1. Proof. intros n Hn; discriminate. Qed. Theorem disc3 : forall n, S (S n) = 0 -> forall Q:Prop, Q. Proof. intros n Hn Q. discriminate. Qed.Theorem inj_succ : forall n m, S n = S m -> n = m. Proof. Lemma inj_pred : forall n m, n = m -> pred n = pred m. Proof. intros n m eq_n_m. rewrite eq_n_m. trivial. Qed. intros n m eq_Sn_Sm. apply inj_pred with (n:= S n) (m := S m); assumption. Qed.Lemma list_inject : forall (A:Set)(a b :A)(l l':list A), a :: b :: l = b :: a :: l' -> a = b /\ l = l'. Proof. intros A a b l l' e. injection e. auto. Qed. Theorem not_le_Sn_0 : forall n:nat, ~ (S n <= 0). Proof. red; intros n H. case H. Undo.Lemma not_le_Sn_0_with_constraints : forall n p , S n <= p -> p = 0 -> False. Proof. intros n p H; case H ; intros; discriminate. Qed.eapply not_le_Sn_0_with_constraints; eauto. Qed. Theorem not_le_Sn_0' : forall n:nat, ~ (S n <= 0). Proof. red; intros n H ; inversion H. Qed.Derive Inversion le_Sn_0_inv with (forall n :nat, S n <= 0). Check le_Sn_0_inv.Theorem le_Sn_0'' : forall n p : nat, ~ S n <= 0 . Proof. intros n p H; inversion H using le_Sn_0_inv. Qed.Derive Inversion_clear le_Sn_0_inv' with (forall n :nat, S n <= 0). Check le_Sn_0_inv'. Theorem le_reverse_rules : forall n m:nat, n <= m -> n = m \/ exists p, n <= p /\ m = S p. 
Require Import Coq.Classes.Morphisms.Global Instance Subrelation_eq_le : subrelation eqRat leRat. repeat red. intuition. eapply eqRat_impl_leRat. trivial. Qed.Global Instance eqRat_resp_leRat : forall x, Proper (eqRat ==> Basics.flip Basics.impl) (leRat x).intuition. repeat red; intuition. simpl. unfold respectful. intuition. eapply leRat_trans. eapply H0. eapply eqRat_impl_leRat. symmetry. trivial.Qed.Local Open Scope rat_scope. Theorem rat0_le_all : forall r, 0 <= r. rattac. Qed.Theorem rat1_ne_rat0 : ~ (eqRat 1 0). intuition. Qed.Theorem rat0_ne_rat1 : ~ (eqRat 0 1). intuition. Qed.Theorem ratAdd_comm : forall r1 r2, r1 + r2 == r2 + r1. rattac. Qed.Theorem ratAdd_0_r : forall r, r == r + 0. rattac; inversion H; subst; rewrite mult_1_r; trivial. Qed.Theorem ratAdd_0_l : forall r, r == 0 + r. intuition. rewrite ratAdd_comm. apply ratAdd_0_r. Qed.Theorem ratMult_comm : forall (r1 r2 : Rat), eqRat (ratMult r1 r2) (ratMult r2 r1). rattac. Qed.Theorem ratAdd_assoc : forall r1 r2 r3, r1 + r2 + r3 == r1 + (r2 + r3). rattac. inversion H; clear H; subst. Local Open Scope nat_scope. Ltac arithNormalize_step := repeat rewrite mult_succ_r in *; repeat rewrite mult_plus_distr_r in *; repeat rewrite mult_plus_distr_l in *; repeat rewrite mult_minus_distr_r in *; repeat rewrite mult_minus_distr_l in *; repeat rewrite plus_assoc in *; repeat rewrite mult_assoc in *. Ltac arithNormalize := repeat arithNormalize_step. Ltac arithSimplify := match goal with | [|- _ + ?x = _ + ?x] => f_equal | [|- _ + (?x1 * ?x2) = _ + (?x2 * ?x1) ] => f_equal | [|- _ + (?x1 * ?x2 * ?x3) = _ + (?x1 * ?x3 * ?x2) ] => f_equal | [|- _ + (?x1 * ?x2 * ?x3 * ?x4 * ?x5 * ?x6) = _ + (?x1 * ?x3 * ?x2 * ?x4 * ?x5 * ?x6) ] => f_equal | [|- _ * ?x1 = _ * ?x1] => f_equal | [|- _ * ?x = _ ] => rewrite mult_comm; repeat rewrite mult_assoc; arithSimplify | [|- _ + ?x = _ ] => rewrite plus_comm; repeat rewrite plus_assoc; arithSimplify | [|- _ * ?x1 <= _ * ?x1] => apply mult_le_compat; auto | [|- _ * ?x1 <= _ * ?x1] => apply plus_le_compat; auto | [|- _ * ?x <= _ ] => rewrite mult_comm; repeat rewrite mult_assoc; arithSimplify | [|- _ + ?x <= _ ] => rewrite plus_comm; repeat rewrite plus_assoc; arithSimplify end. arithNormalize. arithSimplify. arithSimplify. do 5 arithSimplify. do 5 arithSimplify. Qed.Local Open Scope rat_scope. Theorem ratMult_assoc : forall r1 r2 r3, r1 * r2 * r3 == r1 * (r2 * r3). 
From Coq Require Import ZArith Lia Zquot. From Coq Require SpecFloat.Notation cond_Zopp := SpecFloat.cond_Zopp (only parsing). Notation iter_pos := SpecFloat.iter_pos (only parsing).Section Zmissing. Theorem Zopp_le_cancel : forall x y : Z, (-y <= -x)%Z -> Z.le x y. 
flatid_addr_insert_inv_1 in Hflatid. destruct Hflatid as (a & Hvalid & -> & Hamlookup & Hflatid). assert (delete (addr2flat a) m = m). { rewrite delete_notin //. } rewrite H0 in Hflatid. rewrite map_size_insert_None //. apply IHfm in Hflatid as ->. rewrite map_size_delete_Some; eauto. assert (0 < size am)%nat. { eauto using Map.map_size_nonzero_lookup. } lia. Qed.End flatid2addr. Section map. Context {PROP : bi}. Context `{Countable K} {A : Type}. Theorem big_sepM_flatid_addr_map_1 (Œ¶ : _ -> A -> PROP) fm am : flatid_addr_map fm am -> ([‚àó map] a‚Ü¶b ‚àà am, Œ¶ a b) -‚àó [‚àó map] fa‚Ü¶b ‚àà fm, ‚àÉ a, ‚åú fa = addr2flat a ‚åù ‚àó Œ¶ a b. Proof. rewrite <- (list_to_map_to_list am). pose proof (NoDup_fst_map_to_list am); revert H0. generalize (map_to_list am); intros l H0. clear am; intros. iIntros "H". iInduction l as [|] "IH" forall (fm H0 H1). - simpl in *. apply flatid_addr_empty_2 in H1. rewrite H1. repeat rewrite big_sepM_empty. done. - simpl in *. inversion H0; clear H0; subst. apply flatid_addr_insert_inv_2 in H1; intuition idtac. iDestruct (big_sepM_insert_delete with "H") as "[Ha H]". erewrite <- (insert_id fm) by eauto. iApply big_sepM_insert_delete. iSplitL "Ha". { iExists _; iFrame. done. } rewrite delete_notin. 2: { apply not_elem_of_list_to_map_1; eauto. } rewrite -> (delete_notin (list_to_map _)) in H3. 2: { apply not_elem_of_list_to_map_1; eauto. } iDestruct ("IH" $! _ H5 H3 with "H") as "H". iFrame. Qed. Theorem big_sepM_flatid_addr_map_2 (Œ¶ : _ -> A -> PROP) fm am : flatid_addr_map fm am -> ([‚àó map] fa‚Ü¶b ‚àà fm, Œ¶ fa b) -‚àó [‚àó map] a‚Ü¶b ‚àà am, Œ¶ (addr2flat a) b. Proof. rewrite <- (list_to_map_to_list fm). pose proof (NoDup_fst_map_to_list fm); revert H0. generalize (map_to_list fm); intros l H0. clear fm; intros. iIntros "H". iInduction l as [|] "IH" forall (am H0 H1). - simpl in *. apply flatid_addr_empty_1 in H1. rewrite H1. repeat rewrite big_sepM_empty. done. - simpl in *. inversion H0; clear H0; subst. apply flatid_addr_insert_inv_1 in H1; destruct H1; intuition subst. iDestruct (big_sepM_insert_delete with "H") as "[Ha H]". erewrite <- (insert_id am) by eauto. iApply big_sepM_insert_delete. iSplitL "Ha". { rewrite H0. iFrame. } rewrite delete_notin. 2: { apply not_elem_of_list_to_map_1; eauto. } rewrite -> (delete_notin (list_to_map _)) in H6. 2: { apply not_elem_of_list_to_map_1; eauto. } iDestruct ("IH" $! _ H5 H6 with "H") as "H". iFrame. Qed.End map. Section gmap_addr_by_block. Variable (T : Type). Definition gmap_addr_by_block (m : gmap addr T) : gmap u64 (gmap u64 T) := gmap_curry m. Theorem gmap_addr_by_block_empty : gmap_addr_by_block ‚à = ‚à . 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops Functor.Representable.Hom_Func_Prop. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat. From Categories Require Import NatTrans.NatTrans NatTrans.Operations. From Categories Require Import Adjunction.Adjunction Adjunction.Duality Adjunction.Adj_Facts. From Categories Require Import KanExt.Global KanExt.Local KanExt.LocalFacts.ConesToHom KanExt.LocalFacts.HomToCones KanExt.GlobalDuality.Local Open Scope functor_scope. Section Global_to_Local_Right. Context {C C' : Category} (p : C --> C') (D : Category) (rke : Right_KanExt p D) (F : C --> D). Definition Cone_for_LoKan : LoKan_Cone p F := {| cone_apex := (rke _o F)%object; cone_edge := @adj_morph_ex _ _ _ _ (right_kan_ext_adj rke) (rke _o F) F (NatTrans_id _) |}. Section Cone_Morph_to_Cone_for_LoKan. Context (Cn : LoKan_Cone p F). Lemma Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id (morph : (Cn --> ((rke _o)%object F))%nattrans) : morph = ( ( (rke @_a)%morphism (Cn ‚àò p)%functor F ( (adj_morph_ex (right_kan_ext_adj rke) (NatTrans_id ((rke _o) F)%object)) ‚àò (morph ‚àò_h (NatTrans_id p)) ) ) ‚àò (Trans (adj_unit (right_kan_ext_adj rke)) Cn) )%nattrans. Proof. rewrite (@F_compose); cbn. rewrite NatTrans_compose_assoc. cbn_rewrite <- (@Trans_com _ _ _ _ (@adj_unit _ _ _ _ (right_kan_ext_adj rke)) _ _ morph). rewrite <- NatTrans_compose_assoc. cbn_rewrite <- ( @adj_morph_com _ _ _ _ (right_kan_ext_adj rke) _ _ (NatTrans_id ((rke _o)%object F)) ). rewrite NatTrans_id_unit_left. trivial. Qed. Program Definition Cone_Morph_to_Cone_for_LoKan : LoKan_Cone_Morph Cn Cone_for_LoKan := {| cone_morph := (((rke _a (cone_edge Cn))%morphism) ‚àò (Trans (adj_unit (right_kan_ext_adj rke)) Cn))%nattrans |}. Next Obligation. Proof. match goal with [|- _ = NatTrans_compose (NatTrans_hor_comp _ ?X) _] => apply (@adj_morph_unique _ _ _ _ (right_kan_ext_adj rke) _ _ X); trivial end. apply Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id. Qed. End Cone_Morph_to_Cone_for_LoKan. Section Cone_Morph_to_Cone_for_LoKan_Unique. Context {Cn : LoKan_Cone p F} (M M' : LoKan_Cone_Morph Cn Cone_for_LoKan). Theorem Cone_Morph_to_Cone_for_LoKan_Unique : (M = M' :> (_ --> _)%nattrans). 
x, or zero x = x. Proof. intros. rewrite or_commut. apply or_zero. Qed.Theorem or_mone: forall x, or x mone = mone. Proof. bit_solve. Qed.Theorem or_idem: forall x, or x x = x. Proof. bit_solve. destruct (testbit x i); auto. Qed.Theorem and_or_distrib: forall x y z, and x (or y z) = or (and x y) (and x z). Proof. bit_solve. apply demorgan1. Qed.Corollary and_or_distrib_l: forall x y z, and (or x y) z = or (and x z) (and y z). Proof. intros. rewrite (and_commut (or x y)). rewrite and_or_distrib. f_equal; apply and_commut. Qed.Theorem or_and_distrib: forall x y z, or x (and y z) = and (or x y) (or x z). Proof. bit_solve. apply orb_andb_distrib_r. Qed.Corollary or_and_distrib_l: forall x y z, or (and x y) z = and (or x z) (or y z). Proof. intros. rewrite (or_commut (and x y)). rewrite or_and_distrib. f_equal; apply or_commut. Qed.Theorem and_or_absorb: forall x y, and x (or x y) = x. Proof. bit_solve. assert (forall a b, a && (a || b) = a) by destr_bool. auto. Qed.Theorem or_and_absorb: forall x y, or x (and x y) = x. Proof. bit_solve. assert (forall a b, a || (a && b) = a) by destr_bool. auto. Qed.Theorem xor_commut: forall x y, xor x y = xor y x. Proof. bit_solve. apply xorb_comm. Qed.Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z). Proof. bit_solve. apply xorb_assoc. Qed.Theorem xor_zero: forall x, xor x zero = x. Proof. bit_solve. apply xorb_false. Qed.Corollary xor_zero_l: forall x, xor zero x = x. Proof. intros. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_idem: forall x, xor x x = zero. Proof. bit_solve. apply xorb_nilpotent. Qed.Theorem xor_zero_one: xor zero one = one. Proof. rewrite xor_commut. apply xor_zero. Qed.Theorem xor_one_one: xor one one = zero. Proof. apply xor_idem. Qed.Theorem xor_zero_equal: forall x y, xor x y = zero -> x = y. Proof. intros. apply same_bits_eq; intros. assert (xorb (testbit x i) (testbit y i) = false). rewrite <- bits_xor; auto. rewrite H. apply bits_zero. destruct (testbit x i); destruct (testbit y i); reflexivity || discriminate. Qed.Theorem xor_is_zero: forall x y, eq (xor x y) zero = eq x y. Proof. intros. predSpec eq eq_spec (xor x y) zero. - apply xor_zero_equal in H. subst y. rewrite eq_true; auto. - predSpec eq eq_spec x y. + elim H; subst y; apply xor_idem. + auto. Qed. Theorem and_xor_distrib: forall x y z, and x (xor y z) = xor (and x y) (and x z). 
:= | Here : forall x : Stream S, P x -> ExistsS P x | Further : forall (x : Stream S) (s : S), ExistsS P x -> ExistsS P (s ^ x). CoInductive isTrace : Stream S -> Prop := is_trace : forall (x : Stream S) (s1 s2 : S) (l : Label), tr s1 l s2 -> isTrace (s2 ^ x) -> isTrace (s1 ^ s2 ^ x). Definition isTraceFrom (Sini : S) (x : Stream S) := Sini = hd x /\ isTrace x. Inductive Until (P Q : Stream S -> Prop) : Stream S -> Prop := | UntilFurther : forall (s : S) (x : Stream S), P (s ^ x) -> Until P Q x -> Until P Q (s ^ x) | UntilHere : forall x : Stream S, Q x -> Until P Q x. Inductive EX_Until (Sini : S) (P Q : Stream S -> Prop) : Prop := ExUntil : forall x : Stream S, isTraceFrom Sini x -> Until P Q x -> EX_Until Sini P Q. Definition FA_Until (Sini : S) (P Q : Stream S -> Prop) := forall x : Stream S, isTraceFrom Sini x -> Until P Q x. Definition Always (Sini : S) (P : Stream S -> Prop) := forall x : Stream S, isTraceFrom Sini x -> ForAllS P x. Definition Inevitable (Sini : S) (P : Stream S -> Prop) := forall x : Stream S, isTraceFrom Sini x -> ExistsS P x. Inductive Posible (Sini : S) (P : Stream S -> Prop) : Prop := posible : forall x : Stream S, isTraceFrom Sini x -> ExistsS P x -> Posible Sini P. Inductive SafePath (Sini : S) (P : Stream S -> Prop) : Prop := safePath : forall x : Stream S, isTraceFrom Sini x -> ForAllS P x -> SafePath Sini P. Theorem Equiv1 : forall (Sini : S) (P : Stream S -> Prop), Posible Sini P <-> EX_Until Sini (fun _ : Stream S => True) P. Proof. unfold iff in |- *; intros; split; intro. inversion_clear H. apply ExUntil with (P := fun _ : Stream S => True) (1 := H0). elim H1; intros. constructor 2; assumption. constructor 1; trivial. inversion_clear H. apply posible with (1 := H0). elim H1; intros. constructor 2; assumption. constructor 1; assumption. Qed. Theorem Equiv2 : forall (Sini : S) (P : Stream S -> Prop), Inevitable Sini P <-> FA_Until Sini (fun _ : Stream S => True) P. 
l', In v l -> incl l' l -> incl a (vsmerge (v, l')) -> incl a l. Proof. intros. eapply incl_vsmerge_in''; eauto. eapply incl_vsmerge_trans; eauto. Qed. Local Hint Resolve in_vsmerge_hd incl_vsmerge_trans incl_vsmerge_in_trans. Opaque vsmerge. Theorem writeback_ok' : forall a cs, {< vs0, PRE:hm a |+> vs0 POST:hm' RET:cs' exists v, ( [[ Map.find a (CSMap cs) = Some (v, true) /\ cs' = mk_cs (Map.add a (v, false) (CSMap cs)) (CSMaxCount cs) (CSCount cs) (CSEvict cs) ]] * a |+> (v, vsmerge vs0)) \/ ( [[ (Map.find a (CSMap cs) = None \/ exists v, Map.find a (CSMap cs) = Some (v, false)) /\ cs' = cs ]] * a |+> vs0 ) CRASH:hm' a |+> vs0 >} writeback a cs. Proof. unfold writeback; intros. hoare. Unshelve. all: eauto. Qed. Theorem writeback_ok : forall a cs, {< d vs (F : rawpred), PRE:hm rep cs d * [[ (F * a |+> vs)%pred d ]] POST:hm' RET:cs' rep cs' d * [[ addr_clean (CSMap cs') a ]] * [[ Map.In a (CSMap cs) -> Map.In a (CSMap cs') ]] CRASH:hm' exists cs', rep cs' d >} writeback a cs. Proof. unfold writeback, rep; intros. prestep; norml; unfold stars; simpl; denote ptsto_subset as Hx; apply ptsto_subset_valid' in Hx; repeat deex. - rewrite mem_pred_extract with (a := a) by eauto. unfold cachepred at 2. destruct (Map.find a (CSMap cs)) eqn:Hm; try congruence. destruct p; destruct b; try congruence. cancel. step. erewrite <- upd_nop with (m := d) at 2 by eauto. rewrite <- mem_pred_absorb with (hm := d) (a := a). unfold cachepred at 3. rewrite MapFacts.add_eq_o by reflexivity. unfold ptsto_subset; cancel; eauto. rewrite mem_pred_pimpl_except. 2: intros; apply cachepred_add_invariant; eassumption. cancel. eapply size_valid_add_in; eauto. eapply addr_valid_add; eauto. unfold addr_clean; right; eexists; simpl. apply MapFacts.add_eq_o; auto. eapply MapFacts.add_in_iff; eauto. unfold ptsto_subset; cancel; eauto. eapply pimpl_trans; [ | apply mem_pred_absorb_nop; eauto ]. unfold cachepred at 3; rewrite Hm. unfold ptsto_subset; cancel; eauto. - cancel. step. unfold addr_clean; right; eexists; eauto. cancel. - cancel. step. unfold addr_clean; left; auto. cancel. Unshelve. all: try exact addr_eq_dec. Qed. Hint Extern 1 ({{_}} Bind (writeback _ _) _) => apply writeback_ok : prog. Hint Extern 0 (okToUnify (rep _ _) (rep _ _)) => constructor : okToUnify. Hint Extern 0 (okToUnify (synrep _ _ _) (synrep _ _ _)) => constructor : okToUnify. Hint Extern 0 (okToUnify (mem_pred ?p _) (mem_pred ?p _)) => constructor : okToUnify. Theorem evict_ok : forall a cs, {< d vs (F : rawpred), PRE:hm rep cs d * [[ (F * a |+> vs)%pred d ]] POST:hm' RET:cs' rep cs' d * [[ ~ Map.In a (CSMap cs') ]] * [[ Map.In a (CSMap cs) -> Map.cardinal (CSMap cs') < CSMaxCount cs' ]] CRASH:hm' exists cs', rep cs' d >} evict a cs. 
* S)) x1 x2 f2, fm _ _ o x1 -> (forall x, fm _ _ (o x) x2) -> (forall x y, oc_cost fm cm (o x y) f2) -> forall s, oc_cost fm cm (OC_Run _ _ _ c o s) (fun n => f1 (x1 + x2 + (f2 n))) | oc_cost_Ret : forall (A B C : Set)(c : Comp C) n, cm _ c n -> oc_cost fm cm (OC_Ret A B c) (fun _ => n) | oc_cost_Bind : forall (A B C C' : Set)(c : OracleComp A B C)(f : C -> OracleComp A B C') f1 x f2, oc_cost fm cm c f1 -> fm _ _ f x-> (forall y, oc_cost fm cm (f y) f2) -> oc_cost fm cm (OC_Bind c f) (fun n => (f1 n) + x + (f2 n)) | oc_cost_le : forall (A B C : Set)(c : OracleComp A B C) f1 f2, oc_cost fm cm c f1 -> (forall x, f1 x <= f2 x) -> oc_cost fm cm c f2.Section CostTheory. Context `{function_cost_model}. Theorem cost_compose_unary : forall (A B C: Type) (f1 : A -> B)(f2 : B ->C) c1 c2, cost f1 c1 -> cost f2 c2 -> cost (fun a => f2 (f1 a)) (c1 + c2). intuition. eapply cost_le. eapply (cost_compose f1 _ ). eauto. intuition. eapply cost_const. intuition. eauto. omega. Qed. Theorem cost_compose_binary : forall (A B C D: Type) (f1 : A -> B)(f2 : A ->C)(f3 : B -> C -> D) c1 c2 c3 c4, cost f1 c1 -> cost f2 c2 -> cost f3 c3 -> (forall a, cost (f3 a) c4) -> cost (fun a => f3 (f1 a) (f2 a)) (c1 + c2 + c3 + c4). intuition. eapply cost_le. eapply (cost_compose f2 (fun a x => f3 (f1 a) x)). eauto. intuition. eapply (cost_compose f1 (fun a => f3)). eauto. intuition. eapply cost_const. intuition. eauto. intuition. omega. Qed. Theorem cost_pair_1 : forall (A B : Type), cost (@pair A B) 0. intuition. eapply cost_uncurry_1. eapply cost_ext. 2:{ eapply cost_ident. } intuition. Qed. Theorem cost_pair_2 : forall (A B : Type) a, cost (@pair A B a) 0. intuition. eapply cost_uncurry_2. eapply cost_ext. 2:{ eapply cost_ident. } intuition. Qed. Theorem cost_OC_Bind_1 : forall (A B C C' : Set), cost (@OC_Bind A B C C') 0. intuition. eapply cost_uncurry_1. eapply cost_OC_Bind. Qed. Theorem cost_OC_Bind_2 : forall (A B C C' : Set) (c : OracleComp A B C), cost (@OC_Bind A B C C' c) 0. 
) ) . Defined . Definition tosecovertotal2 { X : UU } ( P : X -> UU ) ( Q : total2 P -> UU ) ( a : forall x : X , forall p : P x , Q ( tpair _ x p ) ) : forall xp : total2 P , Q xp . Proof . intros . destruct xp as [ x p ] . apply ( a x p ) . Defined . Definition weqsecovertotal2 { X : UU } ( P : X -> UU ) ( Q : total2 P -> UU ) : weq ( forall xp : total2 P , Q xp ) ( forall x : X , forall p : P x , Q ( tpair _ x p ) ) . Proof . intros . set ( f := fun a : forall xp : total2 P , Q xp => fun x : X => fun p : P x => a ( tpair _ x p ) ) . set ( g := tosecovertotal2 P Q ) . split with f . assert ( egf : forall a : _ , paths ( g ( f a ) ) a ) . intro . apply funextsec . intro xp . destruct xp as [ x p ] . apply idpath . assert ( efg : forall a : _ , paths ( f ( g a ) ) a ) . intro . apply funextsec . intro x . apply funextsec . intro p . apply idpath . apply ( gradth _ _ egf efg ) . Defined . Definition weqfunfromunit ( X : UU ) : weq ( unit -> X ) X := weqsecoverunit _ . Definition weqfunfromcontr { X : UU } ( Y : UU ) ( is : iscontr X ) : weq ( X -> Y ) Y := weqsecovercontr _ is . Definition weqfunfromtotal2 { X : UU } ( P : X -> UU ) ( Y : UU ) : weq ( total2 P -> Y ) ( forall x : X , P x -> Y ) := weqsecovertotal2 P _ .Definition weqfunfromdirprod ( X X' Y : UU ) : weq ( dirprod X X' -> Y ) ( forall x : X , X' -> Y ) := weqsecovertotal2 _ _ . Theorem impred (n:nat) { T : UU } (P:T -> UU): (forall t:T, isofhlevel n (P t)) -> (isofhlevel n (forall t:T, P t)). 
Require Import Undecidability.Synthetic.Undecidability. Require Import Undecidability.Synthetic.ReducibilityFacts. Require Import Undecidability.DiophantineConstraints.H10C. From Undecidability.FRACTRAN Require Import FRACTRAN Reductions.MM_FRACTRAN. From Undecidability.MinskyMachines Require Import MM Reductions.BSM_MM. From Undecidability.StackMachines Require Import BSM Reductions.SBTM_HALT_to_HaltBSM. Require Import Undecidability.TM.SBTM_undec.From Undecidability.DiophantineConstraints.Reductions Require FRACTRAN_to_H10C_SAT H10C_SAT_to_H10SQC_SAT H10SQC_SAT_to_H10UC_SAT H10UC_SAT_to_H10UPC_SAT.From Undecidability.FRACTRAN Require Import FRACTRAN FRACTRAN_undec. Theorem H10C_SAT_undec : undecidable H10C_SAT. 
[| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba) ===> llist b n fr ba. Axiom llist_end_bwd : forall (ba : W) n (fr : W) b, fr <> 0 -> focusOnBack -> (Ex v1, Ex v2, Ex v1', Ex v2', Ex n', Ex p, [| n = S (S n') |] * [| (v1', v2') %in b |] * [| (v1, v2) %in b %- (v1', v2')|] * lseg (b %- (v1, v2) %- (v1', v2')) n' fr p * [| p <> 0 |] * [| freeable p 3 |] * (p ==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. End QUEUE.Module Queue : QUEUE. Open Scope Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). destruct n; reflexivity. Qed. Theorem queue_extensional : forall b p, HProp_extensional (queue b p). reflexivity. Qed. Theorem lseg_extensional' : forall ba n b b' fr, b %= b' -> lseg b n fr ba ===> lseg b' n fr ba. induction n; sepLemma. Qed. Theorem llist_extensional' : forall ba n b b' fr, b %= b' -> llist b n fr ba ===> llist b' n fr ba. 
A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). intros a b; case a; case b; simpl in |- *; auto. intros d H' A0' H'0 H'1 nZd; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA A0 d nZd); auto. apply divA_A0_l with (1 := cs). Qed. Theorem divTerm_on_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). intros a b; case a; case b; unfold eqT in |- *; simpl in |- *; auto. intros d c A0' c0 H' H'0 H'1; rewrite <- H'1. split; auto. apply divA_is_multA with (1 := cs); auto. rewrite mult_div_id; auto. rewrite mult_mon_zero_l; auto. Qed. Theorem divTerm_on_eqT_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqT (divTerm a nZb) (T1 A1 n). intros a b; case a; case b; unfold eqT in |- *; simpl in |- *; auto. intros b2 c b3 c0 H' H'0 H'1; rewrite H'1; auto. rewrite mult_div_id; auto. Qed. Theorem divTerm_on_plusM_minusM : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, T2M a = mult_mon n (div_mon n (T2M a) (T2M b)) (T2M b) -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). intros a b; case a; case b; simpl in |- *; auto. split; auto. apply divA_is_multA with (1 := cs); auto. Qed. Set Implicit Arguments. Unset Strict Implicit. Definition ppc : Term A n -> Term A n -> Term A n. intros H; case H; intros b2 c2 H'; case H'; intros b3 c3; simpl in |- *; exact (A1, ppcm_mon n c2 c3). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem ppc_com : forall a b : Term A n, eqTerm (A:=A) eqA (n:=n) (ppc a b) (ppc b a). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0; split; auto. apply ppcm_com; auto. Qed. Theorem divTerm_ppc : forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (nZppab : ~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b)), eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZa) a) -> eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZb) b) -> eqTerm (A:=A) eqA (n:=n) c (multTerm (A:=A) multA (n:=n) (divTerm c nZppab) (ppc a b)). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations. From Categories Require Import Functor.Representable.Hom_Func. From Categories Require Import Cat.Cat Cat.Cat_Iso. From Categories Require Import NatTrans.NatTrans NatTrans.Func_Cat NatTrans.NatIso.Local Open Scope functor_scope.Section Hom_Func_Twist. Context (C : Category). Theorem Hom_Func_Twist : (Hom_Func (C^op)) = (Hom_Func C) ‚àò (Twist_Func C (C^op)). 
ee : paths j ( lastelement 0 ) ) . apply ( proofirrelevance _ ( isapropifcontr iscontrstn1 ) _ _ ) . destruct ( nopathstruetofalse ( pathscomp0 ( pathscomp0 ( pathsinv0 e ) ( maponpaths fl ee ) ) ni ) ) . apply ( weqcomp w' ( weqcomp ( invweq ( weqii2withneg _ g' ) ) w0 ) ) . Defined . Theorem weqfromhfiberfromstn { n : nat } { X : UU } ( x : X ) ( is : isisolated X x ) ( f : stn n -> X ) : total2 ( fun x0 : nat => weq ( hfiber f x ) ( stn x0 ) ) . Proof . intros . set ( t := weqfromdecsubsetofstn ( fun i : _ => eqbx X x is ( f i ) ) ) . split with ( pr1 t ) . apply ( weqcomp ( weqhfibertobhfiber f x is ) ( pr2 t ) ) . Defined . Theorem weqfromfunstntostn ( n m : nat ) : weq ( stn n -> stn m ) ( stn ( natpower m n ) ) . Proof. intro n . induction n as [ | n IHn ] . intro m . apply weqcontrcontr . apply ( iscontrfunfromempty2 _ weqstn0toempty ) . apply iscontrstn1 . intro m . set ( w1 := weqfromcoprodofstn 1 n ) . assert ( w2 : weq ( stn ( S n ) -> stn m ) ( (coprod (stn 1) (stn n)) -> stn m ) ) . apply ( weqbfun _ w1 ) . set ( w3 := weqcomp w2 ( weqfunfromcoprodtoprod ( stn 1 ) ( stn n ) ( stn m ) ) ) . set ( w4 := weqcomp w3 ( weqdirprodf ( weqfunfromcontr ( stn m ) iscontrstn1 ) ( IHn m ) ) ) . apply ( weqcomp w4 ( weqfromprodofstn m ( natpower m n ) ) ) . Defined . Definition stnprod { n : nat } ( f : stn n -> nat ) : nat . Proof. intro n . induction n as [ | n IHn ] . intro. apply 1 . intro f . apply ( ( IHn ( fun i : stn n => f ( dni n ( lastelement n ) i ) ) ) * f ( lastelement n ) ) . Defined . Theorem weqstnprod { n : nat } ( P : stn n -> UU ) ( f : stn n -> nat ) ( ww : forall i : stn n , weq ( stn ( f i ) ) ( P i ) ) : weq ( forall x : stn n , P x ) ( stn ( stnprod f ) ) . 
powerRZ (IZR radix) (Fexp x))%R. Local Coercion FtoR : float >-> R. Theorem FzeroisReallyZero : forall z : Z, Fzero z = 0%R :>R. intros z; unfold FtoR in |- *; simpl in |- *; auto with real. Qed. Theorem is_Fzero_rep1 : forall x : float, is_Fzero x -> x = 0%R :>R. intros x H; unfold FtoR in |- *. red in H; rewrite H; simpl in |- *; auto with real. Qed. Theorem LtFnumZERO : forall x : float, (0 < Fnum x)%Z -> (0 < x)%R. intros x; case x; unfold FtoR in |- *; simpl in |- *. intros Fnum1 Fexp1 H'; replace 0%R with (Fnum1 * 0)%R; [ apply Rmult_lt_compat_l | ring ]; auto with real zarith. Qed. Theorem is_Fzero_rep2 : forall x : float, x = 0%R :>R -> is_Fzero x. intros x H'. case (Rmult_integral _ _ H'); simpl in |- *; auto. case x; simpl in |- *. intros Fnum1 Fexp1 H'0; red in |- *; simpl in |- *; auto with real zarith. apply eq_IZR_R0; auto. intros H'0; Contradict H'0; apply powerRZ_NOR; auto with real zarith. Qed. Theorem NisFzeroComp : forall x y : float, ~ is_Fzero x -> x = y :>R -> ~ is_Fzero y. intros x y H' H'0; Contradict H'. apply is_Fzero_rep2; auto. rewrite H'0. apply is_Fzero_rep1; auto. Qed. Theorem Rlt_monotony_exp : forall (x y : R) (z : Z), (x < y)%R -> (x * powerRZ radix z < y * powerRZ radix z)%R. intros x y z H'; apply Rmult_lt_compat_r; auto with real zarith. Qed. Theorem Rle_monotone_exp : forall (x y : R) (z : Z), (x <= y)%R -> (x * powerRZ radix z <= y * powerRZ radix z)%R. intros x y z H'; apply Rmult_le_compat_r; auto with real zarith. Qed. Theorem Rlt_monotony_contra_exp : forall (x y : R) (z : Z), (x * powerRZ radix z < y * powerRZ radix z)%R -> (x < y)%R. intros x y z H'; apply Rmult_lt_reg_l with (r := powerRZ radix z); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix z)); auto. Qed. Theorem Rle_monotony_contra_exp : forall (x y : R) (z : Z), (x * powerRZ radix z <= y * powerRZ radix z)%R -> (x <= y)%R. intros x y z H'; apply Rmult_le_reg_l with (r := powerRZ radix z); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix z)); auto. Qed. Theorem FtoREqInv1 : forall p q : float, ~ is_Fzero p -> p = q :>R -> Fnum p = Fnum q -> p = q. 
(emin + prec - 1) <= Rabs x)%R -> exists eps, (Rabs eps < bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) rnd x = (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error_lt_conversion... apply bpow_gt_0. intros _; now apply relative_error_FLT. Qed.Variable choice : Z -> bool.Theorem relative_error_N_FLT : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error_N with (emin + prec - 1)%Z... apply relative_error_FLT_aux. Qed. Theorem relative_error_N_FLT_ex : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> exists eps, (Rabs eps <= /2 * bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error_le_conversion... apply Rlt_le. apply Rmult_lt_0_compat. apply Rinv_0_lt_compat. now apply (Z2R_lt 0 2). apply bpow_gt_0. now apply relative_error_N_FLT. Qed.Theorem relative_error_N_FLT_round : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs (round beta (FLT_exp emin prec) (Znearest choice) x))%R. Proof with auto with typeclass_instances. intros x Hx. apply relative_error_N_round with (emin + prec - 1)%Z... apply relative_error_FLT_aux. Qed.Theorem relative_error_N_FLT_F2R_emin : forall m, let x := F2R (Float beta m emin) in (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs x)%R. Proof with auto with typeclass_instances. intros m x. destruct (Rlt_or_le (Rabs x) (bpow (emin + prec - 1))) as [Hx|Hx]. rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. apply Rmult_le_pos. apply Rmult_le_pos. apply Rlt_le. apply (RinvN_pos 1). apply bpow_ge_0. apply Rabs_pos. apply generic_format_FLT_FIX... apply Rlt_le. apply Rlt_le_trans with (1 := Hx). apply bpow_le. apply Zle_pred. apply generic_format_FIX. now exists (Float beta m emin). now apply relative_error_N_FLT. Qed.Theorem relative_error_N_FLT_F2R_emin_ex : forall m, let x := F2R (Float beta m emin) in exists eps, (Rabs eps <= /2 * bpow (-prec + 1))%R /\ round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros m x. apply relative_error_le_conversion... apply Rmult_le_pos. apply Rlt_le. apply (RinvN_pos 1). apply bpow_ge_0. now apply relative_error_N_FLT_F2R_emin. Qed. Theorem relative_error_N_FLT_round_F2R_emin : forall m, let x := F2R (Float beta m emin) in (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <= /2 * bpow (-prec + 1) * Rabs (round beta (FLT_exp emin prec) (Znearest choice) x))%R. 
update_destruct; subst; rewrite_update; auto; repeat find_rewrite; simpl; auto. - find_copy_apply_lem_hyp doGenericServer_spec. break_and. auto. - eauto using doGenericServer_same_type. Qed. Lemma candidate_entries_do_generic_server : refined_raft_net_invariant_do_generic_server CandidateEntries. Proof using. red. unfold CandidateEntries. intros. intuition; simpl in *. - unfold candidateEntries_host_invariant in *. intros. eapply candidateEntries_ext; eauto. repeat find_higher_order_rewrite. update_destruct; subst; rewrite_update. + simpl in *. find_copy_apply_lem_hyp doGenericServer_spec. break_and. find_rewrite. repeat match goal with | [ H : nwState ?net ?h = (_, ?d), H' : context [ log ?d ] |- _ ] => replace (log d) with (log (snd (nwState net h))) in H' by (repeat find_rewrite; auto) end. eauto using doGenericServer_preserves_candidateEntries. + eauto using doGenericServer_preserves_candidateEntries. - unfold candidateEntries_nw_invariant in *. intros. simpl in *. eapply candidateEntries_ext; eauto. find_apply_hyp_hyp. intuition. + eauto using doGenericServer_preserves_candidateEntries. + do_in_map. find_copy_apply_lem_hyp doGenericServer_spec. break_and. subst. simpl in *. find_apply_hyp_hyp. exfalso. find_rewrite. eauto 20. Qed. Lemma candidate_entries_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset CandidateEntries. Proof using. red. unfold CandidateEntries. intros. intuition. - unfold candidateEntries_host_invariant in *. intros. repeat find_reverse_higher_order_rewrite. apply candidateEntries_ext with (sigma := nwState net); eauto. - unfold candidateEntries_nw_invariant in *. intros. find_apply_hyp_hyp. eapply_prop_hyp In In; eauto. apply candidateEntries_ext with (sigma := nwState net); eauto. Qed. Lemma reboot_log_same : forall d, log (reboot d) = log d. Proof using. unfold reboot. auto. Qed. Lemma reboot_preservers_candidateEntries : forall net h d gd e, nwState net h = (gd, d) -> candidateEntries e (nwState net) -> candidateEntries e (update name_eq_dec (nwState net) h (gd, reboot d)). Proof using. unfold reboot, candidateEntries. intros. break_exists. exists x. break_and. rewrite update_fun_comm. simpl in *. update_destruct; subst; rewrite_update; auto. repeat find_rewrite. simpl in *. intuition. discriminate. Qed. Lemma candidate_entries_reboot : refined_raft_net_invariant_reboot CandidateEntries. Proof using. red. unfold CandidateEntries. intros. intuition. - unfold candidateEntries_host_invariant in *. intros. repeat find_higher_order_rewrite. eapply candidateEntries_ext; eauto. subst. find_rewrite_lem update_fun_comm. simpl in *. find_rewrite_lem update_fun_comm. simpl in *. update_destruct; subst; rewrite_update. + repeat match goal with | [ H : nwState ?net ?h = (_, ?d), H' : context [ log ?d ] |- _ ] => replace (log d) with (log (snd (nwState net h))) in H' by (repeat find_rewrite; auto) end. find_apply_hyp_hyp. eauto using reboot_preservers_candidateEntries. + eauto using reboot_preservers_candidateEntries. - unfold candidateEntries_nw_invariant in *. intros. repeat find_reverse_rewrite. eapply_prop_hyp In In; eauto. eapply candidateEntries_ext; eauto. eauto using reboot_preservers_candidateEntries. Qed. Lemma candidate_entries_init : refined_raft_net_invariant_init CandidateEntries. Proof using. red. unfold CandidateEntries. unfold candidateEntries_host_invariant, candidateEntries_nw_invariant. intuition; repeat match goal with | [ H : In _ _ |- _ ] => compute in H end; intuition. Qed. Theorem candidate_entries_invariant : forall (net : network), refined_raft_intermediate_reachable net -> CandidateEntries net. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Category Category.Morph Category.Opposite. From Categories Require Import Ext_Cons.Arrow. From Categories Require Import Functor.Functor Functor.Functor_Ops Const_Func. From Categories Require Import Archetypal.Discr.Discr. From Categories Require Import Cat.Cat Cat.Cat_Iso. From Categories Require Import NatTrans.NatTrans NatTrans.NatIso.Local Open Scope morphism_scope. Section Comma. Context {B C D : Category} (F : (B ‚Äì‚âª C)%functor) (G : (D ‚Äì‚âª C)%functor). Record Comma_Obj : Type := { CMO_src : B; CMO_trg : D; CMO_hom : ((F _o CMO_src) ‚Äì‚âª (G _o CMO_trg))%object }. Record Comma_Hom (a b : Comma_Obj) : Type := { CMH_left : (CMO_src a) ‚Äì‚âª (CMO_src b); CMH_right : (CMO_trg a) ‚Äì‚âª (CMO_trg b); CMH_com : ((G _a CMH_right) ‚àò (@CMO_hom a) = (@CMO_hom b) ‚àò (F _a CMH_left))%morphism }. Arguments CMH_left {_ _} _. Arguments CMH_right {_ _} _. Arguments CMH_com {_ _} _. Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) : (@CMH_left _ _ h) = (@CMH_left _ _ h') ‚Üí (@CMH_right _ _ h) = (@CMH_right _ _ h') ‚Üí h = h'. Proof. intros H1 H2. destruct h; destruct h'. cbn in *. ElimEq. PIR. trivial. Qed. Program Definition Comma_Hom_compose {a b c : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) : Comma_Hom a c := {| CMH_left := (CMH_left h') ‚àò (CMH_left h); CMH_right := (CMH_right h') ‚àò (CMH_right h) |}. Next Obligation. Proof. repeat rewrite F_compose. rewrite assoc. rewrite CMH_com. rewrite assoc_sym. rewrite CMH_com. auto. Qed. Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b) (h' : Comma_Hom b c) (h'' : Comma_Hom c d) : Comma_Hom_compose h (Comma_Hom_compose h' h'') = Comma_Hom_compose (Comma_Hom_compose h h') h''. Proof. apply Comma_Hom_eq_simplify; cbn; auto. Qed. Program Definition Comma_Hom_id (a : Comma_Obj) : Comma_Hom a a := {| CMH_left := id; CMH_right := id |}. Theorem Comma_Hom_id_unit_left {a b : Comma_Obj} (h : Comma_Hom a b) : Comma_Hom_compose h (Comma_Hom_id b) = h. 
trivial. - intros. inversion_clear H0. rename x into envx. rename a into msg. destruct H1 as [Cx [Ex [Ey [H1 [H2 [H3 H4]]]]]]. subst E'. assert (Hx : INV envx (w_st Cx) (E ++ Ex)). { assert (w_a C = w_a Cx). { apply step_contract_address_constant with env msg Ex. apply H1. } destruct C as [C_a C_st]. destruct Cx as [Cx_a Cx_st]. simpl. simpl in H. simpl in H0. generalize H. generalize H4. apply step_INV with C_a msg. subst Cx_a. apply H1. } substH IHml with (IHml envx Cx (E ++ Ex) Hx). rewrite app_assoc. apply IHml; trivial. Qed.Lemma INV_implies_totalSupply_fixed : forall env S E, INV env S E -> Sum (st_balances S) (st_totalSupply S). Proof. intros env S E HI. unfold INV in HI. destruct HI as [_ Hsum]. trivial. Qed. Theorem Property_totalSupply_fixed : forall env0 env ml C E C' E', create env0 C E -> env_step env0 env -> run env C ml C' E' -> Sum (st_balances (w_st C')) (st_totalSupply (w_st C')). Proof. intros env0 env ml C E C' E' Hc Hs Hr. unfold run in Hr. destruct Hr as [env' Hsteps]. apply INV_implies_totalSupply_fixed with env' (E++E'). substH Hc with (create_INV _ _ C E Hc Hs). eapply steps_INV; eauto. Qed. Theorem Property_only_onwer_can_mint: forall msg to amount, m_func msg = mc_mint to amount -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C). Proof. intros msg to amount Hfunc env C C' evts Hstep. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [[Howner _] _]. auto. Qed. Theorem Property_only_onwer_can_finish_minting: forall msg, m_func msg = mc_finishMinting -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C). Proof. intros msg Hfunc env C C' evts Hstep. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [[Howner _] _]. auto. Qed. Theorem Property_finish_minting_unresumable: forall msg to amount, m_func msg = mc_mint to amount -> forall C, st_mintingFinished (w_st C) = true -> forall env C' evts, ~ step env C msg C' evts. Proof. intros msg to amount Hfunc C Hfinished env C' evts Hstep. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [[_ [Hfinished' _]] _]. rewrite Hfinished in Hfinished'. inversion Hfinished'. Qed. Theorem Property_restricted_owner_for_transfer: forall msg to v, m_func msg = mc_transfer to v -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) /\ acct <> to -> st_balances (w_st C) acct = st_balances (w_st C') acct. 
Require Export FSucc. Section pred. Variable b : Fbound. Variable radix : Z. Variable precision : nat. Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixMoreThanOne : (1 < radix)%Z. Hypothesis precisionNotZero : precision <> 0. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Definition FPred (x : float) := match Z_eq_bool (Fnum x) (- pPred (vNum b)) with | true => Float (- nNormMin radix precision) (Zsucc (Fexp x)) | false => match Z_eq_bool (Fnum x) (nNormMin radix precision) with | true => match Z_eq_bool (Fexp x) (- dExp b) with | true => Float (Zpred (Fnum x)) (Fexp x) | false => Float (pPred (vNum b)) (Zpred (Fexp x)) end | false => Float (Zpred (Fnum x)) (Fexp x) end end. Theorem FPredSimpl1 : forall x : float, Fnum x = (- pPred (vNum b))%Z -> FPred x = Float (- nNormMin radix precision) (Zsucc (Fexp x)). intros x H'; unfold FPred in |- *. generalize (Z_eq_bool_correct (Fnum x) (- pPred (vNum b))); case (Z_eq_bool (Fnum x) (- pPred (vNum b))); auto. intros H'0; Contradict H'0; auto. Qed. Theorem FPredSimpl2 : forall x : float, Fnum x = nNormMin radix precision -> Fexp x <> (- dExp b)%Z -> FPred x = Float (pPred (vNum b)) (Zpred (Fexp x)). intros x H' H'0; unfold FPred in |- *. generalize (Z_eq_bool_correct (Fnum x) (- pPred (vNum b))); case (Z_eq_bool (Fnum x) (- pPred (vNum b))); auto. intros H'1; absurd (0%nat < Fnum x)%Z; auto with zarith arith. apply Zle_not_lt; rewrite H'1; replace (Z_of_nat 0) with (- (0))%Z; [ apply Zle_Zopp | simpl in |- *; auto ]. unfold pPred in |- *; apply Zle_Zpred; red in |- *; simpl in |- *; auto. rewrite H'. apply nNormPos; auto with zarith. intros H'1; generalize (Z_eq_bool_correct (Fnum x) (nNormMin radix precision)); case (Z_eq_bool (Fnum x) (nNormMin radix precision)). intros H'2; generalize (Z_eq_bool_correct (Fexp x) (- dExp b)); case (Z_eq_bool (Fexp x) (- dExp b)); auto. intros H'3; Contradict H'0; auto. intros H'2; Contradict H'2; auto. Qed. Theorem FPredSimpl3 : FPred (Float (nNormMin radix precision) (- dExp b)) = Float (Zpred (nNormMin radix precision)) (- dExp b). 
leif_sum => b /eMmono->; apply: leif_sum => g /eMmono->. split; last exact: eq_sym. have /CnatP[n Dd]: d b g \in Cnat by rewrite Cnat_cfdot_char. have [Db | _] := eqP; rewrite Dd leC_nat // -ltC_nat -Dd Db cfnorm_gt0. by rewrite -char1_eq0 // cfunE mulf_neq0 ?irr1_neq0. rewrite -!cfdot_Res_l ?cfRes_Ind_invariant // !cfdotZl cfnorm_irr irrWnorm //. rewrite eqxx => /esym/forall_inP/(_ _ _)/eqfun_inP; rewrite /d /= => Dd. have irrMchi: {in calS, forall b, 'chi_b * chi \in irr G}. by move=> b Sb; rewrite /= irrEchar charMchi Dd ?eqxx. have injMchi: {in calS &, injective mul_Iirr}. move=> b g Sb Sg /(congr1 (fun s => '['chi_s, 'chi_(mul_Iirr g)]))/eqP. by rewrite cfnorm_irr !cfIirrE ?irrMchi ?Dd // pnatr_eq1; case: (b =P g). have{DpsiG} ->: 'Ind psi = \sum_(b in calS) e b *: 'chi_(mul_Iirr b). by rewrite DpsiG; apply: eq_bigr => b Sb; rewrite -scalerAl cfIirrE ?irrMchi. split=> // i; rewrite irr_consttE cfdot_suml; apply/idP/idP=> [|/imageP[b Sb ->]]. apply: contraR => N'i; rewrite big1 // => b Sb. rewrite cfdotZl cfdot_irr mulrb ifN_eqC ?mulr0 //. by apply: contraNneq N'i => ->; apply: image_f. rewrite gt_eqF // (bigD1 b) //= cfdotZl cfnorm_irr mulr1 ltr_paddr ?egt0 //. apply: sumr_ge0 => g /andP[Sg _]; rewrite cfdotZl cfdot_irr. by rewrite mulr_ge0 ?ler0n ?Cnat_ge0. Qed. Corollary constt_Ind_ext : [/\ forall b : Iirr (G / N), 'chi_(mod_Iirr b) * chi \in irr G, injective mul_mod_Iirr, irr_constt ('Ind theta) =i codom mul_mod_Iirr & 'Ind theta = \sum_b 'chi_b 1%g *: 'chi_(mul_mod_Iirr b)]. Proof. have IHchi0: G \subset 'I['chi[N]_0] by rewrite inertia_irr0. have [] := constt_Ind_mul_ext IHchi0; rewrite irr0 ?mul1r ?mem_irr //. set psiG := 'Ind 1 => irrMchi injMchi constt_theta {2}->. have dot_psiG b: '[psiG, 'chi_(mod_Iirr b)] = 'chi[G / N]_b 1%g. rewrite mod_IirrE // -cfdot_Res_r cfRes_sub_ker ?cfker_mod //. by rewrite cfdotZr cfnorm1 mulr1 conj_Cnat ?cfMod1 ?Cnat_irr1. have mem_psiG (b : Iirr (G / N)): mod_Iirr b \in irr_constt psiG. by rewrite irr_consttE dot_psiG irr1_neq0. have constt_psiG b: (b \in irr_constt psiG) = (N \subset cfker 'chi_b). apply/idP/idP=> [psiGb | /quo_IirrK <- //]. by rewrite constt0_Res_cfker // -constt_Ind_Res irr0. split=> [b | b g /injMchi/(can_inj (mod_IirrK nsNG))-> // | b0 | ]. - exact: irrMchi. - rewrite constt_theta. apply/imageP/imageP=> [][b psiGb ->]; last by exists (mod_Iirr b). by exists (quo_Iirr N b) => //; rewrite /mul_mod_Iirr quo_IirrK -?constt_psiG. rewrite (reindex_onto _ _ (in1W (mod_IirrK nsNG))) /=. apply/esym/eq_big => b; first by rewrite constt_psiG quo_IirrKeq. by rewrite -dot_psiG /mul_mod_Iirr => /eqP->. Qed.End ConsttIndExtendible. Theorem invariant_chief_irr_cases G K L s (theta := 'chi[K]_s) : chief_factor G L K -> abelian (K / L) -> G \subset 'I[theta] -> let t := #|K : L| in [\/ 'Res[L] theta \in irr L, exists2 e, exists p, 'Res[L] theta = e%:R *: 'chi_p & (e ^ 2)%N = t | exists2 p, injective p & 'Res[L] theta = \sum_(i < t) 'chi_(p i)]. 
Require Import Reals. Open Scope R_scope. Fixpoint bernoullicoeff (n:nat) (k:nat) : R:= match n with | O => match k with | O => INR 1 | _ => INR 0 end |(S m)=> match k with | O => (sum_f_R0 (fun l => -((bernoullicoeff m l)*(/INR (S l))*(INR n)*/ INR (S (S l)) )) m) | (S l)=> (bernoullicoeff m l)*/(INR (S l))*(INR n) end end. Definition bernoulli_polynomial (n:nat) (x:R):= (sum_f_R0 (fun l => (bernoullicoeff n l) *x^l) n). Theorem bernoulli_polynomial_derivable_pt_lim: forall n:nat,forall x:R, derivable_pt_lim (bernoulli_polynomial (S n)) x ((bernoulli_polynomial n x)*(INR (S n))). 
H. rewrite H. auto with zarith. destruct H; (rewrite H in mn2; simpl in mn2; contradiction). Qed.Theorem theorem_17 : forall a n : Z, a >= 2 /\ prime (a^n + 1) -> Zeven a /\ exists m : Z, n = 2^m. Proof. Abort. Lemma div_am1_anm1 : forall a n : Z, n >= 0 -> ((a - 1) | (a^n - 1)). Proof. intros a n ng0. pattern n. apply natlike_ind; [exists 0; reflexivity| |omega]. intros. destruct H0. rewrite Z.pow_succ_r; [|assumption]. exists (x0*a + 1). symmetry. rewrite -> Z.mul_add_distr_r. rewrite <- Z.mul_assoc. rewrite (Z.mul_comm a (a-1)). rewrite -> Z.mul_assoc. rewrite <- H0. ring. Qed.Search (_ <= _ -> _ >= _).Lemma div2k : forall n k : Z, k>0 /\ n>0 /\ (k|n) -> ((2 ^ k - 1) | (2 ^ n - 1)). Proof. intros n k [knz [nnz H]]. destruct H. rewrite H. pattern x. apply natlike_ind. exists 0. rewrite Zmult_0_l. simpl. reflexivity. intros. replace (Z.succ x0 * k) with (x0 * k + k); [|ring]. destruct H1. assert (2 ^ (x0 * k) = x1 * (2 ^ k - 1) + 1). rewrite <- H1. ring. rewrite Zpower_exp. rewrite H2. rewrite Z.mul_add_distr_r. rewrite Z.mul_1_l. rewrite Z.mul_sub_distr_l. rewrite Z.mul_sub_distr_r. exists ((x1 * 2 ^ k + 1)). ring. apply Z.le_ge. apply Z.mul_nonneg_nonneg. assumption. omega. omega. rewrite H in nnz. apply Z.gt_lt in nnz. apply Z.mul_pos_cancel_r in nnz. omega. omega. Qed. Lemma prime_2nm1_prime_n : forall n : Z, prime (2^n - 1) -> prime n. Proof. intros. assert (nn1 : n <> 1). red. intros. rewrite H0 in H. simpl in H. apply not_prime_1 in H. apply H. assert (nn0 : n <> 0). red. intros. rewrite H0 in H. simpl in H. apply not_prime_0 in H. apply H. assert (~(n < 0)). { apply prime_ge_2 in H. apply Z.le_le_succ_r in H. replace (Z.succ (2 ^ n - 1)) with (2 ^ n) in H; [|omega]. red. intros. specialize (Z.pow_neg_r 2 n). intros eq. apply eq in H0. rewrite H0 in H. simpl. omega. } case (prime_dec n); auto. intros. specialize (not_prime_divide n). intros eq. destruct eq. omega. assumption. destruct H1. apply prime_alt in H. unfold prime' in H. destruct H. specialize (H3 (2^x - 1)). destruct H3. split. replace 1 with (2^1-1); [|reflexivity]. apply Z.sub_lt_mono_r. apply Zpower_lt_monotone. omega. omega. apply Z.sub_lt_mono_r. apply Zpower_lt_monotone. omega. omega. apply div2k. split. omega. split. omega. apply H2. Qed. Theorem theorem_18 : forall a n : Z, a > 0 /\ n > 1 /\ prime (a^n - 1) -> a = 2 /\ prime n. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface.Require Import VerdiRaft.CommonTheorems. Require Import VerdiRaft.RefinementCommonTheorems. Require Import VerdiRaft.SpecLemmas. Require Import VerdiRaft.RefinementSpecLemmas.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.NoAppendEntriesToLeaderInterface. Require Import VerdiRaft.NoAppendEntriesToSelfInterface. Require Import VerdiRaft.TermsAndIndicesFromOneLogInterface. Require Import VerdiRaft.RefinedLogMatchingLemmasInterface. Require Import VerdiRaft.LogAllEntriesInterface. Require Import VerdiRaft.AppendEntriesRequestLeaderLogsInterface. Require Import VerdiRaft.LeaderSublogInterface. Require Import VerdiRaft.LeadersHaveLeaderLogsStrongInterface. Require Import VerdiRaft.OneLeaderLogPerTermInterface. Require Import VerdiRaft.MatchIndexLeaderInterface. Require Import VerdiRaft.MatchIndexSanityInterface. Require Import VerdiRaft.AppendEntriesReplySublogInterface. Require Import VerdiRaft.CandidateEntriesInterface. Require Import VerdiRaft.VotesCorrectInterface. Require Import VerdiRaft.CroniesCorrectInterface.Require Import VerdiRaft.MatchIndexAllEntriesInterface.Section MatchIndexAllEntries. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {naetli : no_append_entries_to_leader_interface}. Context {naetsi : no_append_entries_to_self_interface}. Context {taifoli : terms_and_indices_from_one_log_interface}. Context {rlmli : refined_log_matching_lemmas_interface}. Context {laei : log_all_entries_interface}. Context {aelli : append_entries_leaderLogs_interface}. Context {lsi : leader_sublog_interface}. Context {lhllsi : leaders_have_leaderLogs_strong_interface}. Context {ollpti : one_leaderLog_per_term_interface}. Context {mili : match_index_leader_interface}. Context {matchisi : match_index_sanity_interface}. Context {aersi : append_entries_reply_sublog_interface}. Context {cei : candidate_entries_interface}. Context {vci : votes_correct_interface}. Context {cci : cronies_correct_interface}. Definition match_index_all_entries_nw (net : network) : Prop := forall p t es e, In p (nwPackets net) -> pBody p = AppendEntriesReply t es true -> currentTerm (snd (nwState net (pDst p))) = t -> In e (log (snd (nwState net (pDst p)))) -> eTerm e = t -> eIndex e <= maxIndex es -> type (snd (nwState net (pDst p))) = Leader -> In (t, e) (allEntries (fst (nwState net (pSrc p)))). Definition match_index_all_entries_inv (net : network) : Prop := match_index_all_entries net /\ match_index_all_entries_nw net. Lemma match_index_all_entries_init : refined_raft_net_invariant_init match_index_all_entries_inv. Proof using. unfold refined_raft_net_invariant_init, match_index_all_entries_inv, match_index_all_entries_nw, match_index_all_entries. simpl. intros. intuition. Qed. Theorem handleClientRequest_matchIndex_log : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> ps = nil /\ (log st' = log st /\ matchIndex st' = matchIndex st \/ exists e, log st' = e :: log st /\ eIndex e = S (maxIndex (log st)) /\ eTerm e = currentTerm st /\ eClient e = client /\ eInput e = c /\ eId e = id /\ type st = Leader /\ matchIndex st' = assoc_set name_eq_dec (matchIndex st) h (S (maxIndex (log st)))). 
Require Export preuve2. Section gap. Variable N n : nat. Hypothesis alpha_irr : forall n p : Z, (alpha * IZR p)%R <> IZR n. Hypothesis prop_alpha : (0 < alpha)%R /\ (alpha < 1)%R. Hypothesis prop_N : forall N : nat, N >= 2. Hypothesis Hn : 0 < n /\ n < N. Definition succes := after N n. Definition num1 := n + first N. Definition num2 := n + first N - last N. Definition num3 := n - last N. Theorem three_gap : succes = num1 \/ succes = num2 \/ succes = num3.generalize (inser2_trans_lt 0 n (last N) (N - first N) N Hn). 
Require Import List.From Undecidability.Synthetic Require Import Definitions ReducibilityFacts InformativeDefinitions InformativeReducibilityFacts.From Undecidability.PCP Require Import PCP.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list finite.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.From Undecidability.TRAKHTENBROT Require Import notations bpcp fo_sig fo_terms fo_logic fo_sat Sig_discrete Sig_noeq .Set Implicit Arguments.Theorem BPCP_BPCP_problem_eq R : BPCP_problem R <-> BPCP R. Proof. split; intros (u & Hu). + constructor 1 with u; auto. + exists u; auto. Qed.Theorem BPCP_BPCP_problem : BPCP ‚™Ø·µ¢ BPCP_problem. Proof. exists (fun x => x); red; symmetry; apply BPCP_BPCP_problem_eq. Qed.Theorem fo_form_fin_dec_SAT_discr_equiv Œ£ A : FSAT Œ£ A <-> FSAT' Œ£ A. Proof. split. + apply fo_form_fin_dec_SAT_fin_discr_dec. + apply fo_form_fin_discr_dec_SAT_fin_dec. Qed.Corollary FIN_DEC_SAT_FIN_DISCR_DEC_SAT Œ£ : FSAT Œ£ ‚™Ø·µ¢ FSAT' Œ£. Proof. exists (fun A => A); red; apply fo_form_fin_dec_SAT_discr_equiv. Qed.Section FIN_DEC_EQ_SAT_FIN_DEC_SAT. Variable (Œ£ : fo_signature) (e : rels Œ£) (He : ar_rels _ e = 2). Theorem FIN_DEC_EQ_SAT_FIN_DEC_SAT : FSATEQ e He ‚™Ø·µ¢ FSAT Œ£. 
a0 b0); intro H; case (K2.eqdec a1 b1); intro H0; [ left | right | right | right ]; try (rewrite H; rewrite H0; trivial); red in |- *; intro H1; injection H1; tauto. Defined. End PairKey. Module Type DEC_ORDER. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom ordered : order A le. Axiom lt_le_weak : forall a b : A, lt a b -> le a b. Axiom lt_diff : forall a b : A, lt a b -> a <> b. Axiom le_lt_or_eq : forall a b : A, le a b -> lt a b \/ a = b. Parameter lt_eq_lt_dec : forall a b : A, {lt a b} + {a = b} + {lt b a}. End DEC_ORDER.Module Type MORE_DEC_ORDERS. Parameter A : Set. Parameter le : A -> A -> Prop. Parameter lt : A -> A -> Prop. Axiom le_trans : transitive A le. Axiom le_refl : reflexive A le. Axiom le_antisym : antisymmetric A le. Axiom lt_irreflexive : forall a : A, ~ lt a a. Axiom lt_trans : transitive A lt. Axiom lt_not_le : forall a b : A, lt a b -> ~ le b a. Axiom le_not_lt : forall a b : A, le a b -> ~ lt b a. Axiom lt_intro : forall a b : A, le a b -> a <> b -> lt a b. Parameter le_lt_dec : forall a b : A, {le a b} + {lt b a}. Parameter le_lt_eq_dec : forall a b : A, le a b -> {lt a b} + {a = b}. End MORE_DEC_ORDERS. Module More_Dec_Orders (D: DEC_ORDER) : MORE_DEC_ORDERS with Definition A := D.A with Definition le := D.le with Definition lt := D.lt. Definition A := D.A. Definition le := D.le. Definition lt := D.lt. Theorem le_trans : transitive A le. Proof. case D.ordered; auto. Qed. Theorem le_refl : reflexive A le. Proof. case D.ordered; auto. Qed. Theorem le_antisym : antisymmetric A le. Proof. case D.ordered; auto. Qed. Theorem lt_intro : forall a b : A, le a b -> a <> b -> lt a b. Proof. intros a b H diff; case (D.le_lt_or_eq a b H); tauto. Qed. Theorem lt_irreflexive : forall a : A, ~ lt a a. Proof. intros a H. case (D.lt_diff _ _ H); trivial. Qed. Theorem lt_not_le : forall a b : A, lt a b -> ~ le b a. 
None => True end) with | Some p => fun r v => recset p r v | None => fun _ => I end r. Fixpoint to_word {ft : type} : data ft -> word (len ft) := match ft as ft return (data ft -> word (len ft)) with | WordF n => fun v => v | ArrayF ft0 n as ft => (fix arrayf2word n v := match n as n0 return (data (ArrayF ft0 n0) -> word (len (ArrayF ft0 n0))) with | 0 => fun _ => $0 | S n0 => fun v => match v with | nil => $0 | v0 :: v' => combine (to_word v0) (arrayf2word n0 v') end end v) n | RecF t => (fix rec2word {t : rectype} (r : recdata t) : word (len (RecF t)) := match t as t return recdata t -> word (len (RecF t)) with | nil => fun _ => $0 | (_, _) :: _ => fun r => let (v, r') := r in combine (to_word v) (rec2word r') end r) t end. Fixpoint of_word {ft : type} : word (len ft) -> data ft := match ft as ft return (word (len ft) -> data ft) with | WordF n => fun w => w | ArrayF ft0 n as ft => (fix word2arrayf n w := match n as n return (word (len (ArrayF ft0 n)) -> data (ArrayF ft0 n)) with | 0 => fun _ => [] | S n' => fun w0 => (of_word (split1 (len ft0) _ w0)) :: (word2arrayf n' (split2 (len ft0) _ w0)) end w) n | RecF t => (fix word2rec (t : rectype) (w : word (len (RecF t))) : recdata t := match t as t return word (len (RecF t)) -> recdata t with | nil => fun _ => tt | (_, ft) :: t' => fun w => (of_word (split1 (len ft) (len (RecF t')) w), word2rec t' (split2 (len ft) (len (RecF t')) w)) end w) t end. Theorem to_of_id : forall ft w, to_word (@of_word ft w) = w. Proof. einduction ft using type_rect_nest; simpl. reflexivity. induction n. auto. intro w. simpl in *. rewrite IHn. rewrite IHt. apply combine_split. apply IHt. intro w. rewrite word0. trivial. simpl. intro w. rewrite IHt. rewrite IHt0. apply combine_split. Qed. Hint Rewrite to_of_id. Theorem of_to_id : forall ft v, well_formed v -> of_word (@to_word ft v) = v. 
(close :: l) L. Theorem parse_rel_sound_aux : forall (l1 l2:list par) (t:bin), parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2. Proof. intros l1 l2 t H; elim H; clear H l1 l2 t. - intros l1 l2 l3 t1 t2 Hp Hr1 Hp2 Hr2; simpl. rewrite app_ass, Hr1; simpl. now rewrite Hr2. - reflexivity. - reflexivity. Qed. Theorem parse_rel_sound : forall l:list par, (exists t : bin, parse_rel l nil t) -> wp l. Proof. intros l [t H]; replace l with (bin_to_string t). - apply bin_to_string_wp. - symmetry; replace (bin_to_string t) with (bin_to_string t ++ nil). + apply parse_rel_sound_aux; auto. + rewrite app_nil_end; auto. Qed. Inductive wp' : list par -> Prop := | wp'_nil : wp' nil | wp'_cons : forall l1 l2:list par, wp' l1 -> wp' l2 -> wp' (open :: l1 ++ close :: l2). Theorem wp'_concat : forall l1 l2:list par, wp' l1 -> wp' l2 -> wp' (l1 ++ l2). Proof. intros l1 l2 H; generalize l2; clear l2. elim H. - simpl; auto. - intros l1' l2' Hb1' Hr1 Hb2' Hr2 l2 Hb2; simpl; rewrite app_ass. simpl; apply wp'_cons; auto. Qed.#[export] Hint Resolve wp'_nil wp'_cons wp'_concat : core. Theorem wp'_encapsulate : forall l:list par, wp' l -> wp' (open :: l ++ close :: nil). Proof. intros l H; elim H; auto. Qed. Theorem wp_imp_wp' : forall l:list par, wp l -> wp' l. Proof. intros l H; elim H. - apply wp'_nil. - intros; apply wp'_concat; trivial. - intros; apply wp'_encapsulate; trivial. Qed. Theorem wp'_imp_wp : forall l:list par, wp' l -> wp l. Proof. intros l H; elim H; auto. Qed. Inductive wp'' : list par -> Prop := | wp''_nil : wp'' nil | wp''_cons : forall l1 l2:list par, wp'' l1 -> wp'' l2 -> wp'' (l1 ++ open :: l2 ++ close :: nil).#[export] Hint Resolve wp''_nil wp''_cons : core. Lemma wp''_concat : forall l1 l2:list par, wp'' l1 -> wp'' l2 -> wp'' (l1 ++ l2). Proof. intros l1 l2 H1 H2; generalize l1 H1; clear H1 l1; elim H2. - intros; rewrite <- app_nil_end; trivial. - intros; rewrite ass_app; auto. Qed. Theorem wp''_encapsulate : forall l:list par, wp'' l -> wp'' (open :: l ++ close :: nil). Proof. intros l H; change (wp'' (nil ++ open :: l ++ close :: nil)); auto. Qed. #[export] Hint Resolve wp''_concat wp''_encapsulate : core. Theorem wp_imp_wp'' : forall l:list par, wp l -> wp'' l. 
item0)) -> n <= divup (length l) items_per_val. Proof. intros; autorewrite with lists in *. erewrite <- list_chunk_length; eauto. Qed. Local Hint Resolve write_aligned_length_helper. Definition write_aligned xp start (items: itemlist) cs := let chunks := nopad_list_chunk items items_per_val in cs <- BUFCACHE.write_range ((RAStart xp) + start) (map block2val chunks) cs; Ret cs. Theorem write_aligned_ok : forall xp start new cs, {< F d, PRE:hm BUFCACHE.rep cs d * [[ items_valid xp start new ]] * [[ (F * avail_rep xp start (divup (length new) items_per_val))%pred d ]] POST:hm' RET: cs exists d', BUFCACHE.rep cs d' * [[ (F * array_rep xp start (Unsync new))%pred d' ]] XCRASH:hm' exists cs' d', BUFCACHE.rep cs' d' * [[ (F * avail_rep xp start (divup (length new) items_per_val)) % pred d' ]] >} write_aligned xp start new cs. Proof. unfold write_aligned, avail_rep. step. cbn. simplen. step. apply vsupd_range_nopad_unsync_array; auto. xcrash. rewrite vsupd_range_length; auto. simplen. setoid_rewrite nopad_list_chunk_length; auto. Qed. Lemma vssync_range_sync_array : forall xp start items count vsl, items_valid xp start items -> length items = (count * items_per_val)%nat -> length vsl = count -> arrayS (RAStart xp + start) (vssync_range (combine (ipack items) vsl) count) =p=> synced_array xp start items. Proof. unfold synced_array, rep_common; cancel; simplen. unfold vssync_range. rewrite skipn_oob by simplen. rewrite app_nil_r. apply arrayN_unify. rewrite firstn_oob by simplen. rewrite map_fst_combine by simplen. auto. Qed. Lemma helper_ipack_length_eq: forall (vsl : list (list valu)) count items, eqlen (ipack items) vsl -> length items = count * items_per_val -> count = length vsl. Proof. intros. replace (length vsl) with (length (ipack items)) by simplen. rewrite ipack_length; simplen. Qed. Lemma helper_ipack_length_eq': forall (vsl : list (list valu)) count items, eqlen (ipack items) vsl -> length items = count * items_per_val -> length vsl = count. Proof. intros; apply eq_sym; eapply helper_ipack_length_eq; eauto. Qed. Local Hint Resolve helper_ipack_length_eq helper_ipack_length_eq'. Hint Rewrite ipack_length. Lemma vssync_range_pimpl : forall xp start items vsl m, length items = (length vsl) * items_per_val -> m <= (length vsl) -> arrayS (RAStart xp + start) (vssync_range (combine (ipack items) vsl) m) =p=> arrayS (RAStart xp + start) (combine (ipack items) (repeat nil m ++ skipn m vsl)). Proof. intros. unfold vssync_range, ipack. apply arrayN_unify. rewrite skipn_combine by simplen. rewrite <- combine_app. f_equal. rewrite <- firstn_map_comm. rewrite map_fst_combine by simplen. rewrite firstn_skipn; auto. simplen. lia. Qed. Definition sync_aligned xp start count cs := cs <- BUFCACHE.sync_range ((RAStart xp) + start) count cs; Ret cs. Theorem sync_aligned_ok : forall xp start count cs, {< F d0 d items, PRE:hm BUFCACHE.synrep cs d0 d * [[ (F * array_rep xp start (Unsync items))%pred d ]] * [[ length items = (count * items_per_val)%nat ]] * [[ items_valid xp start items /\ sync_invariant F ]] POST:hm' RET: cs exists d', BUFCACHE.synrep cs d0 d' * [[ (F * array_rep xp start (Synced items))%pred d' ]] CRASH:hm' exists cs', BUFCACHE.rep cs' d0 >} sync_aligned xp start count cs. 
with datatypes. intros a1 n l H0 [H1| H1]; try rewrite H1; auto. Qed. Theorem restrict_code_encode_incl : forall (m1 : list A) (c : code A), incl m1 m -> encode eqA_dec c m1 = encode eqA_dec (restrict_code m c) m1. Proof using. intros m1 c; elim m1; simpl in |- *; auto. intros a l H H0. apply f_equal2 with (f := app (A:=bool)); auto with datatypes. apply restrict_code_in; auto with datatypes. apply H; apply incl_tran with (2 := H0); auto with datatypes. Qed. Theorem restrict_code_encode : forall c : code A, encode eqA_dec c m = encode eqA_dec (restrict_code m c) m. Proof using. intros c; apply restrict_code_encode_incl; auto with datatypes. Qed. Theorem restrict_unique_prefix : forall c : code A, not_null c -> in_alphabet m c -> unique_prefix c -> unique_prefix (restrict_code m c). Proof using. intros c HH HH0 (HH1, HH2); split. intros a1 a2 lb1 lb2 H0 H1 H2; apply HH1 with (lb1 := lb1) (lb2 := lb2); auto. unfold restrict_code in H0. case in_map_inv with (1 := H0). intros x; case x; simpl in |- *. intros a0 n (HP1, HP2). rewrite HP2. case (HH0 a0); auto. apply frequency_list_in with (1 := HP1). intros x0 H; rewrite find_code_correct2 with (2 := H); auto. unfold restrict_code in H1. case in_map_inv with (1 := H1). intros x; case x; simpl in |- *. intros a0 n (HP1, HP2). rewrite HP2. case (HH0 a0); auto. apply frequency_list_in with (1 := HP1). intros x0 H; rewrite find_code_correct2 with (2 := H); auto. unfold restrict_code in |- *. apply unique_key_map; auto. Qed. Theorem frequency_list_restric_code_map : forall c, map (fst (B:=_)) (frequency_list eqA_dec m) = map (fst (B:=_)) (restrict_code m c). Proof using. intros c; unfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *; auto. intros a0 l H; apply f_equal2 with (f := cons (A:=A)); auto. Qed. Theorem restrict_not_null : forall c, m <> nil -> restrict_code m c <> nil. Proof using. case m; simpl in |- *; auto. unfold restrict_code in |- *. intros a0 l c H H1. absurd (In ((fun x : A * nat => (fst x, find_code eqA_dec (fst x) c)) (a0, number_of_occurrences eqA_dec a0 (a0 :: l))) nil); auto with datatypes. rewrite <- H1. apply in_map with (f := fun x : A * nat => (fst x, find_code eqA_dec (fst x) c)). apply frequency_number_of_occurrences; auto with datatypes. Qed. Theorem restrict_code_pbbuild : forall c : code A, not_null c -> unique_prefix c -> in_alphabet m c -> m <> nil -> permutation (map fst (frequency_list eqA_dec m)) (all_pbleaves (pbbuild empty (restrict_code m c))). 
H); congruence. Qed. Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive) {struct m} : t B := match m with | Leaf => Leaf | Node l o r => Node (xmap f l (xO i)) (match o with None => None | Some x => Some (f (prev i) x) end) (xmap f r (xI i)) end. Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH. Lemma xgmap: forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A), get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Theorem gmap: forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A), get i (map f m) = option_map (f i) (get i m). Proof. intros A B f i m. unfold map. rewrite xgmap. repeat f_equal. exact (prev_involutive i). Qed. Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B := match m with | Leaf => Leaf | Node l o r => Node (map1 f l) (option_map f o) (map1 f r) end. Theorem gmap1: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map1 f m) = option_map f (get i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A := match l, x, r with | Leaf, None, Leaf => Leaf | _, _, _ => Node l x r end. Lemma gnode': forall (A: Type) (l r: t A) (x: option A) (i: positive), get i (Node' l x r) = get i (Node l x r). Proof. intros. unfold Node'. destruct l; destruct x; destruct r; auto. destruct i; simpl; auto; rewrite gleaf; auto. Qed. Fixpoint filter1 (A: Type) (pred: A -> bool) (m: t A) {struct m} : t A := match m with | Leaf => Leaf | Node l o r => let o' := match o with None => None | Some x => if pred x then o else None end in Node' (filter1 pred l) o' (filter1 pred r) end. Theorem gfilter1: forall (A: Type) (pred: A -> bool) (i: elt) (m: t A), get i (filter1 pred m) = match get i m with None => None | Some x => if pred x then Some x else None end. 
as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. Proof. unfold not; intros a H; inversion_clear H. Qed. Theorem in_split : forall x (l:list A), In x l -> exists l1 l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists [], l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Qed. Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem in_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl; auto. destruct IHl; simpl; auto. right; unfold not; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), [] <> x ++ a :: y. Proof. unfold not. destruct x as [| a l]; simpl; intros. discriminate H. discriminate H. Qed. Theorem app_nil_l : forall l:list A, [] ++ l = l. Proof. reflexivity. Qed. Theorem app_nil_r : forall l:list A, l ++ [] = l. Proof. induction l; simpl; f_equal; auto. Qed. Theorem app_nil_end : forall (l:list A), l = l ++ []. Proof. symmetry; apply app_nil_r. Qed. Theorem app_assoc : forall l m n:list A, l ++ m ++ n = (l ++ m) ++ n. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Poly.Theorem silly1 : forall (n m o p : nat), n = m -> [n;o] = [n;p] -> [n;o] = [m;p]. Admitted. Theorem silly2 : forall (n m o p : nat), n = m -> (forall (q r : nat), q = r -> [q;o] = [r;p]) -> [n;o] = [m;p]. Admitted. Theorem silly3_firsttry : forall (n : nat), n = 5 -> beq_nat (S (S n)) 7 = true. 
svalue_inl_size (x,v) im)%nat. Proof. intros x sub im v v' gxs. do 2 (rewrite sub_inl_proof). apply elements_set_some with (v := v) in gxs. destructAll. rewrite H, H0. clear H; clear H0. unfold list_inl_size. do 2 (rewrite Coqlib.list_append_map). simpl. do 2 (rewrite fold_right_app). simpl. rewrite fold_right_plus_init. rewrite fold_right_plus_init with (n := (svalue_inl_size (x, v') im + fold_right Init.Nat.add 0 (map (fun v0 : positive * svalue => svalue_inl_size v0 im) x1))). lia. Qed. Theorem sub_set_size: forall v x sub im, (sub_inl_size (M.set x v sub) im <= svalue_size v + sub_inl_size sub im)%nat. Proof. intros. assert (svalue_inl_size (x, v) im <= svalue_size v) by apply svalue_inl_le. destruct (M.get x sub) eqn:gxs. - apply set_some_size with (v := v) (im := im) in gxs. lia. - apply set_none_size with (v := v) (im := im) in gxs. lia. Qed. Theorem constr_sub_size: forall e v t lv sub im, (term_sub_inl_size (e, M.set v (SVconstr t lv) sub, im) < term_sub_inl_size (Econstr v t lv e, sub, im))%nat. Proof. intros. unfold term_sub_inl_size. simpl. assert ((sub_inl_size (M.set v (SVconstr t lv) sub) im <= svalue_size (SVconstr t lv) + sub_inl_size sub im))%nat. apply sub_set_size. simpl in H. lia. Defined. Theorem subfds_fds_size: forall fds' fds, subfds_fds fds fds' -> (funs_size fds < funs_size fds')%nat. Proof. induction fds'; intros. - inversion H; subst. apply IHfds' in H2. simpl. lia. simpl. lia. - inversion H. Defined. Theorem case_size: forall g v k cl, List.In (g, k) cl -> (term_size k < term_size (Ecase v cl))%nat. Proof. induction cl; intro; simpl in H. - inversion H. - destruct a. inv H. + inv H0. simpl. lia. + apply IHcl in H0. simpl. simpl in H0. lia. Defined. Theorem dsubterm_fds_size: forall e fds, dsubterm_fds_e e fds -> (term_size e < funs_size fds)%nat. Proof. induction fds; intros. inv H. simpl. lia. apply IHfds in H2. simpl; lia. inv H. Defined. Theorem dsubterm_size: forall e e', dsubterm_e e' e -> term_size e' < term_size e. Proof. intros. inv H; auto. - eapply case_size; eauto. - apply dsubterm_fds_size in H0. simpl. lia. - simpl. lia. Defined. Theorem subterm_size : forall e e', subterm_e e' e -> (term_size e' < term_size e)%nat. Proof. intros. induction H. - apply dsubterm_size; auto. - eapply transitivity; eauto. Defined. Theorem subterm_fds_size: forall e fds, subterm_fds_e e fds -> (term_size e < funs_size fds)%nat. Proof. intros. induction H. - apply subterm_size in H. simpl. lia. - simpl. lia. Defined. Theorem subterm_or_eq_size: forall e e', subterm_or_eq e e' -> (term_size e <= term_size e')%nat. 
H'; case (le_lt_or_eq _ _ H'); auto with arith. Qed. Theorem min_or : forall n m : nat, min n m = n /\ n <= m \/ min n m = m /\ m < n. intros n; elim n; simpl in |- *; auto with arith. intros n' Rec m; case m; simpl in |- *; auto with arith. intros m'; elim (Rec m'); intros H'0; case H'0; clear H'0; intros H'0 H'1; rewrite H'0; auto with arith. Qed. Theorem minus_inv_lt_aux : forall n m : nat, n - m = 0 -> n - S m = 0. intros n; elim n; simpl in |- *; auto with arith. intros n0 H' m; case m; auto with arith. intros H'0; discriminate. Qed. Theorem minus_inv_lt : forall n m : nat, m <= n -> m - n = 0. intros n m H'; elim H'; simpl in |- *; auto with arith. intros m0 H'0 H'1; apply minus_inv_lt_aux; auto. Qed. Theorem minus_le : forall m n p q : nat, m <= n -> p <= q -> m - q <= n - p. intros m n p q H' H'0. case (le_or_lt m q); intros H'1. rewrite minus_inv_lt with (1 := H'1); auto with arith. apply (fun p n m : nat => plus_le_reg_l n m p) with (p := q). rewrite le_plus_minus_r; auto with arith. rewrite (le_plus_minus p q); auto. rewrite (plus_comm p). rewrite plus_assoc_reverse. rewrite le_plus_minus_r; auto with arith. apply le_trans with (1 := H'); auto with arith. apply le_trans with (1 := H'0); auto with arith. apply le_trans with (2 := H'); auto with arith. Qed. Theorem lt_minus_inv : forall n m p : nat, n <= p -> m < n -> p - n < p - m. intros n m p H'; generalize m; clear m; elim H'. intros m H'0; rewrite <- minus_n_n; elim H'0. rewrite <- minus_Sn_m; auto with arith. intros m0 H'1 H'2; rewrite <- minus_Sn_m; auto with arith. intros m H'0 H'1 m0 H'2; repeat rewrite <- minus_Sn_m; auto with arith. apply le_trans with n; auto with arith. Qed. Theorem lt_mult_anti_compatibility : forall n n1 n2 : nat, 0 < n -> n * n1 < n * n2 -> n1 < n2. intros n n1 n2 H' H'0; case (le_or_lt n2 n1); auto. intros H'1; Contradict H'0; auto. apply le_not_lt; auto with arith. Qed. Theorem le_mult_anti_compatibility : forall n n1 n2 : nat, 0 < n -> n * n1 <= n * n2 -> n1 <= n2. 
:: ls) :: map (fun x => a' :: x) (addInAllLocations a ls') end.Fixpoint getAllPermutations(A : Type)(ls : list A) := match ls with | nil => nil :: nil | a :: ls' => let perms' := getAllPermutations ls' in flatten (map (addInAllLocations a) perms') end.Theorem addInAllLocations_not_nil : forall (A : Type) l (a : A), addInAllLocations a l = nil -> False. induction l; intuition; unfold addInAllLocations in *; simpl in *. inversion H. inversion H.Qed.Theorem getAllPermutations_not_nil : forall (A : Type)(ls : list A), getAllPermutations ls = nil -> False. induction ls; intuition; simpl in *. inversion H. case_eq (getAllPermutations ls); intuition. rewrite H0 in H. simpl in *. apply app_eq_nil in H. intuition. eapply addInAllLocations_not_nil; eauto. Qed. Theorem addInAllLocations_perm : forall (A : Type) x0 (a : A) ls2, In ls2 (addInAllLocations a x0) -> Permutation ls2 (a :: x0). induction x0; intuition; simpl in *. intuition; subst. eapply Permutation_refl. intuition; subst. eapply Permutation_refl. eapply in_map_iff in H0. destruct H0. intuition; subst. eapply perm_trans. 2:{ eapply perm_swap. } eapply perm_skip. eapply IHx0. trivial.Qed.Theorem getAllPermutations_perms : forall (A : Set)(ls1 ls2 : list A), In ls2 (getAllPermutations ls1) -> Permutation ls1 ls2. induction ls1; intuition; simpl in *. intuition. subst. econstructor. eapply in_flatten in H. destruct H. intuition. eapply in_map_iff in H0. destruct H0. intuition. subst. eapply addInAllLocations_perm in H1. eapply perm_trans. 2:{ eapply Permutation_sym. eauto. } eapply perm_skip. eapply IHls1. trivial. Qed.Section ShuffleList. Variable A : Set. Hypothesis A_EqDec : EqDec A. Definition shuffle(ls : list A) := o <-$ rndListElem _ (getAllPermutations ls); ret match o with | None => nil | Some x => x end. Theorem shuffle_perm : forall (ls1 ls2 : list A), In ls2 (getSupport (shuffle ls1)) -> Permutation ls2 ls1. intuition. unfold shuffle in *. repeat simp_in_support. destruct x. eapply Permutation_sym. eapply getAllPermutations_perms. apply rndListElem_support in H0. trivial. apply rndListElem_support_None in H0. exfalso. eapply getAllPermutations_not_nil. eauto. Qed. Fixpoint permute(ls : list A)(sigma : list nat) : list A := match sigma with | nil => nil | n :: sigma' => match (nth_error ls n) with | None => nil | Some a => a :: (permute ls sigma') end end. Theorem nth_error_not_None : forall (ls : list A)(n : nat), n < length ls -> nth_error ls n = None -> False. induction ls; destruct n; intuition; simpl in *. omega. omega. inversion H0. eapply IHls; eauto. omega. Qed. Theorem permute_length_eq : forall (sigma : list nat)(ls : list A), (forall n, In n sigma -> n < length ls) -> length (permute ls sigma) = length sigma. 
_ : nat => (c2 a)) (forNats (n0 - i)); ret a1 ++ a2) x == evalDist (ls <-$ (a1 <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats i); a2 <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats (n0 - i)); ret a1 ++ a2); ret (x0 :: ls)) x). inline_first. comp_skip. inline_first. comp_skip. comp_simp. rewrite app_comm_cons. intuition. rewrite H1. clear H1. eapply eqRat_trans. 2:{ comp_skip. eapply IHn0. omega. omega. eapply eqRat_refl. } unfold computeHybrid. inline_first. comp_skip. inline_first. comp_skip. inline_first. comp_skip. comp_simp. simpl. intuition. Qed. Definition B1 : Comp (A * (A * A_State)) := [a, s_A] <-$2 A1; ret (a, (a, s_A)). Definition B2(s : A * A_State)(b : B) : Comp bool := [a, s_A] <-2 s; i <-$ [0 .. n); rndHybrid <-$ computeHybrid n i a; distHybrid <- listReplace rndHybrid i b b; A2 s_A distHybrid. Definition DistSingle_G1(c : A -> Comp B) := [a, s_A] <-$2 B1; b <-$ (c a); B2 s_A b. Theorem DistSingle_G1_equiv : DistSingle_Adv c1 c2 B1 B2 == (| Pr[DistSingle_G1 c1] - Pr[DistSingle_G1 c2] |). unfold DistSingle_Adv, DistSingle_G1, DistSingle_G. intuition. Qed. Definition DistSingle_G2(c : A -> Comp B) := [a, s_A] <-$2 A1; i <-$ [ 0 .. n); distHybrid <-$ (b <-$ c a; rndHybrid <-$ computeHybrid n i a; ret (listReplace rndHybrid i b b)); A2 s_A distHybrid. Theorem DistSingle_G2_equiv : forall c, Pr[DistSingle_G1 c] == Pr[DistSingle_G2 c]. intuition. unfold DistSingle_G1, DistSingle_G2. unfold B1, B2. inline_first. comp_skip. comp_simp. comp_swap_l. comp_skip. inline_first. comp_skip. comp_inline_r. comp_skip. comp_simp. intuition. Qed. Definition DistSingle_G3_c2 := i <-$ [ 0 .. n); [a, s_A] <-$2 A1; distHybrid <-$ computeHybrid n i a; A2 s_A distHybrid. Definition DistSingle_G3_c1 := i <-$ [ 0 .. n); [a, s_A] <-$2 A1; distHybrid <-$ computeHybrid n (S i) a; A2 s_A distHybrid. Theorem DistSingle_G3_c2_equiv : Pr[DistSingle_G2 c2] == Pr[DistSingle_G3_c2]. unfold DistSingle_G2, DistSingle_G3_c2. comp_swap_r. comp_skip. comp_simp. comp_skip. comp_skip. eapply hybrid_replace_c2_equiv. eapply RndNat_support_lt; intuition. Qed. Theorem DistSingle_G3_c1_equiv : Pr[DistSingle_G2 c1] == Pr[DistSingle_G3_c1]. unfold DistSingle_G2, DistSingle_G3_c1. comp_swap_r. comp_skip. comp_simp. comp_skip. comp_skip. eapply hybrid_replace_c1_equiv. eapply RndNat_support_lt; intuition. Qed. Theorem compMap_computeHybrid_0_equiv : forall s_A a, Pr [b <-$ compMap B_EqDec (fun _ : nat => (c2 a)) (forNats n); A2 s_A b ] == Pr [x <-$ computeHybrid n 0 a; A2 s_A x ]. intuition. unfold computeHybrid. unfold forNats. fold forNats. inline_first. unfold compMap. fold compMap. comp_simp. inline_first. rewrite <- minus_n_O. comp_skip. comp_simp. simpl. intuition. Qed. Theorem compMap_computeHybrid_n_equiv : forall s_A a, Pr [b <-$ compMap B_EqDec (fun _ : nat => (c1 a)) (forNats n); A2 s_A b ] == Pr [x <-$ computeHybrid n n a; A2 s_A x ]. 
+ S D P Q = 2 * S A P Q). apply mid_point_equation... rewrite H4. ring. Qed.Theorem l2_11a_strong_strong_strong : forall A B C D P Q : Point, weak_3_parallelogram A B C D -> S A P Q + S C P Q = S B P Q + S D P Q. Proof with Geometry. intros. cases_equality A C. apply l2_11a_strong_strong_strong_aux... cases_equality B D. symmetry. apply l2_11a_strong_strong_strong_aux... unfold weak_3_parallelogram in *. DecompExAnd H X. exists X. intuition. apply l2_11a_strong. unfold weak_parallelogram. intuition. Qed.Theorem l2_11b : forall A B C D P Q : Point, parallelogram A B C D -> S4 P A Q B = S4 P D Q C. Proof with Geometry. intros. unfold S4 in |- *. assert (S P A Q = - S A P Q)... assert (S P Q B = S B P Q)... assert (S P D Q = - S D P Q)... assert (S P Q C = S C P Q)... rewrite H0. rewrite H1. rewrite H2. rewrite H3.assert (T := l2_11a A B C D P Q H)... RewriteVar (S A P Q) T... ring... Qed.Theorem l2_11b_strong_strong : forall A B C D P Q : Point, weak_2_parallelogram A B C D -> S4 P A Q B = S4 P D Q C. Proof with Geometry. intros. unfold S4 in |- *. assert (S P A Q = - S A P Q)... assert (S P Q B = S B P Q)... assert (S P D Q = - S D P Q)... assert (S P Q C = S C P Q)... rewrite H0. rewrite H1. rewrite H2. rewrite H3.assert (T := l2_11a_strong_strong A B C D P Q H)... RewriteVar (S A P Q) T... ring... Qed.Theorem l2_11b_strong_strong_strong : forall A B C D P Q : Point, weak_3_parallelogram A B C D -> S4 P A Q B = S4 P D Q C. Proof with Geometry. intros. unfold S4 in |- *. assert (S P A Q = - S A P Q)... assert (S P Q B = S B P Q)... assert (S P D Q = - S D P Q)... assert (S P Q C = S C P Q)... rewrite H0. rewrite H1. rewrite H2. rewrite H3.assert (T := l2_11a_strong_strong_strong A B C D P Q H)... RewriteVar (S A P Q) T... ring... Qed. Theorem l2_12a : forall A B C D P : Point, parallelogram A B C D -> S P A B = S P D C - S A D C. 
From stdpp Require Import namespaces. From iris.proofmode Require Import tactics. From iris.algebra Require Import excl. From Perennial.base_logic.lib Require Import invariants. From Perennial.program_logic Require Import weakestpre.From Perennial.goose_lang Require Import lang typing. From Perennial.goose_lang Require Import proofmode notation. From Perennial.goose_lang Require Import persistent_readonly. From Perennial.goose_lang.lib Require Import typed_mem. From Perennial.goose_lang.lib Require Export lock.impl. Set Default Proof Using "Type".Section goose_lang. Context `{ffi_sem: ffi_semantics}. Context `{!ffi_interp ffi}. Context {ext_tys: ext_types ext}.Local Coercion Var' (s:string): expr := Var s.Section proof. Context `{!heapGS Œ£} (N : namespace). Definition lock_inv (l : loc) (R : iProp Œ£) : iProp Œ£ := (‚àÉ b : bool, l ‚Ü¶{1/4} #b ‚àó if b then True else l ‚Ü¶{3/4} #b ‚àó R)%I. Definition is_lock (lk : val) (R : iProp Œ£) : iProp Œ£ := (‚àÉ l: loc, ‚åúlk = #l‚åù ‚àß inv N (lock_inv l R))%I. Theorem is_lock_flat lk R : is_lock lk R -‚àó ‚åú‚àÉ (l:loc), lk = #l‚åù. Proof. iIntros "Hl"; iDestruct "Hl" as (l) "[-> _]"; eauto. Qed. Theorem is_lock_ty lk R : is_lock lk R -‚àó ‚åúval_ty lk lockRefT‚åù. Proof. iIntros "Hlk". iDestruct (is_lock_flat with "Hlk") as (l) "->". iPureIntro. val_ty. Qed. Definition locked (lk: val) : iProp Œ£ := ‚àÉ (l:loc), ‚åúlk = #l‚åù ‚àó l ‚Ü¶{3/4} #true. Lemma locked_loc (l:loc) : locked #l ‚ä£‚ä¢ l ‚Ü¶{3/4} #true. Proof. rewrite /locked. iSplit; auto. iIntros "Hl". iDestruct "Hl" as (l' Heq) "Hl". inversion Heq; subst. auto. Qed. Lemma locked_exclusive (lk : val) : locked lk -‚àó locked lk -‚àó False. Proof. iIntros "H1 H2". iDestruct "H1" as (l1 ->) "H1". iDestruct "H2" as (l2 ?) "H2". inversion H; subst. iCombine "H1 H2" as "H". iDestruct (heap_mapsto_frac_valid with "H") as %Hval. eauto. Qed. Global Instance lock_inv_ne l : NonExpansive (lock_inv l). Proof. solve_proper. Qed. Global Instance is_lock_ne l : NonExpansive (is_lock l). Proof. solve_proper. Qed. Global Instance is_lock_persistent l R : Persistent (is_lock l R). Proof. apply _. Qed. Global Instance locked_timeless l : Timeless (locked l). Proof. apply _. Qed. Definition is_free_lock (l: loc): iProp Œ£ := l ‚Ü¶ #false. Theorem is_free_lock_ty lk : is_free_lock lk -‚àó ‚åúval_ty #lk lockRefT‚åù. 
meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> forall n, (WfMod_new type (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineSingle_Rules_pos meths n rules) meths)) (Base (BaseMod regs rules meths)). Proof. intros. rewrite WfMod_new_WfMod_iff in *. apply TraceInclusion_inlineSingle_pos_Rules_l; auto. Qed. Lemma TraceInclusion_inlineSingle_pos_Rules_Wf_l (m : BaseModuleWf type) n : TraceInclusion (inlineSingle_Rules_pos_BaseModuleWf m n) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineSingle_pos_Rules_l P2 n) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineSingle_pos_Rules_Wf_l_new (m : BaseModuleWf_new type) n : TraceInclusion (inlineSingle_Rules_pos_BaseModuleWf_new m n) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineSingle_pos_Rules_Wf_l m'). Qed. Lemma TraceInclusion_inlineAll_pos_Rules_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> (WfMod type (Base (BaseMod regs (inlineAll_Rules meths rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineAll_Rules meths rules) meths)) (Base (BaseMod regs rules meths)). Proof. intros WfH. unfold inlineAll_Rules. induction (Datatypes.length meths); [simpl in *; split; [assumption | apply TraceInclusion_refl]|]. rewrite seq_eq. rewrite fold_left_app; simpl in *. destruct IHn as [IHn1 IHn2]. pose proof (TraceInclusion_inlineSingle_pos_Rules_l IHn1 n) as [sth1 sth2]. destruct n; simpl in *; auto. split; auto. eapply TraceInclusion_trans; eauto. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> (WfMod_new type (Base (BaseMod regs (inlineAll_Rules meths rules) meths))) /\ TraceInclusion (Base (BaseMod regs (inlineAll_Rules meths rules) meths)) (Base (BaseMod regs rules meths)). Proof. repeat rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inlineAll_pos_Rules_l. Qed. Lemma TraceInclusion_inlineAll_pos_Rules_Wf_l (m : BaseModuleWf type) : TraceInclusion (inlineAll_Rules_BaseModuleWf m) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineAll_pos_Rules_l P2) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_Wf_l_new (m : BaseModuleWf_new type) : TraceInclusion (inlineAll_Rules_BaseModuleWf_new m) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineAll_pos_Rules_Wf_l m'). Qed. Lemma TraceInclusion_inlineSingle_pos_Meths_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> forall n, (WfMod type (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n))) (Base (BaseMod regs rules meths)). Proof. intros WfH n. unfold inlineSingle_Meths_pos. case_eq (nth_error meths n); intros sth; [intros sthEq|split; [assumption | apply TraceInclusion_refl]]. split. - apply nth_error_In in sthEq. pose proof (WfMod_inline_all_Meth sth (seq 0 (length meths)) sthEq WfH). repeat rewrite map_fold_right_eq in *. assumption. - apply TraceInclusion_inline_BaseModule_meths_l; auto. eapply nth_error_In; eauto. Qed. Theorem TraceInclusion_inlineSingle_pos_Meths_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> forall n, (WfMod_new type (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineSingle_Meths_pos meths n))) (Base (BaseMod regs rules meths)). 
rewrite inj_plus; ring. Qed. Theorem LSB_comp : forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> LSB x = LSB y. intros x y H' H'0 H'1. case (FshiftCorrectSym radix) with (2 := H'1); auto. intros m1 H'2; elim H'2; intros m2 E; clear H'2. rewrite (LSB_shift x m1); auto. rewrite E; auto. apply sym_equal; apply LSB_shift; auto. apply (NisFzeroComp radix) with (x := x); auto. Qed. Theorem maxDiv_opp : forall (v : Z) (p : nat), maxDiv v p = maxDiv (- v) p. intros v p; elim p; simpl in |- *; auto. intros n H; case (ZdividesP v (radix * Zpower_nat radix n)); case (ZdividesP (- v) (radix * Zpower_nat radix n)); auto. intros Z1 Z2; case Z1. case Z2; intros z1 Hz1; exists (- z1)%Z; rewrite Hz1; ring. intros Z1 Z2; case Z2. case Z1; intros z1 Hz1; exists (- z1)%Z. rewrite <- (Zopp_involutive v); rewrite Hz1; ring. Qed. Theorem LSB_opp : forall x : float, LSB x = LSB (Fopp x). intros x; unfold LSB in |- *; simpl in |- *. rewrite Fdigit_opp; auto. rewrite maxDiv_opp; auto. Qed. Theorem maxDiv_abs : forall (v : Z) (p : nat), maxDiv v p = maxDiv (Zabs v) p. intros v p; elim p; simpl in |- *; auto. intros n H; case (ZdividesP v (radix * Zpower_nat radix n)); case (ZdividesP (Zabs v) (radix * Zpower_nat radix n)); auto. intros Z1 Z2; case Z1. case Z2; intros z1 Hz1; exists (Zabs z1); rewrite Hz1. rewrite Zabs_Zmult; f_equal. apply Zabs_eq. auto with zarith. intros Z1 Z2; case Z2. case Z1; intros z1 Hz1. case (Zle_or_lt v 0); intros Z4. exists (- z1)%Z; rewrite <- (Zopp_involutive v); rewrite <- (Zabs_eq_opp v); auto; rewrite Hz1; ring. exists z1; rewrite <- (Zabs_eq v); auto with zarith; rewrite Hz1; ring. Qed.Theorem LSB_abs : forall x : float, LSB x = LSB (Fabs x). intros x; unfold LSB in |- *; simpl in |- *. rewrite Fdigit_abs; auto. rewrite maxDiv_abs; auto. Qed. Definition MSB (x : float) := Zpred (Z_of_nat (Fdigit radix x) + Fexp x). Theorem MSB_shift : forall (x : float) (n : nat), ~ is_Fzero x -> MSB x = MSB (Fshift radix n x). intros; unfold MSB, Fshift, Fdigit in |- *; simpl in |- *. rewrite digitAdd; auto with zarith. rewrite inj_plus; unfold Zpred in |- *; ring. Qed. Theorem MSB_comp : forall (x y : float) (n : nat), ~ is_Fzero x -> x = y :>R -> MSB x = MSB y. 
: nat), (forall i, i <= n -> Q (nth_tail i l)) /\ P (nth_tail n l)). Proof. split; intros. + pose proof (classic ( (exists n : nat, (forall i : nat, i <= n -> Q (nth_tail i l)) /\ P (nth_tail n l)))) as [? | ?]; auto. left. intros n; revert H; revert H0; revert l. induction n; intros. - simpl. inversion H; subst; auto. - destruct l; simpl; apply IHn. * intros Hcontra. destruct Hcontra as [n0 Hcontra]. apply H0. exists (S n0). simpl; intuition. destruct i; simpl. inversion H; subst; auto. apply H1; omega. * inversion H; subst; auto. exfalso. apply H0. exists 0; intros; simpl; intuition. inversion H3; auto. + destruct H as [? | ?]. - revert H; revert l; cofix H; intros. destruct l. apply ReleaseLater. * pose proof (H0 0); auto. * apply H. intros. specialize (H0 (S n)); auto. - destruct H as [n H]. revert H; revert l; induction n; intros. * intuition; specialize (H0 0). apply ReleaseHere; auto. * destruct l; simpl in *; intuition. apply ReleaseLater. specialize (H0 0); intuition. apply IHn; intuition. specialize (H0 (S i)); intuition. Qed. End Semantics. Ltac ltl_fsimpl := ltl_simpl; repeat ( try rewrite Always_semantics in *; try rewrite Eventually_semantics in *; try rewrite Until_semantics in *; intros; try match goal with | [ H : exists x, _ |- _ ] => let x := fresh x in destruct H as [x H] end ). Section Absorption. Lemma nth_tail_eq_n : forall (l : Stream A) (n n' : nat), n = n' -> nth_tail n l = nth_tail n' l. Proof. intros; subst; auto. Qed. Theorem Eventually_absorb : forall (P : LTLProp A), Eventually (Always (Eventually P)) ~= Always (Eventually P). Proof. ltl_simpl. + ltl_fsimpl. specialize (H n); simpl in *; ltl_fsimpl. exists (n0 + n1); simpl in *. repeat rewrite nth_tail_assoc in *. erewrite nth_tail_eq_n; try eassumption; omega. + rewrite Eventually_semantics. exists 0; auto. Qed. Theorem Always_absorb : forall (P : LTLProp A), Always (Eventually (Always P)) ~= Eventually (Always P). Proof. ltl_simpl. + rewrite Always_semantics in H; specialize (H 0); auto. + ltl_fsimpl. exists n0; ltl_fsimpl. specialize (H (n1 + n)). repeat rewrite nth_tail_assoc in *. erewrite nth_tail_eq_n; try eassumption; omega. Qed. End Absorption. Section Distributivity. Theorem Next_Or_dist : forall (P Q : LTLProp A), Next (Or P Q) ~= Or (Next P) (Next Q). Proof. ltl_simpl. Qed. Theorem Next_And_dist : forall (P Q : LTLProp A), Next (And P Q) ~= And (Next P) (Next Q). 
e) = Some e' -> In e es -> uniqueIndices es -> e = e'. Proof using. intros. pose proof findAtIndex_in _ _ _ H. pose proof findAtIndex_index _ _ _ H. eapply uniqueIndices_elim_eq; eauto. Qed. Definition entries_match' entries entries' := forall e e' e'', eIndex e = eIndex e' -> eTerm e = eTerm e' -> In e entries -> In e' entries' -> eIndex e'' <= eIndex e -> (In e'' entries -> In e'' entries'). Lemma entries_match_entries_match' : forall xs ys, entries_match xs ys -> entries_match' xs ys /\ entries_match' ys xs. Proof using. unfold entries_match, entries_match'. intros. intuition. - eapply H; eauto. - eapply (H e' e); eauto with *. Qed. Definition contiguous (prevLogIndex : logIndex) (prevLogTerm : term) (leaderLog entries : list entry) : Prop := (prevLogIndex = 0 \/ exists e, findAtIndex leaderLog prevLogIndex = Some e /\ eTerm e = prevLogTerm) /\ (forall e, In e leaderLog -> eIndex e > prevLogIndex -> eIndex e <= maxIndex entries -> In e entries) /\ forall e e', eIndex e = eIndex e' -> eTerm e = eTerm e' -> In e entries -> In e' leaderLog -> e = e'. Lemma entries_match_refl : forall l, entries_match l l. Proof using. unfold entries_match. intuition. Qed. Lemma entries_match_sym : forall xs ys, entries_match xs ys -> entries_match ys xs. Proof using. intros. unfold entries_match in *. intros. intuition. - apply H with (e:=e')(e':=e); auto. repeat find_rewrite. auto. - apply H with (e:=e')(e':=e); auto. repeat find_rewrite. auto. Qed. Lemma advanceCurrentTerm_same_log : forall st t, log (advanceCurrentTerm st t) = log st. Proof using. unfold advanceCurrentTerm. intros. break_if; auto. Qed. Lemma tryToBecomeLeader_same_log : forall n st out st' ms, tryToBecomeLeader n st = (out, st', ms) -> log st' = log st. Proof using. unfold tryToBecomeLeader. intros. find_inversion. auto. Qed. Lemma handleRequestVote_same_log : forall n st t c li lt st' ms, handleRequestVote n st t c li lt = (st', ms) -> log st' = log st. Proof using. unfold handleRequestVote. intros. repeat (break_match; try discriminate; repeat (find_inversion; simpl in *)); auto using advanceCurrentTerm_same_log. Qed. Lemma handleRequestVoteReply_same_log : forall n st src t v, log (handleRequestVoteReply n st src t v) = log st. Proof using. unfold handleRequestVoteReply. intros. repeat break_match; simpl; auto using advanceCurrentTerm_same_log. Qed. Lemma advanceCurrentTerm_same_lastApplied : forall st t, lastApplied (advanceCurrentTerm st t) = lastApplied st. Proof using. unfold advanceCurrentTerm. intros. break_if; auto. Qed. Theorem handleTimeout_lastApplied : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> lastApplied st' = lastApplied st. 
Require Import Coq.omega.Omega. Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.WebServer Bedrock.Platform.Bootstrap. Module Type HIDE. Parameter heapSize4 : N -> N. Axiom heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. Parameter to_nat : N -> nat. Axiom to_nat_eq : to_nat = N.to_nat. End HIDE.Module Hide : HIDE. Definition heapSize4 n := (n * 4)%N. Theorem heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. auto. Qed. Definition to_nat := N.to_nat. Theorem to_nat_eq : to_nat = N.to_nat. auto. Qed. End Hide. Module Type S. Parameter heapSize : N. Parameters port numWorkers : W. End S.Module Make(M : S). Import M.Module M'. Definition globalSched : W := ((heapSize + 50) * 4)%N. Definition globalSock : W := globalSched ^+ $4. Definition globalTree : W := globalSched ^+ $8. Definition globalPages : W := globalSched ^+ $12. Definition port := M.port. Definition numWorkers := M.numWorkers. Definition inbuf_size := 256. Theorem inbuf_size_lower : (inbuf_size >= 2)%nat. unfold inbuf_size; auto. Qed. Theorem inbuf_size_upper : (N_of_nat (inbuf_size * 4) < Npow2 32)%N. 
z; case z; auto. intros H'0; inversion H'0. intros x0 y0 p q H'0 z H'1; simple inversion H'1. discriminate H. rewrite <- H1. intros H'2; try assumption. apply ltP_hd; auto. apply ltT_trans with (y := y0); auto. injection H0. intros H'3 H'4; rewrite <- H'4; auto. rewrite <- H2. intros H'2 H'3; apply ltP_hd; auto. apply ltT_eqTl with (a := x1); auto. injection H1. intros H'4 H'5; rewrite H'5; auto. intros x0 y0 p q H'0 H'1 H'2 z H'3; simple inversion H'3. discriminate H. rewrite <- H1; auto. intros H'4; apply ltP_hd; auto. apply ltT_eqTr with (a := y0). apply (eqT_sym A n); auto. injection H0. intros H'5 H'6; rewrite <- H'6; auto. rewrite <- H2. intros H'4 H'5; apply ltP_tl; auto. apply (eqT_trans A n) with (y := x1); auto. injection H1. intros H'6 H'7; rewrite H'7; auto. apply H'2; auto. injection H1. intros H'6; rewrite <- H'6; auto. Qed. Theorem olist_pX_ltP : forall a p, olist (pX a p) -> ltP p (pX a pO). intros a p; case p; auto. intros b l H'. apply ltP_hd; auto. apply olist_pX_order with (l := l); auto. Qed. Theorem ltP_pX_olist : forall a p, olist p -> ltP p (pX a pO) -> olist (pX a p). intros a p; case p; auto. intros H' H'1; unfold olist, DescA, consA in |- *; simpl in |- *; unfold consA, nilA in |- *. apply d_one; auto. intros b l H' H'0. apply olist_cons; auto. simple inversion H'0. discriminate H. injection H1; injection H0; intros H'1 H'2 H'3 H'4; (rewrite H'2; rewrite H'4); auto. injection H2; intros H'1 H'2; rewrite H'1; auto. unfold pO in |- *; intros H'3 H'4; inversion H'4. Qed.Theorem ltP_order_comp : forall (a b c : Term A n) (p q : list (Term A n)), ltP (pX b p) (pX a q) -> ltT a c -> ltT b c. intros a b c p q H1; inversion_clear H1. intros; apply ltT_trans with (y := a); auto. apply eqT_compat_ltTl. apply eqT_sym; trivial. Qed. Hint Resolve ltP_order_comp. Set Implicit Arguments. Unset Strict Implicit. Definition nZterm : list (Term A n) -> Prop. intros H'; elim H'. exact True. intros a P1 Rec. exact (Rec /\ ~ zeroP (A:=A) A0 eqA (n:=n) a). Defined. Definition canonical (a : list (Term A n)) : Prop := olist a /\ nZterm a. Set Strict Implicit. Unset Implicit Arguments. Theorem canonical_imp_olist : forall a, canonical a -> olist a. 
n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) Z0) (pX a0 l)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) Z1) (pX a1 l0))); auto. apply CombLinear_minuspf with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. apply spolyf_canonical with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. change (eqP A eqA n (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX a0 l) (pX a1 l0) H' H'0) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) Z0) (pX a0 l)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) Z1) (pX a1 l0)))) in |- *. apply spoly_is_minus with (1 := cs); auto. Qed. Definition unit : poly A0 eqA ltM -> Term A n. intros p; case p. intros x; case x. intros H'; exact (T1 A1 n). intros a l; case a. intros co m H'; cut (~ eqA co A0). intros H'0; exact (divA A1 co H'0, M1 n). inversion H'; auto. simpl in H0. intuition. Defined. Theorem unit_T1 : forall p : poly A0 eqA ltM, eqT (unit p) (T1 A1 n). unfold eqT in |- *; intros p; case p. intros x; case x; simpl in |- *; auto. intros a l; case a; simpl in |- *; auto. Qed. Theorem divA_nZ : forall a b : A, ~ eqA b A0 -> forall nZa : ~ eqA a A0, ~ eqA (divA b a nZa) A0. intros a b H' nZa; red in |- *; intros H'1; auto. case H'; apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA (divA b a nZa) a); auto. apply divA_is_multA with (1 := cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA A0 a); auto. apply multA_eqA_comp with (1 := cs); auto. apply (eqA_ref _ _ _ _ _ _ _ _ _ cs); auto. apply multA_A0_l with (1 := cs); auto. Qed. Hint Resolve divA_nZ. Theorem unit_nZ : forall p : poly A0 eqA ltM, ~ zeroP (A:=A) A0 eqA (n:=n) (unit p). 
replace (svi_index (parties (ctx_from ctx))) with (voter_index v0) by congruence. easy. * rewrite FMap.find_add_ne in find_add by auto. auto. + destruct (_ <? _) eqn:intime; cbn in *; [congruence|]. destruct (tally prev_state); cbn in *; [congruence|]. destruct (existsb _ _) eqn:all_voted; cbn in *; [congruence|]. destruct (bruteforce_tally _) eqn:bruteforce; cbn -[Nat.ltb] in *; [|congruence]. inversion_clear receive_some; cbn. apply Nat.ltb_ge in intime. split; [lia|]. split; [intros; lia|]. split; [tauto|]. split; [tauto|]. split; [tauto|]. intros (_ & msg_assum) order_assum num_signups_assum. split; [tauto|]. split; [tauto|]. split; [tauto|]. split; [easy|]. intros _. apply f_equal. destruct IH as (finish_before_vote & _ & len_pks & pks_signups & party_count & IH). specialize (IH msg_assum order_assum num_signups_assum). destruct IH as (perm & perm' & addrs & _). unfold AddressMap.values in *. unfold FMap.values in bruteforce. rewrite map_map in bruteforce. rewrite (map_ext_in _ (fun '(_, v) => public_vote v)) in bruteforce by (now intros []). rewrite (bruteforce_tally_correct (FMap.elements (registered_voters prev_state)) (fun '(_, v) => voter_index v) (fun '(addr, _) => svi_sk (parties addr)) (public_keys prev_state) (fun kvp => svi_sv (parties (fst kvp))) (fun '(_, v) => public_vote v)) in bruteforce. * inversion bruteforce. rewrite <- (sumnat_map fst (fun a => if svi_sv (parties a) then 1 else 0))%nat. now setoid_rewrite perm'. * now rewrite FMap.length_elements, <- len_pks. * now rewrite FMap.length_elements, <- len_pks. * auto. * intros [k v] kvpin. apply FMap.In_elements in kvpin. specialize (addrs _ _ kvpin). tauto. * intros [k v] kvpin. rewrite existsb_forallb in all_voted. apply Bool.negb_false_iff in all_voted. rewrite forallb_forall in all_voted. unshelve epose proof (all_voted v _) as all_voted. { apply in_map_iff. exists (k, v). tauto. } apply Bool.negb_true_iff in all_voted. destruct (elmeqb_spec (public_vote v) zero); [congruence|]. apply FMap.In_elements in kvpin. specialize (addrs _ _ kvpin). cbn. destruct addrs as (_ & _ & _ & []); [easy|]. fold (signups prev_inc_calls) (SignupOrderAssumption pks parties prev_inc_calls) in *. rewrite pks_signups. specialize (num_signups_assum ltac:(lia)). now rewrite (all_signups pks parties) by auto. - [CallFacts]: exact (fun _ ctx _ _ _ => ctx_from ctx <> ctx_contract_address ctx). subst CallFacts; cbn in *; congruence. - auto. - [DeployFacts]: exact (fun _ _ => True). unset_all; subst; cbn in *. destruct_chain_step; auto. + destruct valid_header; auto. + destruct_action_eval; auto. intros. apply trace_reachable in from_reachable. pose proof (no_outgoing _ _ from_reachable H0). unfold outgoing_acts in H2. rewrite queue_prev in H2. cbn in H2. destruct (address_eqb_spec (act_from act) to_addr); cbn in *; try congruence. subst. cbn in *. congruence. Qed. Theorem boardroom_voting_correct (bstate : ChainState) (caddr : Address) (trace : ChainTrace empty_state bstate) (pks : list A) (parties : Address -> SecretVoterInfo) : env_contracts bstate caddr = Some (boardroom_voting : WeakContract) -> exists (cstate : State) (depinfo : DeploymentInfo Setup) (inc_calls : list (ContractCallInfo Msg)), deployment_info Setup trace caddr = Some depinfo /\ contract_state bstate caddr = Some cstate /\ incoming_calls Msg trace caddr = Some inc_calls /\ MsgAssumption pks parties inc_calls -> SignupOrderAssumption pks parties inc_calls -> (finish_registration_by (setup cstate) < Blockchain.current_slot bstate -> length pks = length (signups inc_calls)) -> ((has_tallied inc_calls = false -> tally cstate = None) /\ (has_tallied inc_calls = true -> tally cstate = Some (sumnat (fun party => if svi_sv (parties party) then 1 else 0)%nat (map fst (signups inc_calls))))). 
v as [w | a]; simpl in *. { econstructor; intuition. unfold word_scalar_match; simpl. specialize (Hst k (SCA _ w)). rewrite add_eq_o in Hst by eauto. specialize (Hst eq_refl). eapply Hr in Hst. simpl in *. eauto. } { econstructor; intuition. unfold word_scalar_match; simpl. eauto. } Qed. Require Import Bedrock.Platform.Cito.WordMapFacts. Lemma prog_runsto cenv stmt cst cst' stn fs v1 v2 w1 w2 : RunsTo cenv stmt cst cst' -> env_good_to_use modules imports stn fs -> fst cenv = from_bedrock_label_map (Labels stn) -> snd cenv = fs stn -> stmt = Compile.compile (CompileDFacade.compile prog) -> pre_cond v1 v2 -> disjoint_ptrs {(w1, v1); (w2, v2)} -> good_scalars {(w1, v1); (w2, v2)} -> w1 = Locals.sel (fst cst) argvar1 -> w2 = Locals.sel (fst cst) argvar2 -> snd cst == make_heap {(w1, v1); (w2, v2)} -> exists vr, let wr := Locals.sel (fst cst') retvar in let pairs := {(wr, vr)} in post_cond v1 v2 vr /\ snd cst' == make_heap pairs /\ disjoint_ptrs pairs /\ good_scalars pairs. Proof. destruct cenv as [l2w w2spec]; simpl in *. destruct cst as [vs h]; simpl in *. destruct cst' as [vs' h']; simpl in *. intros Hrt Hegtu ? ? ? Hpre Hdisj Hgs ? ? Hheq. subst. eapply CompileDFacadeToCito.compile_runsto in Hrt; try reflexivity; simpl in *; trivial. destruct Hrt as [st' [Hrt [Hsm [Hseleq Hr] ] ] ]. 6 : eapply env_good_to_use_cenv_impls_env; eauto. 2 : eapply unit_syntax_ok. Focus 3. { eapply make_map_make_heap_related with (ks := argvars); eauto; simpl in *. reflexivity. eauto. eauto. } Unfocus. simpl in *. { eapply dfacade_runsto in Hrt; eauto. 2 : reflexivity. destruct Hrt as [ret [Hst' [Hnoleak Hpost] ] ]. eapply make_map_related_make_heap_singleton in Hr. { destruct Hr as [Hh' [Hgs' Hdisj'] ]. exists ret. repeat try_split. - eauto. - eapply Hh'. - eauto. - eauto. } { instantiate (1 := ret). instantiate (1 := retvar). eauto. } { intros k Hnin. eauto. } { reflexivity. } { reflexivity. } { simpl. rewrite diff_same. rewrite diff_empty. reflexivity. } { eauto. } } { eapply submap_refl. } { eauto. } { eapply dfacade_safe; eauto. reflexivity. } Qed. Import Made. Definition output_module := bimport [[ (module_name!fun_name, spec_op_b) ]] bmodule export_module_name {{ bfunction fun_name(argvar1, argvar2, "R") [compileS pre_cond post_cond] "R" <-- Call module_name!fun_name(extra_stack, argvar1, argvar2) [PRE[_, R] Emp POST[R'] [| R' = R |] ];; Return "R" end }}. Require Import Bedrock.Platform.AutoSep. Require Import Bedrock.Platform.Cito.GeneralTactics3. Opaque mult. Import LinkMake.StubsMake.StubMake.LinkSpecMake2.CompileFuncSpecMake.InvMake. Require Import Bedrock.sep.Locals. Theorem is_state_in2 : forall vs sp args e_stack h F, locals ("rp" :: "extra_stack" :: args) vs e_stack sp * is_heap h * mallocHeap 0 * F ===> is_state sp (Locals.sel vs "rp") (wordToNat (Locals.sel vs "extra_stack")) e_stack args (vs, h) nil * mallocHeap 0 * F. 
e1; do (te2, a2) <- transl_expr cenv e2; OK (make_store chunk te1 te2) | Csharpminor.Scall optid sig e el => do (te, a) <- transl_expr cenv e; do tel <- transl_exprlist cenv el; OK (Scall optid sig te tel) | Csharpminor.Sbuiltin optid ef el => do tel <- transl_exprlist cenv el; OK (Sbuiltin optid ef tel) | Csharpminor.Sseq s1 s2 => do ts1 <- transl_stmt cenv xenv s1; do ts2 <- transl_stmt cenv xenv s2; OK (Sseq ts1 ts2) | Csharpminor.Sifthenelse e s1 s2 => do (te, a) <- transl_expr cenv e; do ts1 <- transl_stmt cenv xenv s1; do ts2 <- transl_stmt cenv xenv s2; OK (Sifthenelse te ts1 ts2) | Csharpminor.Sloop s => do ts <- transl_stmt cenv xenv s; OK (Sloop ts) | Csharpminor.Sblock s => do ts <- transl_stmt cenv (true :: xenv) s; OK (Sblock ts) | Csharpminor.Sexit n => OK (Sexit (shift_exit xenv n)) | Csharpminor.Sswitch e ls => let cases := switch_table ls O in let default := length cases in do (te, a) <- transl_expr cenv e; transl_lblstmt cenv (switch_env ls xenv) ls (Sswitch te cases default) | Csharpminor.Sreturn None => OK (Sreturn None) | Csharpminor.Sreturn (Some e) => do (te, a) <- transl_expr cenv e; OK (Sreturn (Some te)) | Csharpminor.Slabel lbl s => do ts <- transl_stmt cenv xenv s; OK (Slabel lbl ts) | Csharpminor.Sgoto lbl => OK (Sgoto lbl) endwith transl_lblstmt (cenv: compilenv) (xenv: exit_env) (ls: Csharpminor.lbl_stmt) (body: stmt) {struct ls}: res stmt := match ls with | Csharpminor.LSdefault s => do ts <- transl_stmt cenv xenv s; OK (Sseq (Sblock body) ts) | Csharpminor.LScase _ s ls' => do ts <- transl_stmt cenv xenv s; transl_lblstmt cenv (List.tail xenv) ls' (Sseq (Sblock body) ts) end.Definition block_alignment (sz: Z) : Z := if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8.Definition assign_variable (cenv_stacksize: compilenv * Z) (id_sz: ident * Z) : compilenv * Z := let (id, sz) := id_sz in let (cenv, stacksize) := cenv_stacksize in let ofs := align stacksize (block_alignment sz) in (PTree.set id ofs cenv, ofs + Zmax 0 sz).Definition assign_variables (cenv_stacksize: compilenv * Z) (vars: list (ident * Z)) : compilenv * Z := List.fold_left assign_variable vars cenv_stacksize.Module VarOrder <: TotalLeBool. Definition t := (ident * Z)%type. Definition leb (v1 v2: t) : bool := zle (snd v1) (snd v2). Theorem leb_total: forall v1 v2, leb v1 v2 = true \/ leb v2 v1 = true. 
(pœÉ2&pg2&Hrtc''&Hcompat_impl&Hgcompat_impl); eauto. exists pœÉ2, pg2. split; first by eauto. split; first by eauto. destruct (global_compat_match_eq _ _ _ Hgcompat Hgcompat1'). eauto. } eapply Hsafe in Hstep as Hnstuck. intros Hstuck. apply Hnstuck. eapply stuck'_transport in Hstuck; eauto. Qed. Theorem head_step_atomic_simulation_rev e1 (pœÉ1 : pstate) pg1 Œ∫ pœÉ2 pg2 efs œÉ1 g1 e2 : ADP.all_synced (world pœÉ1) ‚Üí head_step_atomic e1 pœÉ1 pg1 Œ∫ e2 pœÉ2 pg2 efs ‚Üí state_compat œÉ1 pœÉ1 ‚Üí global_compat g1 pg1 ‚Üí ‚àÉ œÉ2 g2 e2', head_step_atomic e1 œÉ1 g1 Œ∫ e2' œÉ2 g2 efs ‚àß ((e2 = e1 ‚àß efs = [] ‚àß pœÉ2 = pœÉ1 ‚àß pg2 = pg1) ‚à® (e2 = e2' ‚àß state_compat œÉ2 pœÉ2 ‚àß global_compat g2 pg2)). Proof. intros Hsynced Hprim. inversion Hprim; subst. - intros. edestruct (head_step_simulation_rev) as (?&?&?&?&Hcases); eauto. do 3 eexists. split_and!; eauto. econstructor; eauto. - intros. edestruct (prim_step'_rtc_simulation_rev) as (?&?&?&?); eauto. do 3 eexists. split_and!; intuition eauto. apply head_step_atomically; eauto. { eapply prim_step'_safe_transport_rev; eauto. } - intros. do 3 eexists. split_and!; eauto. eapply head_step_atomically_fail. { eapply prim_step'_safe_transport_rev; eauto. } Qed. Theorem prim_step_simulation e1 œÉ1 g1 Œ∫ e2 œÉ2 g2 efs : prim_step e1 œÉ1 g1 Œ∫ e2 œÉ2 g2 efs ‚Üí ‚àÄ pg2 pœÉ2, state_compat œÉ2 pœÉ2 ‚Üí global_compat g2 pg2 ‚Üí ‚àÉ pœÉ1 pg1, state_compat œÉ1 pœÉ1 ‚àß global_compat g1 pg1 ‚àß @prim_step (@goose_lang _ _ ADP.disk_semantics) e1 pœÉ1 pg1 Œ∫ e2 pœÉ2 pg2 efs. Proof. intros Hprim. inversion Hprim. simpl in *. intros. edestruct (head_step_atomic_simulation) as (?&?&?&?); eauto. do 2 eexists; split_and!; intuition eauto. econstructor; eauto. Qed. Theorem step_simulation t1 œÉ1 g1 Œ∫ t2 œÉ2 g2: step (t1, (œÉ1, g1)) Œ∫ (t2, (œÉ2, g2)) ‚Üí ‚àÄ pg2 pœÉ2, state_compat œÉ2 pœÉ2 ‚Üí global_compat g2 pg2 ‚Üí ‚àÉ pœÉ1 pg1, state_compat œÉ1 pœÉ1 ‚àß global_compat g1 pg1 ‚àß @step (@goose_lang _ _ ADP.disk_semantics) (t1, (pœÉ1, pg1)) Œ∫ (t2, (pœÉ2, pg2)). Proof. intros Hstep. inversion Hstep. simpl in *. monad_inv. intros. edestruct (prim_step_simulation) as (?&?&?&?); eauto. do 2 eexists; split_and!; intuition eauto. econstructor; eauto. Qed. Theorem erased_step_simulation t1 œÉ1 g1 t2 œÉ2 g2: erased_step (t1, (œÉ1, g1)) (t2, (œÉ2, g2)) ‚Üí ‚àÄ pg2 pœÉ2, state_compat œÉ2 pœÉ2 ‚Üí global_compat g2 pg2 ‚Üí ‚àÉ pœÉ1 pg1, state_compat œÉ1 pœÉ1 ‚àß global_compat g1 pg1 ‚àß @erased_step (@goose_lang _ _ ADP.disk_semantics) (t1, (pœÉ1, pg1)) (t2, (pœÉ2, pg2)). Proof. intros Hstep. inversion Hstep. simpl in *. intros. edestruct (step_simulation) as (?&?&?&?); eauto. do 2 eexists; split_and!; intuition eauto. econstructor; eauto. Qed. Theorem rtc_erased_step_simulation t1 œÉ1 g1 t2 œÉ2 g2: rtc erased_step (t1, (œÉ1, g1)) (t2, (œÉ2, g2)) ‚Üí ‚àÄ pg2 pœÉ2, state_compat œÉ2 pœÉ2 ‚Üí global_compat g2 pg2 ‚Üí ‚àÉ pœÉ1 pg1, state_compat œÉ1 pœÉ1 ‚àß global_compat g1 pg1 ‚àß rtc (@erased_step (@goose_lang _ _ ADP.disk_semantics)) (t1, (pœÉ1, pg1)) (t2, (pœÉ2, pg2)). 
| [ H : ?X -> _ , H' : ?X |- _ ] => apply H in H'; clear H end; propxFo; repeat match goal with | [ |- exists x, _ ] => eexists | [ |- _ /\ _ ] => split | [ |- simplify _ _ _ ] => eassumption || apply simplify_fwd | [ H : interp ?X (?Y _) |- interp ?X (?Y _) ] => eapply H end. unfold himp, heq; simpl; intros; repeat match goal with | [ H : _ -> _ |- _ ] => apply H; clear H | [ H : forall x, _ -> _ , H' : _ |- _ ] => apply H in H' | [ H : ?X -> _ , H' : ?X |- _ ] => apply H in H'; clear H end; propxFo; repeat match goal with | [ |- exists x, _ ] => eexists | [ |- _ /\ _ ] => split | [ |- simplify _ _ _ ] => eassumption || apply simplify_fwd | [ H : interp ?X (?Y _) |- interp ?X (?Y _) ] => eapply H end. *) Import PropXRel. Hint Immediate HT.split_comm : heaps. Hint Resolve HT.split_assoc HT.disjoint_split_join HT.split_split_disjoint : heaps. Lemma himp_star_comm : forall P Q, himp (star P Q) (star Q P). Proof. unfold star, himp, interp; intros; propxIntuition; eauto with heaps. Qed. Theorem heq_star_comm : forall P Q, heq (star P Q) (star Q P). Proof. intros. unfold heq. generalize himp_star_comm. intuition. Qed. Theorem himp_star_assoc : forall P Q R, himp (star (star P Q) R) (star P (star Q R)). Proof. unfold star, himp, interp; intros; propxIntuition. eapply HT.split_comm. eapply HT.split_assoc. eapply HT.split_comm. eassumption. eapply HT.split_comm. eassumption. eapply HT.disjoint_split_join. eapply HT.disjoint_comm. eauto with heaps. Qed. Theorem heq_star_assoc : forall P Q R, heq (star (star P Q) R) (star P (star Q R)). Proof. split. eapply himp_star_assoc. unfold star, himp, interp; intros; propxIntuition. eapply HT.split_assoc. eassumption. eassumption. eapply HT.split_comm. eapply HT.disjoint_split_join. eapply HT.disjoint_comm. eapply HT.split_split_disjoint. 2: eassumption. eauto with heaps. Qed. Theorem himp_star_frame : forall P Q R S, himp P Q -> himp R S -> himp (star P R) (star Q S). Proof. unfold himp, star, interp; intros; propxIntuition. Focus 2. eapply Imply_E. eapply valid_weaken. eapply H. firstorder. econstructor; firstorder. Focus 2. eapply Imply_E. eapply valid_weaken. eapply H0. firstorder. econstructor; firstorder. eauto. Qed. Theorem heq_star_frame : forall P Q R S, heq P Q -> heq R S -> heq (star P R) (star Q S). 
Require Import Coq.Classes.RelationClasses. Require Import Coq.Setoids.Setoid.Set Implicit Arguments. Set Strict Implicit. Set Asymmetric Patterns.Section parametric. Variable T : Type. Variable R : T -> T -> Prop. Inductive makeRefl (x : T) : T -> Prop := | RRefl : makeRefl x x | RStep : forall y, R x y -> makeRefl x y. Global Instance Refl_makeRefl : Reflexive makeRefl. Proof. constructor. Qed. Global Instance Refl_makeTrans : Transitive R -> Transitive makeRefl. Proof. intro. intro. intros. inversion H0; clear H0; subst; auto. inversion H1; clear H1; subst; auto using RStep. apply RStep. etransitivity; eauto. Qed. Inductive makeTrans (x y : T) : Prop := | TStep : R x y -> makeTrans x y | TTrans : forall z, makeTrans x z -> makeTrans z y -> makeTrans x y. Global Instance Trans_makeTrans : Transitive makeTrans. Proof. intro. intros; eapply TTrans; eassumption. Qed. Global Instance Trans_makeRefl : Reflexive R -> Reflexive makeTrans. Proof. intro. intro. apply TStep. reflexivity. Qed. Inductive leftTrans (x y : T) : Prop := | LTFin : R x y -> leftTrans x y | LTStep : forall z, R x z -> leftTrans z y -> leftTrans x y. Inductive rightTrans (x y : T) : Prop := | RTFin : R x y -> rightTrans x y | RTStep : forall z, rightTrans x z -> R z y -> rightTrans x y. Fixpoint leftTrans_rightTrans_acc x y (l : leftTrans y x) : forall z, rightTrans z y -> rightTrans z x := match l with | LTFin pf => fun z pfR => RTStep pfR pf | LTStep _ pf pfL => fun z pfR => leftTrans_rightTrans_acc pfL (RTStep pfR pf) end. Fixpoint rightTrans_leftTrans_acc x y (l : rightTrans x y) : forall z, leftTrans y z -> leftTrans x z := match l with | RTFin pf => fun z pfR => LTStep pf pfR | RTStep _ pf pfL => fun z pfR => rightTrans_leftTrans_acc pf (LTStep pfL pfR) end. Theorem leftTrans_rightTrans : forall x y, leftTrans x y <-> rightTrans x y. 
elim l; simpl in |- *; auto. intros (a1, n1) l1 Rec H; case (eqA_dec a a1). intros e; apply unique_key_perm with (l1 := (a, S n1) :: l1); auto. apply unique_key_cons; auto. intros b; red in |- *; intros H0; case (unique_key_in _ _ _ _ b _ H); auto. rewrite <- e; auto. apply unique_key_inv with (1 := H); auto. intros n; apply unique_key_cons; auto. intros b; red in |- *; intros H0; case add_frequency_list_in_inv with (1 := H0); auto. intros H2; case (unique_key_in _ _ _ _ b _ H); auto. apply Rec; apply unique_key_inv with (1 := H); auto. Qed. Theorem add_frequency_list_1 : forall a l, (forall ca, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l). Proof using. intros a l; generalize a; elim l; clear a l; simpl in |- *; auto. intros (a1, l1) l0 H a H0. case (eqA_dec a a1); auto. intros H1; case (H0 l1); left; apply f_equal2 with (f := pair (A:=A) (B:=nat)); auto. intros n; apply in_cons; auto; apply H; auto. intros ca; red in |- *; intros H1; case (H0 ca); auto. Qed. Theorem add_frequency_list_in : forall m a n, unique_key m -> In (a, n) m -> In (a, S n) (add_frequency_list a m). Proof using. intros m; elim m; clear m; simpl in |- *; auto. intros (a1, l1) l Rec a n H H1; case (eqA_dec a a1); simpl in |- *; auto. intros H2; case H1; auto. intros H3; left; apply f_equal2 with (f := pair (A:=A) (B:=nat)); injection H3; auto. rewrite H2; intros H3; case unique_key_in with (1 := H) (b2 := n); auto. intros n0; right; apply Rec. apply unique_key_inv with (1 := H); auto. case H1; auto. intros H0; case n0; injection H0; auto. Qed. Theorem add_frequency_list_not_in : forall m a b n, a <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m). Proof using. intros m; elim m; clear m; simpl in |- *; auto. intros (a1, l1) l H a0 b n H0 [H1| H1]; case (eqA_dec b a1); simpl in |- *; auto. intros H2; case H0; injection H1; auto. intros; apply trans_equal with (2 := sym_equal H2); auto. Qed. Fixpoint frequency_list (l : list A) : list (A * nat) := match l with | nil => nil | a :: l1 => add_frequency_list a (frequency_list l1) end. Theorem frequency_list_in : forall a n m, In (a, n) (frequency_list m) -> In a m. 
From Undecidability.Synthetic Require Import Undecidability ReducibilityFacts.Require Import Undecidability.LambdaCalculus.wCBN. From Undecidability.LambdaCalculus.Reductions Require HaltLclosed_to_wCBNclosed wCBNclosed_to_wCBN.Require Import Undecidability.L.L_undec. Require Undecidability.L.Reductions.HaltL_to_HaltLclosed. Theorem wCBNclosed_undec : undecidable wCBNclosed. 
) ( pr1 ab1 ) ) ( eqax1 isb _ _ ( pr2 rq ) ( pr2 ab1 ) ) ) . assert ( ax2 : forall xy1 xy2 : XY , AB xy1 -> AB xy2 -> RQ xy1 xy2 ) . intros xy1 xy2 ab1 ab2 . apply ( dirprodpair ( eqax2 isa _ _ ( pr1 ab1 ) ( pr1 ab2 ) ) ( eqax2 isb _ _ ( pr2 ab1 ) ( pr2 ab2 ) ) ) . apply ( iseqclassconstr _ ax0 ax1 ax2 ) . Defined . Definition image { X Y : UU } ( f : X -> Y ) := total2 ( fun y : Y => ishinh ( hfiber f y ) ) . Definition imagepair { X Y : UU } (f: X -> Y) := tpair ( fun y : Y => ishinh ( hfiber f y ) ) . Definition pr1image { X Y : UU } ( f : X -> Y ) := @pr1 _ ( fun y : Y => ishinh ( hfiber f y ) ) . Definition prtoimage { X Y : UU } (f : X -> Y) : X -> image f. Proof. intros X Y f X0. apply (imagepair _ (f X0) (hinhpr _ (hfiberpair f X0 (idpath _ )))). Defined. Definition issurjective { X Y : UU } (f : X -> Y ) := forall y:Y, ishinh (hfiber f y). Lemma isapropissurjective { X Y : UU } ( f : X -> Y) : isaprop (issurjective f). Proof. intros. apply impred. intro t. apply (pr2 (ishinh (hfiber f t))). Defined. Lemma isinclpr1image { X Y : UU } (f:X -> Y): isincl (pr1image f). Proof. intros. apply isofhlevelfpr1. intro. apply ( pr2 ( ishinh ( hfiber f x ) ) ) . Defined.Lemma issurjprtoimage { X Y : UU } ( f : X -> Y) : issurjective (prtoimage f ). Proof. intros. intro z. set (f' := prtoimage f ). set (g:= pr1image f ). set (gf':= fun x:_ => g ( f' x )). assert (e: paths f gf'). apply etacorrection . assert (ff: hfiber gf' (pr1 z) -> hfiber f' z). apply ( invweq ( samehfibers _ _ ( isinclpr1image f ) z ) ) . assert (is2: ishinh (hfiber gf' (pr1 z))). destruct e. apply (pr2 z). apply (hinhfun ff is2). Defined. Theorem surjectionisepitosets { X Y Z : UU } ( f : X -> Y ) ( g1 g2 : Y -> Z ) ( is1 : issurjective f ) ( is2 : isaset Z ) ( isf : forall x : X , paths ( g1 ( f x ) ) ( g2 ( f x ) ) ) : forall y : Y , paths ( g1 y ) ( g2 y ) . 
{tl:list A | l = x::tl}}+{l = []}. Proof. induction l as [|a tail]. right; reflexivity. left; exists a, tail; reflexivity. Qed. Lemma hd_error_tl_repr : forall l (a:A) r, hd_error l = Some a /\ tl l = r <-> l = a :: r. Proof. destruct l as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. Proof. unfold not; intros a H; inversion_clear H. Qed. Theorem in_split : forall x (l:list A), In x l -> exists l1 l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists [], l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Qed. Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem in_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl; auto. destruct IHl; simpl; auto. right; unfold not; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), [] <> x ++ a :: y. Proof. unfold not. destruct x as [| a l]; simpl; intros. discriminate H. discriminate H. Qed. Theorem app_nil_l : forall l:list A, [] ++ l = l. 
proof (same_except_cur_jm_ _ _ _ _ _ cnti compat). unfold install_perm; simpl in H0. auto. clear - compat. inv compat; constructor; auto. rewrite join_all_res; auto. } assert (B : rmap_bound (Mem.nextblock m) Phi) by apply compat. right. apply state_invariant_c with (mcompat := Hcmpt'); auto. - intro; simpl. pose proof (lock_coh loc) as lock_coh'. destruct (AMap.find _ _) eqn: Hloc; auto. assert (forall v, load_at (restrPermMap (mem_compatible_locks_ltwritable (mem_compatible_forget compat))) loc = Some v -> load_at (restrPermMap (mem_compatible_locks_ltwritable (mem_compatible_forget Hcmpt'))) loc = Some v). { intro. unfold load_at; intro Hload. apply lock_coh_bound in lock_coh. specialize (lock_coh loc). setoid_rewrite Hloc in lock_coh; spec lock_coh; [simpl; auto|]. unfold load in *. destruct (valid_access_dec (restrPermMap (mem_compatible_locks_ltwritable (mem_compatible_forget compat))) _ _ _ _); [|discriminate]. hnf in Hperm; subst. rewrite if_true; auto. { unfold install_perm, juicyRestrict. destruct v0; split; auto. apply Mem.range_perm_implies with Writable; [|constructor]. destruct loc as (?, ofs). repeat intro. eapply lset_range_perm with (ofs := ofs); eauto. destruct (AMap.find (elt:=option rmap) _ _); discriminate. { lkomega. } } } destruct o. + destruct lock_coh' as (? & ? & ? & ? & ? & ?); eauto 7. + destruct lock_coh' as (? & ? & ? & ? & ?); eauto 6. - intros j cntj []. destruct (eq_dec i j) as [<-|ne]. + REWR. apply safety. rewrite m_phi_jm_. REWR. + REWR. specialize (safety' j cntj tt). destruct (getThreadC j tp cntj) eqn: Ej; try solve [erewrite gsoThreadRes; eauto]. pose proof cntUpdate'(ThreadPool := OrdinalThreadPool) _ _ cnti cntj as cntj'. eapply unique_Krun_neq in Ej; try apply unique; auto; contradiction. { destruct safety' as [Hvalid' ?]. split; [|erewrite gsoThreadRes; eauto]. eapply val_inject_incr, Hvalid'. hnf in Hperm; subst; simpl. apply flat_inj_incr. apply Pos.le_refl. } - intros j cntj. destruct (eq_dec i j) as [<-|ne]; REWR. specialize (wellformed j cntj). auto. - intros more j cntj q. destruct (eq_dec i j) as [<-|ne]; REWR. + simpl; eauto. + intros Ej. specialize (unique more j cntj q Ej). auto. * inv Htstep. rename m' into m. pose proof safety as safety'. specialize (safety i cnti tt). rewr (getThreadC i tp cnti) in safety. destruct safety as (c_new_ & E_c_new & safety). getThread_inv; congruence. * jmstep_inv. getThread_inv; congruence. * inv Htstep. rename m' into m. pose proof safety as safety'. specialize (safety i cnti tt). rewr (getThreadC i tp cnti) in safety. destruct safety as (c_new_ & E_c_new & safety). getThread_inv; congruence. * jmstep_inv; getThread_inv; congruence.* contradiction Htid. Qed. Theorem preservation ge Gamma n state state' : ~ blocked_at_external state CREATE -> ~ blocked_at_external state MKLOCK -> ~ blocked_at_external state FREE_LOCK -> ~ blocked_at_external state UNLOCK -> state_step state state' -> state_invariant Jspec' Gamma (S n) state -> state_bupd(ge := ge) (state_invariant Jspec' Gamma n) state' \/ state_bupd(ge := ge) (state_invariant Jspec' Gamma (S n)) state'. 
in let (vs,ren) := x in bterm vs (lsubst_vs (vars ++ vs) nt (ren ++ s)) end. Definition csubst {p} (t : @NTerm p) (sub : CSubstitution) := lsubst t (csub2sub sub).Lemma fold_csubst {p} : forall t sub, lsubst t (@csub2sub p sub) = csubst t sub. Proof. sp. Qed.Lemma csubst_mk_axiom {p} : forall sub, @csubst p mk_axiom sub = mk_axiom. Proof. sp. Qed.Lemma csubst_mk_uni {p} : forall i sub, @csubst p (mk_uni i) sub = mk_uni i. Proof. sp. Qed.Lemma csubst_mk_base {p} : forall sub, @csubst p mk_base sub = mk_base. Proof. sp. Qed.Lemma lsubst_aux_nil {p} : forall t, @lsubst_aux p t [] = t. Proof. nterm_ind t Case; simpl; auto. assert (map (fun t : BTerm => lsubst_bterm_aux t []) lbt = lbt); try (rw H0; auto). induction lbt; simpl; auto. rw IHlbt; auto. destruct a; simpl. f_equal; sp. f_equal; sp. eapply H; eauto. left; auto. intros. eapply H; eauto. right;sp. eauto. Qed. Lemma lsubst_nil {p} : forall t, @lsubst p t [] = t. Proof. intros. unfold lsubst. simpl. cases_if. - apply lsubst_aux_nil. - disjoint_reasoning. Qed.Hint Rewrite @lsubst_nil.Lemma csubst_nil {p} : forall t, @csubst p t [] = t. Proof. unfold csubst; simpl; sp. rw @lsubst_nil; sp. Qed.Hint Rewrite @csubst_nil.Lemma lsubst_aux_trivial {p} : forall t sub, (forall v u, LIn (v, u) sub -> @isprogram p u # ! LIn v (free_vars t)) -> lsubst_aux t sub = t. Proof. unfold lsubst. nterm_ind t as [|f ind|op lbt ind] Case; simpl; introv imp; auto. - Case "vterm". allunfold @isprogram; allunfold @closed; sp. remember (sub_find sub n); destruct o; symmetry in Heqo; auto. apply sub_find_some in Heqo. apply_in_hyp pp; sp. allrw not_over_or; sp. - Case "oterm". assert (map (fun t : BTerm => lsubst_bterm_aux t sub) lbt = lbt) as eq; try (rw eq; auto). induction lbt; simpl; auto. rw IHlbt; sp. + destruct a; simpl. f_equal. f_equal. rewrite ind with (lv := l); sp. allrw @in_sub_filter; sp. apply_in_hyp pp; sp. allrw @in_sub_filter; sp. apply_in_hyp pp; sp; allsimpl. allrw in_app_iff. allrw not_over_or; sp. allrw in_remove_nvars; sp. + rewrite ind with (lv := lv); sp. + apply_in_hyp pp; sp. + apply_in_hyp pp; sp; allsimpl. allrw in_app_iff. allrw not_over_or; sp. Qed.Lemma prog_sub_flatmap_range {p} : forall sub, @prog_sub p sub -> flat_map free_vars (range sub) =[]. Proof. unfold prog_sub, isprogram,closed . introv Hps. apply flat_map_empty. cpx. introv Hin. rw in_map_iff in Hin. exrepnd. subst. simpl. apply Hps in Hin1. cpx. Qed. Theorem dom_range_is_split_snd {p} : forall sub, @range p sub = snd (split sub). 
zarith. rewrite <- Zabs_Zmult. rewrite (fun x => Zabs_eq (Zabs x)); auto with float zarith. Qed. Definition pPred x := Zpred (Zpos x). Theorem maxMax1 : forall (p : float) (z : Z), Fbounded b p -> (Fexp p <= z)%Z -> (Fabs p <= Float (pPred (vNum b)) z)%R. intros p z H H0; unfold FtoRradix in |- *. rewrite <- (FshiftCorrect _ radixMoreThanOne (Zabs_nat (z - Fexp p)) (Float (pPred (vNum b)) z)). unfold FtoR, Fabs in |- *; simpl in |- *; auto with zarith. rewrite Rmult_IZR; rewrite Zpower_nat_Z_powerRZ; auto with zarith. repeat rewrite inj_abs; auto with zarith. replace (z - (z - Fexp p))%Z with (Fexp p); [ idtac | ring ]. rewrite Rmult_assoc; rewrite <- powerRZ_add; auto with real zarith. replace (z - Fexp p + Fexp p)%Z with z; [ idtac | ring ]. apply Rle_trans with (pPred (vNum b) * powerRZ radix (Fexp p))%R. apply Rle_monotone_exp; auto with zarith; repeat rewrite Rmult_IZR; apply Rle_IZR; unfold pPred in |- *; apply Zle_Zpred; auto with float real zarith. apply Rmult_le_compat_l; auto with real zarith. replace 0%R with (IZR 0); auto with real; apply Rle_IZR; unfold pPred in |- *; apply Zle_Zpred; auto with float zarith. apply Rle_powerRZ; auto with float real zarith. Qed. Theorem FnormalBoundAbs : forall p : float, Fnormal p -> (Float (pPred (vNum b)) (Zpred (Fexp p)) < Fabs p)%R. intros p H'; unfold FtoRradix, FtoR in |- *; simpl in |- *. pattern (Fexp p) at 2 in |- *; replace (Fexp p) with (Zsucc (Zpred (Fexp p))); [ rewrite powerRZ_Zs; auto with real zarith | unfold Zsucc, Zpred in |- *; ring ]. repeat rewrite <- Rmult_assoc. apply Rmult_lt_compat_r; auto with real arith. rewrite <- Rmult_IZR; apply Rlt_IZR. unfold pPred in |- *; cut (Zpos (vNum b) <= Zabs (Fnum p) * radix)%Z; auto with zarith. rewrite <- (Zabs_eq radix); auto with float zarith; rewrite <- Zabs_Zmult; rewrite Zmult_comm; auto with float real zarith. Qed. Definition Fsubnormal (p : float) := Fbounded b p /\ Fexp p = (- dExp b)%Z /\ (Zabs (radix * Fnum p) < Zpos (vNum b))%Z. Theorem FsubnormalFbounded : forall p : float, Fsubnormal p -> Fbounded b p. intros p H; case H; auto. Qed. Theorem FsubnormalFexp : forall p : float, Fsubnormal p -> Fexp p = (- dExp b)%Z. intros p H; case H; auto. intros H1 H2; case H2; auto. Qed. Theorem FsubnormalBound : forall p : float, Fsubnormal p -> (Zabs (radix * Fnum p) < Zpos (vNum b))%Z. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. 
(Ptrofs.repr (int_size * (Z.of_N i))))) = Some v -> get_var_or_funvar p lenv y v -> mem_of_asgn_v args_b args_ofs p lenv m (y::ys) (i::inf) (v::vs) | moa_nil: mem_of_asgn_v args_b args_ofs p lenv m [] [] []. Inductive mem_after_asgn args_b args_ofs m: list N -> list Values.val -> Prop := | maa_cons: forall i v inf vs, mem_after_asgn args_b args_ofs m inf vs -> Mem.loadv int_chunk m (Vptr args_b (Ptrofs.add args_ofs (Ptrofs.repr (int_size * (Z.of_N i))))) = Some v -> mem_after_asgn args_b args_ofs m (i::inf) (v::vs) | maa_nil: mem_after_asgn args_b args_ofs m [] [].Theorem mem_of_asgn_nthN: forall {args_b args_ofs p lenv m ys inf vs y v n}, mem_of_asgn_v args_b args_ofs p lenv m ys inf vs -> nthN ys n = Some y -> nthN vs n = Some v -> get_var_or_funvar p lenv y v. Proof. induction ys; intros. inv H0. destruct vs. inv H1. inv H. destruct n. inv H0; inv H1; auto. apply nthN_pos_pred in H0. apply nthN_pos_pred in H1. eapply IHys; eauto. Qed.Theorem mem_of_asgn_after: forall args_b args_ofs p m lenv inf ys vs, mem_of_asgn_v args_b args_ofs p lenv m ys inf vs -> mem_after_asgn args_b args_ofs m inf vs. Proof. induction inf; intros. - inv H; constructor. - inv H; constructor; eauto. Qed.Theorem mem_after_asgn_length: forall args_b args_ofs m inf vs, mem_after_asgn args_b args_ofs m inf vs -> length inf = length vs. Proof. induction inf; intros. inv H; auto. inv H. simpl. erewrite IHinf; eauto. Qed.Theorem mem_of_asgn_exists_v: forall {argsIdent p lenv m args_b args_ofs ys inf}, mem_of_asgn argsIdent p lenv ys inf m -> M.get argsIdent lenv = Some (Vptr args_b args_ofs) -> exists vs, mem_of_asgn_v args_b args_ofs p lenv m ys inf vs. Proof. intros. inv H. destruct H1. destruct H. rewrite H in H0. inv H0. clear H. revert dependent inf. induction ys; intros. - inv H1. exists []. constructor. - inv H1. specialize (IHys _ H4). inv IHys. inv H2. exists (x0::x). destruct H0. constructor; eauto. Qed. Theorem mem_of_asgn_forall_v: forall {argsIdent p lenv m args_b args_ofs ys inf vs}, mem_of_asgn_v args_b args_ofs p lenv m ys inf vs -> M.get argsIdent lenv = Some (Vptr args_b args_ofs) -> mem_of_asgn argsIdent p lenv ys inf m. Proof. induction ys; intros. - inv H. eexists. eexists. split; eauto. - inv H. specialize (IHys _ _ H3 H0). exists args_b, args_ofs. split; auto. constructor. exists v; eauto. inv IHys. destructAll. rewrite H in H0. inv H0. auto. Qed. Theorem mem_of_asgn_v_length: forall {p lenv m args_b args_ofs ys inf vs}, mem_of_asgn_v args_b args_ofs p lenv m ys inf vs -> length inf = length vs. 
: forall x y, { mem x y } + { ~ mem x y }. Proof. intros x y; apply (@M2dec tt). Qed. Let P x := (if mem_dec x (œà 0) then true else false) = true. Let HP0 x : P x <-> mem x (œà 0). Proof. unfold P. destruct (mem_dec x (œà 0)); split; try tauto; discriminate. Qed. Let HP1 : finite_t (sig P). Proof. apply fin_t_finite_t. + intros; apply UIP_dec, bool_dec. + apply finite_t_fin_t_dec; auto. intro; apply bool_dec. Qed. Notation œÄ1 := (@proj1_sig _ _). Let Mn : fo_model (Œ£rel n) (sig P). Proof. exists. + intros []. + intros [] v. exact (mb_is_tuple_in mem (œà 1) (vec_map œÄ1 v)). Defined. Let Mn_dec : fo_model_dec Mn. Proof. intros [] v; apply mb_is_tuple_in_dec; auto. Qed. Let R (x : sig P) (y : X) := œÄ1 x = y. Local Lemma SAT2_to_SATn : exists Y, fo_form_fin_dec_SAT_in A Y. Proof using All. exists (sig P). simpl in HA. destruct HA as (H2 & H3 & H4). change (fol_sem M2 œà (Œ£2_non_empty 0)) in H2. rewrite Œ£2_non_empty_spec in H2. rewrite Œ£2_list_in_spec in H3. revert H3 H4; set (B := A‚¶Éfun v : nat => in_var (2 + v)‚¶Ñ); intros H3 H4. assert (H5 : forall n, n ‚àä fol_vars B -> P (œà n)) by (intros; apply HP0, H3; auto). destruct H2 as (x0 & H0). generalize H0; intros H2. apply HP0 in H0. set (phi := fun n : nat => match in_dec eq_nat_dec n (fol_vars B) with | left H => exist _ (œà n) (H5 _ H) | right _ => exist _ x0 H0 end : sig P). exists Mn, HP1, Mn_dec, (fun n => phi (2+n)). unfold B in *; clear B. rewrite <- Œ£n_Œ£2_correct with (Mn := Mn) (œÜ := phi) (R := R) in H4. + rewrite fol_sem_subst in H4. revert H4; apply fol_sem_ext; intro; rew fot; auto. + intros (x & Hx); exists x; unfold R; simpl; split; auto. apply HP0 in Hx; auto. + intros x Hx; apply HP0 in Hx. exists (exist _ x Hx); red; simpl; auto. + intros v w Hvw. simpl. apply fol_equiv_ext; f_equal. apply vec_pos_ext; intros p. rewrite vec_pos_map; apply Hvw. + intros j Hj; red. unfold phi. destruct (in_dec eq_nat_dec j (fol_vars A‚¶Éfun v : nat => in_var (2 + v)‚¶Ñ)) as [ H | [] ]; auto; simpl. Qed. End nested. Theorem SAT2_SATn A : fo_form_fin_dec_SAT (@Œ£n_Œ£2_enc n A) -> fo_form_fin_dec_SAT A. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Category. Local Open Scope morphism_scope. Inductive Composable_Chain (C : Category) (a b : C) : Type := | Single : (a ‚Äì‚âª b) ‚Üí Composable_Chain C a b | Chain : ‚àÄ (c : Obj), (a ‚Äì‚âª c) ‚Üí Composable_Chain C c b ‚Üí Composable_Chain C a b .Arguments Single {_ _ _} _. Arguments Chain {_ _ _ _} _ _. Fixpoint Forall_Links {C : Category} {a b : C} (ch : Composable_Chain C a b) (P : ‚àÄ {x y : Obj}, (x ‚Äì‚âª y) ‚Üí Prop) : Prop := match ch with | Single f => P f | Chain f ch' => P f ‚àß Forall_Links ch' (@P) end. Fixpoint Compose_of {C : Category} {a b : C} (ch : Composable_Chain C a b) {struct ch} : a ‚Äì‚âª b := match ch with | Single f => f | Chain f ch' => (Compose_of ch') ‚àò f end. Fixpoint Chain_Compose {C : Category} {a b c : C} (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c) : Composable_Chain C a c := match ch1 with | Single f => Chain f ch2 | Chain f ch' => Chain f (Chain_Compose ch' ch2) end. Theorem Compose_of_Chain_Compose (C : Category) (a b c : C) (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c) : ((Compose_of ch2) ‚àò (Compose_of ch1))%morphism = Compose_of (Chain_Compose ch1 ch2). 
Require Export ArithRing. Require Export Compare_dec. Require Export Wf_nat. Require Export Arith. Require Export Omega. Theorem minus_minus : forall a b c : nat, a - b - c = a - (b + c). 
Require Import Coq.Classes.RelationClasses. Require Import Coq.Lists.List. Require Import ExtLib.Core.RelDec. Require Import ExtLib.Tactics.Consider. Require Import ExtLib.Structures.Maps. Require Import ExtLib.Structures.Monad. Require Import ExtLib.Structures.Reducible. Require Import ExtLib.Structures.Functor.Set Implicit Arguments. Set Strict Implicit.Section keyed. Variable K : Type. Variable R : K -> K -> Prop. Variable RD_K : RelDec R. Variable V : Type. Definition alist : Type := list (K * V). Definition alist_remove (k : K) (m : alist) : alist := List.filter (fun x => negb (k ?[ R ] (fst x))) m. Definition alist_add (k : K) (v : V) (m : alist) : alist := (k, v) :: alist_remove k m. Fixpoint alist_find (k : K) (m : alist) : option V := match m with | nil => None | (k',v) :: ms => if k ?[ R ] k' then Some v else alist_find k ms end. Section fold. Import MonadNotation. Local Open Scope monad_scope. Variables T : Type. Variable f : K -> V -> T -> T. Fixpoint fold_alist (acc : T) (map : alist) : T := match map with | nil => acc | (k,v) :: m => let acc := f k v acc in fold_alist acc m end. End fold. Definition alist_union (m1 m2 : alist) : alist := fold_alist alist_add m2 m1. Global Instance Map_alist : Map K V alist := { empty := nil ; add := @alist_add ; remove := alist_remove ; lookup := alist_find ; union := @alist_union }. Section proofs. Hypothesis RDC_K : RelDec_Correct RD_K. Hypothesis Refl : Reflexive R. Hypothesis Sym : Symmetric R. Hypothesis Trans : Transitive R. Definition mapsto_alist (m : alist) k v : Prop := alist_find k m = Some v. Lemma mapsto_alist_cons : forall k v m k' v', mapsto_alist ((k',v') :: m) k v <-> ( (mapsto_alist m k v /\ ~R k k') \/ (R k k' /\ v = v')). Proof. unfold mapsto_alist; intuition; simpl in *. { consider (k ?[ R ] k'); intros. { right. inversion H0; auto. } { left. auto. } } { consider (k ?[ R ] k'); intros; intuition. } { consider (k ?[ R ] k'); intros; intuition. congruence. } Qed. Theorem mapsto_lookup_alist : forall (k : K) (v : V) (m : list (K * V)), lookup k m = Some v <-> mapsto_alist m k v. Proof. reflexivity. Qed. Theorem mapsto_remove_eq_alist : forall (m : list (K * V)) (k : K) (v : V), ~mapsto_alist (remove k m) k v. 
Require Export Q_field. Theorem Qmult_sym : forall n m : Q, Qmult n m = Qmult m n. intros n m; case m; case n; auto; intros n' m'; simpl in |- *; rewrite Qpositive_mult_sym; auto. Qed. Theorem Qmult_assoc : forall n m p : Q, Qmult n (Qmult m p) = Qmult (Qmult n m) p. intros n m p; case p; case m; case n; auto; intros n' m' p'; simpl in |- *; rewrite Qpositive_mult_assoc; auto. Qed. Theorem Qplus_zero_left : forall n : Q, Qplus Zero n = n. intros n; case n; auto. Qed. Theorem Qmult_one_left : forall n : Q, Qmult (Qpos One) n = n. intros n; case n; simpl in |- *; auto; intros; rewrite Qpositive_mult_One; auto. Qed. Theorem Q_opp_def : forall n : Q, Qplus n (Qopp n) = Zero. intros n; case n; simpl in |- *; auto. intros n'; Case' (Qpositive_le_dec n' n'). case (Qpositive_eq_dec n' n'); auto. intros H; elim H; auto. intros H; elim H; auto. intros n'; Case' (Qpositive_le_dec n' n'). case (Qpositive_eq_dec n' n'); auto. intros H; elim H; auto. intros H; elim H; auto. Qed. Definition Q_eq (n m : Q) := match n, m with | Zero, Zero => true | Qpos n', Qpos m' => match Qpositive_eq_dec n' m' with | left h => true | right h => false end | Qneg n', Qneg m' => match Qpositive_eq_dec n' m' with | left h => true | right h => false end | _, _ => false end. Theorem Q_eq_prop : forall x y : Q, Q_eq x y = true -> x = y. 
apply ClosestMax with (min := min); auto. replace (2%nat * r)%R with (r + r)%R; [ idtac | simpl in |- *; ring ]. apply Rminus_le; auto. replace (min + max - (r + r))%R with (max - r - (r - min))%R; [ idtac | simpl in |- *; ring ]. apply Rle_minus; auto. rewrite H'2; auto with real. case (Req_dec min max); intros H'5. right; intros q H'3. case (ClosestMinOrMax _ _ H'3); intros isM0. rewrite <- H'5. apply MinEq with (1 := isM0); auto. apply MaxEq with (1 := isM0); auto. left. apply FNevenEq with (f1 := FNSucc b radix precision min); auto. apply FcanonicBound with (radix := radix). apply FNSuccCanonic; auto with arith. case H'; auto. case H'0; auto. apply MaxEq with (b := b) (r := r); auto. apply MinMax; auto with arith. Contradict H'5; auto. fold FtoRradix in H'5; rewrite H'5 in H'2. replace (FtoRradix max) with (min + (max - min))%R; [ rewrite <- H'2 | idtac ]; ring. apply FNoddSuc; auto. case H'; auto. exists max; split; auto. apply ClosestMax with (min := min); auto. replace (2%nat * r)%R with (r + r)%R; [ idtac | simpl in |- *; ring ]. apply Rminus_le; auto. replace (min + max - (r + r))%R with (max - r - (r - min))%R; [ idtac | simpl in |- *; ring ]. apply Rle_minus; auto with real. right; intros q H'2. apply ClosestMaxEq with (r := r) (min := min); auto. replace (2%nat * r)%R with (r + r)%R; [ idtac | simpl in |- *; ring ]. apply Rminus_lt; auto. replace (min + max - (r + r))%R with (max - r - (r - min))%R; [ idtac | simpl in |- *; ring ]. apply Rlt_minus; auto. Qed. Theorem EvenClosestCompatible : CompatibleP b radix EvenClosest. red in |- *; simpl in |- *. intros r1 r2 p q H' H'0 H'1 H'2; red in |- *. inversion H'. split. apply (ClosestCompatible r1 r2 p q); auto. case H0; intros H1. left. apply FNevenEq with (f1 := p); auto. case H; auto. right; intros q0 H'3. unfold FtoRradix in |- *; rewrite <- H'1; auto. apply H1; auto. apply (ClosestCompatible r2 r1 q0 q0); auto. case H'3; auto. Qed. Theorem EvenClosestMinOrMax : MinOrMaxP b radix EvenClosest. red in |- *; intros r p H'; case (ClosestMinOrMax r p); auto. case H'; auto. Qed. Theorem EvenClosestMonotone : MonotoneP radix EvenClosest. 
auto with T1. Qed.Lemma nf_fin : forall n:nat, nf (T1nat n). Proof. destruct n; auto with T1. Qed.Lemma succ_not_zero : forall alpha, succ alpha <> zero. Proof. destruct alpha. - discriminate. - cbn; destruct alpha1; discriminate. Qed.Lemma succ_is_succ : forall alpha, T1is_succ (succ alpha). Proof. induction alpha. - reflexivity. - simpl. destruct alpha1. + reflexivity. + simpl. trivial. Qed.Lemma finite_lt : forall n p : nat, (n < p)%nat -> lt (FS n) (FS p). Proof. intros; auto with T1. Qed.Lemma finite_ltR : forall n p : nat, lt (FS n) (FS p) -> (n < p)%nat. Proof. intros; simpl in H. unfold lt in H. destruct (compare _ _) eqn:?. 1,3: easy. unfold compare in Heqc; simpl in Heqc. destruct (n ?= p) eqn:?. 1,3: easy. now apply Nat.compare_lt_iff. Qed.Lemma le_eq_lt_dec alpha beta: leq lt alpha beta -> {alpha = beta} + {lt alpha beta}. Proof. intro Hle. destruct (compare alpha beta) eqn:Hcomp. - apply compare_eq_iff in Hcomp as ->. now left. - apply compare_lt_iff in Hcomp. now right. - exfalso. apply compare_gt_iff in Hcomp. destruct Hle. + now apply lt_not_gt in Hcomp. + subst; now apply lt_irrefl in Hcomp. Defined.Lemma lt_succ (alpha : T1) : lt alpha (succ alpha). Proof. induction alpha; cbn; auto with T1. - destruct alpha1; cbn; auto with T1. Qed. Lemma lt_a_phi0_a : forall a, lt a (phi0 a). Proof. induction a;simpl. - auto with T1. - assert (H : leq lt (cons a1 0 zero) (cons a1 n a2)). { case n. - case a2. + apply le_refl. + intros; apply lt_incl_le. auto with T1 arith. - intros; apply lt_incl_le; auto with T1 arith. } apply head_lt. destruct H as [Hlt | ]. + eapply lt_trans; eauto. + assumption. Qed. Lemma phi0_lt : forall a b, lt a b -> lt (phi0 a) (phi0 b). Proof. intros c c' H; auto with T1. Qed. Lemma phi0_ltR : forall a b, lt (phi0 a) (phi0 b) -> lt a b. Proof. intros c c' H; case (lt_inv H). - trivial. - intros [(_, i) | (_, (_, i))]; inversion i. Qed. Lemma nf_of_finite : forall n b, nf (cons zero n b) -> b = zero. Proof. intros n b H; destruct b. - reflexivity. - apply nf_inv3 in H; case (not_lt_zero H);auto. Qed.Theorem zero_le : forall a, leq lt zero a. Proof. intro a; destruct a. - now right. - now left. Qed. Theorem le_inv : forall a n b a' n' b', leq lt (cons a n b) (cons a' n' b') -> lt a a' \/ a = a' /\ (n < n')%nat \/ a = a' /\ n = n' /\ leq lt b b'. 
F, rep: xp (Cached ds) ms hm >> * [[ Forall (fun e => fst e < length (ds!!)) avl /\ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (dsupd_vecs ds avl)) ms' hm' >> XCRASH:hm' << F, would_recover_any: xp ds hm' -- >> \/ << F, would_recover_any: xp (dsupd_vecs ds avl) hm' -- >> >} dwrite_vecs xp avl ms. Proof. unfold dwrite_vecs, rep. step. prestep; unfold rep; cancel. prestep; unfold rep; safecancel. substl (MSVMap a). apply overlap_empty; apply map_empty_vmap0. eapply effective_avl_addrs_ok; eauto. auto. step. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. or_r; cancel. do 2 (xform_norm; cancel). repeat rewrite nthd_0; simpl. substl (MSTxns a); simpl. rewrite Nat.sub_0_r, <- latest_nthd. rewrite <- dsupd_vecs_latest. rewrite synced_recover_any; eauto. eassign (MSTxns a); substl (MSTxns a); simpl. unfold effective; rewrite popn_oob by omega. apply dset_match_nil. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. prestep; unfold rep; cancel. apply not_true_iff_false; auto. eapply effective_avl_addrs_ok; eauto. step. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. or_r; cancel. do 2 (xform_norm; cancel). repeat rewrite nthd_0; simpl. erewrite dset_match_nthd_effective_fst by eauto. rewrite <- dsupd_vecs_fst, <- effective_dsupd_vecs_comm. rewrite MLog.synced_recover_before. rewrite recover_before_any_fst. auto. rewrite effective_dsupd_vecs_comm. eapply dset_match_dsupd_vecs_nonoverlap. apply not_true_is_false; eauto. all: eauto. Qed. Theorem dsync_vecs_ok: forall xp al ms, {< F ds, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[ Forall (fun e => e < length (ds!!)) al /\ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (dssync_vecs ds al)) ms' hm' >> CRASH:hm' << F, would_recover_any: xp ds hm' -- >> >} dsync_vecs xp al ms. Proof. unfold dsync_vecs. prestep; unfold rep; cancel. erewrite dset_match_nthd_effective_fst by eauto. rewrite Forall_forall in *; intros. erewrite <- replay_seq_latest_length; eauto. rewrite latest_effective; eauto. unfold dset_match in *; intuition eauto. prestep; unfold rep; cancel. rewrite map_length. rewrite dssync_vecs_nthd; cancel. rewrite effective_dssync_vecs_comm. eapply dset_match_dssync_vecs; eauto. cancel. erewrite dset_match_nthd_effective_fst by eauto. rewrite MLog.synced_recover_before. rewrite recover_before_any_fst; eauto. Qed. Definition recover_any_pred xp ds hm := ( exists d n ms, [[ n <= length (snd ds) ]] * (rep xp (Cached (d, nil)) ms hm \/ rep xp (Rollback d) ms hm) * [[[ d ::: crash_xform (diskIs (list2nmem (nthd n ds))) ]]])%pred. Theorem sync_invariant_recover_any_pred : forall xp ds hm, sync_invariant (recover_any_pred xp ds hm). Proof. unfold recover_any_pred; intros; auto 10. Qed. Hint Resolve sync_invariant_recover_any_pred. Lemma NEListSubset_effective : forall ds ds' n, NEListSubset ds ds' -> NEListSubset ds (effective ds' n). Proof. unfold effective; intros. apply nelist_subset_popn'; auto. Qed. Theorem crash_xform_any : forall xp ds hm, crash_xform (would_recover_any xp ds hm) =p=> recover_any_pred xp ds hm. 
split; simpl in *; try destruct H; try solve [setoid_rewrite H; apply Permutation_middle]; auto. Defined. Definition find_obligations_function: forall items, { obligations | Forall P obligations -> Forall P items }. refine (fun items => let (pair, H) := split_by_maybe items in this pair.2 ); destruct H; apply (forall_done_undone H); assumption. Defined. Theorem verify__find_obligations_function: forall items found, found = find_obligations_function items -> Forall P (use found) -> Forall P items. Proof. intros ?[]; auto. Qed.End find_obligations.Ltac find_obligations__helper P compute_partial items := let found := eval compute in (find_obligations_function P compute_partial items) in let pf := eval compute in (proj2_sig found) in apply pf; apply Forall_fold_right; simpl; repeat split .Ltac find_obligations P compute_partial items := match goal with | |- Forall P items => find_obligations__helper P compute_partial items | |- forall item, In item items -> P item => apply Coq.Lists.List.Forall_forall; find_obligations__helper P compute_partial items | |- forall item, elem_of item items -> P item => apply Forall_forall; find_obligations__helper P compute_partial items | |- forall index def, index < length items -> P (nth index items def) => apply Coq.Lists.List.Forall_nth; find_obligations__helper P compute_partial items | |- forall index item, (lookup index items) = Some item -> P item => apply Forall_lookup; find_obligations__helper P compute_partial items | |- forall index, index < length items -> P (items !!! index) => apply Forall_lookup_total; find_obligations__helper P compute_partial items | |- forall index (H: index < length items), P (use (safe_lookup items H)) => apply Forall_safe_lookup; find_obligations__helper P compute_partial items end .Module test__find_obligations. Definition P n := (n < 4 \/ n < 6). Definition compute_partial: forall n, partial (P n). refine (fun n => if (lt_dec n 4) then proven else unknown); unfold P; lia. Defined. Definition items := [0; 1; 2; 4; 3; 2; 5]. Theorem find_obligations__Forall: Forall P items. Proof. find_obligations P compute_partial items; lia. Qed. Theorem find_obligations__forall_In: forall item, In item items -> P item. Proof. find_obligations P compute_partial items; lia. Qed. Theorem find_obligations__forall_elem_of: forall item, elem_of item items -> P item. Proof. find_obligations P compute_partial items; lia. Qed. Theorem find_obligations__forall_nth: forall index def, index < length items -> P (nth index items def). Proof. find_obligations P compute_partial items; lia. Qed. Theorem find_obligations__forall_lookup: forall index item, (lookup index items) = Some item -> P item. Proof. find_obligations P compute_partial items; lia. Qed. Theorem find_obligations__forall_lookup_total: forall index, index < length items -> P (items !!! index). Proof. find_obligations P compute_partial items; lia. Qed. Theorem find_obligations__forall_safe_lookup: forall index (H: index < length items), P (use (safe_lookup items H)). 
x.Arguments nothing {_}. Arguments just {_}.#[local] Theorem maybeFIdent (x : object setCategory) : ( fun e : maybe x => match e with | nothing => nothing | just e0 => just (@id setCategory x e0) end ) = @id setCategory (maybe x). Proof. clean. apply functional_extensionality. destruct x0; magic. Qed.#[local] Theorem maybeFComp (x y z : object setCategory) (f : arrow x y) (g : arrow y z) : @compose setCategory _ _ _ ( fun e : maybe y => match e with | nothing => nothing | just e0 => just (g e0) end ) ( fun e : maybe x => match e with | nothing => nothing | just e0 => just (f e0) end ) = ( fun e : maybe x => match e with | nothing => nothing | just e0 => just (compose g f e0) end ). Proof. clean. apply functional_extensionality. destruct x0; magic. Qed.Definition maybeFunctor : functor setCategory setCategory := newFunctor setCategory setCategory maybe (fun _ _ f e => match e with | nothing => nothing | just e => just (f e) end ) maybeFIdent maybeFComp.#[local] Theorem maybeEtaNaturality (x y : object setCategory) (f : arrow x y) : @compose setCategory _ _ _ just (fMap idFunctor f) = @compose setCategory _ _ _ (fMap maybeFunctor f) just. Proof. magic. Qed.Definition maybeEta : naturalTransformation idFunctor maybeFunctor := newNaturalTransformation idFunctor maybeFunctor (@just) maybeEtaNaturality.#[local] Theorem maybeMuNaturality (x y : object setCategory) (f : arrow x y) : @compose setCategory _ _ _ ( fun e1 : oMap (compFunctor maybeFunctor maybeFunctor) y => match e1 with | nothing => nothing | just e2 => e2 end ) (fMap (compFunctor maybeFunctor maybeFunctor) f) = compose (fMap maybeFunctor f) ( fun e1 : oMap (compFunctor maybeFunctor maybeFunctor) x => match e1 with | nothing => nothing | just e2 => e2 end ). Proof. clean. apply functional_extensionality. destruct x0; magic. Qed.Definition maybeMu : naturalTransformation (compFunctor maybeFunctor maybeFunctor) maybeFunctor := newNaturalTransformation (compFunctor maybeFunctor maybeFunctor) maybeFunctor ( fun x e1 => match e1 with | nothing => nothing | just e2 => e2 end ) maybeMuNaturality.#[local] Theorem maybeMAssoc : eta ( vertCompNaturalTransformation maybeMu (leftWhisker maybeMu maybeFunctor) ) = eta ( vertCompNaturalTransformation maybeMu (rightWhisker maybeFunctor maybeMu) ). Proof. clean. apply functional_extensionality_dep. clean. apply functional_extensionality. destruct x0; magic. Qed.#[local] Theorem maybeMIdent1 : eta ( vertCompNaturalTransformation maybeMu (leftWhisker maybeEta maybeFunctor) ) = eta idNaturalTransformation. Proof. magic. Qed.#[local] Theorem maybeMIdent2 : eta ( vertCompNaturalTransformation maybeMu (rightWhisker maybeFunctor maybeEta) ) = eta idNaturalTransformation. 
(succ x) = x. Proof. intros x Fx Hx. apply Rle_antisym. - apply Rnot_lt_le. intros H. apply succ_le_lt with (1 := Fx) in H. revert H. apply Rlt_not_le. apply pred_lt_id. apply Rgt_not_eq. apply Rlt_le_trans with (1 := Hx). apply succ_ge_id. now apply generic_format_pred, generic_format_succ. - apply le_pred_lt with (1 := Fx). now apply generic_format_succ. apply succ_gt_id. now apply Rgt_not_eq. Qed.Theorem succ_pred : forall x, F x -> succ (pred x) = x. Proof. intros x Fx. destruct (Rle_or_lt 0 x) as [[Hx|Hx]|Hx]. now apply succ_pred_aux. rewrite <- Hx. rewrite pred_0, succ_opp, pred_ulp_0. apply Ropp_0. rewrite pred_eq_opp_succ_opp, succ_opp. rewrite pred_succ_aux. apply Ropp_involutive. now apply generic_format_opp. now apply Ropp_0_gt_lt_contravar. Qed.Theorem pred_succ : forall x, F x -> pred (succ x) = x. Proof. intros x Fx. rewrite <- (Ropp_involutive x). rewrite succ_opp, pred_opp. apply f_equal, succ_pred. now apply generic_format_opp. Qed.Theorem round_UP_pred_plus_eps : forall x, F x -> forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x) else (ulp (pred x)))%R -> round beta fexp Zceil (pred x + eps) = x. Proof. intros x Fx eps Heps. rewrite round_UP_plus_eps. now apply succ_pred. now apply generic_format_pred. unfold pred at 4. rewrite Ropp_involutive, pred_succ. rewrite ulp_opp. generalize Heps; case (Rle_bool_spec x 0); intros H1 H2. rewrite Rle_bool_false; trivial. case H1; intros H1'. apply Rlt_le_trans with (2:=H1). apply pred_lt_id. now apply Rlt_not_eq. rewrite H1'; unfold pred, succ. rewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l. rewrite <- Ropp_0; apply Ropp_lt_contravar. apply Rlt_le_trans with (1:=proj1 H2). apply Rle_trans with (1:=proj2 H2). rewrite Ropp_0, H1'. now right. rewrite Rle_bool_true; trivial. now apply pred_ge_0. now apply generic_format_opp. Qed. Theorem round_DN_minus_eps: forall x, F x -> forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x) else (ulp (pred x)))%R -> round beta fexp Zfloor (x - eps) = pred x. Proof. intros x Fx eps Heps. replace (x-eps)%R with (-(-x+eps))%R by ring. rewrite round_DN_opp. unfold pred; apply f_equal. pattern (-x)%R at 1; rewrite <- (pred_succ (-x)). apply round_UP_pred_plus_eps. now apply generic_format_succ, generic_format_opp. rewrite pred_succ. rewrite ulp_opp. generalize Heps; case (Rle_bool_spec x 0); intros H1 H2. rewrite Rle_bool_false; trivial. case H1; intros H1'. apply Rlt_le_trans with (-x)%R. now apply Ropp_0_gt_lt_contravar. apply succ_ge_id. rewrite H1', Ropp_0, succ_eq_pos;[idtac|now right]. rewrite Rplus_0_l. apply Rlt_le_trans with (1:=proj1 H2). rewrite H1' in H2; apply H2. rewrite Rle_bool_true. now rewrite succ_opp, ulp_opp. rewrite succ_opp. rewrite <- Ropp_0; apply Ropp_le_contravar. now apply pred_ge_0. now apply generic_format_opp. now apply generic_format_opp. Qed. Theorem error_lt_ulp : forall rnd { Zrnd : Valid_rnd rnd } x, (x <> 0)%R -> (Rabs (round beta fexp rnd x - x) < ulp x)%R. 
Require Import List Arith Bool Eqdep_dec.Require Import Undecidability.Synthetic.Definitions Undecidability.Synthetic.ReducibilityFacts. Require Import Undecidability.Synthetic.InformativeDefinitions Undecidability.Synthetic.InformativeReducibilityFacts.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops.Set Implicit Arguments.Definition decidable (P : Prop) := { P } + { ~ P }.Fact decidable_bool_eq P : (decidable P -> { Q : bool | P <-> Q = true }) * ({ Q : bool | P <-> Q = true } -> decidable P). Proof. split. + intros H; exists (if H then true else false); destruct H; split; auto; discriminate. + intros (Q & HQ); destruct Q; [ left | right ]; rewrite HQ; auto. Qed.Fact ireduction_decidable X Y (p : X -> Prop) (q : Y -> Prop) : p ‚™Ø·µ¢ q -> (forall y, decidable (q y)) -> forall x, decidable (p x). Proof. unfold decidable, decider, inf_reduces, reduction. intros (f & Hf) Hq x. destruct (Hq (f x)); [ left | right ]; rewrite Hf; auto. Qed. Definition discrete X := forall x y : X, decidable (x=y).Fact discrete_unit : discrete unit. Proof. intros [] []; left; auto. Qed.Local Ltac mydecideeq := unfold discrete, decidable; intro; decide equality.Fact discrete_opt X : discrete X -> discrete (option X). Proof. mydecideeq. Qed.Fact discrete_sum X Y : discrete X -> discrete Y -> discrete (X+Y). Proof. mydecideeq. Qed.Fact discrete_prod X Y : discrete X -> discrete Y -> discrete (X*Y). Proof. mydecideeq. Qed.Fact discrete_list X : discrete X -> discrete (list X). Proof. mydecideeq. Qed.Fact discrete_pos n : discrete (pos n). Proof. unfold discrete, decidable; apply pos_eq_dec. Qed.Fact discrete_vec X n : discrete X -> discrete (vec X n). Proof. unfold discrete, decidable; intros; apply vec_eq_dec; auto. Qed.#[export] Hint Resolve discrete_unit discrete_sum discrete_prod discrete_list discrete_pos discrete_vec : core.Section decidable_fun_pos_bool. Variable (n : nat) (K : (pos n -> bool) -> Prop) (HK : forall P Q, (forall x, P x = Q x) -> K P <-> K Q) (D : forall P, decidable (K P)). Let Dfa : decidable (forall v, K (vec_pos v)). Proof. apply (fol_quant_sem_dec fol_fa). + apply finite_t_vec, finite_t_bool. + intros v; apply D. Qed. Let Dex : decidable (exists v, K (vec_pos v)). Proof. apply (fol_quant_sem_dec fol_ex). + apply finite_t_vec, finite_t_bool. + intros v; apply D. Qed. Theorem fa_fun_pos_bool_decidable : decidable (forall P, K P). 
(Vint n)). Proof. red; intros until x. unfold shrimm. predSpec Int.eq Int.eq_spec n Int.zero. intros. subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shr_zero; auto. destruct (Int.ltu n Int.iwordsize) eqn:WS. case (shrimm_match a); intros. InvEval. exists (Vint (Int.shr n1 n)); split. EvalOp. simpl; rewrite WS; auto. simpl; destruct (Int.lt mask1 Int.zero) eqn:?. TrivialExists. replace (Val.shr x (Vint n)) with (Val.shru x (Vint n)). apply eval_shruimm; auto. destruct x; simpl; auto. rewrite WS. decEq. symmetry. InvEval. destruct v1; simpl in H0; inv H0. apply Int.shr_and_is_shru_and; auto. simpl. TrivialExists. intros. simpl. TrivialExists. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. generalize (Int.one_bits_decomp n). generalize (Int.one_bits_range n). destruct (Int.one_bits n). intros. TrivialExists. destruct l. intros. rewrite H1. simpl. rewrite Int.add_zero. replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul. apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib. destruct l. intros. destruct (optim_for_size tt). TrivialExists. rewrite H1. simpl. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exists (Val.add v1 v2); split. econstructor. eauto. EvalOp. rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. apply Val.add_lessdef; auto. simpl. repeat rewrite H0; auto with coqlib. intros. TrivialExists. Qed.Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros until x; unfold mulimm. predSpec Int.eq Int.eq_spec n Int.zero. intros. exists (Vint Int.zero); split. EvalOp. destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto. predSpec Int.eq Int.eq_spec n Int.one. intros. exists x; split; auto. destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto. case (mulimm_match a); intros; InvEval. TrivialExists. simpl. rewrite Int.mul_commut; auto. subst. rewrite Val.mul_add_distr_l. exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]]. exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]]. exists v''; split; auto. eapply Val.lessdef_trans. eapply Val.add_lessdef; eauto. rewrite Val.mul_commut; auto. apply eval_mulimm_base; auto. Qed.Theorem eval_mul: binary_constructor_sound mul Val.mul. Proof. red; intros until y. unfold mul; case (mul_match a b); intros; InvEval. rewrite Val.mul_commut. apply eval_mulimm. auto. apply eval_mulimm. auto. TrivialExists. Qed.Theorem eval_mulhs: binary_constructor_sound mulhs Val.mulhs. Proof. unfold mulhs; red; intros; TrivialExists. Qed. Theorem eval_mulhu: binary_constructor_sound mulhu Val.mulhu. 
revert Heps; unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros _ (H1,H2). absurd (0 < 0)%R; auto with real. now apply Rle_lt_trans with (1:=H1). intros n Hn H. assert (fexp (ln_beta beta eps) = fexp n). apply valid_exp; try assumption. assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega]. apply lt_bpow with beta. apply Rle_lt_trans with (2:=proj2 H). destruct (ln_beta beta eps) as (e,He). simpl; rewrite Rabs_pos_eq in He. now apply He, Rgt_not_eq. now left. replace (Zfloor (eps * bpow (- fexp (ln_beta beta eps)))) with 0%Z. unfold F2R; simpl; ring. apply sym_eq, Zfloor_imp. split. apply Rmult_le_pos. now left. apply bpow_ge_0. apply Rmult_lt_reg_r with (bpow (fexp n)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus. rewrite H0; ring_simplify (-fexp n + fexp n)%Z. simpl; rewrite Rmult_1_l, Rmult_1_r. apply H. rewrite <- P, round_0; trivial. apply valid_rnd_DN. Qed. Theorem round_UP_plus_eps_pos : forall x, (0 <= x)%R -> F x -> forall eps, (0 < eps <= ulp x)%R -> round beta fexp Zceil (x + eps) = (x + ulp x)%R. Proof with auto with typeclass_instances. intros x Zx Fx eps. case Zx; intros Zx1.intros (Heps1,[Heps2|Heps2]). assert (Heps: (0 <= eps < ulp x)%R). split. now apply Rlt_le. exact Heps2. assert (Hd := round_DN_plus_eps_pos x Zx Fx eps Heps). rewrite round_UP_DN_ulp. rewrite Hd. rewrite 2!ulp_neq_0. unfold canonic_exp. now rewrite ln_beta_plus_eps. now apply Rgt_not_eq. now apply Rgt_not_eq, Rplus_lt_0_compat. intros Fs. rewrite round_generic in Hd... apply Rgt_not_eq with (2 := Hd). pattern x at 2 ; rewrite <- Rplus_0_r. now apply Rplus_lt_compat_l. rewrite Heps2. apply round_generic... now apply generic_format_succ_aux1.rewrite <- Zx1, 2!Rplus_0_l. intros Heps. case (proj2 Heps). unfold round, scaled_mantissa, canonic_exp. unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros H2. intros J; absurd (0 < 0)%R; auto with real. apply Rlt_trans with eps; try assumption; apply Heps. intros n Hn H. assert (fexp (ln_beta beta eps) = fexp n). apply valid_exp; try assumption. assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega]. apply lt_bpow with beta. apply Rle_lt_trans with (2:=H). destruct (ln_beta beta eps) as (e,He). simpl; rewrite Rabs_pos_eq in He. now apply He, Rgt_not_eq. now left. replace (Zceil (eps * bpow (- fexp (ln_beta beta eps)))) with 1%Z. unfold F2R; simpl; rewrite H0; ring. apply sym_eq, Zceil_imp. split. simpl; apply Rmult_lt_0_compat. apply Heps. apply bpow_gt_0. apply Rmult_le_reg_r with (bpow (fexp n)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus. rewrite H0; ring_simplify (-fexp n + fexp n)%Z. simpl; rewrite Rmult_1_l, Rmult_1_r. now left. intros P; rewrite P. apply round_generic... apply generic_format_ulp_0. Qed. Theorem round_UP_pred_plus_eps_pos : forall x, (0 < x)%R -> F x -> forall eps, (0 < eps <= ulp (pred x) )%R -> round beta fexp Zceil (pred x + eps) = x. 
b precision q)) with (FtoR radix q); [ idtac | rewrite FnormalizeCorrect ]; auto. apply isMin_inv1 with (1 := H'); auto. replace (FSucc b radix precision (Fnormalize radix b precision q)) with (FNSucc b radix precision q); [ idtac | case p ]; auto. replace (Float (Fnum p) (Fexp p)) with p; [ idtac | case p ]; auto. case (Req_dec p q); intros Eq0. unfold FtoRradix in Eq0; rewrite Eq0. apply FNSuccLt; auto. case (MinMax q p); auto. intros H'2 H'3; elim H'3; intros H'4 H'5; clear H'3. case H'4; auto. intros H'0; absurd (p <= q)%R; rewrite H'0; auto. apply Rlt_not_le; auto. unfold FtoRradix in |- *; apply FNSuccLt; auto. inversion H'. elim H0; intros H'3 H'6; apply H'6; clear H0; auto. rewrite <- H'0; auto with real. exists (Fnum (Fshift radix (Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (Fnormalize radix b precision q))). pattern (Fexp p) at 2 in |- *; replace (Fexp p) with (Fexp (Fshift radix (Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (Fnormalize radix b precision q))). unfold FtoRradix in |- *; rewrite <- FshiftCorrect with (n := Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (x := Fnormalize radix b precision q). case (Fshift radix (Zabs_nat (Fexp (Fnormalize radix b precision q) - Fexp p)) (Fnormalize radix b precision q)); auto. auto with arith. simpl in |- *; rewrite inj_abs; auto with zarith. Qed. Theorem MaxBinade : forall (r : R) (p : float), Fbounded b p -> (r <= p)%R -> (FNPred b radix precision p < r)%R -> isMax r p. intros r p H' H'0 H'1. rewrite <- (Ropp_involutive r). rewrite <- (Fopp_Fopp p). apply MinOppMax. apply MinBinade; auto with real float. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real.rewrite <- (Fopp_Fopp (FNSucc b radix precision (Fopp p))). rewrite <- FNPredFopFNSucc; auto. unfold FtoRradix in |- *; rewrite Fopp_correct; auto with real arith. Qed. Theorem MaxMin : forall (p : float) (r : R), isMax r p -> r <> p :>R -> isMin r (FNPred b radix precision p). intros p r H' H'0. rewrite <- (Fopp_Fopp (FNPred b radix precision p)). rewrite <- (Ropp_involutive r). apply MaxOppMin. rewrite FNPredFopFNSucc; auto. rewrite Fopp_Fopp; auto.apply MinMax; auto. apply MaxOppMin; auto. Contradict H'0. rewrite <- (Ropp_involutive r); rewrite H'0; auto; unfold FtoRradix in |- *; rewrite Fopp_correct; auto; apply Ropp_involutive. Qed. Theorem FmaxRep : forall p q : float, isMax p q -> exists m : Z, q = Float m (Fexp p) :>R. 
WfBaseMod_inlineSingle_Rules_pos. Qed. Definition inlineSingle_Rules_pos_BaseModuleWf {ty} (m : BaseModuleWf ty) n := Build_BaseModuleWf (WfBaseMod_inlineSingle_Rules_pos n (wfBaseModule m)). Definition inlineSingle_Rules_pos_BaseModuleWf_new {ty} (m : BaseModuleWf_new ty) n := Build_BaseModuleWf_new (WfBaseMod_inlineSingle_Rules_pos_new n (wfBaseModule_new m)). Lemma TraceInclusion_inlineSingle_pos_Rules_Wf (m : BaseModuleWf type) n : TraceInclusion m (inlineSingle_Rules_pos_BaseModuleWf m n). Proof. specialize (TraceInclusion_flatten_r m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineSingle_pos_Rules P2 n) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineSingle_pos_Rules_Wf_new (m : BaseModuleWf_new type) n : TraceInclusion m (inlineSingle_Rules_pos_BaseModuleWf_new m n). Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. eapply (TraceInclusion_inlineSingle_pos_Rules_Wf m'). Qed. Lemma TraceInclusion_inlineAll_pos_Rules regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> (WfMod type (Base (BaseMod regs (inlineAll_Rules meths rules) meths))) /\ TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs (inlineAll_Rules meths rules) meths)). Proof. intros WfH. unfold inlineAll_Rules. induction (Datatypes.length meths); [simpl in *; split; [assumption | apply TraceInclusion_refl]|]. rewrite seq_eq. rewrite fold_left_app; simpl in *. destruct IHn as [IHn1 IHn2]. pose proof (TraceInclusion_inlineSingle_pos_Rules IHn1 n) as [sth1 sth2]. destruct n; simpl in *; auto. split; auto. eapply TraceInclusion_trans; eauto. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> (WfMod_new type (Base (BaseMod regs (inlineAll_Rules meths rules) meths))) /\ TraceInclusion (Base (BaseMod regs rules meths)) (Base (BaseMod regs (inlineAll_Rules meths rules) meths)). Proof. repeat rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inlineAll_pos_Rules. Qed. Lemma WfBaseMod_inlineAll_Rules ty m : WfBaseModule ty m -> WfBaseModule ty (BaseMod (getRegisters m) (inlineAll_Rules (getMethods m) (getRules m)) (getMethods m)). Proof. intros. assert (WfMod ty m) as P1;[constructor; auto|apply WfMod_getFlat in P1]. unfold getFlat in P1; simpl in *. unfold inlineAll_Rules. remember (Datatypes.length (getMethods m)) as n1. setoid_rewrite <- Heqn1. clear Heqn1. induction n1; auto. rewrite seq_eq. rewrite fold_left_app; simpl in *. pose proof (WfBaseMod_inlineSingle_Rules_pos n1 IHn1); simpl in *; auto. Qed. Lemma WfBaseMod_inlineAll_Rules_new ty m : WfBaseModule_new ty m -> WfBaseModule_new ty (BaseMod (getRegisters m) (inlineAll_Rules (getMethods m) (getRules m)) (getMethods m)). Proof. repeat rewrite <- WfBaseModule_WfBaseModule_new_iff. apply WfBaseMod_inlineAll_Rules. Qed. Definition inlineAll_Rules_BaseModuleWf {ty} (m : BaseModuleWf ty) := Build_BaseModuleWf (WfBaseMod_inlineAll_Rules (wfBaseModule m)). Definition inlineAll_Rules_BaseModuleWf_new {ty} (m : BaseModuleWf_new ty) := Build_BaseModuleWf_new (WfBaseMod_inlineAll_Rules_new (wfBaseModule_new m)). Lemma TraceInclusion_inlineAll_pos_Rules_Wf (m : BaseModuleWf type) : TraceInclusion m (inlineAll_Rules_BaseModuleWf m). Proof. specialize (TraceInclusion_flatten_r m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineAll_pos_Rules P2) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Rules_Wf_new (m : BaseModuleWf_new type) : TraceInclusion m (inlineAll_Rules_BaseModuleWf_new m). 
auto. intros a; case a. intros a1 l; case (list_eq_dec eq_bool_dec nil l); auto. intros e l0 H H0; case (H0 a1); rewrite e; simpl in |- *; auto. intros n l0 H H0; apply H. unfold not_null in |- *; intros a2; red in |- *; intros H1. case (H0 a2); simpl in |- *; auto. Qed. Fixpoint encode (c : code) (m : list A) {struct m} : list bool := match m with | nil => nil | a :: b => find_code a c ++ encode c b end. Theorem encode_app : forall l1 l2 c, encode c (l1 ++ l2) = encode c l1 ++ encode c l2. Proof using. intros l1; elim l1; simpl in |- *; auto. intros a l H l2 c; rewrite H; auto. rewrite app_ass; auto. Qed. Theorem encode_cons_inv : forall a l1 l m1, ~ In a m1 -> encode ((a, l1) :: l) m1 = encode l m1. Proof using. intros a l1 l m1; generalize a l1 l; elim m1; simpl in |- *; auto; clear a l1 l m1. intros a l H a0 l1 l0 H0; case (eqA_dec a a0); simpl in |- *; auto. intros H1; case H0; auto. intros e; rewrite H; auto. Qed. Theorem encode_permutation : forall (m : list A) (c1 c2 : code), permutation c1 c2 -> unique_prefix c1 -> encode c1 m = encode c2 m. Proof using. intros m; elim m; simpl in |- *; auto. intros a l H c1 c2 H0 H1. apply f_equal2 with (f := app (A:=bool)); auto. apply find_code_permutation; auto. Qed. Theorem encode_permutation_val : forall m1 m2 c, permutation m1 m2 -> permutation (encode c m1) (encode c m2). Proof using. intros m1 m2 c H; elim H; simpl in |- *; auto; clear H m1 m2. intros; repeat rewrite <- app_ass; auto. intros l1 l2 l3 H H0 H1 H2; apply permutation_trans with (1 := H0); auto. Qed. Fixpoint decode_aux (c : code) (head m : list bool) {struct m} : list A := match m with | nil => match find_val head c with | Some a => a :: nil | None => nil end | a :: m1 => match find_val head c with | Some a1 => a1 :: decode_aux c (a :: nil) m1 | None => decode_aux c (head ++ a :: nil) m1 end end. Theorem decode_aux_correct : forall c : code, unique_prefix c -> not_null c -> forall (m1 m2 head : list bool) (a : A), find_val (head ++ m1) c = Some a -> decode_aux c head (m1 ++ m2) = a :: decode_aux c nil m2. 
[[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * ([[ isError r ]] * LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' \/ [[ r = OK tt ]] * exists flist' f' ilist' frees', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * [[[ m' ::: (Fm * BFILE.rep bxp sm ixp flist' ilist' frees' (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[[ flist' ::: (Fi * inum |-> f') ]]] * [[[ RAData f' ::: rep f' (items ++ (updN block0 0 e)) ]]] * [[ BFILE.ilist_safe ilist (BFILE.pick_balloc frees (MSAlloc ms')) ilist' (BFILE.pick_balloc frees' (MSAlloc ms')) ]] * [[ BFILE.treeseq_ilist_safe inum ilist ilist' ]] ) CRASH:hm' LOG.intact lxp F m0 sm hm' >} extend lxp bxp ixp inum e ms. Proof. unfold extend, rep. prestep. norm. cancel. intuition. eauto. eauto. eauto. safestep. or_l; safecancel. or_r. norm; [ cancel | intuition eauto ]. simpl; pred_apply; norm; [ | intuition ]. cancel; apply extend_ok_helper; auto. apply extend_item_valid; auto. Qed. Theorem readall_ok : forall lxp ixp bxp inum ms, {< F Fm Fi m0 sm m flist f items ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * [[ r = items ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} readall lxp ixp inum ms. Proof. unfold readall, rep. safestep. step; msalloc_eq. rewrite synced_list_length, ipack_length; subst. unfold items_valid in *; intuition. substl (length items); rewrite divup_mul; auto. step; msalloc_eq. subst; rewrite synced_list_map_fst. unfold items_valid, RALen in *; intuition. erewrite iunpack_ipack_firstn; eauto. rewrite firstn_oob; auto. substl (length items); auto. cancel. Qed. Theorem init_ok : forall lxp bxp ixp inum ms, {< F Fm Fi m0 sm m flist f ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] POST:hm' RET:ms' exists m' flist' f' ilist' frees', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * [[[ m' ::: (Fm * BFILE.rep bxp sm ixp flist' ilist' frees' (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[[ flist' ::: (Fi * inum |-> f') ]]] * [[[ RAData f' ::: emp ]]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ BFILE.ilist_safe ilist (BFILE.pick_balloc frees (MSAlloc ms')) ilist' (BFILE.pick_balloc frees' (MSAlloc ms')) ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init lxp bxp ixp inum ms. 
sym_tanner_rel. by rewrite mem_seq1 eq_sym id_of_kind_neq.have [o Hs]: exists o, s = id_of_kind (negk k) o. move: Hun => /= /andP/proj1 /= /andP/proj1. destruct s as [o|o], k. by rewrite tanner_relE. move=> ?; by exists o. move=> ?; by exists o. by rewrite tanner_relE. congr {| children := _; up := _; down := _ |}. rewrite apply_seqs_but1 -!map_comp; last by apply unique_children. apply eq_in_map => [j] /= Hj. move: (Hj). rewrite select_children_spec => /andP [Hpj Hunj]. rewrite -IH //; last first. apply cons_uniq_path => //. by rewrite sym_tanner_rel. rewrite /down_msg. congr sumprod_down. congr Some. symmetry. rewrite msg_spec_alpha_beta // alpha_beta_tag_of_id. rewrite -imset_set1 kind_filter. rewrite filter_map -map_comp Hs. set ups := map (_ \o _ \o _) _. have ->: ups = [seq msg_spec' (id_of_kind (negk k) x) (id_of_kind k i) | x in [set x | (tanner_rel H (id_of_kind k i) \o id_of_kind (negk k)) x] :\ j :\ o]. apply eq_in_map_seqs. rewrite -Hs (select_children_def (j:=o) Hun) Hs //. rewrite /enum_mem. rewrite -filter_predI. apply eq_filter => x. rewrite /= !inE /=. rewrite !node_id_sumprod_up !node_id_build. rewrite (inj_eq (@id_of_kind_inj _ _ _)). by rewrite !andbA (andbC (x !=j)). move=> x /=. rewrite mem_filter !inE !node_id_sumprod_up !node_id_build. rewrite select_children_spec -Hs => /andP/proj2/andP [Hx1 Hx2]. rewrite Hspec' //=. apply cons_uniq_path => //. by rewrite sym_tanner_rel. rewrite /image_mem /enum_mem. rewrite -(map_cons (fun x => msg_spec' (id_of_kind (negk k) x) (id_of_kind k i))). apply eq_alpha_beta => //. apply uniq_perm. by rewrite filter_uniq // -enumT enum_uniq. rewrite /= filter_uniq //. by rewrite mem_filter !inE eqxx. by rewrite -enumT enum_uniq. move=> x /=. rewrite in_cons mem_filter /= mem_enum !inE -enumT mem_enum /=. case Hxo: (x == o). rewrite (eqP Hxo). move: Hunj. rewrite !in_cons Hs. rewrite (inj_eq (@id_of_kind_inj _ _ _)) (eq_sym j). move/norP/proj2/norP/proj1 => -> /=. move/andP/proj1: Hun. by rewrite /= Hs => /andP/proj1 ->. by destruct k; rewrite /= !inE andbT. congr alpha_beta. rewrite -!map_comp. symmetry. rewrite Hs in Hun Hspec' *. rewrite set1F -imset_set1 kind_filter. rewrite (select_children_def (j:=o) Hun) //. rewrite /image_mem. apply eq_in_map. move=> x /=. rewrite mem_filter !inE /= sym_tanner_rel => /andP [] /andP [Hx1 Hx2] _. rewrite -/msg_spec' Hspec' //. apply: cons_uniq_path => //. rewrite !in_cons !negb_or. rewrite (ext_uniq_path tanner_acyclic Hun) //. rewrite (eq_sym (id_of_kind _ x)) id_of_kind_neq //=. by rewrite (inj_eq (@id_of_kind_inj _ _ _)) Hx1. apply msg_spec_alpha_beta. rewrite sym_tanner_rel. by move/andP/proj1: Hun => /= /andP/proj1. Qed.Corollary computed_tree_ok : computed_tree_spec vb d. Proof. by apply tree_ok; rewrite // card0 subn0. Qed. Theorem message_ok (a b : id') h (s : seq id') k (i : ord_of_kind m n' k) : let t := build_computed_tree h s i in (#|id'| - #|s| <= h)%nat -> uniq_path (tanner_rel H) (id_of_kind k i) s -> tanner_rel H a b -> a \in prec_node s ++ labels t -> b \in prec_node s ++ labels t -> msg a b (prec_node s) t = [:: msg_spec' a b]. 
Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Tactics.Example and_exercise : forall n m : nat, n + m = 0 -> n = 0 /\ m = 0. Admitted. Instance testSuchThat_Conj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, Q b -> prop a b)} : Checkable (forall a b, P a /\ Q b -> prop a b) := {| checker f := checker (fun a P b Q => f a b _ ) |}. Proof. split; auto. Defined.Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Admitted. Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Admitted. Instance testSuchThat_Disj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, prop a b)} `{Checkable (forall b, Q b -> forall a, prop a b)} : Checkable (forall a b, P a \/ Q b -> prop a b) := {| checker f := disjoin (Datatypes.cons (checker (fun a P b => f a b _ )) (Datatypes.cons (checker (fun b Q a => f a b _)) Datatypes.nil)) |}. Proof. - left; auto. - right; auto. Defined. Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Admitted. Lemma or_intro : forall A B : Prop, A -> A \/ B. Admitted. Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Admitted. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Admitted. Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Admitted. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Admitted. Theorem contradiction_implies_anything : forall P Q : Prop, (P /\ ~P) -> Q. 
simpl in *; try match goal with | _ : key_in_output_trace _ _ [] |- _ => unfold key_in_output_trace in *; break_exists; simpl in *; intuition end. - unfold key_in_output_trace in *. break_exists; simpl in *; intuition. find_inversion. unfold RaftNetHandler in *. repeat break_let. repeat find_inversion. simpl in *. find_eapply_lem_hyp RIR_handleMessage; eauto. find_copy_eapply_lem_hyp RIR_doLeader; simpl in *; rewrite_update; eauto. find_apply_lem_hyp key_in_output_list_split. intuition; [exfalso; eapply doLeader_key_in_output_list; eauto|]. match goal with | _ : doLeader ?st ?h = _, _ : doGenericServer _ ?d = _ |- _ => replace st with ((update name_eq_dec (nwState net) h st) h) in *; [|rewrite_update; auto] end. find_apply_lem_hyp doLeader_appliedEntries. rewrite_update. repeat find_rewrite_lem update_overwrite. unfold data in *. simpl in *. match goal with | _ : raft_intermediate_reachable (mkNetwork ?ps ?st), H : doGenericServer ?h ?r = _ |- _ => replace r with (nwState (mkNetwork ps st) h) in H by (simpl in *; rewrite_update; auto) end. find_eapply_lem_hyp doGenericServer_key_in_output_list; [|idtac|eauto|]; eauto. simpl in *. find_rewrite_lem update_overwrite. auto. - unfold key_in_output_trace in *. break_exists; simpl in *; intuition. find_inversion. unfold RaftInputHandler in *. repeat break_let. repeat find_inversion. simpl in *. find_copy_eapply_lem_hyp RIR_handleInput; eauto. find_copy_eapply_lem_hyp RIR_doLeader; simpl in *; rewrite_update; eauto. find_apply_lem_hyp key_in_output_list_split. intuition; [exfalso; eapply handleInput_key_in_output_list; eauto|]. find_apply_lem_hyp key_in_output_list_split. intuition; [exfalso; eapply doLeader_key_in_output_list; eauto|]. match goal with | _ : doLeader ?st ?h = _, _ : doGenericServer _ ?d = _ |- _ => replace st with ((update name_eq_dec (nwState net) h st) h) in *; [|rewrite_update; auto] end. find_apply_lem_hyp doLeader_appliedEntries. rewrite_update. repeat find_rewrite_lem update_overwrite. unfold data in *. simpl in *. match goal with | _ : raft_intermediate_reachable (mkNetwork ?ps ?st), H : doGenericServer ?h ?r = _ |- _ => replace r with (nwState (mkNetwork ps st) h) in H by (simpl in *; rewrite_update; auto) end. find_eapply_lem_hyp doGenericServer_key_in_output_list; [|idtac|eauto|]; eauto. simpl in *. find_rewrite_lem update_overwrite. auto. Qed. Section inner. Variable client : clientId. Variables id id' : nat. Variable id_lt_id' : id < id'. Program Instance TR : TraceRelation step_failure := { init := step_failure_init; T := key_in_output_trace client id ; T_dec := key_in_output_trace_dec client id ; R := fun s => before_func (has_key client id) (has_key client id') (applied_entries (nwState (snd s))) }. Next Obligation. simpl in *. find_apply_lem_hyp step_failure_star_raft_intermediate_reachable. find_eapply_lem_hyp applied_entries_monotonic'; eauto. break_exists; repeat find_rewrite. eauto using before_func_app. Defined. Next Obligation. unfold key_in_output_trace in *. intuition. break_exists; intuition. Defined. Next Obligation. find_apply_lem_hyp step_failure_star_raft_intermediate_reachable. find_apply_lem_hyp in_output_changed; auto. eauto using output_implies_greatest. Defined. Theorem output_greatest_id : forall failed net tr, step_failure_star step_failure_init (failed, net) tr -> key_in_output_trace client id tr -> before_func (has_key client id) (has_key client id') (applied_entries (nwState net)). 
<- (Rabs_pos_eq (bpow _)) by apply bpow_ge_0. apply Rsqr_lt_abs_0. rewrite Rsqr_sqrt by now apply Rlt_le. apply Rlt_le_trans with (1 := proj2 He). unfold Rsqr ; rewrite <- bpow_plus. apply bpow_le. generalize (Zdiv2_odd_eqn (e + 1)). destruct Z.odd ; intros ; lia. Qed.Lemma mag_1 : mag 1 = 1%Z :> Z. Proof. apply mag_unique_pos; rewrite bpow_1; simpl; split; [now right|apply IZR_lt]. assert (H := Zle_bool_imp_le _ _ (radix_prop r)); revert H. now apply Z.lt_le_trans. Qed.End pow.Section Bool.Theorem eqb_sym : forall x y, Bool.eqb x y = Bool.eqb y x. Proof. now intros [|] [|]. Qed.Theorem eqb_false : forall x y, x = negb y -> Bool.eqb x y = false. Proof. now intros [|] [|]. Qed.Theorem eqb_true : forall x y, x = y -> Bool.eqb x y = true. Proof. now intros [|] [|]. Qed.End Bool.Section cond_Ropp.Definition cond_Ropp (b : bool) m := if b then Ropp m else m.Theorem IZR_cond_Zopp : forall b m, IZR (cond_Zopp b m) = cond_Ropp b (IZR m). Proof. intros [|] m. apply opp_IZR. apply refl_equal. Qed.Theorem abs_cond_Ropp : forall b m, Rabs (cond_Ropp b m) = Rabs m. Proof. intros [|] m. apply Rabs_Ropp. apply refl_equal. Qed.Theorem cond_Ropp_Rlt_bool : forall m, cond_Ropp (Rlt_bool m 0) m = Rabs m. Proof. intros m. apply sym_eq. case Rlt_bool_spec ; intros Hm. now apply Rabs_left. now apply Rabs_pos_eq. Qed.Theorem Rlt_bool_cond_Ropp : forall x sx, (0 < x)%R -> Rlt_bool (cond_Ropp sx x) 0 = sx. Proof. intros x sx Hx. destruct sx; simpl. - apply Rlt_bool_true. now apply Ropp_lt_gt_0_contravar. - apply Rlt_bool_false. now left. Qed.Theorem cond_Ropp_involutive : forall b x, cond_Ropp b (cond_Ropp b x) = x. Proof. intros [|] x. apply Ropp_involutive. apply refl_equal. Qed.Theorem cond_Ropp_inj : forall b x y, cond_Ropp b x = cond_Ropp b y -> x = y. Proof. intros b x y H. rewrite <- (cond_Ropp_involutive b x), H. apply cond_Ropp_involutive. Qed.Theorem cond_Ropp_mult_l : forall b x y, cond_Ropp b (x * y) = (cond_Ropp b x * y)%R. Proof. intros [|] x y. apply sym_eq. apply Ropp_mult_distr_l_reverse. apply refl_equal. Qed.Theorem cond_Ropp_mult_r : forall b x y, cond_Ropp b (x * y) = (x * cond_Ropp b y)%R. Proof. intros [|] x y. apply sym_eq. apply Ropp_mult_distr_r_reverse. apply refl_equal. Qed.Theorem cond_Ropp_plus : forall b x y, cond_Ropp b (x + y) = (cond_Ropp b x + cond_Ropp b y)%R. Proof. intros [|] x y. apply Ropp_plus_distr. apply refl_equal. Qed.End cond_Ropp. Theorem LPO_min : forall P : nat -> Prop, (forall n, P n \/ ~ P n) -> {n : nat | P n /\ forall i, (i < n)%nat -> ~ P i} + {forall n, ~ P n}. 
singleton_list := cons 42 nil.Definition one_two_three := cons 1 (cons 2 (cons 3 nil)).Fixpoint concat (l1 l2 : natlist) : natlist := match l1 with | nil => l2 | cons h t => cons h (concat t l2) end.Theorem test_concat1: concat (cons 1 (cons 2 nil)) (cons 3 (cons 4 nil)) = (cons 1 (cons 2 (cons 3 (cons 4 nil)))). Proof. simpl. reflexivity. Qed. Theorem concat_nil_left : forall l : natlist, concat nil l = l. Proof. Qed.Theorem concat_nil_right : forall l : natlist, concat l nil = l. Proof. Qed. Theorem concat_associativity : forall l2 l1 l3 : natlist, concat (concat l1 l2) l3 = concat l1 (concat l2 l3). Proof. Qed. Fixpoint snoc (l: natlist) (v: nat) : natlist := match l with | nil => cons v nil | cons h t => cons h (snoc t v) end. Fixpoint rev (l: natlist) : natlist := match l with | nil => nil | cons h t => snoc (rev t) h end. Theorem rev_snoc : forall x l, rev (snoc l x) = cons x (rev l). Proof. Qed.Theorem rev_involutive : forall l : natlist, rev (rev l) = l. Proof. Qed.Theorem concat_cons_snoc : forall l1 x l2, concat l1 (cons x l2) = concat (snoc l1 x) l2. Proof. Qed.Module LogicExercises.Theorem goright_example : 0 = 1 \/ 1 = 1. Proof. right. reflexivity. Qed.Theorem go_somewhere : 0 = 1 \/ (2 = 2 \/ 2 = 3). Proof. Qed.Theorem B_is_enough : forall A B : Prop, B -> A \/ B. Proof. Qed.Theorem two_facts : nil = nil /\ 42 = 42. Proof. split. reflexivity. reflexivity. Qed.Theorem more_facts : 1 = 2 \/ (1 = 1 /\ nil = nil). Proof. Qed.Theorem A_and_B : forall A B : Prop, A -> B -> A /\ B. Proof. Qed.End LogicExercises.Theorem snoc_concat_end : forall (l: natlist) (n: nat), snoc l n = concat l (cons n nil). Proof. Qed.Theorem rev_distributes_over_concat : forall l1 l2 : natlist, rev (concat l1 l2) = concat (rev l2) (rev l1). Proof. Qed. Fixpoint map (f: nat -> nat) (l: natlist) := match l with | nil => nil | cons x xs => cons (f x) (map f xs) end.Theorem map_commutes : forall f g l, (forall x, f (g x) = g (f x)) -> map f (map g l) = map g (map f l). Proof. Qed. Theorem map_fusion : forall f g l, map f (map g l) = map (fun x => f (g x)) l. 
Require Export Iron.Language.SystemF2Data.Type. Require Export Iron.Language.SystemF2Data.Exp.Lit. Require Export Iron.Language.SystemF2Data.Exp.Prim. Inductive exp : Type := | XVar : nat -> exp | XLAM : exp -> exp | XAPP : exp -> ty -> exp | XLam : ty -> exp -> exp | XApp : exp -> exp -> exp | XCon : datacon -> list ty -> list exp -> exp | XCase : exp -> list alt -> exp | XPrim : prim -> list exp -> exp | XLit : lit -> exp with alt : Type := | AAlt : datacon -> exp -> alt.Hint Constructors exp. Hint Constructors alt. Theorem exp_mutind : forall (PX : exp -> Prop) (PA : alt -> Prop) , (forall n, PX (XVar n)) -> (forall x1, PX x1 -> PX (XLAM x1)) -> (forall x1 t2, PX x1 -> PX (XAPP x1 t2)) -> (forall t x1, PX x1 -> PX (XLam t x1)) -> (forall x1 x2, PX x1 -> PX x2 -> PX (XApp x1 x2)) -> (forall dc ts xs, Forall PX xs -> PX (XCon dc ts xs)) -> (forall x aa, PX x -> Forall PA aa -> PX (XCase x aa)) -> (forall p xs, Forall PX xs -> PX (XPrim p xs)) -> (forall l, PX (XLit l)) -> (forall dc x, PX x -> PA (AAlt dc x)) -> forall x, PX x. 
Require Export Arith.Set Implicit Arguments.Section DecidableEqDep. Variable A : Type. Let comp (x y y':A) (eq1:x = y) (eq2:x = y') : y = y' := eq_ind _ (fun a => a = y') eq2 _ eq1. Remark trans_sym_eq : forall (x y:A) (u:x = y), comp u u = refl_equal y. Proof. intros; now case u; trivial. Qed. Variable eq_dec : forall x y:A, x = y \/ x <> y. Variable x : A. Let nu (y:A) (u:x = y) : x = y := match eq_dec x y with | or_introl eqxy => eqxy | or_intror neqxy => False_ind _ (neqxy u) end. Let nu_constant : forall (y:A) (u v:x = y), nu u = nu v. Proof. intros;unfold nu in |- *; case (eq_dec x y); intro e. - reflexivity. - case e; trivial. Qed. Let nu_inv (y:A) (v:x = y) : x = y := comp (nu (refl_equal x)) v. Remark nu_left_inv : forall (y:A) (u:x = y), nu_inv (nu u) = u. Proof. intros; case u; unfold nu_inv in |- *. apply trans_sym_eq. Qed. Theorem eq_proofs_unicity : forall (y:A) (p1 p2:x = y), p1 = p2. Proof. intros. rewrite <- nu_left_inv with (u := p1). rewrite <- nu_left_inv with (u := p2). now rewrite <- (nu_constant p1 p2). Qed. Theorem K_dec : forall P:x = x -> Prop, P (refl_equal x) -> forall p:x = x, P p. intros P H p. now rewrite <- eq_proofs_unicity with x (refl_equal x) p. Qed.End DecidableEqDep. Theorem K_dec_Type : forall A:Type, (forall x y:A, {x = y} + {x <> y}) -> forall (x:A) (P:x = x -> Prop), P (refl_equal x) -> forall p:x = x, P p. 
op_iff in Heq as []. subst. zfc_simple. - intros y Hy. apply CPrdE1 in Hy as [a [Ha [b [Hb Hy]]]]. subst. exists <b, a>. split. apply CPrdI... zfc_simple. Qed.Fact cardAdd_k_k : ‚àÄ ùú , ùú + ùú = 2 ‚ã ùú . Proof with auto. intros. rewrite cardMul_comm. apply CardAx1. cut (ùú √ó {0,} ‚à™ ùú √ó {1,} = ùú √ó 2). { intros H. now rewrite H. } assert (H1_2: 1 ‚àà 2). apply suc_has_n. assert (H0_2: 0 ‚àà 2) by (apply suc_has_0; apply œâ_inductive; nauto). ext Hx. - apply BUnionE in Hx as []. + apply CPrdE1 in H as [a [Ha [b [Hb H]]]]. apply SingE in Hb. subst. apply CPrdI... + apply CPrdE1 in H as [a [Ha [b [Hb H]]]]. apply SingE in Hb. subst. apply CPrdI... - apply CPrdE1 in Hx as [a [Ha [b [Hb Hx]]]]. subst. apply BUnionE in Hb as []. + apply BUnionE in H as []. exfalso0. apply BUnionI1. apply CPrdI... + apply SingE in H. subst b. apply BUnionI2. apply CPrdI... Qed. Theorem cardAdd_assoc : ‚àÄ ùú ùúÜ ùúá, (ùú + ùúÜ) + ùúá = ùú + (ùúÜ + ùúá). Proof with neauto; try congruence; try easy. intros. apply CardAx1. assert (Hnq: Embed 1 = Embed 2 ‚Üí False). { intros. apply (nat_irrefl 2)... rewrite <- H at 1. apply suc_has_n. } eapply Equivalence_Transitive. { apply cardAdd_well_defined. - unfold CardAdd. rewrite <- eqnum_cprd_single, <- CardAx0... - rewrite <- eqnum_cprd_single, (eqnum_cprd_single _ 2)... - apply disjointify_0_1. - unfold disjoint. rewrite binter_comm, binter_bunion_distr. apply EmptyI. intros x Hx. apply BUnionE in Hx as []; apply BInterE in H as []. + eapply disjointE. apply (cprd_disjointify ùúá ùú 2 0). apply suc_neq_0. apply H. apply H0. + eapply disjointE. apply (cprd_disjointify ùúá ùúÜ 2 1). intro. apply Hnq... apply H. apply H0. } symmetry. eapply Equivalence_Transitive. { apply cardAdd_well_defined. - reflexivity. - unfold CardAdd. rewrite <- eqnum_cprd_single, <- CardAx0. apply cardAdd_well_defined. + rewrite <- eqnum_cprd_single, (eqnum_cprd_single _ 1)... + rewrite <- eqnum_cprd_single, (eqnum_cprd_single _ 2)... + apply disjointify_0_1. + apply cprd_disjointify. intro. apply Hnq... - apply disjointify_0_1. - unfold disjoint. rewrite binter_bunion_distr. apply EmptyI. intros x Hx. apply BUnionE in Hx as []. + pose proof (disjointify_0_1 ùú ùúÜ). rewrite H0 in H. exfalso0. + apply BInterE in H as []. eapply disjointE. apply (cprd_disjointify ùú ùúá 0 2). intro. eapply suc_neq_0... apply H. apply H0. } rewrite bunion_assoc... Qed. Theorem cardMul_assoc : ‚àÄ ùú ùúÜ ùúá, (ùú ‚ã ùúÜ) ‚ã ùúá = ùú ‚ã (ùúÜ ‚ã ùúá). 
Require Import Mem. Require Import Prog. Require Import List. Require Import Array. Require Import Pred. Require Import FunctionalExtensionality. Require Import Word. Require Import WordAuto. Require Import Omega. Require Import Ring. Require Import SepAuto. Require Import ListUtils. Require Import ListPred.Set Implicit Arguments. Definition list2nmem (A: Type) (l: list A) : (@mem nat eq_nat_dec A) := fun a => selN (map (@Some A) l) a None.Notation "[[[ NS ':::' P ]]]" := [[ (P)%pred (list2nmem NS) ]]%pred : pred_scope. Notation "„Äê NS '‚Ä£‚Ä£' P „Äë" := [[ (P)%pred (list2nmem NS) ]]%pred : pred_scope.Theorem list2nmem_oob : forall A (l : list A) i, i >= length l -> (list2nmem l) i = None. Proof. unfold list2nmem; intros. rewrite selN_oob; auto. rewrite map_length; auto. Qed. Theorem list2nmem_inbound: forall A F (l : list A) i x, (F * i |-> x)%pred (list2nmem l) -> i < length l. 
ofs + size_chunk chunk -> ~ L b i)%Z -> Mem.store chunk m' b ofs v = Some m'' -> Mem.unchanged_on L m m'. Proof. intros. inv H. constructor. - apply Mem.nextblock_store in H1. rewrite <- H1. auto. - split; intros. eapply Mem.perm_store_2. apply H1. apply unchanged_on_perm; auto. apply unchanged_on_perm; auto. eapply Mem.perm_store_1; eauto. - intros. rewrite <- unchanged_on_contents; auto. symmetry. erewrite Mem.store_mem_contents; eauto. rewrite Maps.PMap.gsspec. destruct (Coqlib.peq b0 b); auto. subst b0. apply Mem.setN_outside. rewrite encode_val_length. rewrite <- size_chunk_conv. destruct (Coqlib.zlt ofs0 ofs); auto. destruct (Coqlib.zlt ofs0 (ofs + size_chunk chunk)); auto. elim (H0 ofs0). chunk_red; omega. auto. Qed. Theorem sem_shr_unboxed: forall n, sem_shr (make_vint (Ptrofs.unsigned n)) val (make_vint 1) val = Some (make_vint (Z.shiftr (Ptrofs.unsigned n) 1)). Proof. intros. unfold sem_shr. unfold sem_shift. simpl. assert (Hrange:= uint_range_unsigned n). destruct Archi.ptr64 eqn:Harchi; archi_red; unfold classify_shift; simpl. { rewrite Int64.shru_div_two_p. rewrite Int64.Zshiftr_div_two_p by omega. rewrite Int64.unsigned_repr by (archi_red; solve_uint_range; omega). unfold Int64.iwordsize. unfold Int64.zwordsize. simpl. unfold Int64.ltu. rewrite Int64.unsigned_repr by (unfold Int64.max_unsigned; solve_uint_range; omega). rewrite Int64.unsigned_repr by (unfold Int64.max_unsigned; solve_uint_range; omega). unfold classify_shift. simpl. reflexivity. } { rewrite Int.shru_div_two_p. rewrite Int.Zshiftr_div_two_p by omega. rewrite Int.unsigned_repr by (archi_red; solve_uint_range; omega). unfold Int.iwordsize. unfold Int.zwordsize. simpl. unfold Int.ltu. rewrite Int.unsigned_repr by (solve_uint_range; omega). rewrite Int.unsigned_repr by (solve_uint_range; omega). unfold classify_shift. simpl. reflexivity. } Qed. Theorem sem_switch_and_255: forall h, (0 <= h <= Ptrofs.max_unsigned)%Z -> sem_switch_arg (int_and h 255) uval = Some (Z.land h 255). Proof. intros. rewrite ptrofs_mu in H. unfold sem_switch_arg. unfold int_and. destruct Archi.ptr64 eqn:Harchi; archi_red; unfold classify_shift; simpl. { unfold Int64.and. rewrite Int64.unsigned_repr with (z := h) by (archi_red; solve_uint_range; omega). rewrite Int64.unsigned_repr with (z := 255%Z) by (archi_red; solve_uint_range; omega). rewrite Int64.unsigned_repr. reflexivity. replace 255%Z with (Z.ones 8) by reflexivity. rewrite Z.land_ones. unfold Int64.max_unsigned in *; simpl in *. assert ( (0 <= h mod Z.pow_pos 2 8 < Z.pow_pos 2 8)%Z). apply Z.mod_bound_pos. omega. compute. reflexivity. destruct H0. split; auto. eapply OrdersEx.Z_as_OT.lt_le_incl. eapply OrdersEx.Z_as_DT.lt_le_trans. eauto. compute. intro. inv H2. omega. } { unfold Int.and. rewrite Int.unsigned_repr with (z := h) by (archi_red; solve_uint_range; omega). rewrite Int.unsigned_repr with (z := 255%Z) by (archi_red; solve_uint_range; omega). rewrite Int.unsigned_repr. reflexivity. replace 255%Z with (Z.ones 8) by reflexivity. rewrite Z.land_ones. unfold Int.max_unsigned in *; simpl in *. assert ( (0 <= h mod Z.pow_pos 2 8 < Z.pow_pos 2 8)%Z). apply Z.mod_bound_pos. omega. compute. reflexivity. destruct H0. split; auto. eapply OrdersEx.Z_as_OT.lt_le_incl. eapply OrdersEx.Z_as_DT.lt_le_trans. eauto. compute. intro. inv H2. omega. } Qed. Theorem sem_switch_arg_1: forall n, (0 <= n <= Ptrofs.max_unsigned)%Z -> sem_switch_arg (int_shru n 1) uval = Some (Z.shiftr n 1). 
rewrite -rsum_Rmul_distr_l; rewrite -rsum_Rmul_distr_l. rewrite mulRA [(#|[finType of l.-tuple _]| %R) *R* _ ]mulRC -mulRA. apply Logic.eq_sym; under eq_bigr => ? ? do rewrite mulRC; rewrite -rsum_Rmul_distr_l mulRC [(Rdefinitions.Rinv _) *R* _] mulRC -!mulRA; apply f_equal; rewrite mulRC -mulRA mulRC; apply Logic.eq_sym. rewrite !card_tuple //=; rewrite expnSr card_ord natRM mulRC. apply Logic.eq_sym; rewrite mulRC rsum_tuple_split rsum_split //=; apply Logic.eq_sym; apply f_equal; apply Logic.eq_sym. rewrite -mulRA mulRC mulRV ?exp1R//= ?mul1R //=. by rewrite RIneq.INR_IZR_INZ; apply/eqP => //=. Qed. Lemma bloomfilter_addn_insert_multiple_inv hashes l (ind: 'I_Hash_size.+1) (bf: BloomFilter) (values: seq B): length values == l -> hashes_have_free_spaces hashes l -> all (hashes_value_unseen hashes) values -> uniq values -> ~~ bloomfilter_get_bit ind bf -> (d[ res <-$ @AMQ_add_multiple (n,k.-1) I hashes bf values; (let '(_, bf') := res in ret bloomfilter_get_bit ind bf')]) true = (1 -R- ((1 -R- Rdefinitions.Rinv (Hash_size.+1 %R)) ^R^ (k * l))). Proof. move=> Hlen Hhashes Huns Huniq Hnth. transitivity ( (d[ res <-$ @AMQ_add_multiple (n,k.-1) I hashes bf values; ret (fun res' => (let '(_, bf') := res' in bloomfilter_get_bit ind bf')) res]) true ). - by rewrite //= !FDistBind.dE; apply/eq_bigr=>[[hs' bf']] _ //=. rewrite -(prsumr_neg1 ). transitivity ( (1 -R- (d[ res <-$ @AMQ_add_multiple (n,k.-1) I hashes bf values; (let '(_, bf') := res in ret ~~ bloomfilter_get_bit ind bf')]) true) ). - by rewrite //= !FDistBind.dE; apply f_equal; apply/eq_bigr=>[[hs' bf']] _ //=. by rewrite (@bloomfilter_addn_insert_multiple _ l). Qed. Lemma bloomfilter_hits_preserve (xs : seq B) (l : nat_eqType) (m : nat) hshs hshs' (bf bf' : bloomfilter_finType) inds : length xs == l -> all (bloomfilter_get_bit^~ bf) inds -> (d[ @AMQ_add_multiple (n,k.-1) I hshs bf xs]) (hshs', bf') != (0 %R) -> all (bloomfilter_get_bit^~ bf') inds. Proof. move: hshs hshs'. rewrite/AMQ_add_multiple/AMQState/AMQ_add/AMQ_add_internal/AMQHash_hash. change (AMQHash (n, k.-1)) with ([finType of k.-1.+1.-tuple (HashVec.Hash.HashState n)]). change (AMQHashValue (n, k.-1)) with ([finType of k.-1.+1.-tuple 'I_Hash_size.+1]). change ((n, k.-1).2.+1) with (k.-1.+1). change ((n, k.-1).1) with n. rewrite (@prednK k Hkgt0). move=> hshs hshs'. elim: l xs bf inds hshs' bf' => [//= [|//=]| l IHl [//=| x xs]] bf inds hshs' bf' Hlen Hall //=. - by comp_normalize =>/bool_neq0_true; rewrite xpair_eqE => /andP[_/eqP->]. - { comp_normalize. comp_possible_decompose. move=> hshs1 bf1 hsh2 bf2 Haddm Hint/bool_neq0_true;rewrite xpair_eqE=>/andP[_/eqP->]. have H1: length xs == l; first by move/eqP: Hlen => [->]. move: Haddm; move=>/(@IHl xs _ _ hshs1 bf1 H1 Hall) //=. move=>/allP Hget; apply/allP => ind Hind. apply bloomfilter_add_internal_preserve. move: (Hget ind Hind) => //=. } Qed. Theorem bloomfilter_addn_bits hashes b (inds: seq 'I_Hash_size.+1) (bf: BloomFilter) (value: B): b < k -> length inds == b -> @AMQHash_hashstate_available_capacity (n,k.-1) hashes 1 -> (@AMQHash_hashstate_unseen (n,k.-1) hashes value) -> uniq inds -> all (fun ind => ~~ bloomfilter_get_bit ind bf) inds -> (d[ res <-$ @AMQ_add (n,k.-1) I bf hashes value; (let '(_, bf') := res in ret (all (bloomfilter_get_bit^~ bf') inds))]) true = \sum_(i in tuple_finType k (ordinal_finType Hash_size.+1)) ((((inds \subseteq i) == true) %R) *R* (Rdefinitions.Rinv (Hash_size.+1 %R) ^R^ k)). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main. Class Terminal (C : Category) : Type := { terminal : C; t_morph : ‚àÄ (d : Obj), (d ‚Äì‚âª terminal)%morphism; t_morph_unique : ‚àÄ (d : Obj) (f g : (d ‚Äì‚âª terminal)%morphism), f = g }.Arguments terminal {_} _. Arguments t_morph {_} _ _. Arguments t_morph_unique {_} _ _ _ _.Coercion terminal : Terminal >-> Obj.Notation "ùüô_ C" := (Terminal C) (at level 75) : object_scope. Theorem Terminal_iso {C : Category} (T T' : (ùüô_ C)%object) : (T ‚âÉ T')%isomorphism. 
dest; constructor. + rewrite createHideMod_Meths; apply (H a); left; reflexivity. + apply IHl; intros; split;auto. Qed.Lemma WfActionT_flatten m k ty: forall (a : ActionT ty k), WfActionT (getRegisters m) a <-> WfActionT (getRegisters (getFlat (Base m))) a. Proof. intro; split; induction 1; econstructor; eauto. Qed.Theorem flatten_WfMod ty m: WfMod ty m -> WfMod ty (flatten m). Proof. unfold flatten. induction 1; simpl; auto; intros. - constructor; auto. - constructor; auto. rewrite createHide_Meths. auto. - unfold getFlat in *; simpl. rewrite WfMod_createHide in *; dest; simpl in *. split. + rewrite map_app. unfold SubList in *; intros. rewrite in_app_iff in *. specialize (H3 x). specialize (H1 x). tauto. + constructor;inversion H4; inversion H2; inversion HWfBaseModule; inversion HWfBaseModule0; subst. * split; intros. -- destruct (in_app_or _ _ _ H6). ++ specialize (H5 _ H7). induction H5; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; left; assumption. ++ specialize (H9 _ H7). induction H9; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; right; assumption. -- repeat split; simpl; intros; dest; try (eapply NoDup_DisjKey; eauto). ++ destruct (in_app_or _ _ _ H6). ** specialize (H8 _ H16 v). induction H8; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; left; assumption. ** specialize (H7 _ H16 v). induction H7; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; right; assumption. Qed.Theorem flatten_WfMod_new ty m : WfMod_new ty m -> WfMod_new ty (flatten m). Proof. repeat rewrite WfMod_new_WfMod_iff. apply flatten_WfMod. Qed.Definition flatten_ModWf ty m: ModWf ty := (Build_ModWf (flatten_WfMod (wfMod m))).Definition flatten_ModWf_new ty m: ModWf_new ty := (Build_ModWf_new _ _ (flatten_WfMod_new _ _ (wfMod_new m))).Section TraceSubstitute. Variable m: ModWf type. Lemma Trace_flatten_same1: forall o l, Trace m o l -> Trace (flatten m) o l. Proof. induction 1; subst. - constructor 1; auto. unfold flatten. rewrite createHide_Regs. auto. - apply (@Step_substitute type) in HStep; auto. + econstructor 2; eauto. + destruct m; auto. Qed. Lemma Trace_flatten_same2: forall o l, Trace (flatten m) o l -> (exists l', (PermutationEquivLists l l') /\ Trace m o l'). Proof. induction 1; subst. - rewrite getAllRegisters_flatten in *. exists nil;split;constructor 1; auto. - apply substitute_Step in HStep;auto; dest. exists (x0::x);split. + constructor; auto. + econstructor 2; eauto. apply (Permutation_map fst) in H2. eapply UpdRegs_perm; eauto. + destruct m; auto. Qed. Theorem TraceInclusion_flatten_r: TraceInclusion m (flatten_ModWf m). Proof. unfold TraceInclusion; intros. exists o1, ls1. repeat split; auto; intros; unfold nthProp2; intros; try destruct (nth_error ls1 i); auto; repeat split; intros; try tauto. apply Trace_flatten_same1; auto. Qed. Theorem TraceInclusion_flatten_l: TraceInclusion (flatten_ModWf m) m. 
:= proj2 He). apply bpow_le. cut (ex' - prec <= ex)%Z. lia. unfold ex, FLT_exp. apply Z.le_max_l. apply Z.le_max_r. Qed.Theorem generic_format_FLT_bpow : forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e). Proof. intros e He. apply generic_format_bpow; unfold FLT_exp. apply Z.max_case; try assumption. unfold Prec_gt_0 in prec_gt_0_; lia. Qed.Theorem FLT_format_bpow : forall e, (emin <= e)%Z -> FLT_format (bpow e). Proof. intros e He. apply FLT_format_generic. now apply generic_format_FLT_bpow. Qed.Theorem FLT_format_satisfies_any : satisfies_any FLT_format. Proof. refine (satisfies_any_eq _ _ _ (generic_format_satisfies_any beta FLT_exp)). intros x. split. apply FLT_format_generic. apply generic_format_FLT. Qed.Theorem cexp_FLT_FLX : forall x, (bpow (emin + prec - 1) <= Rabs x)%R -> cexp beta FLT_exp x = cexp beta (FLX_exp prec) x. Proof. intros x Hx. assert (Hx0: x <> 0%R). intros H1; rewrite H1, Rabs_R0 in Hx. contradict Hx; apply Rlt_not_le, bpow_gt_0. unfold cexp. apply Zmax_left. destruct (mag beta x) as (ex, He). unfold FLX_exp. simpl. specialize (He Hx0). cut (emin + prec - 1 < ex)%Z. lia. apply (lt_bpow beta). apply Rle_lt_trans with (1 := Hx). apply He. Qed. Global Instance FLT_exp_monotone : Monotone_exp FLT_exp. Proof. intros ex ey. unfold FLT_exp. zify ; lia. Qed. Global Instance exists_NE_FLT : (Z.even beta = false \/ (1 < prec)%Z) -> Exists_NE beta FLT_exp. Proof. intros [H|H]. now left. right. intros e. unfold FLT_exp. destruct (Zmax_spec (e - prec) emin) as [(H1,H2)|(H1,H2)] ; rewrite H2 ; clear H2. generalize (Zmax_spec (e + 1 - prec) emin). generalize (Zmax_spec (e - prec + 1 - prec) emin). lia. generalize (Zmax_spec (e + 1 - prec) emin). generalize (Zmax_spec (emin + 1 - prec) emin). lia. Qed. Theorem generic_format_FLT_FLX : forall x : R, (bpow (emin + prec - 1) <= Rabs x)%R -> generic_format beta (FLX_exp prec) x -> generic_format beta FLT_exp x. Proof. intros x Hx H. destruct (Req_dec x 0) as [Hx0|Hx0]. rewrite Hx0. apply generic_format_0. unfold generic_format, scaled_mantissa. now rewrite cexp_FLT_FLX. Qed.Theorem generic_format_FLX_FLT : forall x : R, generic_format beta FLT_exp x -> generic_format beta (FLX_exp prec) x. Proof. clear prec_gt_0_. intros x Hx. unfold generic_format in Hx; rewrite Hx. apply generic_format_F2R. intros _. rewrite <- Hx. unfold cexp, FLX_exp, FLT_exp. apply Z.le_max_l. Qed.Theorem round_FLT_FLX : forall rnd x, (bpow (emin + prec - 1) <= Rabs x)%R -> round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x. Proof. intros rnd x Hx. unfold round, scaled_mantissa. rewrite cexp_FLT_FLX ; trivial. Qed. Theorem cexp_FLT_FIX : forall x, x <> 0%R -> (Rabs x < bpow (emin + prec))%R -> cexp beta FLT_exp x = cexp beta (FIX_exp emin) x. 
l3:list par) (t1 t2:bin), parse_rel l1 (close :: l2) t1 -> parse_rel l2 l3 t2 -> parse_rel (open :: l1) l3 (N t1 t2) | parse_leaf_nil : parse_rel nil nil L | parse_leaf_close : forall l:list par, parse_rel (close :: l) (close :: l) L. Theorem parse_rel_sound_aux : forall (l1 l2:list par) (t:bin), parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2. Proof. intros l1 l2 t H; elim H; clear H l1 l2 t. - intros l1 l2 l3 t1 t2 Hp Hr1 Hp2 Hr2; simpl. rewrite app_ass, Hr1; simpl. now rewrite Hr2. - reflexivity. - reflexivity. Qed. Theorem parse_rel_sound : forall l:list par, (exists t : bin, parse_rel l nil t) -> wp l. Proof. intros l [t H]; replace l with (bin_to_string t). - apply bin_to_string_wp. - symmetry; replace (bin_to_string t) with (bin_to_string t ++ nil). + apply parse_rel_sound_aux; auto. + rewrite app_nil_end; auto. Qed. Inductive wp' : list par -> Prop := | wp'_nil : wp' nil | wp'_cons : forall l1 l2:list par, wp' l1 -> wp' l2 -> wp' (open :: l1 ++ close :: l2). Theorem wp'_concat : forall l1 l2:list par, wp' l1 -> wp' l2 -> wp' (l1 ++ l2). Proof. intros l1 l2 H; generalize l2; clear l2. elim H. - simpl; auto. - intros l1' l2' Hb1' Hr1 Hb2' Hr2 l2 Hb2; simpl; rewrite app_ass. simpl; apply wp'_cons; auto. Qed.#[export] Hint Resolve wp'_nil wp'_cons wp'_concat : core. Theorem wp'_encapsulate : forall l:list par, wp' l -> wp' (open :: l ++ close :: nil). Proof. intros l H; elim H; auto. Qed. Theorem wp_imp_wp' : forall l:list par, wp l -> wp' l. Proof. intros l H; elim H. - apply wp'_nil. - intros; apply wp'_concat; trivial. - intros; apply wp'_encapsulate; trivial. Qed. Theorem wp'_imp_wp : forall l:list par, wp' l -> wp l. Proof. intros l H; elim H; auto. Qed. Inductive wp'' : list par -> Prop := | wp''_nil : wp'' nil | wp''_cons : forall l1 l2:list par, wp'' l1 -> wp'' l2 -> wp'' (l1 ++ open :: l2 ++ close :: nil).#[export] Hint Resolve wp''_nil wp''_cons : core. Lemma wp''_concat : forall l1 l2:list par, wp'' l1 -> wp'' l2 -> wp'' (l1 ++ l2). Proof. intros l1 l2 H1 H2; generalize l1 H1; clear H1 l1; elim H2. - intros; rewrite <- app_nil_end; trivial. - intros; rewrite ass_app; auto. Qed. Theorem wp''_encapsulate : forall l:list par, wp'' l -> wp'' (open :: l ++ close :: nil). 
x at 1 ; rewrite Fx. rewrite ulp_neq_0. unfold F2R. simpl. pattern (bpow (canonic_exp beta fexp x)) at 2 ; rewrite <- Rmult_1_l. rewrite <- Rmult_plus_distr_r. change 1%R with (Z2R 1). rewrite <- Z2R_plus. change (F2R (Float beta (Ztrunc (scaled_mantissa beta fexp x) + 1) (canonic_exp beta fexp x)) <= bpow ex)%R. apply F2R_p1_le_bpow. apply F2R_gt_0_reg with beta (canonic_exp beta fexp x). now rewrite <- Fx. now rewrite <- Fx. now apply Rgt_not_eq. now apply Rlt_le. apply Rplus_le_le_0_compat. now apply Rlt_le. apply Heps. Qed.Theorem round_DN_plus_eps_pos: forall x, (0 <= x)%R -> F x -> forall eps, (0 <= eps < ulp x)%R -> round beta fexp Zfloor (x + eps) = x. Proof. intros x Zx Fx eps Heps. destruct Zx as [Zx|Zx].pattern x at 2 ; rewrite Fx. unfold round. unfold scaled_mantissa. simpl. unfold canonic_exp at 1 2. rewrite ln_beta_plus_eps ; trivial. apply (f_equal (fun m => F2R (Float beta m _))). rewrite Ztrunc_floor. apply Zfloor_imp. split. apply (Rle_trans _ _ _ (Zfloor_lb _)). apply Rmult_le_compat_r. apply bpow_ge_0. pattern x at 1 ; rewrite <- Rplus_0_r. now apply Rplus_le_compat_l. apply Rlt_le_trans with ((x + ulp x) * bpow (- canonic_exp beta fexp x))%R. apply Rmult_lt_compat_r. apply bpow_gt_0. now apply Rplus_lt_compat_l. rewrite Rmult_plus_distr_r. rewrite Z2R_plus. apply Rplus_le_compat. pattern x at 1 3 ; rewrite Fx. unfold F2R. simpl. rewrite Rmult_assoc. rewrite <- bpow_plus. rewrite Zplus_opp_r. rewrite Rmult_1_r. rewrite Zfloor_Z2R. apply Rle_refl. rewrite ulp_neq_0. 2: now apply Rgt_not_eq. rewrite <- bpow_plus. rewrite Zplus_opp_r. apply Rle_refl. apply Rmult_le_pos. now apply Rlt_le. apply bpow_ge_0.rewrite <- Zx, Rplus_0_l; rewrite <- Zx in Heps. case (proj1 Heps); intros P. unfold round, scaled_mantissa, canonic_exp. revert Heps; unfold ulp. rewrite Req_bool_true; trivial. case negligible_exp_spec. intros _ (H1,H2). absurd (0 < 0)%R; auto with real. now apply Rle_lt_trans with (1:=H1). intros n Hn H. assert (fexp (ln_beta beta eps) = fexp n). apply valid_exp; try assumption. assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega]. apply lt_bpow with beta. apply Rle_lt_trans with (2:=proj2 H). destruct (ln_beta beta eps) as (e,He). simpl; rewrite Rabs_pos_eq in He. now apply He, Rgt_not_eq. now left. replace (Zfloor (eps * bpow (- fexp (ln_beta beta eps)))) with 0%Z. unfold F2R; simpl; ring. apply sym_eq, Zfloor_imp. split. apply Rmult_le_pos. now left. apply bpow_ge_0. apply Rmult_lt_reg_r with (bpow (fexp n)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus. rewrite H0; ring_simplify (-fexp n + fexp n)%Z. simpl; rewrite Rmult_1_l, Rmult_1_r. apply H. rewrite <- P, round_0; trivial. apply valid_rnd_DN. Qed. Theorem round_UP_plus_eps_pos : forall x, (0 <= x)%R -> F x -> forall eps, (0 < eps <= ulp x)%R -> round beta fexp Zceil (x + eps) = (x + ulp x)%R. 
Q R S : Prop, (P ‚à® Q ‚à® R)‚Üí((P ‚à® ¬¨R ‚à® S)‚Üí(P ‚à® Q ‚à® S)). Proof. intros P Q R S. specialize n2_8 with Q R S. intros n2_8a. specialize n2_81 with P (Q‚à®R) (¬¨R‚à®S) (Q‚à®S). intros n2_81a. MP n2_81a n2_8a. exact n2_81a. Qed.Theorem n2_83 : ‚àÄ P Q R S : Prop, (P‚Üí(Q‚ÜíR))‚Üí((P‚Üí(R‚ÜíS))‚Üí(P‚Üí(Q‚ÜíS))). Proof. intros P Q R S. specialize n2_82 with (¬¨P) (¬¨Q) R S. intros n2_82a. replace (¬¨Q‚à®R) with (Q‚ÜíR) in n2_82a by now rewrite Impl1_01. replace (¬¨P‚à®(Q‚ÜíR)) with (P‚ÜíQ‚ÜíR) in n2_82a by now rewrite Impl1_01. replace (¬¨R‚à®S) with (R‚ÜíS) in n2_82a by now rewrite Impl1_01. replace (¬¨P‚à®(R‚ÜíS)) with (P‚ÜíR‚ÜíS) in n2_82a by now rewrite Impl1_01. replace (¬¨Q‚à®S) with (Q‚ÜíS) in n2_82a by now rewrite Impl1_01. replace (¬¨Q‚à®S) with (Q‚ÜíS) in n2_82a by now rewrite Impl1_01. replace (¬¨P‚à®(Q‚ÜíS)) with (P‚ÜíQ‚ÜíS) in n2_82a by now rewrite Impl1_01. exact n2_82a. Qed.Theorem n2_85 : ‚àÄ P Q R : Prop, ((P ‚à® Q) ‚Üí (P ‚à® R)) ‚Üí (P ‚à® (Q ‚Üí R)). Proof. intros P Q R. specialize Add1_3 with P Q. intros Add1_3a. specialize Syll2_06 with Q (P‚à®Q) R. intros Syll2_06a. MP Syll2_06a Add1_3a. specialize n2_55 with P R. intros n2_55a. specialize Syll2_05 with (P‚à®Q) (P‚à®R) R. intros Syll2_05a. Syll n2_55a Syll2_05a Ha. specialize n2_83 with (¬¨P) ((P‚à®Q)‚Üí(P‚à®R)) ((P‚à®Q)‚ÜíR) (Q‚ÜíR). intros n2_83a. MP n2_83a Ha. specialize Comm2_04 with (¬¨P) (P‚à®Q‚ÜíP‚à®R) (Q‚ÜíR). intros Comm2_04a. Syll Ha Comm2_04a Hb. specialize n2_54 with P (Q‚ÜíR). intros n2_54a. specialize Simp2_02 with (¬¨P) ((P‚à®Q‚ÜíR)‚Üí(Q‚ÜíR)). intros Simp2_02a. MP Syll2_06a Simp2_02a. MP Hb Simp2_02a. Syll Hb n2_54a Hc. exact Hc. Qed.Theorem n2_86 : ‚àÄ P Q R : Prop, ((P ‚Üí Q) ‚Üí (P ‚Üí R)) ‚Üí (P ‚Üí (Q ‚Üí R)). Proof. intros P Q R. specialize n2_85 with (¬¨P) Q R. intros n2_85a. replace (¬¨P‚à®Q) with (P‚ÜíQ) in n2_85a by now rewrite Impl1_01. replace (¬¨P‚à®R) with (P‚ÜíR) in n2_85a by now rewrite Impl1_01. replace (¬¨P‚à®(Q‚ÜíR)) with (P‚ÜíQ‚ÜíR) in n2_85a by now rewrite Impl1_01. exact n2_85a. Qed.End No2.Module No3.Import No1. Import No2. Theorem Prod3_01 : ‚àÄ P Q : Prop, (P ‚àß Q) = (¬¨(¬¨P ‚à® ¬¨Q)). Proof. intros P Q. apply propositional_extensionality. split. specialize or_not_and with (P) (Q). intros or_not_and. specialize Transp2_03 with (¬¨P ‚à® ¬¨Q) (P ‚àß Q). intros Transp2_03. MP Transp2_03 or_not_and. exact Transp2_03. specialize not_and_or with (P) (Q). intros not_and_or. specialize Transp2_15 with (P ‚àß Q) (¬¨P ‚à® ¬¨Q). intros Transp2_15. MP Transp2_15 not_and_or. exact Transp2_15. Qed. Theorem Conj3_03 : ‚àÄ P Q : Prop, P ‚Üí Q ‚Üí (P‚àßQ). 
Proof. intros . set ( f := fun a : weq Y Z => weqcomp w a ) . set ( g := fun b : weq X Z => weqcomp ( invweq w ) b ) . split with f . assert ( egf : forall a : _ , paths ( g ( f a ) ) a ) . intro a . apply ( invmaponpathsincl _ ( isinclpr1weq _ _ ) ) . apply funextfun . intro y . apply ( maponpaths a ( homotweqinvweq w y ) ) . assert ( efg : forall b : _ , paths ( f ( g b ) ) b ) . intro b . apply ( invmaponpathsincl _ ( isinclpr1weq _ _ ) ) . apply funextfun . intro x . apply ( maponpaths b ( homotinvweqweq w x ) ) . apply ( gradth _ _ egf efg ) . Defined . Theorem weqinvweq ( X Y : UU ) : weq ( weq X Y ) ( weq Y X ) . Proof . intros . set ( f := fun w : weq X Y => invweq w ) . set ( g := fun w : weq Y X => invweq w ) . split with f . assert ( egf : forall w : _ , paths ( g ( f w ) ) w ) . intro . apply ( invmaponpathsincl _ ( isinclpr1weq _ _ ) ) . apply funextfun . intro x . unfold f. unfold g . unfold invweq . simpl . unfold invmap . simpl . apply idpath . assert ( efg : forall w : _ , paths ( f ( g w ) ) w ) . intro . apply ( invmaponpathsincl _ ( isinclpr1weq _ _ ) ) . apply funextfun . intro x . unfold f. unfold g . unfold invweq . simpl . unfold invmap . simpl . apply idpath . apply ( gradth _ _ egf efg ) . Defined . Theorem isofhlevelsnweqtohlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq X Y ) . Proof . intros . apply ( isofhlevelsninclb n _ ( isinclpr1weq _ _ ) ) . apply impred . intro . apply is . Defined . Theorem isofhlevelsnweqfromhlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq Y X ) . 
From Coq Require Import List String Ascii ZArith. Import ListNotations. Open Scope string_scope. Open Scope Z_scope.From Vellvm Require Import LLVMAst LLVMEvents UndefTests TopLevel Refinement TopLevelRefinements CFG DynamicTypes PropT Transformations.Traversal.From Vellvm.Handlers Require Import Stack Local Global.From ITree Require Import ITree Basics Eq.Eq Events.State.From ExtLib Require Import Structures.Monads Structures.Maps Core.RelDec Programming.Eqv.Import EqvNotation. Import ITree.Basics.Basics.Monads.Import MonadNotation. Import ListNotations. Import Monads.Require Import Morphisms. Require Import Relations.Import R. Import TopLevelEnv. Import IO. Import D. Theorem undef_refines_mul_undef_undef: refine_uvalue (UVALUE_Undef (DTYPE_I 64)) (UVALUE_IBinop (Mul false false) (UVALUE_Undef (DTYPE_I 64)) (UVALUE_Undef (DTYPE_I 64))). 
[ x1 | y ]. - assert (ne : x != x1) by apply (negf (maponpaths (@ii1 _ _)) x0). apply (ii1 (make_compl _ _ x1 ne)). - apply (ii2 y). Defined. Theorem isweqtocompltoii1x (X Y : UU) (x : X) : isweq (tocompltoii1x X Y x). Proof. intros. set (f := tocompltoii1x X Y x). set (g := fromcompltoii1x X Y x). assert (egf : ‚àè nexy : _, paths (g (f nexy)) nexy). { intro. induction nexy as [ c | y ]. - induction c as [ t x0 ]. simpl. assert (e : paths (negf (maponpaths (@ii1 X Y)) (negf (invmaponpathsincl (@ii1 X Y) (isinclii1 X Y) x t) x0)) x0) by apply (isapropneg (x = t)). apply (maponpaths (fun ee : x != t => ii1 (make_compl X x t ee)) e). - apply idpath. } assert (efg: ‚àè neii1x : _, paths (f (g neii1x)) neii1x). { intro. induction neii1x as [ t x0 ]. induction t as [ x1 | y ]. - simpl. assert (e : paths (negf (invmaponpathsincl (@ii1 X Y) (isinclii1 X Y) x x1) (negf (maponpaths (@ii1 X Y)) x0)) x0) by apply (isapropneg (paths _ _)). apply (maponpaths (fun ee : (neg (paths (ii1 x) (ii1 x1))) => (make_compl _ _ (ii1 x1) ee)) e). - simpl. assert (e : paths (negf pathsinv0 (negpathsii2ii1 x y)) x0) by apply (isapropneg (paths _ _)). apply (maponpaths (fun ee : (neg (paths (ii1 x) (ii2 y))) => (make_compl _ _ (ii2 y) ee)) e). } apply (isweq_iso f g egf efg). Defined. Definition tocompltoii2y (X Y : UU) (y : Y) : coprod X (compl Y y) -> compl (coprod X Y) (ii2 y). Proof. intros X0. induction X0 as [ x | c ]. - split with (ii1 x). apply (negpathsii2ii1 x y). - split with (ii2 (pr1 c)). assert (e : neg(y = (pr1 c))) by apply (pr2 c). apply (negf (invmaponpathsincl (@ii2 _ _) (isinclii2 X Y) _ _) e). Defined.Definition fromcompltoii2y (X Y : UU) (y : Y) : compl (coprod X Y) (ii2 y) -> coprod X (compl Y y). Proof. intros X0. induction X0 as [ t x ]. induction t as [ x0 | y0 ]. - apply (ii1 x0). - assert (ne : y != y0) by apply (negf (maponpaths (@ii2 _ _)) x). apply (ii2 (make_compl _ _ y0 ne)). Defined. Theorem isweqtocompltoii2y (X Y : UU) (y : Y) : isweq (tocompltoii2y X Y y). 
eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b. intros a b Q H'; elim H'; auto. intros x y H'0 H'1 H'2. apply CombLinear_comp with (p := x); auto. apply eqp_imp_canonical with (p := x) (1 := cs); auto. intros x y z H'0 H'1 H'2 H'3 H'4. apply H'2; auto. apply canonical_reduce with (1 := cs) (3 := H'0) (p := x); auto. apply reduce_cb with (a := x); auto. Qed. Theorem reducestar_cb : forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b. intros a b Q H'; elim H'; auto. intros p q H'0 H'1 H'2 H'3. apply reduceplus_cb with (a := p); auto. Qed.Theorem reduce_cb1 : forall (a : poly A0 eqA ltM) (b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (s2p A A0 eqA n ltM a) b -> CombLinear (a :: Q) b. intros a; case a; simpl in |- *. intros x c b Q H'. cut (canonical A0 eqA ltM b); [ intros Op1 | apply canonical_reduce with (1 := cs) (3 := H') ]; auto. case reduce_inv2 with (1 := cs) (3 := H'); auto; (intros c1 E; elim E; intros d E0; elim E0; intros H'7 H'8; elim H'8; intros H'9 H'10; elim H'10; intros H'11 H'12; clear H'10 H'8 E0 E). apply CombLinear_comp with (p := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec x (mults (A:=A) multA (n:=n) d c1)); auto. apply CombLinear_minuspf; auto. apply CombLinear_id; auto. generalize c H'; case x; auto. intros c2 H'0; inversion H'0; auto. intros t l c0 H'0; change (inPolySet A A0 eqA n ltM (pX t l) (exist (canonical A0 eqA ltM) (pX t l) c0 :: Q)) in |- *; auto. apply incons with (a := t) (p := l) (P := Q); auto. apply CombLinear_mults1; auto. apply CombLinear_id; auto. apply inskip; auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem CombLinear_compo : forall (p : list (Term A n)) (L1 : list (poly A0 eqA ltM)), CombLinear L1 p -> forall L2 : list (poly A0 eqA ltM), (forall q : list (Term A n), inPolySet A A0 eqA n ltM q L1 -> CombLinear L2 q) -> CombLinear L2 p. 
N (P ‚àó Q). Proof. rewrite ncinv_eq. iIntros "#HPdup #HncinvP #HncinvQ !>" (E ? q) "HNC". iMod ("HncinvP" with "[//] HNC") as "[HP [HNC HcloseP]]". iDestruct ("HPdup" with "HP") as "[$ HP]". iMod ("HcloseP" with "HP HNC") as "HNC". iMod ("HncinvQ" with "[//] HNC") as "[$ [$ HcloseQ]]". iIntros "!> [HP HQ]" (q') "HNC". iMod ("HcloseQ" with "HQ HNC") as "$". auto. Qed. Global Instance into_ncinv_ncinv N P : IntoInv (ncinv N P) N := {}. Global Instance into_acc_ncinv N P E: IntoAcc (X := unit) (ncinv N P) (‚ÜëN ‚äÜ E) True (ncfupd E (E ‚àñ ‚ÜëN)) (ncfupd (E ‚àñ ‚ÜëN) E) (Œª _ : (), (‚ñ∑ P)%I) (Œª _ : (), (‚ñ∑ P)%I) (Œª _ : (), None). Proof. rewrite /IntoAcc /accessor bi.exist_unit. iIntros (?) "#Hinv _". iMod (ncinv_acc with "Hinv") as "($&Hcl)"; first auto. iModIntro. auto. Qed. Lemma ncinv_acc_strong E N P : ‚ÜëN ‚äÜ E ‚Üí ncinv N P -‚àó |NC={E,E‚àñ‚ÜëN}=> ‚ñ∑ P ‚àó ‚àÄ E', ‚ñ∑ P -‚àó |NC={E',‚ÜëN ‚à™ E'}=> True. Proof. iIntros (?) "Hncinv". iPoseProof (ncinv_acc (‚Üë N) N with "Hncinv") as "H"; first done. rewrite difference_diag_L. iPoseProof (ncfupd_mask_frame_r _ _ (E ‚àñ ‚Üë N) with "H") as "H"; first set_solver. rewrite left_id_L -union_difference_L //. iMod "H" as "[$ H]"; iModIntro. iIntros (E') "HP". iPoseProof (ncfupd_mask_frame_r _ _ E' with "(H HP)") as "H"; first set_solver. by rewrite left_id_L. Qed. Lemma ncinv_acc_timeless E N P `{!Timeless P} : ‚ÜëN ‚äÜ E ‚Üí ncinv N P -‚àó |NC={E,E‚àñ‚ÜëN}=> P ‚àó (P -‚àó |NC={E‚àñ‚ÜëN,E}=> True). Proof. iIntros (?) "Hncinv". iMod (ncinv_acc with "Hncinv") as "[>HP Hclose]"; auto. iIntros "!> {$HP} HP". iApply "Hclose"; auto. Qed. Lemma ncinv_split_l N P Q : ncinv N (P ‚àó Q) -‚àó ncinv N P. Proof. iIntros "#HI". iApply ncinv_alter; eauto. iIntros "!> !> [$ $] $". Qed. Lemma ncinv_split_r N P Q : ncinv N (P ‚àó Q) -‚àó ncinv N Q. Proof. rewrite (comm _ P Q). eapply ncinv_split_l. Qed. Lemma ncinv_split N P Q : ncinv N (P ‚àó Q) -‚àó ncinv N P ‚àó ncinv N Q. Proof. iIntros "#H". iPoseProof (ncinv_split_l with "H") as "$". iPoseProof (ncinv_split_r with "H") as "$". Qed. Lemma inv_to_ncinv N P : inv N P -‚àó ncinv N P. Proof. iIntros "#H". rewrite ncinv_eq /ncinv_def. iIntros "!>" (E Hsub). iInv "H" as "HP" "Hclo". iIntros (?) "HNC". iModIntro. iFrame. iIntros "HP" (?) "HNC". iFrame. by iMod ("Hclo" with "[$]"). Qed. Theorem ncinv_dup_acc (Q: iProp Œ£) N E (P: iProp Œ£) : ‚ÜëN ‚äÜ E ‚Üí ncinv N P -‚àó (P -‚àó P ‚àó Q) -‚àó |NC={E}=> ‚ñ∑ Q. 
true /\ v = h' /\ currentTerm (handleRequestVoteReply h st h' t r) = t). Proof using. intros. unfold handleRequestVoteReply, advanceCurrentTerm in *. repeat break_match; subst; simpl in *; do_bool; intuition. Qed. Theorem handleTimeout_log_term_type : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> (log st' = log st /\ currentTerm st' = currentTerm st /\ type st' = type st) \/ currentTerm st' = S (currentTerm st). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma handleClientRequest_candidate : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = Candidate -> st' = st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_candidate : forall st h os st' ms, doLeader st h = (os, st', ms) -> type st' = Candidate -> st' = st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_term_votedFor : forall st h os st' ms, doLeader st h = (os, st', ms) -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma doGenericServer_log_type_term_votesReceived : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> log st' = log st /\ type st' = type st /\ currentTerm st' = currentTerm st /\ votesReceived st' = votesReceived st /\ votedFor st' = votedFor st. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleClientRequest_term_votedFor : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = type st /\ currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Theorem handleAppendEntries_term_votedFor : forall h st t n pli plt es ci st' ps h', handleAppendEntries h st t n pli plt es ci = (st', ps) -> votedFor st' = Some h' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto; congruence. Qed. Theorem handleAppendEntriesReply_term_votedFor : forall h st n t es r st' ps h', handleAppendEntriesReply h st n t es r = (st', ps) -> votedFor st' = Some h' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. 
tr, reachable step_dup step_async_init st -> step_dup st st' tr -> step_async (revertNetwork st) (revertNetwork st') tr \/ (revertNetwork st = revertNetwork st' /\ filterMap trace_non_empty_out tr = []). Proof using. intros. find_copy_apply_lem_hyp reachable_sane. find_copy_apply_lem_hyp reachable_seen. find_copy_apply_lem_hyp reachable_equality. break_exists. match goal with H : step_dup _ _ _ |- _ => invcs H end. - unfold seq_num_net_handlers in *. match goal with | [H : context [ if _ then _ else _ ] |- _] => revert H end. break_if; intros. + right. find_inversion. simpl in *. unfold revertNetwork. simpl in *. intuition. f_equal. * f_equal. find_rewrite. symmetry. match goal with | |- filter ?f _ = filter ?g _ => assert (f = g) by (apply functional_extensionality; intros; repeat break_if; repeat find_rewrite; intuition) end. find_rewrite. apply filter_dedup. break_if; intuition. * apply functional_extensionality. intros. break_if; subst; intuition. + left. repeat break_let. find_inversion. match goal with | [ H : processPackets _ _ = _, H' : net_handlers _ _ _ _ = (_, d0, _) |- _ ] => eapply revertNetwork_deliver_step with (d := d0) in H; eauto end. break_exists. break_and. match goal with | [H : nwPackets _ = _ |- _ ] => eapply (StepAsync_deliver _ _ _ _ H); eauto end. - left. unfold seq_num_input_handlers in *. repeat break_let. find_inversion. find_eapply_lem_hyp revertNetwork_input; eauto. econstructor 2; simpl; eauto. - right. split; auto. unfold revertNetwork. f_equal. f_equal. f_equal. simpl. find_rewrite. eauto using dedup_eliminates_duplicates. Qed. Lemma step_dup_star_revert_simulation : forall net tr, step_dup_star step_async_init net tr -> exists tr', step_async_star step_async_init (revertNetwork net) tr' /\ filterMap trace_non_empty_out tr = filterMap trace_non_empty_out tr'. Proof using. intros. remember step_async_init as y in *. revert Heqy. induction H using refl_trans_1n_trace_n1_ind; simpl; intros. - find_rewrite. exists []; simpl. split; auto. apply RT1nTBase. - concludes. subst. break_exists_name tr'. break_and. assert (H_r: reachable step_dup step_async_init x') by (exists tr1; auto). eapply reachable_revert_step in H_r; eauto. break_or_hyp. * exists (tr' ++ tr2); split. + eapply refl_trans_1n_trace_trans; eauto. rewrite (app_nil_end tr2). eapply RT1nTStep; eauto. apply RT1nTBase. + rewrite filterMap_app. rewrite filterMap_app. find_reverse_rewrite. reflexivity. * break_and. find_rewrite. exists tr'; split; simpl; auto. match goal with | [H : filterMap _ _ = filterMap _ _ |- _ ] => rewrite <- H end. rewrite filterMap_app. destruct tr2; simpl in *; [ rewrite <- app_nil_end | idtac ]; auto. match goal with | [H : _ = [] |- _ ] => rewrite H end. rewrite <- app_nil_end; auto. Qed. Theorem reachable_revert : true_in_reachable step_dup step_async_init (fun st => reachable step_async step_async_init (revertNetwork st)). 
Require Import List Arith Omega.Require Import ILL.Definitions.Require Import utils pos vec. Require Import subcode sss. Require Import list_bool bsm_defs mm_defs mm_utils mm_comp.Local Notation "P '/BSM/' s ‚Üì" := (sss_terminates (@bsm_sss _) P s) (at level 70, no associativity). Local Notation "P '/MM/' s ~~> t" := (sss_output (@mm_sss _) P s t) (at level 70, no associativity).Section BSM_MM_HALTS_ON_ZERO. Let f : BSM_PROBLEM -> MM_PROBLEM. Proof. intros (n & i & P & v). destruct (bsm_mm_compiler_2 i P) as (Q & _). exists (2+n), Q. exact (0##0##vec_map stack_enc v). Defined. Theorem BSM_MM_HALTS_ON_ZERO : BSM_HALTING ‚™Ø MM_HALTS_ON_ZERO. Proof. exists f. intros (n & i & P & v); simpl. destruct (bsm_mm_compiler_2 i P) as (Q & H); simpl; auto. Qed.End BSM_MM_HALTS_ON_ZERO.Section BSM_MM_HALTING. Let f : BSM_PROBLEM -> MM_PROBLEM. Proof. intros (n & i & P & v). destruct (bsm_mm_compiler_1 i P) as (Q & _). exists (2+n), Q. exact (0##0##vec_map stack_enc v). Defined. Theorem BSM_MM_HALTING : BSM_HALTING ‚™Ø MM_HALTING. 
(genv_symb := genv_symb) (Hrel := NoExternal_Hrel) (JuicyMachine.MachineSemantics sch r) NoExternal_Espec (globalenv prog) n tt (sch, nil, initial_machine_state n) (proj1_sig init_mem). Proof. intros sch r n thisfunction. pose proof initial_invariant CS V G ext_link prog as INIT. specialize (INIT all_safe init_mem_not_none n sch). match type of INIT with _ _ ?a n ?b => assert (init : inv a n b) by (hnf; eauto) end. pose proof inv_step as SIM. clear INIT; revert init. unfold initial_state, initial_machine_state. unfold initial_corestate, initial_jm, spr, init_mem. match goal with |- context[(sch, nil, ?tp)] => set (t0:= tp) end. match goal with |- context[(sch, ?tp)] => change tp with t0 end. clearbody t0. revert t0. match goal with |- context[(proj1_sig ?m)] => generalize (proj1_sig m) end. generalize sch at 2. generalize (globalenv prog), sch. clear -SIM. induction n; intros g sch schSEM m t INV; [ now constructor | ]. destruct (SIM _ _ _ INV) as [cm' [step INV']]. inversion step as [ | ? ? m' ? sch' ? tp' STEP ]; subst; clear step. - eapply safeN_halted. + reflexivity. + apply I. - eapply safeN_step with (c' := (sch', nil, tp')) (m'0 := m'). + eapply STEP. + apply IHn. apply INV'. Qed.*) Theorem jmsafe_initial_state sch n : jmsafe (globalenv prog) n ((proj1_sig init_mem), (nil, sch, initial_machine_state n)). Proof. eapply invariant_safe. exists n; split; auto. apply initial_invariant. Qed. Lemma initial_corestate_initial : exists b, Genv.find_symbol (globalenv prog) (prog_main prog) = Some b /\ exists m', forall n, initial_core (Clight_new.cl_core_sem (globalenv prog)) n (proj1_sig init_mem) initial_corestate m' (Vptr b Ptrofs.zero) nil. Proof. unfold initial_corestate. destruct spr as (b & ? & [? Hinit] & s). destruct (s O tt) as (jm & ? & _). exists b; split; auto; simpl in *; clear s. specialize (Hinit _ H) as (? & Hinit); hnf in Hinit. destruct Hinit as [_ Hinit]; simpl in Hinit. destruct Hinit as (? & ? & [? ?]); eexists. split3; auto. constructor. split. reflexivity. rewrite <- H. auto. Qed. Lemma jmsafe_csafe n m tr sch s : jmsafe (globalenv prog) n (m, (tr, sch, s)) -> jm_csafe (sch, tr, s) m n. Proof. clear. revert m tr sch s; induction n; intros m tr sch s SAFE. now constructor 1. inversion SAFE; subst. - constructor 2. reflexivity. - econstructor 3; [apply H2|]. eapply tp_bupd_mono; eauto; auto. - econstructor 4; [apply H2|]. intro U''; eapply tp_bupd_mono; eauto; intros. apply IHn, H0. Qed. Theorem safety_initial_state (sch : schedule) (n : nat) : jm_csafe (sch, nil, initial_machine_state n) (proj1_sig init_mem) n. 
-> bvs = firstn nParam vs -> mkCallVars threadInfIdent nParam fenv map n bvs = Some es -> repr_call_vars threadInfIdent nParam fenv map p n bvs es. Proof. Admitted. Admitted. *) Theorem repr_make_case_switch: forall x ls ls', repr_switch_L6_L7 isptrIdent caseIdent x ls ls' (make_case_switch isptrIdent caseIdent x ls ls'). Proof. intros. unfold make_case_switch. constructor. Qed. Definition makeCases argsIdent allocIdent limitIdent threadInfIdent tinfIdent isptrIdent caseIdent (p:program) fenv cenv ienv map := (fix makeCases (l : list (ctor_tag * exp)) : option (labeled_statements * labeled_statements) := match l with | [] => Monad.ret (LSnil, LSnil) | p :: l' => Monad.pbind (translate_body argsIdent allocIdent limitIdent threadInfIdent tinfIdent isptrIdent caseIdent nParam (snd p) fenv cenv ienv map) (fun prog : statement => Monad.pbind (makeCases l') (fun '(ls, ls') => match make_ctor_rep cenv (fst p) with | Some (enum t) => let tag := ((Z.shiftl (Z.of_N t) 1) + 1)%Z in match ls' with | LSnil => Monad.ret (ls, LScons None (Ssequence prog Sbreak) ls') | LScons _ _ _ => Monad.ret (ls, LScons (Some (Z.shiftr tag 1)) (Ssequence prog Sbreak) ls') end | Some (boxed t a) => let tag := ((Z.shiftl (Z.of_N a) 10) + (Z.of_N t))%Z in match ls with | LSnil => Monad.ret (LScons None (Ssequence prog Sbreak) ls, ls') | LScons _ _ _ => Monad.ret (LScons (Some (Z.land tag 255)) (Ssequence prog Sbreak) ls, ls') end | None => None end)) end).Definition fmake_ctor_rep (p:positive) (c:ctor_ty_info) : ctor_rep := let '(Build_ctor_ty_info name _ it a n) := c in match (a =? 0)%N with | true => (enum n) | false => (boxed n a) end. Definition compute_rep_env (cenv:ctor_env): M.t ctor_rep := M.map fmake_ctor_rep cenv. Theorem crep_cenv_correct: forall cenv rep_env, correct_crep_of_env cenv rep_env -> forall c, make_ctor_rep cenv c = M.get c rep_env. Proof. intros. unfold make_ctor_rep. destruct (cps.M.get c cenv) eqn:Hgc. - destruct c0. simpl. destruct (ctor_arity =? 0)%N eqn:Hn0. + rewrite N.eqb_eq in Hn0. subst. inv H. specialize (H0 _ _ _ _ _ _ Hgc). destruct H0. destruct H. inv H0; rewrite H2 in Hgc; inv Hgc. auto. + rewrite N.eqb_neq in Hn0. inv H. specialize (H0 _ _ _ _ _ _ Hgc). destruct H0. destruct H. inv H0; rewrite H2 in Hgc; inv Hgc. exfalso; apply Hn0; auto. auto. - simpl. symmetry. inv H. destruct (M.get c rep_env) eqn:Hcr. exfalso. apply H1 in Hcr. inv Hcr; rewrite H in Hgc; inv Hgc. auto. Qed. Theorem nth_proj_assign': forall p fenv finfo_env, find_symbol_domain p finfo_env -> forall v l a n, Forall_statements_in_seq' (is_nth_projection_of_x threadInfIdent nParam fenv finfo_env p v) (a :: l) (assignConstructorS' threadInfIdent nParam fenv finfo_env v n (a :: l)) (Z.of_nat n). 
= x <-> x = Zp \/ x = Op \/ x = ‚à∏ Op. Proof. split. + intros H. destruct (Zp_eq_dec x Zp) as [ Hx | Hx ]; auto. apply Zp_invert_spec2 in Hx. rewrite H in Hx. apply Zp_prime_square_one in Hx; auto. + intros [ | [|]]; subst. * apply Zp_invert_spec1. * apply Zp_invert_eq_not_zero; try ring. intros H; symmetry in H; revert H; rewrite Zp_zero_is_one; lia. * apply Zp_invert_eq_not_zero; try ring. intros H. rewrite <- Zp_opp_zero in H. symmetry in H; apply Zp_opp_inj in H. revert H; rewrite Zp_zero_is_one; lia. Qed. Fact Zp_invert_involutive x : inv (inv x) = x. Proof. destruct (Zp_eq_dec x Zp) as [ Hx | Hx ]; subst. + do 2 rewrite Zp_invert_spec1; auto. + apply Zp_invert_eq_not_zero. * intros H. apply Zp_invert_spec2 in Hx. rewrite H, Zp_mult_zero in Hx. apply Zp_zero_is_one in Hx; lia. * rewrite Zp_mult_comm; apply Zp_invert_spec2; auto. Qed. Fact Zp_invert_not_fix n : (1 < n < p-1)%nat -> inv„Äön„Äõ<>„Äön„Äõ. Proof. intros H1 H2. apply Zp_invert_fix in H2. destruct H2 as [ H2 | [ H2 | H2 ] ]. + rewrite <- nat2Zp_zero in H2. apply nat2Zp_inj in H2. rewrite rem_lt, rem_lt in H2; lia. + rewrite <- nat2Zp_one in H2. apply nat2Zp_inj in H2. rewrite rem_lt, rem_lt in H2; lia. + rewrite <- nat2Zp_minus_one in H2. apply nat2Zp_inj in H2. rewrite rem_lt, rem_lt in H2; lia. Qed. Fact Zp_invert_stable n : (1 < n < p-1)%nat -> exists m, (1 < m < p-1)%nat /\„Äöm„Äõ= inv„Äön„Äõ. Proof. intros Hn. destruct (nat2Zp_choose (inv „Äön„Äõ)) as [ H | [ H | [ H | H ] ] ]; auto; exfalso; apply f_equal with (f := inv) in H; rewrite Zp_invert_involutive in H; symmetry in H. + rewrite Zp_invert_spec1 in H. rewrite <- nat2Zp_zero, nat2Zp_inj in H. rewrite rem_lt, rem_lt in H; lia. + rewrite Zp_invert_one, <- nat2Zp_one in H. rewrite nat2Zp_inj, rem_lt, rem_lt in H; lia. + rewrite Zp_invert_minus_one, <- nat2Zp_minus_one in H. rewrite nat2Zp_inj, rem_lt, rem_lt in H; lia. Qed. Definition Zp_lprod := fold_right Zp_mult Zp_one. Fact Zp_lprod_nil : Zp_lprod nil = Op. Proof. trivial. Qed. Fact Zp_lprod_cons x l : Zp_lprod (x::l) = x ‚äó Zp_lprod l. Proof. trivial. Qed. Fact Zp_lprod_app l m : Zp_lprod (l++m) = Zp_lprod l ‚äó Zp_lprod m. Proof. induction l as [ | x l IHl ]. + rewrite Zp_lprod_nil, Zp_mult_one; auto. + simpl app; do 2 rewrite Zp_lprod_cons. rewrite IHl; ring. Qed. Theorem Zp_mult_autoinv l : ~ list_has_dup l -> (forall x, In x l -> x <> Zp /\ inv x <> x /\ In (inv x) l) -> Zp_lprod l = Op. 
Require Import List Arith Omega.Require Import utils_tac utils_list sums rel_iter pos vec. Require Import fractran_defs prime_seq. Require Import dio_logic dio_bounded dio_rt_closure dio_single.Set Implicit Arguments.Section fractran_dio. Notation "l /F/ x ‚Üí y" := (fractran_step l x y) (at level 70, no associativity). Lemma dio_rel_fractran_step l x y : ùîªP x -> ùîªP y -> ùîªR (fun ŒΩ => l /F/ x ŒΩ ‚Üí y ŒΩ). Proof. intros Hx Hy. induction l as [ | (p,q) l IHl ]. + apply dio_rel_equiv with (fun _ => False); auto. intros v; rewrite fractran_step_nil_inv; split; tauto. + apply dio_rel_equiv with (1 := fun v => fractran_step_cons_inv p q l (x v) (y v)); auto. Defined. Hint Resolve dio_rel_fractran_step. Theorem dio_rel_fractran_rt l x y : ùîªP x -> ùîªP y -> ùîªR (fun ŒΩ => fractran_compute l (x ŒΩ) (y ŒΩ)). Proof. intros; apply dio_rel_exst, dio_rel_rel_iter; auto. Defined. Theorem dio_rel_fractran_stop l x : ùîªP x -> ùîªR (fun ŒΩ => fractran_stop l (x ŒΩ)). Proof. intros Hx. induction l as [ | (p,q) l IHl ]. + apply dio_rel_equiv with (fun _ => True); auto. intro v; split; auto; intros _ ?. rewrite fractran_step_nil_inv; auto. + apply dio_rel_equiv with (1 := fun v => fractan_stop_cons_inv p q l (x v)); auto. Defined. Hint Resolve dio_rel_fractran_rt dio_rel_fractran_stop. Theorem FRACTRAN_HALTING_on_diophantine ll x : ùîªP x -> ùîªR (fun ŒΩ => FRACTRAN_HALTING (ll,x ŒΩ)). Proof. intros; apply dio_rel_exst, dio_rel_conj; auto. Defined. Theorem FRACTRAN_HALTING_diophantine_0 ll : ùîªR (fun ŒΩ => FRACTRAN_HALTING (ll,ŒΩ 0)). Proof. intros; apply FRACTRAN_HALTING_on_diophantine; auto. Defined. Theorem FRACTRAN_HALTING_diophantine l x : ùîªR (fun _ => FRACTRAN_HALTING (l,x)). 
Set Implicit Arguments.Require Import Bedrock.Platform.Cito.ProgramLogic2.Require Import Bedrock.Platform.AutoSep. Require Import Bedrock.Platform.Cito.Syntax. Require Import Bedrock.Platform.Cito.SyntaxExpr Bedrock.Memory Bedrock.IL Coq.Strings.String. Require Import Bedrock.Platform.Cito.Notations3.Local Open Scope expr.Infix ";;" := SeqEx : stmtex_scope.Delimit Scope stmtex_scope with stmtex.Arguments SkipEx {_}. Arguments SeqEx {_} _ _. Arguments IfEx {_} _ _ _. Arguments WhileEx {_} _ _ _. Arguments AssignEx {_} _ _. Arguments AssertEx {_} _. Arguments DCallEx {_} _ _ _.Notation "'skip'" := SkipEx : stmtex_scope.Notation "'BEFORE' ( vs , h ) 'AFTER' ( vs' , h' ) p" := (fun _ s s' => let vs := sel (fst s) in let h := snd s in let vs' := sel (fst s') in let h' := snd s' in p%word) (at level 0, p at level 200) : stmtex_inv_scope.Delimit Scope stmtex_inv_scope with stmtex_inv.Notation "[ inv ] 'While' cond { body }" := (WhileEx inv%stmtex_inv cond%expr body) : stmtex_scope.Notation "'If' cond { trueStmt } 'else' { falseStmt }" := (IfEx cond%expr trueStmt falseStmt) : stmtex_scope.Notation "x <- e" := (AssignEx x e%expr) : stmtex_scope.Notation "'Assert' [ p ]" := (AssertEx p%stmtex_inv) : stmtex_scope.Notation "'DCall' f ()" := (DCallEx None f nil) (no associativity, at level 95, f at level 0) : stmtex_scope.Notation "'DCall' f ( x1 , .. , xN )" := (DCallEx None f (@cons Expr x1 (.. (@cons Expr xN nil) ..))%expr) (no associativity, at level 95, f at level 0) : stmtex_scope.Notation "x <-- 'DCall' f ()" := (DCallEx (Some x) f nil) (no associativity, at level 95, f at level 0) : stmtex_scope.Notation "x <-- 'DCall' f ( x1 , .. , xN )" := (DCallEx (Some x) f (@cons Expr x1 (.. (@cons Expr xN nil) ..))%expr) (no associativity, at level 95, f at level 0) : stmtex_scope.Notation "a ! b" := (a, b) (only parsing) : stmtex_scope.Section ADTValue. Variable ADTValue : Type. Local Close Scope expr. Require Import Bedrock.Platform.Cito.SyntaxFunc Bedrock.Platform.Cito.GeneralTactics. Require Import Bedrock.Platform.Cito.FuncCore. Notation is_false := (@is_false ADTValue). Theorem lt0_false : forall (n : string) env v v', is_false (0 < n)%expr env v v' -> ($0 >= sel (fst v') n)%word. intros. hnf in H. simpl in H. unfold wltb in H. destruct (wlt_dec (natToW 0) (fst v' n)); try discriminate; auto. Qed. Notation is_true := (@is_true ADTValue). Theorem lt0_true : forall (n : string) env v v', is_true (0 < n)%expr env v v' -> ($0 < sel (fst v') n)%word. 
x = round Zceil x. Proof. intros x Hx. unfold round, Ztrunc. case Rlt_bool_spec. easy. intros [H|H]. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- cexp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. rewrite <- H. now rewrite Zfloor_IZR, Zceil_IZR. Qed.Theorem round_AW_UP : forall x, (0 <= x)%R -> round Zaway x = round Zceil x. Proof. intros x Hx. unfold round, Zaway. case Rlt_bool_spec. intros H. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- cexp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. easy. Qed.Theorem round_AW_DN : forall x, (x <= 0)%R -> round Zaway x = round Zfloor x. Proof. intros x Hx. unfold round, Zaway. case Rlt_bool_spec. easy. intros [H|H]. elim Rlt_not_le with (1 := H). rewrite <- (Rmult_0_l (bpow (- cexp x))). apply Rmult_le_compat_r with (2 := Hx). apply bpow_ge_0. rewrite <- H. now rewrite Zfloor_IZR, Zceil_IZR. Qed.Theorem generic_format_round : forall rnd { Hr : Valid_rnd rnd } x, generic_format (round rnd x). Proof with auto with typeclass_instances. intros rnd Zrnd x. destruct (total_order_T x 0) as [[Hx|Hx]|Hx]. rewrite <- (Ropp_involutive x). destruct (round_DN_or_UP rnd (- - x)) as [Hr|Hr] ; rewrite Hr. rewrite round_DN_opp. apply generic_format_opp. apply generic_format_round_pos... now apply Ropp_0_gt_lt_contravar. rewrite round_UP_opp. apply generic_format_opp. apply generic_format_round_pos... now apply Ropp_0_gt_lt_contravar. rewrite Hx. rewrite round_0... apply generic_format_0. now apply generic_format_round_pos. Qed.Theorem round_DN_pt : forall x, Rnd_DN_pt generic_format x (round Zfloor x). Proof with auto with typeclass_instances. intros x. split. apply generic_format_round... split. pattern x at 2 ; rewrite <- scaled_mantissa_mult_bpow. unfold round, F2R. simpl. apply Rmult_le_compat_r. apply bpow_ge_0. apply Zfloor_lb. intros g Hg Hgx. apply round_ge_generic... Qed.Theorem generic_format_satisfies_any : satisfies_any generic_format. Proof. split.exact generic_format_0. exact generic_format_opp.intros x. eexists. apply round_DN_pt. Qed.Theorem round_UP_pt : forall x, Rnd_UP_pt generic_format x (round Zceil x). Proof. intros x. rewrite <- (Ropp_involutive x). rewrite round_UP_opp. apply Rnd_UP_pt_opp. apply generic_format_opp. apply round_DN_pt. Qed.Theorem round_ZR_pt : forall x, Rnd_ZR_pt generic_format x (round Ztrunc x). Proof. intros x. split ; intros Hx. rewrite round_ZR_DN with (1 := Hx). apply round_DN_pt. rewrite round_ZR_UP with (1 := Hx). apply round_UP_pt. Qed.Lemma round_DN_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> round Zfloor x = 0%R. Proof. intros x ex Hx He. rewrite <- (F2R_0 beta (cexp x)). rewrite <- mantissa_DN_small_pos with (1 := Hx) (2 := He). now rewrite <- cexp_fexp_pos with (1 := Hx). Qed. Theorem round_DN_UP_lt : forall x, ~ generic_format x -> (round Zfloor x < x < round Zceil x)%R. 
A0 eqA ltM. intros H'; case H'. intros x; case x. intros H'0 H'1; exists (pO A n); auto. intros a l H'0 H'1; case H'1. intros x0; case x0. intros H'2; exists (pO A n); auto. intros a0 l0 H'2; exists (ppc (A:=A) A1 (n:=n) a a0 :: pO A n). change (canonical A0 eqA ltM (pX (ppc (A:=A) A1 (n:=n) a a0) (pO A n))) in |- *; apply canonicalp1; auto. apply ppc_nZ with (1 := cs); auto. apply canonical_nzeroP with (ltM := ltM) (p := l); auto. apply canonical_nzeroP with (ltM := ltM) (p := l0); auto. Defined. Theorem divp_ppc : forall a b c : poly A0 eqA ltM, divp (ppcp a b) c -> divp (ppcp b a) c. intros a b c; (case a; case b; case c). intros x c0 x0 c1 x1 c2; generalize c0 c1 c2; case x; case x0; case x1; simpl in |- *; auto. intros a0 l a1 l0 a2 l1 H' H'0 H'1 H'2. apply divP_eqTerm_comp with (1 := cs) (a := ppc (A:=A) A1 (n:=n) a0 a1); auto. Qed. Theorem zerop_ddivp_ppc : forall a b : poly A0 eqA ltM, ~ zerop a -> ~ zerop b -> divp (ppcp a b) b. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. intros a0 l a1 l0 H' H'0 H'1 H'2. apply divP_ppcr with (1 := cs); auto. apply canonical_nzeroP with (ltM := ltM) (p := l); auto. apply canonical_nzeroP with (ltM := ltM) (p := l0); auto. Qed. Theorem divp_nzeropl : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop a. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. Qed. Theorem divp_nzeropr : forall a b : poly A0 eqA ltM, divp a b -> ~ zerop b. intros a b; (case a; case b). intros x c0 x0 c1; generalize c0 c1; case x; case x0; simpl in |- *; auto. Qed. Hint Resolve pO_irreducible. Theorem reducetopO_pO : forall Q : list (poly A0 eqA ltM), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pO A n) (pO A n). intros Q; apply reducestar0; auto. apply Rstar_0; auto. Qed. Hint Resolve reducetopO_pO. Theorem zerop_red_spoly_l : forall a b : poly A0 eqA ltM, zerop a -> forall Q : list (poly A0 eqA ltM), red (spolyp a b) Q. 
Proof. constructor; unfold decidable. repeat decide equality. apply D. Defined.Derive (Arbitrary, Show) for grumble. Derive (Sized, CanonicalSized) for grumble. Derive SizeMonotonic for grumble using genSgrumble. Derive SizedMonotonic for grumble. Derive SizedCorrect for grumble using genSgrumble and SizeMonotonicgrumble.End MumbleGrumble.Fixpoint repeat' X x count : list X := match count with | 0 => nil X | S count' => cons X x (repeat' X x count') end.Fixpoint repeat'' X x count : list X := match count with | 0 => nil _ | S count' => cons _ x (repeat'' _ x count') end.Arguments nil {X}. Arguments cons {X} _ _. Arguments repeat {X} x count. Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X := match count with | 0 => nil | S count' => cons x (repeat''' x count') end.Inductive list' {X:Type} : Type := | nil' : list' | cons' : X -> list' -> list'.Instance dec_list'' {A} (p q : @list' A) (D : forall (x y : A), Dec (x = y)) : Dec (p = q). Proof. constructor; unfold decidable. decide equality. apply D. Defined.Derive (Arbitrary, Show) for list'. Derive (Sized, CanonicalSized) for list'. Derive SizeMonotonic for list' using genSlist'. Derive SizedMonotonic for list'. Derive SizedCorrect for list' using genSlist' and SizeMonotoniclist'.Fixpoint app {X : Type} (l1 l2 : list X) : (list X) := match l1 with | nil => l2 | cons h t => cons h (app t l2) end.Fixpoint rev {X:Type} (l:list X) : list X := match l with | nil => nil | cons h t => app (rev t) (cons h nil) end.Fixpoint length {X : Type} (l : list X) : nat := match l with | nil => 0 | cons _ l' => S (length l') end.Notation "x :: y" := (cons x y) (at level 60, right associativity). Notation "[ ]" := nil. Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..). Notation "x ++ y" := (app x y) (at level 60, right associativity).Theorem app_nil_r : forall (X:Type), forall l:list X, l ++ [] = l. Admitted. Theorem app_assoc : forall A (l m n:list A), l ++ m ++ n = (l ++ m) ++ n. Admitted. Lemma app_length : forall (X:Type) (l1 l2 : list X), length (l1 ++ l2) = length l1 + length l2. Admitted. Theorem rev_app_distr: forall X (l1 l2 : list X), rev (l1 ++ l2) = rev l1 ++ rev l2. 
(1 := fun c_i => _). cbn. instantiate (1 := ltac:(destruct (halt q); refine _)). destruct (halt q). cbn. TM_Correct. instantiate (1 := ltac:(destruct (trans (q, [|map_opt g c_i|])); refine _)). cbn. destruct (trans (q, [|map_opt g c_i|])). instantiate (1 := ltac:(destruct (destruct_vector_cons t); refine _)). cbn. destruct (destruct_vector_cons t). cbn. instantiate (1 := ltac:(destruct x; refine _)). cbn. destruct x. TM_Correct. } intros t (q_, t') ? t_sig ->. TMSimp. rename t'_0 into t'. destruct (halt q) eqn:Eq. - TMSimp. split. reflexivity. eapply H. reflexivity. - specialize (H _ eq_refl) as [[= ->] ->]. cbn in *. assert (Efg : forall o, map_opt g (map_opt f o) = o). { intros [s | ]; cbn; now rewrite ?Hg. } rewrite Efg in H0. clear Efg. destruct trans as [q' T] eqn:Eqt. destruct destruct_vector_cons as [[m c'] [nl ->]]. TMSimp. destruct_vector. split. reflexivity. now eapply H0, H. Qed. Lemma WriteB_total' : exists C, forall (c : option (Fin.t n)), projT1 (WriteB c) ‚Üì fun t k => k >= C. Proof. eapply fintype_forall_exists; cbn. - intros. eapply TerminatesIn_monotone. eassumption. intros ? ? ?. lia. - eapply WriteB_TerminatesIn. Qed. Lemma Step_total q : isTotal (Step q). Proof. destruct (MoveB_total n). destruct (ReadB_total n). destruct (WriteB_total'). eexists. eapply TerminatesIn_monotone. - unfold Step. eapply Switch_TerminatesIn. TM_Correct. cbn in *. eapply H0. cbn. intros c_i. instantiate (1 := ltac:(intros c_i; refine _)); cbn. instantiate (1 := ltac:(destruct (halt q); refine _)); cbn. destruct halt. TM_Correct. instantiate (1 := ltac:(destruct (trans (q, [| map_opt g c_i |])), (destruct_vector_cons t), x2 ; refine _)); cbn. destruct (trans (q, [| map_opt g c_i |])); cbn. destruct (destruct_vector_cons t); cbn. destruct x2. TM_Correct. eapply H1. eapply H. - cbn. intros ? ? ?. repeat eexists; help. instantiate (1 := ltac:(destruct (halt q); refine _)); cbn. destruct halt. lia. rename yout into c_i. destruct (trans (q, [| map_opt g c_i |])); cbn. destruct (destruct_vector_cons t); cbn. instantiate (1 := ltac:(destruct x2; refine _)). destruct x2. TM_Correct. repeat eexists. eapply le_plus_l. eapply le_plus_l. eapply le_plus_l. eapply le_plus_l. intros. eapply le_plus_l. Unshelve. all:cbn. all: try destruct x2; cbn in *. 3:{ destruct halt. cbn. eapply H2. eapply H2. } all:exact 0. Unshelve. all:exact 0. Qed. Lemma Step_total' : exists C, forall q, projT1 (Step q) ‚Üì fun t k => C <= k. Proof. eapply fintype_forall_exists. - intros. eapply TerminatesIn_monotone. eassumption. intros ? ?. lia. - intros q. eapply Step_total. Qed. Theorem WhileStep_Realise : StateWhile Step (start M) ‚ä® fun t '(q', t') => forall t_sig, t = [| encode_tape' t_sig |] -> exists t_sig', eval M (start M) [| t_sig |] q' [| t_sig' |] /\ t' = [| encode_tape' t_sig'|]. 
Proof. unfold mem_pred, mem_pred_one, avs2mem; split; norm; auto. destruct hm_avs; try cancel. eapply equal_f with (x := p_1) in H2. rewrite upd_eq in H2 by auto. unfold empty_mem in H2; congruence. instantiate (1 := nil); cancel. intuition; constructor. Qed.End MemPred.Theorem mem_pred_pimpl : forall LA LEQ LV HA HEQ HV hm p1 p2, (forall a v, p1 a v =p=> p2 a v) -> @mem_pred LA LEQ LV HA HEQ HV p1 hm =p=> mem_pred p2 hm. Proof. unfold mem_pred; intros. cancel; eauto. subst. induction hm_avs; simpl; intros; auto. unfold mem_pred_one at 1 3; simpl. rewrite H. cancel. eapply IHhm_avs. inversion H0; eauto. Qed.Theorem mem_pred_pimpl_except : forall LA LEQ LV HA HEQ HV hm p1 p2 a', (forall a v, a <> a' -> p1 a v =p=> p2 a v) -> @mem_pred LA LEQ LV HA HEQ HV p1 (mem_except hm a') =p=> mem_pred p2 (mem_except hm a'). Proof. unfold mem_pred; intros. cancel; eauto. assert (~ In a' (map fst hm_avs)). eapply avs2mem_none_notin. rewrite <- H3. rewrite mem_except_eq. auto. clear H3 hm. induction hm_avs; simpl; intros; auto. unfold mem_pred_one at 1 3; simpl. rewrite H. cancel. eapply IHhm_avs; eauto. inversion H0; eauto. destruct a; firstorder. Qed. Theorem mem_pred_absent_hm : forall A AEQ LV HV p hm m a, m a = None -> (forall a v, p a v =p=> exists v', a |-> v') -> @mem_pred A AEQ LV A AEQ HV p hm m -> hm a = None. Proof. intros. case_eq (hm a); intros; auto. eapply mem_pred_extract in H1; eauto. rewrite H0 in H1; destruct_lift H1. apply ptsto_valid' in H1; congruence. Qed.Theorem mem_pred_absent_lm : forall A AEQ LV HV p hm m a, hm a = None -> (forall a v, p a v =p=> exists v', a |-> v') -> @mem_pred A AEQ LV A AEQ HV p hm m -> m a = None. Proof. intros. unfold mem_pred, mem_pred_one in H1. destruct_lift H1. apply avs2mem_none_notin in H. generalize dependent m. induction dummy; simpl in *; intros. - apply emp_empty_mem_only in H1; subst. firstorder. - destruct a0; simpl in *. rewrite H0 in H1. destruct (AEQ a0 a); try solve [ exfalso; eauto ]. destruct_lift H1. generalize dependent H1. unfold_sep_star; intros; repeat safedeex. inversion H3. unfold ptsto, mem_union in H1. intuition; subst. match goal with | [ H : forall _, _ -> m1 _ = None |- _ ] => rewrite H end; eauto. Qed. Theorem xform_mem_pred : forall prd (hm : rawdisk), crash_xform (@mem_pred _ addr_eq_dec _ _ addr_eq_dec _ prd hm) <=p=> @mem_pred _ addr_eq_dec _ _ addr_eq_dec _ (fun a v => crash_xform (prd a v)) hm. 
Require Export Preduce. Section Preduceplus. Load "hCoefStructure". Load "hOrderStructure". Load "hReduce". Inductive reduceplus (Q : list (poly A0 eqA ltM)) : list (Term A n) -> list (Term A n) -> Prop := | Rstar_0 : forall x y : list (Term A n), eqP A eqA n x y -> reduceplus Q x y | Rstar_n : forall x y z : list (Term A n), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z. Hint Resolve Rstar_0. Theorem reduceplus_eqp_com : forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduceplus Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduceplus Q r s. 
= 'I_L['chi_i] :&: 'I_L['chi_j]. Proof. by move=> nKL nHL; rewrite inertia_dprod ?irr1_neq0. Qed.End InertiaDprod.Section InertiaBigdprod.Variables (gT : finGroupType) (I : finType) (P : pred I). Variables (A : I -> {group gT}) (G : {group gT}). Implicit Type L : {group gT}. Hypothesis defG : \big[dprod/1%g]_(i | P i) A i = G.Section ConjBig.Variable y : gT. Hypothesis nAy: forall i, P i -> y \in 'N(A i).Lemma cfConjgBigdprodi i (phi : 'CF(A i)) : (cfBigdprodi defG phi ^ y = cfBigdprodi defG (phi ^ y))%CF. Proof. rewrite cfConjgDprodl; try by case: ifP => [/nAy// | _]; rewrite norm1 inE. congr (cfDprodl _ _); case: ifP => [Pi | _]. by rewrite cfConjgRes_norm ?nAy. by apply/cfun_inP=> _ /set1P->; rewrite !(cfRes1, cfConjg1). rewrite -sub1set norms_gen ?norms_bigcup // sub1set. by apply/bigcapP=> j /andP[/nAy]. Qed.Lemma cfConjgBigdprod phi : (cfBigdprod defG phi ^ y = cfBigdprod defG (fun i => phi i ^ y))%CF. Proof. by rewrite rmorph_prod /=; apply: eq_bigr => i _; apply: cfConjgBigdprodi. Qed.End ConjBig.Section InertiaBig.Variable L : {group gT}. Hypothesis nAL : forall i, P i -> L \subset 'N(A i).Lemma inertia_bigdprodi i (phi : 'CF(A i)) : P i -> 'I_L[cfBigdprodi defG phi] = 'I_L[phi]. Proof. move=> Pi; rewrite inertia_dprodl ?Pi ?cfRes_id ?nAL //. by apply/norms_gen/norms_bigcup/bigcapsP=> j /andP[/nAL]. Qed.Lemma inertia_bigdprod phi (Phi := cfBigdprod defG phi) : Phi 1%g != 0 -> 'I_L[Phi] = L :&: \bigcap_(i | P i) 'I_L[phi i]. Proof. move=> nz_Phi; apply/eqP; rewrite eqEsubset; apply/andP; split. rewrite subsetI Inertia_sub; apply/bigcapsP=> i Pi. have [] := cfBigdprodK nz_Phi Pi; move: (_ / _) => a nz_a <-. by rewrite inertia_scale_nz ?sub_inertia_Res //= ?nAL. rewrite subsetI subsetIl; apply: subset_trans (inertia_prod _ _ _). apply: setISS. by rewrite -(bigdprodWY defG) norms_gen ?norms_bigcup //; apply/bigcapsP. apply/bigcapsP=> i Pi; rewrite (bigcap_min i) //. by rewrite -inertia_bigdprodi ?subsetIr. Qed.Lemma inertia_bigdprod_irr Iphi (phi := fun i => 'chi_(Iphi i)) : 'I_L[cfBigdprod defG phi] = L :&: \bigcap_(i | P i) 'I_L[phi i]. Proof. rewrite inertia_bigdprod // -[cfBigdprod _ _]cfIirrE ?irr1_neq0 //. by apply: cfBigdprod_irr => i _; apply: mem_irr. Qed.End InertiaBig.End InertiaBigdprod.Section ConsttInertiaBijection.Variables (gT : finGroupType) (H G : {group gT}) (t : Iirr H). Hypothesis nsHG : H <| G.Local Notation theta := 'chi_t. Local Notation T := 'I_G[theta]%G. Local Notation "` 'T'" := 'I_(gval G)[theta] (at level 0, format "` 'T'") : group_scope.Let calA := irr_constt ('Ind[T] theta). Let calB := irr_constt ('Ind[G] theta). Local Notation AtoB := (Ind_Iirr G). Theorem constt_Inertia_bijection : [/\ {in calA, forall s, 'Ind[G] 'chi_s \in irr G}, {in calA &, injective (Ind_Iirr G)}, Ind_Iirr G @: calA =i calB, {in calA, forall s (psi := 'chi_s) (chi := 'Ind[G] psi), [predI irr_constt ('Res chi) & calA] =i pred1 s} & {in calA, forall s (psi := 'chi_s) (chi := 'Ind[G] psi), '['Res psi, theta] = '['Res chi, theta]}]. 
Require Import GenSepN. Require Import GenSepAuto. Require Import DirTreePath. Require Import DirTreeDef. Require Import DirTreePred. Require Import DirTreeRep. Require Import DirTreeNames. Require Import DirTreeInodes. Import ListNotations.Set Implicit Arguments. Definition dirtree_safe ilist1 free1 tree1 ilist2 free2 tree2 := BFILE.ilist_safe ilist1 free1 ilist2 free2 /\ forall inum off bn pathname f, find_subtree pathname tree2 = Some (TreeFile inum f) -> BFILE.block_belong_to_file ilist2 bn inum off -> ((BFILE.block_belong_to_file ilist1 bn inum off /\ exists pathname' f', find_subtree pathname' tree1 = Some (TreeFile inum f')) \/ BFILE.block_is_unused free1 bn). Theorem dirtree_safe_refl : forall i f t, dirtree_safe i f t i f t. Proof. unfold dirtree_safe; intuition eauto. apply BFILE.ilist_safe_refl. Qed. Theorem dirtree_safe_trans : forall i1 f1 t1 i2 t2 f2 i3 t3 f3, dirtree_safe i1 f1 t1 i2 f2 t2 -> dirtree_safe i2 f2 t2 i3 f3 t3 -> dirtree_safe i1 f1 t1 i3 f3 t3. Proof. unfold dirtree_safe; intros. intuition. eapply BFILE.ilist_safe_trans; eauto. edestruct H3; eauto. - intuition; repeat deex. edestruct H2; eauto. - right. unfold BFILE.ilist_safe in *. unfold BFILE.block_is_unused in *; eauto. intuition. Qed. Lemma dirtree_safe_file : forall ilist frees inum f f', dirtree_safe ilist frees (TreeFile inum f) ilist frees (TreeFile inum f'). Proof. unfold dirtree_safe; intuition. apply BFILE.ilist_safe_refl. left; split; auto. exists pathname. eexists. destruct pathname; simpl in *; try congruence. inversion H. subst; eauto. Qed. Lemma dirtree_safe_ilist_trans : forall ilist frees ilist' frees' tree tree', dirtree_safe ilist frees tree ilist frees tree' -> BFILE.ilist_safe ilist frees ilist' frees' -> dirtree_safe ilist frees tree ilist' frees' tree'. Proof. unfold dirtree_safe, BFILE.ilist_safe; intuition. specialize (H3 _ _ _ H5); intuition. specialize (H4 _ _ _ H6); intuition. eapply H2; eauto. Qed. Lemma dirtree_safe_file_trans : forall ilist frees ilist' frees' inum f f', BFILE.ilist_safe ilist frees ilist' frees' -> dirtree_safe ilist frees (TreeFile inum f) ilist' frees' (TreeFile inum f'). Proof. intros; apply dirtree_safe_ilist_trans; auto. apply dirtree_safe_file. Qed. Theorem dirlist_safe_subtree : forall pathname tree ilist freeblocks subtree ilist' freeblocks' subtree', find_subtree pathname tree = Some subtree -> dirtree_safe ilist freeblocks subtree ilist' freeblocks' subtree' -> dirtree_safe ilist freeblocks tree ilist' freeblocks' (update_subtree pathname subtree' tree). Proof. unfold dirtree_safe; intuition. destruct (pathname_decide_prefix pathname pathname0); repeat deex. - edestruct H2; eauto. eapply find_subtree_helper1. 2: eauto. eauto. left; intuition. repeat deex. do 2 eexists. erewrite find_subtree_app; eauto. - clear H2. unfold BFILE.ilist_safe in H0. destruct H1. specialize (H2 _ _ _ H3). intuition. left. intuition. exists pathname0; eexists. erewrite <- find_subtree_update_subtree_oob'; eauto. Qed. Theorem dirtree_update_safe_inum : forall ilist_newest free_newest tree_newest pathname f tree fsxp F F0 ilist freeblocks ms sm v bn inum off m flag, find_subtree pathname tree_newest = Some (TreeFile inum f) -> BFILE.block_belong_to_file ilist_newest bn inum off -> dirtree_safe ilist (BFILE.pick_balloc freeblocks flag) tree ilist_newest free_newest tree_newest -> (F0 * rep fsxp F tree ilist freeblocks ms sm)%pred (list2nmem m) -> exists tree', (F0 * rep fsxp F tree' ilist freeblocks ms sm)%pred (list2nmem (updN m bn v)) /\ (tree' = tree \/ exists pathname' f', find_subtree pathname' tree = Some (TreeFile inum f') /\ tree' = dirtree_update_inode tree inum off v). 
C n)(f3 : forall n, B n -> C n -> D n) , efficient _ f1 -> efficient _ f2 -> efficient _ f3 -> efficient _ (fun n (a : A n) => f3 n (f1 n a) (f2 n a)). intuition. eapply (@expected_poly_time_compose _ _ _ _ _ _ (fun n a b => f3 n (f1 n a) b)); eauto. eapply (@expected_poly_time_compose _ _ _ _ _ _ (fun n a b => f3 n b)); eauto. eapply expected_poly_time_const. eauto. Qed. Theorem expected_poly_time_pair_f : forall (A B C : nat -> Type)(f1 : forall n, A n -> B n)(f2 : forall n, A n -> C n), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => (f1 n a, f2 n a)). intuition. eapply (@expected_poly_time_compose_binary _ _ _ _ _ _ (fun n b c => pair b c)); eauto. eapply expected_poly_time_pair. Qed. Theorem expected_poly_time_bvxor_f : forall (A : nat -> Type)(f1 : forall n, A n -> Bvector n)(f2 : forall n, A n -> Bvector n), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => BVxor n (f1 n a) (f2 n a)). intuition. eapply (@expected_poly_time_compose_binary _ _ _ _ _ _ BVxor); eauto. eapply expected_poly_time_bvxor. Qed. Theorem expected_poly_time_eqb_bool_f : forall (A : nat -> Type)(f1 : forall n, A n -> bool)(f2 : forall n, A n -> bool), efficient _ f1 -> efficient _ f2 -> efficient _ (fun n (a : A n) => eqb (f1 n a) (f2 n a)). intuition. eapply (@expected_poly_time_compose_binary _ _ _ _ _ _ (fun n a b => eqb a b)); eauto. eapply expected_poly_time_eqb_bool. Qed. Theorem expected_poly_time_fst_f : forall (A B C : nat -> Type)(f : forall n, A n -> (B n * C n)), efficient _ f -> efficient _ (fun n (a : A n) => fst (f n a)). intuition. eapply (@expected_poly_time_compose_simp _ _ _ _ (fun n a => fst a)); eauto. eapply expected_poly_time_fst. Qed. Theorem expected_poly_time_snd_f : forall (A B C : nat -> Type)(f : forall n, A n -> (B n * C n)), efficient _ f -> efficient _ (fun n (a : A n) => snd (f n a)). intuition. eapply (@expected_poly_time_compose_simp _ _ _ _ (fun n a => snd a)); eauto. eapply expected_poly_time_snd. Qed. Theorem expected_poly_time_compose_0_binary : forall (A B C : nat -> Type)(f1 : forall n, A n)(f2 : forall n, B n)(f3 : forall n, A n -> B n -> C n) , efficient _ f1 -> efficient _ f2 -> efficient _ f3 -> efficient _ (fun n => f3 n (f1 n) (f2 n)). 
(Atom j) b) + weight c + weight (Imp a0 a1) < S (S (S (S (weight_neg b + weight (Imp a0 a1) + weight c))))) in |- *. generalize (weight (Imp a0 a1)); intro a. generalize (weight c); intro cn. rewrite (plus_assoc_reverse (weight_neg (Imp (Atom j) b)) cn a). rewrite (plus_comm cn a). rewrite (plus_assoc (weight_neg (Imp (Atom j) b)) a cn). apply le_lt_trans with (S (S (S (weight_neg b))) + a + cn). apply plus_le_compat_r. apply plus_le_compat_r. apply weight_neg_le. apply lt_n_Sn. Qed.Fixpoint list2vlist (gamma : flist) : vlist := match gamma with | nil => nil (A:=list Int * form) | a :: gamma => (nil, a) :: list2vlist gamma end.Lemma vlist_eq : forall gamma : flist, gamma = vlist2list (list2vlist gamma). intros gamma; elim gamma; clear gamma. trivial. intros a gamma ih. simpl in |- *. rewrite <- ih; trivial. Qed. Lemma search_goal_invariant : forall (goal : form) (gamma : flist) (work : nf_list) (context : flist) (j : Int), search_spec goal gamma work context j. intros goal gamma work context j. cut (forall (n : nat) (goal : form) (gamma : flist) (work : nf_list) (context : flist) (j : Int), weight_goal goal < n -> search_spec goal gamma work context j). intros claim. apply claim with (S (weight_goal goal)). apply lt_n_Sn. clear goal gamma work context j. intros n; elim n; clear n. intros goal gamma work context j lt_weight. elimtype False. apply (lt_n_O (weight_goal goal)); assumption.intros n ih goal gamma work context j. case goal; clear goal. intros lt_weight. elim (int_succ j). intros j1 less1. apply rule_gamma_falsum with j1; try assumption. rewrite (vlist_eq gamma). apply (search_atom_aux (S (weight_gamma (vlist2hlist (list2vlist gamma))))). apply lt_n_Sn. intros i lt_weight. rewrite (vlist_eq gamma). apply (search_atom_aux (S (weight_gamma (vlist2hlist (list2vlist gamma))))). apply lt_n_Sn. intros g0 g1 lt_weight. elim (int_succ j). intros j1 less1. apply rule_gamma_a with j1; try assumption. apply ih. apply lt_S_n; assumption. intros g0 g1 lt_weight. elim (int_succ j). intros j1 less1. apply rule_gamma_a with j1; try assumption. apply ih. apply lt_S_n; assumption. intros g0 g1 lt_weight. apply rule_gamma_a_imp_b. apply ih. apply lt_S_n; assumption. Qed. Inductive search_spec (goal : form) (gamma : flist) : Set := | derivable : Derivable gamma goal -> search_spec goal gamma | refutable : forall k : kripke_tree, Is_Monotone_kripke_tree k -> (forall a : form, In a gamma -> forces_t k a) -> (forces_t k goal -> False) -> search_spec goal gamma. Theorem search : forall (goal : form) (gamma : flist), search_spec goal gamma. 
-> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. destruct m as [|m]. reflexivity. apply fold1'_xelements' with (l := @nil (positive * A)). Qed. Arguments empty A : simpl never. Arguments get {A} p m : simpl never. Arguments set {A} p x m : simpl never. Arguments remove {A} p m : simpl never.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. reflexivity. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gso; auto. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then x else get i m. Proof. intros. destruct (peq i j). rewrite e. apply gss. auto. apply gso. auto. Qed. Theorem gsident: forall (A: Type) (i j: positive) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. destruct (peq i j). rewrite e. rewrite gss. auto. rewrite gso; auto. Qed. Definition map (A B : Type) (f : A -> B) (m : t A) : t B := (f (fst m), PTree.map1 f (snd m)). Theorem gmap: forall (A B: Type) (f: A -> B) (i: positive) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold map. unfold get. simpl. rewrite PTree.gmap1. unfold option_map. destruct (PTree.get i (snd m)); auto. Qed. Theorem set2: forall (A: Type) (i: elt) (x y: A) (m: t A), set i y (set i x m) = set i y m. 
A0 eqA (n:=n) c) (nZd : ~ zeroP (A:=A) A0 eqA (n:=n) d), eqT a b -> eqT c d -> eqT (divTerm a nZc) (divTerm b nZd). intros a b c d; case a; case b; case c; case d; unfold eqT in |- *; simpl in |- *; auto. intros A0' c0 d2 c2 H' c3 H'0 c4 H'1 H'2 H'3 H'4; rewrite H'3; rewrite H'4; auto. Qed. Theorem eqTerm_divTerm_comp : forall (a b c d : Term A n) (nZc : ~ zeroP (A:=A) A0 eqA (n:=n) c) (nZd : ~ zeroP (A:=A) A0 eqA (n:=n) d), eqTerm (A:=A) eqA (n:=n) a b -> eqTerm (A:=A) eqA (n:=n) c d -> eqTerm (A:=A) eqA (n:=n) (divTerm a nZc) (divTerm b nZd). intros a b c d; case a; case b; case c; case d; simpl in |- *; auto. intros A0' c0 d2 c2 d3 c3 d4 c4 nZd2 H'0 H'1 H'2. case H'2; intros H'3 H'4; clear H'2. case H'1; intros H'2 H'5; clear H'1. split; auto. rewrite H'5; rewrite H'4; auto. Qed. Hint Resolve eqTerm_divTerm_comp. Theorem divTerm_multTerm_l : forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) -> eqTerm (A:=A) eqA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) c b) nZa) (multTerm (A:=A) multA (n:=n) c (divTerm b nZa)). intros a b c; case a; case b; case c; simpl in |- *; auto. intros d c0 A0' c2 d2 c3 nZd2 H'0; case H'0; intros H'1 H'2; auto. split; auto. apply divA_multA_comp_l with (1 := cs). rewrite H'2. repeat rewrite mult_div_com. rewrite mult_mon_assoc. repeat rewrite mult_div_com; auto. Qed. Theorem divTerm_multTerm_r : forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZa) a) -> eqTerm (A:=A) eqA (n:=n) (divTerm (multTerm (A:=A) multA (n:=n) b c) nZa) (multTerm (A:=A) multA (n:=n) (divTerm b nZa) c). intros a b c; case a; case b; case c; simpl in |- *; auto. intros a0 m a1 m0 a2 m1 nZa H'; split; auto. apply divA_multA_comp_r with (1 := cs). elim H'; intros H'0 H'1; rewrite H'1; clear H'. rewrite mult_div_com; auto. rewrite <- mult_mon_assoc. rewrite (mult_mon_com n m1 m). rewrite mult_mon_assoc. rewrite mult_div_com; auto. Qed. Hint Resolve divTerm_multTerm_l divTerm_multTerm_r. Theorem div_is_T1 : forall (a : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a), eqTerm (A:=A) eqA (n:=n) (divTerm a nZa) (T1 A1 n). 
client : clientId. Variable id : nat. Variable client' : clientId. Variable id' : nat. Lemma output_before_input_not_key_in_input_trace : forall tr tr' s s', ~ output_before_input client id client' id' tr -> step_failure s s' tr' -> output_before_input client id client' id' (tr ++ tr') -> ~ exists i, in_input_trace client' id' i (tr ++ tr'). Proof using. intros. find_eapply_lem_hyp before_func_app_necessary; eauto. intuition. break_exists. unfold in_input_trace in *. break_exists. do_in_app. intuition; [find_apply_hyp_hyp; simpl in *; break_if; repeat (do_bool; intuition)|]. invcs H0; intuition. - break_if; congruence. - find_inversion; try congruence. repeat (do_bool; intuition). break_if; try congruence. - find_inversion. Qed. Lemma output_before_input_key_in_output_trace : forall tr, output_before_input client id client' id' tr -> key_in_output_trace client id tr. Proof using. intros. unfold output_before_input in *. induction tr; simpl in *; intuition. - unfold key_in_output_trace. unfold is_output_with_key in *. repeat break_match; try congruence. subst. do 2 eexists. intuition; eauto. - unfold key_in_output_trace in *. break_exists_exists. simpl; intuition. Qed. Lemma in_applied_entries_entries_ordered : forall net, in_applied_entries client id net -> ~ in_applied_entries client' id' net -> entries_ordered client id client' id' net. Proof using. intros. unfold in_applied_entries, entries_ordered in *. induction (applied_entries (nwState net)); simpl in *; break_exists; intuition. - subst. left. unfold has_key. break_match. simpl. break_if; repeat (do_bool; intuition). - right. intuition. + apply Bool.not_true_iff_false. intuition. find_false. unfold has_key in *. break_match; simpl in *; break_if; repeat (do_bool; intuition); try congruence. subst. eexists; intuition; eauto. + eapply IHl. * eexists; intuition; eauto. * intuition. find_false. break_exists_exists. intuition. Qed. Lemma in_applied_entries_applied_implies_input_state : forall net, in_applied_entries client' id' net -> exists e, eClient e = client' /\ eId e = id' /\ applied_implies_input_state client' id' (eInput e) net. Proof using. intros. unfold in_applied_entries in *. break_exists_exists. intuition. red. exists x. intuition. - red. auto. - unfold applied_entries in *. break_match. + find_apply_lem_hyp in_rev. find_apply_lem_hyp removeAfterIndex_in. eauto. + simpl in *. intuition. Qed. Program Instance TR : TraceRelation step_failure := { init := step_failure_init; T := output_before_input client id client' id'; R := fun s => entries_ordered client id client' id' (snd s) }. Next Obligation. unfold output_before_input. eapply before_func_dec. Defined. Next Obligation. simpl in *. unfold entries_ordered in *. find_apply_lem_hyp step_failure_star_raft_intermediate_reachable. find_eapply_lem_hyp applied_entries_monotonic'; eauto. break_exists; repeat find_rewrite. eauto using before_func_app. Defined. Next Obligation. simpl in *. find_copy_eapply_lem_hyp output_before_input_not_key_in_input_trace; eauto. find_copy_apply_lem_hyp output_before_input_key_in_output_trace. find_eapply_lem_hyp output_implies_applied; [|eapply refl_trans_n1_1n_trace; econstructor; eauto using refl_trans_1n_n1_trace]. eapply in_applied_entries_entries_ordered; auto. intuition. find_false. find_apply_lem_hyp in_applied_entries_applied_implies_input_state. break_exists. intuition. eexists. eapply applied_implies_input; eauto. eapply refl_trans_n1_1n_trace; econstructor; eauto using refl_trans_1n_n1_trace. Defined. Theorem causal_order_preserved : forall failed net tr, step_failure_star step_failure_init (failed, net) tr -> output_before_input client id client' id' tr -> entries_ordered client id client' id' net. 
induction n. sepLemma. sepLemmaLhsOnly. destruct n. specialize (H4 (refl_equal _)); subst. sepLemma. sepLemma. clear H4. transitivity ([| x <> 0 |] * llist (b %- (x1, x0)) (S n) x ba * SEP.ST.star (fr =*> x1) (SEP.ST.star ((fr ^+ $4) =*> x0) ((fr ^+ $8) =*> x))). sepLemma. remember (S n). sepLemmaLhsOnly. etransitivity. eapply himp_star_frame; [ auto | reflexivity ]. sepLemma. sepLemma. injection H4; clear H4; intros; subst. apply lseg_extensional'; bags. Qed. Theorem llist_nonempty_fwd_b : forall b n (fr : W) ba, ~(b %= empty) -> focusOnFront -> llist b n fr ba ===> [| fr <> 0 |] * Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba. destruct n; sepLemma. Qed. Theorem llist_nonempty_bwd : forall b n (fr ba : W), fr <> 0 -> focusOnFront -> (Ex n', Ex v1, Ex v2, Ex p, [| n = S n' |] * [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba) ===> llist b n fr ba. destruct n; sepLemma; match goal with | [ H : S _ = S _ |- _ ] => injection H; intros; subst end; auto; sepLemma. Qed. Lemma llist_end_bwd' : forall (ba : W) n (fr : W) b, (Ex v1, Ex v2, Ex v1', Ex v2', Ex n', Ex p, [| n = S (S n') |] * [| (v1', v2') %in b |] * [| (v1, v2) %in b %- (v1', v2')|] * lseg (b %- (v1, v2) %- (v1', v2')) n' fr p * [| p <> 0 |] * [| freeable p 3 |] * (p ==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. induction n. sepLemma. destruct n. sepLemma. destruct n. sepLemmaLhsOnly. injection H; clear H; intros; subst. sepLemmaLhsOnly. sepLemma. remember (S (S n)). sepLemmaLhsOnly. remember (S (S n)). replace x0 with (S n) by omega. sepLemmaLhsOnly. remember (S (S n)). sepLemma. etransitivity; try apply IHn. sepLemma. apply lseg_extensional'; bags. Qed. Theorem llist_end_bwd : forall (ba : W) n (fr : W) b, fr <> 0 -> focusOnBack -> (Ex v1, Ex v2, Ex v1', Ex v2', Ex n', Ex p, [| n = S (S n') |] * [| (v1', v2') %in b |] * [| (v1, v2) %in b %- (v1', v2')|] * lseg (b %- (v1, v2) %- (v1', v2')) n' fr p * [| p <> 0 |] * [| freeable p 3 |] * (p ==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. 
inv H3. apply bound_var_ctx_comp_ctx; auto. apply Disjoint_sym. eapply Disjoint_Included_l. 2: apply H7. intro; intros. apply bound_var_ctx_comp_ctx; auto. apply Disjoint_sym. eapply Disjoint_Included_l. 2: apply H9. intro; intros. apply bound_var_ctx_comp_ctx; auto. + destructAll. inv H. constructor; eauto. intro. apply bound_var_ctx_comp_ctx in H. inv H. apply H7; auto. inv H1. specialize (H v). apply H. split; auto. split. intro. intro. inv H. apply bound_var_ctx_comp_ctx in H2. inv H2. inv H9. specialize (H2 x). apply H2. split; auto. inv H1. specialize (H2 x). apply H2. split. right; auto. auto. split; intro; intro. inv H. apply bound_var_ctx_comp_ctx in H2. inv H2. inv H11. specialize (H2 x); auto. inv H1. specialize (H2 x); apply H2. split; auto. apply IHc. split; auto. split; auto. eapply Disjoint_Included_l. 2: apply H1. eauto with Ensembles_DB. - split; intro. + inv H. apply IHfdc in H13. destructAll. split. constructor; auto. intro; apply H6. apply bound_var_ctx_comp_ctx. auto. eapply Disjoint_Included_l. 2: apply H8. intro; intro. apply bound_var_ctx_comp_ctx; auto. eapply Disjoint_Included_r. 2: apply H9. intro; intro. apply bound_var_ctx_comp_ctx; auto. split; auto. split. intro. intro. inv H2. inv H3. apply H6. inv H2. apply bound_var_ctx_comp_ctx; auto. inv H2. inv H8. specialize (H2 x). apply H2. split; auto. apply bound_var_ctx_comp_ctx; auto. inv H3. inv H9. specialize (H3 x). apply H3. split; auto. apply bound_var_ctx_comp_ctx; auto. inv H1. specialize (H3 x). apply H3; split; auto. + destructAll. inv H. constructor; auto. intro. apply bound_var_ctx_comp_ctx in H. inv H. auto. inv H1. specialize (H v). apply H. split; auto. split. intro; intro. inv H. apply bound_var_ctx_comp_ctx in H2. inv H2. inv H10. specialize (H2 x). apply H2; auto. inv H1. specialize (H2 x). apply H2; auto. split; intro; intro. inv H. apply bound_var_ctx_comp_ctx in H3. inv H3. inv H11. specialize (H3 x). apply H3; auto. inv H1. specialize (H3 x). apply H3. split. auto. auto. apply IHfdc. split; auto. split; auto. eapply Disjoint_Included_l. 2: apply H1. auto with Ensembles_DB. Qed. Theorem inlined_fundefs_f_staged: forall x im f4, (inlined_fundefs_f f4 (M.set x true im)) = (inlined_fundefs_f (inlined_fundefs_f f4 im) (M.set x true (M.empty bool))). Proof. induction f4; simpl; try rewrite IHf4; auto. destruct (var_dec v x). - subst. unfold get_b. rewrite M.gss. destruct (M.get x im). destruct b. auto. simpl. unfold get_b. rewrite M.gss. auto. simpl. unfold get_b. rewrite M.gss. auto. - unfold get_b. rewrite M.gso. destruct (M.get v im). destruct b. auto. simpl. unfold get_b. rewrite M.gso. rewrite M.gempty. auto. auto. simpl. unfold get_b. rewrite M.gso; auto. auto. Qed. Theorem inlined_ctx_f_staged_mut: forall x im, (forall c, inlined_ctx_f c (M.set x true im) = inlined_ctx_f (inlined_ctx_f c im) (M.set x true (M.empty bool))) /\ ( forall fc, inlined_fundefs_ctx_f fc (M.set x true im) = inlined_fundefs_ctx_f (inlined_fundefs_ctx_f fc im) (M.set x true (M.empty bool))). 
auto. apply Rlt_dichotomy_converse; right; auto with real. red in |- *; auto with real. Qed. Theorem FshiftFdigit : forall (n : nat) (x : float), ~ is_Fzero x -> Fdigit (Fshift n x) = Fdigit x + n. intros n x; case x; unfold Fshift, Fdigit, is_Fzero in |- *; simpl in |- *. intros p1 p2 H; apply digitAdd; auto. Qed. Theorem FshiftCorrect : forall (n : nat) (x : float), Fshift n x = x :>R. intros n x; unfold FtoR in |- *; simpl in |- *. rewrite Rmult_IZR. rewrite Zpower_nat_Z_powerRZ; auto. repeat rewrite Rmult_assoc. rewrite <- powerRZ_add; auto with real zarith. rewrite Zplus_minus; auto. Qed. Theorem FshiftCorrectInv : forall x y : float, x = y :>R -> (Fexp x <= Fexp y)%Z -> Fshift (Zabs_nat (Fexp y - Fexp x)) y = x. intros x y H' H'0; try apply sameExpEq; auto. apply trans_eq with (y := FtoR y); auto. apply FshiftCorrect. generalize H' H'0; case x; case y; simpl in |- *; clear H' H'0 x y. intros Fnum1 Fexp1 Fnum2 Fexp2 H' H'0; rewrite inj_abs; auto with zarith. Qed. Theorem FshiftO : forall x : float, Fshift 0 x = x. intros x; unfold Fshift in |- *; apply floatEq; simpl in |- *. replace (Zpower_nat radix 0) with 1%Z; auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem FshiftCorrectSym : forall x y : float, x = y :>R -> exists n : nat, (exists m : nat, Fshift n x = Fshift m y). intros x y H'. case (Z_le_gt_dec (Fexp x) (Fexp y)); intros H'1. exists 0; exists (Zabs_nat (Fexp y - Fexp x)). rewrite FshiftO. apply sym_equal. apply FshiftCorrectInv; auto. exists (Zabs_nat (Fexp x - Fexp y)); exists 0. rewrite FshiftO. apply FshiftCorrectInv; auto with zarith. Qed. Theorem FshiftAdd : forall (n m : nat) (p : float), Fshift (n + m) p = Fshift n (Fshift m p). intros n m p; case p; unfold Fshift in |- *; simpl in |- *. intros Fnum1 Fexp1; apply floatEq; simpl in |- *; auto with zarith. rewrite Zpower_nat_is_exp; auto with zarith. rewrite (Zmult_comm (Zpower_nat radix n)); auto with zarith. rewrite <- (Zminus_plus_simpl_r (Fexp1 - m) n m). replace (Fexp1 - m + m)%Z with Fexp1; auto with zarith. replace (Z_of_nat (n + m)) with (n + m)%Z; auto with zarith arith. rewrite <- inj_plus; auto. Qed. Theorem ReqGivesEqwithSameExp : forall p q : float, exists r : float, (exists s : float, p = r :>R /\ q = s :>R /\ Fexp r = Fexp s). 
s_st = true /\ Locals.sel vs x <> Locals.sel vs' x -> @is_mapsto_adt ADTValue x s_st' = true -> ~ @In ADTValue (Locals.sel vs' x) h. Lemma new_adt_no_pollute_seq st vs st' vs' st'' vs'' h h' h'' : new_adt_no_pollute st vs st' vs' h -> new_adt_no_pollute st' vs' st'' vs'' h' -> h == h'' -> h' == h'' -> new_adt_no_pollute st vs st'' vs'' h''. Proof. unfold new_adt_no_pollute; intros Hanew Hbnew Hheq Hheq' x Hmt Hmt''. unfold Locals.sel in *. destruct (boolcase (is_mapsto_adt x st')) as [Hmt' | Hmtf']. destruct (Word.weq (vs' x) (vs'' x)) as [Heq | Hne]. rewrite <- Heq in *. rewrite <- Hheq. solve [eapply Hanew; eauto]. eapply Hbnew in Hmt''. rewrite <- Hheq'. solve [eauto]. solve [right; eauto]. eapply Hbnew in Hmt''. rewrite <- Hheq'. solve [eauto]. solve [left; eauto]. Qed. Lemma related_add_sca st vs h lhs w h' : related st (vs, h) -> not_mapsto_adt lhs st = true -> h' == h -> related (StringMap.add lhs (SCA _ w) st) (Locals.upd vs lhs w, h'). Proof. intros Hr Hnmt Hheq. unfold related; simpl in *. split. intros x v Hfx. destruct (string_dec x lhs) as [Heq | Hne]. subst. rewrite StringMapFacts.add_eq_o in * by eauto. inject Hfx; simpl in *. rewrite Locals.sel_upd_eq in * by eauto. eauto. rewrite StringMapFacts.add_neq_o in * by eauto. rewrite Locals.sel_upd_ne in * by eauto. eapply Hr in Hfx; simpl in *. solve [rewrite Hheq; eauto]. intros p a Hfp. rewrite Hheq in Hfp. eapply Hr in Hfp. simpl in *. destruct Hfp as [x [[Hvs Hfx] Hu]]. subst. destruct (string_dec x lhs) as [Heq | Hne]. subst. eapply not_mapsto_adt_find in Hfx; eauto. openhyp; discriminate. exists x. split. rewrite Locals.sel_upd_ne in * by eauto. rewrite StringMapFacts.add_neq_o in * by eauto. eauto. intros x' [Hvs Hfx']. destruct (string_dec x' lhs) as [Heq' | Hne']. subst. rewrite StringMapFacts.add_eq_o in * by eauto. discriminate. rewrite Locals.sel_upd_ne in * by eauto. rewrite StringMapFacts.add_neq_o in * by eauto. eauto. Qed. Lemma new_adt_no_pollute_add_sca st vs lhs w1 w2 h : new_adt_no_pollute st vs (StringMap.add lhs (SCA _ w1) st) (Locals.upd vs lhs w2) h. Proof. unfold new_adt_no_pollute. intros x Hmt Hmt'. destruct (string_dec x lhs) as [Heq | Hne]. subst. rewrite Locals.sel_upd_eq in * by eauto. rewrite is_mapsto_adt_eq_sca in *. discriminate. rewrite Locals.sel_upd_ne in * by eauto. rewrite is_mapsto_adt_neq in * by eauto. intros; openhyp; intuition. rewrite H in Hmt'. discriminate. Qed. Require Bedrock.Platform.Cito.Inv. Theorem compile_runsto : forall t t_env t_st t_st', CitoRunsTo t_env t t_st t_st' -> forall s, t = compile s -> forall h1, h1 <= snd t_st -> forall s_st, related s_st (fst t_st, h1) -> forall s_env, cenv_impls_env t_env s_env -> Safe s_env s s_st -> exists s_st', RunsTo s_env s s_st s_st' /\ let h2 := snd t_st - h1 in h2 <= snd t_st' /\ (forall x, ~ StringSet.In x (assigned s) -> Locals.sel (fst t_st) x = Locals.sel (fst t_st') x) /\ (forall x, is_mapsto_adt x s_st = false \/ is_mapsto_adt x s_st = true /\ Locals.sel (fst t_st) x <> Locals.sel (fst t_st') x -> is_mapsto_adt x s_st' = true -> ~ In (Locals.sel (fst t_st') x) h2) /\ related s_st' (fst t_st', snd t_st' - h2). 
EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_Node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H1. destruct H1. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall A (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall A (m: t A) i, (forall i, get i m = None) -> xelements m i = nil. Proof. intros. replace m with (@Empty A). auto. apply extensionality; intros. symmetry; auto. Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros until n. change (elements m) with (xelements m xH). change (elements n) with (xelements n xH). generalize 1%positive. revert m n. induction m using tree_ind; [ | induction n using tree_ind]; intros until p; intros REL. - replace n with (@Empty B). constructor. apply extensionality; intros. specialize (REL i). simpl in *. inv REL; auto. - replace (Node l o r) with (@Empty A). constructor. apply extensionality; intros. specialize (REL i). simpl in *. inv REL; auto. - rewrite ! xelements_Node. repeat apply list_forall2_app. + apply IHm. intros. specialize (REL (xO i)). rewrite ! gNode in REL; auto. + specialize (REL xH). rewrite ! gNode in REL. inv REL; constructor; auto using list_forall2_nil. + apply IHm0. intros. specialize (REL (xI i)). rewrite ! gNode in REL; auto. Qed. Theorem elements_canonical_order: forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) -> (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros. apply elements_canonical_order'. intros. destruct (get i m) as [x|] eqn:GM. exploit H; eauto. intros (y & P & Q). rewrite P; constructor; auto. destruct (get i n) as [y|] eqn:GN. exploit H0; eauto. intros (x & P & Q). congruence. constructor. Qed. Theorem elements_extensional: forall (A: Type) (m n: t A), (forall i, get i m = get i n) -> elements m = elements n. 
xp freelist freepred * [[ cache_rep freelist (MSCache ms) ]])%pred. Fact cache_rep_freelist0: forall freelist, cache_rep freelist freelist0. Proof. cbv. congruence. Qed. Hint Resolve cache_rep_freelist0. Lemma cache_rep_remove_cons: forall freelist n cache', cache_rep freelist (Some (n :: cache')) -> cache_rep (remove addr_eq_dec n freelist) (Some cache'). Proof. unfold cache_rep. intros. inversion H0; subst. specialize (H _ (eq_refl)). intuition. inversion H; auto. destruct (addr_eq_dec 0 n); subst. cbn in *; intuition auto. rewrite remove_comm. erewrite <- remove_not_In with (l := cfreelist) (a := n). erewrite <- remove_cons with (l := cfreelist). apply permutation_remove; auto. inversion H; auto. Qed. Lemma cache_rep_add_cons: forall freelist x cache, cache_rep freelist (Some cache) -> x <> 0 -> ~In x cache -> cache_rep (x :: freelist) (Some (x :: cache)). Proof. unfold cache_rep. intros. specialize (H _ eq_refl). inversion H2; subst. intuition. destruct H4; auto. constructor; auto. rewrite remove_cons_neq by auto. auto using permutation_cons. Qed. Lemma cache_rep_in: forall bn freelist cache, cache_rep freelist (Some cache) -> bn <> 0 -> In bn freelist <-> In bn cache. Proof. unfold cache_rep. intros. specialize (H _ eq_refl). intuition. rewrite count_occ_In. rewrite <- H3. rewrite count_occ_remove_ne by auto. rewrite <- count_occ_In. auto. rewrite count_occ_In. erewrite <- count_occ_remove_ne by eauto. rewrite H3. rewrite <- count_occ_In. auto. Qed. Lemma cache_rep_none: forall freelist, cache_rep freelist None. Proof. cbv [cache_rep]. intros. congruence. Qed. Hint Resolve cache_rep_none. Ltac apply_cache_rep := match goal with | Hm: MSCache _ = _, H: cache_rep _ _ |- _ => rewrite ?Hm in *; specialize (H _ eq_refl) as ?; intuition end. Theorem init_ok : forall V FP lxp xp ms, {< F Fm m0 sm m bl, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * arrayN (@ptsto _ _ _) (Sig.BMPStart xp) bl) ]]] * [[ Sig.xparams_ok xp /\ Sig.BMPStart xp <> 0 /\ length bl = Sig.BMPLen xp ]] POST:hm' RET:ms exists m' freepred freelist, LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * @rep V FP xp freelist freepred ms) ]]] * [[ forall bn, bn < (Sig.BMPLen xp) * valulen -> In bn freelist ]] * [[ forall dl, length dl = ((Sig.BMPLen xp) * valulen)%nat -> Forall FP dl -> arrayN (@ptsto _ _ _) 0 dl =p=> freepred ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init lxp xp ms. Proof. unfold init, rep; intros. step. step. Qed. Theorem init_nofree_ok : forall V FP lxp xp ms, {< F Fm m0 sm m bl, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * arrayN (@ptsto _ _ _) (Sig.BMPStart xp) bl) ]]] * [[ Sig.xparams_ok xp /\ Sig.BMPStart xp <> 0 /\ length bl = Sig.BMPLen xp ]] POST:hm' RET:ms exists m', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLog ms) sm hm' * [[[ m' ::: (Fm * @rep V FP xp nil emp ms) ]]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} init_nofree lxp xp ms. 
(A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZc) c) -> eqTerm (A:=A) eqA (n:=n) b (multTerm (A:=A) multA (n:=n) (divTerm b nZc) c). intros a b c; case a; case b; case c; simpl in |- *; auto. intros a1 m1 a2 m2 a3 m3 H1 H2 H3 H4 H5; case H5; intros H6 H7; split; auto. apply divA_is_multA with (1 := cs); auto. unfold eqT in H1; simpl in H1; rewrite <- H1; auto. Qed. Let gb : mon n * bool -> bool. intros H'; case H'; auto. Defined. Let gm : mon n * bool -> mon n. intros H'; case H'; auto. Defined. Definition mk_clean : forall a b : mon n, {c : mon n * bool | c = div_mon_clean n a b}. intros a b; exists (div_mon_clean n a b); auto. Qed. Theorem divTerm_dec : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, {eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)} + {~ eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)}. intros a b; case a; case b; simpl in |- *; auto. intros b2 c2 b3 c3. intros Zp1 Zp2. case (mk_clean c3 c2). intros x; case x. intros c b4; case b4. intros H0; left; simpl in |- *; auto. generalize (div_clean_dec1 n c3 c2); rewrite <- H0; simpl in |- *; auto. intros H1; case H1; auto; intros H2 H3; split; auto. apply divA_is_multA with (1 := cs); auto. intros H0; right; red in |- *; intros dviP_H; inversion dviP_H. generalize (div_clean_dec2 n c3 c2); simpl in |- *; auto. intros H'; lapply H'; [ intros H'0; apply H'0; clear H' | clear H' ]. rewrite <- H1; auto. rewrite <- H0; simpl in |- *; auto. Qed. Theorem zeroP_divTerm : forall a b : Term A n, zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). intros a b; case a; case b; simpl in |- *; auto. intros d H' A0' H'0 H'1 nZd; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA A0 d nZd); auto. apply divA_A0_l with (1 := cs). Qed. Theorem divTerm_on_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). 
aexp' -> Prop := | ANumEq : forall n1 n2, n1 = n2 -> aexpEq (ANum n1) (ANum n2).Instance dec_aexpEq (x y : aexp') : Dec (aexpEq x y). constructor; unfold decidable. destruct x; destruct y; try solve [right => H; inversion H; eauto]. destruct ((n = n0)?) eqn:Eq; destruct dec; try solve [inversion Eq]. - left; econstructor; eauto. - right => H; inversion H; eauto. Defined. Conjecture aexpEq_refl : forall x, aexpEq x x. QuickChick aexpEq_refl.Derive ArbitrarySizedSuchThat for (fun x => aexpEq x x'). Derive SizedProofEqs for (fun x => aexpEq x x'). Derive SizeMonotonicSuchThatOpt for (fun x => aexpEq x x'). Derive GenSizedSuchThatSizeMonotonicOpt for (fun x => aexpEq x x'). Derive GenSizedSuchThatCorrect for (fun x => aexpEq x x').Conjecture aexpEq_eq : forall x x', aexpEq x x' -> x = x'. QuickChick aexpEq_eq. Inductive bexp' : Type := | BTrue : bexp' | BFalse : bexp' | BEq : aexp' -> aexp' -> bexp' | BLe : aexp' -> aexp' -> bexp' | BNot : bexp' -> bexp' | BAnd : bexp' -> bexp' -> bexp'.Derive (Arbitrary, Show) for bexp'. Derive (Sized, CanonicalSized) for bexp'. Derive SizeMonotonic for bexp' using genSbexp'. Derive SizedMonotonic for bexp'. Derive SizedCorrect for bexp' using genSbexp' and SizeMonotonicbexp'.Instance dec_eq_bexp (x y : bexp') : Dec (x = y). constructor; unfold decidable; repeat decide equality. Defined.Fixpoint aeval (a : aexp') : nat := match a with | ANum n => n | APlus a1 a2 => (aeval a1) + (aeval a2) | AMinus a1 a2 => (aeval a1) - (aeval a2) | AMult a1 a2 => (aeval a1) * (aeval a2) end.Fixpoint beval (b : bexp') : bool := match b with | BTrue => true | BFalse => false | BEq a1 a2 => beq_nat (aeval a1) (aeval a2) | BLe a1 a2 => leb (aeval a1) (aeval a2) | BNot b1 => negb (beval b1) | BAnd b1 b2 => andb (beval b1) (beval b2) end.Fixpoint optimize_0plus (a:aexp') : aexp' := match a with | ANum n => ANum n | APlus (ANum 0) e2 => optimize_0plus e2 | APlus e1 e2 => APlus (optimize_0plus e1) (optimize_0plus e2) | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2) | AMult e1 e2 => AMult (optimize_0plus e1) (optimize_0plus e2) end.End AExp.Import AExp.Theorem optimize_0plus_sound: forall a, aeval (optimize_0plus a) = aeval a. Admitted. Theorem silly1 : forall ae, aeval ae = aeval ae. Admitted. Theorem silly2 : forall (P : Prop), P -> P. 
Require Import List.Require Import Undecidability.Synthetic.Definitions.From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_nat.From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.From Undecidability.H10 Require Import Dio.dio_single H10.From Undecidability.MuRec.Util Require Import recalg ra_dio_poly ra_sem_eq.Section H10_MUREC_HALTING. Let f : H10_PROBLEM -> MUREC_PROBLEM. Proof. intros (n & p & q). exact (ra_dio_poly_find p q). Defined. Theorem H10_MUREC_HALTING : H10 ‚™Ø Halt_murec. 
dependent A. œâ_induction n; intros A Hfa C HC Hdj. - apply eqnum_empty in HC. subst C. rewrite bunion_empty... - apply set_eqnum_suc_nonempty in HC as Hi... destruct Hi as [c Hc]. apply split_one_element in Hc. rewrite Hc in HC. rewrite bunion_comm in Hc. rewrite Hc, bunion_assoc. apply IH. + apply add_one_still_finite_2... + apply finite_set_remove_one_member... + apply disjointI. intros [x [H1 H2]]. apply SepE in H2 as [H2 H3]. apply BUnionE in H1 as []... eapply disjointE... Qed. Example ex6_9 : ‚àÄ A B, finite A ‚Üí finite B ‚Üí finite (A √ó B). Proof with eauto. intros * Hfa [n [Hn HB]]. generalize dependent B. generalize dependent A. œâ_induction n; intros A Hfa B HB. - apply eqnum_empty in HB. subst B. rewrite cprd_0_r... - apply set_eqnum_suc_nonempty in HB as Hi... destruct Hi as [b Hb]. apply split_one_element in Hb. rewrite Hb in HB. rewrite bunion_comm in Hb. rewrite Hb, ex3_54_b. apply ex6_8. + destruct Hfa as [k [Hk HA]]. exists k. split... rewrite <- eqnum_cprd_single... + apply IH... apply finite_set_remove_one_member... Qed.Example ex6_12_a : ‚àÄ K L, K ‚à™ L = L ‚à™ K. Proof. exact bunion_comm. Qed.Example ex6_12_b : ‚àÄ K L M, K ‚à™ (L ‚à™ M) = (K ‚à™ L) ‚à™ M. Proof. exact bunion_assoc. Qed.Example ex6_12_c : ‚àÄ K L M, K √ó (L ‚à™ M) = (K √ó L) ‚à™ (K √ó M). Proof. exact ex3_2_a. Qed.Lemma union_finite : ‚àÄ A, finite A ‚Üí (‚àÄa ‚àà A, finite a) ‚Üí finite ‚ãÉA. Proof with eauto. intros A [n [Hn HA]]. generalize dependent A. œâ_induction n; intros A HA Hfa. - apply eqnum_empty in HA. subst A. rewrite union_empty... - apply set_eqnum_suc_nonempty in HA as Hi... destruct Hi as [a Ha]. apply split_one_element in Ha as HeqA. rewrite HeqA in HA. rewrite bunion_comm in HeqA. rewrite HeqA, ex2_21. apply ex6_8. + rewrite union_single. apply Hfa... + apply IH. apply finite_set_remove_one_member... intros b Hb. apply Hfa. apply SepE1 in Hb... Qed. Definition Permutation : set ‚Üí set := Œª A, {f ‚àä A ‚ü∂ A | f: A ‚ü∫ A}.Definition CardFactorial : set ‚Üí set := Œª ùú , |Permutation ùú |. Notation "ùú !" := (CardFactorial ùú ) (at level 60) : Card_scope.Lemma permutation_iff : ‚àÄ f A, f: A ‚ü∫ A ‚Üî f ‚àà Permutation A. Proof with auto. split; intros H. - apply SepI... apply arrowI. apply bijection_is_func... - apply SepE2 in H... Qed. Theorem cardFactorial_well_defined : ‚àÄ A B, |A| = |B| ‚Üí A! = B!. 
Require Import Relations. Section leibniz. Variable A : Type. Definition leibniz (a b:A) : Prop := forall P:A -> Prop, P a -> P b. Theorem leibniz_sym : symmetric A leibniz. Proof. intros a b H Q; apply H; trivial. Qed. Theorem leibniz_refl : reflexive A leibniz. Proof. intros a P; trivial. Qed. Theorem leibniz_trans : transitive A leibniz. Proof. intros x y z Hxy Hyz; unfold leibniz; intros P H. apply Hyz; apply Hxy; assumption. Qed. #[local] Hint Resolve leibniz_trans leibniz_sym leibniz_refl : core. Theorem leibniz_equiv : equiv A leibniz. 
:= vm; lfn := fn; lpc := pc.+1 |}. move => Hgfd Hwfb Hallg Hfindinstr HSpc. rewrite (@nth_label_find_label l' (lfd_body fd) pc.+1) //=. rewrite /find_instr /s2 /= Hgfd; case: (is_label_nth_onth HSpc) => ii' ->. by rewrite /eval_instr /=; right; eexists; eauto. Qed. Lemma lsem_tunnel_lprog_pc p s1 s2 fn pc : well_formed_lprog p -> lsem p s1 s2 -> exists s3, lsem p s2 s3 /\ lsem (tunnel_lprog_pc p fn pc) s1 s3. Proof. move => Hwf Hlsem12; pattern s1, s2; set Q:= (fun _ => _); move: Hlsem12; apply: lsem_ind_r. + by rewrite /Q => s; exists s; split; apply Relation_Operators.rt_refl. rewrite /Q => {Q} s3 s4 s5 Hlsem34 Hlsem145 [s6] [Hlsem46 Htlsem36]. case: (lsem_disj1 Hlsem145 Hlsem46) => [?| Hlsem56]; last by exists s6; split. subst s6; case: (lsem1_tunnel_lprog_pc fn pc Hwf Hlsem145). + move => Htlsem45; exists s5; split; first by apply Relation_Operators.rt_refl. by apply (lsem_trans Htlsem36); apply Relation_Operators.rt_step. move => [s7] [Hlsem157 Htlsem147]; exists s7; split; first by apply Relation_Operators.rt_step. by apply (lsem_trans Htlsem36); apply Relation_Operators.rt_step. Qed. Lemma lsem_tunnel_lprog_lsem p : well_formed_lprog p -> (forall s1 s2, lsem (tunnel_lprog p) s1 s2 -> lsem p s1 s2) /\ forall s1 s2, lsem p s1 s2 -> exists s3, lsem p s2 s3 /\ lsem (tunnel_lprog p) s1 s3. Proof. move => Hwf; pattern p, (tunnel_lprog p); set P:= (fun _ => _). move: Hwf; apply tunnel_lprog_ind => //; rewrite /P => {p P}. + move => p; split => //; move => s1 s2 Hlsem12. by exists s2; split => //; apply Relation_Operators.rt_refl. + move => p2 p1 p3 [HP12 HQ12] [HP23 HQ23]; split. - by move => s1 s2 Hlsem312; apply/HP12/HP23. move => s1 s2 Hlsem112. case: (HQ12 _ _ Hlsem112) => s3 [Hlsem123 Hlsem213]. case: (HQ23 _ _ Hlsem213) => s4 [Hlsem234 Hlsem314]. exists s4; split => //; apply (lsem_trans Hlsem123). by apply HP12. move => p fn pc Hwf; split => s1 s2; first by apply tunnel_lprog_pc_lsem. by apply lsem_tunnel_lprog_pc. Qed. Lemma tunnel_lprog_lsem p s1 s2: well_formed_lprog p -> lsem (tunnel_lprog p) s1 s2 -> lsem p s1 s2. Proof. by move => Hwf; move : (lsem_tunnel_lprog_lsem Hwf) => [HP _]; apply HP. Qed. Lemma lsem_tunnel_lprog p s1 s2 : well_formed_lprog p -> lsem p s1 s2 -> exists s3, lsem p s2 s3 /\ lsem (tunnel_lprog p) s1 s3. Proof. by move => Hwf; move : (lsem_tunnel_lprog_lsem Hwf) => [_ HQ]; apply HQ. Qed. Theorem lsem_tunnel_program p tp s1 s2 : tunnel_program p = ok tp -> lsem p s1 s2 -> exists s3, lsem p s2 s3 /\ lsem tp s1 s3. 
Require Export Fcomp. Section operations. Variable radix : Z.Let FtoRradix := FtoR radix. Local Coercion FtoRradix : float >-> R.Hypothesis radixNotZero : (0 < radix)%Z. Definition Fplus (x y : float) := Float (Fnum x * Zpower_nat radix (Zabs_nat (Fexp x - Zmin (Fexp x) (Fexp y))) + Fnum y * Zpower_nat radix (Zabs_nat (Fexp y - Zmin (Fexp x) (Fexp y)))) (Zmin (Fexp x) (Fexp y)). Theorem Fplus_correct : forall x y : float, Fplus x y = (x + y)%R :>R. intros x y; unfold Fplus, Fshift, FtoRradix, FtoR in |- *; simpl in |- *. rewrite plus_IZR. rewrite Rmult_comm; rewrite Rmult_plus_distr_l; auto. repeat rewrite Rmult_IZR. repeat rewrite (Rmult_comm (Fnum x)); repeat rewrite (Rmult_comm (Fnum y)). repeat rewrite Zpower_nat_Z_powerRZ; auto. repeat rewrite <- Rmult_assoc. repeat rewrite <- powerRZ_add; auto with real zarith arith. repeat rewrite inj_abs; auto with real zarith. repeat rewrite Zplus_minus; auto. Qed. Definition Fopp (x : float) := Float (- Fnum x) (Fexp x). Theorem Fopp_correct : forall x : float, Fopp x = (- x)%R :>R. unfold FtoRradix, FtoR, Fopp in |- *; simpl in |- *. intros x. rewrite Ropp_Ropp_IZR; auto with real. Qed. Theorem Fopp_Fopp : forall p : float, Fopp (Fopp p) = p. intros p; case p; unfold Fopp in |- *; simpl in |- *; auto. intros; rewrite Zopp_involutive; auto. Qed. Theorem Fzero_opp : forall f : float, ~ is_Fzero f -> ~ is_Fzero (Fopp f). intros f; case f; intros n e; case n; unfold is_Fzero in |- *; simpl in |- *; auto with zarith; intros; red in |- *; intros; discriminate. Qed. Theorem Fdigit_opp : forall x : float, Fdigit radix (Fopp x) = Fdigit radix x. intros x; unfold Fopp, Fdigit in |- *; simpl in |- *. rewrite <- (digit_abs radix (- Fnum x)). rewrite <- (digit_abs radix (Fnum x)). case (Fnum x); simpl in |- *; auto. Qed. Definition Fabs (x : float) := Float (Zabs (Fnum x)) (Fexp x). Theorem Fabs_correct1 : forall x : float, (0 <= FtoR radix x)%R -> Fabs x = x :>R. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.SpecLemmas. Require Import VerdiRaft.RefinementSpecLemmas.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Import VerdiRaft.VotesLeCurrentTermInterface.Set Bullet Behavior "Strict Subproofs".Section VotesLeCurrentTerm. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Ltac start_proof := cbn [nwState]; intros; subst; repeat find_higher_order_rewrite; update_destruct; rewrite_update; cbn [fst snd] in *; eauto. Lemma votes_le_current_term_client_request : refined_raft_net_invariant_client_request votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_client_request, votes_le_currentTerm. start_proof. erewrite handleClientRequest_currentTerm by eauto. rewrite @votes_update_elections_data_client_request in *. eauto. Qed. Lemma votes_le_current_term_timeout : refined_raft_net_invariant_timeout votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_timeout, votes_le_currentTerm. start_proof. find_copy_eapply_lem_hyp votes_update_elections_data_timeout; eauto. break_or_hyp; auto with *. find_apply_lem_hyp handleTimeout_currentTerm. find_apply_hyp_hyp. eauto using le_trans. Qed. Lemma votes_le_current_term_append_entries : refined_raft_net_invariant_append_entries votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_append_entries, votes_le_currentTerm. start_proof. rewrite @votes_same_append_entries in *. find_apply_lem_hyp handleAppendEntries_currentTerm. find_apply_hyp_hyp. eauto using le_trans. Qed. Lemma votes_le_current_term_append_entries_reply : refined_raft_net_invariant_append_entries_reply votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_append_entries_reply, votes_le_currentTerm. start_proof. find_apply_lem_hyp handleAppendEntriesReply_currentTerm. find_apply_hyp_hyp. eauto using le_trans. Qed. Lemma votes_le_current_term_request_vote : refined_raft_net_invariant_request_vote votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_request_vote, votes_le_currentTerm. start_proof. find_eapply_lem_hyp votes_update_elections_data_request_vote; eauto. intuition. find_apply_hyp_hyp. eauto using le_trans, handleRequestVote_currentTerm. Qed. Lemma votes_le_current_term_request_vote_reply : refined_raft_net_invariant_request_vote_reply votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_request_vote_reply, votes_le_currentTerm. start_proof. find_eapply_lem_hyp votes_update_elections_data_request_vote_reply; eauto. eapply le_trans; [|eapply handleRequestVoteReply_currentTerm'; eauto]; eauto. Qed. Lemma votes_le_current_term_do_leader : refined_raft_net_invariant_do_leader votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_do_leader, votes_le_currentTerm. start_proof. assert (gd = (fst (nwState net h)) /\ d = snd (nwState net h)) by (repeat find_rewrite; auto). break_and. subst. erewrite doLeader_currentTerm by eauto. eauto. Qed. Lemma votes_le_current_term_do_generic_server : refined_raft_net_invariant_do_generic_server votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_do_generic_server, votes_le_currentTerm. start_proof. assert (gd = (fst (nwState net h)) /\ d = snd (nwState net h)) by (repeat find_rewrite; auto). break_and. subst. erewrite doGenericServer_currentTerm by eauto. eauto. Qed. Lemma votes_le_current_term_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_state_same_packet_subset, votes_le_currentTerm. intros. repeat find_reverse_higher_order_rewrite. eauto. Qed. Lemma votes_le_current_term_reboot : refined_raft_net_invariant_reboot votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_reboot, votes_le_currentTerm. start_proof. unfold reboot. simpl. assert (gd = (fst (nwState net h)) /\ d = snd (nwState net h)) by (repeat find_rewrite; auto). break_and. subst. eauto. Qed. Theorem votes_le_current_term_init : refined_raft_net_invariant_init votes_le_currentTerm. Proof using. unfold refined_raft_net_invariant_init, votes_le_currentTerm. simpl. intuition. Qed. Theorem votes_le_current_term_invariant : forall net, refined_raft_intermediate_reachable net -> votes_le_currentTerm net. 
Require Import Hask.Prelude. Require Import Hask.Control.Monad. Require Import P.Pipes.Generalizable All Variables.Definition SProxy (a' a b' b : Type) (m : Type -> Type) (r : Type) : Type := forall s : Type, (a' -> (a -> s) -> s) -> (b -> (b' -> s) -> s) -> (forall x, (x -> s) -> m x -> s) -> (r -> s) -> s.Definition toProxy `(s : SProxy a' a b' b m r) : Proxy a' a b' b m r := s _ Request Respond (fun _ => M) Pure.Definition fromProxy `(p : Proxy a' a b' b m r) : SProxy a' a b' b m r := fun _ req res mon pur => let fix go p := match p with | Request a' fa => req a' (go \o fa) | Respond b fb' => res b (go \o fb') | M _ g h => mon _ (go \o g) h | Pure x => pur x end in go p.Module SProxyLaws.Include PipesLaws.Require Import FunctionalExtensionality.Lemma SProxy_to_from : forall `(x : Proxy a' a b' b m r), toProxy (fromProxy x) = x. Proof. move=> a' a b' b m r. by reduce_proxy IHx (rewrite /toProxy; first [ congr (Request _) | congr (Respond _) | congr (M _) | congr (Pure _) ]). Qed.Axiom f_const : forall `(f : a -> (b -> s) -> s) (x : a) (y : s), f x (const y) = y.Definition const_f `(f : (b -> s) -> a -> s) (x : a) (y : s) : f (const y) x = y := f_const (flip f) x y. Axiom SProxy_parametricity : forall `(sp : SProxy a' a b' b m r) (s : Type) (req : a' -> (a -> s) -> s) (res : b -> (b' -> s) -> s) (mon : forall x, (x -> s) -> m x -> s) (pur : r -> s) (z : r), pur z = sp s req res mon pur.Lemma SProxy_from_to : forall `(x : SProxy a' a b' b m r), fromProxy (toProxy x) = x. Proof. move=> ? ? ? ? ? ? x. extensionality s. extensionality req. extensionality res. extensionality mon. extensionality pur. move: (toProxy x). reduce_proxy IHx (rewrite /fromProxy /funcomp /=; try (move/functional_extensionality in IHx; rewrite IHx ?f_const ?const_f)). exact: SProxy_parametricity. Qed. Theorem sproxy_ind : forall (a' a b' b : Type) (m : Type -> Type) (r : Type) (P : SProxy a' a b' b m r -> Prop), (forall (x : a') (f : a -> SProxy a' a b' b m r), P (fun s req res mon pur => req x (fun a => f a s req res mon pur))) -> (forall (x : b) (f : b' -> SProxy a' a b' b m r), P (fun s req res mon pur => res x (fun b' => f b' s req res mon pur))) -> (forall t (f : t -> SProxy a' a b' b m r) (x : m t), P (fun s req res mon pur => mon _ (fun x => f x s req res mon pur) x)) -> (forall (x : r), P (fun s _ _ _ pur => pur x)) -> forall p : SProxy a' a b' b m r, P p. 
Require Grammar. Require Automaton. Require Interpreter_safe. Require Interpreter_correct. Require Interpreter_complete. Require Import Syntax.Module Make(Export Aut:Automaton.T). Export Aut.Gram. Export Aut.GramDefs.Module Import Inter := Interpreter.Make Aut. Module Safe := Interpreter_safe.Make Aut Inter. Module Correct := Interpreter_correct.Make Aut Inter. Module Complete := Interpreter_complete.Make Aut Inter.Definition complete_validator:unit->bool := Complete.Valid.is_complete. Definition safe_validator:unit->bool := Safe.Valid.is_safe. Definition parse (safe:safe_validator ()=true) init n_steps buffer : parse_result init:= Safe.parse_with_safe (Safe.Valid.is_safe_correct safe) init buffer n_steps. Theorem parse_correct (safe:safe_validator ()= true) init n_steps buffer: match parse safe init n_steps buffer with | Parsed_pr sem buffer_new => exists word, buffer = word ++ buffer_new /\ inhabited (parse_tree (NT (start_nt init)) word sem) | _ => True end. Proof. unfold parse, Safe.parse_with_safe. pose proof (Correct.parse_correct init buffer n_steps). generalize (Safe.parse_no_err (Safe.Valid.is_safe_correct safe) init buffer n_steps). destruct (Inter.parse init buffer n_steps); intros. now destruct (n (eq_refl _)). now destruct p; trivial. Qed. Theorem parse_complete (safe:safe_validator () = true) init n_steps word buffer_end sem: complete_validator () = true -> forall tree:parse_tree (NT (start_nt init)) word sem, match parse safe init n_steps (word ++ buffer_end) with | Fail_pr => False | Parsed_pr sem_res buffer_end_res => sem_res = sem /\ buffer_end_res = buffer_end /\ pt_size tree <= n_steps | Timeout_pr => n_steps < pt_size tree end. 
using. intros t1 t2 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem distinct_leaves_r : forall t1 t2 : btree, distinct_leaves (node t1 t2) -> distinct_leaves t2. Proof using. intros t1 t2 H; red in |- *. intros a t0 t3 H0 H1 H2. apply (H a t0 t3); auto. Qed. Theorem all_leaves_unique : forall t, ulist (all_leaves t) -> distinct_leaves t. Proof using. intros t; elim t; simpl in |- *; auto. intros b H b0 H0 H1; red in |- *. intros t0 t1 t2 H2; inversion H2. intros H4 H7; case (inb_ex t0); intros a HH. apply ulist_app_inv with (a := a) (1 := H1); auto; apply all_leaves_in; apply inb_trans with (1 := HH); auto. apply H; auto; try apply ulist_app_inv_l with (1 := H1). apply H0; auto; try apply ulist_app_inv_r with (1 := H1). Qed. Theorem all_leaves_ulist : forall t, distinct_leaves t -> ulist (all_leaves t). Proof using. intros t; elim t; simpl in |- *; auto. intros b H b0 H0 H1; apply ulist_app; auto. apply H; apply distinct_leaves_l with (1 := H1). apply H0; apply distinct_leaves_r with (1 := H1). intros a H2 H3; case (H1 (leaf a) b b0); auto. apply all_leaves_inb with (1 := H2). apply all_leaves_inb with (1 := H3). Qed. Definition distinct_leaves_dec : forall a, {distinct_leaves a} + {~ distinct_leaves a}. intros a; case (ulist_dec A eqA_dec (all_leaves a)); intros H. left; apply all_leaves_unique; auto. right; Contradict H; apply all_leaves_ulist; auto. Defined. Fixpoint compute_code (a : btree) : list (A * list bool) := match a with | leaf b => (b, nil) :: nil | node l1 l2 => map (fun v : A * list bool => match v with | (a1, b1) => (a1, false :: b1) end) (compute_code l1) ++ map (fun v : A * list bool => match v with | (a1, b1) => (a1, true :: b1) end) (compute_code l2) end. Theorem length_compute_lt_O : forall t, 0 < length (compute_code t). Proof using. intros t; elim t; simpl in |- *; auto with arith. intros b H b0 H0; rewrite length_app. replace 0 with (0 + 0); auto with arith. apply plus_lt_compat. generalize H; elim (compute_code b); simpl in |- *; auto with arith. generalize H0; elim (compute_code b0); simpl in |- *; auto with arith. Qed. Hint Resolve length_compute_lt_O : core. Theorem inCompute_inb : forall (t : btree) (a : A) (l : list bool), In (a, l) (compute_code t) -> inb (leaf a) t. 
Require Import Bedrock.Platform.tests.Thread0 Bedrock.Platform.tests.Connect Bedrock.Platform.Bootstrap. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Module M'. Definition globalSched : W := ((heapSize + 50) * 4)%nat. Definition inbuf_size := 40. Theorem inbuf_size_lower : (inbuf_size >= 2)%nat. unfold inbuf_size; auto. Qed. Theorem inbuf_size_upper : (N_of_nat (inbuf_size * 4) < Npow2 32)%N. reflexivity. Qed. End M'.Import M'.Module E := Connect.Make(M'). Import E.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 1. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 1. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "connect"!"main" @ [E.mainS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREmain[_] globalSched =?> 1 * 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREmain[_] globalSched =?> 1 * mallocHeap 0];; Goto "connect"!"main" end }}. Ltac t := unfold globalSched, localsInvariantMain, M'.globalSched; genesis. Theorem ok0 : moduleOk boot. vcgen; abstract t. Qed. Definition m1 := link Buffers.m boot. Definition m2 := link E.m m1. Definition m := link m2 E.T.T.m. Lemma ok1 : moduleOk m1. link Buffers.ok ok0. Qed. Lemma ok2 : moduleOk m2. link E.ok ok1. Qed. Theorem ok : moduleOk m. 
ex)%Z -> (0 < x * bpow (- fexp ex) < 1)%R. Proof. intros x ex Hx He. split. apply Rmult_lt_0_compat. apply Rlt_le_trans with (2 := proj1 Hx). apply bpow_gt_0. apply bpow_gt_0. apply Rmult_lt_reg_r with (bpow (fexp ex)). apply bpow_gt_0. rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l. rewrite Rmult_1_r, Rmult_1_l. apply Rlt_le_trans with (1 := proj2 Hx). now apply bpow_le. Qed.Theorem scaled_mantissa_small : forall x ex, (Rabs x < bpow ex)%R -> (ex <= fexp ex)%Z -> (Rabs (scaled_mantissa x) < 1)%R. Proof. intros x ex Ex He. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, scaled_mantissa_0, Rabs_R0. now apply (Z2R_lt 0 1). rewrite <- scaled_mantissa_abs. unfold scaled_mantissa. rewrite canonic_exp_abs. unfold canonic_exp. destruct (ln_beta beta x) as (ex', Ex'). simpl. specialize (Ex' Zx). apply (mantissa_small_pos _ _ Ex'). assert (ex' <= fexp ex)%Z. apply Zle_trans with (2 := He). apply bpow_lt_bpow with beta. now apply Rle_lt_trans with (2 := Ex). now rewrite (proj2 (proj2 (valid_exp _) He)). Qed.Theorem abs_scaled_mantissa_lt_bpow : forall x, (Rabs (scaled_mantissa x) < bpow (ln_beta beta x - canonic_exp x))%R. Proof. intros x. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, scaled_mantissa_0, Rabs_R0. apply bpow_gt_0. apply Rlt_le_trans with (1 := bpow_ln_beta_gt beta _). apply bpow_le. unfold scaled_mantissa. rewrite ln_beta_mult_bpow with (1 := Zx). apply Zle_refl. Qed.Theorem ln_beta_generic_gt : forall x, (x <> 0)%R -> generic_format x -> (canonic_exp x < ln_beta beta x)%Z. Proof. intros x Zx Gx. apply Znot_ge_lt. unfold canonic_exp. destruct (ln_beta beta x) as (ex,Ex) ; simpl. specialize (Ex Zx). intros H. apply Zge_le in H. generalize (scaled_mantissa_small x ex (proj2 Ex) H). contradict Zx. rewrite Gx. replace (Ztrunc (scaled_mantissa x)) with Z0. apply F2R_0. cut (Zabs (Ztrunc (scaled_mantissa x)) < 1)%Z. clear ; zify ; omega. apply lt_Z2R. rewrite Z2R_abs. now rewrite <- scaled_mantissa_generic. Qed.Theorem mantissa_DN_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> Zfloor (x * bpow (- fexp ex)) = Z0. Proof. intros x ex Hx He. apply Zfloor_imp. simpl. assert (H := mantissa_small_pos x ex Hx He). split ; try apply Rlt_le ; apply H. Qed.Theorem mantissa_UP_small_pos : forall x ex, (bpow (ex - 1) <= x < bpow ex)%R -> (ex <= fexp ex)%Z -> Zceil (x * bpow (- fexp ex)) = 1%Z. Proof. intros x ex Hx He. apply Zceil_imp. simpl. assert (H := mantissa_small_pos x ex Hx He). split ; try apply Rlt_le ; apply H. Qed. Theorem generic_format_discrete : forall x m, let e := canonic_exp x in (F2R (Float beta m e) < x < F2R (Float beta (m + 1) e))%R -> ~ generic_format x. 
in H. rewrite <- (H a), <- (H b); simpl; auto; left; exists m; auto. Qed. Fact incl_right_cons_incl_or_lhd_or_perm m x l : incl m (x::l) -> incl m l \/ list_has_dup m \/ exists m', m ~p x::m' /\ incl m' l. Proof. intros H. apply incl_cons_rinv in H. destruct H as (m1 & m2 & H1 & H2 & H3). destruct (repeat_choice_two H2) as [ (?&?) | [|] ]; subst m1; simpl in H1; clear H2. + right; left; apply perm_list_has_dup with (1 := Permutation_sym H1), in_list_hd0; left; auto. + left; revert H1 H3; apply perm_incl_left. + firstorder. Qed. Fact incl_left_right_php x l y m : incl (y::m) (x::l) -> list_has_dup (y::m) \/ x = y /\ incl m l \/ In y l /\ incl m l \/ In y l /\ exists m', m ~p x::m' /\ incl m' l. Proof. intros H; apply incl_left_right_cons in H. destruct H as [ (? & ?) | [ (? & ?) | (H1 & H2) ] ]; subst; auto. + left; apply in_list_hd0; auto. + apply incl_right_cons_incl_or_lhd_or_perm in H2; firstorder. left; apply in_list_hd1; auto. Qed. Lemma length_le_and_incl_implies_dup_or_perm l m : length l <= length m -> incl m l -> list_has_dup m \/ m ~p l. Proof. revert m; induction l as [ | x l IHl ]; intros m; simpl; intros H1 H2; auto. + destruct m as [ | y ]; auto; destruct (H2 y); simpl; auto. + destruct incl_right_cons_incl_or_lhd_or_perm with (1 := H2) as [ H3 | [ H3 | (m' & H3 & H4) ] ]; auto. * destruct IHl with (2 := H3) as [ | H ]; try lia; auto. apply Permutation_length in H; lia. * destruct IHl with (2 := H4) as [ H | H ]; try (simpl; lia). - apply Permutation_length in H3; simpl in H3; lia. - left; apply perm_list_has_dup with (1 := Permutation_sym H3). constructor 2; auto. - right; apply perm_trans with (1 := H3); auto. Qed. Theorem finite_php_dup l m : length l < length m -> incl m l -> list_has_dup m. Proof. intros H1 H2. destruct (@length_le_and_incl_implies_dup_or_perm l m) as [ | H3 ]; auto; try lia. apply Permutation_length in H3; lia. Qed. Theorem finite_pigeon_hole l m : length l < length m -> incl m l -> exists x aa bb cc, m = aa++x::bb++x::cc. Proof. intros; apply list_has_dup_eq_duplicates, finite_php_dup with l; auto. Qed. Theorem partition_intersection l m k : length k < length (l++m) -> incl (l++m) k -> list_has_dup l \/ list_has_dup m \/ exists x, In x l /\ In x m. 
= z) wa wb, wa = eq_rect y word wb x (eq_rect_both_helper H1 H2) -> eq_rect x word wa z H1 = eq_rect y word wb z H2. Proof. intros. subst. eq_rect_simpl. reflexivity. Qed. Fact split1_eq_rect_combine_partial_helper : forall a b c d (H : a + c = a + b + d), c = b + d. Proof. intros. omega. Qed. Theorem split1_eq_rect_combine_partial : forall a b c d H (wa : word a) (wc : word c), split1 (a + b) d (eq_rect (a + c) word (combine wa wc) (a + b + d) H) = combine wa (split1 b d (eq_rect _ word wc _ (split1_eq_rect_combine_partial_helper a b c d H))). Proof. intros a b c d H. assert (c = b + d) by omega; subst c. intros. erewrite <- split1_combine; f_equal. eq_rect_simpl. erewrite combine_assoc. rewrite eq_rect_word_match. rewrite combine_split. reflexivity. Qed. Fact combine_eq_rect_combine_helper : forall a b c d, a + b = c -> a + (b + d) = c + d. Proof. intros. omega. Qed. Fact combine_eq_rect_combine : forall a b c d H (wa : word a) (wb : word b) (wa' : word d), combine (eq_rect (a + b) word (combine wa wb) c H) wa' = eq_rect _ word (combine wa (combine wb wa')) _ (combine_eq_rect_combine_helper a b d H). Proof. intros a b c d H. subst c. intros. eq_rect_simpl. erewrite combine_assoc, eq_rect_word_match. reflexivity. Qed. Fact split2_eq_rect_combine : forall a b c H (wa : word a) (wc : word c), split2 a b (eq_rect (a + c) word (combine wa wc) (a + b) H) = eq_rect c word wc b (plus_reg_l c b a H). Proof. intros a b c H. assert (c = b) by omega; subst. intros. eq_rect_simpl. apply split2_combine. Qed. Theorem word_selN_shift_eq_middle : forall idx off n w, @word_selN_shift (idx + 1 + off) n idx w = middle (idx * n) n (off * n) (eq_rec _ word w _ (eq_sym (word_shift_helper3 idx off n))). Proof. intros. eq_rect_simpl. rewrite word_selN_shift_gt_0. generalize_proof. replace ((idx + off) * n) with (idx * n + off * n) by lia. intros HH. unfold wrshift. eq_rect_simpl. erewrite combine_eq_rect2. rewrite eq_rect_combine_dist3 with (w := w); eq_rect_simpl. erewrite combine_eq_rect_combine; eq_rect_simpl. erewrite split2_eq_rect_combine; eq_rect_simpl. repeat erewrite combine_assoc, eq_rect_word_match; eq_rect_simpl. unfold middle. repeat progress (rewrite eq_rect_combine || rewrite split1_combine || rewrite split2_combine). reflexivity. Grab Existential Variables. all : lia. Qed. Theorem word_selN_shift_equiv : forall ft l idx w, idx < l -> @word_selN ft l idx w = @word_selN_shift l (len ft) idx w. 
in *. intros. find_apply_lem_hyp handleRequestVoteReply_log. repeat find_higher_order_rewrite. break_match; try find_rewrite; eauto. - eauto using logs_sorted_nw_packets_unchanged. - eauto using packets_gt_prevIndex_packets_unchanged. - eauto using packets_ge_prevTerm_packets_unchanged. Qed. Lemma doLeader_log : forall h st os st' ps, doLeader st h = (os, st', ps) -> log st' = log st. Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; subst; auto. Qed. Lemma doLeader_messages : forall h st os st' ms m t n pli plt entries c, doLeader st h = (os, st', ms) -> sorted (log st) -> In m ms -> snd m = AppendEntries t n pli plt entries c -> subseq entries (log st) /\ (forall e, In e entries -> eIndex e > pli) /\ (forall e, In e entries -> eTerm e >= plt). Proof using. intros. unfold doLeader in *. repeat break_match; find_inversion; subst; simpl in *; intuition. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. apply subseq_findGtIndex. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. find_apply_lem_hyp findGtIndex_necessary; intuition. - unfold replicaMessage in *. do_in_map. simpl in *. subst. simpl in *. find_inversion. break_match; intuition. find_apply_lem_hyp findGtIndex_necessary; intuition. find_apply_lem_hyp findAtIndex_elim. simpl in *. intuition. repeat find_rewrite. eapply sorted_index_term; eauto. lia. Qed. Theorem logs_sorted_do_leader : raft_net_invariant_do_leader logs_sorted. Proof using. unfold raft_net_invariant_do_leader. unfold logs_sorted. intuition; simpl in *. - unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp doLeader_log. repeat find_higher_order_rewrite. break_match; subst; try find_rewrite; eauto. - unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; intuition; eauto using sorted_subseq. - unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; [idtac|idtac|idtac|eauto]; intuition eauto. - unfold packets_ge_prevTerm. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. do_in_map. subst. simpl in *. find_eapply_lem_hyp doLeader_messages; [idtac|idtac|idtac|eauto]; intuition eauto. Qed. Lemma doGenericServer_packets : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> ps = []. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; subst; auto. Qed. Theorem logs_sorted_do_generic_server : raft_net_invariant_do_generic_server logs_sorted. Proof using. unfold raft_net_invariant_do_generic_server. unfold logs_sorted. intuition; simpl in *. - subst. unfold logs_sorted_host in *. simpl in *. intros. find_apply_lem_hyp doGenericServer_log. repeat find_higher_order_rewrite. break_match; try find_rewrite; eauto. - find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. eauto using logs_sorted_nw_packets_unchanged. - find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. eauto using packets_gt_prevIndex_packets_unchanged. - find_apply_lem_hyp doGenericServer_packets. subst. simpl in *. eauto using packets_ge_prevTerm_packets_unchanged. Qed. Theorem logs_sorted_state_same_packet_subset : raft_net_invariant_state_same_packet_subset logs_sorted. 
real zarith. apply Rlt_not_le; auto with real zarith. Qed. Theorem IZR_inv : forall z1 z2 : Z, IZR z1 = IZR z2 :>R -> z1 = z2. intros z1 z2 H; apply Zle_antisym; apply Zle_Rle; rewrite H; auto with real. Qed. Theorem Zabs_eq_opp : forall x, (x <= 0)%Z -> Zabs x = (- x)%Z. intros x; case x; simpl in |- *; auto. intros p H; Contradict H; auto with zarith. Qed. Theorem Zabs_Zs : forall z : Z, (Zabs (Zsucc z) <= Zsucc (Zabs z))%Z. intros z; case z; auto. simpl in |- *; auto with zarith. repeat rewrite Zabs_eq; auto with zarith. intros p; rewrite Zabs_eq_opp; auto with zarith. 2: unfold Zsucc in |- *; replace 0%Z with (-1 + 1)%Z; auto with zarith. 2: case p; simpl in |- *; intros; red in |- *; simpl in |- *; intros; red in |- *; intros; discriminate. replace (- Zsucc (Zneg p))%Z with (Zpos p - 1)%Z. replace (Zsucc (Zabs (Zneg p))) with (Zpos p + 1)%Z; auto with zarith. unfold Zsucc in |- *; rewrite Zopp_plus_distr. auto with zarith. Qed. Hint Resolve Zabs_Zs: zarith. Theorem Zle_Zpred : forall x y : Z, (x < y)%Z -> (x <= Zpred y)%Z. intros x y H; apply Zlt_succ_le. rewrite <- Zsucc_pred; auto. Qed. Hint Resolve Zle_Zpred: zarith. Theorem Zabs_Zopp : forall z : Z, Zabs (- z) = Zabs z. intros z; case z; simpl in |- *; auto. Qed. Theorem Zle_Zabs : forall z : Z, (z <= Zabs z)%Z. intros z; case z; simpl in |- *; red in |- *; simpl in |- *; auto; try (red in |- *; intros; discriminate; fail). intros p; elim p; simpl in |- *; auto; try (red in |- *; intros; discriminate; fail). Qed. Hint Resolve Zle_Zabs: zarith. Theorem Zlt_mult_simpl_l : forall a b c : Z, (0 < c)%Z -> (c * a < c * b)%Z -> (a < b)%Z. intros a b0 c H H0; apply Zgt_lt. apply Zmult_gt_reg_r with (p := c); try apply Zlt_gt; auto with zarith. repeat rewrite (fun x => Zmult_comm x c); auto with zarith. Qed. Fixpoint pos_eq_bool (a b : positive) {struct b} : bool := match a, b with | xH, xH => true | xI a', xI b' => pos_eq_bool a' b' | xO a', xO b' => pos_eq_bool a' b' | _, _ => false end. Theorem pos_eq_bool_correct : forall p q : positive, match pos_eq_bool p q with | true => p = q | false => p <> q end. 
low_deg (K: nat) (n: node) (adj: nodeset) := S.cardinal adj < K.Lemma low_deg_dec: forall K n adj, {low_deg K n adj}+{~low_deg K n adj}. Proof. intros. unfold low_deg. destruct (lt_dec (S.cardinal adj0) K); auto. Defined. Definition remove_node (n: node) (g: graph) : graph := M.map (S.remove n) (M.remove n g). Lemma select_terminates: forall (K: nat) (g : graph) (n : S.elt), S.choose (subset_nodes (low_deg_dec K) g) = Some n -> M.cardinal (remove_node n g) < M.cardinal g.Proof. intros. unfold remove_node. rewrite cardinal_map. apply Mremove_cardinal_less. apply S.choose_1 in H. apply subset_nodes_sub in H. rewrite <- Sin_domain. auto. Qed.Require Recdef.Function select (K: nat) (g: graph) {measure M.cardinal g}: list node := match S.choose (subset_nodes (low_deg_dec K) g) with | Some n => n :: select K (remove_node n g) | None => nil end. Proof. apply select_terminates. Defined. Definition coloring := M.t node.Definition colors_of (f: coloring) (s: S.t) : S.t := S.fold (fun n s => match M.find n f with Some c => S.add c s | None => s end) s S.empty.Definition color1 (palette: S.t) (g: graph) (n: node) (f: coloring) : coloring := match S.choose (S.diff palette (colors_of f (adj g n))) with | Some c => M.add n c f | None => f end.Definition color (palette: S.t) (g: graph) : coloring := fold_right (color1 palette g) (M.empty _) (select (S.cardinal palette) g).Definition coloring_ok (palette: S.t) (g: graph) (f: coloring) := forall i j, S.In j (adj g i) -> (forall ci, M.find i f = Some ci -> S.In ci palette) /\ (forall ci cj, M.find i f = Some ci -> M.find j f = Some cj -> ci<>cj). Lemma adj_ext: forall g i j, E.eq i j -> S.eq (adj g i) (adj g j).Proof. unfold adj; intros. rewrite (F.find_o _ H). apply S.eq_refl. Qed. Lemma in_colors_of_1: forall i s f c, S.In i s -> M.find i f = Some c -> S.In c (colors_of f s).Proof. intros. unfold colors_of. rewrite S.fold_1. rewrite fold_right_rev_left. apply S.elements_1 in H. apply InA_rev in H; auto. change E.t with S.elt in H. remember (rev (S.elements s)) as al; clear s Heqal. revert H; induction al; simpl; intros; auto. inversion H. inversion H; clear H; subst. rewrite (F.find_o _ H2) in H0. change node with S.elt; rewrite H0. apply S.add_1; auto. specialize (IHal H2). change node with S.elt. case_eq (M.find a f); intros. apply S.add_2. auto. auto. Qed. Theorem color_correct: forall palette g, no_selfloop g -> undirected g -> coloring_ok palette g (color palette g).Proof. 
Abelian_Group.op_neg_def sum_abelian_group. Definition sum_neg_inj : is_injective E E {-} := Abelian_Group.op_neg_inj sum_abelian_group. Theorem sum_cancel_neg : forall x : E, - (- x) = x. Proof Abelian_Group.op_cancel_neg sum_abelian_group. Theorem sum_neg_onto : is_onto E E {-}. Proof Abelian_Group.op_neg_onto sum_abelian_group. Theorem sum_neg_bijective : is_bijective E E {-}. Proof Abelian_Group.op_neg_bijective sum_abelian_group. Theorem sum_neg_rev : forall x y : E, - x = y -> - y = x. Proof Abelian_Group.op_neg_rev sum_abelian_group. Theorem sum_neg_distrib_inv_l : forall x y : E, sum_is_inv_l (x + y) (- y + - x). Proof Abelian_Group.op_neg_distrib_inv_l sum_abelian_group. Theorem sum_neg_distrib_inv_r : forall x y : E, sum_is_inv_r (x + y) (- y + - x). Proof Abelian_Group.op_neg_distrib_inv_r sum_abelian_group. Theorem sum_neg_distrib_inv : forall x y : E, sum_is_inv (x + y) (- y + - x). Proof Abelian_Group.op_neg_distrib_inv sum_abelian_group. Theorem sum_neg_distrib : forall x y : E, - (x + y) = - y + - x. Proof Abelian_Group.op_neg_distrib sum_abelian_group. Theorem sum_0_neg : - 0 = 0. Proof proj2 (sum_neg_def 0) || a = 0 @a by <- sum_id_l (- 0). Theorem sum_neg_0 : forall x : E, - x = 0 -> x = 0. Proof fun x H => proj2 (sum_neg_def x) || x + a = 0 @a by <- H || a = 0 @a by <- sum_id_r x. Theorem sum_neg_0_uniq : unique (fun x => - x = 0) 0. Proof conj sum_0_neg (fun x H => eq_sym (sum_neg_0 x H)). Definition prod_is_id_l := Monoid.is_id_l E prod. Definition prod_is_id_r := Monoid.is_id_r E prod. Definition prod_is_id := Monoid.is_id E prod. Definition prod_monoid := Monoid.monoid E 1 {#} prod_is_assoc prod_id_l prod_id_r. Theorem prod_id : prod_is_id 1. Proof Monoid.op_id prod_monoid. Theorem prod_id_l_uniq : forall x : E, (Monoid.is_id_l E prod x) -> x = 1. Proof Monoid.op_id_l_uniq prod_monoid. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E prod x) -> x = 1. Proof Monoid.op_id_r_uniq prod_monoid. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E prod x) -> x = 1. Proof Monoid.op_id_uniq prod_monoid. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. Proof Monoid.op_intro_l prod_monoid. Theorem prod_intro_r : forall x y z : E, x = y -> x # z = y # z. Proof Monoid.op_intro_r prod_monoid. Definition prod_is_inv_l := Monoid.op_is_inv_l prod_monoid. Definition prod_is_inv_r := Monoid.op_is_inv_r prod_monoid. Definition prod_is_inv := Monoid.op_is_inv prod_monoid. Definition prod_has_inv_l := Monoid.has_inv_l prod_monoid. Definition prod_has_inv_r := Monoid.has_inv_r prod_monoid. Definition prod_has_inv := Monoid.has_inv prod_monoid. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. 
Require Import Mem. Require Import Prog. Require Import List. Require Import Array. Require Import Pred. Require Import FunctionalExtensionality. Require Import Word. Require Import WordAuto. Require Import Omega. Require Import Ring. Require Import SepAuto. Require Import ListUtils. Require Import ListPred.Set Implicit Arguments. Definition list2nmem (A: Type) (l: list A) : (@mem nat eq_nat_dec A) := fun a => selN (map (@Some A) l) a None.Notation "[[[ NS ':::' P ]]]" := [[ (P)%pred (list2nmem NS) ]]%pred : pred_scope. Notation "„Äê NS '‚Ä£‚Ä£' P „Äë" := [[ (P)%pred (list2nmem NS) ]]%pred : pred_scope.Theorem list2nmem_oob : forall A (l : list A) i, i >= length l -> (list2nmem l) i = None. Proof. unfold list2nmem; intros. rewrite selN_oob; auto. rewrite map_length; auto. Qed. Theorem list2nmem_inbound: forall A F (l : list A) i x, (F * i |-> x)%pred (list2nmem l) -> i < length l. Proof. intros. destruct (lt_dec i (length l)); auto; exfalso. apply not_lt in n. apply list2nmem_oob in n. apply ptsto_valid' in H. rewrite H in n. inversion n. Qed. Theorem list2nmem_sel: forall A F (l: list A) i x def, (F * i |-> x)%pred (list2nmem l) -> x = selN l i def. Proof. intros. assert (i < length l). eapply list2nmem_inbound; eauto. unfold list2nmem in H. apply ptsto_valid' in H. erewrite selN_map in H by auto. inversion H; eauto. Qed. Lemma listupd_memupd: forall A l i (v : A), i < length l -> list2nmem (updN l i v) = Mem.upd (list2nmem l) i v. Proof. intros. apply functional_extensionality; intro. unfold list2nmem, Mem.upd. autorewrite with core lists. destruct (eq_nat_dec x i). subst; erewrite selN_updN_eq; auto. rewrite map_length; auto. erewrite selN_updN_ne; auto. Qed.Theorem list2nmem_updN: forall A F (l: list A) i x y, (F * i |-> x)%pred (list2nmem l) -> (F * i |-> y)%pred (list2nmem (updN l i y)). Proof. intros. rewrite listupd_memupd; auto. apply sep_star_comm. apply sep_star_comm in H. eapply ptsto_upd; eauto. eapply list2nmem_inbound; eauto. Qed.Lemma list2nmem_updN_selN : forall A F (l : list A) a v1 def, (F * a |-> v1)%pred (list2nmem (updN l a v1)) -> (F * a |-> selN l a def)%pred (list2nmem l). Proof. intros. destruct (lt_dec a (length l)). eapply list2nmem_updN with (y := selN l a def) in H. rewrite updN_twice in H. rewrite updN_selN_eq in H; auto. apply list2nmem_inbound in H. rewrite length_updN in H. congruence. Qed. Theorem listapp_memupd: forall A l (a : A), list2nmem (l ++ a :: nil) = Mem.upd (list2nmem l) (length l) a. 
latest_effective; eauto. pimpl_crash; cancel. cancel. eexists; apply list2nmem_ptsto_cancel_pair. erewrite dset_match_nthd_effective_fst; eauto. eapply diskset_ptsto_bound_latest; eauto. rewrite latest_effective; eauto. step; subst. erewrite fst_pair; eauto. erewrite dset_match_nthd_effective_fst; eauto. eapply diskset_vmap_find_none; eauto. rewrite latest_effective; eauto. pimpl_crash; cancel. eassign (mk_mstate (MSVMap ms_1) (MSTxns ms_1) ms'_1); cancel. all: auto. Qed. Theorem submit_ok: forall xp ents ms, {< F ds, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[ log_valid ents ds!! ]] POST:hm' RET:^(ms', r) ([[ r = false /\ length ents > LogLen xp ]] * << F, rep: xp (Cached ds) ms' hm' >> * [[ ms' = ms ]]) \/ ([[ r = true ]] * << F, rep: xp (Cached (pushd (replay_disk ents (latest ds)) ds)) ms' hm' >>) CRASH:hm' exists ms', << F, rep: xp (Cached ds) ms' hm' >> >} submit xp ents ms. Proof. unfold submit, rep. step. step. or_r; cancel. rewrite nthd_pushd' by omega; eauto. unfold vmap_match in *; simpl. denote! (Map.Equal _ _) as Heq. rewrite Heq; apply MapFacts.Equal_refl. rewrite effective_pushd_comm. erewrite <- latest_effective. apply dset_match_ext; auto. rewrite latest_effective; auto. step. Unshelve. all: try exact vmap0; eauto. Qed. Local Hint Resolve vmap_match_nil dset_match_nil. Opaque MLog.flush. Theorem flushall_nomerge_ok: forall xp ms, {< F ds, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (ds!!, nil)) ms' hm' >> * [[ MSTxns (fst ms') = nil /\ MSVMap (fst ms') = vmap0 ]] XCRASH:hm' << F, would_recover_any: xp ds hm' -- >> >} flushall_nomerge xp ms. Proof. unfold flushall_nomerge, would_recover_any, rep. prestep. cancel. rewrite nthd_effective, Nat.add_0_r. apply sep_star_comm. - safestep. eapply dset_match_log_valid_selN; eauto. safestep. erewrite dset_match_nthd_S by eauto; cancel. eexists. exfalso; eapply dset_match_ent_length_exfalso; eauto. subst; repeat xcrash_rewrite. xform_norm; cancel. xform_normr. safecancel. eassign (mk_mstate vmap0 (MSTxns ms_1) vmap0); simpl. rewrite selR_inb by eauto; cancel. all: simpl; auto; omega. - safestep. rewrite nthd_oob, latest_effective, nthd_0. cancel. erewrite <- dset_match_length; eauto. apply dset_match_nil. - cancel. xcrash_rewrite. instantiate (1 := (exists raw cs, BUFCACHE.rep cs raw * [[ (F * exists ms n, [[ dset_match xp (effective ds (length (MSTxns ms))) (MSTxns ms) /\ n <= length (MSTxns ms) ]] * MLog.would_recover_either xp (nthd n (effective ds (length (MSTxns ms)))) (selR (MSTxns ms) n nil) hm)%pred raw ]])%pred ). xform_norm; cancel. xform_normr; safecancel. apply MLog.would_recover_either_hashmap_subset. all: eauto. Unshelve. all: constructor. Qed. Hint Extern 1 ({{_}} Bind (flushall_nomerge _ _) _) => apply flushall_nomerge_ok : prog. Opaque flushall_nomerge. Theorem flushall_ok: forall xp ms, {< F ds, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (ds!!, nil)) ms' hm' >> * [[ MSTxns (fst ms') = nil /\ MSVMap (fst ms') = vmap0 ]] XCRASH:hm' << F, would_recover_any: xp ds hm' -- >> >} flushall xp ms. 
Require Import Undecidability.Synthetic.Undecidability.Require Import Undecidability.SystemF.SysF. From Undecidability.SystemF.Reductions Require H10C_SAT_to_SysF_INH LU2SemiU_to_SysF_TYP SysF_TYP_to_SysF_TC.Require Import Undecidability.DiophantineConstraints.H10C_undec Undecidability.SemiUnification.SemiU_undec. Theorem SysF_INH_undec : undecidable SysF_INH. 
From mathcomp Require Import all_ssreflect zify.From Coq Require Import Logic.Eqdep_dec. From hydras Require Import DecPreOrder ON_Generic. From hydras Require Import T1 E0 Hessenberg Hydra_Theorems Hydra_Definitions Hydra_Termination Battle_length Hydra_Examples Epsilon0_Needed_Free Epsilon0_Needed_Std. From gaia Require Export ssete9. Require Import T1Bridge GHessenberg GL_alpha GPrelude. Set Implicit Arguments. Unset Strict Implicit. Unset Printing Implicit Defensive.Import Hydra_Definitions. Fixpoint m (h:Hydra) : T1 := if h is node (hcons _ _ as hs) then ms hs else zero with ms (s : Hydrae) : T1 := if s is hcons h s' then phi0 (m h) o+ ms s' else zero.Compute T1pp (m Examples.Hy). Lemma m_ref h : g2h (m h) = (Hydra_Termination.m h). Proof. induction h using Hydra_rect2 with (P0 := (fun hs => g2h (ms hs) = Hydra_Termination.ms hs)) => //. - case: h IHh => [/= // |] => h hs H => //. - rewrite /ms -!/m -!/ms /oplus g2h_phi0 IHh IHh0 g2h_h2gK => //. Qed.Lemma m_nf h : T1nf (m h). Proof. rewrite -hnf_g2h m_ref; apply Hydra_Termination.m_nf. Qed. Lemma mVariant: Hvariant nf_Wf free m .Proof. split; move => i h h' Hnot_head step; rewrite /restrict; split. 1,3 : apply m_nf. rewrite -(h2g_g2hK (m h)) -(h2g_g2hK (m h')). apply lt_ref; rewrite !m_ref; by apply round_decr. Qed. Theorem every_battle_terminates : Termination.Proof. 
auto with zarith. apply maxDivLt; auto. unfold Fdigit in |- *; apply NotDividesDigit; auto. Qed. Theorem Fexp_le_LSB : forall x : float, (Fexp x <= LSB x)%Z. intros x; unfold LSB in |- *. auto with zarith. Qed. Theorem Ulp_Le_LSigB : forall x : float, (Float 1%nat (Fexp x) <= Float 1%nat (LSB x))%R. intros x; apply (oneExp_le radix); auto. apply Fexp_le_LSB; auto. Qed. Theorem Fexp_le_MSB : forall x : float, ~ is_Fzero x -> (Fexp x <= MSB x)%Z. intros x H'; unfold MSB in |- *. cut (Fdigit radix x <> 0%Z :>Z); unfold Zpred in |- *; auto with zarith. unfold Fdigit in |- *. red in |- *; intros H'0; absurd (digit radix (Fnum x) = 0); auto with zarith. apply not_eq_sym; apply lt_O_neq; apply digitNotZero; auto. Qed. Theorem MSB_le_abs : forall x : float, ~ is_Fzero x -> (Float 1%nat (MSB x) <= Fabs x)%R. intros x H'; unfold MSB, FtoRradix, FtoR in |- *; simpl in |- *. replace (Zpred (Fdigit radix x + Fexp x)) with (Zpred (Fdigit radix x) + Fexp x)%Z; [ idtac | unfold Zpred in |- *; ring ]. rewrite powerRZ_add; auto with real zarith. rewrite Rmult_1_l. repeat rewrite (fun r : R => Rmult_comm r (powerRZ radix (Fexp x))). apply Rmult_le_compat_l; auto with real zarith. rewrite <- inj_pred; auto with real zarith. rewrite <- Zpower_nat_Z_powerRZ; auto. apply Rle_IZR; auto. unfold Fdigit in |- *; auto with arith. apply digitLess; auto. unfold Fdigit in |- *. apply not_eq_sym; apply lt_O_neq; apply digitNotZero; auto. Qed. Theorem abs_lt_MSB : forall x : float, (Fabs x < Float 1%nat (Zsucc (MSB x)))%R. intros x. rewrite (MSB_abs x). unfold MSB, FtoRradix, FtoR in |- *. rewrite <- Zsucc_pred; simpl in |- *. rewrite powerRZ_add; auto with real zarith. rewrite Rmult_1_l. repeat rewrite (fun r : R => Rmult_comm r (powerRZ radix (Fexp x))). apply Rmult_lt_compat_l; auto with real zarith. rewrite <- Zpower_nat_Z_powerRZ; auto with arith. apply Rlt_IZR. unfold Fdigit in |- *; auto with arith. unfold Fabs in |- *; simpl in |- *. pattern (Zabs (Fnum x)) at 1 in |- *; rewrite <- (Zabs_eq (Zabs (Fnum x))); auto with zarith. Qed. Theorem LSB_le_abs : forall x : float, ~ is_Fzero x -> (Float 1%nat (LSB x) <= Fabs x)%R. intros x H'; apply Rle_trans with (FtoRradix (Float 1%nat (MSB x))). apply (oneExp_le radix); auto. apply LSB_le_MSB; auto. apply MSB_le_abs; auto. Qed. Theorem MSB_monotoneAux : forall x y : float, (Fabs x <= Fabs y)%R -> Fexp x = Fexp y -> (MSB x <= MSB y)%Z. 
a' return ( paths ( f ( g a' ) ) a' ) with tpair _ ( tpair _ X Y ) w => ( maponpaths ( s1 X Y ) ( weqpathsweq0 X Y w ) ) end ) . set ( h := fun a1 : Z1 => pr1 ( pr1 a1 ) ) . assert ( egf0 : forall a1 : Z1 , paths ( pr1 ( g ( f a1 ) ) ) ( pr1 a1 ) ). intro. apply idpath. assert ( egf1 : forall a1 a1' : Z1 , paths ( pr1 a1' ) ( pr1 a1 ) -> paths a1' a1 ). intros. set ( X' := maponpaths ( @pr1 _ _ ) X ). assert ( is : isweq h ). apply isweqpr1pr1 . apply ( invmaponpathsweq ( weqpair h is ) _ _ X' ). set ( egf := fun a1 => ( egf1 _ _ ( egf0 a1 ) ) ). set ( is2 := gradth _ _ egf efg ). apply ( isweqtotaltofib P1 P2 ( fun XY : dirprod UU UU => match XY with tpair _ X Y => @eqweqmap X Y end ) is2 ( dirprodpair T1 T2 ) ). Defined. Lemma isweqtransportf10 { X : UU } ( P : X -> UU ) { x x' : X } ( e : paths x x' ) : isweq ( transportf P e ). Proof. intros. destruct e. apply idisweq. Defined.Lemma isweqtransportb10 { X : UU } ( P : X -> UU ) { x x' : X } ( e : paths x x' ) : isweq ( transportb P e ). Proof. intros. apply ( isweqtransportf10 _ ( pathsinv0 e ) ). Defined. Lemma l1 { X0 X0' : UU } ( ee : paths X0 X0' ) ( P : UU -> UU ) ( pp' : P X0' ) ( R : forall X X' : UU , forall w : weq X X' , P X' -> P X ) ( r : forall X : UU , forall p : P X , paths ( R X X ( idweq X ) p ) p ) : paths ( R X0 X0' ( eqweqmap ee ) pp' ) ( transportb P ee pp' ). Proof. intro. intro. intro. intro. intro. destruct ee. simpl. intro. intro. apply r. Defined. Theorem weqtransportb ( P : UU -> UU ) ( R : forall ( X X' : UU ) ( w : weq X X' ) , P X' -> P X ) ( r : forall X : UU , forall p : P X , paths ( R X X ( idweq X ) p ) p ) : forall ( X X' : UU ) ( w : weq X X' ) ( p' : P X' ) , paths ( R X X' w p' ) ( transportb P ( weqtopaths w ) p' ). 
p). Definition Fshift (n : nat) (x : float) := Float (Fnum x * Zpower_nat radix n) (Fexp x - n). Theorem sameExpEq : forall p q : float, p = q :>R -> Fexp p = Fexp q -> p = q. intros p q; case p; case q; unfold FtoR in |- *; simpl in |- *. intros Fnum1 Fexp1 Fnum2 Fexp2 H' H'0; rewrite H'0; rewrite H'0 in H'. cut (Fnum1 = Fnum2). intros H'1; rewrite <- H'1; auto. apply eq_IZR; auto. apply Rmult_eq_reg_l with (r := powerRZ radix Fexp1); repeat rewrite (Rmult_comm (powerRZ radix Fexp1)); auto. apply Rlt_dichotomy_converse; right; auto with real. red in |- *; auto with real. Qed. Theorem FshiftFdigit : forall (n : nat) (x : float), ~ is_Fzero x -> Fdigit (Fshift n x) = Fdigit x + n. intros n x; case x; unfold Fshift, Fdigit, is_Fzero in |- *; simpl in |- *. intros p1 p2 H; apply digitAdd; auto. Qed. Theorem FshiftCorrect : forall (n : nat) (x : float), Fshift n x = x :>R. intros n x; unfold FtoR in |- *; simpl in |- *. rewrite Rmult_IZR. rewrite Zpower_nat_Z_powerRZ; auto. repeat rewrite Rmult_assoc. rewrite <- powerRZ_add; auto with real zarith. rewrite Zplus_minus; auto. Qed. Theorem FshiftCorrectInv : forall x y : float, x = y :>R -> (Fexp x <= Fexp y)%Z -> Fshift (Zabs_nat (Fexp y - Fexp x)) y = x. intros x y H' H'0; try apply sameExpEq; auto. apply trans_eq with (y := FtoR y); auto. apply FshiftCorrect. generalize H' H'0; case x; case y; simpl in |- *; clear H' H'0 x y. intros Fnum1 Fexp1 Fnum2 Fexp2 H' H'0; rewrite inj_abs; auto with zarith. Qed. Theorem FshiftO : forall x : float, Fshift 0 x = x. intros x; unfold Fshift in |- *; apply floatEq; simpl in |- *. replace (Zpower_nat radix 0) with 1%Z; auto with zarith. simpl in |- *; auto with zarith. Qed. Theorem FshiftCorrectSym : forall x y : float, x = y :>R -> exists n : nat, (exists m : nat, Fshift n x = Fshift m y). intros x y H'. case (Z_le_gt_dec (Fexp x) (Fexp y)); intros H'1. exists 0; exists (Zabs_nat (Fexp y - Fexp x)). rewrite FshiftO. apply sym_equal. apply FshiftCorrectInv; auto. exists (Zabs_nat (Fexp x - Fexp y)); exists 0. rewrite FshiftO. apply FshiftCorrectInv; auto with zarith. Qed. Theorem FshiftAdd : forall (n m : nat) (p : float), Fshift (n + m) p = Fshift n (Fshift m p). 
sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Ring.sum_id_uniq ring. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Ring.sum_inv_l_r_eq ring. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Ring.sum_inv_sym ring. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Ring.sum_inv_uniq ring. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Ring.sum_inv_ex ring. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. Proof Ring.sum_inv_uniq_ex ring. Theorem sum_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Ring.sum_intro_l ring. Theorem sum_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Ring.sum_intro_r ring. Theorem sum_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Ring.sum_cancel_l ring. Theorem sum_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Ring.sum_cancel_r ring. Theorem sum_inv_l_uniq : forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y. Proof Ring.sum_inv_l_uniq ring. Theorem sum_inv_r_uniq : forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Ring.sum_inv_r_uniq ring. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Ring.sum_0_inv_l ring. Theorem sum_0_inv_r : sum_is_inv_r 0 0. Proof Ring.sum_0_inv_r ring. Theorem sum_0_inv : sum_is_inv 0 0. Proof Ring.sum_0_inv ring. Theorem sum_has_inv_l_0 : sum_has_inv_l 0. Proof Ring.sum_has_inv_l_0 ring. Theorem sum_has_inv_r_0 : sum_has_inv_r 0. Proof Ring.sum_has_inv_r_0 ring. Theorem sum_has_inv_0 : sum_has_inv 0. Proof Ring.sum_has_inv_0 ring. Theorem sum_inv_0_eq_0 : forall x : E, sum_is_inv x 0 -> x = 0. Proof Ring.sum_inv_0_eq_0 ring. Theorem sum_inv_0_uniq : unique (fun x => sum_is_inv x 0) 0. Proof Ring.sum_inv_0_uniq ring. Definition sum_neg_strong : forall x : E, { y | sum_is_inv x y } := Ring.sum_neg_strong ring. Definition sum_neg : E -> E := Ring.sum_neg ring.Notation "{-}" := (sum_neg) : commutative_ring_scope.Notation "- x" := (sum_neg x) : commutative_ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Ring.sum_neg_def ring. Theorem sum_neg_inj : is_injective E E sum_neg. Proof Ring.sum_neg_inj ring. Theorem sum_cancel_neg : forall x : E, sum_neg (- x) = x. 
Require Import Coq.Arith.Arith. Require Import Coq.Arith.EqNat. Require Import Coq.omega.Omega. Require Import Coq.Lists.List. Require Import Coq.Logic.FunctionalExtensionality. Import ListNotations. Require Import Maps. Require Import Imp. Definition aequiv (a1 a2 : aexp) : Prop := forall (st:state), aeval st a1 = aeval st a2.Definition bequiv (b1 b2 : bexp) : Prop := forall (st:state), beval st b1 = beval st b2.Definition cequiv (c1 c2 : com) : Prop := forall (st st' : state), (c1 / st \\ st') <-> (c2 / st \\ st').Theorem skip_left: forall c, cequiv (SKIP;; c) c. Proof. intros c st st'. split; intros H. - inversion H. subst. inversion H2. subst. assumption. - apply E_Seq with st. apply E_Skip. assumption. Qed. Theorem skip_right: forall c, cequiv (c ;; SKIP) c. Proof. Admitted. Theorem IFB_true_simple: forall c1 c2, cequiv (IFB BTrue THEN c1 ELSE c2 FI) c1. Proof. intros c1 c2. split; intros H. - inversion H; subst. assumption. inversion H5. - apply E_IfTrue. reflexivity. assumption. Qed.Theorem IFB_true: forall b c1 c2, bequiv b BTrue -> cequiv (IFB b THEN c1 ELSE c2 FI) c1. Proof. intros b c1 c2 Hb. split; intros H. - inversion H; subst. + assumption. + unfold bequiv in Hb. simpl in Hb. rewrite Hb in H5. inversion H5. - apply E_IfTrue; try assumption. unfold bequiv in Hb. simpl in Hb. rewrite Hb. reflexivity. Qed. Theorem IFB_false: forall b c1 c2, bequiv b BFalse -> cequiv (IFB b THEN c1 ELSE c2 FI) c2. Proof. Admitted.Theorem swap_if_branches: forall b e1 e2, cequiv (IFB b THEN e1 ELSE e2 FI) (IFB BNot b THEN e2 ELSE e1 FI). Proof. Admitted. Theorem WHILE_false : forall b c, bequiv b BFalse -> cequiv (WHILE b DO c END) SKIP. Proof. intros b c Hb. split; intros H. - inversion H; subst. + apply E_Skip. + rewrite Hb in H2. inversion H2. - inversion H; subst. apply E_WhileEnd. rewrite Hb. reflexivity. Qed.[] *)Lemma WHILE_true_nonterm : forall b c st st', bequiv b BTrue -> ~( (WHILE b DO c END) / st \\ st' ). Proof. intros b c st st' Hb. intros H. remember (WHILE b DO c END) as cw eqn:Heqcw. induction H; inversion Heqcw; subst; clear Heqcw. - unfold bequiv in Hb. rewrite Hb in H. inversion H. - apply IHceval2. reflexivity. Qed.*)Theorem WHILE_true: forall b c, bequiv b BTrue -> cequiv (WHILE b DO c END) (WHILE BTrue DO SKIP END). Proof. Admitted. Theorem loop_unrolling: forall b c, cequiv (WHILE b DO c END) (IFB b THEN (c ;; WHILE b DO c END) ELSE SKIP FI). 
a2' end | BLe a1 a2 => match (fold_constants_aexp a1, fold_constants_aexp a2) with | (ANum n1, ANum n2) => if leb n1 n2 then BTrue else BFalse | (a1', a2') => BLe a1' a2' end | BNot b1 => match (fold_constants_bexp b1) with | BTrue => BFalse | BFalse => BTrue | b1' => BNot b1' end | BAnd b1 b2 => match (fold_constants_bexp b1, fold_constants_bexp b2) with | (BTrue, BTrue) => BTrue | (BTrue, BFalse) => BFalse | (BFalse, BTrue) => BFalse | (BFalse, BFalse) => BFalse | (b1', b2') => BAnd b1' b2' end end.Example fold_bexp_ex1 : fold_constants_bexp (BAnd BTrue (BNot (BAnd BFalse BTrue))) = BTrue. Proof. reflexivity. Qed.Example fold_bexp_ex2 : fold_constants_bexp (BAnd (BEq (AId X) (AId Y)) (BEq (ANum 0) (AMinus (ANum 2) (APlus (ANum 1) (ANum 1))))) = BAnd (BEq (AId X) (AId Y)) BTrue. Proof. reflexivity. Qed.Fixpoint fold_constants_com (c : com) : com := match c with | SKIP => SKIP | i ::= a => CAss i (fold_constants_aexp a) | c1 ;; c2 => (fold_constants_com c1) ;; (fold_constants_com c2) | IFB b THEN c1 ELSE c2 FI => match fold_constants_bexp b with | BTrue => fold_constants_com c1 | BFalse => fold_constants_com c2 | b' => IFB b' THEN fold_constants_com c1 ELSE fold_constants_com c2 FI end | WHILE b DO c END => match fold_constants_bexp b with | BTrue => WHILE BTrue DO SKIP END | BFalse => SKIP | b' => WHILE b' DO (fold_constants_com c) END end end.Example fold_com_ex1 : fold_constants_com (X ::= APlus (ANum 4) (ANum 5);; Y ::= AMinus (AId X) (ANum 3);; IFB BEq (AMinus (AId X) (AId Y)) (APlus (ANum 2) (ANum 4)) THEN SKIP ELSE Y ::= ANum 0 FI;; IFB BLe (ANum 0) (AMinus (ANum 4) (APlus (ANum 2) (ANum 1))) THEN Y ::= ANum 0 ELSE SKIP FI;; WHILE BEq (AId Y) (ANum 0) DO X ::= APlus (AId X) (ANum 1) END) = (X ::= ANum 9;; Y ::= AMinus (AId X) (ANum 3);; IFB BEq (AMinus (AId X) (AId Y)) (ANum 6) THEN SKIP ELSE (Y ::= ANum 0) FI;; Y ::= ANum 0;; WHILE BEq (AId Y) (ANum 0) DO X ::= APlus (AId X) (ANum 1) END). Proof. reflexivity. Qed. Theorem fold_constants_aexp_sound : atrans_sound fold_constants_aexp. Proof. unfold atrans_sound. intros a. unfold aequiv. intros st. induction a; simpl; try reflexivity; try (destruct (fold_constants_aexp a1); destruct (fold_constants_aexp a2); rewrite IHa1; rewrite IHa2; reflexivity). Qed. Theorem fold_constants_bexp_sound: btrans_sound fold_constants_bexp. 
Require Export Tree_Inf RelationClasses.Set Implicit Arguments.Section LTree_bisimilar_def. Variable A:Type.CoInductive LTree_bisimilar : LTree A -> LTree A -> Prop := LTree_bisimilar_leaf : LTree_bisimilar LLeaf LLeaf | LTree_bisimilar_bin : forall (a:A) (t1 t'1 t2 t'2 : LTree A), LTree_bisimilar t1 t'1 -> LTree_bisimilar t2 t'2 -> LTree_bisimilar (LBin a t1 t2) (LBin a t'1 t'2).Instance LTree_bisimilar_refl : Reflexive LTree_bisimilar. Proof. cofix H; intro a; case a ; constructor; auto. Qed.Instance LTree_bisimilar_sym : Symmetric LTree_bisimilar. Proof. cofix H. intros x y; case x; case y. - left. - inversion_clear 1. - inversion_clear 1. - inversion_clear 1; now right. Qed.Instance LTree_bisimilar_trans : Transitive LTree_bisimilar. Proof. cofix H; intros x y z ; case x; case y. - inversion 2; constructor. - inversion 1. - inversion 1. - inversion_clear 1. case z; inversion_clear 1; right; now eapply H; eauto. Qed.Global Instance bisimilar_equiv : Equivalence LTree_bisimilar. Proof. split;[apply LTree_bisimilar_refl | apply LTree_bisimilar_sym | apply LTree_bisimilar_trans]. Qed. Theorem LTree_bisimilar_label : forall (p:path) (t t': LTree A), LTree_bisimilar t t' -> LTree_label t p = LTree_label t' p. 
apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem CombLinear_incl : forall (a : list (Term A n)) (P Q : list (poly A0 eqA ltM)), (forall a : list (Term A n), inPolySet A A0 eqA n ltM a P -> inPolySet A A0 eqA n ltM a Q) -> CombLinear P a -> CombLinear Q a. intros a P Q H' H'0; elim H'0; auto. intros a0 p q s H'1 H'2 H'3 H'4 H'5. apply CombLinear_comp with (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. apply eqp_imp_canonical with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply canonical_pluspf with (1 := os); auto. apply canonical_mults with (1 := cs); auto. apply inPolySet_imp_canonical with (L := P); auto. apply CombLinear_canonical with (Q := Q); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Remark CombLinear_trans_cons_lem : forall (a : list (Term A n)) (R : list (poly A0 eqA ltM)), CombLinear R a -> forall (b : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), R = b :: Q -> CombLinear Q (s2p A A0 eqA n ltM b) -> CombLinear Q a. intros a R H'; elim H'; auto. intros a0 p q s H'0 H'1 H'2 H'3 H'4 b Q H'5 H'6. apply CombLinear_comp with (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply eqp_imp_canonical with (1 := cs) (p := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) a0 q) p); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. 2: apply canonical_pluspf; auto. 2: apply canonical_mults with (1 := cs); auto. 2: apply inPolySet_imp_canonical with (L := R); auto. 2: apply CombLinear_canonical with (1 := H'2); auto. 2: apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply CombLinear_pluspf; auto. apply CombLinear_mults1; auto. 2: apply H'3 with (b := b); auto. rewrite H'5 in H'1; inversion H'1; auto. rewrite <- H2 in H'6; simpl in H'6; auto. Qed. Theorem reduce_cb : forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear Q a -> CombLinear Q b. 
Rmult_lt_compat_l; auto with real zarith. rewrite <- Zpower_nat_Z_powerRZ; auto with arith. apply Rlt_IZR. unfold Fdigit in |- *; auto with arith. unfold Fabs in |- *; simpl in |- *. pattern (Zabs (Fnum x)) at 1 in |- *; rewrite <- (Zabs_eq (Zabs (Fnum x))); auto with zarith. Qed. Theorem LSB_le_abs : forall x : float, ~ is_Fzero x -> (Float 1%nat (LSB x) <= Fabs x)%R. intros x H'; apply Rle_trans with (FtoRradix (Float 1%nat (MSB x))). apply (oneExp_le radix); auto. apply LSB_le_MSB; auto. apply MSB_le_abs; auto. Qed. Theorem MSB_monotoneAux : forall x y : float, (Fabs x <= Fabs y)%R -> Fexp x = Fexp y -> (MSB x <= MSB y)%Z. intros x y H' H'0; unfold MSB in |- *. rewrite <- H'0. cut (Fdigit radix x <= Fdigit radix y)%Z; [ unfold Zpred in |- *; auto with zarith | idtac ]. unfold Fdigit in |- *; apply inj_le. apply digit_monotone; auto. apply le_IZR. apply Rmult_le_reg_l with (r := powerRZ radix (Fexp x)); auto with real zarith. repeat rewrite (Rmult_comm (powerRZ radix (Fexp x))); auto. pattern (Fexp x) at 2 in |- *; rewrite H'0; auto. Qed. Theorem MSB_monotone : forall x y : float, ~ is_Fzero x -> ~ is_Fzero y -> (Fabs x <= Fabs y)%R -> (MSB x <= MSB y)%Z. intros x y H' H'0 H'1; rewrite (MSB_abs x); rewrite (MSB_abs y). case (Zle_or_lt (Fexp (Fabs x)) (Fexp (Fabs y))); simpl in |- *; intros Zle1. rewrite MSB_shift with (x := Fabs y) (n := Zabs_nat (Fexp (Fabs y) - Fexp (Fabs x))). apply MSB_monotoneAux; auto. unfold FtoRradix in |- *; repeat rewrite Fabs_correct; auto with real arith. rewrite FshiftCorrect; auto with real arith. repeat rewrite Fabs_correct; auto with real arith. repeat rewrite Rabs_Rabsolu; repeat rewrite <- Fabs_correct; auto with real arith. unfold Fshift in |- *; simpl in |- *. rewrite inj_abs; [ ring | auto with zarith ]. apply Fabs_Fzero; auto. rewrite MSB_shift with (x := Fabs x) (n := Zabs_nat (Fexp (Fabs x) - Fexp (Fabs y))). apply MSB_monotoneAux; auto. unfold FtoRradix in |- *; repeat rewrite Fabs_correct; auto with real arith. rewrite FshiftCorrect; auto with real arith. repeat rewrite Fabs_correct; auto with real arith. repeat rewrite Rabs_Rabsolu; repeat rewrite <- Fabs_correct; auto with real arith. unfold Fshift in |- *; simpl in |- *. rewrite inj_abs; [ ring | auto with zarith ]. apply Fabs_Fzero; auto. Qed. Theorem MSB_le_multAux : forall x y : float, ~ is_Fzero x -> ~ is_Fzero y -> (MSB x + MSB y <= MSB (Fmult x y))%Z. 
Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Malloc Bedrock.Platform.Bootstrap Bedrock.Platform.Cito.examples.Factorial. Module Type S. Parameter heapSize : nat. End S.Module Make(M : S). Import M.Section boot. Hypothesis heapSizeLowerBound : (3 <= heapSize)%nat. Definition size := heapSize + 50 + 0. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize * 4). goodSize. Qed. Definition bootS := bootS heapSize 0. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "top"!"top" @ [topS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%nat;; Assert [PREonly[_] 0 =?> heapSize];; Call "malloc"!"init"(0, heapSize) [PREonly[_] mallocHeap 0];; Call "top"!"top"() [PREonly[_] [| False |] ] end }}. Theorem ok : moduleOk boot. vcgen; abstract genesis. Qed. Definition m0 := link Malloc.m boot. Definition m1 := link all m0. Lemma ok0 : moduleOk m0. link Malloc.ok ok. Qed. Lemma ok1 : moduleOk m1. link all_ok ok0. Qed. Variable stn : settings. Variable prog : program. Hypothesis inj : forall l1 l2 w, Labels stn l1 = Some w -> Labels stn l2 = Some w -> l1 = l2. Hypothesis agree : forall l pre bl, LabelMap.MapsTo l (pre, bl) (XCAP.Blocks m1) -> exists w, Labels stn l = Some w /\ prog w = Some bl. Hypothesis agreeImp : forall l pre, LabelMap.MapsTo l pre (XCAP.Imports m1) -> exists w, Labels stn l = Some w /\ prog w = None. Hypothesis omitImp : forall l w, Labels stn ("sys", l) = Some w -> prog w = None. Variable w : W. Hypothesis at_start : Labels stn ("main", Global "main") = Some w. Variable st : state. Hypothesis mem_low : forall n, (n < size * 4)%nat -> st.(Mem) n <> None. Hypothesis mem_high : forall w, ($ (size * 4) <= w)%word -> st.(Mem) w = None. Theorem safe : sys_safe stn prog (w, st). 
Require Import Coq.omega.Omega. Require Import Coq.Structures.OrderedType Coq.FSets.FMapAVL. Require Import Coq.Lists.List. Require Import Coq.Setoids.Setoid Coq.Classes.RelationClasses. Require Import Bedrock.Reflection. Require Import Coq.Numbers.Natural.Peano.NPeano.Set Implict Arguments. Set Strict Implicit.Module Ordered_nat <: OrderedType with Definition t := nat. Definition t := nat. Definition eq := @eq nat. Definition lt := @lt. Theorem eq_refl : forall x, eq x x. reflexivity. Qed. Theorem eq_sym : forall a b, eq a b -> eq b a. 
Set Implicit Arguments.Require Export Classical. Require Export Description. Require Import ChoiceFacts.Local Notation inhabited A := A (only parsing).Theorem excluded_middle_informative : forall P:Prop, {P} + {~ P}. Proof. apply (constructive_definite_descr_excluded_middle constructive_definite_description classic). Qed.Theorem classical_definite_description : forall (A : Type) (P : A->Prop), inhabited A -> { x : A | (exists! x : A, P x) -> P x }. Proof. intros A P i. destruct (excluded_middle_informative (exists! x, P x)) as [Hex|HnonP]. apply constructive_definite_description with (P:= fun x => (exists! x : A, P x) -> P x). destruct Hex as (x,(Hx,Huni)). exists x; split. intros _; exact Hx. firstorder. exists i; tauto. Qed.Definition iota (A : Type) (i:inhabited A) (P : A->Prop) : A := proj1_sig (classical_definite_description P i).Definition iota_spec (A : Type) (i:inhabited A) (P : A->Prop) : (exists! x:A, P x) -> P (iota i P) := proj2_sig (classical_definite_description P i). Theorem dependent_unique_choice : forall (A:Type) (B:A -> Type) (R:forall x:A, B x -> Prop), (forall x:A, exists! y : B x, R x y) -> (exists f : (forall x:A, B x), forall x:A, R x (f x)). 
not in |- *; intros; split. intros H H0; inversion_clear H0. generalize (H x H1); elim H2; intros. inversion_clear H3 in H0. apply (H0 H4). inversion_clear H4. apply (H3 H6). generalize Sini; cofix u. simple destruct x; intros; constructor. elim (classic (P (s ^ s0))); [ trivial | intros ]. absurd (Posible Sini0 (fun s : Stream S => ~ P s)). assumption. apply posible with (1 := H0). constructor 1; assumption. elim H0; simpl in |- *; intros. apply (u (hd s0)); intros. generalize H0; clear H0; generalize H3; clear H3. rewrite <- H1; case s0; simpl in |- *; intros. apply (notPosible (P:=fun s : Stream S => ~ P s) H H0); assumption. inversion_clear H2; simpl in |- *. unfold isTraceFrom in |- *; split; trivial. unfold isTraceFrom in |- *; split; trivial. Qed. Lemma not_EX : forall (P : Stream S -> Prop) (x : Stream S) (s : S), ~ ExistsS P (s ^ x) -> ~ ExistsS P x. Proof. unfold not in |- *; intros. apply (H (Further s H0)). Qed. Theorem Equiv4 : forall (Sini : S) (P : Stream S -> Prop), SafePath Sini P <-> ~ Inevitable Sini (fun s : Stream S => ~ P s). Proof. unfold iff, Inevitable, not in |- *; intros; split. intro sp; inversion sp; intros. generalize H0; elim (H1 x H); intros. inversion_clear H3 in H2. apply (H2 H4). apply H3; inversion_clear H4; assumption. intro H; elim (not_all_ex_not (Stream S) (fun x : Stream S => isTraceFrom Sini x -> ExistsS (fun s : Stream S => P s -> False) x) H). intros. generalize (not_imply_elim2 (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0). generalize (not_imply_elim (isTraceFrom Sini x) (ExistsS (fun s : Stream S => ~ P s) x) H0); intros. apply safePath with (1 := H1). generalize H1; clear H1; generalize H2; clear H2. generalize x; generalize Sini; cofix u. simple destruct x0; intros; constructor. elim (classic (P (s ^ s0))); [ trivial | intro ]. elim (H2 (Here (P:=fun s : Stream S => ~ P s) H3)). apply u with (Sini := hd s0). generalize H2; clear H2; case s0; unfold not in |- *; intros. apply (not_EX H2 H3). elim H1; intros ig trace; inversion_clear trace. unfold isTraceFrom in |- *; split; trivial. unfold isTraceFrom in |- *; split; trivial. Qed. Theorem Mon_I_S : forall (x : Stream S) (Pg Pp : Stream S -> Prop), ForAllS Pg x -> (forall s : Stream S, Pg s -> Pp s) -> ForAllS Pp x. 
rewrite /=. rewrite H1. reflexivity. - iApply big_sepM2_insert; eauto. iFrame. Qed. Theorem big_sepML_insert_app Œ¶ m l k v lv : m !! k = None -> Œ¶ k v lv ‚àó big_sepML Œ¶ m l -‚àó big_sepML Œ¶ (<[k := v]> m) (l ++ [lv]). Proof. iIntros "% [Hp Hml]". rewrite -Permutation_cons_append. iApply big_sepML_insert; eauto; iFrame. Qed. Theorem big_sepML_delete_cons Œ¶ m l lv : big_sepML Œ¶ m (lv :: l) -‚àó ‚àÉ k v, ‚åú m !! k = Some v ‚åù ‚àó Œ¶ k v lv ‚àó big_sepML Œ¶ (delete k m) l. Proof. iIntros "Hml". rewrite big_sepML_eq. iDestruct "Hml" as (lm) "[% Hml]". assert (lv ‚àà lv :: l) by apply elem_of_list_here. setoid_rewrite H0 in H1. apply elem_of_list_fmap_2 in H1 as [[k lv0] H1]. simpl in H1; intuition subst. apply elem_of_map_to_list in H3. iDestruct (big_sepM2_lookup_r_some with "Hml") as %[v Hmk]; eauto. iExists _, _. iSplitR; eauto. iDestruct (big_sepM2_delete with "Hml") as "[Hp Hml]"; eauto. iFrame. iExists _. iSplitR; last iFrame. iPureIntro. replace lm with (<[k := lv0]> (delete k lm)) in H0. 2: { rewrite insert_delete; eauto. } setoid_rewrite map_to_list_insert in H0. 2: apply lookup_delete. simpl in H0. apply Permutation.Permutation_cons_inv in H0. done. Qed. Lemma map_to_list_insert_overwrite (l : list LV) (i : nat) (k : K) (lv lv' : LV) (lm : gmap K LV) : l !! i = Some lv -> lm !! k = Some lv -> l ‚â°‚Çö (map_to_list lm).*2 -> <[i := lv']> l ‚â°‚Çö (map_to_list (<[k := lv']> lm)).*2. Proof. intros. rewrite -insert_delete_insert. rewrite map_to_list_insert. 2: apply lookup_delete. erewrite delete_Permutation in H2; eauto. erewrite (delete_Permutation _ i lv'). 2: { rewrite list_lookup_insert; eauto. eapply lookup_lt_Some; eauto. } erewrite <- (insert_id lm) in H2; eauto. rewrite -insert_delete_insert in H2. erewrite map_to_list_insert in H2. 2: apply lookup_delete. simpl in *. apply Permutation.Permutation_cons_inv in H2. rewrite -H2. f_equiv. repeat rewrite delete_take_drop. rewrite -> take_insert by lia. rewrite -> drop_insert_gt by lia. f_equiv. Qed. Lemma map_to_list_delete (l : list LV) (lm : gmap K LV) (k : K) (i : nat) (x : LV) : l !! i = Some x -> lm !! k = Some x -> l ‚â°‚Çö (map_to_list lm).*2 -> delete i l ‚â°‚Çö (map_to_list (delete k lm)).*2. Proof. intros. erewrite delete_Permutation in H2; eauto. erewrite <- (insert_id lm) in H2; eauto. rewrite -insert_delete_insert in H2. erewrite map_to_list_insert in H2. 2: apply lookup_delete. simpl in *. apply Permutation.Permutation_cons_inv in H2. eauto. Qed. Theorem big_sepML_delete_m Œ¶ m l k v : m !! k = Some v -> big_sepML Œ¶ m l -‚àó ‚àÉ i lv, ‚åú l !! i = Some lv ‚åù ‚àó Œ¶ k v lv ‚àó big_sepML Œ¶ (delete k m) (delete i l). 
Monoid.op_id_l_uniq prod_monoid. Theorem prod_id_r_uniq : forall x : E, (Monoid.is_id_r E prod x) -> x = 1. Proof Monoid.op_id_r_uniq prod_monoid. Theorem prod_id_uniq : forall x : E, (Monoid.is_id E prod x) -> x = 1. Proof Monoid.op_id_uniq prod_monoid. Theorem prod_intro_l : forall x y z : E, x = y -> z # x = z # y. Proof Monoid.op_intro_l prod_monoid. Theorem prod_intro_r : forall x y z : E, x = y -> x # z = y # z. Proof Monoid.op_intro_r prod_monoid. Definition prod_is_inv_l := Monoid.op_is_inv_l prod_monoid. Definition prod_is_inv_r := Monoid.op_is_inv_r prod_monoid. Definition prod_is_inv := Monoid.op_is_inv prod_monoid. Definition prod_has_inv_l := Monoid.has_inv_l prod_monoid. Definition prod_has_inv_r := Monoid.has_inv_r prod_monoid. Definition prod_has_inv := Monoid.has_inv prod_monoid. Theorem prod_inv_l_r_eq : forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z. Proof Monoid.op_inv_l_r_eq prod_monoid. Theorem prod_inv_sym : forall x y : E, prod_is_inv x y <-> prod_is_inv y x. Proof Monoid.op_inv_sym prod_monoid. Theorem prod_cancel_l : forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y. Proof Monoid.op_cancel_l prod_monoid. Theorem prod_cancel_r : forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y. Proof Monoid.op_cancel_r prod_monoid. Theorem prod_inv_l_uniq : forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y. Proof Monoid.op_inv_l_uniq prod_monoid. Theorem prod_inv_r_uniq : forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y. Proof Monoid.op_inv_r_uniq prod_monoid. Definition prod_inv_uniq : forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y := Monoid.op_inv_uniq prod_monoid. Theorem prod_inv_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem prod_inv_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_has_inv_l_1 : prod_has_inv_l 1. Proof Monoid.op_has_inv_l_0 prod_monoid. Theorem prod_has_inv_r_1 : prod_has_inv_r 1. Proof Monoid.op_has_inv_r_0 prod_monoid. Theorem prod_has_inv_1 : prod_has_inv 1. Proof Monoid.op_has_inv_0 prod_monoid. Theorem prod_inv_1_eq_1 : forall x : E, prod_is_inv x 1 -> x = 1. Proof Monoid.op_inv_0_eq_0 prod_monoid. Theorem prod_inv_1_uniq : unique (fun x => prod_is_inv x 1) 1. Proof Monoid.op_inv_0_uniq prod_monoid. Theorem recipr_1_l : prod_is_inv_l 1 1. Proof Monoid.op_inv_0_l prod_monoid. Theorem recipr_1_r : prod_is_inv_r 1 1. Proof Monoid.op_inv_0_r prod_monoid. Theorem recipr_1 : prod_is_inv 1 1. Proof Monoid.op_inv_0 prod_monoid. Theorem prod_sum_distrib : is_distrib E prod sum. 
{struct b} : bool := match a, b with | xH, xH => true | xI a', xI b' => pos_eq_bool a' b' | xO a', xO b' => pos_eq_bool a' b' | _, _ => false end. Theorem pos_eq_bool_correct : forall p q : positive, match pos_eq_bool p q with | true => p = q | false => p <> q end. intros p q; generalize p; elim q; simpl in |- *; auto; clear p q. intros p Rec q; case q; simpl in |- *; try (intros; red in |- *; intros; discriminate; fail). intros q'; generalize (Rec q'); case (pos_eq_bool q' p); simpl in |- *; auto. intros H1; rewrite H1; auto. intros H1; Contradict H1; injection H1; auto. intros p Rec q; case q; simpl in |- *; try (intros; red in |- *; intros; discriminate; fail). intros q'; generalize (Rec q'); case (pos_eq_bool q' p); simpl in |- *; auto. intros H1; rewrite H1; auto. intros H1; Contradict H1; injection H1; auto. intros q; case q; simpl in |- *; try (intros; red in |- *; intros; discriminate; fail); auto. Qed. Theorem Z_O_1 : (0 < 1)%Z. red in |- *; simpl in |- *; auto; intros; red in |- *; intros; discriminate. Qed. Hint Resolve Z_O_1: zarith. Definition Z_eq_bool a b := match a, b with | Z0, Z0 => true | Zpos a', Zpos b' => pos_eq_bool a' b' | Zneg a', Zneg b' => pos_eq_bool a' b' | _, _ => false end. Theorem Z_eq_bool_correct : forall p q : Z, match Z_eq_bool p q with | true => p = q | false => p <> q end. intros p q; case p; case q; simpl in |- *; auto; try (intros; red in |- *; intros; discriminate; fail). intros p' q'; generalize (pos_eq_bool_correct q' p'); case (pos_eq_bool q' p'); simpl in |- *; auto. intros H1; rewrite H1; auto. intros H1; Contradict H1; injection H1; auto. intros p' q'; generalize (pos_eq_bool_correct q' p'); case (pos_eq_bool q' p'); simpl in |- *; auto. intros H1; rewrite H1; auto. intros H1; Contradict H1; injection H1; auto. Qed. Theorem Zlt_mult_ZERO : forall x y : Z, (0 < x)%Z -> (0 < y)%Z -> (0 < x * y)%Z. intros x y; case x; case y; unfold Zlt in |- *; simpl in |- *; auto. Qed. Hint Resolve Zlt_mult_ZERO: zarith. Theorem Zlt_Zminus_ZERO : forall z1 z2 : Z, (z2 < z1)%Z -> (0 < z1 - z2)%Z. 
introv rR Hal Hap. invertsn Hap. constructor. revert Hal Hap. apply respects_alphal_ex_closed_comput; auto. Qed.Lemma ex_approx_alpha_rw_l_aux {p} : forall lib ex a b a', @alpha_eq p a a' -> ex_approx lib ex a b -> ex_approx lib ex a' b. Proof. unfold ex_approx. introv. generalize (@respects_alpha_l_ex_approx_aux_bot2_or_bot2 p lib ex). revert a b a'. exact (ex_approxr_alpha_rw_l_aux lib ex bot2). Qed.Lemma respects_alphar_ex_closed_comput {p} : forall lib ex R, respects_alpha_r R -> respects_alpha_r (@ex_close_comput p lib ex R). Proof. introv rR Hal Hap. repnud Hap. unfolds_base. alpha_hyps Hal. dands; eauto 2 with slow. - introv Hcv. apply Hap2 in Hcv. exrepnd. eapply compute_to_value_alpha with (t2:=b') in Hcv1; eauto with slow. exrepnd. invertsna Hcv2 Hbal. exists lbt2. split; eauto with slow;[]. repnud Hcv0. split;spcf;[]. introv Hlt. duplicate Hlt. apply_clear Hcv0 in Hlt. dimp (Hbal0 n); [omega|]. repnud Hlt. exrepnd. unfold blift. exists lv nt1 nt2. spc; eauto. eauto with slow. - introv comp. apply Hap3 in comp; exrepnd; auto. repndors; exrepnd; tcsp. right. eapply compute_to_exception_alpha with (t2:=b') in comp0; eauto with slow. exrepnd. eexists; eexists; dands;[eauto| |]; eauto 3 with slow. - introv comp. apply Hap4 in comp; exrepnd. eapply computes_to_seq_alpha in comp1;[| |eauto]; eauto 3 with slow; exrepnd. eexists; dands; eauto. Qed.Lemma ex_approxr_alpha_rw_r_aux {p} : forall lib ex r a b b', respects_alpha_r (ex_approx_aux lib ex r \2/ r) -> @alpha_eq p b b' -> ex_approx_aux lib ex r a b -> ex_approx_aux lib ex r a b'. Proof. intro r. introv rR Hal Hap. invertsn Hap. constructor. revert Hal Hap. apply respects_alphar_ex_closed_comput; auto. Qed.Lemma ex_approx_alpha_rw_r_aux {p} : forall lib ex a b b', @alpha_eq p b b' -> ex_approx lib ex a b -> ex_approx lib ex a b'. Proof. unfold approx. introv. generalize (@respects_alpha_r_ex_approx_aux_bot2_or_bot2 p lib ex). revert a b b'. exact (ex_approxr_alpha_rw_r_aux lib ex bot2). Qed.Hint Resolve ex_approx_alpha_rw_r_aux : slowbad. Hint Resolve ex_approx_alpha_rw_l_aux : slowbad. Lemma respects_alpha_ex_closed_comput {p} : forall lib ex R, respects_alpha R -> respects_alpha (@ex_close_comput p lib ex R). Proof. introv ra. destruct ra. split. - apply respects_alphal_ex_closed_comput; auto. - apply respects_alphar_ex_closed_comput; auto. Qed. Hint Resolve respects_alpha_ex_closed_comput : respects.Corollary respects_alpha_ex_approx {p} : forall lib ex, respects_alpha (@ex_approx p lib ex). Proof. split; introv; intros; eauto with slowbad. Qed. Hint Immediate respects_alpha_ex_approx. Hint Resolve respects_alpha_ex_approx : respects.Theorem ex_approx_open_relates_only_wf {p} : forall lib ex (t1 t2 : @NTerm p), ex_approx_open lib ex t1 t2 -> nt_wf t1 # nt_wf t2. Proof. introv. apply olift_relates_only_wf. Qed. Hint Resolve ex_approx_open_relates_only_wf : slow. Theorem ex_approx_open_lsubst {p} : forall lib ex a b lvi lvo, let sub := @var_ren p lvi lvo in ex_approx_open lib ex a b -> ex_approx_open lib ex (lsubst a sub) (lsubst b sub). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Nat_Facts Ext_Cons.Prod_Cat.Operations. From Categories Require Import Functor.Main. From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop. From Categories Require Import NatTrans.Main. From Categories Require Import Adjunction.Adjunction Adjunction.Duality. From Categories Require Import Cat.Cat Cat.Exponential Cat.Exponential_Facts. From Categories Require Import Yoneda.Yoneda. From Categories Require Import Functor.Functor_Extender.Local Open Scope functor_scope.Section Hom_Adjunct_left_iso. Context {C D : Category} {F F' : C ‚Äì‚âª D} (N : (F' ‚âÉ F)%natiso) {G : D ‚Äì‚âª C} (adj : F ‚ä£_hom G) . Definition Hom_Adjunct_left_iso : F' ‚ä£_hom G := (adj ‚àò ((NatTrans_id_Iso (Hom_Func D)) ‚àò_h (Prod_Functor_NatIso (N^op) (NatTrans_id_Iso (Functor_id D)))) )%isomorphism%natiso.End Hom_Adjunct_left_iso.Section Hom_Adjunct_right_iso. Context {C D : Category} {F : C ‚Äì‚âª D} {G G' : D ‚Äì‚âª C} (N : (G ‚âÉ G')%natiso) (adj : F ‚ä£_hom G) . Definition Hom_Adjunct_right_iso : F ‚ä£_hom G' := Hom_Adjunct_Duality (Hom_Adjunct_left_iso ((N^op)‚Åª¬π)%isomorphism%natiso (Hom_Adjunct_Duality adj)).End Hom_Adjunct_right_iso.Section Adjunct_left_iso. Context {C D : Category} (F F' : C ‚Äì‚âª D) (N : (F' ‚âÉ F)%natiso) (G : D ‚Äì‚âª C) (adj : F ‚ä£ G) . Definition Adjunct_left_iso : F' ‚ä£ G := Hom_Adj_to_Adj (Hom_Adjunct_left_iso N (Adj_to_Hom_Adj adj)).End Adjunct_left_iso.Section Adjunct_right_iso. Context {C D : Category} (F : C ‚Äì‚âª D) (G G' : D ‚Äì‚âª C) (N : (G ‚âÉ G')%natiso) (adj : F ‚ä£ G) . Definition Adjunct_right_iso : F ‚ä£ G' := Hom_Adj_to_Adj (Hom_Adjunct_right_iso N (Adj_to_Hom_Adj adj)).End Adjunct_right_iso.Section Hom_Adjunct_left_unique. Context {C D : Category} {F F' : C ‚Äì‚âª D} {G : D ‚Äì‚âª C} (adj : F ‚ä£_hom G) (adj' : F' ‚ä£_hom G) . Definition Hom_Adjunct_left_unique : (F ‚âÉ F')%natiso. Proof. apply (@Opposite_NatIso _ _ (F^op) (F'^op)). eapply (Embedding_mono (Yoneda_Emb (D^op))). eapply Isomorphism_Compose; [eapply Inverse_Isomorphism; apply Exp_Cat_morph_ex_compose_Iso |]. eapply Isomorphism_Compose; [|apply Exp_Cat_morph_ex_compose_Iso]. apply Exp_Cat_morph_ex_Iso. eapply Isomorphism_Compose. apply adj. eapply Inverse_Isomorphism. apply adj'. Defined.End Hom_Adjunct_left_unique. Section Hom_Adjunct_right_unique. Context {C D : Category} {F : C ‚Äì‚âª D} {G G' : D ‚Äì‚âª C} (adj : F ‚ä£_hom G) (adj' : F ‚ä£_hom G') . Theorem Hom_Adjunct_right_unique : (G ‚âÉ G')%natiso. 
Lemma Œµ‚ÇÄ_is_Œµ_number : Œµ‚ÇÄ ‚ãµ Œµ_number. Proof with neauto. split... ext. - rewrite ordExp_limit in H... apply FUnionE in H as [Œ± [HŒ± Hx]]. eapply ord_trans... apply Œµ‚ÇÄ_closed_under_œâ_exp... - rewrite ordExp_limit... eapply FUnionI... apply Œµ‚ÇÄE in H as [n [Hn Hx]]. eapply ordExp_enlarge_l_strictly... Qed. Lemma Œµ_number_neq_0 : ‚àÄŒµ ‚ãµ Œµ_number, Œµ ‚â 0. Proof with eauto. intros Œµ [HŒµ Heq]. intros H. subst. rewrite ordExp_0_r in Heq... Qed. Lemma Œµ_number_neq_1 : ‚àÄŒµ ‚ãµ Œµ_number, Œµ ‚â 1. Proof with neauto. intros Œµ [HŒµ Heq]. intros H. subst. rewrite ordExp_1_r in Heq... Qed. Lemma Œµ_number_has_tower_n : ‚àÄn ‚àà œâ, ‚àÄŒµ ‚ãµ Œµ_number, Œæ ^^·¥∏ n ‚àà Œµ. Proof with neauto. intros n Hn. œâ_induction n; intros Œµ [HŒµ Heq]. - rewrite <- zero, ordTetL_0, <- Heq... apply ordExp_enlarge_r... apply ord_neq_0_1_gt_1... apply Œµ_number_neq_0. split... apply Œµ_number_neq_1. split... - rewrite ordTetL_suc, <- Heq... apply ordExp_preserve_lt... apply IH. split... Qed. Lemma Œµ‚ÇÄ_is_the_least_Œµ_number : ‚àÄŒ± ‚ãµ Œµ_number, Œµ‚ÇÄ ‚ã∏ Œ±. Proof with eauto. intros Œµ [HŒµ Heq]. apply ord_le_iff_sub... intros x Hx. apply Œµ‚ÇÄE in Hx as [n [Hn Hx]]. eapply ord_trans... apply Œµ_number_has_tower_n... split... Qed. Definition Œµ := Enumerate Œµ_number. Lemma Œµ_number_sub_ùêéùêç : Œµ_number ‚´É ùêéùêç. Proof. intros Œ± []; auto. Qed. Local Hint Resolve Œµ_number_sub_ùêéùêç : core. Lemma Œµ_number_unbounded : unbounded Œµ_number. Proof. apply fixed_point_class_unbounded, ordExp_normal; nauto. Qed. Local Hint Resolve Œµ_number_unbounded : core. Lemma Œµ_spec : ‚àÄŒ± ‚ãµ ùêéùêç, ‚àÄŒ≤ ‚ãµ Œµ_number, Œ≤ ‚àâ {Œµ x | x ‚àä Œ±} ‚Üí Œµ Œ± ‚ã∏ Œ≤. Proof. intros Œ± HŒ± Œ≤ HŒ≤. apply enum_spec; auto. Qed. Lemma Œµ_is_Œµ_number : Œµ :·∂ú ùêéùêç ‚áí Œµ_number. Proof. apply enum_into_class; auto. Qed. Local Hint Resolve Œµ_is_Œµ_number : core. Lemma Œµ_operative : Œµ :·∂ú ùêéùêç ‚áí ùêéùêç. Proof. intros. apply enum_operative; auto. Qed. Local Hint Resolve Œµ_operative : core. Theorem Œµ_0 : Œµ 0 = Œµ‚ÇÄ. Proof with auto. ord_ext... - apply Œµ_spec... apply Œµ‚ÇÄ_is_Œµ_number. intros H. apply ReplAx in H as [x [Hx _]]. exfalso0. - apply Œµ‚ÇÄ_is_the_least_Œµ_number... Qed. Theorem Œµ_monotone : monotone Œµ. Proof. apply enum_monotone; auto. Qed. Theorem Œµ_injective : class_injective Œµ ùêéùêç. Proof. apply enum_injective; auto. Qed. Theorem Œµ_surjective : class_surjective Œµ ùêéùêç Œµ_number. Proof. apply enum_surjective; auto. Qed. Theorem Œµ_iff_Œµ_number : ‚àÄ Œæ, Œæ ‚ãµ Œµ_number ‚Üî ‚àÉ Œ±, Œ± ‚ãµ ùêéùêç ‚àß Œµ Œ± = Œæ. Proof. apply enum_iff_class; auto. Qed. Theorem Œµ_normal : normal Œµ. Proof. apply fixedPoint_normal, ordExp_normal; nauto. Qed. Theorem Œµ_limit : continuous Œµ. Proof. apply Œµ_normal. Qed. Theorem Œµ_closed : closed Œµ_number. 
Require Import Coq.Logic.FunctionalExtensionality. Require Import Coq.Program.Basics.Set Implicit Arguments.Module Type Monad. Parameter m : Type -> Type. Parameter ret : forall {A : Type}, A -> m A. Parameter bind : forall {A B : Type}, m A -> (A -> m B) -> m B. Infix ">>=" := bind (at level 50, left associativity). Axiom left_id : forall (A B : Type) (x : A) (f : A -> m B), ret x >>= f = f x. Axiom right_id : forall (A : Type) (x : m A), x >>= ret = x. Axiom bind_assoc : forall (A B C : Type) (n : m A) (f : A -> m B) (g : B -> m C), (n >>= f) >>= g = n >>= (fun x => f x >>= g). End Monad.Local Open Scope program_scope. Module MonadExt (M : Monad). Import M. Definition fmap {A B : Type} (f : A -> B) (n : m A) : m B := n >>= ret ‚àò f. Definition join {A : Type} (n : m (m A)) : m A := n >>= id. Theorem fmap_compose_join_eq_bind : forall (A B : Type) (n : m A) (f : A -> m B), n >>= f = join (fmap f n). Proof. unfold join, fmap; intros. rewrite bind_assoc. f_equal; apply functional_extensionality; intros. unfold compose; rewrite left_id. auto. Qed. Theorem fmap_id : forall (A : Type), fmap (@id A) = @id (m A). Proof. unfold fmap, compose; intros. apply functional_extensionality; intros; unfold id. rewrite right_id. auto. Qed. Theorem fmap_associativity : forall (A B C : Type) (f : A -> B) (g : B -> C), fmap (g ‚àò f) = fmap g ‚àò fmap f. 
: A, o = Some a. split; intros. eapply ex_up; eauto. openhyp. nintro. rewrite H0 in H; intuition. Qed. Lemma augment_elim_2 : forall imps specs stn (lbls : list glabel), augment imps specs stn lbls -> (forall x, List.In x lbls -> LabelMap.find (x : Labels.label) imps <> None) -> forall l, List.In l lbls -> Labels stn l <> None. Proof. induction lbls; simpl; intros. intuition. destruct H1. subst. destruct l. unfold to_bedrock_label in *. simpl in *. destruct (option_dec (LabelMap.LabelMap.find (elt:=assert) (s, Global s0) imps)). destruct s1. rewrite e in H. openhyp. eapply Some_not_None; eexists; eauto. generalize H0; specialize (H0 (s, s0)); intro; simpl in *. rewrite e in H0. intuition. destruct a. unfold to_bedrock_label in *. simpl in *. destruct (option_dec (LabelMap.LabelMap.find (elt:=assert) (s, Global s0) imps)). destruct s1. rewrite e in H. openhyp. eauto. generalize H0; specialize (H0 (s, s0)); intro; simpl in *. rewrite e in H0. intuition. Qed. Notation stn_good_to_use := (LinkSpec.stn_good_to_use modules imports). Lemma augment_stn_good_to_use : forall specs stn, augment (fullImports bimports_diff_bexports stubs) specs stn accessible_labels -> stn_good_to_use stn. Proof. unfold LinkSpec.stn_good_to_use. unfold label_in. intros. openhyp. assert (In lbl exports). subst. eapply MapsTo_In. eapply exports_mapsto_iff. descend; eauto. subst. eapply augment_elim_2 in H. 2 : eapply accessible_labels_subset_fullImports. Focus 2. eapply exports_accessible_labels. eapply in_find_iff. eauto. eauto. eapply augment_elim_2 in H. 2 : eapply accessible_labels_subset_fullImports. Focus 2. eapply imports_accessible_labels. eapply in_find_iff. eauto. eauto. Qed. Lemma augment_stn_injective : forall specs stn, augment (fullImports bimports_diff_bexports stubs) specs stn accessible_labels -> stn_injective (label_in modules imports) (glabel2w stn). Proof. unfold stn_injective. intros. unfold label_in in H0. openhyp. assert (In lbl1 exports). subst. eapply MapsTo_In. eapply exports_mapsto_iff. descend; eauto. unfold label_in in H1. openhyp. assert (In lbl2 exports). subst. eapply MapsTo_In. eapply exports_mapsto_iff. descend; eauto. eapply augment_injective_exports; eauto. exfalso. eapply augment_injective_exports_imports; eauto. unfold label_in in H1. openhyp. assert (In lbl2 exports). subst. eapply MapsTo_In. eapply exports_mapsto_iff. descend; eauto. exfalso. eapply augment_injective_exports_imports; eauto. eapply augment_injective_imports; eauto. Qed. Lemma augment_env_good_to_use : forall specs stn, augment (fullImports bimports_diff_bexports stubs) specs stn accessible_labels -> env_good_to_use modules imports stn fs. intros. split. eapply augment_stn_good_to_use; eauto. split. eapply augment_stn_injective; eauto. eapply augment_fs_good_to_use; eauto. Qed. Lemma good_vcs : forall ls, (forall x, List.In x ls -> List.In x (Functions m)) -> vcs (makeVcs bimports_diff_bexports stubs (List.map make_stub ls)). induction ls; simpl; eauto. Opaque funcs_ok. Opaque spec_without_funcs_ok. wrap0. descend. eapply fs_funcs_ok; eauto. eapply Imply_sound. eauto. step auto_ext. descend; eauto. simpl in *. eapply augment_env_good_to_use; eauto. erewrite tgt_fullImports; eauto. Qed. Theorem make_module_ok : XCAP.moduleOk make_module. 
:= ex_intro2 : forall x:A, P x -> Q x -> ex2 (A:=A) P Q.Definition all (A:Type) (P:A -> Prop) := forall x:A, P x.Notation "'exists' x .. y , p" := (ex (fun x => .. (ex (fun y => p)) ..)) (at level 200, x binder, right associativity, format "'[' 'exists' '/ ' x .. y , '/ ' p ']'") : type_scope.Notation "'exists2' x , p & q" := (ex2 (fun x => p) (fun x => q)) (at level 200, x ident, p at level 200, right associativity) : type_scope. Notation "'exists2' x : A , p & q" := (ex2 (A:=A) (fun x => p) (fun x => q)) (at level 200, x ident, A at level 200, p at level 200, right associativity, format "'[' 'exists2' '/ ' x : A , '/ ' '[' p & '/' q ']' ']'") : type_scope.Notation "'exists2' ' x , p & q" := (ex2 (fun x => p) (fun x => q)) (at level 200, x strict pattern, p at level 200, right associativity) : type_scope. Notation "'exists2' ' x : A , p & q" := (ex2 (A:=A) (fun x => p) (fun x => q)) (at level 200, x strict pattern, A at level 200, p at level 200, right associativity, format "'[' 'exists2' '/ ' ' x : A , '/ ' '[' p & '/' q ']' ']'") : type_scope.Section universal_quantification. Variable A : Type. Variable P : A -> Prop. Theorem inst : forall x:A, all (fun x => P x) -> P x. Proof. unfold all; auto. Qed. Theorem gen : forall (B:Prop) (f:forall y:A, B -> P y), B -> all P. Proof. red; auto. Qed.End universal_quantification.Inductive eq (A:Type) (x:A) : A -> Prop := eq_refl : x = x :>Awhere "x = y :> A" := (@eq A x y) : type_scope.Notation "x = y" := (x = y :>_) : type_scope. Notation "x <> y :> T" := (~ x = y :>T) : type_scope. Notation "x <> y" := (x <> y :>_) : type_scope.Arguments eq {A} x _. Arguments eq_refl {A x} , [A] x.Arguments eq_ind [A] x P _ y _. Arguments eq_rec [A] x P _ y _. Arguments eq_rect [A] x P _ y _.Hint Resolve I conj or_introl or_intror : core. Hint Resolve eq_refl: core. Hint Resolve ex_intro ex_intro2: core.Section Logic_lemmas. Theorem absurd : forall A C:Prop, A -> ~ A -> C. 
v x). subst. rewrite M.gempty. reflexivity. rewrite M.gempty. reflexivity. Qed. Theorem remove_none_d: forall t d v x, M.get x v = None -> map_getd_r t d (M.remove x v) v. unfold map_getd_r; intros. unfold getd. destruct (var_dec v0 x). subst. rewrite H. rewrite M.grs. reflexivity. rewrite M.gro. reflexivity. assumption. Qed. Theorem remove_set_1_d: forall t d x v e, map_getd_r t d (M.remove x (M.set x e v)) (M.remove x v). Proof. unfold map_getd_r; unfold getd; intros. destruct (var_dec v0 x). subst. rewrite M.grs. rewrite M.grs. reflexivity. rewrite M.gro. rewrite M.gso. rewrite M.gro. reflexivity. assumption. assumption. assumption. Qed. Theorem remove_set_2_d: forall t d x y v e, x <> y -> map_getd_r t d (M.remove x (M.set y e v)) (M.set y e (M.remove x v)). Proof. unfold map_getd_r; intros. unfold getd. destruct (var_dec v0 x). - subst. rewrite M.grs. rewrite M.gso. rewrite M.grs. reflexivity. assumption. - rewrite M.gro. 2: assumption. destruct (var_dec v0 y). + subst. rewrite M.gss. rewrite M.gss. reflexivity. + rewrite M.gso. rewrite M.gso. rewrite M.gro. reflexivity. assumption. assumption. assumption. Qed. Theorem remove_remove_d: forall t d x y sub, map_getd_r t d (M.remove x (M.remove y sub)) (M.remove y (M.remove x sub)). Proof. unfold map_getd_r; intros. unfold getd. destruct (var_dec v x); destruct (var_dec v y); subst. - subst. reflexivity. - rewrite M.grs. rewrite M.gro. rewrite M.grs. reflexivity. assumption. - rewrite M.gro. rewrite M.grs. rewrite M.grs. reflexivity. assumption. - rewrite M.gro. rewrite M.gro. rewrite M.gro. rewrite M.gro. reflexivity. assumption. assumption. assumption. assumption. Qed. Theorem set_set_d: forall t d e e' x y sub, x <> y -> map_getd_r t d (M.set x e (M.set y e' sub)) (M.set y e' (M.set x e sub)). Proof. unfold map_getd_r; intros. unfold getd. destruct (var_dec v x); destruct (var_dec v y); try (subst x || subst y). - exfalso; auto. - rewrite M.gss. rewrite M.gso. rewrite M.gss. reflexivity. assumption. - rewrite M.gso. rewrite M.gss. rewrite M.gss. reflexivity. assumption. - rewrite M.gso. rewrite M.gso. rewrite M.gso. rewrite M.gso. reflexivity. assumption. assumption. assumption. assumption. Qed. Theorem inv_set_d: forall t d e sub sub' v, map_getd_r t d (M.remove v sub) (M.remove v sub') -> map_getd_r t d (M.set v e sub) (M.set v e sub'). Proof. unfold map_getd_r; intros. unfold getd. specialize (H v0). destruct (var_dec v0 v). - subst. rewrite 2 M.gss. reflexivity. - rewrite 2 M.gso. unfold getd in H. rewrite 2 M.gro in H. assumption. assumption. assumption. assumption. assumption. Qed. Theorem set_remove_d: forall t d x e sub, map_getd_r t d (M.set x e (M.remove x sub)) (M.set x e sub). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor Functor.Functor_Ops. From Categories Require Import Cat.Cat. From Categories Require Import NatTrans.NatTrans.Local Open Scope nattrans_scope. Section Opposite_NatTrans. Context {C D : Category} {F F' : (C --> D)%functor} (N : (F --> F')%nattrans). Program Definition Opposite_NatTrans : F'^op --> F^op := {| Trans := Trans N; Trans_com := fun c c' h => (Trans_com_sym N h); Trans_com_sym := fun c c' h => (Trans_com N h) |}.End Opposite_NatTrans.Notation "N '^op'" := (Opposite_NatTrans N) : nattrans_scope. Section Compose_NOP. Context {C D : Category} {F F' F'' : (C --> D)%functor} (N : F --> F') (N' : F' --> F''). Theorem NatTrans_compose_Op : ((N' ‚àò N)^op = N^op ‚àò (N'^op))%nattrans. Proof. apply NatTrans_eq_simplify. trivial. Qed.End Compose_NOP. Section NatTrans_id_Op. Context {C D : Category} (F : (C --> D)%functor). Theorem NatTrans_id_Op : ((NatTrans_id F)^op)%nattrans = NatTrans_id (F^op)%functor. Proof. apply NatTrans_eq_simplify. trivial. Qed.End NatTrans_id_Op. Program Definition NatTrans_hor_comp {C D E : Category} {F G : (C --> D)%functor} {F' G' : (D --> E)%functor} (tr : F --> G) (tr' : F' --> G') : (F' ‚àò F) --> (G' ‚àò G) := {| Trans := fun c : Obj => ((G' _a (Trans tr c)) ‚àò (Trans tr' (F _o c)))%morphism |}.Next Obligation. Proof. rewrite assoc. rewrite Trans_com. rewrite assoc_sym. rewrite <- F_compose. rewrite Trans_com. rewrite F_compose. auto. Qed.Next Obligation. Proof. symmetry. apply NatTrans_hor_comp_obligation_1. Qed.Notation "N ‚àò_h N'" := (NatTrans_hor_comp N' N) : nattrans_scope. Section Hor_Compose_ids. Context {C D E : Category} (F : (C --> D)%functor) (G : (D --> E)%functor). Theorem NatTrans_hor_comp_ids : ((NatTrans_id G) ‚àò_h (NatTrans_id F))%nattrans = NatTrans_id (G ‚àò F). 
(xI i) v (M.Node l o r) = M.Node l o (M.set i v r). Proof. unfold M.set. destruct r; cbn; simpl; destruct l; destruct o; auto. Qed. Lemma xelements_set_node_xO {A} i (v : A) l o r : M.set (xO i) v (M.Node l o r) = M.Node (M.set i v l) o r. Proof. unfold M.set. destruct r; cbn; simpl; destruct l; destruct o; auto. Qed. Lemma xelements_set_node_xH {A} (v : A) l o r : M.set xH v (M.Node l o r) = M.Node l (Some v) r. Proof. unfold M.set. destruct r; cbn; simpl; destruct l; destruct o; auto. Qed. Theorem xelements_set_none: forall (A: Type) v (m: M.t A) i j, M.get i m = None -> exists l1 l2, M.xelements m j = app l1 l2 /\ M.xelements (M.set i v m) j = app l1 (cons (M.prev_append j i,v) l2). Proof. intros A v m. induction m using M.tree_ind; intros. - exists nil, nil. split; auto. cbn. unfold M.set; cbn. now rewrite xelements_set_leaf. - destruct i; simpl in *. + rewrite M.gNode in H0. rewrite xelements_set_node_xI, M.xelements_Node. apply IHm0 with (j:= xI j) in H0; do 3 (destruct H0). rewrite M.xelements_Node. cbn. rewrite H0. destruct o. * exists (M.xelements l (xO j) ++ ((M.prev j, a) :: x)), x0. split. cbn. now rewrite <- app_assoc. now rewrite <- app_assoc, H1. * exists ((M.xelements l (xO j)) ++ x), x0. split; auto. cbn. now rewrite <- app_assoc. now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. rewrite xelements_set_node_xO, !M.xelements_Node. apply IHm with (j := xO j) in H0; destructAll. destruct o as [a|]. * exists x, (x0 ++ ((M.prev j, a)::M.xelements r (xI j))). split; auto. now rewrite (app_assoc x x0), <- H0. cbn. now rewrite H1, <- app_assoc. * exists x, (x0 ++ M.xelements r (xI j)). split; auto. now rewrite (app_assoc x x0), <- H0. cbn. now rewrite H1, <- app_assoc. + rewrite M.gNode in H0. subst o. exists (M.xelements l (xO j)), (M.xelements r (xI j)). rewrite xelements_set_node_xH, !M.xelements_Node. split; auto. Qed. Theorem elements_set_none: forall (A: Type) v (m: M.t A) i , M.get i m = None -> exists l1 l2, M.elements m = l1 ++ l2 /\ M.elements (M.set i v m) = l1 ++ (i,v)::l2. Proof. unfold M.elements. intros. apply xelements_set_none with (v:= v) (j := xH) (m := m) in H. simpl in H. apply H. Qed. Theorem xelements_set_some: forall (A: Type) v v' (m: M.t A) i j, M.get i m = Some v' -> exists l1 l2, M.xelements m j = l1 ++ (M.prev_append j i,v')::l2 /\ M.xelements (M.set i v m) j = l1 ++ (M.prev_append j i,v)::l2. 
From Perennial.goose_lang.lib Require Import encoding. From Perennial.goose_lang Require Import crash_modality. From Perennial.goose_lang.lib Require Import into_val.From Goose.github_com.tchajed.goose.internal.examples Require Import append_log.From Perennial.program_proof Require Import disk_prelude. From Perennial.program_proof Require Import disk_lib. From Perennial.goose_lang.lib Require Import slice.crash_slice. From Perennial.program_proof Require Import marshal_block.Section heap. Context `{!heapGS Œ£}. Implicit Types v : val. Implicit Types z : Z. Implicit Types s : Slice.t. Implicit Types (stk:stuckness) (E: coPset). Local Opaque struct_mapsto.Definition is_hdr_block (sz disk_sz: u64) (b: Block) := block_encodes b [EncUInt64 sz; EncUInt64 disk_sz].Definition is_hdr (sz disk_sz: u64): iProp Œ£ := ‚àÉ b, 0 d‚Ü¶ b ‚àó ‚åúis_hdr_block sz disk_sz b‚åù.Definition is_log' (sz disk_sz: u64) (vs:list Block): iProp Œ£ := is_hdr sz disk_sz ‚àó 1 d‚Ü¶‚àó vs ‚àó ‚åúlength vs = int.nat sz‚åù ‚àó (‚àÉ (free: list Block), (1 + length vs) d‚Ü¶‚àó free ‚àó ‚åú (1 + length vs + length free)%Z = int.Z disk_sz ‚åù) .Definition log_fields (l:loc) (sz disk_sz: u64): iProp Œ£ := l ‚Ü¶[Log :: "sz"] #sz ‚àó l ‚Ü¶[Log :: "diskSz"] #disk_sz.Definition ptsto_log (l:loc) (vs:list Block): iProp Œ£ := ‚àÉ (sz: u64) (disk_sz: u64), log_fields l sz disk_sz ‚àó is_log' sz disk_sz vs.Theorem wp_mkHdr stk E lptr (sz disk_sz: u64) : {{{ log_fields lptr sz disk_sz }}} Log__mkHdr #lptr @ stk; E {{{ l cap b, RET (slice_val (Slice.mk l 4096 cap)); mapsto_block l 1 b ‚àó ‚åúis_hdr_block sz disk_sz b‚åù ‚àó log_fields lptr sz disk_sz }}}. Proof. iIntros (Œ¶) "[Hsz Hdisk_sz] HŒ¶". wp_call. wp_apply wp_new_enc. iIntros (enc) "Henc". wp_steps. wp_loadField. wp_apply (wp_Enc__PutInt with "Henc"); [ word | iIntros "Henc" ]. wp_steps. wp_loadField. wp_apply (wp_Enc__PutInt with "Henc"); [ word | iIntros "Henc" ]. wp_apply (wp_Enc__Finish with "[$Henc]"). iIntros (s b) "[%Henc Hs]". iDestruct (slice.is_slice_small_sz with "Hs") as %Hsz. rewrite length_Block_to_vals /block_bytes in Hsz. destruct s. replace sz0 with (U64 4096). { iApply "HŒ¶". iDestruct (slice_to_block with "Hs") as "Hb"; [ done | ]. iFrame. iPureIntro. rewrite /is_hdr_block /block_encodes. rewrite list_to_block_to_list; eauto. rewrite vec_to_list_length //. } simpl in Hsz. apply (inj int.Z); word. Qed. Theorem wpc_write_hdr_fupd stk k E1 lptr (sz0 disk_sz0 sz disk_sz:u64) : ‚àÄ Œ¶ Œ¶c, log_fields lptr sz disk_sz -‚àó (<disc> Œ¶c ‚àß is_hdr sz0 disk_sz0 ‚àó ‚ñ∑ (is_hdr sz disk_sz ‚àó log_fields lptr sz disk_sz ={E1}=‚àó <disc> Œ¶c ‚àß Œ¶ #())) -‚àó WPC Log__writeHdr #lptr @ stk; E1 {{ Œ¶ }} {{ Œ¶c }}. 
|- _ ] => edestruct H; eauto end. or_r; cancel. or_l; cancel. unfold items_valid, RALen in *; intuition. cancel. apply LOG.rep_hashmap_subset; auto. Unshelve. all: try exact tt; eauto. Qed. Hint Extern 1 ({{_}} Bind (get _ _ _ _ _) _) => apply get_ok : prog. Hint Extern 1 ({{_}} Bind (put _ _ _ _ _ _) _) => apply put_ok : prog. Hint Extern 1 ({{_}} Bind (extend _ _ _ _ _ _) _) => apply extend_ok : prog. Hint Extern 1 ({{_}} Bind (readall _ _ _ _) _) => apply readall_ok : prog. Hint Extern 1 ({{_}} Bind (init _ _ _ _ _) _) => apply init_ok : prog. Hint Extern 1 ({{_}} Bind (ifind _ _ _ _ _) _) => apply ifind_ok : prog. Definition get_array lxp ixp inum ix ms := r <- get lxp ixp inum ix ms; Ret r. Definition put_array lxp ixp inum ix item ms := r <- put lxp ixp inum ix item ms; Ret r. Definition extend_array lxp bxp ixp inum item ms := r <- extend lxp bxp ixp inum item ms; Ret r. Definition ifind_array lxp ixp inum cond ms := r <- ifind lxp ixp inum cond ms; Ret r. Theorem get_array_ok : forall lxp ixp bxp inum ix ms, {< F Fm Fi Fe m0 sm m flist f items e ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] * [[[ items ::: Fe * ix |-> e ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * [[ r = e ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSAllocC ms' = MSAllocC ms]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} get_array lxp ixp inum ix ms. Proof. unfold get_array. hoare. eapply list2nmem_ptsto_bound; eauto. subst; apply eq_sym. eapply list2nmem_sel; eauto. Qed. Theorem put_array_ok : forall lxp ixp bxp inum ix e ms, {< F Fm Fi Fe m0 sm m flist f items e0 ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[ Rec.well_formed e ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] * [[[ items ::: Fe * ix |-> e0 ]]] POST:hm' RET:ms' exists m' flist' f' items', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * [[[ m' ::: (Fm * BFILE.rep bxp sm ixp flist' ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[[ flist' ::: (Fi * inum |-> f') ]]] * [[[ RAData f' ::: rep f' items' ]]] * [[[ items' ::: Fe * ix |-> e ]]] * [[ items' = updN items ix e ]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} put_array lxp ixp inum ix e ms. 
(S p * S q' + S p' * S q) (S q * S q') (S p * S q' + S p' * S q + S q * S q'))); intros p3 Hex; elim Hex; intros q3 Heq3; rewrite Heq3; clear Hex. intros (Heq1, Heq2). elim (construct_correct2' (S p' * S q'' + S p'' * S q' + S q' * S q'') (S p' * S q'' + S p'' * S q') (S q' * S q'')). intros d'; elim (interp_non_zero (Qpositive_c (S p' * S q'' + S p'' * S q') (S q' * S q'') (S p' * S q'' + S p'' * S q' + S q' * S q''))); intros p4 Hex; elim Hex; intros q4 Heq6; rewrite Heq6; clear Hex. intros (Heq4, Heq5). apply construct_correct4'. simpl in |- *; auto with arith. simpl in |- *; auto with arith. simpl in |- *; auto with arith. simpl in |- *; auto with arith. auto. auto. unfold snd, fst in Heq5, Heq1, Heq2, Heq4, Heq5. apply mult_reg_l with d'. rewrite mult_plus_distr_r. rewrite (mult_comm (S d')). rewrite mult_plus_distr_r. repeat rewrite mult_assoc_reverse. rewrite <- Heq5. rewrite mult_plus_distr_r. rewrite (mult_comm (S d')). rewrite mult_plus_distr_r. rewrite (mult_comm (S p * S q4)). rewrite (mult_comm (S p4 * S q)). rewrite (mult_comm (S p4)). repeat rewrite <- mult_assoc. rewrite <- Heq5. rewrite <- Heq4. rewrite (mult_assoc (S p'')). rewrite <- (mult_comm (S q3)). rewrite <- mult_assoc. apply mult_reg_l with d. repeat rewrite (mult_comm (S d)); repeat rewrite mult_plus_distr_r; repeat rewrite <- (mult_comm (S d)); repeat rewrite (mult_assoc (S d)); repeat rewrite (mult_comm (S d)); rewrite <- Heq1; rewrite <- Heq2. ring. simpl in |- *; auto with arith. simpl in |- *; auto with arith. auto. simpl in |- *; auto with arith. simpl in |- *; auto with arith. auto. Qed. Definition Qpositive_mult (w w' : Qpositive) := match Qpositive_i w with | (p, q) => match Qpositive_i w' with | (p', q') => Qpositive_c (p * p') (q * q') (p * p' + q * q') end end. Theorem Qpositive_mult_One : forall w : Qpositive, Qpositive_mult One w = w. intros w; elim (interp_non_zero w); intros p Hex; elim Hex; intros q Heq. unfold Qpositive_mult in |- *. replace (Qpositive_i One) with (1, 1). rewrite Heq. repeat rewrite mult_1_l. apply construct_correct; auto with *. simpl in |- *; auto. Qed. Theorem Qpositive_mult_sym : forall w w' : Qpositive, Qpositive_mult w w' = Qpositive_mult w' w. 
selN_last; auto. eapply wordToNat_natToWord_bound; eauto. erewrite wordToNat_natToWord_bound; eauto. rewrite app_length; simpl; omega. + apply wle_le in n. erewrite wordToNat_natToWord_bound in n; eauto. repeat erewrite selN_oob with (def := None); try rewrite map_length; auto. rewrite app_length; simpl; intuition. rewrite Nat.add_1_r; apply lt_le_S. apply le_lt_or_eq in n; intuition. contradict n0; rewrite H0. apply wordToNat_inj. erewrite wordToNat_natToWord_bound; eauto. Qed. Theorem list2mem_app: forall A (F : @pred addr (@weq addrlen) A) l a (b : addr), length l <= wordToNat b -> F (list2mem l) -> (F * $ (length l) |-> a)%pred (list2mem (l ++ a :: nil)). Proof. intros. erewrite listapp_memupd; eauto. apply ptsto_upd_disjoint; auto. unfold list2mem, sel. rewrite selN_oob; auto. rewrite map_length. erewrite wordToNat_natToWord_bound; eauto. Qed. Theorem list2mem_removelast_is : forall A l (def : A) (b : addr), l <> nil -> length l <= wordToNat b -> list2mem (removelast l) = fun i => if (wlt_dec i $ (length l - 1)) then Some (sel l i def) else None. Proof. intros; apply functional_extensionality; intros. destruct (wlt_dec x $ (length l - 1)); unfold list2mem, sel. - assert (wordToNat x < length l - 1); apply wlt_lt in w. erewrite wordToNat_natToWord_bound with (bound:=b) in w by omega; auto. rewrite selN_map with (default' := def). rewrite selN_removelast by omega; auto. rewrite length_removelast by auto; omega. - rewrite selN_oob; auto. rewrite map_length. rewrite length_removelast by auto. apply wle_le in n. rewrite wordToNat_natToWord_bound with (bound:=b) in n by omega; auto. Qed. Theorem list2mem_removelast_list2mem : forall A (l : list A) (b : addr), l <> nil -> length l <= wordToNat b -> list2mem (removelast l) = fun i => if (weq i $ (length l - 1)) then None else (list2mem l) i. Proof. intros; apply functional_extensionality; intros. assert (exists def, firstn 1 l = def :: nil) as Hdef. destruct l; try congruence. exists a; eauto. destruct Hdef as [def _]. erewrite list2mem_removelast_is with (def := def) by eauto. unfold list2mem, sel. destruct (wlt_dec x $ (length l - 1)); destruct (weq x $ (length l - 1)); subst; intuition. apply wlt_lt in w; omega. erewrite selN_map with (default' := def); auto. apply wlt_lt in w; rewrite wordToNat_natToWord_bound with (bound:=b) in w by omega; omega. erewrite selN_oob; auto. rewrite map_length. assert ($ (length l - 1) < x)%word. destruct (weq $ (length l - 1) x); intuition. apply wlt_lt in H1; rewrite wordToNat_natToWord_bound with (bound:=b) in H1 by omega; omega. Qed. Theorem list2mem_removelast: forall A F (l : list A) v (b : addr), l <> nil -> length l <= wordToNat b -> (F * $ (length l - 1) |-> v)%pred (list2mem l) -> F (list2mem (removelast l)). 
cs')) m). Proof. unfold rep; intros. cancel. xform_normr. cancel. unfold pimpl, crash_xform; intros. eexists; split. eapply mem_pred_cachepred_refl; eauto. apply possible_crash_mem_match; auto. eapply possible_crash_trans. eauto. eapply mem_pred_possible_crash_trans; eauto. unfold size_valid in *; intuition. unfold addr_valid in *; intuition. eapply MapFacts.empty_in_iff; eauto. Qed. Lemma crash_xform_rep_r_pred : forall cs m (F : pred), (crash_xform F)%pred m -> rep cs m =p=> exists m', crash_xform (rep (cache0 (CSMaxCount cs)) m') * [[ F m' ]]. Proof. intros. unfold crash_xform in H; deex. rewrite crash_xform_rep_r by eauto. cancel. Qed. Definition init_load := init. Definition init_recover := init. Lemma sync_xform_cachepred : forall m a vs, sync_xform (cachepred m a vs) =p=> exists v, [[ In v (vsmerge vs) ]] * a |=> v. Proof. unfold cachepred; intros. case_eq (Map.find a m); intros; try destruct p, b. - rewrite sync_xform_exists_comm. apply pimpl_exists_l; intro. rewrite sync_xform_sep_star_dist, sync_xform_lift_empty. rewrite sync_xform_ptsto_subset_precise; simpl. cancel. apply in_cons; auto. - rewrite sync_xform_sep_star_dist, sync_xform_lift_empty. rewrite sync_xform_ptsto_subset_precise; simpl. cancel. - rewrite sync_xform_ptsto_subset_precise; cancel. Qed. Lemma sync_xform_mem_pred_cachepred : forall cm m, sync_xform (mem_pred (cachepred cm) m) =p=> exists m', mem_pred (cachepred (Map.empty (valu * bool))) m' * [[ possible_crash m m' ]]. Proof. intros. rewrite sync_xform_mem_pred. unfold mem_pred at 1. xform_norm; subst. rename hm_avs into l. revert H; revert l. induction l; simpl; intros. cancel. apply mem_pred_empty_mem. unfold possible_crash; intuition. inversion H; destruct a; subst; simpl in *. unfold mem_pred_one; simpl. rewrite IHl by auto. xform_norm. rewrite sync_xform_cachepred. norml; unfold stars; simpl. apply pimpl_exists_r. exists (upd m' n (v, nil)). rewrite <- mem_pred_absorb. unfold cachepred at 3; unfold ptsto_subset. rewrite MapFacts.empty_o; cancel. erewrite <- notindomain_mem_eq; auto. eapply possible_crash_notindomain; eauto. apply avs2mem_notindomain; auto. apply possible_crash_upd; eauto. Qed. Theorem init_recover_ok : forall cachesize, {< d F, PRE:hm exists cs, rep cs d * [[ F d ]] * [[ cachesize <> 0 ]] POST:hm' RET:cs exists d', rep cs d' * [[ (crash_xform F) d' ]] CRASH:hm' exists cs, rep cs d >} init_recover cachesize. Proof. unfold init_recover, init, rep. step. prestep; norml; unfold stars; simpl. rewrite sync_xform_sep_star_dist. rewrite sync_xform_mem_pred_cachepred; norm. cancel. rewrite sync_xform_sync_invariant; auto. intuition eauto. unfold size_valid in *; intuition. unfold addr_valid in *; intuition. eapply MapFacts.empty_in_iff; eauto. unfold crash_xform; eexists; eauto. Qed. Hint Extern 1 ({{_}} Bind (init_recover _) _) => apply init_recover_ok : prog. Lemma sync_xform_arrayS : forall l start, sync_xform (arrayS start l) =p=> arrayS start l. Proof. induction l; simpl; intros. rewrite sync_xform_emp; cancel. rewrite sync_xform_sep_star_dist. rewrite sync_xform_ptsto_subset_preserve. rewrite IHl. cancel. Qed. Theorem init_load_ok : forall cachesize, {!< disk, PRE:vm,hm arrayS 0 disk * [[ cachesize <> 0 ]] POST:vm',hm' RET:cs exists d, rep cs d * [[ arrayS 0 disk d ]] * [[ vm' = vm ]] CRASH:hm' arrayS 0 disk >!} init_load cachesize. 
right; case n0; trivial. case n0; simpl in |- *. auto. intro n1; elim (IHl n1); auto. Qed. Lemma nth_S_cons : forall (n:nat) (l:list A) (d a:A), In (nth n l d) l -> In (nth (S n) (a :: l) d) (a :: l). Proof. simpl in |- *; auto. Qed. Fixpoint nth_error (l:list A) (n:nat) {struct n} : Exc A := match n, l with | O, x :: _ => value x | S n, _ :: l => nth_error l n | _, _ => error end. Definition nth_default (default:A) (l:list A) (n:nat) : A := match nth_error l n with | Some x => x | None => default end. Lemma nth_In : forall (n:nat) (l:list A) (d:A), n < length l -> In (nth n l d) l. Proof. unfold lt in |- *; induction n as [| n hn]; simpl in |- *. destruct l; simpl in |- *; [ inversion 2 | auto ]. destruct l as [| a l hl]; simpl in |- *. inversion 2. intros d ie; right; apply hn; auto with arith. Qed. Lemma nth_overflow : forall l n d, length l <= n -> nth n l d = d. Proof. induction l; destruct n; simpl; intros; auto. inversion H. apply IHl; auto with arith. Qed. Lemma nth_indep : forall l n d d', n < length l -> nth n l d = nth n l d'. Proof. induction l; simpl; intros; auto. inversion H. destruct n; simpl; auto with arith. Qed. Lemma app_nth1 : forall l l' d n, n < length l -> nth n (l++l') d = nth n l d. Proof. induction l. intros. inversion H. intros l' d n. case n; simpl; auto. intros; rewrite IHl; auto with arith. Qed. Lemma app_nth2 : forall l l' d n, n >= length l -> nth n (l++l') d = nth (n-length l) l' d. Proof. induction l. intros. simpl. destruct n; auto. intros l' d n. case n; simpl; auto. intros. inversion H. intros. rewrite IHl; auto with arith. Qed. Section Remove. Hypothesis eq_dec : forall x y : A, {x = y}+{x <> y}. Fixpoint remove (x : A) (l : list A){struct l} : list A := match l with | nil => nil | y::tl => if (eq_dec x y) then remove x tl else y::(remove x tl) end. Theorem remove_In : forall (l : list A) (x : A), ~ In x (remove x l). 
forall x y z : E, x + z = y + z -> x = y. Proof fun x y z => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z). Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof fun x => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x). Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof fun x => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x). Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Monoid.op_inv_uniq op_monoid. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof fun x => ex_ind (fun y (H : op_is_inv x y) => ex_intro (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z) y (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0)))) (op_inv_ex x). Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Monoid.op_inv_0_l op_monoid. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Monoid.op_inv_0_r op_monoid. Theorem op_inv_0 : op_is_inv 0 0. Proof Monoid.op_inv_0 op_monoid. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Monoid.op_has_inv_l_0 op_monoid. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Monoid.op_has_inv_r_0 op_monoid. Theorem op_has_inv_0 : has_inv 0. Proof Monoid.op_has_inv_0 op_monoid. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Monoid.op_inv_0_eq_0 op_monoid. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Monoid.op_inv_0_uniq op_monoid. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := fun x => Monoid.op_neg_strong op_monoid x (op_inv_ex x). Definition op_neg : E -> E := fun x => Monoid.op_neg op_monoid x (op_inv_ex x).Notation "{-}" := (op_neg) : group_scope.Notation "- x" := (op_neg x) : group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof fun x => Monoid.op_neg_def op_monoid x (op_inv_ex x).Theorem op_neg_inj : is_injective E E op_neg. Proof fun x y => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y). Theorem op_cancel_neg : forall x : E, - (- x) = x. Proof fun x => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)). Theorem op_neg_onto : is_onto E E {-}. Proof fun x => ex_intro (fun y => - y = x) (- x) (op_cancel_neg x). Theorem op_neg_bijective : is_bijective E E {-}. Proof conj op_neg_inj op_neg_onto. Theorem op_neg_rev : forall x y : E, - x = y -> - y = x. 
LabelKey.compare' string_lt fst snd string_dec sumbool_rec sumbool_rect Ascii.N_of_ascii Ascii.N_of_digits N.compare Pos.compare string_rec string_rect Ascii.ascii_dec LabelMap.find LabelMap.Raw.find Nplus Nmult Pos.compare_cont Pos.add Pos.mul Ascii.ascii_rec Ascii.ascii_rect Bool.bool_dec bool_rec bool_rect eq_rec_r eq_rec eq_rect eq_sym label'_lt label'_eq label'_rec label'_rect LabelMap.Raw.bal LabelMap.Raw.create Int.Z_as_Int.gt_le_dec Int.Z_as_Int.plus Int.Z_as_Int.ge_lt_dec LabelMap.Raw.height ZArith_dec.Z_gt_le_dec Int.Z_as_Int._0 BinInt.Z.add Int.Z_as_Int._1 Int.Z_as_Int._2 ZArith_dec.Z_gt_dec ZArith_dec.Z_ge_lt_dec Int.Z_as_Int.max BinInt.Z.max BinInt.Z.compare BinInt.Z.ltb union ZArith_dec.Z_ge_dec diff LabelMap.mem LabelMap.Raw.mem LabelMap.is_empty LabelMap.Raw.is_empty Pos.succ].Ltac link m1 m2 := apply linkOk; [ apply m1 | apply m2 | exact (refl_equal true) | link_simp; tauto | link_simp; tauto | link_simp; tauto ].Lemma specs_cong : forall (specs : codeSpec W (settings * state)) x p, specs x = p -> forall y, x = y -> specs y = p. congruence. Qed.Implicit Arguments specs_cong [specs x p y].Hint Extern 1 (?specs _ = Some _) => match goal with | [ H : specs _ = Some _ |- _ ] => apply (specs_cong H); congruence end.Lemma use_himp : forall pc state specs (P Q : hprop pc state nil), himp specs P Q -> forall s m, interp specs (P s m) -> interp specs (Q s m). intros; apply (Imply_sound (H _ _)); auto. Qed.Lemma Imply_refl : forall pc state specs (P : PropX pc state), interp specs (P ---> P). intros; apply Imply_I; apply Env; simpl; auto. Qed.Section PropX. Variables pc state : Type. Variable P : PropX pc state. Variable specs : codeSpec pc state. Open Scope PropX_scope. Theorem injL : forall (p : Prop), (p -> interp specs P) -> interp specs ([| p |] ---> P). intros. apply Imply_I. eapply Inj_E. eauto. auto. Qed. Theorem cptrL : forall i a, (specs i = Some (fun x => a x) -> interp specs P) -> interp specs (Cptr i a ---> P). intros. apply Imply_I. eapply Cptr_E. eauto. eauto. Qed. Theorem andL : forall Q R, interp specs (Q ---> (R ---> P)) -> interp specs (Q /\ R ---> P). intros. apply Imply_I. eapply Imply_E. eapply Imply_E. eauto. eapply And_E1. eauto. eapply And_E2. eauto. Qed. Ltac hyp := eapply Env; simpl; eauto. Theorem existsL : forall A (p : A -> _), (forall x, interp specs (p x ---> P)) -> interp specs ((Exists p) ---> P). intros. apply Imply_I. eapply Exists_E. eauto. intros. eapply Imply_E. eauto. hyp. Qed. Theorem injR : forall (p : Prop), p -> interp specs (P ---> [| p |]). intros. apply Imply_I. eapply Inj_I. auto. Qed. Theorem cptrR : forall i a, specs i = Some (fun x => a x) -> interp specs (P ---> Cptr i a). 
(S n0) | None => None end end end%bs. Fixpoint length (l : t) : nat := match l with | EmptyString => 0 | String _ l => S (length l) end. Local Fixpoint contains (start: nat) (keys: list t) (fullname: t) :bool := match keys with | List.cons kh ktl => match index start kh fullname with | Some n => contains (n + length kh) ktl fullname | None => false end | List.nil => true end. Fixpoint eqb (a b : t) : bool := match a , b with | EmptyString , EmptyString => true | String x xs , String y ys => if ByteCompare.eqb x y then eqb xs ys else false | _ , _ => false end. Fixpoint compare (xs ys : t) : comparison := match xs , ys with | EmptyString , EmptyString => Eq | EmptyString , _ => Lt | _ , EmptyString => Gt | String x xs , String y ys => match ByteCompare.compare x y with | Eq => compare xs ys | x => x end end. Lemma eqb_compare xs ys : eqb xs ys = match compare xs ys with Eq => true | _ => false end. Proof. induction xs in ys |- *; destruct ys => /= //. rewrite ByteCompareSpec.eqb_compare. destruct ByteCompare.compare => //. Qed. Fixpoint concat (sep : t) (s : list t) : t := match s with | nil => EmptyString | cons s nil => s | cons s xs => s ++ sep ++ concat sep xs end.End String.Definition bs := String.t. Notation string := String.t.Bind Scope bs_scope with bs.String Notation String.t String.parse String.print : bs_scope.Notation "x ++ y" := (String.append x y) : bs_scope. Import String. Require Import Orders Coq.Structures.OrderedType.Lemma to_N_inj : forall x y, Byte.to_N x = Byte.to_N y <-> x = y. Proof. split. 2: destruct 1; reflexivity. intros. assert (Some x = Some y). { do 2 rewrite <- Byte.of_to_N. destruct H. reflexivity. } injection H0. auto. Qed.Module OT_byte <: OrderedType.OrderedType with Definition t := Byte.byte. Definition t := Byte.byte. Definition eq := @Logic.eq t. Definition lt := fun l r => ByteCompare.compare l r = Lt. Theorem eq_refl : forall x : t, eq x x. Proof. intros; apply eq_refl. Qed. Theorem eq_sym : forall x y : t, eq x y -> eq y x. Proof. apply eq_sym. Qed. Theorem eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z. 
Require Import ProofIrrelevance. Require Import Description. Require Import base. Require Import function. Require Import monoid.Module Group. Structure Group : Type := group { E: Set; E_0: E; op: E -> E -> E; op_is_assoc : Monoid.is_assoc E op; op_id_l : Monoid.is_id_l E op E_0; op_id_r : Monoid.is_id_r E op E_0; op_inv_l_ex : forall x : E, exists y : E, Monoid.is_inv_l E op E_0 (conj op_id_l op_id_r) x y; op_inv_r_ex : forall x : E, exists y : E, Monoid.is_inv_r E op E_0 (conj op_id_l op_id_r) x y }.Arguments E_0 {g}.Arguments op {g} x y.Arguments op_is_assoc {g} x y z.Arguments op_id_l {g} x.Arguments op_id_r {g} x.Arguments op_inv_l_ex {g} x.Arguments op_inv_r_ex {g} x.Notation "0" := E_0 : group_scope.Notation "x + y" := (op x y) (at level 50, left associativity) : group_scope.Notation "{+}" := op : group_scope.Open Scope group_scope.Section Theorems. Variable g : Group. Let E := E g. Definition op_monoid := Monoid.monoid E 0 {+} op_is_assoc op_id_l op_id_r. Definition op_is_id_l := Monoid.op_is_id_l op_monoid. Definition op_is_id_r := Monoid.op_is_id_r op_monoid. Definition op_is_id := Monoid.op_is_id op_monoid. Theorem op_id : op_is_id 0. Proof Monoid.op_id op_monoid. Definition op_is_inv_l := Monoid.op_is_inv_l op_monoid. Definition op_is_inv_r := Monoid.op_is_inv_r op_monoid. Theorem op_id_l_uniq : forall x : E, (op_is_id_l x) -> x = 0. Proof Monoid.op_id_l_uniq op_monoid. Theorem op_id_r_uniq : forall x : E, (op_is_id_r x) -> x = 0. 
v, p1 a v =p=> p2 a v) -> @mem_pred LA LEQ LV HA HEQ HV p1 hm =p=> mem_pred p2 hm. Proof. unfold mem_pred; intros. cancel; eauto. subst. induction hm_avs; simpl; intros; auto. unfold mem_pred_one at 1 3; simpl. rewrite H. cancel. eapply IHhm_avs. inversion H0; eauto. Qed.Theorem mem_pred_pimpl_except : forall LA LEQ LV HA HEQ HV hm p1 p2 a', (forall a v, a <> a' -> p1 a v =p=> p2 a v) -> @mem_pred LA LEQ LV HA HEQ HV p1 (mem_except hm a') =p=> mem_pred p2 (mem_except hm a'). Proof. unfold mem_pred; intros. cancel; eauto. assert (~ In a' (map fst hm_avs)). eapply avs2mem_none_notin. rewrite <- H3. rewrite mem_except_eq. auto. clear H3 hm. induction hm_avs; simpl; intros; auto. unfold mem_pred_one at 1 3; simpl. rewrite H. cancel. eapply IHhm_avs; eauto. inversion H0; eauto. destruct a; firstorder. Qed. Theorem mem_pred_absent_hm : forall A AEQ LV HV p hm m a, m a = None -> (forall a v, p a v =p=> exists v', a |-> v') -> @mem_pred A AEQ LV A AEQ HV p hm m -> hm a = None. Proof. intros. case_eq (hm a); intros; auto. eapply mem_pred_extract in H1; eauto. rewrite H0 in H1; destruct_lift H1. apply ptsto_valid' in H1; congruence. Qed.Theorem mem_pred_absent_lm : forall A AEQ LV HV p hm m a, hm a = None -> (forall a v, p a v =p=> exists v', a |-> v') -> @mem_pred A AEQ LV A AEQ HV p hm m -> m a = None. Proof. intros. unfold mem_pred, mem_pred_one in H1. destruct_lift H1. apply avs2mem_none_notin in H. generalize dependent m. induction dummy; simpl in *; intros. - apply emp_empty_mem_only in H1; subst. firstorder. - destruct a0; simpl in *. rewrite H0 in H1. destruct (AEQ a0 a); try solve [ exfalso; eauto ]. destruct_lift H1. generalize dependent H1. unfold_sep_star; intros; repeat safedeex. inversion H3. unfold ptsto, mem_union in H1. intuition; subst. match goal with | [ H : forall _, _ -> m1 _ = None |- _ ] => rewrite H end; eauto. Qed. Theorem xform_mem_pred : forall prd (hm : rawdisk), crash_xform (@mem_pred _ addr_eq_dec _ _ addr_eq_dec _ prd hm) <=p=> @mem_pred _ addr_eq_dec _ _ addr_eq_dec _ (fun a v => crash_xform (prd a v)) hm. Proof. unfold mem_pred; intros; split. xform_norm; subst. rewrite xform_listpred. cancel. cancel; subst. xform_normr; cancel. rewrite xform_listpred. cancel. eauto. Qed. Theorem sync_xform_mem_pred : forall prd (hm : rawdisk), sync_xform (@mem_pred _ addr_eq_dec _ _ addr_eq_dec _ prd hm) <=p=> @mem_pred _ addr_eq_dec _ _ addr_eq_dec _ (fun a v => sync_xform (prd a v)) hm. 
*; (repeat exists 0; auto; fail) || (intros w' Hrec; elim Hrec; intros p' Hex; elim Hex; intros q' Heq; rewrite Heq). exists (p' + S q'); exists q'; auto. exists p'; exists (p' + S q'); auto. Qed. Fixpoint Qpositive_c (p q n : nat) {struct n} : Qpositive := match n with | O => One | S n' => match p - q with | O => match q - p with | O => One | v => dL (Qpositive_c p v n') end | v => nR (Qpositive_c v q n') end end. Theorem minus_O_le : forall n m : nat, n - m = 0 -> n <= m. intros n; elim n; clear n. auto with arith. intros n Hrec m; case m; clear m. simpl in |- *; intros Heq; discriminate Heq. simpl in |- *; intros; apply le_n_S; apply Hrec; auto. Qed. Theorem le_minus_O : forall n m : nat, n <= m -> n - m = 0. intros n; elim n; clear n. simpl in |- *; auto. intros n Hrec m; case m; clear m. intros Hle; inversion Hle. intros m' Hle; simpl in |- *; apply Hrec; auto with arith. Qed. Theorem minus_le : forall m n : nat, m - n <= m. intros m; elim m. simpl in |- *; auto. intros m' Hrec n; case n; simpl in |- *; auto. Qed. Theorem mult_reg_l : forall n m p : nat, S n * m = S n * p -> m = p. intros n m; elim m; clear m. intros p; case p; simpl in |- *. auto. intros p'; rewrite <- mult_n_O. intros H; discriminate H. intros m' Hrec p; case p. rewrite <- mult_n_O; simpl in |- *; intros H; discriminate H. intros p'; repeat rewrite (mult_comm (S n)); simpl in |- *. intros H; injection H. intros H'; apply f_equal with (f := S). apply Hrec. repeat rewrite (mult_comm (S n)). apply plus_reg_l with n. exact H'. Qed. Theorem absolu_inj_nat : forall x : nat, Z.abs_nat (Z_of_nat x) = x. intros x; case x. auto. simpl in |- *. exact nat_of_P_o_P_of_succ_nat_eq_succ. Qed. Theorem absolu_mult : forall x y : Z, Z.abs_nat (x * y) = Z.abs_nat x * Z.abs_nat y. intros x; case x; auto; intros p y; case y; auto; simpl in |- *; intros; apply nat_of_P_mult_morphism. Qed. Theorem Qpositive_c_unfold1 : forall p q n : nat, S p + S q + S q <= S n -> Qpositive_c (S p + S q) (S q) (S n) = nR (Qpositive_c (S p) (S q) n). 
"HŒ¶". iFrame "Hdurable_frag". iExists ‚à , false. rewrite !fmap_empty. iFrame "Hctx". iFrame "‚àó#". auto with iFrame. Qed. Theorem wp_Op__Begin (l_txn: loc) Œ≥ dinit : {{{ is_txn l_txn Œ≥.(jrnl_txn_names) dinit ‚àó is_txn_system N Œ≥ }}} Begin #l_txn {{{ Œ≥txn l, RET #l; is_jrnl N l Œ≥ dinit Œ≥txn (Œª _, emp) }}}. Proof. iIntros (Œ¶) "Hpre HŒ¶". wp_apply (wp_Op__Begin' with "Hpre"). iIntros (???) "[? ?]". iNamed. iApply "HŒ¶". iExists Œ≥durable. iFrame. iExists ‚à . rewrite !big_sepM_empty. iFrame "‚àó#". auto with iFrame. Qed. Definition is_object l a obj: iProp Œ£ := ‚àÉ dirty, is_buf l a {| bufKind := objKind obj; bufData := objData obj; bufDirty := dirty |}. Theorem wp_Op__ReadBuf l Œ≥ dinit Œ≥txn Œ≥durable (a: addr) (sz: u64) obj : bufSz (objKind obj) = int.nat sz ‚Üí {{{ is_jrnl_mem N l Œ≥ dinit Œ≥txn Œ≥durable ‚àó jrnl_maps_to Œ≥txn a obj }}} Op__ReadBuf #l (addr2val a) #sz {{{ dirty (bufptr:loc), RET #bufptr; is_buf bufptr a (Build_buf _ (objData obj) dirty) ‚àó (‚àÄ (obj': bufDataT (objKind obj)) dirty', is_buf bufptr a (Build_buf _ obj' dirty') -‚àó ‚åúdirty' = true ‚à® (dirty' = dirty ‚àß obj' = objData obj)‚åù ==‚àó is_jrnl_mem N l Œ≥ dinit Œ≥txn Œ≥durable ‚àó jrnl_maps_to Œ≥txn a (existT (objKind obj) obj')) }}}. Proof. iIntros (? Œ¶) "Hpre HŒ¶". iDestruct "Hpre" as "[Hjrnl Ha]". iNamed "Hjrnl". iDestruct (map_valid with "Htxn_ctx Ha") as %Hmt_lookup. fmap_Some in Hmt_lookup as vo. wp_apply (mspec.wp_Op__ReadBuf with "[$Hjrnl]"). { iPureIntro. split; first by eauto. rewrite H. word. } iIntros (??) "[Hbuf Hbuf_upd]". iApply "HŒ¶". iFrame "Hbuf". iIntros (obj' dirty') "Hbuf". iIntros (Hdirty). iMod ("Hbuf_upd" with "[$Hbuf]") as "Hjrnl". { iPureIntro; intuition auto. } intuition subst. - iMod (map_update with "Htxn_ctx Ha") as "[Htxn_ctx $]". iModIntro. iExists (<[a:=mspec.mkVersioned (objData (mspec.committed vo)) obj']> mT), true. iFrame "Htxn_system". rewrite !fmap_insert !mspec.committed_mkVersioned !mspec.modified_mkVersioned //. change (existT (objKind ?x) (objData ?x)) with x. rewrite (insert_id (mspec.committed <$> mT)); last first. { rewrite lookup_fmap Hmt_lookup //. } rewrite orb_true_r. iFrame "#‚àó". iPureIntro; intros; congruence. - iModIntro. simpl. rewrite insert_id; last first. { rewrite Hmt_lookup. destruct vo as [K [c m]]; done. } iFrame "Ha". iExists mT, _. iFrameNamed. iPureIntro. destruct anydirty; eauto. Qed. Definition data_has_obj (data: list byte) (a:addr) obj : Prop := match objData obj with | bufBit b => ‚àÉ b0, data = [b0] ‚àß get_bit b0 (word.modu (addrOff a) 8) = b | bufInode i => vec_to_list i = data | bufBlock b => vec_to_list b = data end. Theorem data_has_obj_to_buf_data s a obj data : data_has_obj data a obj ‚Üí is_slice_small s u8T 1 data -‚àó is_buf_data s (objData obj) a. 
F). Proof. repeat intro. apply hlist_gen_ext. auto. Qed.Lemma equiv_hlist_gen : forall T (F : T -> Type) (f : forall t, F t) f' (R : forall t, F t -> F t -> Prop), (forall t, R t (f t) (f' t)) -> forall ls, equiv_hlist R (hlist_gen f ls) (hlist_gen f' ls). Proof. induction ls; simpl; constructor; auto. Qed.Global Instance Proper_equiv_hlist_gen : forall A (F : A -> Type) R, Proper (forall_relation R ==> forall_relation (@equiv_hlist _ _ R)) (@hlist_gen A F). Proof. repeat intro. apply equiv_hlist_gen. auto. Qed.Fixpoint hlist_erase {A B} {ls : list A} (hs : hlist (fun _ => B) ls) : list B := match hs with | Hnil => nil | Hcons _ _ x hs' => cons x (hlist_erase hs') end.Lemma hlist_erase_hlist_gen : forall A B ls (f : A -> B), hlist_erase (hlist_gen f ls) = map f ls. Proof. induction ls; simpl; intros; f_equal; auto. Qed. Section hlist_Forall. Variable A : Type. Variable P : A -> Prop. Fixpoint hlist_Forall ls (hs : hlist P ls) : Forall P ls := match hs with | Hnil => Forall_nil _ | Hcons _ _ H hs' => Forall_cons _ H (hlist_Forall hs') end.End hlist_Forall.Section hlist_rel. Variable A : Type. Variables F G : A -> Type. Variable R : forall x : A, F x -> G x -> Prop. Inductive hlist_hrel : forall ls, hlist F ls -> hlist G ls -> Prop := | hrel_Hnil : hlist_hrel Hnil Hnil | hrel_Hcons : forall t ts x y xs ys, @R t x y -> @hlist_hrel ts xs ys -> @hlist_hrel (t :: ts) (Hcons x xs) (Hcons y ys).End hlist_rel.Section hlist_rel_map. Variable A : Type. Variables F G F' G' : A -> Type. Variable R : forall x : A, F x -> G x -> Prop. Variable R' : forall x : A, F' x -> G' x -> Prop. Variable ff : forall x : A, F x -> F' x. Variable gg : forall x : A, G x -> G' x. Hypothesis R_ff_R' : forall t x y, @R t x y -> @R' t (ff x) (gg y). Theorem hlist_hrel_map : forall ls xs ys, @hlist_hrel A F G R ls xs ys -> @hlist_hrel A F' G' R' ls (hlist_map ff xs) (hlist_map gg ys). Proof. induction 1; simpl; constructor; eauto. Qed. Theorem hlist_hrel_cons : forall l ls x xs y ys, @hlist_hrel A F G R (l :: ls) (Hcons x xs) (Hcons y ys) -> @R l x y /\ @hlist_hrel A F G R ls xs ys. 
l1)) -> b = F x a)) in H0. eauto. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. intuition. simpl in *. intuition. trivial. assert (b0 = F x l). eapply H6. trivial. eapply H6 in H5. subst. rewrite H7. rewrite eqbBvector_complete. trivial. comp_simp. rewrite eqb_refl. simpl. eapply comp_spec_eq_refl. Qed. Theorem G2_3_4_close : | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <= Adv_WCR _ _ F (Rnd k) au_F_A. eapply leRat_trans. eapply fundamental_lemma_h. eapply G2_3_4_bad_eq . eapply G2_3_4_eq_until_bad. rewrite G2_3_bad_equiv. rewrite G2_3_bad_small. intuition. Qed. Definition G2_5 := [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil; ret b. Theorem G2_4_5_equiv : Pr[x <-$ G2_4; ret fst x] == Pr[G2_5]. unfold G2_4, G2_5. inline_first. comp_irr_l. wftac. inline_first. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a (z, (F x z)) = arrayLookup _ b z)). intuition. intuition. unfold randomFunc_mem. rewrite H0. case_eq ( arrayLookup (list_EqDec (Bvector_EqDec b)) x2 a); intuition. eapply comp_spec_ret; intuition. simpl in *. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H3. subst. rewrite eqbBvector_complete. trivial. simpl. eauto. comp_skip. apply (oneVector c). apply (oneVector c). eapply comp_spec_ret; intuition. simpl. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H5. subst. rewrite eqbBvector_complete. trivial. simpl. trivial. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G2_5_equiv : Pr[G2_5] == Pr[G2]. unfold G2_5, G2. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a z = arrayLookup _ b z)). intuition. intuition. eapply randomFunc_mem_spec. intuition. simpl in *. intuition. subst. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_equiv : | Pr[G1] - Pr[G2] | <= Adv_WCR _ _ F (Rnd k) au_F_A. rewrite G2_1_equiv. rewrite G2_1_2_equiv. rewrite G2_2_3_equiv. rewrite <- G2_5_equiv. rewrite <- G2_4_5_equiv. eapply G2_3_4_close. Qed. Theorem G2_equiv : Pr[G2] == Pr[PRF_G_B ({0, 1}^c) _ _ A]. reflexivity. Qed. Theorem hF_PRF : PRF_Advantage ({0, 1}^(c + k)) ({0, 1}^c) hF _ _ A <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A + Adv_WCR _ _ F (Rnd k) au_F_A. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.CandidatesVoteForSelvesInterface.Section CandidatesVoteForSelvesProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Ltac rewrite_state := match goal with | [st : name -> raft_data, H : forall _, ?st _ = _ |- _] => rewrite H in * end. Ltac t := repeat break_match; simpl in *; try find_inversion; rewrite_state; try use_applyEntries_spec; repeat break_if; subst; eauto; simpl in *; try discriminate. Theorem candidates_vote_for_selves_do_leader : raft_net_invariant_do_leader (candidates_vote_for_selves). 
unfold red in |- *; simpl in |- *. intros x Cx x0 Cx0 aL H'1; inversion H'1. cut (canonical A0 eqA ltM (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cx Cx0)); [ intros Op1 | apply spolyf_canonical with (1 := cs) ]; auto. cut (canonical A0 eqA ltM (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x0 x Cx0 Cx)); [ intros Op2 | apply spolyf_canonical with (1 := cs) ]; auto. apply reducestar0; auto. apply reduceplus_eqp_com with (1 := cs) (p := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec x x0 Cx Cx0)) (q := mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (pO A n)); auto. apply reduceplus_mults with (1 := cs); auto. inversion H; auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply spolyf_com with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply spolyf_com with (1 := cs); auto. Qed. Theorem rstar_rtopO : forall (Q : list (poly A0 eqA ltM)) (p : list (Term A n)), canonical A0 eqA ltM p -> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (pO A n) -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (pO A n). intros Q p H' H'0. elim reduce0_reducestar with (1 := cs) (eqA_dec := eqA_dec) (ltM_dec := ltM_dec) (Q := Q) (p := pO A n); auto. intros t E; apply reducestar0; auto. apply pO_irreducible; auto. Qed. Definition spO : poly A0 eqA ltM. exists (pO A n); simpl in |- *; auto. Defined. Definition sp1 : poly A0 eqA ltM. exists (pX (A1, M1 n) nil); auto. Defined. Definition sgen : nat -> poly A0 eqA ltM. intros m; exists (pX (A1, gen_mon n m) (pO A n)). apply canonicalp1; auto. Defined. Definition sscal : A -> poly A0 eqA ltM -> poly A0 eqA ltM. intros a p; case p. intros x H'1; exists (tmults A0 multA eqA_dec (a, M1 n) x); auto. unfold tmults in |- *; case (zeroP_dec A A0 eqA eqA_dec n (a, M1 n)); simpl in |- *; auto. Qed. Theorem red_cons : forall (a : poly A0 eqA ltM) (p : list (poly A0 eqA ltM)), In a p -> red a p. 
n = nat_decomp_nat (S (S radix)) ms}) (fun n (F : forall r, r < n -> {ms : list nat | Forall (fun m => m < (S (S radix))) ms /\ r = nat_decomp_nat (S (S radix)) ms}) => nat_rec (fun q => q = Nat.div n (S (S radix)) -> {ms : list nat | Forall (fun m => m < (S (S radix))) ms /\ n = nat_decomp_nat (S (S radix)) ms}) (fun H : 0 = Nat.div n (S (S radix)) => let H0 : n = nat_decomp_nat (S (S radix)) [n mod (S (S radix))] := ltac:( lazy [nat_decomp_nat list_rec list_rect]; rewrite (Nat.mul_0_r (S (S radix))); rewrite (Nat.add_0_l _); apply (div0_mod n (S (S radix)) (Nat.neq_succ_0 (S radix)) H)) in exist (fun ms => Forall (fun m => m < (S (S radix))) ms /\ n = nat_decomp_nat (S (S radix)) ms) [n mod (S (S radix))] (conj (Forall_cons (n mod (S (S radix))) (Nat.mod_upper_bound n (S (S radix)) (Nat.neq_succ_0 (S radix))) (Forall_nil (fun m => m < S (S radix)))) H0)) (fun q _ (H : S q = Nat.div n (S (S radix))) => let (ms, H0) := F (S q) (eq_ind_r (fun x => x < n) (Nat.div_lt n (S (S radix)) (or_ind (fun H0 : 0 < n => H0) (fun H0 : 0 = n => False_ind (0 < n) (let H2 : Nat.div n (S (S radix)) = 0 := eq_ind 0 (fun x => Nat.div x (S (S radix)) = 0) (Nat.div_0_l (S (S radix)) (Nat.neq_succ_0 (S radix))) n H0 in let H1 : S q = 0 := eq_ind_r (fun x => x = 0) H2 H in Nat.neq_succ_0 q H1)) ((proj1 (Nat.lt_eq_cases 0 n)) (Nat.le_0_l n))) (le_n_S 1 (S radix) (le_n_S 0 radix (Nat.le_0_l radix)))) H) in let xs := n mod (S (S radix)) :: ms in let H1 : n = nat_decomp_nat (S (S radix)) xs := ltac:( unfold xs; lazy [nat_decomp_nat list_rec list_rect]; fold (nat_decomp_nat (S (S radix))); rewrite <- (proj2 H0); rewrite H; rewrite <- (Nat.div_mod n (S (S radix)) (Nat.neq_succ_0 (S radix))); reflexivity) in let H2 : Forall (fun m => m < S (S radix)) xs := Forall_cons (n mod S (S radix)) (Nat.mod_upper_bound n (S (S radix)) (Nat.neq_succ_0 (S radix))) (proj1 H0) in exist _ xs (conj H2 H1)) (Nat.div n (S (S radix))) eq_refl)%nat (lt_wf n). Local Theorem inv_inj : forall (A B : Type) (f : A -> B) (g : B -> A), (forall x : A, g (f x) = x) -> (forall x y : A, f x = f y -> x = y). 
tauto. + inv H. destruct H0; subst; rewrite createHideMod_Meths in *; auto. specialize (IHl HWf); dest; apply H0; assumption. + inv H. destruct (IHl HWf); assumption. - unfold SubList; induction l; simpl; intros; try tauto; dest; constructor. + rewrite createHideMod_Meths; apply (H a); left; reflexivity. + apply IHl; intros; split;auto. Qed.Lemma WfActionT_flatten m k ty: forall (a : ActionT ty k), WfActionT (getRegisters m) a <-> WfActionT (getRegisters (getFlat (Base m))) a. Proof. intro; split; induction 1; econstructor; eauto. Qed.Theorem flatten_WfMod ty m: WfMod ty m -> WfMod ty (flatten m). Proof. unfold flatten. induction 1; simpl; auto; intros. - constructor; auto. - constructor; auto. rewrite createHide_Meths. auto. - unfold getFlat in *; simpl. rewrite WfMod_createHide in *; dest; simpl in *. split. + rewrite map_app. unfold SubList in *; intros. rewrite in_app_iff in *. specialize (H3 x). specialize (H1 x). tauto. + constructor;inversion H4; inversion H2; inversion HWfBaseModule; inversion HWfBaseModule0; subst. * split; intros. -- destruct (in_app_or _ _ _ H6). ++ specialize (H5 _ H7). induction H5; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; left; assumption. ++ specialize (H9 _ H7). induction H9; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; right; assumption. -- repeat split; simpl; intros; dest; try (eapply NoDup_DisjKey; eauto). ++ destruct (in_app_or _ _ _ H6). ** specialize (H8 _ H16 v). induction H8; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; left; assumption. ** specialize (H7 _ H16 v). induction H7; econstructor; eauto; simpl; rewrite map_app; apply in_or_app; right; assumption. Qed.Theorem flatten_WfMod_new ty m : WfMod_new ty m -> WfMod_new ty (flatten m). Proof. repeat rewrite WfMod_new_WfMod_iff. apply flatten_WfMod. Qed.Definition flatten_ModWf ty m: ModWf ty := (Build_ModWf (flatten_WfMod (wfMod m))).Definition flatten_ModWf_new ty m: ModWf_new ty := (Build_ModWf_new _ _ (flatten_WfMod_new _ _ (wfMod_new m))).Section TraceSubstitute. Variable m: ModWf type. Lemma Trace_flatten_same1: forall o l, Trace m o l -> Trace (flatten m) o l. Proof. induction 1; subst. - constructor 1; auto. unfold flatten. rewrite createHide_Regs. auto. - apply (@Step_substitute type) in HStep; auto. + econstructor 2; eauto. + destruct m; auto. Qed. Lemma Trace_flatten_same2: forall o l, Trace (flatten m) o l -> (exists l', (PermutationEquivLists l l') /\ Trace m o l'). Proof. induction 1; subst. - rewrite getAllRegisters_flatten in *. exists nil;split;constructor 1; auto. - apply substitute_Step in HStep;auto; dest. exists (x0::x);split. + constructor; auto. + econstructor 2; eauto. apply (Permutation_map fst) in H2. eapply UpdRegs_perm; eauto. + destruct m; auto. Qed. Theorem TraceInclusion_flatten_r: TraceInclusion m (flatten_ModWf m). 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Coq_Cats.Type_Cat.Type_Cat.Section Monic_Iso_Monic_Factorization. Context {A B : Type} {f : A ‚Üí B} (fm : @is_Monic Type_Cat _ _ f). Definition Monic_Image_of : Type := {x : B & {a : A | f a = x}}. Definition Monic_From_Image_forward : Monic_Image_of ‚Üí B := fun x => projT1 x. Program Definition Monic_Iso_Monic_Factor_Monic : @Monic Type_Cat Monic_Image_of B := {| mono_morphism := Monic_From_Image_forward; mono_morphism_monomorphic := fun T g h => _ |}. Next Obligation. Proof. extensionality x. assert (H' := equal_f H x); cbn in H'. destruct (g x) as [gx Hgx]; destruct (h x) as [hx Hhx]. cbn in *. destruct H'. assert (Hgx = Hhx) as ->; trivial. apply sig_proof_irrelevance. destruct Hgx as [y Hy]; destruct Hhx as [z Hz]. cbn in *. refine (equal_f (fm (unit : Type) (fun _ => y) (fun _ => z) _) tt). FunExt; cbn; auto. Qed. Definition Monic_To_Image : A ‚Üí Monic_Image_of := fun a => existT _ (f a) (exist _ a eq_refl). Definition Monic_From_Image_back : Monic_Image_of ‚Üí A := fun x => proj1_sig (projT2 x). Theorem Monic_From_Image_back_is_Monic : @is_Monic Type_Cat _ _ Monic_To_Image. Proof. intros T g h H. extensionality x. assert (H' := f_equal (fun w : Monic_Image_of => (fun u : unit => projT1 w)) (equal_f H x) ); clear H. apply (equal_f (fm (unit : Type) (fun _ => (g x)) (fun _ => (h x)) H') tt). Qed. Theorem Monic_To_Image_form_split_epic : (fun (x : Monic_Image_of) => Monic_To_Image (Monic_From_Image_back x)) = (fun x => x). 
n p, HProp_extensional (usl' s n p). Axiom usl_extensional : forall s p, HProp_extensional (usl s p). Axiom usl'_set_extensional : forall n s s' p, s %= s' -> usl' s n p ===> usl' s' n p. Axiom usl_fwd : forall s p, usl s p ===> [| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r. Axiom usl_bwd : forall s p, ([| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r) ===> usl s p. Axiom nil_fwd : forall s n (p : W), p = 0 -> usl' s n p ===> [| s %= empty /\ n = O |]. Axiom nil_bwd : forall s n (p : W), p = 0 -> [| s %= empty /\ n = O |] ===> usl' s n p. Axiom cons_fwd : forall s n (p : W), p <> 0 -> usl' s n p ===> Ex n', Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| freeable p 2 /\ n = S n' /\ v %in s |]. Axiom cons_bwd : forall s n (p : W), p <> 0 -> (Ex n', Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| freeable p 2 /\ n = S n' /\ v %in s |]) ===> usl' s n p. End USL.Module Usl : USL. Open Scope Sep_scope. Fixpoint usl' (s : set) (n : nat) (p : W) : HProp := match n with | O => [| p = 0 /\ s %= empty |] | S n' => [| p <> 0 /\ freeable p 2 |] * Ex v, Ex p', (p ==*> v, p') * usl' (s %- v) n' p' * [| v %in s |] end. Definition usl (s : set) (p : W) := [| freeable p 2 |] * Ex n, Ex r, Ex junk, p =*> r * (p ^+ $4) =*> junk * usl' s n r. Theorem usl'_extensional : forall s n p, HProp_extensional (usl' s n p). destruct n; reflexivity. Qed. Theorem usl_extensional : forall s p, HProp_extensional (usl s p). reflexivity. Qed. Theorem usl'_set_extensional : forall n s s' p, s %= s' -> usl' s n p ===> usl' s' n p. 
big_sepML_eq /big_sepML_def. iIntros "Hml". iDestruct "Hml" as (lm) "[% Hml]". destruct (map_to_list lm) eqn:Heq. - apply map_to_list_empty_iff in Heq; subst. iDestruct (big_sepM2_empty_l with "Hml") as %He. done. - simpl in *. apply Permutation_nil_cons in H0. eauto. Qed. Theorem big_sepML_empty_l Œ¶ l : big_sepML Œ¶ ‚à l -‚àó ‚åú l = [] ‚åù. Proof. rewrite big_sepML_eq /big_sepML_def. iIntros "Hml". iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_empty_r with "Hml") as %He; subst. rewrite map_to_list_empty /= in H0. iPureIntro. eapply Permutation_nil_r. done. Qed. Theorem big_sepML_sep Œ¶ Œ® m l : big_sepML (Œª k v lv, Œ¶ k v lv ‚àó Œ® k v lv) m l -‚àó big_sepML Œ¶ m l ‚àó big_sepML Œ® m l. Proof. iIntros "Hml". rewrite big_sepML_eq. iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_sep with "Hml") as "[Hml0 Hml1]". iSplitL "Hml0". { iExists _. iFrame. done. } { iExists _. iFrame. done. } Qed. Theorem big_sepML_sepM Œ¶ (P : K -> V -> PROP) m l : big_sepML (Œª k v lv, Œ¶ k v lv ‚àó P k v) m l ‚ä£‚ä¢ big_sepML Œ¶ m l ‚àó big_opM _ P m. Proof. rewrite big_sepML_eq; iSplit. - iIntros "Hlm". iDestruct "Hlm" as (lm) "[% Hlm]". iDestruct (big_sepM2_sep with "Hlm") as "[Hlm0 Hlm1]". iSplitL "Hlm0". + iExists _. iFrame. done. + iDestruct (big_sepM2_sepM_1 with "Hlm1") as "Hlm1". iDestruct (big_sepM_mono with "Hlm1") as "Hlm1"; last by iFrame. iIntros (k x Hkx) "H". iDestruct "H" as (y2) "[% H]". iFrame. - iIntros "[Hlm Hm]". iDestruct "Hlm" as (lm) "[% Hlm]". iExists _. iSplitR; first by eauto. iDestruct (big_sepM2_dom with "Hlm") as "%Hmlm". iApply big_sepM2_sep; iFrame. rewrite big_op.big_sepM2_unseal /big_op.big_sepM2_def. iSplit. { iPureIntro. split; intros. { apply elem_of_dom. rewrite -Hmlm. apply elem_of_dom. eauto. } { apply elem_of_dom. rewrite Hmlm. apply elem_of_dom. eauto. } } clear H0. iInduction m as [|i x m] "IH" using map_ind forall (lm Hmlm). { rewrite dom_empty_L in Hmlm. assert (lm = ‚à ) by (apply dom_empty_iff_L; auto); subst. rewrite map_zip_empty_l. iApply big_sepM_empty. done. } iDestruct (big_sepM_insert with "Hm") as "[Hi Hm]"; eauto. assert (is_Some (lm !! i)) as Hlmi. { apply elem_of_dom. rewrite -Hmlm. apply elem_of_dom. rewrite lookup_insert; eauto. } destruct Hlmi. replace lm with (<[i:=x0]> (delete i lm)). 2: { rewrite insert_delete; eauto. } rewrite map_zip_insert. iApply big_sepM_insert. { rewrite map_zip_lookup_none_1; eauto. } iFrame. iApply "IH"; last by iFrame. iPureIntro. rewrite dom_delete_L -Hmlm dom_insert_L. assert (i ‚àâ dom m). { apply not_elem_of_dom. eauto. } set_solver. Qed. Theorem big_sepML_sepM_ex Œ¶ m l : big_sepML Œ¶ m l -‚àó big_opM _ (Œª k v, ‚àÉ lv, ‚åú lv ‚àà l ‚åù ‚àó Œ¶ k v lv) m. 
Require Export Min. Require Export Arith. Require Export Reals. Require Export Zpower. Require Export ZArith. Require Export Zcomplements. Require Export sTactic. Hint Resolve R1_neq_R0: real. Theorem minus_minus : forall a b : nat, a <= b -> b - (b - a) = a. intros a b H'. apply sym_equal. apply plus_minus; auto. rewrite plus_comm; apply le_plus_minus; auto. Qed. Theorem lte_comp_mult : forall p q r t : nat, p <= q -> r <= t -> p * r <= q * t. intros p q r t H'; elim H'; simpl in |- *; auto with arith. elim p; simpl in |- *; auto with arith. intros n H m H0 H1 H2; apply plus_le_compat; auto with arith. apply le_trans with (m := r + n * r); auto with arith. Qed. Hint Resolve lte_comp_mult: arith. Theorem le_refl_eq : forall n m : nat, n = m -> n <= m. intros n m H'; rewrite H'; auto. Qed. Theorem lt_le_pred : forall n m : nat, n < m -> n <= pred m. intros n m H'; inversion H'; simpl in |- *; auto. apply le_trans with (S n); auto. Qed. Theorem lt_comp_mult_l : forall p q r : nat, 0 < p -> q < r -> p * q < p * r. intros p; elim p; simpl in |- *. auto with arith. intros n0; case n0. simpl in |- *; auto with arith. intros n1 H' q r H'0 H'1. apply lt_trans with (m := q + S n1 * r); auto with arith. Qed. Hint Resolve lt_comp_mult_l: arith. Theorem lt_comp_mult_r : forall p q r : nat, 0 < p -> q < r -> q * p < r * p. 
s2; auto. Qed. Theorem state_star_inversion: forall H1 H2 state, (H1 \* H2) state -> exists s1 s2, H1 s1 /\ H2 s2 /\ state_disjoint s1 s2 /\ state = union s1 s2. Proof. intros ??? A; hnf in A; eauto. Qed. Theorem state_star_commutative: forall H1 H2, H1 \* H2 <*> H2 \* H1. Proof. apply state_operation_commutative; unfold state_star; intros ?? state (s1 & s2 & ? & ? & [] & U); rewrite state_union_commutative in U; trivial; exists s2, s1; repeat split; auto. Qed. Theorem state_star_associative H1 H2 H3: (H1 \* H2) \* H3 <*> H1 \* (H2 \* H3). Proof. apply state_implies_antisymmetric. - intros state (state' & h3 & (h1 & h2 & ?&?&?&?)&?& D%symmetry &?); subst state'; exists h1, (union h2 h3); rewrite state_union_associative; assert (D' := D); apply state_disjoint_union_distributive in D' as [?%symmetry ?%symmetry]; repeat split; repeat apply state_star_intro; trivial; apply state_disjoint_union_distributive; split; trivial. - intros state (h1 & state' &?&(h2 & h3 &?&?&?&?)&D&?); subst state'; exists (union h1 h2), h3; rewrite <-state_union_associative; assert (D' := D); apply state_disjoint_union_distributive in D' as []; repeat split; repeat apply state_star_intro; trivial; symmetry; apply state_disjoint_union_distributive; split; symmetry; trivial. Qed. Theorem state_star_empty_l H: \[] \* H <*> H. Proof. apply state_implies_antisymmetric; hnf. - intros ? [? (? & ?%state_unknown_inversion & ? & ? & ?)]; subst; rewrite state_union_empty_l; assumption. - intros ?; exists empty, state; repeat split; simpl; try apply state_unknown_intro; try apply map_disjoint_empty_l; try rewrite state_union_empty_l; trivial. Qed. Theorem state_star_empty_r H: H \* \[] <*> H. Proof. rewrite state_star_commutative; apply state_star_empty_l. Qed. Theorem state_star_exists A (P: A -> Assertion) H: (\exists a, P a) \* H <*> \exists a, (P a \* H). Proof. apply state_implies_antisymmetric; intros state. - intros (s1 & s2 & (a &?)&?&?&?); exists a, s1, s2; auto. - intros (a & (s1 & s2 &?&?&?&?)); exists s1, s2; split; auto; exists a; trivial. Qed. Theorem state_implies_frame_l H2 H1 H1': H1 **> H1' -> (H1 \* H2) **> (H1' \* H2). Proof. intros ?? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_frame_r H1 H2 H2': H2 **> H2' -> (H1 \* H2) **> (H1 \* H2'). Proof. intros ?? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_frame H1 H1' H2 H2': H1 **> H1' -> H2 **> H2' -> (H1 \* H2) **> (H1' \* H2'). Proof. intros ??? (s1 & s2 & (?&?&?&?)); exists s1, s2; auto. Qed. Theorem state_implies_star_trans_l H1 H2 H3 H4: H1 **> H2 -> H2 \* H3 **> H4 -> H1 \* H3 **> H4. 
hlist_hd h. Proof. simpl. intros. match goal with | |- context [ match ?X with _ => _ end ] => destruct X end. reflexivity. Qed. Lemma hlist_tl_fst_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), hlist_tl (fst (hlist_split (t :: xs) ys h)) = fst (hlist_split xs ys (hlist_tl h)). Proof. simpl. intros. match goal with | |- context [ match ?X with _ => _ end ] => remember X end. destruct p. simpl. change h0 with (fst (h0, h1)). f_equal; trivial. Qed. Lemma hlist_tl_snd_hlist_split : forall t (xs ys : list _) (h : hlist (t :: xs ++ ys)), snd (hlist_split xs ys (hlist_tl h)) = snd (hlist_split (t :: xs) ys h). Proof. simpl. intros. match goal with | |- context [ match ?X with _ => _ end ] => remember X end. destruct p. simpl. change h1 with (snd (h0, h1)). rewrite Heqp. reflexivity. Qed. Polymorphic Fixpoint nth_error_get_hlist_nth (ls : list iT) (n : nat) {struct ls} : option {t : iT & hlist ls -> F t} := match ls as ls0 return option {t : iT & hlist ls0 -> F t} with | nil => None | l :: ls0 => match n as n0 return option {t : iT & hlist (l :: ls0) -> F t} with | 0 => Some (@existT _ (fun t => hlist (l :: ls0) -> F t) l (@hlist_hd _ _)) | S n0 => match nth_error_get_hlist_nth ls0 n0 with | Some (existT x f) => Some (@existT _ (fun t => hlist _ -> F t) x (fun h : hlist (l :: ls0) => f (hlist_tl h))) | None => None end end end. Theorem nth_error_get_hlist_nth_Some : forall ls n s, nth_error_get_hlist_nth ls n = Some s -> exists pf : nth_error ls n = Some (projT1 s), forall h, projT2 s h = match pf in _ = t return match t return Type with | Some t => F t | None => unit end with | eq_refl => hlist_nth h n end. Proof. induction ls; simpl; intros; try congruence. { destruct n. { inv_all; subst; simpl. exists (eq_refl). intros. rewrite (hlist_eta h). reflexivity. } { forward. inv_all; subst. destruct (IHls _ _ H0); clear IHls. simpl in *. exists x0. intros. rewrite (hlist_eta h). simpl. auto. } } Qed. Theorem nth_error_get_hlist_nth_None : forall ls n, nth_error_get_hlist_nth ls n = None <-> nth_error ls n = None. 
Theorem bool_cases : forall b:bool, b = true \/ b = false. Proof bool_ind (fun b:bool => b = true \/ b = false) (or_introl _ (refl_equal true)) (or_intror _ (refl_equal false)). Theorem bool_cases' : forall b:bool, b = true \/ b = false. 
Require Import List Arith Omega.Require Import ILL.Definitions.Require Import pos vec. Require Import sss subcode mm_defs. Require Import fractran_defs prime_seq mm_fractran.Set Implicit Arguments.Definition FRACTRAN_PROBLEM := (list (nat*nat) * nat)%type.Definition FRACTRAN_HALTING (P : FRACTRAN_PROBLEM) : Prop. Proof. destruct P as (l & x). exact (l /F/ x ‚Üì). Defined.Definition FRACTRAN_ALT_PROBLEM := (list (nat*nat) * { n : nat & vec nat n })%type.Definition FRACTRAN_ALT_HALTING : FRACTRAN_ALT_PROBLEM -> Prop. Proof. intros (l & n & v). exact (l /F/ ps 1 * exp 1 v ‚Üì). Defined.Section MM_HALTING_FRACTRAN_ALT_HALTING. Let f : MM_PROBLEM -> FRACTRAN_ALT_PROBLEM. Proof. intros (n & P & v); red. destruct (mm_fractran_n P) as (l & H1 & _). split. + exact l. + exists n; exact v. Defined. Theorem MM_FRACTRAN_ALT_HALTING : MM_HALTING ‚™Ø FRACTRAN_ALT_HALTING. 
x. Proof. intros. apply Bplus_commut. unfold binop_nan. destruct Archi.fpu_returns_default_qNaN. easy. destruct x, y; try reflexivity. now destruct H. Qed.Theorem mul_commut: forall x y, is_nan _ _ x = false \/ is_nan _ _ y = false -> mul x y = mul y x. Proof. intros. apply Bmult_commut. unfold binop_nan. destruct Archi.fpu_returns_default_qNaN. easy. destruct x, y; try reflexivity. now destruct H. Qed.Theorem mul2_add: forall f, add f f = mul f (of_int (Int.repr 2%Z)). Proof. intros. apply Bmult2_Bplus. intros x y Hx Hy. unfold binop_nan. destruct Archi.fpu_returns_default_qNaN. easy. destruct x as [| |sx px Nx|]; try discriminate. now destruct y, Archi.choose_binop_pl_64. Qed.Definition exact_inverse : float -> option float := Bexact_inverse 53 1024 __ __.Theorem div_mul_inverse: forall x y z, exact_inverse y = Some z -> div x y = mul x z. Proof. intros. apply Bdiv_mult_inverse. 2: easy. intros x0 y0 z0 Hx Hy Hz. unfold binop_nan. destruct Archi.fpu_returns_default_qNaN. easy. destruct x0 as [| |sx px Nx|]; try discriminate. now destruct y0, z0. Qed.Theorem cmp_swap: forall c x y, cmp (swap_comparison c) x y = cmp c y x. Proof. unfold cmp, compare; intros. rewrite (Bcompare_swap _ _ x y). apply cmp_of_comparison_swap. Qed.Theorem cmp_ne_eq: forall f1 f2, cmp Cne f1 f2 = negb (cmp Ceq f1 f2). Proof. intros; apply cmp_of_comparison_ne_eq. Qed.Theorem cmp_lt_eq_false: forall f1 f2, cmp Clt f1 f2 = true -> cmp Ceq f1 f2 = true -> False. Proof. intros f1 f2; apply cmp_of_comparison_lt_eq_false. Qed.Theorem cmp_le_lt_eq: forall f1 f2, cmp Cle f1 f2 = cmp Clt f1 f2 || cmp Ceq f1 f2. Proof. intros f1 f2; apply cmp_of_comparison_le_lt_eq. Qed.Theorem cmp_gt_eq_false: forall x y, cmp Cgt x y = true -> cmp Ceq x y = true -> False. Proof. intros f1 f2; apply cmp_of_comparison_gt_eq_false. Qed.Theorem cmp_ge_gt_eq: forall f1 f2, cmp Cge f1 f2 = cmp Cgt f1 f2 || cmp Ceq f1 f2. Proof. intros f1 f2; apply cmp_of_comparison_ge_gt_eq. Qed.Theorem cmp_lt_gt_false: forall f1 f2, cmp Clt f1 f2 = true -> cmp Cgt f1 f2 = true -> False. Proof. intros f1 f2; apply cmp_of_comparison_lt_gt_false. Qed.Theorem of_to_bits: forall f, of_bits (to_bits f) = f. Proof. intros; unfold of_bits, to_bits, bits_of_b64, b64_of_bits. rewrite Int64.unsigned_repr, binary_float_of_bits_of_binary_float; [reflexivity|]. generalize (bits_of_binary_float_range 52 11 __ __ f). change (2^(52+11+1)) with (Int64.max_unsigned + 1). omega. Qed.Theorem to_of_bits: forall b, to_bits (of_bits b) = b. Proof. intros; unfold of_bits, to_bits, bits_of_b64, b64_of_bits. rewrite bits_of_binary_float_of_bits. apply Int64.repr_unsigned. apply Int64.unsigned_range. Qed.Definition ox8000_0000 := Int.repr Int.half_modulus. Theorem of_intu_of_int_1: forall x, Int.ltu x ox8000_0000 = true -> of_intu x = of_int x. 
Unset Automatic Introduction. Add LoadPath "../.." .Require Export Foundations.hlevel2.algebra1d . Lemma negpaths0sx ( x : nat ) : neg ( paths O (S x) ) . Proof. intro. set (f:= fun n : nat => match n with O => true | S m => false end ) . apply ( negf ( @maponpaths _ _ f 0 ( S x ) ) nopathstruetofalse ) . Defined. Lemma negpathssx0 ( x : nat ) : neg ( paths (S x) O ) . Proof. intros x X. apply (negpaths0sx x (pathsinv0 X)). Defined. Lemma invmaponpathsS ( n m : nat ) : paths ( S n ) ( S m ) -> paths n m . Proof. intros n m e . set ( f := fun n : nat => match n with O => O | S m => m end ) . apply ( @maponpaths _ _ f ( S n ) ( S m ) e ) . Defined. Lemma noeqinjS ( x x' : nat ) : neg ( paths x x' ) -> neg ( paths (S x) (S x') ) . Proof. intros x x'. apply ( negf ( invmaponpathsS x x' ) ) . Defined. Definition isdeceqnat: isdeceq nat. Proof. unfold isdeceq. intro x . induction x as [ | x IHx ] . intro x' . destruct x'. apply ( ii1 ( idpath O ) ) . apply ( ii2 ( negpaths0sx x' ) ) . intro x' . destruct x'. apply ( ii2 (negpathssx0 x ) ) . destruct ( IHx x' ) as [ p | e ]. apply ( ii1 ( maponpaths S p ) ) . apply ( ii2 ( noeqinjS _ _ e ) ) . Defined . Definition isisolatedn ( n : nat ) : isisolated _ n . Proof. intro. unfold isisolated . intro x' . apply isdeceqnat . Defined. Theorem isasetnat: isaset nat. 
find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * eauto. * subst. unfold raft_data in *. repeat find_rewrite. eapply lifted_leader_sublog_host; eauto. + eauto. - repeat update_destruct_max_simplify. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. auto. + repeat find_rewrite. eauto. + find_eapply_lem_hyp leaderLogs_update_elections_data_RVR; eauto; intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. discriminate. + eauto. Qed. Theorem leaderLogs_sublog_do_leader : refined_raft_net_invariant_do_leader leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_leader, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doLeader_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doLeader_same_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_do_generic_server : refined_raft_net_invariant_do_generic_server leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_generic_server, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doGenericServer_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doGenericServer_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_state_same_packet_subset, leaderLogs_sublog. intuition. repeat find_reverse_higher_order_rewrite. eauto. Qed. Theorem leaderLogs_sublog_reboot : refined_raft_net_invariant_reboot leaderLogs_sublog. 
Require Export List. From Huffman Require Export Aux. Section permutation. Variable A : Type. Inductive permutation : list A -> list A -> Prop := | permutation_nil : permutation nil nil | permutation_skip : forall (a : A) (l1 l2 : list A), permutation l2 l1 -> permutation (a :: l2) (a :: l1) | permutation_swap : forall (a b : A) (l : list A), permutation (a :: b :: l) (b :: a :: l) | permutation_trans : forall l1 l2 l3 : list A, permutation l1 l2 -> permutation l2 l3 -> permutation l1 l3. Hint Constructors permutation : core. Theorem permutation_refl : forall l : list A, permutation l l. Proof using. simple induction l. apply permutation_nil. intros a l1 H. apply permutation_skip with (1 := H). Qed. Hint Resolve permutation_refl : core. Theorem permutation_sym : forall l m : list A, permutation l m -> permutation m l. Proof using. intros l1 l2 H'; elim H'. apply permutation_nil. intros a l1' l2' H1 H2. apply permutation_skip with (1 := H2). intros a b l1'. apply permutation_swap. intros l1' l2' l3' H1 H2 H3 H4. apply permutation_trans with (1 := H4) (2 := H2). Qed. Theorem permutation_length : forall l m : list A, permutation l m -> length l = length m. Proof using. intros l m H'; elim H'; simpl in |- *; auto. intros l1 l2 l3 H'0 H'1 H'2 H'3. rewrite <- H'3; auto. Qed. Theorem permutation_nil_inv : forall l : list A, permutation l nil -> l = nil. Proof using. intros l H; generalize (permutation_length _ _ H); case l; simpl in |- *; auto. intros; discriminate. Qed. Lemma permutation_one_inv_aux : forall l1 l2 : list A, permutation l1 l2 -> forall a : A, l1 = a :: nil -> l2 = a :: nil. Proof using. intros l1 l2 H; elim H; clear H l1 l2; auto. intros a l3 l4 H0 H1 b H2. apply f_equal2 with (f := cons (A:=A)). injection H2; auto. apply permutation_nil_inv; auto. injection H2; intros H3 H4; rewrite <- H3; auto. apply permutation_sym; auto. intros; discriminate. Qed. Theorem permutation_one_inv : forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil. 
(CSMaxCount cs) (CSCount cs + 1) (eviction_update (CSEvict cs) a)) end. Definition begin_sync (cs : cachestate) := Ret cs. Definition sync a (cs : cachestate) := cs <- writeback a cs; Ret cs. Definition end_sync (cs : cachestate) := Sync;; Ret cs. Definition cache0 sz := mk_cs (Map.empty _) sz 0 eviction_init. Definition init (cachesize : nat) := Sync;; Ret (cache0 cachesize). Definition read_array a i cs := r <- read (a + i) cs; Ret r. Definition write_array a i v cs := cs <- write (a + i) v cs; Ret cs. Definition sync_array a i cs := cs <- sync (a + i) cs; Ret cs. Definition size_valid cs := Map.cardinal (CSMap cs) = CSCount cs /\ Map.cardinal (CSMap cs) <= CSMaxCount cs /\ CSMaxCount cs <> 0. Definition addr_valid (d : rawdisk) (cm : cachemap) := forall a, Map.In a cm -> d a <> None. Definition addr_clean (cm : cachemap) a := Map.find a cm = None \/ exists v, Map.find a cm = Some (v, false). Definition addrs_clean cm al := Forall (addr_clean cm) al. Definition cachepred (cache : cachemap) (a : addr) (vs : valuset) : @pred _ addr_eq_dec valuset := (match Map.find a cache with | None => a |+> vs | Some (v, false) => a |+> vs * [[ v = fst vs ]] | Some (v, true) => exists v0, a |+> (v0, snd vs) * [[ v = fst vs /\ In v0 (snd vs) ]] end)%pred. Notation mem_pred := (@mem_pred _ addr_eq_dec _ _ addr_eq_dec _). Definition rep (cs : cachestate) (m : rawdisk) : rawpred := ([[ size_valid cs /\ addr_valid m (CSMap cs) ]] * mem_pred (cachepred (CSMap cs)) m)%pred. Definition synpred (cache : cachemap) (a : addr) (vs : valuset) : @pred _ addr_eq_dec valuset := (exists vsd, a |+> vsd * match Map.find a cache with | None => [[ vs = (fst vsd, nil) ]] | Some (v, false) => [[ vs = (fst vsd, nil) /\ v = fst vsd ]] | Some (v, true) => [[ vs = (v, (fst vsd) :: nil) ]] end)%pred. Definition synrep' (cs : cachestate) (m : rawdisk) : rawpred := ([[ size_valid cs /\ addr_valid m (CSMap cs) ]] * mem_pred (synpred (CSMap cs)) m)%pred. Definition synrep (cs : cachestate) (mbase m : rawdisk) : rawpred := (rep cs mbase /\ synrep' cs m)%pred. Theorem sync_invariant_cachepred : forall cache a vs, sync_invariant (cachepred cache a vs). 
ye) (pr2 w (pr1 ye))). } apply (isofhlevelweqb _ (make_weq _ is') (is _)). Defined.Corollary isofhlevelfhomot2 (n : nat) {X X' Y : UU} (f : X -> Y) (f' : X' -> Y) (w : X ‚âÉ X') (h : ‚àè x : X, paths (f x) (f' (w x))) : isofhlevelf n f -> isofhlevelf n f'. Proof. intros X0. assert (X1 : isofhlevelf n (Œª x : X, f' (w x))) by apply (isofhlevelfhomot n _ _ h X0). apply (isofhlevelfgwtog n w f' X1). Defined. Theorem isofhlevelfonpaths (n : nat) {X Y : UU} (f : X -> Y) (x x' : X) : isofhlevelf (S n) f -> isofhlevelf n (@maponpaths _ _ f x x'). Proof. intros X0. set (y := f x'). set (xe' := make_hfiber f x' (idpath _)). assert (is1 : isofhlevelf n (d2g f x xe')). { unfold isofhlevelf. intro y0. apply (isofhlevelweqf n (ezweq3g f x xe' y0) (X0 y (make_hfiber f x y0) xe')). } assert (h : ‚àè ee : x' = x, paths (d2g f x xe' ee) (maponpaths f (pathsinv0 ee))). { intro. assert (e0: paths (pathscomp0 (maponpaths f (pathsinv0 ee)) (idpath _)) (maponpaths f (pathsinv0 ee))) by (induction ee; simpl; apply idpath). apply (e0). } apply (isofhlevelfhomot2 n _ _ (make_weq (@pathsinv0 _ x' x) (isweqpathsinv0 _ _)) h is1). Defined.Theorem isofhlevelfsn (n : nat) {X Y : UU} (f : X -> Y) : (‚àè x x' : X, isofhlevelf n (@maponpaths _ _ f x x')) -> isofhlevelf (S n) f. Proof. intros X0. unfold isofhlevelf. intro y. simpl. intros x x'. induction x as [ x e ]. induction x' as [ x' e' ]. induction e'. set (xe' := make_hfiber f x' (idpath _)). set (xe := make_hfiber f x e). set (d3 := d2g f x xe'). simpl in d3. assert (is1 : isofhlevelf n (d2g f x xe')). assert (h : ‚àè ee : x' = x, paths (maponpaths f (pathsinv0 ee)) (d2g f x xe' ee)). { intro. unfold d2g. simpl. apply (pathsinv0 (pathscomp0rid _)). } assert (is2 : isofhlevelf n (Œª ee: x' = x, maponpaths f (pathsinv0 ee))) by apply (isofhlevelfgtogw n ( make_weq _ (isweqpathsinv0 _ _)) (@maponpaths _ _ f x x') (X0 x x')). apply (isofhlevelfhomot n _ _ h is2). apply (isofhlevelweqb n (ezweq3g f x xe' e) (is1 e)). Defined. Theorem isofhlevelfssn (n : nat) {X Y : UU} (f : X -> Y) : (‚àè x : X, isofhlevelf (S n) (@maponpaths _ _ f x x)) -> isofhlevelf (S (S n)) f. 
Require Import Coq.omega.Omega. Require Import Bedrock.Platform.AutoSep Bedrock.Platform.Bootstrap Bedrock.Platform.Malloc Bedrock.Platform.Buffers Bedrock.Platform.XmlLex Bedrock.Platform.XmlLang Bedrock.Platform.Arrays8 Bedrock.Platform.ArrayOps. Require Import Bedrock.Platform.RelDb Bedrock.Platform.XmlOutput Bedrock.Platform.Bags Bedrock.Platform.Io Bedrock.Platform.Http Bedrock.Platform.HttpQ Bedrock.Platform.Thread. Module Type HIDE. Parameter heapSize4 : N -> N. Axiom heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. Parameter to_nat : N -> nat. Axiom to_nat_eq : to_nat = N.to_nat. End HIDE.Module Hide : HIDE. Definition heapSize4 n := (n * 4)%N. Theorem heapSize4_eq : forall n, heapSize4 n = (n * 4)%N. auto. Qed. Definition to_nat := N.to_nat. Theorem to_nat_eq : to_nat = N.to_nat. auto. Qed. End Hide.Record wf (ts : tables) (pr : program) (buf_size outbuf_size : N) : Prop := { WellFormed : XmlLang.wf ts pr; NotTooGreedy : (reserved pr <= 86)%nat; Buf_size_lower : (buf_size >= 2)%N; Buf_size_upper : (buf_size * 4 < Npow2 32)%N; Outbuf_size_lower : (outbuf_size >= 2)%N; Outbuf_size_upper : (outbuf_size * 4 < Npow2 32)%N; ND : NoDup (Names ts); GoodSchema : twfs ts; UF : uf ts }.Module Type S. Parameter ts : tables. Parameter pr : program. Parameters buf_size outbuf_size heapSize : N. Axiom Wf : wf ts pr buf_size outbuf_size. Parameters port numWorkers : W. End S.Module Make(M : S). Import M.Module Locations. Definition globalSched : W := ((heapSize + 50) * 4)%N. Definition globalSock : W := globalSched ^+ $4. End Locations.Import Locations.Module M'''. Definition globalSched := globalSched. Local Open Scope Sep_scope. Definition globalInv (fs : files) : HProp := db ts * Ex fr, globalSock =*> fr * [| fr %in fs |]. End M'''.Module T := Thread.Make(M''').Import T M'''. Export T M'''.Module MyM. Definition sched := sched. Definition globalInv := globalInv. Definition buf_size := outbuf_size. Theorem buf_size_lower : (nat_of_N buf_size >= 2)%nat. generalize (Outbuf_size_lower _ _ _ _ M.Wf). unfold buf_size; intros; nomega. Qed. Theorem buf_size_upper : goodSize (4 * nat_of_N buf_size). 
bs <-$ compMap _ (fun _ => (c a)) (forNats n); ret (fold_left (fun b x => b || (Q x)) bs false). Theorem TrueSingle_impl_Mult : Pr[TrueMult_G] <= (n / 1) * Pr[TrueSingle_G]. unfold TrueMult_G, TrueSingle_G. simpl in *. eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. eapply sumList_factor_constant_l. } eapply sumList_le. intuition. eapply leRat_trans. 2:{ eapply eqRat_impl_leRat. symmetry. rewrite ratMult_comm. eapply ratMult_assoc. } eapply ratMult_leRat_compat. intuition. specialize (@compMap_Q_eq_compFold _ _ Q n (c a) false); intuition. rewrite H0. rewrite prob_sum_le_mult. rewrite ratMult_comm. eapply ratMult_leRat_compat; intuition. Local Transparent evalDist. simpl. reflexivity. Qed.End TrueSingle_impl_Mult.Section TrueMult_impl_Repeat. Variable A B : Set. Hypothesis eqdb : EqDec B. Variable A1 : Comp A. Hypothesis A1_wf : well_formed_comp A1. Variable c : A -> Comp B. Variable f P : B -> bool. Hypothesis c_wf : forall x, In x (getSupport A1) -> well_formed_comp (c x). Hypothesis Repeat_c_terminating : forall x, In x (getSupport A1) -> exists x1 : B, In x1 (filter P (getSupport (c x))). Definition TrueRepeat_G := a <-$ A1; b <-$ Repeat (c a) P; ret (f b). Variable n : nat. Variable failProb : Rat. Hypothesis failProb_correct : forall (a : A), In a (getSupport A1) -> Pr[x <-$ c a; ret negb (P x)] <= failProb. Definition TrueRepeat_G1 := a <-$ A1; bs <-$ compMap _ (fun _ => c a) (forNats n); b_opt <- hd_error (filter P bs); b' <-$ Repeat (c a) P; b <- match b_opt with | None => b' | Some x => x end; ret (f b). Theorem TrueRepeat_G_G1_equiv : Pr[ TrueRepeat_G] == Pr[TrueRepeat_G1]. unfold TrueRepeat_G, TrueRepeat_G1. inline_first. comp_skip. assert (Pr [b <-$ Repeat (c x) P; ret f b ] == Pr [b <-$ (y <-$ compMap _ (fun _ => (c x)) (forNats n); match (hd_error (filter P y)) with | None => Repeat (c x) P | Some z => ret z end); ret f b ]). comp_skip. eapply Repeat_unroll_n. eauto. eauto. rewrite H0. clear H0. inline_first. comp_skip. case_eq (hd_error (filter P x0)); intuition. comp_irr_r. edestruct Repeat_c_terminating; eauto. eapply well_formed_Repeat. unfold eq_dec. intuition. eapply (EqDec_dec _). eauto. eauto. reflexivity. Qed. Definition TrueRepeat_G2 := a <-$ A1; bs <-$ compMap _ (fun _ => c a) (forNats n); b_opt <- hd_error (filter P bs); b' <-$ Repeat (c a) P; b <- match b_opt with | None => b' | Some x => x end; ret (f b, if b_opt then false else true). Theorem TrueRepeat_G1_G2_equiv : Pr [TrueRepeat_G1] <= Pr[x <-$ TrueRepeat_G2; ret (fst x || snd x)]. 
r. Definition write_array a i v cs := cs <- write (a + i) v cs; Ret cs. Definition sync_array a i cs := cs <- sync (a + i) cs; Ret cs. Definition size_valid cs := Map.cardinal (CSMap cs) = CSCount cs /\ Map.cardinal (CSMap cs) <= CSMaxCount cs /\ CSMaxCount cs <> 0. Definition addr_valid (d : rawdisk) (cm : cachemap) := forall a, Map.In a cm -> d a <> None. Definition addr_clean (cm : cachemap) a := Map.find a cm = None \/ exists v, Map.find a cm = Some (v, false). Definition addrs_clean cm al := Forall (addr_clean cm) al. Definition cachepred (cache : cachemap) (a : addr) (vs : valuset) : @pred _ addr_eq_dec valuset := (match Map.find a cache with | None => a |+> vs | Some (v, false) => a |+> vs * [[ v = fst vs ]] | Some (v, true) => exists v0, a |+> (v0, snd vs) * [[ v = fst vs /\ In v0 (snd vs) ]] end)%pred. Notation mem_pred := (@mem_pred _ addr_eq_dec _ _ addr_eq_dec _). Definition rep (cs : cachestate) (m : rawdisk) : rawpred := ([[ size_valid cs /\ addr_valid m (CSMap cs) ]] * mem_pred (cachepred (CSMap cs)) m)%pred. Definition synpred (cache : cachemap) (a : addr) (vs : valuset) : @pred _ addr_eq_dec valuset := (exists vsd, a |+> vsd * match Map.find a cache with | None => [[ vs = (fst vsd, nil) ]] | Some (v, false) => [[ vs = (fst vsd, nil) /\ v = fst vsd ]] | Some (v, true) => [[ vs = (v, (fst vsd) :: nil) ]] end)%pred. Definition synrep' (cs : cachestate) (m : rawdisk) : rawpred := ([[ size_valid cs /\ addr_valid m (CSMap cs) ]] * mem_pred (synpred (CSMap cs)) m)%pred. Definition synrep (cs : cachestate) (mbase m : rawdisk) : rawpred := (rep cs mbase /\ synrep' cs m)%pred. Theorem sync_invariant_cachepred : forall cache a vs, sync_invariant (cachepred cache a vs). Proof. unfold cachepred; intros. destruct (Map.find a cache); eauto. destruct p; destruct b; eauto. Qed. Theorem sync_invariant_synpred : forall cache a vs, sync_invariant (synpred cache a vs). Proof. unfold synpred; intros. destruct (Map.find a cache); eauto. destruct p; destruct b; eauto. Qed. Hint Resolve sync_invariant_cachepred sync_invariant_synpred. Theorem sync_invariant_rep : forall cs m, sync_invariant (rep cs m). Proof. unfold rep; eauto. Qed. Hint Resolve sync_invariant_rep. Theorem sync_invariant_synrep' : forall cs m, sync_invariant (synrep' cs m). 
From Huffman Require Export OneStep. From Huffman Require Export HeightPred. From Huffman Require Export CoverMin. From Huffman Require Export OrderedCover. From Huffman Require Export SubstPred. Require Import ArithRing.Section Build. Variable A : Type. Variable f : A -> nat. Inductive build : list (btree A) -> btree A -> Prop := | build_one : forall t : btree A, build (t :: nil) t | build_step : forall (t : btree A) (l1 l2 : list (btree A)), one_step f l1 l2 -> build l2 t -> build l1 t. Theorem build_cover : forall l t, build l t -> cover l t. Proof using. intros l t H; elim H; clear H l t; auto. intros t l1 l2 (l3, (t1, (t2, (HH, (HH1, HH2))))) H0 H1; try assumption. apply cover_node with (1 := HH1); auto. apply cover_permutation with (2 := HH2); auto. Qed. Theorem build_comp : forall (l1 l2 : list (btree A)) (t1 t2 : btree A), build l1 t1 -> build l2 t2 -> weight_tree_list f l1 = weight_tree_list f l2 -> same_sum_leaves f l1 l2 -> weight_tree f t1 = weight_tree f t2. 
Require Import ExtLib.Data.Fin.Set Implicit Arguments. Set Strict Implicit. Set Asymmetric Patterns.Section parametric. Variable T : Type. Inductive vector : nat -> Type := | Vnil : vector 0 | Vcons : forall {n}, T -> vector n -> vector (S n). Definition vector_hd n (v : vector (S n)) : T := match v in vector n' return match n' with | 0 => unit | S _ => T end with | Vnil => tt | Vcons _ x _ => x end. Definition vector_tl n (v : vector (S n)) : vector n := match v in vector n' return match n' with | 0 => unit | S n => vector n end with | Vnil => tt | Vcons _ _ x => x end. Theorem vector_eta : forall n (v : vector n), v = match n as n return vector n -> vector n with | 0 => fun _ => Vnil | S n => fun v => Vcons (vector_hd v) (vector_tl v) end v. Proof. destruct v; auto. Qed. Fixpoint get {n : nat} (f : fin n) : vector n -> T := match f in fin n return vector n -> T with | F0 n => @vector_hd _ | FS n f => fun v => get f (vector_tl v) end. Fixpoint put {n : nat} (f : fin n) (t : T) : vector n -> vector n := match f in fin n return vector n -> vector n with | F0 _ => fun v => Vcons t (vector_tl v) | FS _ f => fun v => Vcons (vector_hd v) (put f t (vector_tl v)) end. Theorem get_put_eq : forall {n} (v : vector n) (f : fin n) val, get f (put f val v) = val. Proof. induction n. { inversion f. } { remember (S n). destruct f. inversion Heqn0; subst; intros; reflexivity. inversion Heqn0; subst; simpl; auto. } Qed. Theorem get_put_neq : forall {n} (v : vector n) (f f' : fin n) val, f <> f' -> get f (put f' val v) = get f v. 
multA divA cs eqA_dec n ltM ltM_dec os aP (exist (fun a => canonical A0 eqA ltM a) x c)); simpl in |- *; auto. intros x0; case x0; simpl in |- *; auto. intros x1 c0 H'0 H'1. apply rstar_rtopO; auto. apply reduceplus_trans with (Q := aQ) (1 := cs) (y := x1); auto. inversion H'0; auto. apply inP_reduceplus with (Q := aP); auto. intros a0 H'3. apply Incl_inp_inPolySet with (P := aP); auto. apply reduceplus_mults_inv with (1 := cs) (a := unit (mks A A0 eqA n ltM x1 c0)); auto. apply unit_nZ; auto. apply unit_T1; auto. inversion H'1; inversion H; auto. Qed. Theorem red_zerop : forall (a : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), red (nf a P) P -> zerop (nf a P). unfold nf in |- *. intros p aP; case p. intros x c. case (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os aP (exist (fun l => canonical A0 eqA ltM l) x c)); auto. unfold red in |- *; auto. intros x0; case x0. intros x1; case x1. simpl in |- *; auto. intros a l c0 H' H'0; inversion H'. simpl in |- *. change (reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec aP (mults (A:=A) multA (n:=n) (unit (mks A A0 eqA n ltM (a :: l) c0)) (a :: l)) (pO A n)) in H'0. inversion H'0. inversion H3. inversion H7. simpl in H0. cut (~ zeroP (A:=A) A0 eqA (n:=n) (unit (mks A A0 eqA n ltM (pX a l) c0))); [ intros nZd | idtac ]; auto. case (H0 (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (T1 A1 n) (b:=unit (mks A A0 eqA n ltM (pX a l) c0)) nZd) y)); auto. apply reduce_mults_invf with (1 := cs); auto. apply unit_T1; auto. apply unit_nZ; auto. Qed. Theorem zerop_red : forall (a : poly A0 eqA ltM) (aP : list (poly A0 eqA ltM)), zerop (nf a aP) -> red a aP. intros a aP H'. apply nf_red with (aP := aP); auto with datatypes. generalize H'; case (nf a aP); simpl in |- *; auto. intros x; case x; simpl in |- *; auto. intros c H'0; red in |- *; simpl in |- *; auto. intros a0 l H'0 H'1; elim H'1; auto. Qed. Theorem canonical_s2p : forall x : poly A0 eqA ltM, canonical A0 eqA ltM (s2p A A0 eqA n ltM x). 
in *. rewrite H5 in *. rewrite H11 in *. specialize (H4 (ex_intro _ _ (refl_equal _))). unfold Provable in H4. injection H; clear H; intros; subst. simpl exprD in *. unfold types0 in *. unfold Provable in *. simpl exprD in *. deconstruct. rewrite H10 in *. specialize (H3 (ex_intro _ _ (refl_equal _))). specialize (H9 (ex_intro _ _ (refl_equal _))). subst. apply simplify_fwd in H2. destruct H2. destruct H. destruct H. destruct H2. destruct H2. destruct H2. destruct H2. destruct H5. simpl in H. simpl in H2. simpl in H5. destruct H5. generalize (split_semp _ _ _ H2 H11); intro; subst. apply simplify_bwd in H9. specialize (smem_read_correct' _ _ _ _ (i := natToW (variablePosition' t x1)) H9); intro Hsmem. rewrite wmult_comm in Hsmem. rewrite <- natToW_times4 in Hsmem. rewrite variablePosition'_4 in Hsmem. erewrite split_smem_get_word; eauto. left. unfold natToW in *. rewrite Hsmem. f_equal. unfold Array.sel. apply array_selN. apply array_bound in H9. rewrite wordToNat_natToWord_idempotent; auto. apply nth_error_variablePosition'; auto. rewrite length_toArray in *. apply Nlt_in. rewrite Nat2N.id. rewrite Npow2_nat. specialize (variablePosition'_length _ _ H4). omega. red. apply array_bound in H9. repeat rewrite wordToN_nat. rewrite wordToNat_natToWord_idempotent. rewrite wordToNat_natToWord_idempotent. apply Nlt_in. repeat rewrite Nat2N.id. rewrite length_toArray. apply variablePosition'_length; auto. apply Nlt_in. rewrite Npow2_nat. repeat rewrite Nat2N.id. assumption. apply Nlt_in. rewrite Npow2_nat. repeat rewrite Nat2N.id. specialize (variablePosition'_length _ _ H4). rewrite length_toArray in H9. omega. Qed. Theorem easy_bridge : forall args uvars vars summ pe ve P, sym_read Prover summ args pe = Some ve -> match applyD (exprD funcs uvars vars) (SEP.SDomain ssig) args _ (SEP.SDenotation ssig) with | None => False | Some p => P p end -> exists ve', sym_read_easier Prover summ args pe = Some ve' /\ exprD funcs uvars vars ve wordT = exprD funcs uvars vars ve' wordT. intros. simpl in H0. repeat (destruct args; simpl in *; try discriminate). case_eq (exprD funcs uvars vars e0 valsT); [ intros ? Heq | intro Heq ]; rewrite Heq in *. Focus 2. deconstruct. deconstruct. match goal with | [ |- context[if ?E then _ else _] ] => destruct E end; try discriminate. deconstruct; eauto. match goal with | [ |- context[if ?E then _ else _] ] => destruct E end; try discriminate. deconstruct. do 2 esplit; [ reflexivity | ]. simpl exprD. destruct e5; try reflexivity. destruct t3; try reflexivity. do 7 (destruct n; try reflexivity). rewrite Heq. erewrite sym_sel_correct by eassumption; reflexivity. Qed. Theorem sym_read_correct : forall args uvars vars cs summ pe p ve m stn, sym_read Prover summ args pe = Some ve -> Valid Prover_correct uvars vars summ -> exprD funcs uvars vars pe wordT = Some p -> match applyD (exprD funcs uvars vars) (SEP.SDomain ssig) args _ (SEP.SDenotation ssig) with | None => False | Some p => ST.satisfies cs p stn m end -> match exprD funcs uvars vars ve wordT with | Some v => ST.HT.smem_get_word (IL.implode stn) p m = Some v | _ => False end. 
bool with | None => fun x _ => match x with end | Some t => fun x y => Eqb t x y end end. Global Instance SemiReflect_Eqb (t : type) (x y : Impl t) : SemiReflect (Eqb _ x y) (x = y). Proof. consider (Eqb t x y); intros; constructor. apply Eqb_correct; auto. Qed. Lemma tvar_val_seqb_correct t x y : tvar_val_seqb t x y = true -> x = y. Proof. revert x y. destruct t; simpl. discriminate. destruct (nth_error types n); simpl. refine (fun x y H => Eqb_correct _ x y H). intros []. Defined. Global Instance SemiReflect_tvar_val_seqb t x y : SemiReflect (tvar_val_seqb t x y) (x = y). Proof. revert x y. destruct t; simpl; intros; try constructor. destruct (nth_error types n); simpl. consider (Eqb t x y); intros; constructor. auto. destruct x. Qed. Fixpoint functionTypeD (domain : list Type) (range : Type) : Type := match domain with | nil => range | d :: domain' => d -> functionTypeD domain' range end. Record signature := Sig { Domain : list tvar; Range : tvar; Denotation : functionTypeD (map tvarD Domain) (tvarD Range) }. Definition Default_signature : signature := {| Domain := nil ; Range := tvProp ; Denotation := True |}. Definition functions := list signature. Definition variables := list tvar. Variable funcs : functions. Variable uvars : variables. Variable vars : variables. Definition func := nat. Definition var := nat. Definition uvar := nat. Unset Elimination Schemes. Inductive expr : Type := | Const : forall t : tvar, tvarD t -> expr | Var : var -> expr | Func : forall f : func, list expr -> expr | Equal : tvar -> expr -> expr -> expr | Not : expr -> expr | UVar : uvar -> expr. Definition exprs : Type := list expr. Set Elimination Schemes. Section expr_ind. Variable P : expr -> Prop. Hypotheses (Hc : forall (t : tvar) (t0 : tvarD t), P (Const t t0)) (Hv : forall x : var, P (Var x)) (Hu : forall x : uvar, P (UVar x)) (Hf : forall (f : func) (l : list expr), Forall P l -> P (Func f l)) (He : forall t e1 e2, P e1 -> P e2 -> P (Equal t e1 e2)) (Hn : forall e, P e -> P (Not e)). Theorem expr_ind : forall e : expr, P e. 
xy as [ x | y ] . apply idpath. apply (fromempty (nf y)). apply (gradth f g egf efg). Defined. Definition weqii1withneg ( X : UU ) { Y : UU } ( nf : neg Y ) := weqpair _ ( isweqii1withneg X nf ) .Theorem isweqii2withneg { X : UU } ( Y : UU ) (nf : X -> empty): isweq (@ii2 X Y). Proof. intros. set (f:= @ii2 X Y). set (g:= fun xy:coprod X Y => match xy with ii1 x => fromempty (nf x) | ii2 y => y end). assert (egf: forall y : Y, paths (g (f y)) y). intro. apply idpath. assert (efg: forall xy: coprod X Y, paths (f (g xy)) xy). intro. destruct xy as [ x | y ] . apply (fromempty (nf x)). apply idpath. apply (gradth f g egf efg). Defined. Definition weqii2withneg { X : UU } ( Y : UU ) ( nf : neg X ) := weqpair _ ( isweqii2withneg Y nf ) .Definition coprodf { X Y X' Y' : UU } (f: X -> X')(g: Y-> Y'): coprod X Y -> coprod X' Y' := fun xy: coprod X Y => match xy with ii1 x => ii1 (f x)| ii2 y => ii2 (g y) end. Definition homotcoprodfcomp { X X' Y Y' Z Z' : UU } ( f : X -> Y ) ( f' : X' -> Y' ) ( g : Y -> Z ) ( g' : Y' -> Z' ) : homot ( funcomp ( coprodf f f' ) ( coprodf g g' ) ) ( coprodf ( funcomp f g ) ( funcomp f' g' ) ) . Proof. intros . intro xx' . destruct xx' as [ x | x' ] . apply idpath . apply idpath . Defined . Definition homotcoprodfhomot { X X' Y Y' } ( f g : X -> Y ) ( f' g' : X' -> Y' ) ( h : homot f g ) ( h' : homot f' g' ) : homot ( coprodf f f') ( coprodf g g') := fun xx' : _ => match xx' with ( ii1 x ) => maponpaths ( @ii1 _ _ ) ( h x ) | ( ii2 x' ) => maponpaths ( @ii2 _ _ ) ( h' x' ) end . Theorem isweqcoprodf { X Y X' Y' : UU } ( w : weq X X' )( w' : weq Y Y' ) : isweq (coprodf w w' ). 
(own_valid_2 with "Hm Hk") as %[Hlookup%map_ptsto_included _]%auth_both_valid_discrete. iMod (own_update_2 with "Hm Hk") as "[Hm $]". { eapply auth_update, singleton_local_update, (exclusive_local_update _ (Cinl (1%Qp, to_agree (v2: leibnizO V))))=> //. rewrite lookup_fmap Hlookup //=. } iModIntro. rewrite -to_mapUR_insert_inl. iExists _; iFrame. iPureIntro. rewrite fmap_insert //. Qed. Theorem map_update_map {Œ≥} m' m0 m : dom m' = dom m0 ‚Üí map_ctx Œ≥ 1 m -‚àó ([‚àó map] a‚Ü¶v ‚àà m0, ptsto_mut Œ≥ a 1 v) -‚àó |==> map_ctx Œ≥ 1 (m' ‚à™ m) ‚àó [‚àó map] a‚Ü¶v ‚àà m', ptsto_mut Œ≥ a 1 v. Proof. iIntros (Hdom) "Hctx Hm0". iInduction m0 as [|l v m0] "IH" using map_ind forall (m m' Hdom). - rewrite dom_empty_L in Hdom; apply dom_empty_iff_L in Hdom as ->. rewrite left_id_L big_sepM_empty. by iFrame. - rewrite big_sepM_insert //. iDestruct "Hm0" as "[Hl Hm0]". rewrite dom_insert_L in Hdom. assert (l ‚àà dom m') by set_solver. apply elem_of_dom in H0 as [v' Hlookup]. iMod (map_update _ _ v' with "Hctx Hl") as "[Hctx Hl]". iSpecialize ("IH" $! (<[l:=v']> m)). apply dom_union_inv_L in Hdom as (m1&m2 & -> & ? & ? & ?); last first. { apply disjoint_singleton_l, not_elem_of_dom; auto. } iMod ("IH" $! m2 with "[%] Hctx Hm0") as "[Hctx Hm0]"; auto. iModIntro. assert (m1 = {[l := v']}). { apply dom_singleton_inv_L in H1 as [v'' ->]. f_equal. erewrite lookup_union_Some_l in Hlookup; last first. { rewrite lookup_singleton_Some //. } congruence. } subst. rewrite big_sepM_union // big_sepM_singleton. iFrame. iExactEq "Hctx". f_equal. rewrite insert_union_singleton_l. rewrite assoc. f_equal. rewrite map_union_comm //. Qed. Theorem map_freeze Œ≥ m k v : map_ctx Œ≥ 1 m -‚àó ptsto_mut Œ≥ k 1 v ==‚àó map_ctx Œ≥ 1 m ‚àó ptsto_ro Œ≥ k v. Proof. unseal. iDestruct 1 as (m_ro ->) "Hm". iIntros "Hk". iDestruct (own_valid_2 with "Hm Hk") as %[Hlookup%map_ptsto_included _]%auth_both_valid_discrete. iMod (own_update_2 with "Hm Hk") as "[Hm $]". { eapply auth_update, singleton_local_update, (exclusive_local_update _ (Cinr (to_agree (v: leibnizO V))))=> //. rewrite lookup_fmap Hlookup //=. } iModIntro. rewrite -to_mapUR_insert_inr. iExists _; iFrame. iPureIntro. apply map_eq; intros k'; rewrite !lookup_fmap. destruct (decide (k = k')); subst. - rewrite lookup_insert Hlookup //. - rewrite lookup_insert_ne //. Qed. Theorem map_alloc_ro {Œ≥ m} k v : m !! k = None ‚Üí map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (<[k:=v]> m) ‚àó ptsto_ro Œ≥ k v. Proof. iIntros (?) "Hm". iMod (map_alloc k v with "Hm") as "[Hm Hk]"; auto. iMod (map_freeze with "Hm Hk") as "[$ $]". auto. Qed. Theorem map_alloc_many' {Œ≥ m} m0 Œ¶: (‚àÄ m k v, m !! k = None ‚Üí map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (<[k:=v]> m) ‚àó Œ¶ k v) ‚Üí ( ‚àÄ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (m0 ‚à™ m) ‚àó [‚àó map] a‚Ü¶v ‚àà m0, Œ¶ a v. 
mult_0_r. intuition. trivial. trivial. rewrite (mult_comm (expnat n x)). repeat rewrite mult_assoc. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite mult_comm. eapply mult_le_compat; trivial. rewrite <- mult_1_l at 1. eapply mult_le_compat; trivial. eapply expnat_ge_1. omega. destruct (eq_nat_dec n 0); subst. repeat rewrite expnat_0. simpl. repeat rewrite mult_0_r. intuition. trivial. trivial. rewrite (mult_comm (expnat n x)). repeat rewrite mult_assoc. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite <- mult_assoc. rewrite (mult_comm (expnat n x2)). rewrite mult_assoc. eapply mult_le_compat; trivial. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. rewrite <- mult_1_r at 1. eapply mult_le_compat; trivial. eapply expnat_ge_1. omega. Qed. Require Import FCF.Rat. Local Open Scope rat_scope.Definition negligible(f : nat -> Rat) := forall c, exists n, forall x (pf_nz : nz x), x > n -> ~ ((1 / expnat x c) <= f x)%rat. Theorem negligible_eq : forall (f1 f2 : nat -> Rat), negligible f1 -> (forall n, f1 n == f2 n) -> negligible f2. intuition. unfold negligible in *. intuition. edestruct H. econstructor. intuition. eapply H1. eauto. rewrite H3. rewrite <- H0. intuition.Qed.Lemma negligible_le : forall f1 f2, (forall n, f2 n <= f1 n)%rat -> negligible f1 -> negligible f2. intuition. unfold negligible in *. intuition. edestruct H0. econstructor. intuition. eapply H1. eauto. rewrite H3. eauto. Qed.Lemma negligible_plus : forall f1 f2, negligible f1 -> negligible f2 -> negligible (fun n => f1 n + f2 n)%rat. unfold negligible in *. intuition. destruct (H (S c)). destruct (H0 (S c)). exists (max 1 (max x x0)). intuition. apply Nat.max_lub_lt_iff in H3. intuition. assert (1 / expnat x1 c <= 2/1 * (maxRat (f1 x1) (f2 x1)))%rat. eapply leRat_trans. eapply H4. eapply ratAdd_2_ratMax. assert (1 / expnat x1 (S c) <= RatIntro 1 (posnatMult (pos 2) (pos (expnat x1 c))))%rat. eapply leRat_terms; intuition. unfold natToPosnat, posnatToNat, posnatMult. eapply expnat_double_le. omega. unfold maxRat in *. case_eq (bleRat (f1 x1) (f2 x1)); intuition. rewrite H8 in H3. eapply H2. eapply le_lt_trans. eapply Max.le_max_r. eauto. rewrite H7. rewrite rat_mult_den. rewrite H3. rewrite <- ratMult_assoc. rewrite <- ratMult_num_den. rewrite num_dem_same_rat1. rewrite ratMult_1_l. intuition. unfold posnatMult, natToPosnat, posnatToNat. omega. rewrite H8 in H3. eapply H1. eapply le_lt_trans. eapply Max.le_max_l. eauto. rewrite H7. rewrite rat_mult_den. rewrite H3. rewrite <- ratMult_assoc. rewrite <- ratMult_num_den. rewrite num_dem_same_rat1. rewrite ratMult_1_l. intuition. unfold posnatMult, natToPosnat, posnatToNat. omega. Qed.Local Open Scope nat_scope. Theorem double_log_plus_3_le_h : forall y x, y = Nat.log2 x -> y >= 4 -> 2 * y + 3 <= x. 
Require Import Prog. Require Import Hoare. Require Import ProofIrrelevance.Set Implicit Arguments.Ltac inj_existT := match goal with | [ H: existT ?P ?p _ = existT ?P ?p _ |- _ ] => apply inj_pair2 in H end.Ltac inv_step := match goal with | [ H: step _ _ _ _ _ _ _ _ |- _ ] => inversion H; repeat inj_existT; subst; clear H end.Ltac inv_fail_step := try match goal with | [ H: exec _ _ _ _ (Failed _) |- _ ] => inversion H; repeat inj_existT; subst; clear H end; match goal with | [ H: fail_step _ _ _ |- _ ] => inversion H; subst; clear H end.Ltac inv_crash_step := try match goal with | [ H: exec _ _ _ _ (Crashed _ _ _) |- _ ] => inversion H; repeat inj_existT; subst; clear H end; match goal with | [ H: crash_step _ |- _ ] => inversion H; subst; clear H end.Ltac inv_exec' H := inversion H; repeat inj_existT; subst; try inv_step; try inv_fail_step; try inv_crash_step; subst; clear H.Ltac inv_exec := lazymatch goal with | [ H: exec _ _ _ (Ret _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (AlertModified) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (Debug _ _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ (Bind _ _) _ |- _ ] => inv_exec' H | [ H: exec _ _ _ _ _ |- _ ] => inv_exec' H end.Section MonadLaws. Definition prog_equiv T : prog T -> prog T -> Prop := fun p1 p2 => forall m vm hm out, exec m vm hm p1 out <-> exec m vm hm p2 out. Arguments prog_equiv {T} _ _. Infix "~=" := prog_equiv (at level 50, left associativity). Theorem bind_left_id : forall T T' v (p: T -> prog T'), Bind (Ret v) p ~= p v. Proof. split; intros. - inv_exec. inv_exec; eauto. - eauto. Qed. Theorem bind_left_alert_modified : forall T' (p: unit -> prog T'), Bind (AlertModified) p ~= p tt. 
Section Relations. Variable A : Set. Variable R : A -> A -> Prop. Definition Rstar (x y : A) := forall P : A -> A -> Prop, (forall u : A, P u u) -> (forall u v w : A, R u v -> P v w -> P u w) -> P x y. Theorem Rstar_reflexive : forall x : A, Rstar x x. Proof fun (x : A) (P : A -> A -> Prop) (h1 : forall u : A, P u u) (h2 : forall u v w : A, R u v -> P v w -> P u w) => h1 x. Theorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z. Proof fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop) (h1 : forall u : A, P u u) (h2 : forall u v w : A, R u v -> P v w -> P u w) => h2 x y z t1 (t2 P h1 h2). Theorem Rstar_transitive : forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z. 
(cs:=cs). + apply qic_additivity. + apply qic_nonzero. } inst_next (fun l => maxl l). do 3 (prove_rule H).inst_next maxl. do 4 (prove_rule H).inst_next (fun l => maxl l). prove_rule H.rewrite cons_app. apply QI.p_smc_QI_app. { intros f lp t s. cbn. intro H. destruct H; try tauto. inversion H. subst. unfold map. simpl. rewrite QI.value_as_p_term_assignment. simpl. eexists. eexists. repeat split; auto. rewrite Nat.max_0_r. unfold qic at 1. simpl. unfold cs. apply le_trans with (m:=Syntax.value_size (s q)). - rewrite <- Syntax.compatible_sizes with (variable:=variable) (function:=function). set (v:=Syntax.term_from_value variable function (s q)). generalize (Syntax.gt_term_size_O v). intro. omega. - apply QI.value_size_le_QI with (cs:=cs). + apply qic_additivity. + apply qic_nonzero. }inst_next maxl. prove_rule H.inst_next maxl. do 2 (prove_rule H). inst_next (fun l => suml l + 1). do 4 (prove_rule H). inst_next (fun l => suml l + 1). do 2 (prove_rule H).inst_next (fun l => maxl l + 1); do 3 (prove_rule H). inst add_carryF (fun l => maxl l + 1). inst_next (fun l => maxl l + 1). do 18 (prove_rule H).inst_next (fun l => maxl l + 1); do 3 (prove_rule H).inst_next (fun l => match l with [p1;y1;m1;c1] => (m1+3) * (c1+1) + max p1 y1 | _ => maxl l end). do 3 (prove_rule H).inst_next (fun l => match l with [p1;y1;m1;c1] => (m1+3) * (c1+1) + max p1 y1 | _ => maxl l end). do 2 (prove_rule H).inst_next (fun l => match l with [x1;y1;m1;c1] => x1 + (y1 + 1) * 2 * (m1+3) * (c1+1) | _ => maxl l end). do 3 (prove_rule H). inst_next (fun l => maxl l +1). do 5 (prove_rule H).inst_next (fun l => match l with [x1;y1;m1] => x1 + (y1+1) * 2 * (m1+3) * (m1+2) | _ => maxl l end). do 2 (prove_rule H).eexists (fun x => None). unfold QI.p_smc, QI.p_compatible_QI, QI.p_subterm, QI.p_monotonicity. repeat split.- intros f l x Hin; assert(H' := maxl_is_max _ _ Hin); assert (H'' := maxl_le_suml l); destruct f; simpl; trivial; try omega; (repeat (destruct l; trivial); repeat(destruct Hin as [ H | Hin]; [subst; simpl; try_prove_ineq |]); try inversion Hin). simpl; nia.- intros f xs ys Hfor. destruct f; qif_monotonic_tac; repeat (destruct Hfor; simpl; try qif_monotonic_tac). - simpl; tauto. Defined.Definition qif := proj1_sig qif_proofs.Proposition qi_is_valid : valid_QI mcs qic qif cs. Proof. unfold qif. destruct qif_proofs as (qif & Hs & Hm & Hc). repeat split; trivial. apply qic_bounded. apply qic_nonzero. Qed. Theorem polytime: forall i s p c f lv d v, let t := fapply f lv in let pi := cbv_update i s p c t d v in cbv_wf pi -> cache_bounded qic qif c -> cbv_size pi <= global_bound mcs qif f lv c. 
n = o. Admitted. QuickChick trans_eq. *)Example trans_eq_example' : forall (a b c d e f : nat), [a;b] = [c;d] -> [c;d] = [e;f] -> [a;b] = [e;f]. Admitted. Example trans_eq_exercise : forall (n m o p : nat), m = (minustwo o) -> (n + p) = m -> (n + p) = (minustwo o). Admitted. Theorem S_injective : forall (n m : nat), S n = S m -> n = m. Admitted. Theorem beq_nat_0_l : forall n, 0 = n -> n = 0. Admitted. QuickChick beq_nat_0_l. *)Theorem inversion_ex4 : forall (n : nat), S n = O -> 2 + 2 = 5. Admitted. Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A), x = y -> f x = f y. Admitted. Theorem plus_n_n_injective : forall n m, n + n = m + m -> n = m. Admitted. Theorem double_injective : forall n m, double n = double m -> n = m. Admitted. Theorem beq_id_true : forall (x y : id), x = y -> x = y. Admitted. QuickChick beq_id_true. *) Theorem nth_error_after_last: forall (X : Type) (l : list X) (n : nat), length l = n -> nth_error l n = None. Admitted. QuickChick nth_error_after_last. *)Definition square n := n * n.Lemma square_mult : forall n m, square (n * m) = square n * square m. Admitted. Definition foo (x: nat) := 5.Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1. Admitted. Definition bar x := match x with | O => 5 | S _ => 5 end.Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1. Admitted. Definition sillyfun (n : nat) : bool := if beq_nat n 3 then false else if beq_nat n 5 then false else false.Theorem sillyfun_false : forall (n : nat), sillyfun n = false. Admitted. Definition sillyfun1 (n : nat) : bool := if beq_nat n 3 then true else if beq_nat n 5 then true else false.Theorem sillyfun1_odd : forall (n : nat), sillyfun1 n = true -> oddb n = true. Admitted. Theorem bool_fn_applied_thrice : forall (f : bool -> bool) (b : bool), f (f (f b)) = f b. Admitted. Theorem beq_nat_sym : forall (n m : nat), beq_nat n m = beq_nat m n. Admitted. Theorem beq_nat_trans : forall n m p, beq_nat n m = true -> beq_nat m p = true -> beq_nat n p = true. 
| wp_encapsulate : forall l:list par, wp l -> wp (open :: l ++ close :: nil). Theorem wp_oc : wp (open :: close :: nil). Proof. change (wp (open :: nil ++ close :: nil)) in |- *. apply wp_encapsulate. apply wp_nil. Qed. Theorem wp_o_head_c : forall l1 l2:list par, wp l1 -> wp l2 -> wp (open :: l1 ++ close :: l2). Proof. intros l1 l2 H1 H2. replace (open :: l1 ++ close :: l2) with ((open :: l1 ++ close :: nil) ++ l2). - apply wp_concat. apply wp_encapsulate; trivial. trivial. - repeat (simpl in |- *; rewrite app_ass); simpl in |- *. trivial. Qed. Theorem wp_o_tail_c : forall l1 l2:list par, wp l1 -> wp l2 -> wp (l1 ++ open :: l2 ++ close :: nil). Proof. intros l1 l2 H1 H2; apply wp_concat. - trivial. - now apply wp_encapsulate. Qed. Inductive bin : Set := | L : bin | N : bin -> bin -> bin. Fixpoint bin_to_string (t:bin) : list par := match t with | L => nil (A:=par) | N u v => open :: bin_to_string u ++ close :: bin_to_string v end.Theorem bin_to_string_wp : forall t:bin, wp (bin_to_string t). Proof. simple induction t. - simpl ; apply wp_nil. - simpl ; intros t1 H1 t2 H2; apply wp_o_head_c; trivial. Qed.#[export] Hint Resolve wp_nil wp_concat wp_encapsulate wp_o_head_c wp_o_tail_c wp_oc : core.Fixpoint bin_to_string' (t:bin) : list par := match t with | L => nil (A:=par) | N u v => bin_to_string' u ++ open :: bin_to_string' v ++ close :: nil end. Theorem bin_to_string'_wp : forall t:bin, wp (bin_to_string' t). Proof. simple induction t; simpl ; auto. Qed. Inductive parse_rel : list par -> list par -> bin -> Prop := | parse_node : forall (l1 l2 l3:list par) (t1 t2:bin), parse_rel l1 (close :: l2) t1 -> parse_rel l2 l3 t2 -> parse_rel (open :: l1) l3 (N t1 t2) | parse_leaf_nil : parse_rel nil nil L | parse_leaf_close : forall l:list par, parse_rel (close :: l) (close :: l) L. Theorem parse_rel_sound_aux : forall (l1 l2:list par) (t:bin), parse_rel l1 l2 t -> l1 = bin_to_string t ++ l2. Proof. intros l1 l2 t H; elim H; clear H l1 l2 t. - intros l1 l2 l3 t1 t2 Hp Hr1 Hp2 Hr2; simpl. rewrite app_ass, Hr1; simpl. now rewrite Hr2. - reflexivity. - reflexivity. Qed. Theorem parse_rel_sound : forall l:list par, (exists t : bin, parse_rel l nil t) -> wp l. 
= (x * (1 + eps))%R. Proof with auto with typeclass_instances. intros m x. apply relative_error_lt_conversion... apply bpow_gt_0. now apply relative_error_F2R_emin. Qed.Theorem relative_error_round : (0 < p)%Z -> forall x, (bpow emin <= Rabs x)%R -> (Rabs (round beta fexp rnd x - x) < bpow (-p + 1) * Rabs (round beta fexp rnd x))%R. Proof with auto with typeclass_instances. intros Hp x Hx. assert (Hx': (x <> 0)%R). intros T; contradict Hx; rewrite T, Rabs_R0. apply Rlt_not_le, bpow_gt_0. apply Rlt_le_trans with (ulp beta fexp x)%R. now apply error_lt_ulp. rewrite ulp_neq_0; trivial. unfold cexp. destruct (mag beta x) as (ex, He). simpl. specialize (He Hx'). assert (He': (emin < ex)%Z). apply (lt_bpow beta). apply Rle_lt_trans with (2 := proj2 He). exact Hx. apply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R. rewrite <- bpow_plus. apply bpow_le. generalize (Hmin ex). omega. apply Rmult_le_compat_l. apply bpow_ge_0. generalize He. apply round_abs_abs... clear rnd valid_rnd x Hx Hx' He. intros rnd valid_rnd x _ Hx. rewrite <- (round_generic beta fexp rnd (bpow (ex - 1))). now apply round_le. apply generic_format_bpow. ring_simplify (ex - 1 + 1)%Z. generalize (Hmin ex). omega. Qed.Theorem relative_error_round_F2R_emin : (0 < p)%Z -> forall m, let x := F2R (Float beta m emin) in (x <> 0)%R -> (Rabs (round beta fexp rnd x - x) < bpow (-p + 1) * Rabs (round beta fexp rnd x))%R. Proof. intros Hp m x Hx. apply relative_error_round. exact Hp. unfold x. rewrite <- F2R_Zabs. apply bpow_le_F2R. apply lt_F2R with beta emin. rewrite F2R_0, F2R_Zabs. now apply Rabs_pos_lt. Qed.Variable choice : Z -> bool.Theorem relative_error_N : forall x, (bpow emin <= Rabs x)%R -> (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * bpow (-p + 1) * Rabs x)%R. Proof. intros x Hx. apply Rle_trans with (/2 * ulp beta fexp x)%R. now apply error_le_half_ulp. rewrite Rmult_assoc. apply Rmult_le_compat_l. apply Rlt_le. apply Rinv_0_lt_compat. now apply IZR_lt. assert (Hx': (x <> 0)%R). intros H. apply Rlt_not_le with (2 := Hx). rewrite H, Rabs_R0. apply bpow_gt_0. rewrite ulp_neq_0; trivial. unfold cexp. destruct (mag beta x) as (ex, He). simpl. specialize (He Hx'). apply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R. rewrite <- bpow_plus. apply bpow_le. assert (emin < ex)%Z. apply (lt_bpow beta). apply Rle_lt_trans with (2 := proj2 He). exact Hx. generalize (Hmin ex). omega. apply Rmult_le_compat_l. apply bpow_ge_0. apply He. Qed. Theorem relative_error_N_ex : forall x, (bpow emin <= Rabs x)%R -> exists eps, (Rabs eps <= /2 * bpow (-p + 1))%R /\ round beta fexp (Znearest choice) x = (x * (1 + eps))%R. 
m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. 
Require Export MSB. Section MSBProp. Variable b : Fbound. Variable precision : nat. Variable radix : Z. Let FtoRradix := FtoR radix. Coercion FtoRradix : float >-> R. Hypothesis radixMoreThanOne : (1 < radix)%Z. Let radixMoreThanZERO : (0 < radix)%Z := Zlt_1_O _ (Zlt_le_weak _ _ radixMoreThanOne). Hint Resolve radixMoreThanZERO: zarith. Hypothesis precisionGreaterThanOne : 1 < precision. Hypothesis pGivesBound : Zpos (vNum b) = Zpower_nat radix precision. Theorem boundOnePrecision : forall a : float, Fbounded b a -> (Rabs a < Float 1%nat (precision + Fexp a))%R. intros a H. replace (FtoRradix (Float 1%nat (precision + Fexp a))) with (FtoRradix (Fshift radix precision (Float 1%nat (precision + Fexp a)))); [ idtac | apply (FshiftCorrect radix); auto ]. unfold Fshift, FtoRradix, FtoR in |- *; simpl in |- *. rewrite <- pGivesBound. replace (precision + Fexp a - precision)%Z with (Fexp a); [ idtac | ring ]. rewrite Rabs_mult; rewrite (fun x y => Rabs_pos_eq (powerRZ x y)); auto with real zarith. apply Rlt_monotony_exp; auto with float real zarith. rewrite Faux.Rabsolu_Zabs; auto with float real zarith. Qed. Theorem boundNormalMult : forall x y : float, Fnormal radix b x -> Fbounded b y -> (Rabs y * Float 1%nat (Fexp x) < radix * (Rabs x * Float 1%nat (Fexp y)))%R. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Main.Local Open Scope morphism_scope.Section Algebras. Context {C : Category} (T : (C --> C)%functor). Record Algebra : Type := { Alg_Carrier : C; Constructors : (T _o Alg_Carrier)%object --> Alg_Carrier }. Record Algebra_Hom (alg alg' : Algebra) : Type := { Alg_map : (Alg_Carrier alg) --> (Alg_Carrier alg'); Alg_map_com : ((Constructors alg') ‚àò (T _a Alg_map) = Alg_map ‚àò (Constructors alg))%morphism }. Arguments Alg_map {_ _} _. Arguments Alg_map_com {_ _} _. Program Definition Algebra_Hom_compose {alg alg' alg'' : Algebra} (h : Algebra_Hom alg alg') (h' : Algebra_Hom alg' alg'') : Algebra_Hom alg alg'' := {| Alg_map := ((Alg_map h') ‚àò (Alg_map h))%morphism |}. Next Obligation. Proof. destruct h as [alm almcm]; destruct h' as [alm' almcm']; cbn. rewrite F_compose. rewrite assoc_sym. rewrite almcm'. rewrite assoc. rewrite almcm. auto. Qed. Lemma Algebra_Hom_eq_simplify (alg alg' : Algebra) (ah ah' : Algebra_Hom alg alg') : (Alg_map ah) = (Alg_map ah') -> ah = ah'. Proof. intros; destruct ah; destruct ah'; cbn in *. ElimEq. PIR. trivial. Qed. Theorem Algebra_Hom_compose_assoc {alg alg' alg'' alg''' : Algebra} (f : Algebra_Hom alg alg') (g : Algebra_Hom alg' alg'') (h : Algebra_Hom alg'' alg''') : (Algebra_Hom_compose f (Algebra_Hom_compose g h)) = (Algebra_Hom_compose (Algebra_Hom_compose f g) h). Proof. apply Algebra_Hom_eq_simplify; cbn; auto. Qed. Program Definition Algebra_Hom_id (alg : Algebra) : Algebra_Hom alg alg := {| Alg_map := id |}. Theorem Algebra_Hom_id_unit_left {alg alg' : Algebra} (f : Algebra_Hom alg alg') : (Algebra_Hom_compose f (Algebra_Hom_id alg')) = f. Proof. apply Algebra_Hom_eq_simplify; cbn; auto. Qed. Theorem Algebra_Hom_id_unit_right {alg alg' : Algebra} (f : Algebra_Hom alg alg') : (Algebra_Hom_compose (Algebra_Hom_id alg) f) = f. 
Require Import Bedrock.Platform.Thread Bedrock.Platform.Arrays8 Bedrock.Platform.MoreArrays Bedrock.Platform.Buffers Bedrock.Platform.Io Bedrock.Platform.tests.StringDb. Require Import Coq.Strings.Ascii.Definition W_of_ascii (ch : ascii) : W := N_of_ascii ch. Coercion W_of_ascii : ascii >-> W.Local Hint Extern 1 (@eq W _ _) => words. Section strings. Open Scope Sep_scope. Fixpoint strings (n : nat) (p : W) : HProp := Ex len, p =*> len * match n with | O => [| len = 0 |] | S n' => [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Definition strings' (n : nat) (p len : W) : HProp := match n with | O => [| len = 0 |] | S n' => [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len') end. Theorem strings_fwd : forall n p, strings n p ===> Ex len, p =*> len * strings' n p len. destruct n; sepLemma. Qed. Theorem strings_bwd : forall n p, Ex len, p =*> len * strings' n p len ===> strings n p. destruct n; sepLemma. Qed. Theorem strings'_fwd_zero : forall n p (len : W), len = 0 -> strings' n p len ===> Emp. destruct n; sepLemma. Qed. Theorem strings'_fwd_nonzero : forall n p (len : W), len <> 0 -> strings' n p len ===> Ex n', [| n = S n' |] * [| len <> 0 |] * (p ^+ $4) =?>8 wordToNat len * Ex len', (p ^+ $4 ^+ len) =*> len' * (p ^+ $4 ^+ len ^+ $4) =?>8 wordToNat len' * strings n' (p ^+ $4 ^+ len ^+ $4 ^+ len'). 
H'3); intros H'4. 2: split; auto. 2: apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with zarith. absurd (Fnum (Fshift radix (Zabs_nat (Fexp p - Fexp q)) p) < Fnum q)%Z; auto. 2: apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with zarith. 2: unfold FtoRradix in |- *; rewrite FshiftCorrect; auto. 2: unfold Fshift in |- *; simpl in |- *; auto with zarith. 2: replace (Z_of_nat (Zabs_nat (Fexp p - Fexp q))) with (Fexp p - Fexp q)%Z; auto with zarith. 2: cut (0 < Fexp p - Fexp q)%Z; auto with zarith. 2: case (Fexp p - Fexp q)%Z; simpl in |- *; auto with zarith. 2: intros p0; rewrite (inject_nat_convert (Zpos p0)); auto with arith. 2: intros p0 H'5; discriminate. red in |- *; intros H'5. absurd (Fdigit radix (Fshift radix (Zabs_nat (Fexp p - Fexp q)) p) <= Fdigit radix q); auto with arith. rewrite FshiftFdigit; auto with arith. replace (Fdigit radix p) with precision. replace (Fdigit radix q) with precision; auto with zarith. cut (0 < Fexp p - Fexp q)%Z; auto with zarith. case (Fexp p - Fexp q)%Z; simpl in |- *; auto with zarith. intros p0 H'6; generalize (convert_not_O p0); auto with zarith. intros p0 H'6; discriminate. apply sym_equal; auto with float. apply sym_equal; auto with float. apply FnormalNotZero; auto with arith. unfold Fdigit in |- *; apply digit_monotone; auto with arith. repeat rewrite Zabs_eq; auto with zarith. apply LeR0Fnum with (radix := radix); auto with zarith. apply Rle_trans with (r2 := FtoRradix p); auto with real. apply LeR0Fnum with (radix := radix); auto with zarith. unfold FtoRradix in |- *; rewrite FshiftCorrect; auto. Qed. Theorem FnormalLtNeg : forall p q : float, Fnormal p -> Fnormal q -> (q <= 0)%R -> (p < q)%R -> (Fexp q < Fexp p)%Z \/ Fexp p = Fexp q /\ (Fnum p < Fnum q)%Z. intros p q H' H'0 H'1 H'2. cut ((Fexp (Fopp q) < Fexp (Fopp p))%Z \/ Fexp (Fopp q) = Fexp (Fopp p) /\ (Fnum (Fopp q) < Fnum (Fopp p))%Z). simpl in |- *. intros H'3; elim H'3; clear H'3; intros H'3; [ idtac | elim H'3; clear H'3; intros H'3 H'4 ]; auto; right; split; auto with zarith. apply FnormalLtPos; try apply FnormalFop; auto; unfold FtoRradix in |- *; repeat rewrite Fopp_correct; replace 0%R with (-0)%R; auto with real. Qed. Definition nNormMin := Zpower_nat radix (pred precision). Theorem nNormPos : (0 < nNormMin)%Z. 
else (ulp (pred x)))%R -> round beta fexp Zceil (pred x + eps) = x. Proof. intros x Fx eps Heps. rewrite round_UP_plus_eps. now apply succ_pred. now apply generic_format_pred. unfold pred at 4. rewrite Ropp_involutive, pred_succ. rewrite ulp_opp. generalize Heps; case (Rle_bool_spec x 0); intros H1 H2. rewrite Rle_bool_false; trivial. case H1; intros H1'. apply Rlt_le_trans with (2:=H1). apply pred_lt_id. now apply Rlt_not_eq. rewrite H1'; unfold pred, succ. rewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right]. rewrite Rplus_0_l. rewrite <- Ropp_0; apply Ropp_lt_contravar. apply Rlt_le_trans with (1:=proj1 H2). apply Rle_trans with (1:=proj2 H2). rewrite Ropp_0, H1'. now right. rewrite Rle_bool_true; trivial. now apply pred_ge_0. now apply generic_format_opp. Qed. Theorem round_DN_minus_eps: forall x, F x -> forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x) else (ulp (pred x)))%R -> round beta fexp Zfloor (x - eps) = pred x. Proof. intros x Fx eps Heps. replace (x-eps)%R with (-(-x+eps))%R by ring. rewrite round_DN_opp. unfold pred; apply f_equal. pattern (-x)%R at 1; rewrite <- (pred_succ (-x)). apply round_UP_pred_plus_eps. now apply generic_format_succ, generic_format_opp. rewrite pred_succ. rewrite ulp_opp. generalize Heps; case (Rle_bool_spec x 0); intros H1 H2. rewrite Rle_bool_false; trivial. case H1; intros H1'. apply Rlt_le_trans with (-x)%R. now apply Ropp_0_gt_lt_contravar. apply succ_ge_id. rewrite H1', Ropp_0, succ_eq_pos;[idtac|now right]. rewrite Rplus_0_l. apply Rlt_le_trans with (1:=proj1 H2). rewrite H1' in H2; apply H2. rewrite Rle_bool_true. now rewrite succ_opp, ulp_opp. rewrite succ_opp. rewrite <- Ropp_0; apply Ropp_le_contravar. now apply pred_ge_0. now apply generic_format_opp. now apply generic_format_opp. Qed. Theorem error_lt_ulp : forall rnd { Zrnd : Valid_rnd rnd } x, (x <> 0)%R -> (Rabs (round beta fexp rnd x - x) < ulp x)%R. Proof with auto with typeclass_instances. intros rnd Zrnd x Zx. destruct (generic_format_EM beta fexp x) as [Hx|Hx].rewrite round_generic... unfold Rminus. rewrite Rplus_opp_r, Rabs_R0. rewrite ulp_neq_0; trivial. apply bpow_gt_0.destruct (round_DN_or_UP beta fexp rnd x) as [H|H] ; rewrite H ; clear H.rewrite Rabs_left1. rewrite Ropp_minus_distr. apply Rplus_lt_reg_l with (round beta fexp Zfloor x). rewrite <- round_UP_DN_ulp with (1 := Hx). ring_simplify. assert (Hu: (x <= round beta fexp Zceil x)%R). apply round_UP_pt... destruct Hu as [Hu|Hu]. exact Hu. elim Hx. rewrite Hu. apply generic_format_round... apply Rle_minus. apply round_DN_pt...rewrite Rabs_pos_eq. rewrite round_UP_DN_ulp with (1 := Hx). apply Rplus_lt_reg_r with (x - ulp x)%R. ring_simplify. assert (Hd: (round beta fexp Zfloor x <= x)%R). apply round_DN_pt... destruct Hd as [Hd|Hd]. exact Hd. elim Hx. rewrite <- Hd. apply generic_format_round... apply Rle_0_minus. apply round_UP_pt... Qed. Theorem error_le_ulp : forall rnd { Zrnd : Valid_rnd rnd } x, (Rabs (round beta fexp rnd x - x) <= ulp x)%R. 
(set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply gss. apply gso; auto. Qed. Theorem grs: forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None. Proof. intros. apply PTree.grs. Qed. Theorem gro: forall (A: Type) (i j: elt) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. intros. apply PTree.gro. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. Proof. intros. destruct (elt_eq i j). subst j; apply grs. apply gro; auto. Qed. Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq. Theorem beq_sound: forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A), beq eqA t1 t2 = true -> forall (x: elt), match get x t1, get x t2 with | None, None => True | Some y1, Some y2 => eqA y1 y2 = true | _, _ => False end. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Functor.Functor. Section Opposite_Functor. Context {C D : Category} (F : (C ‚Äì‚âª D)%functor). Local Open Scope morphism_scope. Local Open Scope object_scope. Program Definition Opposite_Functor : (C^op ‚Äì‚âª D^op)%functor := {| FO := F _o; FA := fun _ _ h => F @_a _ _ h; F_id := fun a => F_id F a; F_compose := fun _ _ _ f g => F_compose F g f |}.End Opposite_Functor.Notation "F '^op'" := (Opposite_Functor F) : functor_scope. Section Functor_Compose. Context {C C' C'' : Category} (F : (C ‚Äì‚âª C')%functor) (F' : (C' ‚Äì‚âª C'')%functor). Local Open Scope morphism_scope. Local Open Scope object_scope. Program Definition Functor_compose : (C ‚Äì‚âª C'')%functor := {| FO := fun c => F' _o (F _o c); FA := fun c d f => F' _a (F _a f) |}. End Functor_Compose.Notation "F ‚àò G" := (Functor_compose G F) : functor_scope. Section Functor_Assoc. Context {C1 C2 C3 C4 : Category} (F : (C1 ‚Äì‚âª C2)%functor) (G : (C2 ‚Äì‚âª C3)%functor) (H : (C3 ‚Äì‚âª C4)%functor). Local Open Scope functor_scope. Theorem Functor_assoc : (H ‚àò G) ‚àò F = H ‚àò (G ‚àò F). Proof. Func_eq_simpl; trivial. Qed.End Functor_Assoc.Program Definition Functor_id (C : Category) : (C ‚Äì‚âª C)%functor := {| FO := fun x => x; FA := fun c d f => f |}.Section Functor_Identity_Unit. Context (C C' : Category) (F : (C ‚Äì‚âª C')%functor). Theorem Functor_id_unit_left : ((Functor_id C') ‚àò F)%functor = F. 
by auto. trivial. 2: instantiate (1 := fun rt => forall v, (fix well_formed' {rt : rectype} : data (RecF rt) -> Prop := match rt as rt return (data (RecF rt) -> Prop) with | [] => fun _ => True | (_, ft) :: t' => fun r => let (r0, r') := r in well_formed r0 /\ well_formed' r' end) rt v -> (fix word2rec (t : rectype) (w : word (len (RecF t))) : recdata t := match t as t return word (len (RecF t)) -> recdata t with | nil => fun _ => tt | (_, ft) :: t' => fun w => (of_word (split1 (len ft) (len (RecF t')) w), word2rec t' (split2 (len ft) (len (RecF t')) w)) end w) rt ((fix rec2word {t : rectype} (r : recdata t) : word (len (RecF t)) := match t as t return recdata t -> word (len (RecF t)) with | nil => fun _ => WO | (_, _) :: _ => fun r => let (v, r') := r in combine (to_word v) (rec2word r') end r) rt v) = v). apply IHt. simpl. intros v t. destruct v. trivial. simpl. intro v. destruct v. intro Hrl. destruct Hrl. rewrite split1_combine. rewrite split2_combine. rewrite IHt0 by assumption. rewrite IHt by assumption. trivial. Qed. Theorem to_eq : forall ft a b, @to_word ft a = @to_word ft b -> well_formed a -> well_formed b -> a = b. Proof. intros. rewrite <- Rec.of_to_id with (v := a) by auto. rewrite <- Rec.of_to_id with (v := b) by auto. congruence. Qed. Theorem of_eq : forall ft a b, @of_word ft a = @of_word ft b -> a = b. Proof. intros. rewrite <- Rec.to_of_id with (w := a). rewrite <- Rec.to_of_id with (w := b). congruence. Qed. Lemma of_word_empty : forall t n w, n = 0 -> @of_word (ArrayF t n) w = nil. Proof. intros. generalize w. rewrite H. intros. simpl in w0. apply length_nil. reflexivity. Qed. Theorem of_word_length : forall ft w, well_formed (@of_word ft w). Proof. einduction ft using type_rect_nest. simpl. trivial. simpl. induction n. split; trivial. intro w. edestruct IHn. split. simpl. rewrite H. trivial. simpl. constructor. apply IHt. assumption. apply IHt. simpl. trivial. simpl. intro w. split. apply IHt. apply IHt0. Qed. Theorem of_word_well_formed : forall (ft:type) w, well_formed (@of_word ft w). Proof. apply of_word_length. Qed. Theorem array_of_word_length : forall ft n w, List.length (@of_word (ArrayF ft n) w) = n. 
real zarith. apply Rplus_eq_reg_l with (r := FtoR radix y); auto with real. Qed. Theorem Feq_bool_correct_f : forall x y : float, Feq_bool x y = false -> ~ Feq x y. intros x y H'; Contradict H'. rewrite Feq_bool_correct_r; auto with arith. red in |- *; intros H'0; discriminate. Qed. Definition Flt_bool (x y : float) := match Fcompare x y with | Lt => true | _ => false end. Theorem Flt_bool_correct_t : forall x y : float, Flt_bool x y = true -> Flt x y. intros x y H'; red in |- *. apply Rplus_lt_reg_r with (r := (- y)%R). repeat rewrite (Rplus_comm (- y)). rewrite Rplus_opp_r. change (x - y < 0)%R in |- *. rewrite <- Fdiff_correct. replace 0%R with (powerRZ radix (Zmin (Fexp x) (Fexp y)) * 0)%R; auto with real arith. rewrite (Rmult_comm (Fdiff x y)). apply Rmult_lt_compat_l; auto with real zarith. replace 0%R with (IZR 0); auto with real arith. apply Rlt_IZR; red in |- *. generalize H'; unfold Flt_bool, Fcompare in |- *. case (Fdiff x y ?= 0)%Z; auto; intros; try discriminate. Qed. Theorem Flt_bool_correct_r : forall x y : float, Flt x y -> Flt_bool x y = true. intros x y H'. cut (0 < y - x)%R; auto with arith. 2: apply Rplus_lt_reg_l with (r := FtoRradix x); rewrite Rplus_0_r; rewrite Rplus_minus; auto with real. intros H'0. cut (Fdiff x y < 0)%R; auto with arith. intros H'1. cut (Fdiff x y < 0)%Z; auto with zarith. intros H'2; generalize (Zlt_compare _ _ H'2); unfold Flt_bool, Fcompare, Zcompare in |- *; case (Fdiff x y); auto with arith; intros; contradiction. apply lt_IZR; auto with arith. apply (Rlt_monotony_contra_exp radix) with (z := Zmin (Fexp x) (Fexp y)); auto with arith real; rewrite Rmult_0_l. rewrite Fdiff_correct; auto with real. Qed. Theorem Flt_bool_correct_f : forall x y : float, Flt_bool x y = false -> Fle y x. intros x y H'. case (Rtotal_order (FtoRradix y) (FtoRradix x)); auto with real. intros H'0; red in |- *; apply Rlt_le; auto with real. intros H'0; elim H'0; clear H'0; intros H'1. red in |- *; rewrite H'1; auto with real. Contradict H'; rewrite Flt_bool_correct_r; auto with real. red in |- *; intros H'; discriminate. Qed. Definition Fle_bool (x y : float) := match Fcompare x y with | Lt => true | Eq => true | _ => false end. Theorem Fle_bool_correct_t : forall x y : float, Fle_bool x y = true -> Fle x y. 
intros; discriminate. case (ZquotientProp z1 z2); auto; intros r (H1, (H2, H3)). case (Zle_or_lt 0 (Zquotient z1 z2)); auto; intros Z2. Contradict H3; apply Zle_not_lt. replace r with (z1 - Zquotient z1 z2 * z2)%Z; [ idtac | pattern z1 at 1 in |- *; rewrite H1; ring ]. repeat rewrite Zabs_eq; auto. pattern z2 at 1 in |- *; replace z2 with (0 + 1 * z2)%Z; [ idtac | ring ]. unfold Zminus in |- *; apply Zle_trans with (z1 + 1 * z2)%Z; auto with zarith. apply Zplus_le_compat_l. rewrite Zopp_mult_distr_l. apply Zle_Zmult_comp_r; auto with zarith. unfold Zminus in |- *; rewrite Zopp_mult_distr_l; auto with zarith. Qed. Definition Zdivides (n m : Z) := exists q : Z, n = (m * q)%Z. Theorem ZdividesZquotient : forall n m : Z, m <> 0%Z -> Zdivides n m -> n = (Zquotient n m * m)%Z. intros n m H' H'0. case H'0; intros z1 Hz1. case (ZquotientProp n m); auto; intros z2 (Hz2, (Hz3, Hz4)). cut (z2 = 0%Z); [ intros H1; pattern n at 1 in |- *; rewrite Hz2; rewrite H1; ring | idtac ]. cut (z2 = ((z1 - Zquotient n m) * m)%Z); [ intros H2 | idtac ]. case (Z_eq_dec (z1 - Zquotient n m) 0); intros H3. rewrite H2; rewrite H3; ring. Contradict Hz4. replace (Zabs m) with (1 * Zabs m)%Z; [ idtac | ring ]. apply Zle_not_lt; rewrite H2. rewrite Zabs_Zmult; apply Zle_Zmult_comp_r; auto with zarith. generalize H3; case (z1 - Zquotient n m)%Z; try (intros H1; case H1; auto; fail); simpl in |- *; intros p; case p; simpl in |- *; auto; intros; red in |- *; simpl in |- *; auto; red in |- *; intros; discriminate. rewrite Zmult_minus_distr_r; rewrite (Zmult_comm z1); rewrite <- Hz1; (pattern n at 1 in |- *; rewrite Hz2); ring. Qed. Theorem ZdividesZquotientInv : forall n m : Z, n = (Zquotient n m * m)%Z -> Zdivides n m. intros n m H'; red in |- *. exists (Zquotient n m); auto. pattern n at 1 in |- *; rewrite H'; auto with zarith. Qed. Theorem ZdividesMult : forall n m p : Z, Zdivides n m -> Zdivides (p * n) (p * m). intros n m p H'; red in H'. elim H'; intros q E. red in |- *. exists q. rewrite E. auto with zarith. Qed. Theorem Zeq_mult_simpl : forall a b c : Z, c <> 0%Z -> (a * c)%Z = (b * c)%Z -> a = b. 
intros. repeat rewrite wordToNat_natToWord_idempotent' by xparams_ok. auto. unfold Rec.well_formed. simpl. intuition. Qed. Definition v_pickle_superblock (fsxp : fs_xparams) : valu. remember (pickle_superblock fsxp) as sb; clear Heqsb. rewrite superblock_padded_len in *. exact sb. Defined. Definition v_unpickle_superblock (v : valu) : fs_xparams. rewrite <- superblock_padded_len in *. exact (unpickle_superblock v). Defined. Theorem v_pickle_unpickle_superblock : forall fsxp, fs_xparams_ok fsxp -> v_unpickle_superblock (v_pickle_superblock fsxp) = fsxp. Proof. intros. unfold v_pickle_superblock, v_unpickle_superblock. unfold eq_rec_r, eq_rec. rewrite eq_rect_nat_double. rewrite <- (eq_rect_eq_dec eq_nat_dec). apply pickle_unpickle_superblock; auto. Qed. Theorem goodSize_magic_number : goodSize addrlen magic_number. Proof. unfold magic_number. eapply wordToNat_natToWord_idempotent'_iff; eauto. Qed. Definition rep (fsxp : fs_xparams) : rawpred := ([[ fs_xparams_ok fsxp ]] * [[ FSXPMagic fsxp = magic_number ]] * 0 |+> (v_pickle_superblock fsxp, nil))%pred. Definition load cs := let^ (cs, v) <- BUFCACHE.read 0 cs; Ret ^(cs, v_unpickle_superblock v). Theorem load_ok : forall cs, {< m F fsxp, PRE:hm BUFCACHE.rep cs m * [[ (F * rep fsxp)%pred m ]] POST:hm' RET:^(cs',r) BUFCACHE.rep cs' m * [[ r = fsxp ]] CRASH:hm' exists cs', BUFCACHE.rep cs' m >} load cs. Proof. unfold load, rep. hoare. apply v_pickle_unpickle_superblock; auto. Qed. Definition init fsxp cs := cs <- BUFCACHE.write 0 (v_pickle_superblock fsxp) cs; cs <- BUFCACHE.begin_sync cs; cs <- BUFCACHE.sync 0 cs; cs <- BUFCACHE.end_sync cs; Ret cs. Theorem init_ok : forall fsxp cs, {< m F, PRE:hm BUFCACHE.rep cs m * [[ fs_xparams_ok fsxp ]] * [[ FSXPMagic fsxp = magic_number ]] * [[ (F * 0 |->?)%pred m ]] * [[ sync_invariant F ]] POST:hm' RET:cs exists m', BUFCACHE.rep cs m' * [[ (F * rep fsxp)%pred m' ]] XCRASH:hm' exists cs' m' vs, BUFCACHE.rep cs' m' * [[ (F * 0 |+> vs)%pred m' ]] >} init fsxp cs. Proof. unfold rep, init. step. rewrite ptsto_pimpl_ptsto_subset; cancel. hoare. xcrash. xcrash. xcrash. xcrash. Qed. Hint Extern 1 ({{_}} Bind (load _) _) => apply load_ok : prog. Hint Extern 1 ({{_}} Bind (init _ _) _) => apply init_ok : prog. Theorem crash_xform_rep : forall fsxp, crash_xform (rep fsxp) <=p=> rep fsxp. Proof. unfold rep; intros; split; rewrite crash_xform_sep_star_dist; rewrite crash_xform_sep_star_dist; repeat rewrite crash_xform_lift_empty. rewrite crash_xform_ptsto_subset; cancel. rewrite ptsto_pimpl_ptsto_subset. subst; auto. rewrite <- crash_xform_ptsto_subset_r. cancel. rewrite ptsto_subset_pimpl_ptsto; eauto. unfold vsmerge; simpl; auto. Qed. Hint Rewrite crash_xform_rep : crash_xform. Theorem sync_invariant_rep : forall xp, sync_invariant (rep xp). Proof. unfold rep; eauto. Qed. Hint Resolve sync_invariant_rep. Hint Extern 0 (okToUnify (rep _) (rep _)) => constructor : okToUnify. Theorem rep_magic_number : forall fsxp, rep fsxp =p=> rep fsxp * [[ FSXPMagic fsxp = magic_number ]]. 
Theorem abcd_c : forall (A:Type) (a b c d:A), a = c \/ b = c \/ c = c \/ d = c. 
wp_pure1. wp_bind (Skip)%E. iApply (wpc_nval_elim_wp with "Htwophase"); auto. wp_pures. iModIntro. iNamed 1. iDestruct (is_twophase_wf_jrnl with "Htwophase") as "%Hwf_jrnl"; [eassumption|eassumption|]. destruct Hnotstuck as (s&g&Hsub&Hdom&Hnotstuck). apply not_stuck'_ReadBit_inv in Hnotstuck as (œÉj&Hopen&Hlookup1&Hlookup2); last eauto. assert (Ha_in_dom: a ‚àà objs_dom). { rewrite -Hdom. apply elem_of_dom. rewrite Hopen => //=. } assert (Hk: Œ≥.(jrnl_txn_names).(txn_kinds) !! a.(addrBlock) = Some KindBit). { destruct Hjrnl_maps_kinds as (_&<-). destruct Hsub as (?&Hs_eq&?&?&?). rewrite Hs_eq in Hopen. inversion Hopen; subst. rewrite -Hlookup2. f_equal. eauto. } wp_apply (wp_Txn__ReadBufBit with "Htwophase"); [assumption|rewrite Hk //|]. iIntros (??) "Hpost". iNamed "Hpost". iDestruct (is_twophase_raw_get_valid with "Htwophase") as "%Hvalids". apply fmap_Some_1 in Hobj as [vobj [Hvobj Heq]]. apply Hvalids in Hvobj as Hvobj_valid. destruct Hvobj_valid as (Hvalid_addr&Hvalid_off&Hvalid_Œ≥). rewrite Hvalid_Œ≥ in Hk. inversion Hk. iApply "HŒ¶". subst mt_changed'. destruct (mt_changed !! a) as [vobj'|] eqn:Hacc. - rewrite Hvobj in Hacc. inversion Hacc. subst vobj'. iDestruct (is_twophase_wf_jrnl with "Htwophase") as "%Hwf_jrnl'"; [eassumption|eassumption|]. iExists _, _, _, _. iFrame "‚àó #". iFrame (Hjrnl_maps_kinds Hjrnl_maps_mt). iPureIntro; split; last assumption. eapply always_steps_trans; first by eapply Halways_steps. apply always_steps_bind. eapply always_steps_ReadBitOp; first by intuition. { destruct Hjrnl_maps_mt as [_ <-]. rewrite !lookup_fmap Hvobj //. rewrite /= -Heq //. } { destruct Hjrnl_maps_kinds as [_ ->]. rewrite Hvalid_Œ≥. subst. eauto. } - rewrite lookup_insert in Hvobj. assert (committed vobj = modified vobj) as Hvobj'. { inversion Hvobj as [Hvobj']. destruct vobj as [k [oc om]]. reflexivity. } remember (updateData œÉj1 a (bufObj_to_obj (modified vobj))) as œÉj1'. remember (updateData œÉj2 a (bufObj_to_obj (modified vobj))) as œÉj2'. assert (jrnl_maps_kinds_valid Œ≥ œÉj1' œÉj2') as Hjrnl_maps_kinds' by rewrite HeqœÉj1' HeqœÉj2' //. assert ( jrnl_maps_have_mt (<[a:=object_to_versioned (modified vobj)]> mt_changed) œÉj1' œÉj2' ) as Hjrnl_maps_mt'. { rewrite HeqœÉj1' HeqœÉj2' /jrnl_maps_have_mt !fmap_insert /modified /committed modified_to_versioned committed_to_versioned /=. destruct Hjrnl_maps_mt as [<- <-]. intuition. } iDestruct (is_twophase_wf_jrnl with "Htwophase") as "%Hwf_jrnl'"; [eassumption| |]. { inversion Hvobj. subst. eauto. } iExists œÉj1', œÉj2', _, _. iFrame "‚àó #". iSplit. { rewrite HeqœÉj1' /=. eauto. } iPureIntro. split; last first. { split_and!; intuition. inversion Hvobj. subst. eauto. } subst œÉj1' œÉj2'. eapply always_steps_trans. { apply always_steps_extend; last by apply Halways_steps. - destruct Hjrnl_maps_mt as [_ <-]. rewrite !dom_fmap. apply not_elem_of_dom. assumption. - eexists _. destruct Hjrnl_maps_kinds as [-> _]. rewrite Hvalid_Œ≥ objSz_bufObj_to_obj. intuition. } apply always_steps_bind. eapply always_steps_ReadBitOp; first by intuition. { rewrite /updateData. destruct Hjrnl_maps_mt as [_ <-]. rewrite /= -!fmap_insert !lookup_fmap lookup_insert //. rewrite /= -Heq //. } { rewrite /updateData. destruct Hjrnl_maps_kinds as [_ ->]. rewrite Hvalid_Œ≥ //. } Qed. Theorem wp_Txn__OverWrite' l Œ≥ Œ≥' dinit objs_dom j K0 K {Hctx: LanguageCtx' (ext := @spec_ffi_op_field _) (ffi := (spec_ffi_model_field)) (ffi_semantics := (spec_ext_semantics_field)) K} e1 a ov : {{{ is_twophase_started l Œ≥ Œ≥' dinit objs_dom j K0 e1 (K (ExternalOp (ext := @spec_ffi_op_field jrnl_spec_ext) OverWriteOp (PairV (addr2val' a) (val_of_obj' ov)))) }}} Txn__OverWrite' #l (addr2val a, val_of_obj ov) {{{ RET #(); is_twophase_started l Œ≥ Œ≥' dinit objs_dom j K0 e1 (K #()) }}}. 
as [v'' ->]. f_equal. erewrite lookup_union_Some_l in Hlookup; last first. { rewrite lookup_singleton_Some //. } congruence. } subst. rewrite big_sepM_union // big_sepM_singleton. iFrame. iExactEq "Hctx". f_equal. rewrite insert_union_singleton_l. rewrite assoc. f_equal. rewrite map_union_comm //. Qed. Theorem map_freeze Œ≥ m k v : map_ctx Œ≥ 1 m -‚àó ptsto_mut Œ≥ k 1 v ==‚àó map_ctx Œ≥ 1 m ‚àó ptsto_ro Œ≥ k v. Proof. unseal. iDestruct 1 as (m_ro ->) "Hm". iIntros "Hk". iDestruct (own_valid_2 with "Hm Hk") as %[Hlookup%map_ptsto_included _]%auth_both_valid_discrete. iMod (own_update_2 with "Hm Hk") as "[Hm $]". { eapply auth_update, singleton_local_update, (exclusive_local_update _ (Cinr (to_agree (v: leibnizO V))))=> //. rewrite lookup_fmap Hlookup //=. } iModIntro. rewrite -to_mapUR_insert_inr. iExists _; iFrame. iPureIntro. apply map_eq; intros k'; rewrite !lookup_fmap. destruct (decide (k = k')); subst. - rewrite lookup_insert Hlookup //. - rewrite lookup_insert_ne //. Qed. Theorem map_alloc_ro {Œ≥ m} k v : m !! k = None ‚Üí map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (<[k:=v]> m) ‚àó ptsto_ro Œ≥ k v. Proof. iIntros (?) "Hm". iMod (map_alloc k v with "Hm") as "[Hm Hk]"; auto. iMod (map_freeze with "Hm Hk") as "[$ $]". auto. Qed. Theorem map_alloc_many' {Œ≥ m} m0 Œ¶: (‚àÄ m k v, m !! k = None ‚Üí map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (<[k:=v]> m) ‚àó Œ¶ k v) ‚Üí ( ‚àÄ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (m0 ‚à™ m) ‚àó [‚àó map] a‚Ü¶v ‚àà m0, Œ¶ a v. Proof. iIntros (Halloc Hnone) "Hm". iInduction m0 as [|l v m0'] "IH" using map_ind forall (m Hnone). { rewrite left_id. iFrame. iModIntro. iApply big_sepM_empty. done. } iMod ("IH" with "[] Hm") as "[Hm Hmany]". { iPureIntro. intros k Hk. eapply Hnone. destruct (decide (l = k)); subst. { rewrite lookup_insert. eauto. } rewrite lookup_insert_ne; eauto. } iMod (Halloc _ l v with "Hm") as "[Hm Hl]". { rewrite lookup_union_None; intuition. eapply Hnone. rewrite lookup_insert. eauto. } iModIntro. rewrite insert_union_l; iFrame "Hm". iApply big_sepM_insert; eauto. iFrame. Qed. Theorem map_alloc_many {Œ≥ m} m0 : ( ‚àÄ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (m0 ‚à™ m) ‚àó [‚àó map] a‚Ü¶v ‚àà m0, ptsto_mut Œ≥ a 1 v. Proof. intros. iApply (map_alloc_many' _ (Œª a v, ptsto_mut Œ≥ a 1 v)); eauto. intros. by apply map_alloc. Qed. Theorem map_alloc_many_ro {Œ≥ m} m0 : ( ‚àÄ k, is_Some (m0 !! k) -> m !! k = None ) -> map_ctx Œ≥ 1 m ==‚àó map_ctx Œ≥ 1 (m0 ‚à™ m) ‚àó [‚àó map] a‚Ü¶v ‚àà m0, ptsto_ro Œ≥ a v. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Induction.Module NatList.Inductive natprod : Type := | pair : nat -> nat -> natprod.Instance dec_natprod (p q : natprod) : Dec (p = q). Proof. constructor; unfold decidable; repeat decide equality. Defined.Derive (Arbitrary, Show) for natprod. Derive (Sized, CanonicalSized) for natprod. Derive SizeMonotonic for natprod using genSnatprod. Derive SizedMonotonic for natprod. Derive SizedCorrect for natprod using genSnatprod and SizeMonotonicnatprod.Definition fst (p : natprod) : nat := match p with | pair x y => x end.Definition snd (p : natprod) : nat := match p with | pair x y => y end.Notation "( x , y )" := (pair x y).Definition fst' (p : natprod) : nat := match p with | (x,y) => x end.Definition snd' (p : natprod) : nat := match p with | (x,y) => y end.Definition swap_pair (p : natprod) : natprod := match p with | (x,y) => (y,x) end.Theorem surjective_pairing' : forall (n m : nat), (n,m) = (fst (n,m), snd (n,m)). Admitted. Theorem surjective_pairing : forall (p : natprod), p = (fst p, snd p). Admitted. Theorem snd_fst_is_swap : forall (p : natprod), (snd p, fst p) = swap_pair p. 
neutral_contra. Hint Unfold interp. Theorem normal_sound : forall G P, normal G P -> valid G P. generalize normal_neutral_sound; firstorder. Qed. Hint Immediate normal_sound. Lemma interp_sound : forall P, interp P -> match P with | Inj _ p => p | Cptr G f a => match G return (_ -> propX G) -> Prop with | nil => fun a => specs f = Some (fun x => a x) | _ => fun _ => False end a | And G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 /\ interp P2 | _ => fun _ _ => False end P1 P2 | Or G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 \/ interp P2 | _ => fun _ _ => False end P1 P2 | Imply G P1 P2 => match G return propX G -> propX G -> Prop with | nil => fun P1 P2 => interp P1 -> interp P2 | _ => fun _ _ => False end P1 P2 | Forall G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => forall x, interp (P1 x) | _ => fun _ => False end P1 | Exists G _ P1 => match G return (_ -> propX G) -> Prop with | nil => fun P1 => exists x, interp (P1 x) | _ => fun _ => False end P1 | ForallX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => forall x, interp (Subst P1 x) | _ => fun _ => False end P1 | ExistsX G _ P1 => match G return propX (_ :: G) -> Prop with | nil => fun P1 => exists x, interp (Subst P1 x) | _ => fun _ => False end P1 | _ => False end. intros ? H; apply normalization in H; inversion H; subst; clear H; try solve [ elimtype False; eauto ]; intuition eauto. Qed. Ltac sound := intros; match goal with | [ H : interp _ |- _ ] => solve [ apply interp_sound in H; auto ] end. Theorem Inj_sound : forall p, interp (Inj p) -> p. 
H') -> (\[P] \* H) ==> H'. Proof. introv W Hh. rewrite state_star_pure_l in Hh. applys* W. Qed. Theorem hempty_eq_state_pure_true : \[] = \[True]. Proof. applys himpl_antisym; intros h M. { applys* state_pure_intro_hempty. } { forwards*: state_pure_inv_hempty M. } Qed. Theorem hfalse_hstar_any: forall H, \[False] \* H = \[False]. Proof. intros. applys himpl_antisym; intros h; rewrite state_star_pure_l; intros M. { false*. } { lets: state_pure_inv_hempty M. false*. } Qed. Theorem state_register_intro: forall register value, ($register == value) (machine_state empty {[ register := value ]}). Proof. intros; hnf; auto. Qed. Theorem state_register_inversion: forall register value state, ($register == value) state -> state = (machine_state empty {[ register := value ]}). Proof. intros ??? A; hnf in A; auto. Qed. Theorem state_star_register_same register v1 v2: ($register == v1) \* ($register == v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_register_inversion & ?%state_register_inversion & [] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_counter_intro: forall counter, (pc_at counter) (machine_state {[ 0%fin := counter ]} empty). Proof. intros; hnf; auto. Qed. Theorem state_counter_inversion: forall counter state, (pc_at counter) state -> state = (machine_state {[ 0%fin := counter ]} empty). Proof. intros ?? A; hnf in A; auto. Qed. Theorem state_star_counter v1 v2: (pc_at v1) \* (pc_at v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_counter_inversion & ?%state_counter_inversion & [? _] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_exists_intro: forall A (a: A) (P: A -> Assertion) state, P a state -> (\exists a, P a) state. Proof. intros; hnf; eauto. Qed. Theorem state_exists_inversion: forall X (P: X -> Assertion) state, (\exists x, P x) state -> exists x, P x state. Proof. intros ??? A; hnf in A; eauto. Qed. Theorem state_forall_intro: forall A (P: A -> Assertion) state, (forall a, P a state) -> (state_forall P) state. Proof. intros; hnf; assumption. Qed. Theorem state_forall_inversion: forall A (P: A -> Assertion) state, (state_forall P) state -> forall a, P a state. Proof. intros; hnf; trivial. Qed. Theorem state_implies_forall_r: forall A (P: A -> Assertion) H, (forall a, H **> P a) -> H **> (state_forall P). Proof. intros ??? M ???; apply M; assumption. Qed. Theorem state_implies_forall_l: forall A a (P: A -> Assertion) H, (P a **> H) -> (state_forall P) **> H. Proof. intros ???? M ??; apply M; trivial. Qed. Theorem state_forall_specialize: forall A a (P: A -> Assertion), (state_forall P) **> (P a). 
Require Import Coq_Cats.Type_Cat.Type_Cat. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat. From Categories Require Import Cat.Cat. From Categories Require Import NatTrans.NatTrans NatTrans.Operations NatTrans.Func_Cat NatTrans.NatIso.Local Open Scope isomorphism_scope. Local Open Scope morphism_scope. Local Open Scope object_scope. Section Opposite_Cat_Iso. Context {C D : Category} (I : C ‚âÉ‚âÉ D ::> Cat). Program Definition Opposite_Cat_Iso : (C^op)%category ‚âÉ‚âÉ (D^op)%category ::> Cat := {| iso_morphism := ((iso_morphism I)^op)%functor; inverse_morphism := ((inverse_morphism I)^op)%functor |}. Next Obligation. change (I ‚Åª¬π ^op ‚àò (iso_morphism I) ^op)%functor with (((inverse_morphism I) ‚àò (iso_morphism I))^op)%functor. cbn_rewrite (left_inverse I). trivial. Qed. Next Obligation. change ((iso_morphism I) ^op ‚àò I ‚Åª¬π ^op)%functor with (((iso_morphism I) ‚àò (inverse_morphism I))^op)%functor. cbn_rewrite (right_inverse I). trivial. Qed.End Opposite_Cat_Iso. Section Cat_IConv. Context {C D : Category} (I : C ‚âÉ‚âÉ D ::> Cat). Definition Cat_Iso_Obj_conv (c : C) : c = (((inverse_morphism I) _o) (((iso_morphism I) _o) c))%object. Proof. change (I ‚Åª¬π _o ((iso_morphism I) _o c)) with ((I ‚Åª¬π ‚àò I)%morphism _o c)%object; rewrite (left_inverse I); trivial. Qed. Definition Cat_Iso_Hom_conv (c c' : C) : ((((inverse_morphism I) _o) (((iso_morphism I) _o) c)) ‚Äì‚âª (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))%morphism = (c ‚Äì‚âª c'). Proof. do 2 rewrite <- Cat_Iso_Obj_conv; trivial. Defined. Definition Cat_Iso_conv_inv {c c' : C} (h : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) ‚Äì‚âª (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))) : c ‚Äì‚âª c' := match Cat_Iso_Hom_conv c c' in _ = Y return Y with eq_refl => h end. Theorem Cat_Iso_conv_inv_JMeq {c c' : C} (h : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) ‚Äì‚âª (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))) : Cat_Iso_conv_inv h ~= h. Proof. unfold Cat_Iso_conv_inv. destruct Cat_Iso_Hom_conv. trivial. Qed. Definition Cat_Iso_conv {c c' : C} (h : c ‚Äì‚âª c') : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) ‚Äì‚âª (((inverse_morphism I) _o) (((iso_morphism I) _o) c')) := match eq_sym (Cat_Iso_Hom_conv c c') in _ = Y return Y with eq_refl => h end. Theorem Cat_Iso_conv_JMeq {c c' : C} (h : c ‚Äì‚âª c') : Cat_Iso_conv h ~= h. Proof. unfold Cat_Iso_conv. destruct Cat_Iso_Hom_conv. trivial. Qed. Theorem Cat_Iso_conv_inv_Cat_Iso_conv {c c' : C} (h : c ‚Äì‚âª c') : Cat_Iso_conv_inv (Cat_Iso_conv h) = h. Proof. unfold Cat_Iso_conv_inv, Cat_Iso_conv. destruct Cat_Iso_Hom_conv; trivial. Qed. Theorem Cat_Iso_conv_Cat_Iso_conv_inv {c c' : C} (h : (((inverse_morphism I) _o) (((iso_morphism I) _o) c)) ‚Äì‚âª (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))) : Cat_Iso_conv (Cat_Iso_conv_inv h) = h. Proof. unfold Cat_Iso_conv_inv, Cat_Iso_conv. destruct Cat_Iso_Hom_conv; trivial. Qed. Theorem Cat_Iso_conv_inv_I_inv_I {c c' : C} (h : c ‚Äì‚âª c') : Cat_Iso_conv_inv (((inverse_morphism I) _a) (((iso_morphism I) _a) h)) = h. 
H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto. Qed.Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m. intros n m p H; auto with arith. Qed.Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m. intros n m p H H1; red; apply mult_lt_compat_l; auto. Qed.Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p. intros n m p; case p; auto with arith. Qed.Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m. intros n m p H; case (le_or_lt m n); auto with arith; intros H1. absurd (p * n < p * m); auto with arith. apply le_not_lt; apply mult_le_compat_l; auto. Qed. Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0. intros n m p; case p; auto with arith. Qed.Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m. intros n m p H; case (le_or_lt n m); auto with arith; intros H1. absurd (p * n > p * m); auto with arith. Qed.Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m. intros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith. apply lt_not_le; apply mult_lt_compat_l; auto. Qed.Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m. intros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith. unfold ge; apply lt_not_le; apply mult_lt_compat_l; auto. Qed.Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b. intros a b; case a ; case b; simpl; auto with arith. intros n H1 H2; absurd (0 < 0); auto with arith. Qed.Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0. intros a b H1 H2; red; apply lt_mult_0; auto with arith. Qed. Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a . 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Category. Local Open Scope morphism_scope. Inductive Composable_Chain (C : Category) (a b : C) : Type := | Single : (a --> b) ‚Üí Composable_Chain C a b | Chain : ‚àÄ (c : Obj), (a --> c) ‚Üí Composable_Chain C c b ‚Üí Composable_Chain C a b.Arguments Single {_ _ _} _. Arguments Chain {_ _ _ _} _ _. Fixpoint Forall_Links {C : Category} {a b : C} (ch : Composable_Chain C a b) (P : ‚àÄ {x y : Obj}, (x --> y) ‚Üí Prop) : Prop := match ch with | Single f => P f | Chain f ch' => P f ‚àß Forall_Links ch' (@P) end. Fixpoint Compose_of {C : Category} {a b : C} (ch : Composable_Chain C a b) {struct ch} : a --> b := match ch with | Single f => f | Chain f ch' => (Compose_of ch') ‚àò f end. Fixpoint Chain_Compose {C : Category} {a b c : C} (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c) : Composable_Chain C a c := match ch1 with | Single f => Chain f ch2 | Chain f ch' => Chain f (Chain_Compose ch' ch2) end. Theorem Compose_of_Chain_Compose (C : Category) (a b c : C) (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c) : ((Compose_of ch2) ‚àò (Compose_of ch1))%morphism = Compose_of (Chain_Compose ch1 ch2). Proof. induction ch1; auto. simpl. rewrite <- assoc. rewrite IHch1; trivial. Qed. Theorem Forall_Links_Chain_Compose (C : Category) (a b c : C) (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c) (P : ‚àÄ (x y : Obj), (x --> y) ‚Üí Prop) : Forall_Links ch1 P ‚Üí Forall_Links ch2 P ‚Üí Forall_Links (Chain_Compose ch1 ch2) P. 
:= q). apply div_rem_spec1. } destruct H6 as (z & H6); exists z; split. + apply IHn. exists q, c; msplit 2; auto. intros i Hi; apply H2; lia. + destruct (H2 n) as (u & v & G1 & G2 & G3); auto. rewrite is_digit_fun with (1 := H4) (2 := G2), is_digit_fun with (1 := H6) (2 := G1); auto. Qed. Notation power := (mscal mult 1). Notation "‚àë" := (msum plus 0). Lemma rel_iter_iter_seq n x y : rel_iter R n x y -> rel_iter_seq n x y. Proof. intros H. apply rel_iter_sequence in H. destruct H as (f & H1 & H2 & H3). assert (exists q, forall i, i <= n -> f i < q) as Hq. { clear H1 H2 H3. revert f; induction n as [ | n IHn ]; intros f. + exists (S (f 0)); intros [ | ] ?; lia. + destruct IHn with (f := fun i => (f (S i))) as (q & Hq). exists (1+f 0+q); intros [ | i ] Hi; try lia. generalize (Hq i); intros; lia. } destruct Hq as (q & Hfq). assert (q <> 0) as Hq. { generalize (Hfq 0); intros; lia. } set (c := ‚àë (S n) (fun i => f i * power i q)). assert (forall i, i <= n -> is_digit c q i (f i)) as Hc. { intros i Hi; split; auto. + exists (‚àë (n-i) (fun j => f (1+i+j) * power j q)), (‚àë i (fun i => f i * power i q)); split. 2: apply sum_power_lt; auto; intros; apply Hfq; lia. unfold c; replace (S n) with (i+S (n - i)) by lia. rewrite msum_plus, plus_comm; f_equal; auto. rewrite msum_ext with (g := fun k => power i q*(f (i+k)*power k q)). * rewrite sum_0n_scal_l, mult_comm; f_equal. rewrite msum_S, plus_comm; f_equal. 2: simpl; rewrite Nat.mul_1_r; f_equal; lia. rewrite (mult_comm _ q), <- sum_0n_scal_l. apply msum_ext. intros j _. replace (i+S j) with (1+i+j) by lia. rewrite power_S; ring. * intros j _; rewrite power_plus; ring. } exists q, c; msplit 2. + intros i Hi; exists (f i), (f (S i)). split; [ | split ]. * apply Hc; lia. * apply Hc; lia. * apply H3; auto. + rewrite <- H1; apply Hc; lia. + rewrite <- H2; apply Hc; lia. Qed. Hint Resolve rel_iter_seq_iter rel_iter_iter_seq : core. Theorem rel_iter_seq_equiv n x y : rel_iter R n x y <-> rel_iter_seq n x y. 
String.t String.parse String.print : bs_scope.Notation "x ++ y" := (String.append x y) : bs_scope. Import String. Require Import Orders Coq.Structures.OrderedType.Lemma to_N_inj : forall x y, Byte.to_N x = Byte.to_N y <-> x = y. Proof. split. 2: destruct 1; reflexivity. intros. assert (Some x = Some y). { do 2 rewrite <- Byte.of_to_N. destruct H. reflexivity. } injection H0. auto. Qed.Module OT_byte <: OrderedType.OrderedType with Definition t := Byte.byte. Definition t := Byte.byte. Definition eq := @Logic.eq t. Definition lt := fun l r => ByteCompare.compare l r = Lt. Theorem eq_refl : forall x : t, eq x x. Proof. intros; apply eq_refl. Qed. Theorem eq_sym : forall x y : t, eq x y -> eq y x. Proof. apply eq_sym. Qed. Theorem eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z. Proof. apply eq_trans. Qed. Theorem lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z. Proof. exact ByteCompareSpec.lt_trans. Qed. Theorem lt_not_eq : forall x y : t, lt x y -> not (eq x y). Proof. apply ByteCompareSpec.lt_not_eq. Qed. Definition compare (x y : t) : OrderedType.Compare lt eq x y. refine ( match ByteCompare.compare x y as X return ByteCompare.compare x y = X -> OrderedType.Compare lt eq x y with | Eq => fun pf => OrderedType.EQ _ | Lt => fun pf => OrderedType.LT pf | Gt => fun pf => OrderedType.GT _ end (Logic.eq_refl)). now apply ByteCompareSpec.compare_eq in pf. rewrite ByteCompareSpec.compare_opp in pf. apply CompOpp_iff in pf. apply pf. Defined. Definition eq_dec : forall x y : t, {eq x y} + {not (eq x y)} := Classes.eq_dec. End OT_byte.Global Instance byte_eqdec : Classes.EqDec Byte.byte := _.Module StringOT <: UsualOrderedType. Definition t := string. Definition eq : t -> t -> Prop := eq. Definition eq_equiv : Equivalence eq := _. Definition compare := String.compare. Definition lt x y : Prop := compare x y = Lt. Theorem compare_spec : forall x y, CompareSpec (x = y) (lt x y) (lt y x) (compare x y). Proof. induction x; destruct y; simpl. - constructor; reflexivity. - constructor. reflexivity. - constructor. reflexivity. - unfold lt; simpl. destruct (ByteCompareSpec.compare_spec b b0); simpl. + subst. destruct (IHx y); constructor; eauto. congruence. now rewrite ByteCompareSpec.compare_eq_refl. + constructor; auto. + red in H. rewrite H. constructor; auto. Qed. Theorem eq_refl : forall x : t, eq x x. 
q1 p1. intros H1; rewrite (Pcompare_Eq_eq p1 q1); auto. unfold Pos.compare. generalize (Pcompare_Eq_eq p1 q1); case (Pcompare p1 q1 Datatypes.Eq); simpl in |- *; intros H H1; try discriminate; rewrite H; auto. Qed. Theorem Zlt_Zopp : forall x y : Z, (x < y)%Z -> (- y < - x)%Z. intros x y; case x; case y; simpl in |- *; auto with zarith; intros p p0; unfold Zlt in |- *; simpl in |- *; unfold Pos.compare; rewrite <- ZC4; auto. Qed. Hint Resolve Zlt_Zopp: zarith. Theorem Zle_Zopp : forall x y : Z, (x <= y)%Z -> (- y <= - x)%Z. intros x y H'; case (Zle_lt_or_eq _ _ H'); auto with zarith. Qed. Hint Resolve Zle_Zopp: zarith. Theorem absolu_INR : forall n : nat, Zabs_nat (Z_of_nat n) = n. intros n; case n; simpl in |- *; auto with arith. intros n0; rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith. Qed. Theorem absolu_Zopp : forall p : Z, Zabs_nat (- p) = Zabs_nat p. intros p; case p; simpl in |- *; auto. Qed. Theorem Zabs_absolu : forall z : Z, Zabs z = Z_of_nat (Zabs_nat z). intros z; case z; simpl in |- *; auto; intros p; apply sym_equal; apply inject_nat_convert; auto. Qed. Theorem absolu_comp_mult : forall p q : Z, Zabs_nat (p * q) = Zabs_nat p * Zabs_nat q. intros p q; case p; case q; simpl in |- *; auto; intros p0 p1; apply ((fun (x y : positive) (_ : positive -> positive) => nat_of_P_mult_morphism x y) p1 p0 (fun x => x)). Qed. Theorem Zmin_sym : forall m n : Z, Zmin n m = Zmin m n. intros m n; unfold Zmin in |- *. case n; case m; simpl in |- *; auto; unfold Pos.compare. intros p p0; rewrite (ZC4 p p0). generalize (Pcompare_Eq_eq p0 p). case (Pcompare p0 p Datatypes.Eq); simpl in |- *; auto. intros H'; rewrite H'; auto. intros p p0; rewrite (ZC4 p p0). generalize (Pcompare_Eq_eq p0 p). case (Pcompare p0 p Datatypes.Eq); simpl in |- *; auto. intros H'; rewrite H'; auto. Qed. Theorem Zpower_nat_O : forall z : Z, Zpower_nat z 0 = Z_of_nat 1. intros z; unfold Zpower_nat in |- *; simpl in |- *; auto. Qed. Theorem Zpower_nat_1 : forall z : Z, Zpower_nat z 1 = z. intros z; unfold Zpower_nat in |- *; simpl in |- *; rewrite Zmult_1_r; auto. Qed. Theorem Zmin_le1 : forall z1 z2 : Z, (z1 <= z2)%Z -> Zmin z1 z2 = z1. 
Theorem L5_7 : ‚àÄ P Q R S : Prop, ((P‚ÜîQ) ‚àß (R‚ÜîS)) ‚Üí ((P‚ÜîR) ‚Üí (Q‚ÜîS)). 
*; auto. Qed. Lemma handleAppendEntriesReply_log : forall h st h' t es r st' ms, handleAppendEntriesReply h st h' t es r = (st', ms) -> log st' = log st. Proof using. unfold handleAppendEntriesReply, advanceCurrentTerm. intros. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleRequestVoteReply_log : forall h st h' t r st', handleRequestVoteReply h st h' t r = st' -> log st' = log st. Proof using. intros. eapply handleRequestVoteReply_spec; eauto. Qed. Lemma handleRequestVoteReply_log_rewrite : forall h st h' t r, log (handleRequestVoteReply h st h' t r) = log st. Proof using. intros. erewrite handleRequestVoteReply_log; eauto. Qed. Lemma handleAppendEntriesReply_packets : forall h st from t es s st' ps, handleAppendEntriesReply h st from t es s = (st', ps) -> ps = []. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; subst; auto. Qed. Lemma doGenericServer_packets : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> ps = []. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; simpl in *; subst; auto. Qed. Theorem handleAppendEntries_not_append_entries : forall h st t n pli plt es ci st' m, handleAppendEntries h st t n pli plt es ci = (st', m) -> ~ is_append_entries m. Proof using. intros. unfold handleAppendEntries in *. repeat break_match; find_inversion; intuition; break_exists; congruence. Qed. Lemma handleAppendEntries_clientCache: forall h st (d : raft_data) (m : msg) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex), handleAppendEntries h st t n pli plt es ci = (d, m) -> clientCache d = clientCache st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto. Qed. Lemma handleAppendEntriesReply_clientCache: forall h st (d : raft_data) (m : list (name * msg)) (t : nat) (es : list entry) (res : bool) h', handleAppendEntriesReply h st h' t es res = (d, m) -> clientCache d = clientCache st. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat (break_match; try find_inversion; simpl in *; auto). Qed. Lemma advanceCurrentTerm_clientCache : forall st t, clientCache (advanceCurrentTerm st t) = clientCache st. Proof using. unfold advanceCurrentTerm. intros. break_if; auto. Qed. Theorem handleTimeout_clientCache : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> clientCache st' = clientCache st. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; auto. Qed. Theorem handleClientRequest_clientCache: forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> clientCache st' = clientCache st. 
[]. apply restrE2 in H as [Hp Hx]. apply SepE in Hx as [_ Hx1]. apply binRelE3 in Hx1. apply BUnionE in Hx1 as []. exfalso0. apply SingE in H; subst. apply func_ap in Hp... rewrite f_0 in Hp; subst... Qed.Lemma f_ap_preserve_lt : ‚àÄ A, ‚àÄ n m ‚àà œâ, n ‚àà m ‚Üí (F A)[n] ‚äÜ (F A)[m]. Proof with auto. intros A n Hn m Hm Hnm. destruct (f_spec A) as [Hf [Hd HŒ≥]]. rewrite HŒ≥, HŒ≥... intros y Hy. apply BUnionE in Hy as [|Hy]; [apply BUnionI1|apply BUnionI2]... apply UnionAx in Hy as [a [Ha Hy]]. apply UnionAx in Ha as [b [Hb Ha]]. apply UnionAx. exists a. split... apply UnionAx. exists b. split... apply ranE in Hb as [x Hp]. apply restrE2 in Hp as [Hp Hx]. apply (ranI _ x). apply restrI... apply segI. apply SepE in Hx as [_ Hxn]. eapply Lt_trans; eauto. apply binRelI... Qed.Lemma f_n : ‚àÄ A, ‚àÄn ‚àà œâ, (F A)[n‚Å∫] = A ‚à™ ‚ãÉ (F A)[n]. Proof with auto; try congruence. intros A n Hn. destruct (f_spec A) as [Hf [Hd HŒ≥]]. assert (Hnp: n‚Å∫ ‚àà œâ) by (apply œâ_inductive; auto). rewrite HŒ≥... apply ExtAx; intros y; split; intros Hy; (apply BUnionE in Hy as [|Hy]; [apply BUnionI1|apply BUnionI2])... - apply UnionAx in Hy as [a [Ha Hy]]. apply UnionAx in Ha as [b [Hb Ha]]. apply ranE in Hb as [c Hp]. apply restrE2 in Hp as [Hp Hc]. apply func_ap in Hp... subst. apply SepE in Hc as [_ Hc]. apply binRelE2 in Hc as [Hc [_ Hcn]]. apply UnionAx. exists a. split... apply le_iff_lt_suc in Hcn as []... apply (f_ap_preserve_lt _ c)... - apply UnionAx in Hy as [a [Ha Hy]]. apply UnionAx. exists a. split... apply UnionAx. exists ((F A)[n]). split... apply (ranI _ n). apply restrI. apply segI. apply binRelI... apply func_correct... Qed.Lemma f_inclusion : ‚àÄ A, ‚àÄn ‚àà œâ, ‚àÄa ‚àà (F A)[n], a ‚äÜ (F A)[n‚Å∫]. Proof with neauto. intros A n Hn. œâ_induction n; intros a Ha x Hx. - rewrite f_0 in Ha. rewrite f_1. apply BUnionI2. apply UnionAx. exists a. split... - rewrite f_n in Ha... rewrite f_n, f_n; [..|apply œâ_inductive]... apply BUnionE in Ha as []; apply BUnionI2. + apply UnionAx. exists a. split... apply BUnionI1... + apply UnionAx. exists a. split... apply BUnionI2... Qed.End TransitiveClosureDef.Definition TransitiveClosure := Œª A, ‚ãÉ (ran (F A)). Notation ùóßùóñ := TransitiveClosure. Theorem tc_trans : ‚àÄ A, trans (ùóßùóñ A). 
Require Import ILL.Definitions singleTM.Require Import utils_tac pos vec. Require Import mm_defs fractran_defs dio_logic dio_elem dio_single.Require Import HALT_MM MM_FRACTRAN FRACTRAN_DIO UNDEC.Set Implicit Arguments.Definition H10_PROBLEM := { n : nat & dio_polynomial (pos n) Empty_set * dio_polynomial (pos n) Empty_set }%type.Definition H10 : H10_PROBLEM -> Prop. Proof. intros (n & p & q). apply (dio_single_pred (p,q)), (fun _ => 0). Defined.Section DIO_SINGLE_SAT_H10. Let f : DIO_SINGLE_PROBLEM -> H10_PROBLEM. Proof. intros (E,v). destruct (dio_poly_eq_pos E) as (n & p & q & H2). exists n. exact (dp_inst_par v p, dp_inst_par v q). Defined. Theorem DIO_SINGLE_SAT_H10 : DIO_SINGLE_SAT ‚™Ø H10. 
| gcd_mod : forall b a d q r : Z, b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d. Definition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.Definition gcdZ_i (a b : Z) := exist (is_gcdZ a b). Definition P (a : Z) := forall b : Z, have_gcdZ a b.Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n. Proof. intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro. split with (absZ b). rewrite e. apply (gcd_OZ b). unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros. elim (H r H0 n). intros. split with x. apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1. unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0. Qed.Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b. Proof. exact (recZ P acc_P). Qed. Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.intros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *. split. elim H3; intros; elim H5; intros; exact H6. split. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9. apply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0). elim H3; intros; elim H11; intros. exact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I). elim H3; intros; exact H10. intros. elim H3; intros; elim H7; intros. apply (H9 q0). cut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10. apply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5). apply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0). exact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I). elim H1; intros; elim H11; intros; elim H13; intros; rewrite H15. elim (addZ_commutativity r (multZ b0 q)). elim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))). elim (addZ_opposite (multZ b0 q) I); intros. elim H17; intros. elim H19; intros. rewrite H20. symmetry in |- *. exact (add_OZ r). exact H4. Qed. Definition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b). Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b). 
=> xelements l (xO i) ((prev i, x) :: xelements r (xI i) k) end. Definition elements (A: Type) (m : t A) := xelements m xH nil. Remark xelements_append: forall A (m: t A) i k1 k2, xelements m i (k1 ++ k2) = xelements m i k1 ++ k2. Proof. induction m; intros; simpl. - auto. - destruct o; rewrite IHm2; rewrite <- IHm1; auto. Qed. Remark xelements_leaf: forall A i, xelements (@Leaf A) i nil = nil. Proof. intros; reflexivity. Qed. Remark xelements_node: forall A (m1: t A) o (m2: t A) i, xelements (Node m1 o m2) i nil = xelements m1 (xO i) nil ++ match o with None => nil | Some v => (prev i, v) :: nil end ++ xelements m2 (xI i) nil. Proof. intros. simpl. destruct o; simpl; rewrite <- xelements_append; auto. Qed. Lemma xelements_incl: forall (A: Type) (m: t A) (i : positive) k x, In x k -> In x (xelements m i k). Proof. induction m; intros; simpl. auto. destruct o. apply IHm1. simpl; right; auto. auto. Qed. Lemma xelements_correct: forall (A: Type) (m: t A) (i j : positive) (v: A) k, get i m = Some v -> In (prev (prev_append i j), v) (xelements m j k). Proof. induction m; intros. rewrite (gleaf A i) in H; congruence. destruct o; destruct i; simpl; simpl in H. apply xelements_incl. right. auto. auto. inv H. apply xelements_incl. left. reflexivity. apply xelements_incl. auto. auto. inv H. Qed. Theorem elements_correct: forall (A: Type) (m: t A) (i: positive) (v: A), get i m = Some v -> In (i, v) (elements m). Proof. intros A m i v H. generalize (xelements_correct m i xH nil H). rewrite prev_append_prev. exact id. Qed. Lemma in_xelements: forall (A: Type) (m: t A) (i k: positive) (v: A) , In (k, v) (xelements m i nil) -> exists j, k = prev (prev_append j i) /\ get j m = Some v. Proof. induction m; intros. - rewrite xelements_leaf in H. contradiction. - rewrite xelements_node in H. rewrite ! in_app_iff in H. destruct H as [P | [P | P]]. + exploit IHm1; eauto. intros (j & Q & R). exists (xO j); auto. + destruct o; simpl in P; intuition auto. inv H. exists xH; auto. + exploit IHm2; eauto. intros (j & Q & R). exists (xI j); auto. Qed. Theorem elements_complete: forall (A: Type) (m: t A) (i: positive) (v: A), In (i, v) (elements m) -> get i m = Some v. 
Require Export Ensembles. Require Export Constructive_sets. Require Export Relations_1. Require Export Relations_1_facts. Require Export Partial_Order. Require Export Cpo. Require Export Powerset.Section Sets_as_an_algebra. Variable U : Type. Theorem Empty_set_zero : forall X:Ensemble U, Union U (Empty_set U) X = X. Proof. auto 6 with sets. Qed. Theorem Empty_set_zero_right : forall X:Ensemble U, Union U X (Empty_set U) = X. Proof. auto 6 with sets. Qed. Theorem Empty_set_zero' : forall x:U, Add U (Empty_set U) x = Singleton U x. Proof. unfold Add at 1; auto using Empty_set_zero with sets. Qed. Lemma less_than_empty : forall X:Ensemble U, Included U X (Empty_set U) -> X = Empty_set U. Proof. auto with sets. Qed. Theorem Union_commutative : forall A B:Ensemble U, Union U A B = Union U B A. Proof. auto with sets. Qed. Theorem Union_associative : forall A B C:Ensemble U, Union U (Union U A B) C = Union U A (Union U B C). Proof. auto 9 with sets. Qed. Theorem Union_idempotent : forall A:Ensemble U, Union U A A = A. 
From Perennial.program_proof.mvcc Require Import txn_prelude txnmgr_repr txnmgr_get_min_active_tid index_proof.Section program. Context `{!heapGS Œ£, !mvcc_ghostG Œ£}. Theorem wp_txnMgr__gc txnmgr Œ≥ : is_txnmgr txnmgr Œ≥ -‚àó {{{ True }}} TxnMgr__gc #txnmgr {{{ RET #(); True }}}. 
elt (to_blm m1) (to_blm m2) <-> m1 <= m2. Proof. unfold Submap, LabelMapFacts.Submap. intros; split; intros. { repeat erewrite <- to_blm_spec in *; eauto. } destruct k. destruct l; simpl in *. { replace ((s, Labels.Global s0)) with (to_bedrock_label (s, s0)) in * by eauto. repeat erewrite to_blm_spec in *. eauto. } repeat rewrite to_blm_no_local in *. discriminate. Qed. Theorem make_module_exports_submap : LabelMapFacts.Submap (to_blm (mapi (foreign_func_spec) (map_aug_mod_name ax_mod_name exports))) (Exports make_module). Proof. simpl. rewrite exps_spec. eapply to_blm_Submap. intros k v Hk. eapply find_mapsto_iff in Hk. eapply mapi_mapsto_iff in Hk; [ | intros; subst; eauto]. destruct Hk as [ax [? Hk] ]. subst. eapply find_mapsto_iff in Hk. eapply map_aug_mod_name_elim in Hk. destruct Hk as [x [? Hx] ]. subst. unfold func_to_import; simpl in *. unfold stubs. rewrite map_map. simpl. eapply find_mapsto_iff. eapply MapsTo_to_map. { eapply NoDupKey_aug_mod_name. intros; simpl; eauto. } eapply in_map_iff. unfold stub_spec; simpl. Require Import Bedrock.Platform.Cito.StringMap. Import StringMap. Require Import Bedrock.Platform.Cito.StringMapFacts. Import FMapNotations. assert (Hx' : In x (Funs m)). { eapply exports_sub_domain; eauto. eapply find_Some_in; eauto. } eapply in_find_Some in Hx'. destruct Hx' as [f Hx']. exists (x, (f, ax)); split; eauto. eapply find_in_elements. eapply find_inter_intro; eauto. Qed. Import LabelMap. Import LabelMapFacts. Import FMapNotations. Lemma Submap_Equal elt (m1 m2 : t elt) : m1 <= m2 -> m2 <= m1 -> m1 == m2. Proof. intros H1 H2. intros k. eapply option_univalence. intros v; split; eauto. Qed. Require Import Bedrock.Platform.Cito.GLabelMap. Import GLabelMap. Require Import Bedrock.Platform.Cito.GLabelMapFacts. Import FMapNotations. Theorem make_module_exports_submap2 : LabelMapFacts.Submap (Exports make_module) (to_blm (mapi (foreign_func_spec) (map_aug_mod_name ax_mod_name exports))). Proof. simpl. rewrite exps_spec. eapply to_blm_Submap. intros k v Hk. unfold func_to_import in *; simpl in *. unfold stubs in *. rewrite map_map in Hk. simpl in *. eapply find_mapsto_iff in Hk. eapply MapsTo_to_map_elim in Hk. Focus 2. { eapply NoDupKey_aug_mod_name. intros; simpl; eauto. } Unfocus. eapply in_map_iff in Hk. unfold stub_spec in *; simpl in *. Require Import Bedrock.Platform.Cito.StringMap. Import StringMap. Require Import Bedrock.Platform.Cito.StringMapFacts. Import FMapNotations. destruct Hk as [ [x [f ax] ] [Hinj Hx] ]. simpl in *. inject Hinj. eapply in_elements_find in Hx. eapply find_inter_elim in Hx; eauto. destruct Hx as [H1 H2]. Require Import Bedrock.Platform.Cito.GLabelMap. Import GLabelMap. Require Import Bedrock.Platform.Cito.GLabelMapFacts. Import FMapNotations. eapply find_mapsto_iff. eapply mapi_mapsto_iff; [ intros; subst; eauto | ]. exists ax; split; eauto. eapply find_mapsto_iff. eapply map_aug_mod_name_intro; eauto. Qed. Theorem make_module_exports_equal : LabelMap.Equal (Exports make_module) (to_blm (mapi (foreign_func_spec) (map_aug_mod_name ax_mod_name exports))). Proof. eapply Submap_Equal. - eapply make_module_exports_submap2. - eapply make_module_exports_submap. Qed. Theorem make_module_exports x ax : StringMap.find x exports = Some ax -> LabelMap.find (ax_mod_name, Global x) (Exports make_module) = Some (foreign_func_spec (ax_mod_name, x) ax). 
apply PTree.elements_complete in H0. eauto. + destruct H as [a ?]. apply PTree.elements_correct in H. apply (in_map fst) in H. auto. Qed.Lemma PTree_gs {A: Type}: forall (T: PTree.t A) i j x, (exists a, PTree.get i T= Some a) -> exists a, PTree.get i (PTree.set j x T) = Some a. Proof. intros. destruct H. destruct (Pos.eq_dec i j). + subst. rewrite PTree.gss; eauto. + rewrite PTree.gso; eauto. Qed.Lemma PTree_gs_equiv {A: Type}: forall (T: PTree.t A) i j x, (exists a, PTree.get i T= Some a) \/ i = j <-> exists a, PTree.get i (PTree.set j x T) = Some a. Proof. intros. split; intros. + destruct H; [apply PTree_gs; auto |]. subst; rewrite PTree.gss; eauto. + destruct (Pos.eq_dec i j); auto. rewrite PTree.gso in H by auto. auto. Qed.Lemma PTree_set_In_fst_elements {A: Type}: forall (T: PTree.t A) i i' a', In i (map fst (PTree.elements T)) -> In i (map fst (PTree.elements (PTree.set i' a' T))). Proof. intros. rewrite PTree_In_fst_elements in H |- *. apply PTree_gs; auto. Qed. Fixpoint relative_defined_type {A: Type} (l: list (ident * A)) (t: type): Prop := match t with | Tarray t' _ _ => relative_defined_type l t' | Tstruct id _ => In id (map fst l) | Tunion id _ => In id (map fst l) | _ => True end.Lemma relative_defined_type_mono: forall {A B: Type} (l1: list (ident * A)) (l2: list (ident * B)) (t: type), (forall i, In i (map fst l1) -> In i (map fst l2)) -> relative_defined_type l1 t -> relative_defined_type l2 t. Proof. intros. induction t; auto. + simpl in *. firstorder. + simpl in *. firstorder. Qed.Lemma relative_defined_type_equiv: forall {A B: Type} (l1: list (ident * A)) (l2: list (ident * B)) (t: type), (forall i, In i (map fst l1) <-> In i (map fst l2)) -> (relative_defined_type l1 t <-> relative_defined_type l2 t). Proof. intros. split; apply relative_defined_type_mono; firstorder. Qed.Inductive ordered_composite: list (positive * composite) -> Prop := | ordered_composite_nil: ordered_composite nil | ordered_composite_cons: forall i co l, Forall (relative_defined_type l) (map snd (co_members co)) -> ordered_composite l -> ordered_composite ((i, co) :: l).Module composite_reorder.Module CompositeRankOrder <: TotalLeBool. Definition t := (positive * composite)%type. Definition leb (x y: t) := Nat.leb (co_rank (snd y)) (co_rank (snd x)). Theorem leb_total : forall a1 a2, leb a1 a2 = true \/ leb a2 a1 = true. Proof. intros. unfold leb. rewrite !Nat.leb_le. omega. Qed. Theorem leb_trans: Transitive (fun x y => is_true (leb x y)). 
(DataStart xp) (vsupd_vecs d (firstn n (Map.elements m))) =p=> unsync_rep xp m d. Proof. unfold unsync_rep, map_replay; cancel. apply apply_unsync_applying_ok'. apply KNoDup_NoDup; auto. Qed. Lemma apply_unsync_syncing_ok' : forall l a d n, NoDup (map fst l) -> ~ In a (map fst l) -> selN d a ($0, nil) = selN (vssync_vecs (vsupd_vecs d l) (firstn n (map fst l))) a ($0, nil). Proof. induction l; intros; simpl. rewrite firstn_nil; simpl; auto. destruct a; inversion H; simpl in *; subst; intuition. destruct n; simpl; auto. rewrite vsupd_vecs_vsupd_notin by auto. unfold vsupd. rewrite selN_updN_ne by auto. rewrite vsupd_vecs_selN_not_in; auto. unfold vssync. rewrite -> updN_vsupd_vecs_notin by auto. rewrite <- IHl; auto. rewrite selN_updN_ne by auto. unfold vsupd. rewrite selN_updN_ne; auto. Qed. Lemma apply_unsync_syncing_ok : forall xp m d n, arrayS (DataStart xp) (vssync_vecs (vsupd_vecs d (Map.elements m)) (firstn n (map_keys m))) =p=> unsync_rep xp m d. Proof. unfold unsync_rep, equal_unless_in; cancel. rewrite vssync_vecs_length, vsupd_vecs_length; auto. apply apply_unsync_syncing_ok'. apply KNoDup_NoDup; auto. eauto. Qed. Lemma rep_rollback_pimpl : forall xp d ms hm, rep xp (Rollback d) ms hm =p=> rep xp (Recovering d) ms hm. Proof. unfold rep; intros. cancel; eauto. rewrite DLog.rep_rollback_pimpl; eauto. cancel. Qed. Lemma rep_synced_pimpl : forall xp nr d ms hm, rep xp (Synced nr d) ms hm =p=> rep xp (Recovering d) ms hm. Proof. unfold rep; intros. cancel; eauto. rewrite DLog.rep_synced_pimpl; eauto. cancel. Qed. Theorem recover_before_either : forall xp d ents hm, would_recover_before xp d hm =p=> would_recover_either xp d ents hm. Proof. unfold would_recover_before, would_recover_either; cancel. Qed. Theorem synced_recover_before : forall xp na d ms hm, rep xp (Synced na d) ms hm =p=> would_recover_before xp d hm. Proof. unfold would_recover_before; cancel. Unshelve. eauto. Qed. Theorem synced_recover_either : forall xp na d ms ents hm, rep xp (Synced na d) ms hm =p=> would_recover_either xp d ents hm. Proof. unfold would_recover_either; cancel. Qed. Theorem rollback_recover_either : forall xp d ms ents hm, rep xp (Rollback d) ms hm =p=> would_recover_either xp d ents hm. Proof. unfold would_recover_either; cancel. rewrite rep_rollback_pimpl. or_r; or_r; or_r; cancel. Qed. Theorem applying_recover_before : forall xp d ms hm, rep xp (Applying d) ms hm =p=> would_recover_before xp d hm. Proof. unfold would_recover_before; cancel. Qed. Theorem synced_recover_after : forall xp na d ms ents hm, rep xp (Synced na (replay_disk ents d)) ms hm =p=> would_recover_either xp d ents hm. Proof. unfold would_recover_either; intros. norm; unfold stars; simpl; auto. or_r; or_l; cancel. Qed. Theorem applying_recover_after : forall xp d ms ents hm, rep xp (Applying d) ms hm =p=> would_recover_either xp d ents hm. 
fi_0 <= gc_size)%Z /\ (forall (i:N), (i < n)%N -> exists li, Mem.loadv int_chunk m (Vptr b (Ptrofs.repr (int_size*(Z.of_N (2+i)%N)))) = Some (make_vint (Z.of_N li)) /\ (nthN l i) = Some li). Inductive Forall_fundefs: (L6.cps.var -> fun_tag -> list L6.cps.var -> exp -> Prop) -> fundefs -> Prop := | Ff_cons : forall (P:(L6.cps.var -> fun_tag -> list L6.cps.var -> exp -> Prop)) f t vs e fds, P f t vs e -> Forall_fundefs P fds -> Forall_fundefs P (Fcons f t vs e fds) | Ff_nil: forall P, Forall_fundefs P Fnil. Theorem Forall_fundefs_In: forall P f t vs e fds, Forall_fundefs P fds -> fun_in_fundefs fds (f,t,vs,e) -> P f t vs e. Proof. induction fds; intros. - inv H; inv H0; subst. + inv H; auto. + apply IHfds; auto. - inv H0. Qed. Definition correct_environments_for_function: genv -> fun_env -> M.t positive -> mem -> fundefs -> L6.cps.var -> fun_tag -> list L6.cps.var -> exp -> Prop := fun ge fenv finfo_env m fds f t vs e => exists l locs finfo b, M.get f finfo_env = Some finfo /\ correct_fundef_info m f t vs e finfo /\ M.get t fenv = Some (l, locs) /\ l = N.of_nat (length vs) /\ Genv.find_symbol (globalenv p) f = Some b /\ repr_val_L6_L7 (cps.Vfun (M.empty cps.val) fds f) m (Vptr b Ptrofs.zero). Definition correct_environments_for_functions: fundefs -> genv -> fun_env -> M.t positive -> mem -> Prop := fun fds ge fenv finfo_env m => Forall_fundefs (correct_environments_for_function ge fenv finfo_env m fds) fds. Definition is_protected_id (id:positive) : Prop := List.In id protectedIdent.Definition is_protected_tinfo_id (id:positive) : Prop := id = allocIdent \/ id = limitIdent \/ id = argsIdent.Theorem is_protected_tinfo_weak: forall x, is_protected_tinfo_id x -> is_protected_id x. Proof. intros. repeat destruct H; subst; inList. Qed. Definition functions_not_bound (rho:L6.eval.env) (e:exp): Prop := (forall x, bound_var e x -> Genv.find_symbol (Genv.globalenv p) x = None)/\ (forall x y v, M.get y rho = Some v -> bound_notfun_val v x -> Genv.find_symbol (Genv.globalenv p) x = None).Inductive unique_bindings_val: L6.cps.val -> Prop := | UB_Vfun: forall rho fds f, unique_bindings_fundefs fds -> unique_bindings_val (Vfun rho fds f) | UB_Vconstr: forall c vs, Forall unique_bindings_val vs -> unique_bindings_val (Vconstr c vs) |UB_VInt: forall z, unique_bindings_val (cps.Vint z) . Definition unique_bindings_env (rho:L6.eval.env) (e:exp) : Prop := unique_bindings e /\ (forall x v, M.get x rho = Some v -> ~ bound_var e x /\ unique_bindings_val v). Theorem unique_bindings_env_prefix: forall e rho, unique_bindings_env rho e -> forall rho', prefix_ctx rho' rho -> unique_bindings_env rho' e. 
apply Rlt_sign_pos_pos_rev with x; auto with real. Qed.Theorem Rgt_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y > 0-> 0 > y)%R. intros x y H1 H2; red; apply Rlt_sign_neg_neg_rev with x; auto with real. Qed.Theorem Rgt_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 > x * y -> 0 > y)%R. intros x y H1 H2; red; apply Rlt_sign_pos_neg_rev with x; auto with real. Qed.Theorem Rgt_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 > x * y -> y > 0)%R. intros x y H1 H2; red; apply Rlt_sign_neg_pos_rev with x; auto with real. Qed.Theorem Rmult_le_compat_l: forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R. auto with real. Qed.Theorem Rmult_le_neg_compat_l: forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R. intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring. replace (p * m)%R with (-(-p * m))%R; auto with real; try ring. Qed.Theorem Ropp_lt: forall n m, (m < n -> -n < -m)%R. auto with real. Qed.Theorem Rmult_lt_neg_compat_l: forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R. intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring. replace (p * m)%R with (-(-p * m))%R; auto with real; try ring. Qed.Theorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R. auto with real. Qed.Theorem Rmult_ge_compat_l: forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R. intros n m p H H1; apply Rle_ge; auto with real. Qed.Theorem Rmult_ge_neg_compat_l: forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R. intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring. replace (p * m)%R with (-(-p * m))%R; auto with real;try ring. Qed.Theorem Ropp_gt: forall n m, (m > n -> -n > -m)%R. auto with real. Qed.Theorem Rmult_gt_compat_l: forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R. unfold Rgt; auto with real. Qed. Theorem Rmult_gt_neg_compat_l: forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R. 
Hb. intros a. destruct (beq_dec a (m_sender msg)). + rewrite Nat.eqb_eq in H. subst a. rewrite (tmap_get_upd_eq _ _ _). auto. + rewrite Nat.eqb_neq in H. rewrite tmap_get_upd_ne. simpl. omega. apply neq_beq_false in H. apply beq_sym in H. auto. - rewrite Hb. apply Sum_sig with (m_sender msg); auto. Qed.Lemma step_contract_address_constant : forall env C I C' E', step env C I C' E' -> w_a C = w_a C'. Proof. intros. destruct C as [a S]. destruct C' as [a' S']. induction H; simpl; auto; intuition. Qed.Lemma steps_INV: forall ml env C E, INV env (w_st C) E -> forall env' C' E', steps env C ml env' C' E' -> INV env' (w_st C') (E ++ E'). Proof. induction ml. - intros. inversion_clear H0. destruct H2. subst. rewrite app_nil_r. trivial. - intros. inversion_clear H0. rename x into envx. rename a into msg. destruct H1 as [Cx [Ex [Ey [H1 [H2 [H3 H4]]]]]]. subst E'. assert (Hx : INV envx (w_st Cx) (E ++ Ex)). { assert (w_a C = w_a Cx). { apply step_contract_address_constant with env msg Ex. apply H1. } destruct C as [C_a C_st]. destruct Cx as [Cx_a Cx_st]. simpl. simpl in H. simpl in H0. generalize H. generalize H4. apply step_INV with C_a msg. subst Cx_a. apply H1. } substH IHml with (IHml envx Cx (E ++ Ex) Hx). rewrite app_assoc. apply IHml; trivial. Qed.Lemma INV_implies_totalSupply_fixed : forall env S E, INV env S E -> Sum (st_balances S) (st_totalSupply S). Proof. intros env S E HI. unfold INV in HI. destruct HI as [_ Hsum]. trivial. Qed. Theorem Property_totalSupply_fixed : forall env0 env ml C E C' E', create env0 C E -> env_step env0 env -> run env C ml C' E' -> Sum (st_balances (w_st C')) (st_totalSupply (w_st C')). Proof. intros env0 env ml C E C' E' Hc Hs Hr. unfold run in Hr. destruct Hr as [env' Hsteps]. apply INV_implies_totalSupply_fixed with env' (E++E'). substH Hc with (create_INV _ _ C E Hc Hs). eapply steps_INV; eauto. Qed. Theorem Property_only_onwer_can_mint: forall msg to amount, m_func msg = mc_mint to amount -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C). Proof. intros msg to amount Hfunc env C C' evts Hstep. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [[Howner _] _]. auto. Qed. Theorem Property_only_onwer_can_finish_minting: forall msg, m_func msg = mc_finishMinting -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C). 
e; OK (Sassign id te) | Csharpminor.Sstore chunk e1 e2 => do te1 <- transl_expr cenv e1; do te2 <- transl_expr cenv e2; OK (Sstore chunk te1 te2) | Csharpminor.Scall optid sig e el => do te <- transl_expr cenv e; do tel <- transl_exprlist cenv el; OK (Scall optid sig te tel) | Csharpminor.Sbuiltin optid ef el => do tel <- transl_exprlist cenv el; OK (Sbuiltin optid ef tel) | Csharpminor.Sseq s1 s2 => do ts1 <- transl_stmt cenv xenv s1; do ts2 <- transl_stmt cenv xenv s2; OK (Sseq ts1 ts2) | Csharpminor.Sifthenelse e s1 s2 => do te <- transl_expr cenv e; do ts1 <- transl_stmt cenv xenv s1; do ts2 <- transl_stmt cenv xenv s2; OK (Sifthenelse te ts1 ts2) | Csharpminor.Sloop s => do ts <- transl_stmt cenv xenv s; OK (Sloop ts) | Csharpminor.Sblock s => do ts <- transl_stmt cenv (true :: xenv) s; OK (Sblock ts) | Csharpminor.Sexit n => OK (Sexit (shift_exit xenv n)) | Csharpminor.Sswitch long e ls => let (tbl, dfl) := switch_table ls O in do te <- transl_expr cenv e; transl_lblstmt cenv (switch_env ls xenv) ls (Sswitch long te tbl dfl) | Csharpminor.Sreturn None => OK (Sreturn None) | Csharpminor.Sreturn (Some e) => do te <- transl_expr cenv e; OK (Sreturn (Some te)) | Csharpminor.Slabel lbl s => do ts <- transl_stmt cenv xenv s; OK (Slabel lbl ts) | Csharpminor.Sgoto lbl => OK (Sgoto lbl) endwith transl_lblstmt (cenv: compilenv) (xenv: exit_env) (ls: Csharpminor.lbl_stmt) (body: stmt) {struct ls}: res stmt := match ls with | Csharpminor.LSnil => OK (Sseq (Sblock body) Sskip) | Csharpminor.LScons _ s ls' => do ts <- transl_stmt cenv xenv s; transl_lblstmt cenv (List.tail xenv) ls' (Sseq (Sblock body) ts) end.Definition block_alignment (sz: Z) : Z := if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8.Definition assign_variable (cenv_stacksize: compilenv * Z) (id_sz: ident * Z) : compilenv * Z := let (id, sz) := id_sz in let (cenv, stacksize) := cenv_stacksize in let ofs := align stacksize (block_alignment sz) in (PTree.set id ofs cenv, ofs + Z.max 0 sz).Definition assign_variables (cenv_stacksize: compilenv * Z) (vars: list (ident * Z)) : compilenv * Z := List.fold_left assign_variable vars cenv_stacksize.Module VarOrder <: TotalLeBool. Definition t := (ident * Z)%type. Definition leb (v1 v2: t) : bool := zle (snd v1) (snd v2). Theorem leb_total: forall v1 v2, leb v1 v2 = true \/ leb v2 v1 = true. 
Require Export ZFC.Elements.EST8_2. Import OrdinalClass ùêéùêçOperation. Declare Scope OrdArith_scope. Delimit Scope OrdArith_scope with oa. Open Scope OrdArith_scope. Definition OrdAdd := Œª Œ±, Operation Œ± Suc. Notation "Œ± + Œ≤" := (OrdAdd Œ± Œ≤) : OrdArith_scope.Theorem ordAdd_0_r : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± + 0 = Œ±. Proof. intros Œ± H. apply operation_0. Qed.Theorem ordAdd_suc : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± + Œ≤‚Å∫ = (Œ± + Œ≤)‚Å∫. Proof. intros Œ± H. apply operation_suc. Qed.Theorem ordAdd_limit : ‚àÄŒ± ‚ãµ ùêéùêç, continuous (OrdAdd Œ±). Proof. intros Œ± H ùúÜ. apply operation_limit. Qed.Corollary ordAdd_1_r : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± + 1 = Œ±‚Å∫. Proof. intros Œ± H. rewrite pred, ordAdd_suc, ordAdd_0_r; auto. Qed.Theorem ordAdd_ran : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± + Œ≤ ‚ãµ ùêéùêç. Proof. intros Œ± HŒ± Œ≤ HŒ≤. apply operation_operative; auto. Qed. Local Hint Resolve ordAdd_ran : core. Local Hint Resolve add_ran : core. Theorem fin_ordAdd_eq_add : ‚àÄ m n ‚àà œâ, m + n = (m + n)%œâ. 
{0,1}^eta; ls' <-$ (PRF_DRBG_f_bad (injD r) n'); ret (v :: ls') end. Print PRF_DRBG_f.Check PRF_DRBG_f_bad. Definition PRF_DRBG_G3_bad_1 := ls <-$ PRF_DRBG_f_bad v_init l; ret (hasDups _ ls). Theorem PRF_DRBG_f_bad_spec : forall n v (ls : list (D * Bvector eta)), comp_spec (fun (x1 : list (Bvector eta) * list (D * Bvector eta)) (x2 : list D) => Permutation (fst (split (snd x1))) ((fst (split ls)) ++ x2)) ((PRF_DRBG_f_G2 v n) _ _ (fun (ls : list (D * Bvector eta)) (a : D) => x <-$ { 0 , 1 }^eta; ret (x, (a, x) :: ls)) ls) (PRF_DRBG_f_bad v n). Proof. Print PRF_DRBG_f_G2. Check (PRF_DRBG_f_G2 v_init O) _ _.Check (fun (ls : list (D * Bvector eta)) (a : D) => x <-$ { 0 , 1 }^eta; ret (x, (a, x) :: ls)).Variable lsx : list (D * Bvector eta). Check ((PRF_DRBG_f_G2 v_init O) _ _ (fun (ls : list (D * Bvector eta)) (a : D) => x <-$ { 0 , 1 }^eta; ret (x, (a, x) :: ls)) nil). induction n; intuition; simpl in *. fcf_simp. fcf_spec_ret. simpl. rewrite app_nil_r. apply Permutation_refl. fcf_inline_first. fcf_skip. fcf_skip. fcf_spec_ret. simpl in H3. simpl. destruct (split ls). simpl in H3. simpl. eapply Permutation_trans. apply H3. apply Permutation_cons_app. apply Permutation_refl. Qed. Check PRF_A _ _ (fun ls a => x <-$ {0, 1}^eta; ret (x, (a, x)::ls)) nil. Fixpoint PRF_DRBG_f_bad (v : D)(n : nat) : Comp (list D) := match n with | O => ret nil | S n' => r <-$ {0,1}^eta; ls' <-$ (PRF_DRBG_f_bad (injD r) n'); ret (v :: ls') end.Check PRF_DRBG_f_bad. Definition PRF_DRBG_G3_bad_1 := ls <-$ PRF_DRBG_f_bad v_init l; ret (hasDups _ ls). *) Theorem PRF_DRBG_G3_bad_equiv : Pr[x <-$ PRF_DRBG_G3_3; ret (snd x)] == Pr[PRF_DRBG_G3_bad_1]. Proof. unfold PRF_DRBG_G3_3, PRF_DRBG_G3_bad_1. simpl. fcf_inline_first. fcf_to_prhl_eq. fcf_skip. * apply PRF_DRBG_f_bad_spec. * simpl in H1. fcf_inline_first. fcf_irr_l. fcf_simp. simpl. fcf_spec_ret. apply Permutation_hasDups. assumption. Qed. Fixpoint PRF_DRBG_f_bad_2 (n : nat) := match n with | O => ret nil | S n' => r <-$ {0,1}^eta; ls' <-$ (PRF_DRBG_f_bad_2 n'); ret (r :: ls') end.Check PRF_DRBG_f_bad_2. Definition PRF_DRBG_G3_bad_2 := ls <-$ PRF_DRBG_f_bad_2 (pred l); ret (hasDups _ (v_init :: (map injD ls))). Theorem PRF_DRBG_f_bad_2_equiv : forall n v, comp_spec (fun x1 x2 => x1 = v :: (map injD x2)) (PRF_DRBG_f_bad v (S n)) (PRF_DRBG_f_bad_2 n). induction n; intuition; simpl in *. fcf_irr_l. fcf_simp. fcf_spec_ret. fcf_skip. fcf_skip. fcf_spec_ret. Qed. Theorem PRF_DRBG_G3_bad_1_2_equiv : Pr[PRF_DRBG_G3_bad_1] == Pr[PRF_DRBG_G3_bad_2]. 
Require Import List Arith Lia.From Undecidability.Shared.Libs.DLW Require Import utils pos vec subcode sss compiler_correction.From Undecidability.MinskyMachines.MMA Require Import mma_defs mma_utils.Set Implicit Arguments.Tactic Notation "rew" "length" := autorewrite with length_db.Local Notation "e #> x" := (vec_pos e x). Local Notation "e [ v / x ]" := (vec_change e x v).Local Notation "P //‚Çê s -+> t" := (sss_progress (@mma_sss _) P s t) (at level 70, no associativity). Local Notation "P //‚Çê s ->> t" := (sss_compute (@mma_sss _) P s t) (at level 70, no associativity). Local Notation "P //‚Çê s ~~> t" := (sss_output (@mma_sss _) P s t) (at level 70, no associativity). Local Notation "P //‚Çê s ‚Üì" := (sss_terminates (@mma_sss _) P s) (at level 70, no associativity). Section mma_sim. Variables (n : nat). Definition mma_instr_compile lnk (_ : nat) (ii : mm_instr (pos n)) := match ii with | INC‚Çê k => INC‚Çê k :: nil | DEC‚Çê k j => DEC‚Çê k (lnk j) :: nil end. Definition mma_instr_compile_length (ii : mm_instr (pos n)) := 1. Fact mma_instr_compile_length_eq lnk i ii : length (mma_instr_compile lnk i ii) = mma_instr_compile_length ii. Proof. destruct ii; simpl; auto. Qed. Fact mma_instr_compile_length_geq ii : 1 <= mma_instr_compile_length ii. Proof. cbv; lia. Qed. Hint Resolve mma_instr_compile_length_eq mma_instr_compile_length_geq : core. Hint Resolve subcode_refl : core. Lemma mma_instr_compile_sound : instruction_compiler_sound mma_instr_compile (@mma_sss _) (@mma_sss _) eq. Proof. intros lnk I i1 v1 i2 v2 w1 H; revert H w1. change v1 with (snd (i1,v1)) at 2. change i1 with (fst (i1,v1)) at 2 3 4 6 7 8. change v2 with (snd (i2,v2)) at 2. change i2 with (fst (i2,v2)) at 2. generalize (i1,v1) (i2,v2); clear i1 v1 i2 v2. induction 1 as [ i x k | i x k v H | i x k v u H ]; simpl; intros w1 H0 ->. + exists (w1 [(S (w1#>x))/x]); split; auto. mma sss INC with x. mma sss stop; now f_equal. + exists w1; split; auto. mma sss DEC zero with x (lnk k). mma sss stop; now f_equal. + exists (w1[u/x]); split; auto. mma sss DEC S with x (lnk k) u. mma sss stop. Qed. Hint Resolve mma_instr_compile_sound : core. Theorem mma_auto_compiler : compiler_t (@mma_sss n) (@mma_sss n) eq. Proof. apply generic_compiler with (icomp := mma_instr_compile) (ilen := mma_instr_compile_length); auto. + apply mma_sss_total_ni. + apply mma_sss_fun. Qed. Theorem mma_auto_simulator i (P : list (@mm_instr (pos n))) : { Q : list (@mm_instr (pos n)) | forall v, (forall i' v', (i,P) //‚Çê (i,v) ~~> (i',v') -> (1,Q) //‚Çê (1,v) ~~> (length Q+1,v')) /\ ((1,Q) //‚Çê (1,v) ‚Üì -> (i,P) //‚Çê (i,v) ‚Üì) }. 
rewrite fold_left_init with (h := S); simpl in |- *; auto. intros a b1 b2; repeat rewrite plus_assoc_reverse. apply f_equal2 with (f := plus); auto; apply plus_comm. Qed. Fixpoint all_cover_aux (l : list (btree A)) (n : nat) {struct n} : list (btree A) := match n with | O => nil | S n1 => flat_map (fun l1 => match l1 with | nil => nil | a :: nil => a :: nil | a :: b :: l2 => all_cover_aux (node a b :: l2) n1 end) (all_permutations l) end. Definition all_cover l := all_cover_aux l (length l). Theorem all_cover_aux_cover : forall (n : nat) l t, n = length l -> In t (all_cover_aux l n) -> cover l t. Proof using. intros n; elim n; simpl in |- *; auto. intros l t H H0; elim H0. intros n0 H l t H0 H1. case in_flat_map_ex with (1 := H1); clear H1. intros x; case x; clear x. simpl in |- *; intros (H1, H2); case H2. intros b x; case x; clear x. simpl in |- *; intros (H1, [H2| H2]). rewrite <- H2. rewrite permutation_one_inv with (a := b) (l := l); auto. apply all_permutations_permutation; auto. case H2. intros b1 l1 (H1, H2). apply cover_node with (l2 := l1) (t1 := b) (t2 := b1); auto. apply permutation_sym; apply all_permutations_permutation; auto. apply H; auto. apply eq_add_S; apply trans_equal with (1 := H0). apply trans_equal with (length (b :: b1 :: l1)); auto. apply permutation_length. apply permutation_sym; apply all_permutations_permutation; auto. Qed. Theorem all_cover_cover : forall l t, In t (all_cover l) -> cover l t. Proof using. intros l t H; apply all_cover_aux_cover with (n := length l); auto. Qed. Theorem cover_all_cover_aux : forall (n : nat) l t, n = length l -> cover l t -> In t (all_cover_aux l n). intros n; elim n; simpl in |- *; auto. intros l; case l; simpl in |- *; auto. intros t H H0; inversion H0. generalize (permutation_nil_inv _ _ (permutation_sym _ _ _ H1)); intros; discriminate. intros; discriminate. intros n0 H l t H0 H1; inversion H1. simpl in |- *; auto. apply in_flat_map with (t1 :: t2 :: l2); auto. apply H; auto. apply eq_add_S; apply trans_equal with (1 := H0). apply trans_equal with (length (t1 :: t2 :: l2)); auto. apply permutation_length; auto. apply permutation_all_permutations; auto. apply permutation_sym; auto. Qed. Theorem cover_all_cover : forall l t, cover l t -> In t (all_cover l). 
0 (M.combine (f_opt_d 0 minus) count (init_census (rename_all_ns sig m))) (update_census sig m c_minus count)) /\ (forall f count sig, map_getd_r _ 0 (M.combine (f_opt_d 0 minus) count (update_census_f (M.empty var) (rename_all_fun_ns sig f) c_plus (M.empty nat))) (update_census_f sig f c_minus count)). Proof. eapply exp_def_mutual_ind; intros; simpl. - intro. rewrite gccombine_sub. rewrite <- H. rewrite gccombine_sub. unfold init_census. simpl. rewrite <- combine_minus_census_list. rewrite gccombine_sub. assert (Hfr := init_census_f_ar). destruct (Hfr c_plus). intros. simpl. rewrite H0. auto. rewrite H0. assert (Hcc := combine_plus_census_correct). destruct Hcc. rewrite <- H2. rewrite gccombine'. unfold init_census. lia. - intro. rewrite gccombine_sub. unfold init_census. simpl. rewrite ?gdempty. simpl. rewrite apply_r_empty. rewrite get_c_minus. reflexivity. - intro. rewrite gccombine_sub. unfold init_census. simpl. simpl in H0. unfold init_census in H0. simpl in H0. rewrite init_census_plus_ar. erewrite proper_minus_census_d. 2:{ apply smgd_sym. apply H0. } rewrite <- H. rewrite gccombine_sub. rewrite gccombine_sub. assert (Hcc := combine_plus_census_correct). destruct Hcc. rewrite <- H1. rewrite gccombine'. lia. - unfold init_census. simpl. intro. rewrite gccombine_sub. rewrite <- H. rewrite gccombine_sub. rewrite init_census_plus_ar. assert (H' := combine_plus_census_correct). destruct H'. rewrite <- H0. rewrite gccombine'. rewrite apply_r_empty. rewrite get_c_minus. lia. - intro. rewrite gccombine_sub. rewrite <- H. rewrite gccombine_sub. rewrite <- combine_minus_census_list. rewrite gccombine_sub. unfold init_census. simpl. assert (Hcc := combine_plus_census_correct). destruct Hcc. rewrite <- H0. rewrite gccombine'. rewrite <- combine_plus_census_list. rewrite gccombine'. rewrite apply_r_empty. rewrite apply_r_list_empty. rewrite get_c_minus. assert (Hfr := init_census_f_ar). destruct (Hfr c_plus). 1:{ intros. simpl. rewrite H2. auto. } rewrite <- (proj1 (rename_all_ns_empty)). unfold init_census. simpl. lia. - intro. rewrite gccombine_sub. unfold init_census. simpl. rewrite init_census_plus_ar. rewrite <- H0. rewrite gccombine_sub. symmetry. assert (H' := combine_plus_census_correct). destruct H'. rewrite <- H1. rewrite gccombine'. rewrite <- H2. rewrite gccombine'. rewrite <- (proj2 rename_all_ns_empty). rewrite <- H. rewrite gccombine_sub. unfold init_census. rewrite gdempty. lia. - intro. rewrite gccombine_sub. rewrite <- combine_minus_census_list. rewrite gccombine_sub. unfold init_census. simpl. rewrite <- combine_plus_census_list. rewrite gccombine'. rewrite apply_r_empty. rewrite apply_r_list_empty. rewrite get_c_minus. lia. - intro. rewrite gccombine_sub. unfold init_census. simpl. rewrite <- H. rewrite gccombine_sub. assert (H' := combine_plus_census_correct). destruct H'. rewrite <- H0. rewrite gccombine'. symmetry. rewrite <- combine_minus_census_list. rewrite gccombine_sub. rewrite <- (proj1 rename_all_ns_empty). lia. - intro. rewrite gccombine_sub. rewrite get_c_minus. unfold init_census. simpl. rewrite apply_r_empty. lia. - intro; rewrite gccombine_sub. rewrite <- H0. rewrite gccombine_sub. rewrite init_census_plus_ar_f. assert (H' := combine_plus_census_correct). destruct H'. rewrite <- H2. rewrite gccombine'. symmetry. rewrite <- H. rewrite gccombine_sub. unfold init_census. lia. - intro. rewrite gccombine_sub. rewrite gdempty. rewrite minus_n_O. reflexivity. Qed. Theorem rename_all_ns_app_ctx: forall e sig, (forall c, rename_all_ns sig (c |[ e]|) = (rename_all_ctx_ns sig c) |[rename_all_ns sig e ]|) /\ (forall fc, rename_all_fun_ns sig (fc <[ e]>) = (rename_all_fun_ctx_ns sig fc) <[rename_all_ns sig e ]>). 
From Coq Require Import ZArith Reals Lia.Require Import Zaux Raux Defs Digits.Section Float_prop.Variable beta : radix. Notation bpow e := (bpow beta e).Theorem Rcompare_F2R : forall e m1 m2 : Z, Rcompare (F2R (Float beta m1 e)) (F2R (Float beta m2 e)) = Z.compare m1 m2. Proof. intros e m1 m2. unfold F2R. simpl. rewrite Rcompare_mult_r. apply Rcompare_IZR. apply bpow_gt_0. Qed. Theorem le_F2R : forall e m1 m2 : Z, (F2R (Float beta m1 e) <= F2R (Float beta m2 e))%R -> (m1 <= m2)%Z. 
l2) -> canonical A0 eqA ltM (pX a (pluspf l1 l2)). intros l1 l2 a H' H'0. apply order_plusP with (l1 := l1) (l2 := l2); auto. apply canonical_pluspf; auto. apply canonical_imp_canonical with (a := a); auto. apply canonical_imp_canonical with (a := a); auto. Qed. Theorem pluspf_inv1_eqa : forall a p q, canonical A0 eqA ltM (pX a p) -> canonical A0 eqA ltM (pX a q) -> pX a (pluspf p q) = pluspf (pX a p) q. intros a p q; case q; auto. rewrite <- pO_pluspf_inv2; auto. rewrite <- pO_pluspf_inv2; auto. intros a0 l H'0 H'1. change (pX a (pluspf p (pX a0 l)) = pluspf (pX a p) (pX a0 l)) in |- *. apply pluspf_inv1_eq; auto. apply (canonical_pX_order _ A0 eqA) with (l := l); auto. Qed. Theorem pluspf_inv2_eqa : forall a p q, canonical A0 eqA ltM (pX a p) -> canonical A0 eqA ltM (pX a q) -> pX a (pluspf p q) = pluspf p (pX a q). intros a p; case p; auto. intros q H'0 H'1. rewrite <- pO_pluspf_inv1; auto. rewrite <- pO_pluspf_inv1; auto. intros a0 l q H'0 H'1. change (pX a (pluspf (pX a0 l) q) = pluspf (pX a0 l) (pX a q)) in |- *. apply pluspf_inv2_eq; auto. apply (canonical_pX_order A A0 eqA) with (l := l); auto. Qed. Theorem p0_pluspf_l : forall p, eqP A eqA n (pluspf (pO A n) p) p. intros p; rewrite <- pO_pluspf_inv1; auto. Qed. Theorem p0_pluspf_r : forall p, eqP A eqA n (pluspf p (pO A n)) p. intros p; rewrite <- pO_pluspf_inv2; auto. Qed. Hint Resolve p0_pluspf_l p0_pluspf_r. Theorem plusTerm_is_pX : forall (a : Term A n) (p : list (Term A n)), canonical A0 eqA ltM (pX a p) -> eqP A eqA n (pluspf (pX a (pO A n)) p) (pX a p). intros a p; case p; auto. intros a0 l H'. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pX a (pluspf (pO A n) (a0 :: l))); auto. change (eqP A eqA n (pluspf (pX a (pO A n)) (pX a0 l)) (pX a (pluspf (pO A n) (pX a0 l)))) in |- *. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); apply pluspf_inv1; auto. apply (canonical_pX_order A A0 eqA) with (l := l); auto. Qed. Hint Resolve plusTerm_is_pX. Theorem pluspf3_assoc : forall l, canonical A0 eqA ltM (fst l) -> canonical A0 eqA ltM (fst (snd l)) -> canonical A0 eqA ltM (snd (snd l)) -> eqP A eqA n (pluspf (pluspf (fst l) (fst (snd l))) (snd (snd l))) (pluspf (fst l) (pluspf (fst (snd l)) (snd (snd l)))). 
0%Z). apply Zabs_nat_lt. lia. simpl; auto. auto with arith. exists q. assert (H': k' = S r') by assumption. rewrite <- H';auto. * unfold check_range in H2. rewrite Hmod in H2; discriminate H2. * lia. * unfold check_range in H2; fold check_range in H2. case_eq ((v mod rz)%Z). intros Heqmod. rewrite Heqmod in H2. discriminate H2. intros pmod Heqmod; rewrite Heqmod in H2. elim (Hrec (Z.pred rz) Hlt). rewrite <- H1. rewrite inj_S. rewrite inj_S. rewrite inj_S. rewrite <- Zpred_succ. auto. assumption. exists (S k'). repeat split;auto. exists q; assumption. intros p Hmod. elim (Z_mod_lt v rz). rewrite Hmod. unfold Z.le; simpl; intros Hle'; elim Hle';auto. rewrite <- H1. rewrite inj_S. unfold Z.succ. generalize (Zle_0_nat (S r')). intros; lia. Qed.Theorem nat_of_P_Psucc : forall p:positive, nat_of_P (Pos.succ p) = S (nat_of_P p). Proof. intros p; elim p. - simpl; intros p'; rewrite nat_of_P_xO. intros Heq; rewrite Heq; rewrite nat_of_P_xI; ring. - intros p' Heq; simpl. rewrite nat_of_P_xI. rewrite nat_of_P_xO;auto. - auto. Qed.Theorem nat_to_Z_and_back: forall n:nat, Z.abs_nat (Z.of_nat n) = n. Proof. intros n; elim n. - auto. - intros n'; simpl; case n'. + simpl; auto. + intros n''; simpl; rewrite nat_of_P_Psucc. intros Heq; rewrite Heq; auto. Qed. Theorem check_correct : forall p:nat, 0 < p -> check_primality p = true -> ~(exists k:nat, k <> 1 /\ k <> p /\ (exists q:nat, p = q*k)). Proof. unfold lt; intros p Hle; elim Hle. - intros Hcp (k, (Hne1, (Hne1bis, (q, Heq)))); rewrite mult_comm in Heq. assert (Hle' : k < 1). + elim (le_lt_or_eq k 1); try(intuition; fail). apply divisor_smaller with (2:= Heq); auto. + case_eq k. intros Heq'; rewrite Heq' in Heq; simpl in Heq; discriminate Heq. intros; lia. - intros p' Hlep' Hrec; unfold check_primality. assert (H':(exists p'':nat, p' = (S p''))). + inversion Hlep'. exists 0; auto. eapply ex_intro;eauto. + elim H'; intros p'' Hp''; rewrite Hp''. repeat rewrite <- pred_Sn. intros Hcr Hex. elim check_range_correct with (3:= Hcr). rewrite inj_S; generalize (Zle_0_nat (S p'')). intros; lia. auto. elim Hex; intros k (Hne1, (HneSSp'', (q, Heq))); exists k. split. assert (HkleSSp'': k <= S (S p'')). * apply (divisor_smaller (S (S p'')) q). auto with arith. rewrite mult_comm. assumption. * lia. * split. assumption. exists q; now rewrite nat_to_Z_and_back. Qed. Theorem prime_2333 : ~(exists k:nat, k <> 1 /\ k <> 2333 /\ (exists q:nat, 2333 = q*k)). Proof. Time apply check_correct; auto with arith.Time Qed. Theorem reflection_test : forall x y z t u:nat, x+(y+z+(t+u)) = x+y+(z+(t+u)). 
not_trivially_empty l1 o1 r1 -> tree_rec2 (Node l1 o1 r1) Empty = base2 (Node l1 o1 r1). Proof. intros. destruct l1, o1, r1; try contradiction; reflexivity. Qed. Lemma unroll_tree_rec2_EN: forall l2 o2 r2, not_trivially_empty l2 o2 r2 -> tree_rec2 Empty (Node l2 o2 r2) = base1 (Node l2 o2 r2). Proof. intros. destruct l2, o2, r2; try contradiction; reflexivity. Qed. Lemma unroll_tree_rec2_NN: forall l1 o1 r1 l2 o2 r2, not_trivially_empty l1 o1 r1 -> not_trivially_empty l2 o2 r2 -> tree_rec2 (Node l1 o1 r1) (Node l2 o2 r2) = nodes l1 o1 r1 l2 o2 r2 (tree_rec2 l1 l2) (tree_rec2 r1 r2). Proof. intros. destruct l1, o1, r1; try contradiction; destruct l2, o2, r2; try contradiction; reflexivity. Qed. End TREE_REC2. Section TREE_IND. Context {A: Type} (P: tree A -> Type) (empty: P Empty) (node: forall l, P l -> forall o r, P r -> not_trivially_empty l o r -> P (Node l o r)). Program Fixpoint tree_ind' (m: tree' A) : P (Nodes m) := match m with | Node001 r => @node Empty empty None (Nodes r) (tree_ind' r) _ | Node010 x => @node Empty empty (Some x) Empty empty _ | Node011 x r => @node Empty empty (Some x) (Nodes r) (tree_ind' r) _ | Node100 l => @node (Nodes l) (tree_ind' l) None Empty empty _ | Node101 l r => @node (Nodes l) (tree_ind' l) None (Nodes r) (tree_ind' r) _ | Node110 l x => @node (Nodes l) (tree_ind' l) (Some x) Empty empty _ | Node111 l x r => @node (Nodes l) (tree_ind' l) (Some x) (Nodes r) (tree_ind' r) _ end. Definition tree_ind (m: tree A) : P m := match m with | Empty => empty | Nodes m' => tree_ind' m' end. End TREE_IND. Lemma tree'_not_empty: forall {A} (m: tree' A), exists i, get' i m <> None. Proof. induction m; simpl; try destruct IHm as [p H]. - exists (xI p); auto. - exists xH; simpl; congruence. - exists xH; simpl; congruence. - exists (xO p); auto. - destruct IHm1 as [p H]; exists (xO p); auto. - exists xH; simpl; congruence. - exists xH; simpl; congruence. Qed. Corollary extensionality_empty: forall {A} (m: tree A), (forall i, get i m = None) -> m = Empty. Proof. intros. destruct m as [ | m]; auto. destruct (tree'_not_empty m) as [i GET]. elim GET. apply H. Qed. Theorem extensionality: forall (A: Type) (m1 m2: tree A), (forall i, get i m1 = get i m2) -> m1 = m2. 
H2 H. apply list_app_eq_inv in H. destruct H as [ (m & H3 & H4) | (m & H3 & H4) ]; destruct m. inversion H4; subst; rewrite <- app_nil_end; auto. inversion H4; subst; destruct H1; apply in_or_app; right; left; auto. inversion H4; subst; rewrite <- app_nil_end; auto. inversion H4; subst; destruct H2; apply in_or_app; right; left; auto. Qed.Section flat_map. Variable (X Y : Type) (f : X -> list Y). Fact flat_map_app l1 l2 : flat_map f (l1++l2) = flat_map f l1 ++ flat_map f l2. Proof. induction l1; simpl; auto; solve list eq; f_equal; auto. Qed. Fact flat_map_app_inv l r1 y r2 : flat_map f l = r1++y::r2 -> exists l1 m1 x m2 l2, l = l1++x::l2 /\ f x = m1++y::m2 /\ r1 = flat_map f l1++m1 /\ r2 = m2++flat_map f l2. Proof. revert r1 y r2. induction l as [ | x l IHl ]; intros r1 y r2 H. + destruct r1; discriminate. + simpl in H. apply list_app_cons_eq_inv in H. destruct H as [ (m & Hm1 & Hm2) | (m & Hm1 & Hm2) ]. - apply IHl in Hm2. destruct Hm2 as (l1 & m1 & x' & m2 & l2 & G1 & G2 & G3 & G4); subst. exists (x::l1), m1, x', m2, l2; simpl; repeat (split; auto). rewrite app_ass; auto. - exists nil, r1, x, m, l; auto. Qed.End flat_map.Fact in_concat_iff X (ll : list (list X)) x : In x (concat ll) <-> exists l, In x l /\ In l ll. Proof. rewrite <- (map_id ll) at 1. rewrite <- flat_map_concat_map, in_flat_map. firstorder. Qed.Fact flat_map_flat_map X Y Z (f : X -> list Y) (g : Y -> list Z) l : flat_map g (flat_map f l) = flat_map (fun x => flat_map g (f x)) l. Proof. induction l; simpl; auto. rewrite flat_map_app; f_equal; auto. Qed.Fact flat_map_single X Y (f : X -> Y) l : flat_map (fun x => f x::nil) l = map f l. Proof. induction l; simpl; f_equal; auto. Qed.Section list_in_map. Variable (X Y : Type). Fixpoint list_in_map l : (forall x, @In X x l -> Y) -> list Y. Proof. refine (match l with | nil => fun _ => nil | x::l => fun f => f x _ :: @list_in_map l _ end). + left; auto. + intros y Hy; apply (f y); right; auto. Defined. Theorem In_list_in_map l f x (Hx : In x l) : In (f x Hx) (list_in_map l f). 
Proof. unfold traceRefines; intros. inv H. apply multistepMapZeroR in HMultistepBeh; auto. destruct HMultistepBeh as [uSpec [ll ?]]; dest. exists uSpec, ll. split; auto. constructor; auto. Qed. End ThetaRel. Section ThetaRelNoRuleMap. Variable thetaR: RegsT -> RegsT -> Prop. Variable thetaInit: thetaR (initRegs (getRegInits imp)) (initRegs (getRegInits spec)). Variable defsImpZero: getDefsBodies imp = nil. Variable defsSpecZero: getDefsBodies spec = nil. Variable substepRuleMap: forall oImp uImp rule csImp (Hreach: reachable oImp imp), Substep imp oImp uImp (Rle (Some rule)) csImp -> forall oSpec, thetaR oImp oSpec -> exists srule uSpec, Substep spec oSpec uSpec (Rle srule) (liftToMap1 p csImp) /\ thetaR (M.union uImp oImp) (M.union uSpec oSpec). Lemma stepMapZeroR_NoRuleMap: forall o (reachO: reachable o imp) u l (s: Step imp o u l) oSpec, thetaR o oSpec -> exists sl uSpec, Step spec oSpec uSpec sl /\ equivalentLabel (liftToMap1 p) l sl /\ thetaR (M.union u o) (M.union uSpec oSpec). Proof. intros; apply step_zero in s; auto; dest. destruct l as [ann ds cs]; simpl in *; subst. destruct ann as [[r|]|]. - pose proof (substepRuleMap reachO H1 H). destruct H0 as [srule [uSpec ?]]; dest. exists {| annot := Some srule; defs := M.empty _; calls := liftToMap1 p cs |}. exists uSpec; repeat split. + apply substepZero_imp_step in H0; auto. + auto. - inv H1; exists emptyRuleLabel, (M.empty _); repeat split. + match goal with | [ |- Step _ _ _ ?l ] => change l with (getLabel (Rle None) (M.empty _)) end. apply substepZero_imp_step; auto. constructor. + mred. - inv H1; exists emptyMethLabel, (M.empty _); repeat split. + match goal with | [ |- Step _ _ _ ?l ] => change l with (getLabel (Meth None) (M.empty _)) end. apply substepZero_imp_step; auto. constructor. + mred. Qed. Lemma multistepMapZeroR_NoRuleMap: forall o u l, o = initRegs (getRegInits imp) -> Multistep imp o u l -> exists uSpec ll, thetaR u uSpec /\ equivalentLabelSeq (liftToMap1 p) l ll /\ Multistep spec (initRegs (getRegInits spec)) uSpec ll. Proof. induction 2; simpl; intros; repeat subst. - do 2 eexists; repeat split. + instantiate (1:= initRegs (getRegInits spec)); auto. + instantiate (1:= nil); constructor. + constructor; auto. - specialize (IHMultistep eq_refl). destruct IHMultistep as [puSpec [pll ?]]; dest. apply stepMapZeroR_NoRuleMap with (oSpec:= puSpec) in HStep; auto; [|eexists; constructor; eauto]. destruct HStep as [sl [uSpec ?]]; dest. exists (M.union uSpec puSpec), (sl :: pll). repeat split; auto. + constructor; auto. + constructor; auto. Qed. Theorem decompositionZeroR_NoRuleMap: traceRefines (liftToMap1 p) imp spec. 
l i lv : l !! i = Some lv -> big_sepML Œ¶ m l -‚àó ‚àÉ k v, ‚åú m !! k = Some v ‚åù ‚àó Œ¶ k v lv ‚àó ‚àÄ v' lv', Œ¶ k v' lv' -‚àó big_sepML Œ¶ (<[k := v']> m) (<[i := lv']> l). Proof. iIntros (Hi) "Hml". rewrite big_sepML_eq /big_sepML_def. iDestruct "Hml" as (lm) "[% Hml]". eapply list_some_map_to_list in Hi as Hi'; eauto. destruct Hi'. iDestruct (big_sepM2_lookup_r_some with "Hml") as (xm) "%"; eauto. iDestruct (big_sepM2_insert_acc with "Hml") as "[Hx Hml]"; eauto. iExists _, _. iSplitR; first by done. iFrame. iIntros (v' lv') "Hx". iSpecialize ("Hml" with "Hx"). iExists (<[x:=lv']> lm). iFrame. iPureIntro. eapply map_to_list_insert_overwrite; eauto. Qed. Theorem big_sepML_lookup_l_app_acc Œ¶ m lv l0 l1 : big_sepML Œ¶ m (l0 ++ lv :: l1) -‚àó ‚àÉ k v, ‚åú m !! k = Some v ‚åù ‚àó Œ¶ k v lv ‚àó ‚àÄ v' lv', Œ¶ k v' lv' -‚àó big_sepML Œ¶ (<[k := v']> m) (l0 ++ lv' :: l1). Proof. iIntros "Hml". iDestruct (big_sepML_lookup_l_acc with "Hml") as "Hres". { rewrite lookup_app_r. - erewrite Nat.sub_diag. eauto. - lia. } iDestruct "Hres" as (k v) "(% & Hk & Hml)". iExists _, _. iSplitR; first eauto. iFrame. iIntros (v' lv') "Hk". iSpecialize ("Hml" with "Hk"). replace (length l0) with (length l0 + 0) by lia. rewrite insert_app_r. simpl. iFrame. Qed. Theorem big_sepML_lookup_m_acc Œ¶ m l k v : m !! k = Some v -> big_sepML Œ¶ m l -‚àó ‚àÉ i lv, ‚åú l !! i = Some lv ‚åù ‚àó Œ¶ k v lv ‚àó ‚àÄ v' lv', Œ¶ k v' lv' -‚àó big_sepML Œ¶ (<[k := v']> m) (<[i := lv']> l). Proof. iIntros (Hi) "Hml". rewrite big_sepML_eq /big_sepML_def. iDestruct "Hml" as (lm) "[% Hml]". iDestruct (big_sepM2_lookup_l_some with "Hml") as (xm) "%"; eauto. iDestruct (big_sepM2_insert_acc with "Hml") as "[Hx Hml]"; eauto. eapply map_to_list_some_list in H1 as H1'; eauto. destruct H1'. iExists _, _. iSplitR; first by done. iFrame. iIntros (v' lv') "Hx". iSpecialize ("Hml" with "Hx"). iExists (<[k := lv']> lm). iFrame. iPureIntro. eapply map_to_list_insert_overwrite; eauto. Qed. Theorem big_sepML_mono Œ¶ Œ® m l : big_sepML Œ¶ m l -‚àó ‚åú ‚àÄ k v lv, Œ¶ k v lv -‚àó Œ® k v lv ‚åù -‚àó big_sepML Œ® m l. Proof. rewrite big_sepML_eq; iIntros "Hml %". iDestruct "Hml" as (lm) "[% Hml]". iExists lm; iSplitR; first by eauto. iApply big_sepM2_mono; eauto. Qed. Theorem big_sepML_lookup_l_Some Œ¶ m l i lv : l !! i = Some lv -> big_sepML Œ¶ m l -‚àó ‚åú ‚àÉ k v, m !! k = Some v ‚åù. 
zarith. intros H'2; repeat split; simpl in |- *; auto with float zarith arith. apply Zlt_trans with (Zabs (Fnum a)); auto with float zarith. repeat rewrite Zabs_eq_opp; auto with float zarith. rewrite Zabs_Zmult. rewrite (Zabs_eq radix); [ idtac | apply Zle_trans with 1%Z; auto with zarith ]. repeat rewrite Zabs_eq_opp; auto with float zarith. pattern (Zpos (vNum b)) at 1 in |- *; rewrite (PosNormMin radix) with (precision := precision); auto with zarith. apply Zle_Zmult_comp_l; auto with zarith. replace (- Zsucc (Fnum a))%Z with (Zpred (- Fnum a)). auto with float zarith. unfold pPred in |- *; apply Zle_Zpred. case (Zle_lt_or_eq (nNormMin radix precision) (- Fnum a)); auto. rewrite <- Zabs_eq_opp; auto with float zarith. apply pNormal_absolu_min with (b := b); auto. intros H'4; Contradict H'2; rewrite H'4; ring. apply Zpred_Zopp_Zs; auto. Qed. Theorem FSuccNormNegNormMin : Fsubnormal radix b (FSucc (Float (- nNormMin radix precision) (- dExp b))). unfold FSucc in |- *; simpl in |- *. generalize (Z_eq_bool_correct (- nNormMin radix precision) (pPred (vNum b))); case (Z_eq_bool (- nNormMin radix precision) (pPred (vNum b))); intros H'; auto. absurd (0%nat < pPred (vNum b))%Z; auto. rewrite <- H'; auto with float zarith. replace (Z_of_nat 0) with (- (0))%Z; [ idtac | simpl in |- *; auto ]. apply Zle_not_lt; apply Zle_Zopp; auto with float zarith. apply Zlt_le_weak; auto with float zarith. apply nNormPos; auto with float zarith. unfold pPred in |- *; apply Zlt_succ_pred; simpl in |- *; auto with float zarith. apply (vNumbMoreThanOne radix) with (precision := precision); auto with float zarith. generalize (Z_eq_bool_correct (- nNormMin radix precision) (- nNormMin radix precision)); case (Z_eq_bool (- nNormMin radix precision) (- nNormMin radix precision)); intros H'0. 2: Contradict H'0; auto. generalize (Z_eq_bool_correct (- dExp b) (- dExp b)); case (Z_eq_bool (- dExp b) (- dExp b)); intros H'1. 2: Contradict H'1; auto. repeat split; simpl in |- *; auto with zarith. apply Zle_lt_trans with (m := nNormMin radix precision); auto with float zarith. rewrite <- Zopp_Zpred_Zs; rewrite Zabs_Zopp; rewrite Zabs_eq; auto with float zarith. apply Zle_Zpred; simpl in |- *; auto with float zarith. apply nNormPos; auto with float zarith. rewrite Zabs_Zmult; rewrite (Zabs_eq radix); auto with zarith. rewrite (PosNormMin radix) with (precision := precision); auto with zarith. apply Zmult_gt_0_lt_compat_l; auto with float zarith. rewrite <- Zopp_Zpred_Zs; rewrite Zabs_Zopp. rewrite Zabs_eq; auto with zarith. apply Zle_Zpred; simpl in |- *; auto with float zarith. apply nNormPos; auto with float zarith. Qed. Theorem FSuccNegCanonic : forall a : float, (a <= 0)%R -> Fcanonic radix b a -> Fcanonic radix b (FSucc a). 
) . set ( w3 := weqcomp w2 ( weqfunfromcoprodtoprod ( stn 1 ) ( stn n ) ( stn m ) ) ) . set ( w4 := weqcomp w3 ( weqdirprodf ( weqfunfromcontr ( stn m ) iscontrstn1 ) ( IHn m ) ) ) . apply ( weqcomp w4 ( weqfromprodofstn m ( natpower m n ) ) ) . Defined . Definition stnprod { n : nat } ( f : stn n -> nat ) : nat . Proof. intro n . induction n as [ | n IHn ] . intro. apply 1 . intro f . apply ( ( IHn ( fun i : stn n => f ( dni n ( lastelement n ) i ) ) ) * f ( lastelement n ) ) . Defined . Theorem weqstnprod { n : nat } ( P : stn n -> UU ) ( f : stn n -> nat ) ( ww : forall i : stn n , weq ( stn ( f i ) ) ( P i ) ) : weq ( forall x : stn n , P x ) ( stn ( stnprod f ) ) . Proof . intro n . induction n as [ | n IHn ] . intros . simpl . apply ( weqcontrcontr ) . apply ( iscontrsecoverempty2 _ ( negstn0 ) ) . apply iscontrstn1 . intros . set ( w1 := weqdnicoprod n ( lastelement n ) ) . set ( w2 := weqonsecbase P w1 ) . set ( w3 := weqsecovercoprodtoprod ( fun x : _ => P ( w1 x ) ) ) . set ( w4 := weqcomp w2 w3 ) . set ( w5 := IHn ( fun x : stn n => P ( w1 ( ii1 x ) ) ) ( fun x : stn n => f ( w1 ( ii1 x ) ) ) ( fun i : stn n => ww ( w1 ( ii1 i ) ) ) ) . set ( w6 := weqcomp w4 ( weqdirprodf w5 ( weqsecoverunit _ ) ) ) . simpl in w6 . set ( w7 := weqcomp w6 ( weqdirprodf ( idweq _ ) ( invweq ( ww ( lastelement n ) ) ) ) ) . apply ( weqcomp w7 ( weqfromprodofstn _ _ ) ) . Defined . Theorem weqweqstnsn ( n : nat ) : weq ( weq ( stn ( S n ) ) ( stn ( S n ) ) ) ( dirprod ( stn ( S n ) ) ( weq ( stn n ) ( stn n ) ) ) . 
Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b. intros a b; case a; case b; simpl in |- *; auto. intuition. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed.Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b. intros a b H' H'0; red in |- *; intros H'1. apply H'. apply zeroP_comp_eqTerm with (a := b); auto. apply eqTerm_sym; auto. Qed. Set Implicit Arguments. Unset Strict Implicit. Definition plusTerm : Term -> Term -> Term. intros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1 H2; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a1 m1 a2 m2 H1 H2; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. Qed. Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b). intros a b c; case a; case b; case c; simpl in |- *; auto. intuition. Qed. Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x). 
Require Import Bool. Require Import Arith. Require Import Compare_dec. Require Import Peano_dec. Require Import General. Require Import MyList. Require Import MyRelations.Require Export Main. Require Export SortECC.Section ECC. Definition trm_ecc := term srt_ecc. Definition env_ecc := env srt_ecc. Definition ecc : CTS_spec srt_ecc := Build_CTS_spec _ axiom_ecc rules_ecc univ_ecc (beta_delta_rule _). Definition ecc_pts : PTS_sub_spec srt_ecc := cts_pts_functor _ ecc. Definition le_type : red_rule srt_ecc := Rule _ (Le_type _ (pts_le_type _ ecc_pts)). Definition typ_ecc : env_ecc -> trm_ecc -> trm_ecc -> Prop := typ _ ecc_pts. Definition wft_ecc : env_ecc -> trm_ecc -> Prop := wf_type _ ecc_pts. Definition wf_ecc : env_ecc -> Prop := wf _ ecc_pts. Definition ecc_sn := sn srt_ecc (ctxt _ (Rule _ (head_reduct _ ecc))). Hint Unfold le_type typ_ecc wft_ecc wf_ecc ecc_sn: pts. Lemma whnf : forall (e : env_ecc) (t : trm_ecc), ecc_sn e t -> {u : trm_ecc | red _ (beta_delta _) e t u & head_normal _ (beta_delta _) e u}. Proof beta_delta_whnf srt_ecc. Lemma bd_conv_hnf : forall (e : env_ecc) (x y : trm_ecc), ecc_sn e x -> ecc_sn e y -> decide (conv_hn_inv _ (beta_delta_rule _) e x y). Proof CR_WHNF_convert_hn srt_ecc ecc_sort_dec (beta_delta_rule srt_ecc) (church_rosser_beta_delta srt_ecc) whnf. Theorem ecc_is_subtype_dec : subtype_dec_CTS _ ecc. apply Build_subtype_dec_CTS. exact (church_rosser_beta_delta srt_ecc).exact (bd_hn_sort srt_ecc).exact (bd_hn_prod srt_ecc).exact whnf.exact bd_conv_hnf.exact univ_ecc_dec. Qed. Axiom ecc_normalise : forall (e : env_ecc) (t T : trm_ecc), typ_ecc e t T -> ecc_sn e t. Lemma sound_ecc_bd : rule_sound _ ecc_pts (beta_delta _). unfold beta_delta in |- *. simpl in |- *. unfold union in |- *. apply union_sound. apply beta_sound; auto with arith pts. simpl in |- *. apply cumul_inv_prod. exact ecc_is_subtype_dec.apply delta_sound. Qed. Lemma ecc_is_norm_sound : norm_sound_CTS _ ecc. Proof. refine (Build_norm_sound_CTS srt_ecc ecc sound_ecc_bd ecc_normalise _ _ _). left. apply ecc_inf_axiom.exact ecc_inf_rule.intros. elim ecc_inf_axiom with s1; intros. split with x. apply (pp_ok p). Qed. Theorem ecc_algorithms : PTS_TC _ ecc_pts. 
auto. apply H2; omega. + destruct H as [n H]. revert H. revert l. induction n; simpl; intuition. pose proof (H1 0). destruct l; simpl in *. apply UntilLater. apply H; omega. apply IHn; intuition. pose proof (H1 (S i)); simpl in *; intuition. Qed. Theorem Release_semantics : forall (l : Stream A) (P Q : LTLProp A), Release P Q l <-> (forall (n : nat), Q (nth_tail n l)) \/ (exists (n : nat), (forall i, i <= n -> Q (nth_tail i l)) /\ P (nth_tail n l)). Proof. split; intros. + pose proof (classic ( (exists n : nat, (forall i : nat, i <= n -> Q (nth_tail i l)) /\ P (nth_tail n l)))) as [? | ?]; auto. left. intros n; revert H; revert H0; revert l. induction n; intros. - simpl. inversion H; subst; auto. - destruct l; simpl; apply IHn. * intros Hcontra. destruct Hcontra as [n0 Hcontra]. apply H0. exists (S n0). simpl; intuition. destruct i; simpl. inversion H; subst; auto. apply H1; omega. * inversion H; subst; auto. exfalso. apply H0. exists 0; intros; simpl; intuition. inversion H3; auto. + destruct H as [? | ?]. - revert H; revert l; cofix H; intros. destruct l. apply ReleaseLater. * pose proof (H0 0); auto. * apply H. intros. specialize (H0 (S n)); auto. - destruct H as [n H]. revert H; revert l; induction n; intros. * intuition; specialize (H0 0). apply ReleaseHere; auto. * destruct l; simpl in *; intuition. apply ReleaseLater. specialize (H0 0); intuition. apply IHn; intuition. specialize (H0 (S i)); intuition. Qed. End Semantics. Ltac ltl_fsimpl := ltl_simpl; repeat ( try rewrite Always_semantics in *; try rewrite Eventually_semantics in *; try rewrite Until_semantics in *; intros; try match goal with | [ H : exists x, _ |- _ ] => let x := fresh x in destruct H as [x H] end ). Section Absorption. Lemma nth_tail_eq_n : forall (l : Stream A) (n n' : nat), n = n' -> nth_tail n l = nth_tail n' l. Proof. intros; subst; auto. Qed. Theorem Eventually_absorb : forall (P : LTLProp A), Eventually (Always (Eventually P)) ~= Always (Eventually P). Proof. ltl_simpl. + ltl_fsimpl. specialize (H n); simpl in *; ltl_fsimpl. exists (n0 + n1); simpl in *. repeat rewrite nth_tail_assoc in *. erewrite nth_tail_eq_n; try eassumption; omega. + rewrite Eventually_semantics. exists 0; auto. Qed. Theorem Always_absorb : forall (P : LTLProp A), Always (Eventually (Always P)) ~= Eventually (Always P). 
:= (Z2Zp Hv'). Notation "„Äö x „Äõ" := (f x). Notation "„Äò x „Äô" := (morph22 f x). Local Notation "‚äü" := (MI22 (Zp_opp Hv')). Local Infix "‚ä " := (MU22 (Zp_plus Hv') (Zp_mult Hv')) (at level 40, left associativity). Let Am_iAm_mod :„ÄòA m„Äô= ‚äü„ÄòiA m„Äô. Proof. apply M22_equal. + rewrite Z2Zp_opp, Zp_opp_inv. apply Z2Zp_inj. exists 1; rewrite Hv; ring. + rewrite Z2Zp_opp; auto. + rewrite Z2Zp_opp, Zp_opp_inv; auto. + rewrite <- Z2Zp_opp. apply Z2Zp_inj. exists 1; rewrite Hv; ring. Qed. Fact A2m_mod : „ÄòA (2*m)„Äô= ‚äü„ÄòMZ_one„Äô. Proof. rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A; auto. rewrite mscal_S, mscal_1; auto. rewrite MU22_morph with (1 := Z2Zp_morph). rewrite Am_iAm_mod at 1. do 2 rewrite <- MI22_morph with (1 := Z2Zp_morph). rewrite <- MU22_morph with (1 := Z2Zp_morph). f_equal. rewrite M22_opp_mult_l with (1 := Zring); f_equal. apply iA_A. Qed. Fact A2lm_mod : „ÄòA (2*l*m)„Äô= „ÄòMZ_scal (mscal Zmult 1 l (-1)) MZ_one„Äô. Proof. replace (2*l*m)%nat with (l*(2*m))%nat by ring. rewrite <- MZ_expo_A, mscal_mult, MZ_expo_A; auto. rewrite expo22_morph with (1 := Z2Zp_morph). rewrite A2m_mod. rewrite <- MI22_morph with (1 := Z2Zp_morph). rewrite <- expo22_morph with (1 := Z2Zp_morph). f_equal. rewrite <- M22scal_MI22 with (1 := Zring). change (-(1)) with (-1). rewrite expo22_scal with (1 := Zring); f_equal. rewrite mscal_of_unit; auto. Qed. Let expoZ_opp1 i : expoZ i (-1) = 1 \/ expoZ i (-1) = -1. Proof. induction i as [ | i IHi ]. + rewrite mscal_0; auto. + rewrite mscal_S; lia. Qed. Variable (j : nat) (Hl : (l <> 0)%nat) (Hj : (j <= m)%nat). Fact alpha_2lm_plus_j :„ÄöŒ± (S (2*l*m+j))„Äõ=„ÄöexpoZ l (-1)*Œ± (S j)„Äõ. Proof. generalize (A_plus (2*l*m) j); intros H. apply f_equal with (f := morph22 f) in H. rewrite MU22_morph with (1 := Z2Zp_morph) in H. rewrite A2lm_mod in H. rewrite <- MU22_morph with (1 := Z2Zp_morph) in H. apply M22_proj12 in H. rewrite Z.mul_0_r, Z.mul_0_l, Z.mul_1_r, Z.add_0_l in H. apply H. Qed. Let Hj' : (j <= 2*l*m)%nat. Proof. apply le_trans with (1*m)%nat; try lia. apply mult_le_compat; lia. Qed. Fact alpha_2lm_minus_j :„ÄöŒ± (S (2*l*m-j))„Äõ=„ÄöexpoZ (S l) (-1)*Œ± (S j)„Äõ. Proof using Hl Hj. generalize (A_minus Hj'); intros H. apply f_equal with (f := morph22 f) in H. rewrite MU22_morph with (1 := Z2Zp_morph) in H. rewrite A2lm_mod in H. rewrite <- MU22_morph with (1 := Z2Zp_morph) in H. apply M22_proj12 in H. rewrite Z.mul_0_r, Z.mul_0_l, Z.mul_1_r, Z.add_0_l in H. unfold plus in H; rewrite H; f_equal. rewrite mscal_S; ring. Qed. Theorem alpha_nat_2lm_plus_j : nat2Zp Hv' (alpha_nat (2*l*m+j)) = nat2Zp Hv' (alpha_nat j) \/ nat2Zp Hv' (alpha_nat (2*l*m+j)) = Zp_opp Hv' (nat2Zp Hv' (alpha_nat j)). 
Œ± ‚àà œâ ^^·¥∏ n. Proof. split. apply Œµ‚ÇÄE. intros [n [Hn HŒ±]]. apply (Œµ‚ÇÄI n); auto. Qed. Lemma Œµ‚ÇÄ_neq_0 : Œµ‚ÇÄ ‚â 0. Proof. rewrite Œµ‚ÇÄ_normal_form. intros H. apply ordTetL_eq_0 in H; nauto. Qed. Local Hint Resolve Œµ‚ÇÄ_neq_0 : core. Lemma Œµ‚ÇÄ_closed_under_œâ_exp : ‚àÄŒ± ‚àà Œµ‚ÇÄ, œâ ^ Œ± ‚àà Œµ‚ÇÄ. Proof with nauto. intros Œ± HŒ±. assert (HoŒ±: Œ± ‚ãµ ùêéùêç). apply (ord_is_ords Œµ‚ÇÄ)... apply Œµ‚ÇÄE in HŒ± as [n [Hn HŒ±]]. apply (Œµ‚ÇÄI n‚Å∫). apply œâ_inductive... rewrite œâ_tower_suc... apply ordExp_preserve_lt... Qed. Definition Œµ_number := Œª Œµ, Œµ ‚ãµ ùêéùêç ‚àß œâ ^ Œµ = Œµ. Lemma Œµ‚ÇÄ_is_Œµ_number : Œµ‚ÇÄ ‚ãµ Œµ_number. Proof with neauto. split... ext. - rewrite ordExp_limit in H... apply FUnionE in H as [Œ± [HŒ± Hx]]. eapply ord_trans... apply Œµ‚ÇÄ_closed_under_œâ_exp... - rewrite ordExp_limit... eapply FUnionI... apply Œµ‚ÇÄE in H as [n [Hn Hx]]. eapply ordExp_enlarge_l_strictly... Qed. Lemma Œµ_number_neq_0 : ‚àÄŒµ ‚ãµ Œµ_number, Œµ ‚â 0. Proof with eauto. intros Œµ [HŒµ Heq]. intros H. subst. rewrite ordExp_0_r in Heq... Qed. Lemma Œµ_number_neq_1 : ‚àÄŒµ ‚ãµ Œµ_number, Œµ ‚â 1. Proof with neauto. intros Œµ [HŒµ Heq]. intros H. subst. rewrite ordExp_1_r in Heq... assert (1 ‚àà œâ)... rewrite Heq in H. eapply nat_irrefl... Qed. Lemma Œµ_number_has_tower_n : ‚àÄn ‚àà œâ, ‚àÄŒµ ‚ãµ Œµ_number, œâ ^^·¥∏ n ‚àà Œµ. Proof with neauto. intros n Hn. œâ_induction n; intros Œµ [HŒµ Heq]. - rewrite <- zero, œâ_tower_0, <- Heq. apply ordExp_enlarge_r... apply ord_neq_0_1_gt_1... apply Œµ_number_neq_0. split... apply Œµ_number_neq_1. split... - rewrite œâ_tower_suc, <- Heq... apply ordExp_preserve_lt... apply IH. split... Qed. Lemma Œµ‚ÇÄ_is_the_least_Œµ_number : ‚àÄŒ± ‚ãµ Œµ_number, Œµ‚ÇÄ ‚ã∏ Œ±. Proof with eauto. intros Œµ [HŒµ Heq]. apply ord_le_iff_sub... intros x Hx. apply Œµ‚ÇÄE in Hx as [n [Hn Hx]]. eapply ord_trans... apply Œµ_number_has_tower_n... split... Qed. Definition Œµ := Enumerate Œµ_number. Lemma Œµ_number_sub_ùêéùêç : Œµ_number ‚´É ùêéùêç. Proof. intros Œ± []; auto. Qed. Local Hint Resolve Œµ_number_sub_ùêéùêç : core. Lemma Œµ_number_unbounded : unbounded Œµ_number. Proof. apply fixed_point_class_unbounded, ordExp_normal; nauto. Qed. Local Hint Resolve Œµ_number_unbounded : core. Lemma Œµ_spec : ‚àÄŒ± ‚ãµ ùêéùêç, ‚àÄŒæ ‚ãµ Œµ_number, Œæ ‚àâ {Œµ x | x ‚àä Œ±} ‚Üí Œµ Œ± ‚ã∏ Œæ. Proof. intros Œ± HŒ± Œæ HŒæ. apply enum_spec; auto. Qed. Lemma Œµ_is_Œµ_number : Œµ :·∂ú ùêéùêç ‚áí Œµ_number. Proof. apply enum_into_class; auto. Qed. Local Hint Resolve Œµ_is_Œµ_number : core. Lemma Œµ_operative : Œµ :·∂ú ùêéùêç ‚áí ùêéùêç. Proof. intros. apply enum_operative; auto. Qed. Local Hint Resolve Œµ_operative : core. Theorem Œµ_0 : Œµ 0 = Œµ‚ÇÄ. 
Variable S : Set. Variable tr : S -> Label -> S -> Prop. Inductive RState (Sini : S) : S -> Prop := | rsIni : RState Sini Sini | rsNext : forall (s1 s2 : S) (l : Label), RState Sini s1 -> tr s1 l s2 -> RState Sini s2. Inductive RState_T (Sini : S) : S -> Instant -> Prop := | rsIni_T : RState_T Sini Sini time0 | rsTime_T : forall (s1 s2 : S) (t : Instant), RState_T Sini s1 t -> tr s1 Tick s2 -> RState_T Sini s2 (Inc t) | rsNoTime_T : forall (s1 s2 : S) (l : Label) (t : Instant), RState_T Sini s1 t -> l <> Tick -> tr s1 l s2 -> RState_T Sini s2 t. Definition ForAll (Sini : S) (P : S -> Prop) := forall s : S, RState Sini s -> P s. Definition ForAll_T (Sini : S) (P : S -> Prop) (bound : Instant -> Prop) := forall (s : S) (t : Instant), bound t -> RState_T Sini s t -> P s. Inductive Exists (Sini : S) (P : S -> Prop) : Prop := exists_ : forall s : S, RState Sini s -> P s -> Exists Sini P. Inductive Exists_T (Sini : S) (P : S -> Prop) (bound : Instant -> Prop) : Prop := exists_T : forall (s : S) (t : Instant), bound t -> RState_T Sini s t -> P s -> Exists_T Sini P bound. Theorem Mon_I : forall (Sini : S) (Pg Pp : S -> Prop), ForAll Sini Pg -> (forall s : S, Pg s -> Pp s) -> ForAll Sini Pp. Proof. unfold ForAll in |- *; intros. apply H0. apply H; assumption. Qed. Theorem Mon_I_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> ForAll_T Sini Pp bound. Proof. unfold ForAll_T in |- *; intros. apply H0. apply (H s t); assumption. Qed. Theorem Conj : forall (Sini : S) (P1 P2 : S -> Prop), ForAll Sini P1 -> ForAll Sini P2 -> ForAll Sini (fun s : S => P1 s /\ P2 s). Proof. unfold ForAll in |- *; intros. split; [ apply H | apply H0 ]; assumption. Qed. Theorem Conj_T : forall (Sini : S) (P1 P2 : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P1 bound -> ForAll_T Sini P2 bound -> ForAll_T Sini (fun s : S => P1 s /\ P2 s) bound. 
generalize (X.eq_trans H2 e);intro. elim (X.lt_not_eq H0 H3). generalize (X.lt_trans H0 l);intro. generalize (X.eq_sym H);intro. elim (X.lt_not_eq H2 H3). elim H0;clear H0;intros. right. split. eauto. eauto. Qed. Lemma lt_not_eq : forall (x y:t),(lt x y)->~(eq x y). unfold lt, eq;destruct x;destruct y;intro;intro. elim H0;clear H0;intros. case H. intro. apply (X.lt_not_eq H2 H0). intro. elim H2;clear H2;intros. apply (Y.lt_not_eq H3 H1). Qed. Definition compare : forall (x y:t),(Compare lt eq x y). destruct x;destruct y. case (X.compare t0 t2);intro. apply LT. left;trivial. case (Y.compare t1 t3);intro. apply LT. right. tauto. apply EQ. split;trivial. apply GT. right;auto. apply GT. left;trivial. Defined. Definition eq_dec : forall (x y: t), { eq x y } + { ~ eq x y}. Proof. intros [xa xb] [ya yb]; simpl. destruct (X.eq_dec xa ya). destruct (Y.eq_dec xb yb). + left; now split. + right. now intros [eqa eqb]. + right. now intros [eqa eqb]. Defined. Hint Immediate eq_sym. Hint Resolve eq_refl eq_trans lt_not_eq lt_trans. End OrderedPair.Module MessageSpi. Inductive message : Set := | MNam : nat -> message. Definition t := message. Fixpoint message_lt (m n:message) {struct m} : Prop := match (m,n) with | (MNam n1,MNam n2) => n1 < n2 end. Module Ord <: OrderedType with Definition t := message with Definition eq := @eq message. Definition t := message. Definition eq := @eq message. Definition lt := message_lt. Lemma eq_refl : forall (x:t),eq x x. unfold eq;auto. Qed. Lemma eq_sym : forall (x y:t),(eq x y )->(eq y x). unfold eq;auto. Qed. Lemma eq_trans : forall (x y z:t),(eq x y)->(eq y z)->(eq x z). unfold eq;auto;intros;congruence. Qed. Lemma lt_trans : forall (x y z:t),(lt x y)->(lt y z)->(lt x z). unfold lt. induction x;destruct y;simpl;try tauto;destruct z;try tauto;intros. omega. Qed. Lemma lt_not_eq : forall (x y:t),(lt x y)->~(eq x y). unfold eq;unfold lt. induction x;destruct y;simpl;try tauto;intro;red;intro;try (discriminate H0);injection H0;intros. elim (lt_irrefl n);try omega. Qed. Definition compare : forall (x y:t),(Compare lt eq x y). unfold lt, eq. induction x;destruct y;intros;try (apply LT;simpl;trivial;fail);try (apply GT;simpl;trivial;fail). case (lt_eq_lt_dec n n0);intros;try (case s;clear s;intros). apply LT;trivial. apply EQ;trivial. rewrite e;trivial. apply GT;trivial. Defined. Definition eq_dec : forall (x y: t), { eq x y } + { ~ eq x y}. Proof. intros [i] [j]. unfold eq. destruct (eq_nat_dec i j). + left. now f_equal. + right. intros meq; now inversion meq. Defined. Hint Immediate eq_sym. Hint Resolve eq_refl eq_trans lt_not_eq lt_trans. End Ord. Theorem eq_dec : forall (m n:message),{m=n}+{~(m=n)}. 
- assert (A1: length ls = 0) by omega. apply length_zero_iff_nil in A1. now subst ls. - destruct ls as [| x1 xs]. now simpl. destruct xs as [| x2 xs]. intros. simpl. rewrite ?fold_tree_equation. auto. intros. rewrite fold_tree_equation. name_term tpl (unapp_half (x1::x2::xs)) Tpl; rewrite <- Tpl; destruct tpl as [m1 m2]. simpl in K. assert (K': S (length xs) <= l) by (rewrite le_S_n; auto); clear K; rename K' into K. assert (length m1 <= length (x2::xs) /\ length m2 <= length (x2::xs)) as [A1 A2]. { symmetry in Tpl. apply unapp_half_nonnil_reduces in Tpl; auto. 2: simpl; omega. simpl in *. omega. } simpl in A1, A2. assert (A3: length m1 <= l) by omega; clear A1. assert (A4: length m2 <= l) by omega; clear A2. remember (f (fold_tree f seed m1) (fold_tree f seed m2)) as sth. rewrite fold_tree_equation. simpl. apply unapp_half_map with (f := (@evalExpr _)) in Tpl. simpl in Tpl. rewrite <- Tpl. rewrite Heqsth; clear Heqsth. rewrite <- ?IHl; auto. destruct xs; simpl; auto. Qed. Variable fComm: forall a b, fEval a b = fEval b a. Variable fAssoc: forall a b c, fEval (fEval a b) c = fEval a (fEval b c). Variable unit: Expr type (SyntaxKind k). Variable fUnit: forall x, fEval (evalExpr unit) x = x. Lemma evalExprFoldTree_evalExprFoldLeft ls: evalExpr (fold_tree f unit ls) = evalExpr (fold_left f ls unit). Proof. rewrite evalFoldLeft_Expr. rewrite evalFoldTree_Expr. rewrite fold_left_fold_tree; auto. Qed. Lemma evalExprFoldTree_evalExprFoldRight ls: evalExpr (fold_tree f unit ls) = evalExpr (fold_right f unit ls). Proof. rewrite evalFoldRight_Expr. rewrite evalFoldTree_Expr. rewrite fold_right_fold_tree; auto. Qed. End FoldExpr.Section SimulationZeroAct. Variable imp spec: BaseModuleWf type. Variable simRel: RegsT -> RegsT -> Prop. Variable simRelGood: forall oImp oSpec, simRel oImp oSpec -> getKindAttr oSpec = getKindAttr (getRegisters spec). Variable initRel: forall rimp, Forall2 regInit rimp (getRegisters imp) -> exists rspec, Forall2 regInit rspec (getRegisters spec) /\ simRel rimp rspec. Variable NoMeths: getMethods imp = []. Variable NoMethsSpec: getMethods spec = []. Variable simulation: forall oImp rImp uImp rleImp csImp oImp' aImp, In (rleImp, aImp) (getRules imp) -> SemAction oImp (aImp type) rImp uImp csImp WO -> UpdRegs [uImp] oImp oImp' -> forall oSpec, simRel oImp oSpec -> ((simRel oImp' oSpec /\ csImp = []) \/ (exists rleSpec aSpec, In (rleSpec, aSpec) (getRules spec) /\ exists rSpec uSpec, SemAction oSpec (aSpec type) rSpec uSpec csImp WO /\ exists oSpec', UpdRegs [uSpec] oSpec oSpec' /\ simRel oImp' oSpec')). Theorem simulationZeroAct: TraceInclusion (Base imp) (Base spec). 
threadInfIdent nParam avs aind fenv map) eqn:Happvar; inv H. destruct (mkCallVars threadInfIdent nParam fenv map (Init.Nat.min (N.to_nat n) nParam) bvs) eqn:Hcallvar; inv H1. erewrite <- find_symbol_map_f. 2: eauto. econstructor; eauto. constructor. eapply asgnAppVars_correct; eauto. eapply mkCallVars_correct; eauto. - inv H. - simpl in H. inv H. eapply R_halt_e. apply find_symbol_map. auto. Qed. Inductive proper_ctor_ty_info: ctor_ty_info -> Prop := | PC_enum: forall name iname it ord, (0 <= (Z.of_N ord) < Ptrofs.half_modulus)%Z -> proper_ctor_ty_info (Build_ctor_ty_info name iname it 0%N ord) | PC_boxed: forall name iname it a ord, (0 <= (Z.of_N ord) < Zpower.two_p 8)%Z -> (0 <= Z.of_N (Npos a) < Zpower.two_power_nat (Ptrofs.wordsize - 10))%Z -> proper_ctor_ty_info (Build_ctor_ty_info name iname it (Npos a)%N ord). Definition proper_cenv (cenv:ctor_env):= forall c name iname it a ord, M.get c cenv = Some (Build_ctor_ty_info name iname it a ord) -> proper_ctor_ty_info (Build_ctor_ty_info name iname it a ord) /\ ~ (exists c' name' iname' a', c <> c' /\ M.get c' cenv = Some (Build_ctor_ty_info name' iname' it a' ord)).Theorem proper_cenv_set_none: forall k v m, proper_cenv (Maps.PTree.set k v m) -> M.get k m = None -> proper_cenv m. Proof. intros; intro; intros. assert (c <> k). intro; subst. rewrite H1 in H0; inv H0. split. erewrite <- M.gso in H1. 2: eauto. apply H in H1. destruct H1; auto. intro; destructAll. assert (x <> k). intro; subst. rewrite H4 in H0; inv H0. erewrite <- M.gso in H1. apply H in H1. destruct H1. apply H6. exists x, x0, x1, x2. split; auto. rewrite M.gso; auto. auto. Qed.Theorem compute_proper_rep_env: forall cenv, proper_cenv cenv -> correct_crep_of_env cenv (compute_rep_env cenv). Proof. intros. split; intros. - unfold compute_rep_env. rewrite M.gmap. unfold fmake_ctor_rep. rewrite H0. simpl. specialize (H _ _ _ _ _ _ H0). destructAll. destruct a. + eexists; split; auto. rewrite N.eqb_refl. inv H. econstructor; eauto. + eexists; split; auto. assert (N.pos p <> 0%N). intro Hp; inv Hp. rewrite <- N.eqb_neq in H2. rewrite H2. inv H. econstructor; eauto. - unfold compute_rep_env in H0. rewrite M.gmap in H0. unfold fmake_ctor_rep in H0. destruct (M.get c cenv) eqn:Hccenv. 2: inv H0. destruct c0. simpl in H0. specialize (H _ _ _ _ _ _ Hccenv). destruct H. destruct ctor_arity. + rewrite N.eqb_refl in H0. inv H0. inv H. econstructor; eauto. + assert (N.pos p <> 0%N). intro Hp; inv Hp. rewrite <- N.eqb_neq in H2. rewrite H2 in H0. inv H0. inv H. econstructor; eauto. Qed. Theorem compute_dc_ienv: forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv /\ correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv). 
Int.eq Int.eq_spec n Int.zero. exists x. split. apply H. destruct x; simpl; auto. rewrite H0. rewrite Int64.shru'_zero. constructor. destruct (Int.ltu n Int64.iwordsize') eqn:LT; simpl. - rewrite Val.shrlu_rolml by apply LT. apply eval_rolml. auto. - TrivialExists. constructor; eauto. constructor. EvalOp. simpl; eauto. constructor. constructor. Qed.Theorem eval_shrlimm: forall n, unary_constructor_sound (fun e => shrlimm e n) (fun v => Val.shrl v (Vint n)). Proof. intros; unfold shrlimm. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shrlimm; auto. red; intros. predSpec Int.eq Int.eq_spec n Int.zero. exists x; split; auto. subst n; destruct x; simpl; auto. destruct (Int.ltu Int.zero Int64.iwordsize'); auto. change (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero). rewrite Int64.shr_zero; auto. destruct (Int.ltu n Int64.iwordsize') eqn:LT; simpl. assert (DEFAULT: exists v, eval_expr ge sp e m le (Eop (Oshrlimm n) (a:::Enil)) v /\ Val.lessdef (Val.shrl x (Vint n)) v) by TrivialExists. destruct (shrlimm_match a); InvEval. - TrivialExists. simpl; rewrite LT; auto. - destruct (Int.ltu (Int.add n n1) Int64.iwordsize') eqn:LT'; auto. subst. econstructor; split. EvalOp. simpl; eauto. destruct v1; simpl; auto. rewrite LT'. destruct (Int.ltu n1 Int64.iwordsize') eqn:LT1; auto. simpl; rewrite LT. rewrite Int.add_commut, Int64.shr'_shr'; auto. rewrite Int.add_commut; auto. - apply DEFAULT. - TrivialExists. constructor; eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Theorem eval_shll: binary_constructor_sound shll Val.shll. Proof. unfold shll. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shll; auto. red; intros. destruct (is_intconst b) as [n2|] eqn:C. - exploit is_intconst_sound; eauto. intros EQ; subst y. apply eval_shllimm; auto. - TrivialExists. Qed.Theorem eval_shrlu: binary_constructor_sound shrlu Val.shrlu. Proof. unfold shrlu. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shrlu; auto. red; intros. destruct (is_intconst b) as [n2|] eqn:C. - exploit is_intconst_sound; eauto. intros EQ; subst y. apply eval_shrluimm; auto. - TrivialExists. Qed.Theorem eval_shrl: binary_constructor_sound shrl Val.shrl. Proof. unfold shrl. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_shrl; auto. red; intros. destruct (is_intconst b) as [n2|] eqn:C. - exploit is_intconst_sound; eauto. intros EQ; subst y. apply eval_shrlimm; auto. - TrivialExists. Qed.Theorem eval_negl: unary_constructor_sound negl Val.negl. Proof. unfold negl. destruct Archi.splitlong eqn:SL. apply SplitLongproof.eval_negl; auto. red; intros. destruct (is_longconst a) as [n|] eqn:C. - exploit is_longconst_sound; eauto. intros EQ; subst x. econstructor; split. apply eval_longconst. auto. - TrivialExists. Qed.Theorem eval_addlimm: forall n, unary_constructor_sound (addlimm n) (fun v => Val.addl v (Vlong n)). Proof. unfold addlimm. red; intros. predSpec Int64.eq Int64.eq_spec n Int64.zero. exists x. split; auto. rewrite H0. destruct x; auto. simpl. rewrite Int64.add_zero. constructor. destruct (addlimm_match a). - econstructor; split. apply eval_longconst. simpl. InvEval. unfold Val.rolml. auto. - InvEval. TrivialExists. simpl. rewrite <- H. rewrite Val.addl_assoc. reflexivity. - InvEval. TrivialExists. Qed. Theorem eval_addl: binary_constructor_sound addl Val.addl. 
Require Export Arith Lia List. Require Export Wellfounded. Require Export parsing. Theorem parse_rel_fun : forall l l1 t1, parse_rel l l1 t1 -> forall l2 t2, parse_rel l l2 t2 -> l1 = l2. 
(mag y) as (ey, Hey). simpl. intro H. destruct Hex as (_,Hex); [now apply Rgt_not_eq|]. destruct Hey as (Hey,_); [now apply Rgt_not_eq|]. rewrite Rabs_right in Hex; [|now apply Rle_ge; apply Rlt_le]. rewrite Rabs_right in Hey; [|now apply Rle_ge; apply Rlt_le]. apply (Rlt_le_trans _ _ _ Hex). apply Rle_trans with (bpow (ey - 1)); [|exact Hey]. now apply bpow_le; lia. Qed.Theorem mag_bpow : forall e, (mag (bpow e) = e + 1 :> Z)%Z. Proof. intros e. apply mag_unique. rewrite Rabs_right. replace (e + 1 - 1)%Z with e by ring. split. apply Rle_refl. apply bpow_lt. apply Zlt_succ. apply Rle_ge. apply bpow_ge_0. Qed.Theorem mag_mult_bpow : forall x e, x <> 0%R -> (mag (x * bpow e) = mag x + e :>Z)%Z. Proof. intros x e Zx. destruct (mag x) as (ex, Ex) ; simpl. specialize (Ex Zx). apply mag_unique. rewrite Rabs_mult. rewrite (Rabs_pos_eq (bpow e)) by apply bpow_ge_0. split. replace (ex + e - 1)%Z with (ex - 1 + e)%Z by ring. rewrite bpow_plus. apply Rmult_le_compat_r. apply bpow_ge_0. apply Ex. rewrite bpow_plus. apply Rmult_lt_compat_r. apply bpow_gt_0. apply Ex. Qed.Theorem mag_le_bpow : forall x e, x <> 0%R -> (Rabs x < bpow e)%R -> (mag x <= e)%Z. Proof. intros x e Zx Hx. destruct (mag x) as (ex, Ex) ; simpl. specialize (Ex Zx). apply bpow_lt_bpow. now apply Rle_lt_trans with (Rabs x). Qed.Theorem mag_gt_bpow : forall x e, (bpow e <= Rabs x)%R -> (e < mag x)%Z. Proof. intros x e Hx. destruct (mag x) as (ex, Ex) ; simpl. apply lt_bpow. apply Rle_lt_trans with (1 := Hx). apply Ex. intros Zx. apply Rle_not_lt with (1 := Hx). rewrite Zx, Rabs_R0. apply bpow_gt_0. Qed.Theorem mag_ge_bpow : forall x e, (bpow (e - 1) <= Rabs x)%R -> (e <= mag x)%Z. Proof. intros x e H. destruct (Rlt_or_le (Rabs x) (bpow e)) as [Hxe|Hxe]. - assert (mag x = e :> Z) as Hln. now apply mag_unique; split. rewrite Hln. now apply Z.le_refl. - apply Zlt_le_weak. now apply mag_gt_bpow. Qed.Theorem bpow_mag_gt : forall x, (Rabs x < bpow (mag x))%R. Proof. intros x. destruct (Req_dec x 0) as [Zx|Zx]. rewrite Zx, Rabs_R0. apply bpow_gt_0. destruct (mag x) as (ex, Ex) ; simpl. now apply Ex. Qed.Theorem bpow_mag_le : forall x, (x <> 0)%R -> (bpow (mag x-1) <= Rabs x)%R. Proof. intros x Hx. destruct (mag x) as (ex, Ex) ; simpl. now apply Ex. Qed. Theorem mag_le_Zpower : forall m e, m <> Z0 -> (Z.abs m < Zpower r e)%Z-> (mag (IZR m) <= e)%Z. 
(MNam b) -> h M (MNam b). intros. inversion H. trivial. Qed. Lemma h_incl_syn : forall h : hedge, inclusion h (synthesis h). unfold inclusion in |- *. intros. apply SynInc. trivial. Qed. Definition le_h (g h : hedge) := inclusion (synthesis g) (synthesis h). Definition equiv_h (g h : hedge) := le_h g h /\ le_h h g. Lemma le_h_refl : forall h : hedge, le_h h h. unfold le_h in |- *. intro. apply inclusion_refl. Qed. Lemma le_h_trans : forall f g h : hedge, le_h f g -> le_h g h -> le_h f h. unfold le_h in |- *. intros. apply inclusion_trans with (synthesis g); trivial. Qed. Lemma le_h_antisym : forall g h : hedge, le_h g h -> le_h h g -> equiv_h g h. unfold equiv_h in |- *. tauto. Qed. Lemma equiv_refl : forall h : hedge, equiv_h h h. unfold equiv_h in |- *. intro. split; apply le_h_refl. Qed. Lemma equiv_h_trans : forall f g h : hedge, equiv_h f g -> equiv_h g h -> equiv_h f h. unfold equiv_h in |- *. intros. elim H. elim H0. intros. split; apply le_h_trans with g; trivial. Qed. Lemma equiv_h_sym : forall g h : hedge, equiv_h g h -> equiv_h h g. unfold equiv_h in |- *. tauto. Qed. Lemma le_h_impl_incl_syn : forall g h : hedge, le_h g h -> inclusion g (synthesis h). unfold le_h in |- *. intros. apply inclusion_trans with (synthesis g); trivial. apply h_incl_syn. Qed. Lemma incl_syn_impl_le_h : forall g h : hedge, inclusion g (synthesis h) -> le_h g h. unfold le_h in |- *. unfold inclusion in |- *. intros. induction H0 as [M N H0| M N K L H0_1 HrecH0_1 H0_0 HrecH0_0| M1 N1 M2 N2 H0_1 HrecH0_1 H0_0 HrecH0_0| o M N H0 HrecH0]. apply H; trivial. apply SynEnc; trivial. apply SynPair; trivial. apply SynOp; trivial. Qed. Theorem le_h_iff_incl_syn : forall g h : hedge, le_h g h <-> inclusion g (synthesis h). split. apply le_h_impl_incl_syn. apply incl_syn_impl_le_h. Qed. Theorem inclusion_impl_le_h : forall g h : hedge, inclusion g h -> le_h g h. intros. apply incl_syn_impl_le_h. apply inclusion_trans with h; trivial. apply h_incl_syn. Qed. Lemma equal_impl_equiv_h : forall g h : hedge, equal g h -> equiv_h g h. unfold equal in |- *. unfold equiv_h in |- *. intros. elim H. intros. split. apply inclusion_impl_le_h; trivial. apply inclusion_impl_le_h; trivial. Qed. Theorem le_h_le_h_impl_union_le_h : forall f g h : hedge, le_h f h -> le_h g h -> le_h (union f g) h. 
H'13 H'12 E ] | idtac | idtac | idtac ] | idtac ]; auto. apply redIn2 with (c := c); auto. simpl in |- *; auto. apply redInInclQ with (Q := genOCPf l); auto. apply redInclP with (P := l); auto. apply H'; auto. apply incl_tran with (m := a :: l); simpl in |- *; auto. apply redIn2 with (c := c); auto. simpl in |- *; auto. apply redIn1; auto. apply red_incl with (p := addEnd A A0 eqA n ltM a l) (1 := cs); auto. apply addEnd_incl; auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. elim H'1; [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; auto. case (zerop_dec A A0 eqA n ltM a); intros Z; auto. apply redIn1; auto. apply zerop_red_spoly_l; auto. case (zerop_dec A A0 eqA n ltM b); intros Z1; auto. apply redIn1; auto. apply zerop_red_spoly_r; auto. lapply (spolyp_addEnd_genPcPf l); [ intros H'4; elim (H'4 (genOCPf l) a b); [ intros c E; elim E; intros H'11 H'12; elim H'12; intros H'13 H'14; elim H'13; [ intros H'15; clear H'13 H'12 E | intros H'15; clear H'13 H'12 E ] | idtac | idtac | idtac ] | idtac ]; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redInInclQ with (Q := genOCPf l); auto. apply redInclP with (P := l); auto. apply H'; auto. apply incl_tran with (m := a :: l); simpl in |- *; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redIn1; auto. apply red_incl with (1 := cs) (p := addEnd A A0 eqA n ltM a l); auto. apply addEnd_incl; auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. Qed. Theorem OBuch_Stable_f : forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> stable P Q. intros P Q H'; try assumption. apply OBuch_Stable with (Q := genOCPf P); auto. intros a H'0; try assumption. apply genOCPf_stable; auto. Qed. Theorem OBuch_Inv_f : forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> forall a b : poly A0 eqA ltM, In a Q -> In b Q -> reds a b Q. 
(m : BaseModuleWf type) n : TraceInclusion (inlineSingle_Meths_pos_BaseModuleWf m n) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineSingle_pos_Meths_l P2 n) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineSingle_pos_Meths_Wf_l_new (m : BaseModuleWf_new type) n : TraceInclusion (inlineSingle_Meths_pos_BaseModuleWf_new m n) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineSingle_pos_Meths_Wf_l m'). Qed. Lemma TraceInclusion_inlineAll_pos_Meths_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> (WfMod type (Base (BaseMod regs rules (inlineAll_Meths meths)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineAll_Meths meths))) (Base (BaseMod regs rules meths)). Proof. intros WfH. unfold inlineAll_Meths. induction (Datatypes.length meths); [simpl; split; [assumption | apply TraceInclusion_refl]|]. rewrite seq_eq. rewrite fold_left_app; simpl. destruct IHn as [IHn1 IHn2]. pose proof (TraceInclusion_inlineSingle_pos_Meths_l IHn1 n) as [sth1 sth2]. destruct n; simpl in *; auto. split; auto. eapply TraceInclusion_trans; eauto. Qed. Theorem TraceInclusion_inlineAll_pos_Meths_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> (WfMod_new type (Base (BaseMod regs rules (inlineAll_Meths meths)))) /\ TraceInclusion (Base (BaseMod regs rules (inlineAll_Meths meths))) (Base (BaseMod regs rules meths)). Proof. repeat rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inlineAll_pos_Meths_l. Qed. Lemma TraceInclusion_inlineAll_pos_Meths_Wf_l (m : BaseModuleWf type) : TraceInclusion (inlineAll_Meths_BaseModuleWf m) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineAll_pos_Meths_l P2) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Meths_Wf_l_new (m : BaseModuleWf_new type) : TraceInclusion (inlineAll_Meths_BaseModuleWf_new m) m. Proof. destruct m. pose (Build_BaseModuleWf (WfBaseModule_new_WfBaseModule wfBaseModule_new)) as m'. apply (@TraceInclusion_inlineAll_pos_Meths_Wf_l m'). Qed. Lemma TraceInclusion_inlineAll_pos_l regs rules meths: (WfMod type (Base (BaseMod regs rules meths))) -> (WfMod type (Base (inlineAll_All regs rules meths))) /\ TraceInclusion (Base (inlineAll_All regs rules meths)) (Base (BaseMod regs rules meths)). Proof. unfold inlineAll_All in *. intros WfH1. pose proof (TraceInclusion_inlineAll_pos_Meths_l WfH1) as [WfH2 P2]. pose proof (TraceInclusion_inlineAll_pos_Rules_l WfH2) as [WfH3 P3]. split; auto. eapply TraceInclusion_trans; eauto. Qed. Theorem TraceInclusion_inlineAll_pos_l_new regs rules meths: (WfMod_new type (Base (BaseMod regs rules meths))) -> (WfMod_new type (Base (inlineAll_All regs rules meths))) /\ TraceInclusion (Base (inlineAll_All regs rules meths)) (Base (BaseMod regs rules meths)). Proof. repeat rewrite WfMod_new_WfMod_iff. apply TraceInclusion_inlineAll_pos_l. Qed. Lemma TraceInclusion_inlineAll_pos_Wf_l (m : BaseModuleWf type) : TraceInclusion (inlineAll_All_BaseModuleWf m) m. Proof. specialize (TraceInclusion_flatten_l m) as P1. specialize (wfMod (flatten_ModWf m)) as P2. simpl in *; unfold flatten, getFlat in *; simpl in *. specialize (TraceInclusion_inlineAll_pos_l P2) as TMP; dest. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_inlineAll_pos_Wf_l_new (m : BaseModuleWf_new type) : TraceInclusion (inlineAll_All_BaseModuleWf_new m) m. 
Require Import Classical.Require Import Ensembles. Require Import Relations_1. Require Import Relations_1_facts. Require Import podefs. Require Import podefs_1.Section The_power_set_partial_order. Variable U : Type. Inductive Power_set (A : Ensemble U) : Ensemble (Ensemble U) := Definition_of_Power_set : forall X : Ensemble U, Included U X A -> In (Ensemble U) (Power_set A) X. Hint Resolve Definition_of_Power_set. Variable A : Ensemble U. Theorem Empty_set_minimal : forall X : Ensemble U, Included U (Empty_set U) X. Proof. red in |- *; intros X x H'; elim H'. Qed. Hint Resolve Empty_set_minimal. Theorem Power_set_non_empty : forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A). Proof. intro A'; apply Non_empty_intro with (Empty_set U); auto. Qed. Hint Resolve Power_set_non_empty. Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U). Proof. auto 8. Qed. Hint Resolve Inclusion_is_an_order. Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U). elim Inclusion_is_an_order; auto. Qed. Hint Resolve Inclusion_is_transitive. Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U). 
(fun k => ~~ p k) s). Proof. by move=> WF_s; rewrite -partition_fst -partition_snd //; case: (partition p s). Qed.Theorem split_splitMember (x : Word) (s : IntSet) : WF s -> let: (l,m,r) := splitMember x s in split x s = (l, r) /\ member x s = m. Proof. move=> [fs Sem_s]. apply splitMember_Sem with fs => //= l fl r fr m' Sem_l Sem_r <-{m'} def_fl def_fr. split. - apply split_Sem with fs => //= l' fl' r' fr' Sem_l' Sem_r' def_fl' def_fr'. f_equal; eauto using Sem_unique. - by apply member_Sem. Qed. Theorem split_splitMember' (x : Word) (s : IntSet) : WF s -> split x s = ((splitMember x s).1.1, (splitMember x s).2) /\ member x s = (splitMember x s).1.2. Proof. by move=> /(split_splitMember x); case: (splitMember x s) => [[? ?] ?]. Qed.Theorem splitMember_split (x : Word) (s : IntSet) : WF s -> let: (l,r) := split x s in splitMember x s = (l, member x s, r). Proof. by move=> /(split_splitMember x); case: (splitMember x s) => [[? ?] ?] [-> ->]. Qed.Theorem splitMember_split' (x : Word) (s : IntSet) : WF s -> splitMember x s = ((split x s).1, member x s, (split x s).2). Proof. by move=> /(splitMember_split x); case: (split x s) => [? ?]. Qed.Theorem split_filter (x : Word) (s : IntSet) : WF s -> split x s = (filter (fun y => y < x) s, filter (fun y => y > x) s). Proof. move=> [fs Sem_s]. apply split_Sem with fs => //= l fl r fr Sem_l Sem_r def_fl def_fr. f_equal; eauto using Sem_unique, filter_Sem. Qed.Theorem splitMember_filter (x : Word) (s : IntSet) : WF s -> splitMember x s = (filter (fun y => y < x) s, member x s, filter (fun y => y > x) s). Proof. by move=> WFs; move: (WFs) (WFs) => /(splitMember_split' x) -> /(split_filter x) ->. Qed. Theorem Sem_Desc0 : forall s f, Sem s f -> exists r, Desc0 s r f. Proof. apply Sem_ind => [f false_f | s r f Desc_srf]. - by exists (0%N,0%N); apply Desc0Nil. - by exists r; apply (Desc0NotNil s r f r f); rewrite // isSubrange_refl. Qed.Theorem Sem_member (s : IntSet) : WF s -> Sem s (member ^~ s). Proof. move=> [f def_f]. apply Sem_change_f with f => //. by move: (def_f) => /member_Sem. Qed. Theorem Nil_member : forall k, member k Nil = false. 
with | inl s => let (k, _) := s in Z_of_nat k | inr s => let (k, _) := s in Z.opp (Z_of_nat k) end.Lemma double_eq_half_eq:forall m n, Div2.double m = Div2.double n -> m =n. Proof. unfold Div2.double; intros m n; omega. Defined.Lemma parity_mismatch_not_eq:forall m n, Even.even m -> Even.odd n -> ~m=n. Proof. intros m n H_even H_odd H_eq; subst m; apply (Even.not_even_and_odd n); trivial. Defined.Lemma even_double:forall n, Even.even (Div2.double n). Proof. intro n; unfold Div2.double; replace (n + n) with (2*n); auto with arith; omega. Defined.Lemma double_S_neq_pred:forall m n, ~Div2.double (S m) = pred (Div2.double n). Proof. intros m [|n]. unfold Div2.double; omega. apply (parity_mismatch_not_eq (Div2.double (S m)) (pred (Div2.double (S n)))); try apply even_double; replace (pred (Div2.double (S n))) with (S (Div2.double n)); [ constructor; apply even_double | unfold Div2.double; omega]. Defined.Lemma eq_add_pred : forall n m : nat, pred n = pred m -> {n = m} + {n<2/\m<2}. Proof. intros [|[|n]] m; simpl; intros H; try (right; omega); left; rewrite (f_equal S H); symmetry; apply S_pred with 0; omega. Defined.Lemma nat_to_Z_to_nat_i : forall (z:Z), nat_to_Z_i (Z_to_nat_i z) = z. Proof. intros [|p|p]; unfold nat_to_Z_i. simpl; case (even_odd_exists_dec 0); intros [k Hk]; [transitivity (Z_of_nat 0) |transitivity (Z.opp (Z_of_nat 0)) ]; trivial; try apply (f_equal Z.opp); apply (f_equal Z_of_nat); unfold Div2.double in Hk; omega. case (even_odd_exists_dec (Z_to_nat_i (Zpos p)) ); intros [k Hk]. unfold Z_to_nat_i in Hk; rewrite <- (double_eq_half_eq _ _ Hk); symmetry; apply Zpos_eq_Z_of_nat_o_nat_of_P. apply False_ind; unfold Z_to_nat_i in Hk; destruct (ZL4 p) as [m Hm]; rewrite Hm in Hk; apply (double_S_neq_pred m k); assumption. case (even_odd_exists_dec (Z_to_nat_i (Zneg p)) ); intros [k Hk]. unfold Z_to_nat_i in Hk; unfold Div2.double in Hk; destruct (ZL4 p) as [m Hm]; omega. unfold Z_to_nat_i in Hk; case (eq_add_pred _ _ Hk). intro Hk'; rewrite <- (double_eq_half_eq _ _ Hk'); symmetry; apply Z.opp_inj; rewrite Zopp_neg; rewrite Z.opp_involutive; apply Zpos_eq_Z_of_nat_o_nat_of_P. intros [H_nat_p_lt_2 _]; apply False_ind; destruct (ZL4 p) as [m Hm]; rewrite Hm in H_nat_p_lt_2; rewrite Div2.double_S in H_nat_p_lt_2; omega. Defined.Lemma Z_to_nat_to_Z_i : forall (n:nat), Z_to_nat_i (nat_to_Z_i n) = n. Proof. intros [|n]; unfold nat_to_Z_i. case (even_odd_exists_dec 0); intros [k Hk]; transitivity (Z_to_nat_i (Z_of_nat 0)); trivial; apply (f_equal Z_to_nat_i); simpl; unfold Div2.double in Hk; omega. case (even_odd_exists_dec (S n)); intros [[|k] Hk]; rewrite Hk; trivial; simpl; [apply (f_equal Div2.double); apply nat_of_P_o_P_of_succ_nat_eq_succ |transitivity (pred (Div2.double (S k))); trivial; apply (f_equal pred); apply (f_equal Div2.double); apply nat_of_P_o_P_of_succ_nat_eq_succ ]. Defined. Theorem Z_is_denumerable:is_denumerable Z. 
hasInputDups init')). { fcf_skip_eq. simplify. eapply comp_spec_eq_trans_r. + destruct b0. eapply simplify_hasDups. + destruct b0. eapply rb_oracle_state_same_after_i. lia. } clear n n0 IHlistLen'. apply Gi_rb_collisions_inner_eq_general_i_eq0; auto. } { assert (i_neq_0 : i <> 0) by lia. apply beq_nat_false_iff in i_neq_0. rewrite i_neq_0. pose proof (beq_nat_refl i) as i_refl. rewrite <- i_refl. clear i_neq_0 i_refl. eapply comp_spec_eq_trans_r. 2:{ unfold compMap_v_init. eapply (compMap_v_eq_init_list_placeholder v v_prev); auto. } simpl. eapply comp_spec_eq_trans_r. clear n n0 IHlistLen'. instantiate (1 := (a <-$ (Generate_v_oc (k, v) blocks) (list (Blist * Bvector eta)) (list_EqDec (pair_EqDec eqdbl (Bvector_EqDec eta))) rb_oracle init; [_, init'] <-2 a; ret hasInputDups init')). { fcf_skip_eq. destruct b0. + eapply comp_spec_eq_trans_r. instantiate(1:= (a0 <-$ (oracleCompMap_inner (pair_EqDec (list_EqDec (list_EqDec (Bvector_EqDec eta))) (pair_EqDec nat_EqDec eqDecState)) (list_EqDec (list_EqDec (Bvector_EqDec eta))) (Oi_oc' i) (S i, (b0, b1)) (replicate listLen' blocks)) (list (Blist * Bvector eta)) (list_EqDec (pair_EqDec eqdbl (Bvector_EqDec eta))) rb_oracle b; [_, rb_state2]<-2 a0; ret hasInputDups rb_state2)). simplify. apply simplify_hasDups. eapply rb_oracle_state_same_after_i. lia. } clear n n0 IHlistLen'. apply Gi_rb_collisions_inner_eq_general_i_neq0. auto. } Qed.Lemma Gi_rb_bad_eq_2' : forall (i : nat) (v : Bvector eta), Pr [Gi_rb_bad_no_adv i] == Pr[case_on_i i numCalls blocksPerCall v]. Proof. intros i v. fcf_to_prhl_eq. unfold Gi_rb_bad_no_adv. simplify. fcf_irr_l. wfi. simplify. eapply comp_spec_eq_trans_r. instantiate (1 := (a <-$ (oracleCompMap_inner (pair_EqDec (list_EqDec (list_EqDec (Bvector_EqDec eta))) (pair_EqDec nat_EqDec eqDecState)) (list_EqDec (list_EqDec (Bvector_EqDec eta))) (Oi_oc' i) (0%nat, (b, b0)) requestList) (list (Blist * Bvector eta)) (list_EqDec (pair_EqDec eqdbl (Bvector_EqDec eta))) rb_oracle nil; [_, state] <-2 a; ret hasInputDups state)). { prog_equiv. fcf_spec_ret. } eapply comp_spec_eq_trans_r. eapply split_out_oracle_call_forall; auto. lia. { constructor. } { intros. Transparent map. simpl. constructor; intros; contradiction. Opaque map. } instantiate (1 := v). unfold case_on_i_gen. unfold case_on_i. unfold hasInputDups. Transparent hasDups. simpl. Opaque hasDups. rewrite plus_comm. simpl. Opaque map. assert (hasDups_map_equiv : forall a, hasDups eqdbl (map (to_list (n:=eta)) (v :: a) ++ map (fst (B:=Bvector eta)) nil) = hasDups (Bvector_EqDec eta) (v :: a)). { intros. rewrite app_nil_r. pose proof hasDups_inj_equiv as hasDups_inj. specialize (hasDups_inj _ _ _ _ (v :: a) (to_list (n := eta))). rewrite hasDups_inj. reflexivity. apply to_list_injective. } destruct (ge_dec i numCalls); destruct (zerop i); try fcf_spec_ret; unfold compMap_v; prog_equiv; fcf_spec_ret. Qed. Theorem hasDups_cons_orb : forall (A : Set)(eqd : EqDec A)(ls : list A)(a : A), hasDups _ (a :: ls) = (if (in_dec (EqDec_dec _) a ls) then true else false) || hasDups _ ls. intuition. Transparent hasDups. simpl. destruct (in_dec (EqDec_dec eqd) a ls); intuition. Qed. Theorem compMap_hasDups_cons_orb : forall (A : Set)(ls : list A) x, Pr[lb <-$ compMap _ (fun _ => {0,1}^eta) ls; ret hasDups _ (x :: lb)] == Pr[lb <-$ compMap _ (fun _ => {0,1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lb) then true else false) || hasDups _ lb]. 
F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] * [[[ items ::: Fe * ix |-> e ]]] POST:hm' RET:^(ms', r) LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' * [[ r = e ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSAllocC ms' = MSAllocC ms]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms') sm hm' >} get_array lxp ixp inum ix ms. Proof. unfold get_array. hoare. eapply list2nmem_ptsto_bound; eauto. subst; apply eq_sym. eapply list2nmem_sel; eauto. Qed. Theorem put_array_ok : forall lxp ixp bxp inum ix e ms, {< F Fm Fi Fe m0 sm m flist f items e0 ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[ Rec.well_formed e ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] * [[[ items ::: Fe * ix |-> e0 ]]] POST:hm' RET:ms' exists m' flist' f' items', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * [[[ m' ::: (Fm * BFILE.rep bxp sm ixp flist' ilist frees (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[[ flist' ::: (Fi * inum |-> f') ]]] * [[[ RAData f' ::: rep f' items' ]]] * [[[ items' ::: Fe * ix |-> e ]]] * [[ items' = updN items ix e ]] * [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * [[ MSAllocC ms' = MSAllocC ms ]] * [[ MSDBlocks ms' = MSDBlocks ms ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} put_array lxp ixp inum ix e ms. Proof. unfold put_array. hoare. eapply list2nmem_ptsto_bound; eauto. eapply list2nmem_updN; eauto. Qed. Theorem extend_array_ok : forall lxp bxp ixp inum e ms, {< F Fm Fi Fe m0 sm m flist f items ilist frees, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) (MSLL ms) sm hm * [[ Rec.well_formed e ]] * [[[ m ::: (Fm * BFILE.rep bxp sm ixp flist ilist frees (MSAllocC ms) (MSCache ms) (MSICache ms) (MSDBlocks ms)) ]]] * [[[ flist ::: (Fi * inum |-> f) ]]] * [[[ RAData f ::: rep f items ]]] * [[[ items ::: Fe ]]] POST:hm' RET:^(ms', r) exists m', [[ MSAlloc ms' = MSAlloc ms ]] * [[ MSCache ms' = MSCache ms ]] * [[ MSIAllocC ms' = MSIAllocC ms ]] * ([[ isError r ]] * LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' \/ [[ r = OK tt ]] * exists flist' f' items' ilist' frees', LOG.rep lxp F (LOG.ActiveTxn m0 m') (MSLL ms') sm hm' * [[[ m' ::: (Fm * BFILE.rep bxp sm ixp flist' ilist' frees' (MSAllocC ms') (MSCache ms') (MSICache ms') (MSDBlocks ms')) ]]] * [[[ flist' ::: (Fi * inum |-> f') ]]] * [[[ RAData f' ::: rep f' items' ]]] * [[[ items' ::: Fe * (length items) |-> e * arrayN (@ptsto _ addr_eq_dec _) (length items + 1) (repeat item0 (items_per_val - 1)) ]]] * [[ items' = items ++ (updN block0 0 e) ]] * [[ BFILE.ilist_safe ilist (BFILE.pick_balloc frees (MSAlloc ms')) ilist' (BFILE.pick_balloc frees' (MSAlloc ms')) ]] * [[ BFILE.treeseq_ilist_safe inum ilist ilist' ]] ) CRASH:hm' LOG.intact lxp F m0 sm hm' >} extend_array lxp bxp ixp inum e ms. 
Require Import Coq.Strings.String. Require Import Coq.Lists.List. Require Import Coq.Classes.Morphisms. Require Import ChargeCore.Logics.ILogic. Require Import ChargeCore.Tactics.Tactics.Section indexed. Context {L : Type} {ILO : ILogicOps L} {IL : ILogic L}. Theorem destruct_top : forall A B C D : L, A |-- B -->> C -->> D -> A |-- B //\\ C -->> D. Proof. intros. rewrite H. charge_tauto. Qed. Theorem split_top : forall A B C D : L, A |-- B -->> D -> A |-- C -->> D -> A |-- B \\// C -->> D. Proof. intros. charge_intros. charge_cases. - charge_apply H; charge_tauto. - charge_apply H0; charge_tauto. Qed. Theorem move_top : forall A B C D : L, A //\\ C |-- B -->> D -> (A //\\ B) //\\ C |-- D. Proof. intros. charge_apply H. charge_tauto. Qed. Theorem copy_top : forall A B C : L, A |-- B -->> B -->> C -> A |-- B -->> C. 
x n) | E_Seq : forall c1 c2 st st' st'', c1 / st \\ st' -> c2 / st' \\ st'' -> (c1 ;; c2) / st \\ st'' | E_IfTrue : forall st st' b c1 c2, beval st b = true -> c1 / st \\ st' -> (IFB b THEN c1 ELSE c2 FI) / st \\ st' | E_IfFalse : forall st st' b c1 c2, beval st b = false -> c2 / st \\ st' -> (IFB b THEN c1 ELSE c2 FI) / st \\ st' | E_WhileFalse : forall b st c, beval st b = false -> (WHILE b DO c END) / st \\ st | E_WhileTrue : forall st st' st'' b c, beval st b = true -> c / st \\ st' -> (WHILE b DO c END) / st' \\ st'' -> (WHILE b DO c END) / st \\ st'' where "c1 '/' st '\\' st'" := (ceval c1 st st').Example ceval_example1: (X ::= ANum 2;; IFB BLe (AId X) (ANum 1) THEN Y ::= ANum 3 ELSE Z ::= ANum 4 FI) / empty_state \\ (t_update (t_update empty_state X 2) Z 4). Proof. apply E_Seq with (t_update empty_state X 2). - apply E_Ass. reflexivity. - apply E_IfFalse. reflexivity. apply E_Ass. reflexivity. Qed. Example ceval_example2: (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state \\ (t_update (t_update (t_update empty_state X 0) Y 1) Z 2). Proof. Admitted.Definition pup_to_n : com . Admitted.Theorem pup_to_2_ceval : pup_to_n / (t_update empty_state X 2) \\ t_update (t_update (t_update (t_update (t_update (t_update empty_state X 2) Y 0) Y 2) X 1) Y 3) X 0. Proof. Admitted.Theorem ceval_deterministic: forall c st st1 st2, c / st \\ st1 -> c / st \\ st2 -> st1 = st2. Proof. intros c st st1 st2 E1 E2. generalize dependent st2. induction E1; intros st2 E2; inversion E2; subst. - reflexivity. - reflexivity. - assert (st' = st'0) as EQ1. { apply IHE1_1; assumption. } subst st'0. apply IHE1_2. assumption. - apply IHE1. assumption. - rewrite H in H5. inversion H5. - rewrite H in H5. inversion H5. - apply IHE1. assumption. - reflexivity. - rewrite H in H2. inversion H2. - rewrite H in H4. inversion H4. - assert (st' = st'0) as EQ1. { apply IHE1_1; assumption. } subst st'0. apply IHE1_2. assumption. Qed. Theorem plus2_spec : forall st n st', st X = n -> plus2 / st \\ st' -> st' X = n + 2. 
Require Import VerdiRaft.Raft. Require Import VerdiRaft.CommonTheorems.Require Import VerdiRaft.SpecLemmas.Require Import VerdiRaft.TermSanityInterface. Require Import VerdiRaft.SortedInterface.Section SortedProof. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {tsi : term_sanity_interface}. Theorem logs_sorted_init : raft_net_invariant_init logs_sorted. Proof using. unfold raft_net_invariant_init, logs_sorted, logs_sorted_host, logs_sorted_nw, packets_gt_prevIndex, packets_ge_prevTerm in *. intuition; simpl in *; intuition. Qed. Theorem handleClientRequest_packets : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> ps = []. Proof using. intros. find_apply_lem_hyp handleClientRequest_log. intuition. Qed. Theorem logs_sorted_nw_packets_unchanged : forall net ps' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_packets_unchanged : forall net ps' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_gt_prevIndex (mkNetwork ps' st'). 
word l | ArrayF t' _ => list (data t') | RecF rt => (fix recdata (t : list (string * type)) : Type := match t with | [] => unit | (_, ft) :: t' => data ft * recdata t' end%type) rt end. Definition recdata ft := data (RecF ft). Fixpoint len (t : type) : nat := match t with | WordF l => l | ArrayF t' l => l * len t' | RecF rt => (fix reclen (t : rectype) : nat := match t with | [] => 0 | (_, ft) :: t' => len ft + reclen t' end) rt end. Fixpoint well_formed {t : type} : data t -> Prop := match t as t return (data t -> Prop) with | WordF _ => fun _ => True | ArrayF _ l => fun v => Datatypes.length v = l /\ Forall well_formed v | RecF rt => (fix well_formed' {rt : rectype} : data (RecF rt) -> Prop := match rt as rt return (data (RecF rt) -> Prop) with | [] => fun _ => True | (_, ft) :: t' => fun r => let (r0, r') := r in well_formed r0 /\ well_formed' r' end) rt end. Theorem firstn_well_formed : forall (ft:type) n1 n2 w, @well_formed (ArrayF ft (n1+n2)) w -> @well_formed (ArrayF ft n1) (firstn n1 w). Proof. intros. unfold well_formed in *. inversion H. split. rewrite firstn_length_l; omega. rewrite Forall_forall; intros. apply in_firstn_in in H2. rewrite Forall_forall in H1. apply H1. assumption. Qed. Theorem firstn_l_well_formed : forall (ft:type) n n' w, n <= n' -> @well_formed (ArrayF ft n') w -> @well_formed (ArrayF ft n) (firstn n w). Proof. intros. unfold well_formed in *. inversion H0. split. rewrite firstn_length_l; omega. rewrite Forall_forall in *; intros. eapply H2. eapply in_firstn_in; eauto. Qed. Theorem skipn_well_formed : forall (ft:type) n1 n2 w, @well_formed (ArrayF ft (n1+n2)) w -> @well_formed (ArrayF ft n2) (skipn n1 w). Proof. intros. unfold well_formed in *. inversion H. split. rewrite skipn_length; omega. rewrite Forall_forall; intros. apply in_skipn_in in H2. rewrite Forall_forall in H1. apply H1. assumption. Qed. Theorem tl_well_formed : forall (ft:type) n d w, @well_formed (ArrayF ft (S n)) (d::w) -> @well_formed (ArrayF ft n) w. Proof. intros. unfold well_formed in *. inversion H. split. simpl in *. omega. rewrite Forall_forall in *; intros. apply H1. constructor; assumption. Qed. Theorem empty_well_formed : forall (ft:type) w, List.length w = 0 -> @well_formed (ArrayF ft 0) w. 
-> Fbounded b p. intros p H; case H; auto. Qed. Theorem FnormalBound : forall p : float, Fnormal p -> (Zpos (vNum b) <= Zabs (radix * Fnum p))%Z. intros p H; case H; auto. Qed. Hint Resolve FnormalBounded FnormalBound: float. Theorem FnormalNotZero : forall p : float, Fnormal p -> ~ is_Fzero p. unfold is_Fzero in |- *; intros p H; red in |- *; intros H1. case H; rewrite H1. replace (Zabs (radix * 0)) with 0%Z; auto with zarith. rewrite Zmult_comm; simpl in |- *; auto. Qed. Theorem FnormalFop : forall p : float, Fnormal p -> Fnormal (Fopp p). intros p H; split; auto with float. replace (Zabs (radix * Fnum (Fopp p))) with (Zabs (radix * Fnum p)); auto with float. case p; simpl in |- *; auto with zarith. intros Fnum1 Fexp1; rewrite <- Zopp_mult_distr_r; apply sym_equal; apply Zabs_Zopp. Qed. Theorem FnormalFabs : forall p : float, Fnormal p -> Fnormal (Fabs p). intros p; case p; intros a e H; split; auto with float. simpl in |- *; case H; intros H1 H2; simpl in |- *; auto. rewrite <- (Zabs_eq radix); auto with zarith. rewrite <- Zabs_Zmult. rewrite (fun x => Zabs_eq (Zabs x)); auto with float zarith. Qed. Definition pPred x := Zpred (Zpos x). Theorem maxMax1 : forall (p : float) (z : Z), Fbounded b p -> (Fexp p <= z)%Z -> (Fabs p <= Float (pPred (vNum b)) z)%R. intros p z H H0; unfold FtoRradix in |- *. rewrite <- (FshiftCorrect _ radixMoreThanOne (Zabs_nat (z - Fexp p)) (Float (pPred (vNum b)) z)). unfold FtoR, Fabs in |- *; simpl in |- *; auto with zarith. rewrite Rmult_IZR; rewrite Zpower_nat_Z_powerRZ; auto with zarith. repeat rewrite inj_abs; auto with zarith. replace (z - (z - Fexp p))%Z with (Fexp p); [ idtac | ring ]. rewrite Rmult_assoc; rewrite <- powerRZ_add; auto with real zarith. replace (z - Fexp p + Fexp p)%Z with z; [ idtac | ring ]. apply Rle_trans with (pPred (vNum b) * powerRZ radix (Fexp p))%R. apply Rle_monotone_exp; auto with zarith; repeat rewrite Rmult_IZR; apply Rle_IZR; unfold pPred in |- *; apply Zle_Zpred; auto with float real zarith. apply Rmult_le_compat_l; auto with real zarith. replace 0%R with (IZR 0); auto with real; apply Rle_IZR; unfold pPred in |- *; apply Zle_Zpred; auto with float zarith. apply Rle_powerRZ; auto with float real zarith. Qed. Theorem FnormalBoundAbs : forall p : float, Fnormal p -> (Float (pPred (vNum b)) (Zpred (Fexp p)) < Fabs p)%R. 
Import Bedrock.Platform.Cito.WordFacts. Theorem is_state_in'' : forall vs sp args e_stack h, locals ("rp" :: "extra_stack" :: args) vs e_stack sp * is_heap h ===> is_state sp (sel vs "rp") (wordToNat (sel vs "extra_stack")) e_stack args (vs, h) nil. Proof. intros; sepLemma. set (_ :: _ :: _). set (_ * _)%Sep. etransitivity. instantiate (1 := (h0 * [| NoDup l |])%Sep). subst h0 l. unfold locals. set (array _ _). sepLemma. subst h0 l. sepLemma. etransitivity. etransitivity. 2 : eapply is_state_in. sepLemma. change LinkMake.StubsMake.StubMake.LinkSpecMake2.CompileFuncSpecMake.InvMake2.is_state with is_state. unfold is_state, Inv.has_extra_stack, locals, array. sepLemma. inversion_clear H. inversion_clear H2. eauto. fold (@length W). rewrite mult_0_r. rewrite wplus_0. rewrite plus_0_r. rewrite length_toArray. sepLemma. Qed. Theorem is_state_in''' : forall vs sp args e_stack F, locals ("rp" :: "extra_stack" :: args) vs e_stack sp * mallocHeap 0 * F ===> is_state sp (sel vs "rp") (wordToNat (sel vs "extra_stack")) e_stack args (vs, heap_empty) nil * mallocHeap 0 * F. intros; sepLemma. etransitivity; [ | apply is_state_in'' ]; auto. sepLemma. Qed. Lemma toArray_map_length : forall A vs f ls1 ls2, toArray ls1 vs = @List.map A _ f ls2 -> length ls1 = length ls2. intros. eapply f_equal with (f := @length _) in H. rewrite length_toArray in *. rewrite map_length in *. eauto. Qed. Ltac clear_all := repeat match goal with | H : _ |- _ => clear H end. Theorem is_state_out''' : forall sp rp args pairs vs e_stack e_stack', NoDup args -> ~List.In "rp" args -> ~List.In "extra_stack" args -> toArray args vs = List.map fst pairs -> is_state sp rp e_stack e_stack' args (vs, make_heap pairs) nil ===> Ex vs', locals ("rp" :: "extra_stack" :: args) vs' e_stack' sp * is_heap (make_heap pairs) * [| sel vs' "extra_stack" = e_stack |] * [| saved_vars vs' args pairs |]. unfold Himp; intros. etransitivity. 2 : eapply is_state_out''; eauto. 2 : eapply toArray_map_length; eauto. change LinkSpecMake2.CompileFuncSpecMake.InvMake2.is_state with is_state. unfold is_state, locals, Inv.has_extra_stack; simpl. rewrite H2. rewrite mult_0_r. rewrite wplus_0. set (array (List.map _ _) _). set (is_heap _). rewrite map_length. replace (length args) with (length pairs). rewrite plus_0_r. clear_all. sepLemma. symmetry; eapply toArray_map_length; eauto. Grab Existential Variables. eauto. Qed. Lemma make_heap_heap_empty : forall ls, make_heap (List.map (fun w : W => (w, SCA _ w)) ls) = heap_empty. induction ls; simpl; intuition. Qed. Lemma map_id : forall A ls, List.map (fun x : A => x) ls = ls. induction ls; simpl; intuition. Qed. Theorem is_state_out'''' : forall vs sp rp F e_stack e_stack' args, NoDup args -> ~List.In "rp" args -> ~List.In "extra_stack" args -> (is_state sp rp e_stack e_stack' args (vs, heap_empty) nil * mallocHeap 0) * F ===> Ex vs', locals ("rp" :: "extra_stack" :: args) vs' e_stack' sp * [| sel vs' "extra_stack" = e_stack|] * mallocHeap 0 * F. 
by assumption. rewrite IHis_simple at 1. ra. rewrite cupxb. rewrite (@expand_01 e) at 1 by assumption. apply str_eps. Qed. Lemma epsilon_pure e: is_pure e -> epsilon e = false. Proof. induction 1; trivial. simpl. now rewrite IHis_pure1. simpl. rewrite IHis_pure. now case epsilon. Qed. Lemma epsilon_deriv_pure a e: is_pure e -> eps (deriv a e) ‚â° deriv a e. Proof. induction 1; simpl; fold_regex. reflexivity. rewrite <-expand_01. reflexivity. apply is_01_ofbool. rewrite orb_pls. now apply cup_weq. rewrite orb_pls, 2andb_dot, IHis_pure. rewrite deriv_01 by assumption. case (epsilon e); simpl; fold_regex; ra. Qed.Lemma expand_pure e A: is_pure e -> vars e ‚â¶ A -> e ‚â° \sum_(a \in A) var a ‚ã deriv a e . Proof. intros He HA. rewrite (expand' e HA) at 1. rewrite epsilon_pure by assumption. apply cupbx. Qed. Lemma deriv_sup a I J (f: I -> regex'): deriv a (\sup_(i\in J) f i) = \sup_(i\in J) deriv a (f i). Proof. apply f_sup_eq; now f_equal. Qed.Lemma epsilon_reflexive e: epsilon e -> 1 ‚â¶ e. Proof. intro H. rewrite (expand e), H. lattice. Qed.Definition lang e: lang' sigma := fun w => epsilon (derivs w e).#[export] Instance lang_leq: Proper (leq ==> leq) lang. Proof. intros e f H w. unfold lang. now rewrite H. Qed.#[export] Instance lang_weq: Proper (weq ==> weq) lang := op_leq_weq_1. Lemma epsilon_iff_reflexive_eps (e: regex'): epsilon e <-> 1 ‚â¶ eps e. Proof. case epsilon. intuition. intuition. discriminate. apply lang_leq in H. specialize (H [] eq_refl). discriminate. Qed. Notation elang e := (eval (f':=fun _=>lang_tt) (fun i => eq [i]) (to_expr e)). Lemma epsilon_iff_lang_nil e: epsilon e <-> (elang e) []. Proof. induction e; simpl. firstorder discriminate. firstorder. setoid_rewrite Bool.orb_true_iff. now apply cup_weq. setoid_rewrite Bool.andb_true_iff. setoid_rewrite lang_dot_nil. now apply cap_weq. split. now exists O. reflexivity. firstorder discriminate. Qed. Lemma eval_deriv a e: elang (deriv a e) ‚â° lang_deriv a (elang e). Proof. induction e; simpl deriv; simpl eval; fold_regex; fold_lang. - reflexivity. - now rewrite lang_deriv_1. - rewrite lang_deriv_pls. now apply cup_weq. - generalize (epsilon_iff_lang_nil e1). case epsilon; intro He1. setoid_rewrite dot1x. setoid_rewrite lang_deriv_dot_1. 2: now apply He1. now rewrite <- IHe1, <- IHe2. setoid_rewrite dot0x. setoid_rewrite lang_deriv_dot_2. 2: clear -He1; intuition discriminate. rewrite <- IHe1. apply cupxb. - rewrite lang_deriv_str. now rewrite <- IHe. - case eqb_spec. intros <- w. compute. split. now intros <-. now intro E; injection E. intros D w. compute. split. intros []. intro E. apply D. injection E. congruence. Qed. Theorem lang_eval e: lang e ‚â° elang e. 
] => eapply H; try eassumption; auto; [apply in_map_iff; eexists; split; [|eauto]; auto] end. - assert (leaderLogs_term_sanity net) by eauto using leaderLogs_term_sanity_invariant. unfold leaderLogs_term_sanity in *. assert (eTerm e' < n) by eauto. assert (every_entry_was_created net) by eauto using every_entry_was_created_invariant. unfold every_entry_was_created in *. find_insterU. find_insterU. find_insterU. find_insterU. conclude_using eauto. conclude_using eauto. unfold term_was_created in *. break_exists. find_copy_apply_hyp_hyp. repeat break_or_hyp; try omega. assert (leaderLogs_preserved net) by eauto using leaderLogs_preserved_invariant. unfold leaderLogs_preserved in *. exfalso. eauto. } assert (leaderLogs_votesWithLog net) by eauto using leaderLogs_votesWithLog_invariant. unfold leaderLogs_votesWithLog in *. find_apply_hyp_hyp. match goal with | [ H : exists _, _ |- _ ] => destruct H as [quorum'] end. break_and. assert (NoDup nodes) by eauto using all_fin_NoDup. match goal with | H : NoDup nodes, _ : NoDup ?l1, _ : NoDup ?l2 |- _ => eapply pigeon with (l := nodes) (sub1 := l1) (sub2 := l2) in H end; eauto using all_fin_all, name_eq_dec, div2_correct. match goal with | [ H : exists _, _ |- _ ] => destruct H as [a] end. break_and. find_apply_hyp_hyp. find_apply_hyp_hyp. break_exists. break_and. assert (In e x). { assert (allEntries_votesWithLog net) by eauto using allEntries_votesWithLog_invariant. unfold allEntries_votesWithLog in *. eapply_prop_hyp In In; eauto. break_or_hyp; auto. break_exists. break_and. match goal with | [ H : context [ In _ _ -> _ \/ _ ], H' : In _ _ |- _ ] => eapply H in H' end. repeat (try break_or_hyp; break_and); try omega. congruence. } assert (sorted x) by (eapply votesWithLog_sorted_invariant; eauto). assert (maxTerm x >= eTerm e) by eauto using maxTerm_is_max. assert (maxIndex x >= eIndex e) by eauto using maxIndex_is_max. assert (exists e', In e' l /\ eTerm e' = maxTerm l /\ eIndex e' = maxIndex l). { assert (eTerm e >= 1 /\ eIndex e >= 1) by match goal with | [ H : In _ (votesWithLog _) |- _ ] => solve [eapply terms_and_indices_from_one_invariant in H; eauto] end. destruct l. - simpl in *. unfold moreUpToDate in *. do_bool. repeat (intuition; do_bool); try omega. - simpl in *. eauto. } match goal with | [ H : exists _, _ |- _ ] => destruct H as [e'] end. break_and. find_apply_hyp_hyp. unfold moreUpToDate in *. do_bool; repeat (try break_or_hyp; break_and; do_bool); omega. - match goal with | [ H : context [In], H' : context [In] |- _ ] => apply H in H'; intuition; omega end. Qed. Theorem leader_completeness_committed_invariant : forall net, refined_raft_intermediate_reachable net -> leader_completeness_committed net. 
From Perennial.Helpers Require Import Transitions. From Perennial.base_logic Require Import base_logic lib.invariants. From iris.proofmode Require Import tactics. From iris.prelude Require Import options.Section simulation. Context `{!invGS Œ£}. Context {state: Type} (wf: state -> Prop) (P: state -> iProp Œ£). Context (E: coPset). Definition simulation_fupd {T} (tr: transition state T) (Q: T -> iProp Œ£): iProp Œ£ := (‚àÄ œÉ œÉ' r, ‚åúwf œÉ‚åù -‚àó ‚åúrelation.denote tr œÉ œÉ' r‚åù -‚àó (P œÉ ={E}=‚àó P œÉ' ‚àó ‚åúwf œÉ'‚åù ‚àó Q r)). Theorem simulation_bind_fupd {A B} (tr1: transition state A) (tr2: A -> transition state B) (Q: B -> iProp Œ£) : simulation_fupd tr1 (fun x => simulation_fupd (tr2 x) Q) -‚àó simulation_fupd (bind tr1 tr2) Q. 
From Huffman Require Import Code. From Huffman Require Import BTree. From Huffman Require Import Build. From Huffman Require Import PBTree2BTree. From Huffman Require Import Restrict. Section Huffman. Variable A : Type. Variable empty : A. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Variable m : list A. Hypothesis frequency_more_than_one : 1 < length (frequency_list eqA_dec m). Theorem not_null_m : m <> nil. 
Lemma votes_correct_request_vote : refined_raft_net_invariant_request_vote votes_correct. Proof using vlcti. unfold refined_raft_net_invariant_request_vote, votes_correct. split_votes_correct; start_proof. - find_eapply_lem_hyp votes_update_elections_data_request_vote; eauto. find_eapply_lem_hyp votes_update_elections_data_request_vote; eauto. intuition; [eauto | | | congruence]; subst; find_copy_apply_lem_hyp votes_le_current_term_invariant; auto; find_copy_apply_lem_hyp handleRequestVote_currentTerm; do_le_antisym; match goal with | [ H : votes_currentTerm_votedFor_correct _, H' : In _ _ |- _ ] => apply H in H'; conclude_using congruence end; find_apply_lem_hyp handleRequestVote_votedFor; auto; intuition congruence. - find_eapply_lem_hyp votes_update_elections_data_request_vote; eauto. intuition. subst. find_copy_apply_lem_hyp votes_le_current_term_invariant; auto. find_copy_apply_lem_hyp handleRequestVote_currentTerm. do_le_antisym. find_apply_hyp_hyp. find_copy_apply_lem_hyp handleRequestVote_currentTerm_votedFor. intuition; try lia; try congruence. - subst. find_copy_apply_lem_hyp handleRequestVote_currentTerm_votedFor. repeat find_rewrite. intuition. + eauto using votes_update_elections_data_request_vote_intro. + eauto using votes_update_elections_data_request_vote_intro. + eauto using votes_update_elections_data_request_vote_intro_old. Qed. Lemma votes_correct_request_vote_reply : refined_raft_net_invariant_request_vote_reply votes_correct. Proof using vlcti. unfold refined_raft_net_invariant_request_vote_reply, votes_correct. split_votes_correct; start_proof. - erewrite @votes_update_elections_data_request_vote_reply_eq in * by auto. eauto. - erewrite @votes_update_elections_data_request_vote_reply_eq in * by auto. find_copy_apply_lem_hyp votes_le_current_term_invariant; auto. subst. match goal with | [ H : context [currentTerm ?x] |- _ ] => remember x as st'' eqn:Hst''; apply eq_sym in Hst'' end. find_copy_apply_lem_hyp handleRequestVoteReply_term_votedFor_cases. intuition; try lia. repeat find_rewrite. eauto. - erewrite @votes_update_elections_data_request_vote_reply_eq in * by auto. find_copy_eapply_lem_hyp handleRequestVoteReply_term_votedFor; eauto. intuition. repeat find_rewrite. eauto. Qed. Lemma votes_correct_do_leader : refined_raft_net_invariant_do_leader votes_correct. Proof using. unfold refined_raft_net_invariant_do_leader, votes_correct. intros. match goal with H : nwState _ _ = _ |- _ => assert (gd = fst (nwState net h) /\ d = snd (nwState net h)) by (intuition; find_rewrite; reflexivity); clear H end. split_votes_correct; start_proof; subst. - eauto. - find_apply_lem_hyp doLeader_term_votedFor. break_and. repeat find_rewrite. eauto. - find_apply_lem_hyp doLeader_term_votedFor. break_and. repeat find_rewrite. eauto. Qed. Lemma votes_correct_do_generic_server : refined_raft_net_invariant_do_generic_server votes_correct. Proof using. unfold refined_raft_net_invariant_do_generic_server, votes_correct. intros. match goal with H : nwState _ _ = _ |- _ => assert (gd = fst (nwState net h) /\ d = snd (nwState net h)) by (intuition; find_rewrite; reflexivity); clear H end. split_votes_correct; start_proof; subst. - eauto. - find_apply_lem_hyp doGenericServer_log_type_term_votesReceived. break_and. repeat find_rewrite. eauto. - find_apply_lem_hyp doGenericServer_log_type_term_votesReceived. break_and. repeat find_rewrite. eauto. Qed. Lemma votes_correct_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset votes_correct. Proof using. unfold refined_raft_net_invariant_state_same_packet_subset, votes_correct. split_votes_correct; intros; repeat find_reverse_higher_order_rewrite; eauto. Qed. Lemma votes_correct_reboot : refined_raft_net_invariant_reboot votes_correct. Proof using. unfold refined_raft_net_invariant_reboot, votes_correct, reboot. intros. match goal with H : nwState _ _ = _ |- _ => assert (gd = fst (nwState net h) /\ d = snd (nwState net h)) by (intuition; repeat find_rewrite; reflexivity); clear H end. split_votes_correct; start_proof; subst; simpl in *; eauto. Qed. Theorem votes_correct_init : refined_raft_net_invariant_init votes_correct. Proof using. unfold refined_raft_net_invariant_init, votes_correct. split_votes_correct; simpl in *; intuition; discriminate. Qed. Theorem votes_correct_invariant : forall net, refined_raft_intermediate_reachable net -> votes_correct net. 
Require Import Coq.Classes.EquivDec. Require Import ExtLib.Structures.EqDep. Require Coq.Logic.Eqdep_dec.Set Implicit Arguments. Set Strict Implicit.Section Classes. Context {A : Type}. Context {dec : EqDec A (@eq A)}. Theorem UIP_refl : forall {x : A} (p1 : x = x), p1 = refl_equal _. intros. eapply Eqdep_dec.UIP_dec. apply equiv_dec. Qed. Theorem UIP_equal : forall {x y : A} (p1 p2 : x = y), p1 = p2. 
z, (y = z) -> (x >= y) -> (x >= z). intros x y z H; rewrite H; auto. Qed.Theorem ge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y). intros x y z H1 H2; red; apply le_trans with z; auto. Qed.Close Scope nat_scope.Open Scope N_scope.Theorem Nplus_eq_compat_l: forall a b c, b = c -> a + b = a + c. intros; apply f_equal2 with (f:= Nplus); auto. Qed.Theorem Nplus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c. intros a b c H1 H2; case H1. apply Nplus_reg_l with a; auto. Qed.Theorem Nplus_lt_compat_l: forall n m p, n < m -> p + n < p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_gt_compat_l: forall n m p, n > m -> p + n > p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_le_compat_l: forall n m p, n <= m -> p + n <= p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_ge_compat_l: forall n m p, n >= m -> p + n >= p + m. intros; to_nat; auto with arith. Qed.Theorem Nplus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c. intros a b c H H1; case H; apply f_equal2 with (f:= Nplus); auto. Qed.Theorem Nplus_lt_reg_l: forall n m p, p + n < p + m -> n < m. intros; to_nat; apply plus_lt_reg_l with nn1; auto with arith. Qed.Theorem Nplus_gt_reg_l: forall n m p, p + n > p + m -> n > m. intros; to_nat; apply plus_gt_reg_l with nn1; auto with arith. Qed.Theorem Nplus_le_reg_l: forall n m p, p + n <= p + m -> n <= m. intros; to_nat; apply plus_le_reg_l with nn1; auto with arith. Qed.Theorem Nplus_ge_reg_l: forall n m p, p + n >= p + m -> n >= m. intros; to_nat; apply plus_ge_reg_l with nn1; auto with arith. Qed. Theorem Neq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros; subst; auto. Qed.Theorem Neq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros; subst; auto. Qed.Theorem Neq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem Neq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). 
vs vs') = y vs. Proof. clear. induction tvs; simpl; intros. { exfalso; inversion H. } { destruct n. { clear H IHtvs. eexists; split; eauto. eexists; split; eauto. simpl. intros. rewrite (hlist_eta vs). reflexivity. } { apply Lt.lt_S_n in H. { specialize (IHtvs _ H). forward_reason. rewrite H0. rewrite H1. forward. subst. simpl in *. eexists; split; eauto. eexists; split; eauto. simpl. intros. rewrite (hlist_eta vs). simpl. auto. } } } Qed. Lemma nth_error_get_hlist_nth_appR : forall tvs' tvs n x, n >= length tvs -> nth_error_get_hlist_nth (tvs ++ tvs') n = Some x -> exists y, nth_error_get_hlist_nth tvs' (n - length tvs) = Some (@existT _ _ (projT1 x) y) /\ forall vs vs', (projT2 x) (hlist_app vs vs') = y vs'. Proof. clear. induction tvs; simpl; intros. { rewrite <- Minus.minus_n_O. rewrite H0. destruct x. simpl. eexists; split; eauto. intros. rewrite (hlist_eta vs). reflexivity. } { destruct n. { inversion H. } { assert (n >= length tvs) by (eapply le_S_n; eassumption). clear H. { forward. inv_all; subst. simpl in *. specialize (IHtvs _ _ H1 H0). simpl in *. forward_reason. rewrite H. eexists; split; eauto. intros. rewrite (hlist_eta vs). simpl. auto. } } } Qed.End hlist.Arguments Hnil {_ _}. Arguments Hcons {_ _ _ _} _ _. Arguments equiv_hlist {_ F} R {_} _ _ : rename. Section hlist_map. Variable A : Type. Variables F G : A -> Type. Variable ff : forall x, F x -> G x. Fixpoint hlist_map (ls : list A) (hl : hlist F ls) {struct hl} : hlist G ls := match hl in @hlist _ _ ls return hlist G ls with | Hnil => Hnil | Hcons _ _ hd tl => Hcons (ff hd) (hlist_map tl) end. Theorem hlist_app_hlist_map : forall ls ls' (a : hlist F ls) (b : hlist F ls'), hlist_map (hlist_app a b) = hlist_app (hlist_map a) (hlist_map b). Proof. induction a. simpl; auto. simpl. intros. f_equal. auto. Qed.End hlist_map.Arguments hlist_map {_ _ _} _ {_} _. Section hlist_map_rules. Variable A : Type. Variables F G G' : A -> Type. Variable ff : forall x, F x -> G x. Variable gg : forall x, G x -> G' x. Theorem hlist_map_hlist_map : forall ls (hl : hlist F ls), hlist_map gg (hlist_map ff hl) = hlist_map (fun _ x => gg (ff x)) hl. Proof. induction hl; simpl; f_equal. assumption. Defined. Theorem hlist_get_hlist_map : forall ls t (hl : hlist F ls) (m : member t ls), hlist_get m (hlist_map ff hl) = ff (hlist_get m hl). 
Require Import Le Gt Minus Min Bool.Set Implicit Arguments. Section Lists. Variable A : Type. Inductive list : Type := | nil : list | cons : A -> list -> list. Infix "::" := cons (at level 60, right associativity) : list_scope. Open Scope list_scope. Definition head (l:list) := match l with | nil => error | x :: _ => value x end. Definition hd (default:A) (l:list) := match l with | nil => default | x :: _ => x end. Definition tail (l:list) : list := match l with | nil => nil | a :: m => m end. Fixpoint length (l:list) : nat := match l with | nil => 0 | _ :: m => S (length m) end.Parameter size : list -> nat. Axiom size_nil : size nil = 0. Fixpoint In (a:A) (l:list) {struct l} : Prop := match l with | nil => False | b :: m => b = a \/ In a m end. Fixpoint app (l m:list) {struct l} : list := match l with | nil => m | a :: l1 => a :: app l1 m end. Infix "++" := app (right associativity, at level 60) : list_scope.End Lists.Arguments nil {A}. Infix "::" := cons (at level 60, right associativity) : list_scope. Infix "++" := app (right associativity, at level 60) : list_scope.Open Scope list_scope.Delimit Scope list_scope with list.Bind Scope list_scope with list.Arguments list _%type_scope.Section Facts. Variable A : Type. Theorem nil_cons : forall (x:A) (l:list A), nil <> x :: l. Proof. intros; discriminate. Qed. Theorem destruct_list : forall l : list A, {x:A & {tl:list A | l = x::tl}}+{l = nil}. 
* [[[ m ::: Fm * rep bxp IFs ir l ]]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * [[ r = l ]] CRASH:hm' exists ms', LOG.rep lxp F (LOG.ActiveTxn m0 m) ms' sm hm' >} read lxp ir ms. Proof. unfold read. step; denote rep as Hx. step. rewrite rep_piff_direct in Hx; unfold rep_direct in Hx; destruct_lift Hx. substl; substl (length l); auto. unfold rep in H; destruct_lift H; omega. unfold rep, indrep in Hx. destruct_lifts. indrep_n_tree_extract_lengths. hoare. rewrite app_assoc with (l := firstn _ _). rewrite <- firstn_sum_split. rewrite firstn_skipn. congruence. Qed. Theorem indread_range_helper_ok : forall lxp bn indlvl start len ms, let localstart := fold_left plus (map (fun i => NIndirect ^ S i) (seq 0 indlvl)) 0 in {< F Fm IFs m0 sm m l bxp, PRE:hm LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm * [[[ m ::: (Fm * indrep_n_tree indlvl bxp IFs bn l) ]]] POST:hm' RET:^(ms, r) LOG.rep lxp F (LOG.ActiveTxn m0 m) ms sm hm' * let len' := (len - (localstart - start)) in [[ r = firstn len' (skipn (start - localstart) l) ]] CRASH:hm' LOG.intact lxp F m0 sm hm' >} indread_range_helper indlvl lxp bn start len ms. Proof. unfold indread_range_helper. step; indrep_n_tree_extract_lengths; hoare. substl (length l). let H := fresh in edestruct Min.min_spec as [ [? H]|[? H] ]; rewrite H; clear H. omega. omega. let H := fresh in edestruct Min.min_spec as [ [? H]|[? H] ]; rewrite H; clear H. auto. rewrite firstn_oob. rewrite firstn_oob; auto. autorewrite with core. omega. autorewrite with core. omega. rewrite skipn_oob, firstn_nil by omega. auto. rewrite sub_le_eq_0 by omega. auto. Qed. Local Hint Extern 1 ({{_}} Bind (indread_range_helper _ _ _ _ _ _ ) _) => apply indread_range_helper_ok : prog. Abort. *) Lemma indrec_ptsto_pimpl : forall ibn indrec, IndRec.rep ibn indrec =p=> exists v, ibn |-> (v, nil). Proof. unfold IndRec.rep; cancel. assert (length (synced_list (IndRec.Defs.ipack indrec)) = 1). unfold IndRec.items_valid in H2; intuition. rewrite synced_list_length; subst. rewrite IndRec.Defs.ipack_length. setoid_rewrite H0. rewrite Rounding.divup_mul; auto. rewrite arrayN_isolate with (i := 0) by omega. unfold IndSig.RAStart; rewrite Nat.add_0_r. rewrite skipn_oob by omega; simpl. instantiate (2 := ($0, nil)). rewrite synced_list_selN; cancel. Qed. Hint Rewrite cuttail_length : core. Hint Rewrite upd_len_get_len upd_len_get_ind upd_len_get_dind upd_len_get_tind upd_len_get_blk upd_len_get_iattr : core. Hint Rewrite upd_irec_get_len upd_irec_get_ind upd_irec_get_dind upd_irec_get_tind upd_irec_get_blk upd_irec_get_iattr : core. Local Hint Resolve upd_len_get_iattr upd_irec_get_iattr. Theorem upd_len_indrep : forall bxp Fs ir l n, indrep bxp Fs ir l <=p=> indrep bxp Fs (upd_len ir n) l. 
Heq Hin. destruct s as [s [f HSem]]. unfold filter, In, In_set in *. simpl in *. erewrite member_Sem in Hin by (eapply filter_Sem; try eassumption; intro i; reflexivity). simpl in *. rewrite andb_true_iff in Hin. intuition. Qed. Lemma filter_3 : forall (s : t) (x : elt) (f : elt -> bool), compat_bool N.eq f -> In x s -> f x = true -> In x (filter f s). Proof. intros s x P Heq Hin HP. destruct s as [s [f HSem]]. unfold filter, In, In_set in *. simpl in *. erewrite member_Sem in Hin by eassumption. erewrite member_Sem by (eapply filter_Sem; try eassumption; intro i; reflexivity). simpl in *. rewrite andb_true_iff. intuition. Qed. Lemma partition_1 : forall (s : t) (f : elt -> bool), compat_bool N.eq f -> Equal (fst (partition f s)) (filter f s). Proof. intros. destruct s. unfold Equal, partition; simpl. rewrite partition_fst. reflexivity. Qed. Lemma partition_2 : forall (s : t) (f : elt -> bool), compat_bool N.eq f -> Equal (snd (partition f s)) (filter (fun x : elt => negb (f x)) s). Proof. intros. destruct s. unfold Equal, partition; simpl. rewrite partition_snd by assumption. reflexivity. Qed. Lemma elements_1 : forall (s : t) (x : elt), In x s -> InA N.eq x (elements s). Proof. intros. destruct s as [s Hwf]. destruct Hwf as [f HSem]. simpl in *. unfold In_set in *. erewrite member_Sem in H by eassumption. apply OrdFacts.ListIn_In. rewrite <- toList_In by eassumption. assumption. Qed. Lemma elements_2 : forall (s : t) (x : elt), InA N.eq x (elements s) -> In x s. Proof. intros. destruct s as [s Hwf]. destruct Hwf as [f HSem]. simpl in *. unfold In_set in *. erewrite member_Sem by eassumption. rewrite InA_alt in H. destruct H as [_[[]?]]. rewrite <- toList_In in H by eassumption. assumption. Qed. Lemma elements_3 (s : t) : Sorted E.lt (elements s). Proof. unfold E.lt; destruct s as [s WFs]; simpl. apply StronglySorted_Sorted. now apply to_List_sorted. Qed. Lemma elements_3w (s : t) : NoDupA N.eq (elements s). Proof. apply OrdFacts.Sort_NoDup, elements_3. Qed. Definition compare (s s' : t) : Compare lt eq s s'. Proof. destruct (compare s s') eqn:CMP. - apply EQ; abstract now apply equal_2; destruct s, s'; generalize dependent CMP; rewrite Ord_compare_Eq; unfold "==", Eq__WFIntSet; simpl. - apply LT; abstract order t. - apply GT; abstract order t. Defined. Theorem lt_trans (s1 s2 s3 : t) : lt s1 s2 -> lt s2 s3 -> lt s1 s3. 
Transparent sumor_rec. Transparent sumbool_rec. Transparent sig_rec. Theorem is_a_sort : forall t : term, decide (exists s : sort, t = Srt s). 
(pp_ok H1).right. split with (Not_a_type A x). constructor. apply (pp_ok H0).red in |- *; intros. elim b with s. apply (pp_least H0). trivial.constructor.apply type_correctness with (1 := pp_ok H0).right. inversion_clear b. split with x. trivial.apply Infe_subt with A; trivial with pts.trivial. Defined. End Fixpoint_Body.Section Infer_Full_PTS. Fixpoint full_ppal_type (t : term) : forall e : env, wf e -> infer_ppal_type e t := fun e H => match t return (infer_ppal_type e t) with | Srt s => infer_sort e s H | Ref n => infer_ref e n H | Abs A M => infer_abs full_ppal_type e A M H | App u v => infer_app full_ppal_type e u v H | Prod A B => infer_prod full_ppal_type e A B H end. Lemma tmp_add_typ : forall (e : env) (t : term), wf e -> decl_dec e (Ax t). Proof fix_add_typ full_ppal_type. Lemma tmp_check_typ_when_wf : forall (e : env) (t T : term), wf e -> wf_type e T -> check_dec e t T. Proof fix_chk_wk full_ppal_type. Let add_cst : forall (e : env) (t T : term), wf e -> decl_dec e (Def t T).intros. elim (tmp_add_typ e T); trivial; intros. elim (tmp_check_typ_when_wf e t T); trivial; intros. left. inversion_clear w. apply wf_cst with s; trivial with pts.right with err; auto with pts.inversion_clear w. left with s; trivial with pts.right with err; auto with pts. Qed. Lemma tmp_check_wf_type : forall (e : env) (t : term), wf e -> wft_dec e t.intros. elim (is_a_sort t); intros. left. inversion_clear a; subst t; auto with pts.case (tmp_add_typ e t); trivial; intros. left. inversion_clear w; auto with pts. apply wft_typed with s; auto with pts.right with err; auto with pts. Qed. Let check_type : forall (e : env) (t T : term), wf e -> check_dec e t T.intros. case (tmp_check_wf_type e T); trivial; intros. apply tmp_check_typ_when_wf; trivial.right with err; auto with pts. inversion_clear d. apply Chke_type; trivial.apply Chke_type2; trivial. Qed. Definition full_type_checker : PTS_TC := Build_PTS_TC (fun e t => full_ppal_type t e) check_type tmp_add_typ add_cst tmp_check_typ_when_wf tmp_check_wf_type. Theorem decide_wf : forall e : env, decide (wf e). simple induction e; intros; auto with pts. elim H; intros. elim a; intros. elim tmp_add_typ with l t; intros; auto. right. apply decl_err_not_wf with err; trivial.elim add_cst with l t t0; intros; auto. right. apply decl_err_not_wf with err; trivial.right; red in |- *; intros. apply b. apply inv_wf with a; trivial. Qed. Theorem decide_typ : forall (e : env) (t T : term), decide (typ e t T). 
a). Proof using. intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1. Qed. Theorem fold_left_eta : forall l a f1, (forall a b, In b l -> f a b = f1 a b) -> fold_left f l a = fold_left f1 l a. Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H a0 f1 H0. rewrite H0; auto. Qed. Theorem fold_left_map : forall (C : Type) a l (k : C -> B), fold_left f (map k l) a = fold_left (fun a b => f a (k b)) l a. Proof using. intros C a l k; generalize a; elim l; simpl in |- *; auto. Qed. Theorem fold_right_app : forall a l1 l2, fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1. Proof using. intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1. intros a l H a0 l2; rewrite H; auto. Qed. Theorem fold_left_init : (forall (a : A) (b : B), h (f a b) = f (h a) b) -> forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a). Proof using. intros H a l; generalize a; elim l; clear l a; simpl in |- *; auto. intros a l H0 a0. rewrite <- H; auto. Qed. End fold. Section List. Variables (A : Type) (B : Type) (C : Type). Variable f : A -> B. Theorem list_length_ind : forall P : list A -> Prop, (forall l1 : list A, (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) -> forall l : list A, P l. Proof using. intros P H l; apply well_founded_ind with (R := fun x y : list A => length x < length y); auto. apply wf_inverse_image with (R := lt); auto. apply lt_wf. Qed. Definition list_length_induction : forall P : list A -> Type, (forall l1 : list A, (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) -> forall l : list A, P l. intros P H l; apply well_founded_induction_type with (R := fun x y : list A => length x < length y); auto. apply wf_inverse_image with (R := lt); auto. apply lt_wf. Defined. Theorem in_ex_app : forall (a : A) (l : list A), In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2). 
Require Export Coq.Logic.Epsilon. Require Import ZFC.Axiom.ZFC2. Definition ClassChoice := Œª P, epsilon (inhabits ‚à ) P. Definition class_choice_spec := Œª P, epsilon_spec (inhabits ‚à ) P. Definition SetChoice := Œª S, ClassChoice (Œª x, x ‚àà S). Definition set_choice_spec := Œª S, class_choice_spec (Œª x, x ‚àà S). Lemma chosen_contained : ‚àÄ s, ‚¶ø s ‚Üí SetChoice s ‚àà s. Proof. intros s. apply set_choice_spec. Qed. Theorem chosen_included : ‚àÄ S, (‚àÄs ‚àà S, ‚¶øs) ‚Üí {SetChoice s | s ‚àä S} ‚äÜ ‚ãÉS. Proof. intros S H x Hx. apply ReplAx in Hx as [s [H1 H2]]. eapply UnionI. apply H1. apply H in H1. subst. apply chosen_contained. apply H1. Qed. Theorem one_chosen : ‚àÄ S, (‚àÄs ‚àà S, ‚¶øs) ‚Üí (‚àÄ s t ‚àà S, s ‚â t ‚Üí disjoint s t) ‚Üí ‚àÄs ‚àà S, ‚àÉ x, s ‚à© {SetChoice s | s ‚àä S} = {x,}. 
try eassumption. apply REACH_nil. eapply mappedI_true; eassumption. specialize (RC' _ H2). destruct (mappedD_true _ _ RC') as [[? ?] ?]. eapply as_inj_DomRng; eassumption. eapply REACH_cons; try eassumption. assert (RRC: REACH_closed m1' (fun b : Values.block => mapped (as_inj nu') b && (locBlocksSrc nu' b || DomSrc nu' b && (negb (locBlocksSrc nu' b) && REACH m1' (exportedSrc nu' (ret1 :: nil)) b)))). eapply REACH_closed_intersection; eassumption. assert (GFnu': forall b, isGlobalBlock (Genv.globalenv prog) b = true -> DomSrc nu' b && (negb (locBlocksSrc nu' b) && REACH m1' (exportedSrc nu' (ret1 :: nil)) b) = true). intros. specialize (Glob _ H2). assert (FSRC:= extern_incr_frgnBlocksSrc _ _ INC). rewrite replace_locals_frgnBlocksSrc in FSRC. rewrite FSRC in Glob. rewrite (frgnBlocksSrc_locBlocksSrc _ WDnu' _ Glob). apply andb_true_iff; simpl. split. unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ Glob). intuition. apply REACH_nil. unfold exportedSrc. rewrite (frgnSrc_shared _ WDnu' _ Glob). intuition. split. unfold vis in *. econstructor; try eassumption. eapply match_cont_sub; try eassumption. rewrite replace_externs_as_inj. rewrite replace_externs_locBlocksSrc, replace_externs_frgnBlocksSrc in *. clear RRC RR1 RC' PHnu' INCvisNu' H0 UnchLOOR UnchPrivSrc H1 H. destruct INC. rewrite replace_locals_extern in H. rewrite replace_locals_frgnBlocksTgt, replace_locals_frgnBlocksSrc, replace_locals_pubBlocksTgt, replace_locals_pubBlocksSrc, replace_locals_locBlocksTgt, replace_locals_locBlocksSrc, replace_locals_extBlocksTgt, replace_locals_extBlocksSrc, replace_locals_local in H0. destruct H0 as [? [? [? [? [? [? [? [? ?]]]]]]]]. red; intros. destruct (restrictD_Some _ _ _ _ _ H9); clear H9. apply restrictI_Some. apply joinI. destruct (joinD_Some _ _ _ _ _ H10). apply H in H9. left; trivial. destruct H9. right. rewrite H0 in H12. split; trivial. destruct (disjoint_extern_local _ WDnu' b); trivial. congruence. rewrite H3, H7 in H11. remember (locBlocksSrc nu' b) as d. destruct d; trivial; simpl in *. apply andb_true_iff. split. unfold DomSrc. rewrite (frgnBlocksSrc_extBlocksSrc _ WDnu' _ H11). intuition. apply REACH_nil. unfold exportedSrc. apply frgnSrc_shared in H11; trivial. rewrite H11; intuition. rewrite replace_externs_as_inj. rewrite replace_externs_frgnBlocksSrc, replace_externs_locBlocksSrc. eapply restrict_val_inject; try eassumption. intros. destruct (getBlocks_inject (as_inj nu') (ret1::nil) (ret2::nil)) with (b:=b) as [bb [dd [JJ' GBbb]]]; try eassumption. constructor. assumption. constructor. remember (locBlocksSrc nu' b) as d. destruct d; simpl; trivial. apply andb_true_iff. split. eapply as_inj_DomRng; eassumption. apply REACH_nil. unfold exportedSrc. rewrite H2. trivial. rewrite replace_externs_as_inj. eapply inject_mapped; try eassumption. rewrite replace_externs_locBlocksSrc, replace_externs_frgnBlocksSrc. eapply restrict_mapped_closed; try eassumption. unfold vis. rewrite replace_externs_locBlocksSrc, replace_externs_frgnBlocksSrc, replace_externs_as_inj. destruct (eff_after_check2 _ _ _ _ _ MemInjNu' RValInjNu' _ (eq_refl _) _ (eq_refl _) _ (eq_refl _) WDnu' SMvalNu'). intuition. red; intros. destruct (GFP _ _ H4). split; trivial. eapply extern_incr_as_inj; try eassumption. rewrite replace_locals_as_inj. assumption. admit. Qed. Theorem transl_program_correct: forall (TRANSL: sel_program prog = OK tprog) (R: list_norepet (map fst (prog_defs prog))) entrypoints (entry_points_ok : forall v1 v2 sig, In (v1, v2, sig) entrypoints -> exists b f1 f2, v1 = Vptr b Int.zero /\ v2 = Vptr b Int.zero /\ Genv.find_funct_ptr ge b = Some f1 /\ Genv.find_funct_ptr tge b = Some f2) (init_mem: exists m0, Genv.init_mem prog = Some m0), SM_simulation.SM_simulation_inject cmin_eff_sem cminsel_eff_sem ge tge entrypoints. 
subterm_size in H. simpl. lia. - simpl. lia. Defined. Theorem subterm_or_eq_size: forall e e', subterm_or_eq e e' -> (term_size e <= term_size e')%nat. Proof. intros. induction H. apply dsubterm_size in H; lia. reflexivity. etransitivity; eauto. Defined. Theorem subfds_or_eq_size: forall fds fds', subfds_or_eq fds fds' -> (funs_size fds <= funs_size fds')%nat. Proof. destruct fds; intros; inversion H; try (subst; reflexivity). - apply subfds_fds_size in H0. lia. - inversion H0; subst. simpl; lia. simpl; lia. Defined. Corollary subfds_e_size: forall fds e, subfds_e fds e -> (funs_size fds < term_size e)%nat. Proof. intros. inversion H. destructAll. apply subfds_or_eq_size in H1. apply subterm_or_eq_size in H0. simpl in H0. lia. Defined. Definition b_map_le: b_map -> b_map -> Prop := fun inl inl_r => forall v, get_b v inl = true -> get_b v inl_r = true. Theorem b_map_le_refl: forall i, b_map_le i i. Proof. intros; intro; intros. assumption. Defined. Theorem b_map_le_trans: forall i i' i'', b_map_le i i' -> b_map_le i' i'' -> b_map_le i i''. Proof. intros; intro; intros. apply H in H1. apply H0 in H1. assumption. Defined. Theorem b_map_le_true : forall v i, b_map_le i (M.set v true i). Proof. intros. intro. intros. destruct (var_dec v0 v); subst. - apply gdss. - rewrite gdso by auto. apply H. Defined. Theorem svalue_inl_b_map_le : forall inl inl', b_map_le inl inl' -> forall v, svalue_inl_size v inl' <= svalue_inl_size v inl. Proof. intros. unfold svalue_inl_size. destruct v; simpl. destruct (get_b p inl) eqn:gbp. apply H in gbp. rewrite gbp; auto. destruct (get_b p inl'); lia. Qed. Theorem sub_size_le : forall sub inl inl', b_map_le inl inl' -> sub_inl_size sub inl' <= sub_inl_size sub inl. Proof. intros. do 2 (rewrite sub_inl_proof). remember (M.elements sub) as l. clear Heql. induction l. reflexivity. unfold list_inl_size in *. simpl. assert ( svalue_inl_size a inl' <= svalue_inl_size a inl) by (apply svalue_inl_b_map_le; auto). lia. Qed. Inductive b_map_le_i : b_map -> b_map -> Prop := | ble_refl: forall b, b_map_le_i b b | ble_add : forall b b' v, b_map_le_i b b' -> b_map_le_i b (M.set v true b'). Theorem b_map_le_c : forall b b', b_map_le_i b b' -> b_map_le b b'. Proof. intros. induction H. apply b_map_le_refl. subst. eapply b_map_le_trans. apply IHb_map_le_i. apply b_map_le_true. Defined. Theorem b_map_le_i_trans: forall b b', b_map_le_i b b' -> forall b'', b_map_le_i b' b'' -> b_map_le_i b b''. Proof. intros b b' H b'' H'. induction H'; intros. assumption. apply ble_add. apply IHH'. assumption. Defined. Theorem b_map_i_true: forall b b' v, (b_map_le_i (M.set v true b) b' -> b_map_le_i b b'). 
assert (~In (fst (s, v), projT1 (snd (s, v))) (getKindAttr (getAllMethods m))) as P1. { simpl; assumption. } specialize (In_nth_error _ _ H2) as TMP; dest. specialize (Trace_meth_InCall_InDef_InExec H _ _ H7 P0) as P2. specialize (getNumCalls_nonneg (s, v) x1) as P3. inv H6; specialize (H8 (s, v)); unfold getListFullLabel_diff in *. inv H5. + rewrite (NotInDef_ZeroExecs_Step' _ P1 HStep0) in *; lia. + specialize (In_nth_error _ _ H6) as TMP; dest. rewrite (NotInDef_ZeroExecs_Trace' _ H4 P1 _ H5) in *; lia. Qed. Corollary TraceInclusion_HideMeth m m' s: TraceInclusion m m' -> TraceInclusion (HideMeth m s) (HideMeth m' s). Proof. intros. apply TraceInclusion'_TraceInclusion. apply TraceInclusion_TraceInclusion' in H. eauto using TraceInclusion'_HideMeth. Qed. Lemma TraceInclusion_createHideMod m m' ls: TraceInclusion m m' -> TraceInclusion (createHideMod m ls) (createHideMod m' ls). Proof. intros; induction ls; auto; simpl in *. apply TraceInclusion_HideMeth. assumption. Qed. Lemma TraceInclusion'_TraceInclusion_iff m m' : TraceInclusion m m' <-> TraceInclusion' m m'. Proof. split; intros; eauto using TraceInclusion'_TraceInclusion, TraceInclusion_TraceInclusion'. Qed. Lemma Trace_createHide l m m' : TraceInclusion (Base m) (Base m') -> TraceInclusion (createHide m l) (createHide m' l). Proof. induction l; simpl in *; auto. intros. apply TraceInclusion_TraceInclusion' in H. apply TraceInclusion'_TraceInclusion. apply TraceInclusion'_HideMeth. apply TraceInclusion_TraceInclusion'; apply TraceInclusion'_TraceInclusion in H; auto. Qed. Lemma WfMod_WfBase_getFlat ty m: (WfMod ty m) -> (WfMod ty (Base (getFlat m))). Proof. intro. induction m; simpl in *. - intros. constructor 1; intros; apply WfMod_WfBaseMod_flat; auto; specialize (H ty); inv H; auto. - intros. unfold getFlat in *; simpl in *; apply IHm. intros. specialize (H). inv H; auto. - intros. assert (HWf1: WfMod ty m1) by (specialize (H); inv H; auto). assert (HWf2: WfMod ty m2) by (specialize (H); inv H; auto). assert (WfConcat1: WfConcat ty m1 m2) by (specialize (H); inv H; auto). assert (WfConcat2: WfConcat ty m2 m1) by (specialize (H); inv H; auto). specialize (H). inv H. specialize (IHm1 HWf1); specialize (IHm2 HWf2). constructor 1; ((apply WfMod_WfBaseMod_flat; constructor 3; auto) || (specialize (IHm1); specialize (IHm2); inv IHm1; inv IHm2; simpl in *; apply NoDupKey_Expand; auto)). Qed. Lemma TraceInclusion_flatten_inline_everything_r (m : ModWf type) : TraceInclusion m (flatten_inline_everything_ModWf m). Proof. specialize (wfMod (flatten_inline_everything_ModWf m)) as Wf1. simpl. specialize (TraceInclusion_flatten_r m) as P1. unfold flatten, getFlat in *. assert (WfMod type (Base (getFlat m))). { intros. apply (WfMod_WfBase_getFlat (wfMod m)). } unfold getFlat in *. specialize (TraceInclusion_inlineAll_pos H) as TMP; dest. unfold inlineAll_All in *. apply (Trace_createHide (getHidden m)) in H1. eauto using TraceInclusion_trans. Qed. Theorem TraceInclusion_flatten_inline_everything_r_new (m : ModWf_new type) : TraceInclusion m (flatten_inline_everything_ModWf_new m). 
Q_distr_left_aux : forall (x y : Q) (z' : Qpositive), Qmult (Qplus x y) (Qpos z') = Qplus (Qmult x (Qpos z')) (Qmult y (Qpos z')). intros x y z'; case y. repeat rewrite <- (Qplus_sym Zero). repeat rewrite Qplus_zero_left; auto with *. case x.simpl in |- *; auto with *.intros x' y'; simpl in |- *. rewrite Qpositive_mult_distr. auto.intros x' y'; simpl in |- *. Case' (Qpositive_le_dec x' y'). case (Qpositive_eq_dec x' y'). simpl in |- *. intros Heq; rewrite Heq. Case' (Qpositive_le_dec (Qpositive_mult y' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult y' z') (Qpositive_mult y' z')). auto. intros H; elim H; auto. intros H; elim H; auto. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q n q0; elim n. apply Qpositive_mult_simpl with z'. auto. simpl in |- *; intros; rewrite Qpositive_mult_minus_distr; auto with *. intros H H0 H1 n q; elim H. apply Qpositive_le_antisym; auto. apply Qpositive_le_mult; auto with *. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q H H0 H1; elim H. apply Qpositive_mult_simpl with z'; auto. intros n q H H0 H1; elim H. apply Qpositive_mult_simpl with z'; apply Qpositive_le_antisym; auto with *. apply Qpositive_le_mult; auto. intros H H0 H3 H1 H2 H4. simpl in |- *. rewrite Qpositive_mult_minus_distr; auto. intros y'; case x.simpl in |- *; repeat rewrite Qplus_zero_left; auto.intros x'; simpl in |- *. Case' (Qpositive_le_dec x' y'). case (Qpositive_eq_dec x' y'). Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). auto. intros n q e q0; elim n; rewrite e; auto. intros n H0 H1 e q; elim n; rewrite e; auto. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q n; elim n; apply Qpositive_mult_simpl with z'; auto. simpl in |- *. intros; rewrite Qpositive_mult_minus_distr; auto with *. intros H H0 H1 n q; elim H1; apply Qpositive_le_mult; auto with *. Case' (Qpositive_le_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). case (Qpositive_eq_dec (Qpositive_mult x' z') (Qpositive_mult y' z')). intros e q n; elim n; apply Qpositive_mult_simpl with z'; auto. intros n q H H0 H1; elim n. apply Qpositive_le_antisym; auto. apply Qpositive_le_mult; auto with *. simpl in |- *. intros; rewrite Qpositive_mult_minus_distr; auto.intros x'; simpl in |- *; rewrite Qpositive_mult_distr; auto with *. Qed. Theorem Qmult_zero : forall x : Q, Qmult Zero x = Zero. 
= ?X1) => n | _ => compute_rank tl (S n) v end end.Ltac model_aux l f v := match v with | (f ?X1 ?X2) => let r1 := model_aux l f X1 with r2 := model_aux l f X2 in constr:(node r1 r2) | ?X1 => let n := compute_rank l 0 X1 in constr:(leaf n) | _ => constr:(leaf 0) end.Ltac model_A A f def v := let l := term_list f (nil (A:=A)) v in let t := model_aux l f v in constr:(bin_A A f l def t).Ltac assoc_eq A f assoc_thm := match goal with | [ |- (@eq A ?X1 ?X2) ] => let term1 := model_A A f X1 X1 with term2 := model_A A f X1 X2 in (change (term1 = term2); apply flatten_valid_A_2 with (1 := assoc_thm); auto) end.Theorem reflection_test3 : forall x y z t u:Z, (x*(y*z*(t*u)) = x*y*(z*(t*u)))%Z. Proof. intros; assoc_eq Z Zmult Zmult_assoc. Qed. Fixpoint nat_le_bool (n m:nat){struct m} : bool := match n, m with | O, _ => true | S _, O => false | S n, S m => nat_le_bool n m end.Fixpoint insert_bin (n:nat)(t:bin){struct t} : bin := match t with | leaf m => match nat_le_bool n m with | true => node (leaf n)(leaf m) | false => node (leaf m)(leaf n) end | node (leaf m) t' => match nat_le_bool n m with | true => node (leaf n) t | false => node (leaf m)(insert_bin n t') end | t => node (leaf n) t end.Fixpoint sort_bin (t:bin) : bin := match t with | node (leaf n) t' => insert_bin n (sort_bin t') | t => t end. Section commut_eq. Variables (A : Type)(f : A->A->A). Hypothesis comm : forall x y:A, f x y = f y x. Hypothesis assoc : forall x y z:A, f x (f y z) = f (f x y) z. Fixpoint bin_A' (l:list A)(def:A)(t:bin){struct t} : A := match t with | node t1 t2 => f (bin_A' l def t1)(bin_A' l def t2) | leaf n => nth n l def end. Theorem flatten_aux_valid_A' : forall (l:list A)(def:A)(t t':bin), f (bin_A' l def t)(bin_A' l def t') = bin_A' l def (flatten_aux t t'). Proof. intros l def t; elim t; simpl; auto. intros t1 IHt1 t2 IHt2 t'; rewrite <- IHt1; rewrite <- IHt2. symmetry; apply assoc. Qed. Theorem flatten_valid_A' : forall (l:list A)(def:A)(t:bin), bin_A' l def t = bin_A' l def (flatten t). 
Require Import Arith Lia Wellfounded List Extraction.From Undecidability.Shared.Libs.DLW.Wf Require Import acc_irr.Set Implicit Arguments.Section measure_rect. Variable (X : Type) (m : X -> nat) (P : X -> Type). Hypothesis F : forall x, (forall x', m x' < m x -> P x') -> P x. Arguments F : clear implicits. Let R x y := m x < m y. Let Rwf : forall x : X, Acc R x. Proof. apply wf_inverse_image with (f := m), lt_wf. Qed. Let Fix_F : forall x : X, Acc R x -> P x. Proof. refine( fix Fix_F x (H : Acc R x) { struct H } := F x (fun x' (H' : R x' x) => Fix_F x' _) ). destruct H as [ G ]. apply G. trivial. Defined. Let Fix_F_fix x A : @Fix_F x A = F x (fun y H => Fix_F (Acc_inv A H)). Proof. destruct A; reflexivity. Qed. Definition measure_rect x : P x := Fix_F (Rwf x). Hypothesis F_ext : forall x f g, (forall y H, f y H = g y H) -> F x f = F x g. Let Fix_F_Acc_irr : forall x f g, @Fix_F x f = Fix_F g. Proof using F_ext. apply Acc_irrelevance. intros; apply F_ext; auto. Qed. Theorem measure_rect_fix x : measure_rect x = @F x (fun y _ => measure_rect y). 
; upper := (fun q => exists y, r_upper c y /\ upper y q) |}. - intros q r E. split. + intros [x [? G]]. exists x. rewrite E in G. auto. + intros [x [? G]]. exists x. rewrite <- E in G. auto. - intros q r E. split. + intros [x [? G]]. exists x. rewrite E in G. auto. + intros [x [? G]]. exists x. rewrite <- E in G. auto. - destruct (r_lower_bound c) as [x ?]. destruct (lower_bound x) as [q ?]. exists q, x ; auto. - destruct (r_upper_bound c) as [x ?]. destruct (upper_bound x) as [q ?]. exists q, x ; auto. - intros q r A [x [C D]]. exists x. split ; auto. apply (lower_lower x q r) ; assumption. - intros q [x [C D]]. destruct (lower_open x q D) as [r [F G]]. exists r. split ; auto. exists x ; auto. - intros q r A [x [C D]]. exists x. split ; auto. apply (upper_upper x q r) ; assumption. - intros r [y [C D]]. destruct (upper_open y r D) as [q [F G]]. exists q. split ; auto. exists y ; auto. - intros q [[x [H1 H2]] [y [G1 G2]]]. absurd (r_lower c x /\ r_upper c x). + apply r_disjoint. + split ; auto. apply (r_upper_upper c y x) ; auto. exists q ; auto. - intros q r H. assert (G : ((q + q + r) * (1#3) < (q + r + r) * (1#3))%R). + exists ((q + r) * (1#2)) ; split. * apply (Qmult_lt_r _ _ (6#1)); [reflexivity | idtac]. apply (Qplus_lt_r _ _ (- (3#1) * q - (2#1) * r)). now ring_simplify. * apply (Qmult_lt_r _ _ (6#1)); [reflexivity | idtac]. apply (Qplus_lt_r _ _ (- (2#1) * q - (3#1) * r)). now ring_simplify. + destruct (r_located c ((q + q + r) * (1#3)) ((q + r + r) * (1#3)) G). * left; exists ((q + q + r) * (1#3)) ; split ; auto. apply (Qmult_lt_r _ _ (3#1)); [reflexivity | idtac]. apply (Qplus_lt_r _ _ (- (2#1) * q)). now ring_simplify. * right ; exists ((q + r + r) * (1#3)) ; split ; auto. apply (Qmult_lt_r _ _ (3#1)); [reflexivity | idtac]. apply (Qplus_lt_r _ _ (- (2#1) * r)). now ring_simplify. Defined. Theorem dedekind_complete : forall c : RCut, RCut_eq c (RCut_of_R (R_of_RCut c)). 
o with | objBit b => 1 | objBytes o => 8 * (length o) end. Inductive jrnl_ext_tys : @val jrnl_op -> (ty * ty) -> Prop := | JrnlOpenOpType : jrnl_ext_tys (Œª: "v", ExternalOp OpenOp (Var "v"))%V (unitT, extT JrnlT) | JrnlMkAllocOpType : jrnl_ext_tys (Œª: "v", ExternalOp MkAllocOp (Var "v"))%V (baseT uint64BT, extT AllocT). Instance jrnl_ty: ext_types jrnl_op := {| val_tys := jrnl_val_ty; get_ext_tys := jrnl_ext_tys |}. Definition addrT : ty := impl.struct.t (impl.struct.decl [ "Blkno" :: uint64T; "Off" :: uint64T ])%struct. Record jrnl_map : Type := { jrnlData : gmap addr obj; jrnlKinds : gmap blkno kind; jrnlAllocs : gmap loc u64 }. Definition updateData m a o := {| jrnlData := <[a := o]> (jrnlData m); jrnlKinds := jrnlKinds m; jrnlAllocs := jrnlAllocs m |}. Definition updateAllocs m l max := {| jrnlData := jrnlData m; jrnlKinds := jrnlKinds m; jrnlAllocs := <[l := max]> (jrnlAllocs m) |}. Definition clearAllocs m := {| jrnlData := jrnlData m; jrnlKinds := jrnlKinds m; jrnlAllocs := ‚à |}. Definition offsets_aligned (m : jrnl_map) := (‚àÄ a, a ‚àà dom (jrnlData m) ‚Üí ‚àÉ k, jrnlKinds m !! (addrBlock a) = Some k ‚àß valid_off k (addrOff a)). Definition size_consistent_and_aligned a (o: obj) (jk: gmap blkno kind) := ‚àÉ k, jk !! (addrBlock a) = Some k ‚àß objSz o = bufSz k ‚àß valid_off k (addrOff a). Definition sizes_correct (m : jrnl_map) := (‚àÄ a o, jrnlData m !! a = Some o ‚Üí ‚àÉ k, jrnlKinds m !! (addrBlock a) = Some k ‚àß objSz o = bufSz k). Definition wf_jrnl (m : jrnl_map) := offsets_aligned m ‚àß sizes_correct m. Definition jrnl_state := RecoverableState (jrnl_map). Definition get_jrnl (s: jrnl_state) := match s with | Closed j | Opened j => j end. Instance jrnl_model : ffi_model := recoverable_model jrnl_map (populate {| jrnlData := ‚à ; jrnlKinds := ‚à ; jrnlAllocs := ‚à |}). Existing Instances r_mbind r_fmap. Fixpoint tmapM {Œ£ A B} (f: A -> transition Œ£ B) (l: list A) : transition Œ£ (list B) := match l with | [] => ret [] | x::xs => b ‚Üê f x; bs ‚Üê tmapM f xs; ret (b :: bs) end. Definition allocIdent: transition (state*global_state) loc := l ‚Üê allocateN; modify (prod_map (set heap <[l := Free #()]>) id);; ret l. Existing Instance fallback_genPred. Definition isFreshAlloc (œÉja: gmap loc u64) (l: loc) := œÉja !! l = None. Theorem fresh_locs_isFreshAlloc œÉja : isFreshAlloc œÉja (fresh_locs (dom œÉja)). 
Resolve clos_rtn1_rt : main. #[local] Hint Resolve clos_rt_rtn1 : main. Theorem rootUniquelyReachable : forall n, verticallyReachable n root -> n = root. Proof. clean. assert (clos_refl_trans_n1 proxies n root); magic. pose proof rootProxy. induction H0; magic. assert (y = z); magic. Qed. #[export] Hint Resolve rootUniquelyReachable : main. Theorem rootProxyUniqueness : forall n, proxy n = n -> n = root. Proof. clean. induction (rootReach n); magic. Qed. #[export] Hint Resolve rootProxyUniqueness : main. Theorem rootReachUniqueness : forall n1, (forall n2, verticallyReachable n1 n2) -> n1 = root. Proof. magic. Qed. #[export] Hint Resolve rootReachUniqueness : main. Definition reachable := clos_refl_trans edge. #[export] Hint Unfold reachable : main. Theorem horizontalSoundness : forall n1 n2, horizontallyReachable n1 n2 -> reachable n1 n2. Proof. clean. induction H; magic. apply rt_trans with (y := y); magic. Qed. #[export] Hint Resolve horizontalSoundness : main. Theorem horizontalCovalency : forall n1 n2, horizontallyReachable n1 n2 -> proxy n1 = proxy n2. Proof. clean. induction H; magic. Qed. #[export] Hint Resolve horizontalCovalency : main. Theorem proxyUniqueness : forall n1 n2 n3, proxies n1 n3 -> proxies n2 n3 -> n1 = n2. Proof. magic. Qed. #[export] Hint Resolve proxyUniqueness : main. Theorem proxySoundness : forall n, proxies (proxy n) n. Proof. clean. assert (clos_refl_trans_n1 proxies root n). - apply clos_rt_rtn1. apply rootReach. - invert H. + split; magic. exists root. split; magic. + invert H0. magic. Qed. #[export] Hint Resolve proxySoundness : main. Theorem verticalProxyReach : forall n, verticallyReachable (proxy n) n. Proof. magic. Qed. #[export] Hint Resolve verticalProxyReach : main. Theorem verticalSoundness : forall n1 n2, verticallyReachable n1 n2 -> reachable n1 n2. Proof. clean. induction H; magic. - invert H. invert H1. apply rt_trans with (y := x); magic. apply horizontalSoundness. magic. - apply rt_trans with (y := y); magic. Qed. #[export] Hint Resolve verticalSoundness : main. Theorem verticalAntisymmetry : forall n1 n2, verticallyReachable n1 n2 -> verticallyReachable n2 n1 -> n1 = n2. Proof. clean. assert (n1 <> n2 -> verticallyReachable n2 root). - assert (clos_refl_trans_1n proxies root n1). + apply clos_rt_rt1n. apply rootReach. + induction H1; magic. clean. assert (clos_refl_trans_n1 proxies n2 y); magic. destruct H4. * assert (clos_refl_trans_n1 proxies z n2); magic. destruct H4; magic. assert (x = y); magic. apply rt_trans with (y := z); magic. * assert (x = y); magic. - destruct (classic (n1 = n2)); magic. pose proof (rootUniquelyReachable n2). magic. Qed. #[export] Hint Resolve verticalAntisymmetry : main. Theorem verticalAncestorsTotallyOrdered : forall n1 n2 n3, verticallyReachable n1 n3 -> verticallyReachable n2 n3 -> verticallyReachable n1 n2 \/ verticallyReachable n2 n1. 
(_ \/ _) |- _ => clear H end. intuition; try lia; [|find_copy_apply_lem_hyp UniqueIndices_invariant; unfold UniqueIndices in *; intuition; eapply rachet; [symmetry|idtac|idtac|idtac|idtac]; eauto]. exfalso. find_eapply_lem_hyp findAtIndex_max_thing; eauto; try break_exists; try congruence; eauto using entries_max_thing. + repeat find_rewrite. find_copy_apply_lem_hyp state_machine_safety_invariant. find_copy_apply_lem_hyp max_index_sanity_invariant. unfold state_machine_safety, maxIndex_sanity in *. intuition. find_copy_apply_lem_hyp logs_sorted_invariant. unfold logs_sorted in *. intuition. eapply removeAfterIndex_same_sufficient'; eauto using logs_contiguous. * intros. eapply entries_gt_0; intuition eauto. * intros. copy_eapply_prop_hyp state_machine_safety_nw In; unfold commit_recorded in *; simpl in *; repeat (forwards; [intuition eauto; lia|]; concludes). match goal with H : _ /\ (_ \/ _) |- _ => clear H end. intuition; try lia; try solve [find_apply_lem_hyp logs_contiguous; auto; lia]. exfalso. subst. break_exists. intuition. find_false. find_apply_lem_hyp maxIndex_non_empty. break_exists. intuition. repeat find_rewrite. f_equal. find_apply_lem_hyp findAtIndex_elim. intuition. eapply uniqueIndices_elim_eq with (xs := log st'); eauto using sorted_uniqueIndices. unfold state_machine_safety_nw in *. eapply_prop_hyp commit_recorded In; intuition; eauto; try lia; try solve [find_apply_lem_hyp logs_contiguous; auto; lia]. unfold commit_recorded. intuition. + repeat find_rewrite. find_copy_apply_lem_hyp logs_sorted_invariant. unfold logs_sorted in *. intuition. eapply removeAfterIndex_same_sufficient'; eauto using logs_contiguous. * { intros. do_in_app. intuition. - eapply entries_gt_0; eauto. reflexivity. - find_apply_lem_hyp removeAfterIndex_in. find_apply_lem_hyp logs_contiguous; eauto. } * find_apply_lem_hyp max_index_sanity_invariant. unfold maxIndex_sanity in *. intuition. * intros. find_copy_apply_lem_hyp state_machine_safety_invariant. unfold state_machine_safety in *. break_and. copy_eapply_prop_hyp state_machine_safety_nw In; eauto. simpl in *. intuition eauto. forwards; eauto. concludes. forwards; [unfold commit_recorded in *; intuition eauto|]. concludes. intuition; apply in_app_iff; try solve [right; eapply removeAfterIndex_le_In; eauto; lia]; exfalso. find_eapply_lem_hyp findAtIndex_max_thing; eauto using entries_max_thing. break_exists; congruence. + break_exists. intuition. subst. repeat find_rewrite. find_copy_apply_lem_hyp logs_sorted_invariant. unfold logs_sorted in *. intuition. eapply removeAfterIndex_same_sufficient'; eauto using logs_contiguous. * { intros. do_in_app. intuition. - eapply entries_gt_0; eauto. reflexivity. - find_apply_lem_hyp removeAfterIndex_in. find_apply_lem_hyp logs_contiguous; eauto. } * find_apply_lem_hyp max_index_sanity_invariant. unfold maxIndex_sanity in *. intuition. * { intros. find_copy_apply_lem_hyp state_machine_safety_invariant. unfold state_machine_safety in *. break_and. copy_eapply_prop_hyp state_machine_safety_nw In; eauto. simpl in *. intuition eauto. forwards; eauto. concludes. forwards; [unfold commit_recorded in *; intuition eauto|]. concludes. intuition; apply in_app_iff; try solve [right; eapply removeAfterIndex_le_In; eauto; lia]. subst. find_apply_lem_hyp maxIndex_non_empty. break_exists. intuition. repeat find_rewrite. find_apply_lem_hyp findAtIndex_elim. intuition. find_false. f_equal. eapply uniqueIndices_elim_eq with (xs := log (nwState net h)); eauto using sorted_uniqueIndices. unfold state_machine_safety_nw in *. eapply rachet; eauto using sorted_app, sorted_uniqueIndices. copy_eapply_prop_hyp commit_recorded In; intuition; eauto; try lia; unfold commit_recorded; intuition. - exfalso. pose proof entries_gt_pli. eapply_prop_hyp AppendEntries AppendEntries; [|idtac|simpl; eauto|]; eauto. lia. - exfalso. pose proof entries_gt_pli. eapply_prop_hyp AppendEntries AppendEntries; [|idtac|simpl; eauto|]; eauto. lia. } - apply applied_entries_log_lastApplied_update_same; eauto using handleAppendEntriesReply_same_log, handleAppendEntriesReply_same_lastApplied. Qed. Theorem handleTimeout_log : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> log st' = log st. 
extensionality. simpl. rewrite (sepcon_comm (nth a l1 emp)). repeat rewrite sepcon_assoc. f_equal. apply fold_right_sepcon_deletenth. Qed.Lemma map_delete_nth {A B} (f:A->B): forall n l, delete_nth n (map f l) = map f (delete_nth n l). Proof. induction n; intros; destruct l; simpl; trivial. rewrite IHn. trivial. Qed.Fixpoint my_nth {A} (n : nat) (l : list A) (default : A) {struct l} : A := match n with | 0%nat => match l with | [] => default | x :: _ => x end | S m => match l with | [] => default | _ :: t => my_nth m t default end end.Lemma my_nth_nth {A}: forall n l (d:A), my_nth n l d = nth n l d. Proof. induction n; destruct l; intros; simpl; trivial. Qed.Fixpoint my_delete_nth {A} (n:nat) (xs:list A) : list A := match n with | 0%nat => match xs with | [] => [] | _ :: ys => ys end | S n' => match xs with | [] => [] | y :: ys => y :: my_delete_nth n' ys end end.Lemma my_delete_nth_delete_nth {A}: forall n (l:list A), my_delete_nth n l = delete_nth n l. Proof. induction n; destruct l; intros; simpl; trivial. Qed.Fixpoint my_freezelist_nth (l: list nat) (al: list mpred): (list mpred) * (list mpred) := match l with | nil => (nil,al) | (n::l') => let (xs, ys) := my_freezelist_nth l' al in (my_nth n ys emp::xs, my_delete_nth n ys) end. Lemma my_freezelist_nth_freezelist_nth: forall l al, my_freezelist_nth l al = freezelist_nth l al. Proof. induction l; simpl; intros; trivial. rewrite IHl; clear IHl. remember (freezelist_nth l al) as F. destruct F. rewrite my_nth_nth, my_delete_nth_delete_nth; trivial. Qed. Lemma freeze_SEP'': forall l Espec {cs: compspecs} Delta P Q R c Post xs ys, (xs, ys) = my_freezelist_nth l R -> @semax cs Espec Delta (PROPx P (LOCALx Q (SEPx (FRZL xs:: ys)))) c Post -> @semax cs Espec Delta (PROPx P (LOCALx Q (SEPx R))) c Post. Proof. intros. rewrite my_freezelist_nth_freezelist_nth in H. eapply freeze_SEP'; eassumption. Qed.Ltac freeze_tac L name := eapply (freeze_SEP'' (map nat_of_Z L)); first [solve [reflexivity] | match goal with | |- semax _ (PROPx _ (LOCALx _ (SEPx ((FRZL ?xs) :: _)))) _ _ => let D := fresh name in set (D:=xs); change xs with (@abbreviate (list mpred) xs) in D; simpl nat_of_Z; unfold my_delete_nth end].Module ZOrder <: Orders.TotalLeBool. Definition t := Z. Definition leb := Z.leb. Theorem leb_total : forall a1 a2, Z.leb a1 a2 = true \/ Z.leb a2 a1 = true. 
Require Import Prog. Require Import Log. Require Import BFile. Require Import Word. Require Import Omega. Require Import BasicProg. Require Import Bool. Require Import Pred PredCrash. Require Import DirName. Require Import Hoare. Require Import GenSepN. Require Import ListPred. Require Import SepAuto. Require Import Idempotent. Require Import Inode. Require Import List ListUtils. Require Import Balloc. Require Import Bytes. Require Import DirTree. Require Import Rec. Require Import Arith. Require Import Array. Require Import FSLayout. Require Import Cache. Require Import Errno. Require Import AsyncDisk. Require Import GroupLog. Require Import DiskLogHash. Require Import SuperBlock. Require Import DiskSet. Require Import AsyncFS.Set Implicit Arguments. Import ListNotations. Module AFS_RECOVER. Import AFS. Import DirTree. Import DirTreeDef. Parameter cachesize : nat. Axiom cachesize_ok : cachesize <> 0. Hint Resolve cachesize_ok. Notation MSLL := BFILE.MSLL. Notation MSAlloc := BFILE.MSAlloc. Theorem file_getattr_recover_ok : forall fsxp inum mscs, {X<< ds sm pathname Fm Ftop tree f ilist frees, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: (Fm * DirTreeRep.rep fsxp Ftop tree ilist frees mscs sm) ]]] * [[ find_subtree pathname tree = Some (TreeFile inum f) ]] POST:hm' RET:^(mscs',r) LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[ r = DFAttr f ]] REC:hm' RET:r exists mscs fsxp, exists d sm' n, LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn (d, nil)) (MSLL mscs) sm' hm' * [[ n <= length (snd ds) ]] * [[[ d ::: crash_xform (diskIs (list2nmem (nthd n ds))) ]]] >>X} file_get_attr fsxp inum mscs >> recover cachesize. Proof. unfold forall_helper. recover_ro_ok. destruct v. cancel. eauto. step. norm'l. unfold stars; simpl. cancel. eassign_idempred. simpl_idempred_l. xform_norml; rewrite SB.crash_xform_rep; (rewrite LOG.notxn_after_crash_diskIs || rewrite LOG.rollbacktxn_after_crash_diskIs); try eassumption. cancel. safestep; subst. 2: eauto. simpl_idempred_r. eauto. simpl_idempred_r. rewrite <- LOG.before_crash_idempred. cancel. auto. cancel. safestep; subst. 2:eauto. simpl_idempred_r. eauto. simpl_idempred_r. rewrite <- LOG.before_crash_idempred. cancel. auto. Qed. Theorem read_fblock_recover_ok : forall fsxp inum off mscs, {X<< ds sm Fm Ftop tree pathname f Fd vs ilist frees, PRE:hm LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs) sm hm * [[[ ds!! ::: (Fm * DirTreeRep.rep fsxp Ftop tree ilist frees mscs sm)]]] * [[ find_subtree pathname tree = Some (TreeFile inum f) ]] * [[[ (DFData f) ::: (Fd * off |-> vs) ]]] POST:hm' RET:^(mscs', r) LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn ds) (MSLL mscs') sm hm' * [[ r = fst vs ]] REC:hm' RET:r exists mscs fsxp, exists d sm' n, LOG.rep (FSXPLog fsxp) (SB.rep fsxp) (LOG.NoTxn (d, nil)) (MSLL mscs) sm' hm' * [[ n <= length (snd ds) ]] * [[[ d ::: crash_xform (diskIs (list2nmem (nthd n ds))) ]]] >>X} read_fblock fsxp inum off mscs >> recover cachesize. 
Require Import Relation_Definitions. Require Import Relation_Operators.Section Wf_Transitive_Closure. Variable A : Type. Variable R : relation A. Notation trans_clos := (clos_trans A R). Lemma incl_clos_trans : inclusion A R trans_clos. red; auto with sets. Qed. Lemma Acc_clos_trans : forall x:A, Acc R x -> Acc trans_clos x. induction 1 as [x0 _ H1]. apply Acc_intro. intros y H2. induction H2; auto with sets. apply Acc_inv with y; auto with sets. Defined. Hint Resolve Acc_clos_trans. Lemma Acc_inv_trans : forall x y:A, trans_clos y x -> Acc R x -> Acc R y. Proof. induction 1 as [| x y]; auto with sets. intro; apply Acc_inv with y; assumption. Qed. Theorem wf_clos_trans : well_founded R -> well_founded trans_clos. 
x => PS.mem x (Mem.memories (n_eqs n)))) as E; setoid_rewrite E; clear E. setoid_rewrite filter_In. setoid_rewrite <-PSE.MP.Dec.F.mem_iff. unfold Mem.memories, fbys in *. induction (n_eqs n) as [|[]]; inversion_clear WT as [|?? WTeq]; simpl; auto. + split; try contradiction. setoid_rewrite PSE.MP.Dec.F.empty_iff; intuition. + inversion_clear WTeq as [| | |???? Hint]. intros (x, t); split. *{ intros * (Hin & Mem); apply in_fbys_spec; apply In_fold_left_memory_eq in Mem as [Mem|Mem]. - apply In_fold_left_memory_eq in Mem as [Mem|Mem]; [|rewrite PSE.MP.Dec.F.empty_iff in Mem; contradiction]. left; apply IHl; auto. intros * Hin'; apply Spec; simpl; auto. - apply PSE.MP.Dec.F.add_iff in Mem as [E|Mem]; [|rewrite PSE.MP.Dec.F.empty_iff in Mem; contradiction]. inv E. right; constructor; simpl. assert (In (x, t) (idty (n_in n ++ n_vars n ++ n_out n))) as Hin' by (rewrite 2 idty_app, 2 in_app; auto). f_equal. eapply NoDupMembers_det; eauto. apply NoDupMembers_idty, n_nodup. } *{ intros * Hin; rewrite In_fold_left_memory_eq; apply in_fbys_spec in Hin as [Hin|Hin]. - apply IHl in Hin; auto. + intuition. + intros * Hin'; apply Spec; simpl; auto. - inversion_clear Hin as [E|]; try contradiction; inv E. rewrite PSE.MP.Dec.F.add_iff; intuition. simpl in Spec. assert (InMembers x (n_vars n)) as Hin by auto. pose proof (n_nodup n) as Hnodup. rewrite fst_NoDupMembers, 2 map_app, NoDup_swap, <- 2 map_app, <-fst_NoDupMembers in Hnodup. eapply NoDupMembers_app_InMembers, NotInMembers_app in Hnodup as (? & ?); eauto. rewrite 2 idty_app, 2 in_app in Hint; destruct Hint as [Hint|[|Hint]]; auto; apply In_InMembers in Hint; rewrite InMembers_idty in Hint; contradiction. } Qed. Lemma translate_node_wt: forall G n, wt_node G n -> wt_system (translate G) (translate_node n). Proof. unfold wt_node, wt_system; intros * WT; simpl. eapply translate_eqns_wt; eauto. - repeat rewrite idty_app. rewrite <-app_assoc. apply Permutation_app_head. rewrite Permutation_app_comm, app_assoc. apply Permutation_app_tail. rewrite fbys_gather_eqs, <-fst_partition_memories_fbys; eauto. setoid_rewrite ps_from_list_gather_eqs_memories. rewrite <-idty_app. apply Permutation_map. rewrite <-permutation_partition; auto. - setoid_rewrite fbys_gather_eqs. unfold gather_mems, fbys. induction (n_eqs n) as [|[] eqs]; simpl; intros * Hin Mem; try contradiction; inversion_clear WT as [|?? WTeq]; auto. inv WTeq. apply in_fbys_spec. destruct Mem as [|Mem]. + subst. right; constructor. f_equal. eapply NoDupMembers_det; eauto. apply NoDupMembers_idty, n_nodup. + left; auto. - intros * Hin IsV. rewrite 2 idty_app, 2 in_app. rewrite 2 idty_app, 2 in_app in Hin; destruct Hin as [|[|]]; auto. right; left. setoid_rewrite ps_from_list_gather_eqs_memories. rewrite snd_partition_filter. pose proof (filter_fst_idty _ _(n_vars n) (fun x => negb (PS.mem x (Mem.memories (n_eqs n))))) as E; setoid_rewrite E; clear E. rewrite filter_In, Bool.negb_true_iff, <-PSE.MP.Dec.F.not_mem_iff. intuition. eapply not_Is_variable_in_memories; eauto. apply NoDup_defs_node. Qed. Hint Resolve translate_node_wt. Theorem translate_wt: forall G, wt_global G -> wt_program (translate G). 
struct_mapsto_agree l t q1 v1 q2 v2 : l ‚Ü¶[t]{q1} v1 -‚àó l ‚Ü¶[t]{q2} v2 -‚àó ‚åúv1 = v2‚åù. Proof. iIntros "Hl1 Hl2". iDestruct (struct_mapsto_ty with "Hl1") as %Hty1. iDestruct (struct_mapsto_ty with "Hl2") as %Hty2. pose proof (val_ty_len Hty1). pose proof (val_ty_len Hty2). iDestruct (struct_mapsto_agree_flatten with "Hl1 Hl2") as %Heq. { congruence. } iPureIntro. eapply flatten_struct_inj; eauto. Qed. Lemma byte_mapsto_untype l q (x: u8) : l ‚Ü¶[byteT]{q} #x ‚ä£‚ä¢ l ‚Ü¶{q} #x. Proof. rewrite struct_mapsto_eq /struct_mapsto_def /=. rewrite loc_add_0 right_id. iSplit. - iDestruct 1 as "[$ _]". - iDestruct 1 as "$". auto. Qed. Theorem base_mapsto_untype {l bt q v} : match bt with | unitBT => false | _ => true end = true -> l ‚Ü¶[baseT bt]{q} v ‚ä£‚ä¢ l ‚Ü¶{q} v ‚àó ‚åúval_ty v (baseT bt)‚åù. Proof. intros Hnotunit. iSplit. - iIntros "Hl". iDestruct (struct_mapsto_ty with "Hl") as %Hty. rewrite struct_mapsto_singleton; eauto. inv_ty; simpl; auto. congruence. - iIntros "[Hl %]". unseal. iSplitL; auto. inv_ty; simpl; try rewrite loc_add_0 right_id; auto. Qed. Theorem base_load_ty {bt} : match bt with | unitBT => false | _ => true end = true -> load_ty (baseT bt) = (Œª: "l", !(Var "l"))%V. Proof. destruct bt; simpl; intros; auto. congruence. Qed. Theorem wp_base_load stk E bt (l:loc) (Œ¶: val -> iProp Œ£) : match bt with | unitBT => false | _ => true end = true -> (‚àÄ le, ‚åúAtomic StronglyAtomic le‚åù -‚àó (‚àÄ q v, {{{ l ‚Ü¶[baseT bt]{q} v }}} le @ stk; E {{{ RET v; l ‚Ü¶[baseT bt]{q} v }}}) -‚àó WP le @ stk; E {{ Œ¶ }}) -‚àó WP load_ty (baseT bt) #l @ stk; E {{ Œ¶ }}. Proof. intros Hnotunit. iIntros "Hle". rewrite -> base_load_ty by auto. wp_lam. iApply "Hle". { iPureIntro. apply _. } iIntros (q v Œ¶') "!> Hl HŒ¶'". iDestruct (struct_mapsto_ty with "Hl") as %Hty. iDestruct (base_mapsto_untype with "Hl") as "[Hl _]"; auto. wp_apply (wp_load with "Hl"). iIntros "Hl". iApply "HŒ¶'". iApply (base_mapsto_untype with "[$Hl]"); eauto. Qed. Theorem struct_mapsto_prod q l v1 t1 v2 t2 : l ‚Ü¶[t1 * t2]{q} (v1, v2) ‚ä£‚ä¢ l ‚Ü¶[t1]{q} v1 ‚àó (l +‚Çó ty_size t1) ‚Ü¶[t2]{q} v2. Proof. unseal. rewrite /struct_mapsto /= big_opL_app. iSplit. - iIntros "[[Hv1 Hv2] %]". inversion H; subst; clear H. iSplitL "Hv1"; iFrame; eauto. iSplitL; eauto. erewrite val_ty_flatten_length by eauto. setoid_rewrite ty_size_offset. iFrame. - iIntros "[[Hv1 %] [Hv2 %]]". erewrite val_ty_flatten_length by eauto. setoid_rewrite ty_size_offset. iFrame. iPureIntro. constructor; auto. Qed. Theorem nat_scaled_offset_to_Z {v t} {i: nat} : val_ty v t -> Z.of_nat (length (flatten_struct v)) * i = ty_size t * Z.of_nat i. 
as Œº. pose proof (ordMin_correct Œ±‚Å∫ P) as [HŒº Hmin]... { exists Œ±. split. apply BUnionI2... split... } fold Œº in HŒº, Hmin. apply SepE in HŒº as [HŒºŒ± [HPŒº HŒº]]. exists Œº. split... split... intros x HPx Hx. destruct (classic (x ‚àà Œ±‚Å∫)) as [HxŒ±|HxŒ±]. + assert (x ‚àà {Œæ ‚àä Œ±‚Å∫ | P Œæ}). apply SepI... split... apply Hmin in H as []... apply binRelE3 in H... + assert (HoŒº: Œº ‚ãµ ùêéùêç). apply Hsub... assert (Hox: x ‚ãµ ùêéùêç). apply Hsub... destruct (classic (Œº = x)) as [|Hnq]... apply ord_connected in Hnq as []... exfalso. apply HxŒ±. eapply ord_trans... - intros x y [HxC [Hx H1]] [HyC [Hy H2]]. apply H1 in Hy... apply H2 in Hx... destruct Hx; destruct Hy... exfalso. eapply ord_not_lt_gt; revgoals... Qed. Global Hint Immediate Œ≥_functional : core. Lemma enum_spec : ‚àÄ C, C ‚´É ùêéùêç ‚Üí unbounded C ‚Üí ‚àÄŒ± ‚ãµ ùêéùêç, ‚àÄŒæ ‚ãµ C, Œæ ‚àâ {Enumerate C x | x ‚àä Œ±} ‚Üí Enumerate C Œ± ‚ã∏ Œæ. Proof with auto. intros C Hsub Hund Œ± HoŒ± Œæ HŒæC Hout. pose proof (recursion_spec (Œ≥ C) Œ±) as [_ [_ Hmin]]... apply Hmin... rewrite ran_of_op_repl... Qed. Lemma enum_into_class : ‚àÄ C, C ‚´É ùêéùêç ‚Üí unbounded C ‚Üí Enumerate C :·∂ú ùêéùêç ‚áí C. Proof. intros C Hsub Hund Œ± HoŒ±. unfold Enumerate. apply (recursion_spec (Œ≥ C) Œ±); auto. Qed. Lemma enum_operative : ‚àÄ C, C ‚´É ùêéùêç ‚Üí unbounded C ‚Üí Enumerate C :·∂ú ùêéùêç ‚áí ùêéùêç. Proof. intros C Hsub Hund Œ± HoŒ±. apply Hsub. apply enum_into_class; auto. Qed. Theorem enum_monotone : ‚àÄ C, C ‚´É ùêéùêç ‚Üí unbounded C ‚Üí monotone (Enumerate C). Proof with eauto. intros C Hsub Hund Œ± HoŒ± Œ≤ HŒ≤. assert (HoŒ≤: Œ≤ ‚ãµ ùêéùêç). eapply ord_is_ords... pose proof (recursion_spec (Œ≥ C) Œ±) as [Hinf [Hout _]]... pose proof (recursion_spec (Œ≥ C) Œ≤) as [_ [_ Hmin]]... fold (Enumerate C) in *. rewrite ran_of_op_repl in *. assert (Enumerate C Œ± ‚àâ {Enumerate C x | x ‚àä Œ≤}). { intros H. apply ReplAx in H as [Œ¥ [HŒ¥ H]]. apply Hout. rewrite <- H. apply ReplI. eapply ord_trans... } apply Hmin in H as []... exfalso. apply Hout. rewrite <- H. apply ReplI... Qed. Corollary enum_injective : ‚àÄ C, C ‚´É ùêéùêç ‚Üí unbounded C ‚Üí class_injective (Enumerate C) ùêéùêç. Proof with eauto. intros C Hsub Hund. eapply monotone_operation_injective... apply enum_into_class... apply enum_monotone... Qed. Theorem enum_surjective : ‚àÄ C, C ‚´É ùêéùêç ‚Üí unbounded C ‚Üí class_surjective (Enumerate C) ùêéùêç C. 
x -> ForAllS P x. Definition Inevitable (Sini : S) (P : Stream S -> Prop) := forall x : Stream S, isTraceFrom Sini x -> ExistsS P x. Inductive Posible (Sini : S) (P : Stream S -> Prop) : Prop := posible : forall x : Stream S, isTraceFrom Sini x -> ExistsS P x -> Posible Sini P. Inductive SafePath (Sini : S) (P : Stream S -> Prop) : Prop := safePath : forall x : Stream S, isTraceFrom Sini x -> ForAllS P x -> SafePath Sini P. Theorem Equiv1 : forall (Sini : S) (P : Stream S -> Prop), Posible Sini P <-> EX_Until Sini (fun _ : Stream S => True) P. Proof. unfold iff in |- *; intros; split; intro. inversion_clear H. apply ExUntil with (P := fun _ : Stream S => True) (1 := H0). elim H1; intros. constructor 2; assumption. constructor 1; trivial. inversion_clear H. apply posible with (1 := H0). elim H1; intros. constructor 2; assumption. constructor 1; assumption. Qed. Theorem Equiv2 : forall (Sini : S) (P : Stream S -> Prop), Inevitable Sini P <-> FA_Until Sini (fun _ : Stream S => True) P. Proof. unfold iff, Inevitable, FA_Until in |- *; intros; split; intros. elim (H x H0); intros. constructor 2; assumption. constructor 1; trivial. elim (H x H0); intros. constructor 2; assumption. constructor 1; assumption. Qed. Lemma ConsTrace : forall (s1 s2 : S) (x z : Stream S), isTraceFrom s2 z -> isTraceFrom s1 (s1 ^ s2 ^ x) -> isTraceFrom s1 (s1 ^ z). Proof. unfold isTraceFrom in |- *; simpl in |- *. simple destruct z; simple destruct 1; simple destruct 3; simpl in |- *; intros. compute in H0; rewrite H0 in H4. inversion_clear H4 in H1. split; [ trivial | apply (isTraceTick H5 H1) ]. split; [ trivial | apply (isTraceDisc H5 H6 H1) ]. Qed. Lemma notPosible : forall (P : Stream S -> Prop) (s1 : S), ~ Posible s1 P -> forall (z : Stream S) (s2 : S), isTraceFrom s1 (s1 ^ s2 ^ z) -> ~ Posible s2 P. Proof. unfold not at 2 in |- *; intros. elim H1; intros. apply H; cut (isTraceFrom s1 (s1 ^ x)). intro H4; apply (posible (P:=P) H4). apply Further; assumption. apply ConsTrace with (1 := H2) (2 := H0); assumption. Qed. Require Import Classical. Theorem Equiv3 : forall (Sini : S) (P : Stream S -> Prop), Always Sini P <-> ~ Posible Sini (fun s : Stream S => ~ P s). 
V' x) -> rw <> "len" -> inputOk V' es. induction 1; do 2 inversion_clear 1; subst; simpl; intuition; constructor; auto. destruct x; simpl in *; intuition idtac. repeat rewrite <- H1 by congruence; assumption. Qed. Hint Extern 1 (inputOk _ _) => eapply inputOk_weaken_delete; try eassumption; [ solve [ eauto 1 ] | solve [ descend ] ]. Lemma four_shimmy : forall a b c, c = a -> c = 4 * b -> a = b * 4. intros; omega. Qed. Hint Immediate four_shimmy. Lemma derows : forall P Q P' sch head, P ===> P' -> P * Q ===> Q * (P' * rows sch head nil). sepLemma. Qed. Require Import Coq.Arith.Arith. Lemma row_free' : forall p n m, (p ^+ natToW 8) =?> n * (p ^+ natToW 8 ^+ natToW (n * 4)) =?> m ===> allocated p 8 (n + m). sepLemma. eapply Himp_trans; [ | apply allocated_join ]. apply Himp_star_frame; apply allocated_shift_base; eauto. words. rewrite natToW_plus. rewrite (mult_comm 4). rewrite natToW_times4. rewrite natToW_times4. rewrite plus_0_r. words. omega. omega. Qed. Lemma row_free : forall p n m, (Ex ls1, Ex ls2, array ls1 (p ^+ natToW 8) * [| length ls1 = n |] * array ls2 (p ^+ natToW 8 ^+ natToW (n * 4)) * [| length ls2 = m |]) ===> allocated p 8 (n + m). intros; eapply Himp_trans; [ | apply row_free' ]. sepLemma; apply Himp_star_frame; (eapply Himp_trans; [ | apply MoreArrays.free_array' ]; sepLemma). Qed. Lemma rhints : TacPackage. prepare tt row_free. Defined. Hint Rewrite length_posl length_lenl : sepFormula. Hint Extern 1 (@eq nat _ _) => omega. Lemma inBounds_times4 : forall m w ls r, inBounds w ls -> m = wordToNat w -> m = 4 * r -> inBounds (natToW (r * 4)) ls. intros; subst. rewrite mult_comm in H1. apply (f_equal natToW) in H1. rewrite natToW_wordToNat in *; subst. auto. Qed. Hint Immediate inBounds_times4. Lemma div4_out : forall n w r, n = wordToNat w -> n = 4 * wordToNat r -> w = r ^* natToW 4. intros; subst. match goal with | [ |- ?x = ?y ] => assert (wordToNat x = wordToNat y) end. rewrite H0. rewrite wordToNat_wmult. apply mult_comm. apply goodSize_weaken with (wordToNat w). eauto. change (wordToNat (natToW 4)) with 4. omega. apply (f_equal natToW) in H. repeat rewrite natToW_wordToNat in H; assumption. Qed. Hint Immediate div4_out. Theorem Delete_post : forall im mn (H : importsGlobal im) ns res pre specs st, (forall (specs0 : codeSpec W (settings * state)) (st0 : settings * state), interp specs0 (pre st0) -> interp specs0 (dinvar true (fun x : W => x) ns res st0)) -> vcs (DeleteVcs im ns res) -> interp specs (Postcondition (toCmd Delete' mn H ns res pre) st) -> interp specs (dinvar true (fun x : W => x) ns res st). 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Tactics.Example and_exercise : forall n m : nat, n + m = 0 -> n = 0 /\ m = 0. Admitted. Instance testSuchThat_Conj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, Q b -> prop a b)} : Checkable (forall a b, P a /\ Q b -> prop a b) := {| checker f := checker (fun a P b Q => f a b _ ) |}. Proof. split; auto. Defined.Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Admitted. Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Admitted. Instance testSuchThat_Disj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, prop a b)} `{Checkable (forall b, Q b -> forall a, prop a b)} : Checkable (forall a b, P a \/ Q b -> prop a b) := {| checker f := disjoin (Datatypes.cons (checker (fun a P b => f a b _ )) (Datatypes.cons (checker (fun b Q a => f a b _)) Datatypes.nil)) |}. Proof. - left; auto. - right; auto. Defined. Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Admitted. Lemma or_intro : forall A B : Prop, A -> A \/ B. Admitted. Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Admitted. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Admitted. Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. 
y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.Module SimpleArith2. Import SimpleArith1.Theorem step_deterministic: deterministic step. Admitted. End SimpleArith2.Ltac solve_by_inverts n := match goal with | H : ?T |- _ => match type of T with Prop => solve [ inversion H; match n with S (S (?n')) => subst; solve_by_inverts (S n') end ] end end.Ltac solve_by_invert := solve_by_inverts 1. Module SimpleArith3. Import SimpleArith1.Theorem step_deterministic_alt: deterministic step. Admitted. End SimpleArith3.Inductive value : tm -> Prop := | v_const : forall n, value (C n).Instance dec_value t : Dec (value t). constructor; unfold decidable. destruct t. - left; constructor; auto. - right=> contra. inversion contra. Defined. Derive ArbitrarySizedSuchThat for (fun t => value t).Reserved Notation " t '===>' t' " (at level 40).Inductive step : tm -> tm -> Prop := | ST_PlusConstConst : forall n1 n2, P (C n1) (C n2) ===> C (n1 + n2) | ST_Plus1 : forall t1 t1' t2, t1 ===> t1' -> P t1 t2 ===> P t1' t2 | ST_Plus2 : forall v1 t2 t2', value v1 -> t2 ===> t2' -> P v1 t2 ===> P v1 t2' where " t '===>' t' " := (step t t').Theorem step_deterministic : deterministic step. Admitted. Definition step_fun (t : tm) : option tm := Some t.Axiom step_fun_correct : forall t t', step_fun t = Some t' <-> step t t'.Instance dec_step (t : tm) : Dec (exists t', step t t') := {| dec := _ |}. Proof. destruct (step_fun t) eqn:Step. - left; exists t0; eapply step_fun_correct; eauto. - right => [[t' contra]]. eapply step_fun_correct in contra; congruence. Defined.Theorem strong_progress : forall t, value t \/ (exists t', t ===> t'). Admitted. QuickChick strong_progress. Definition normal_form {X:Type} (R:relation X) (t:X) : Prop := ~ exists t', R t t'.Lemma value_is_nf : forall v, value v -> normal_form step v. Admitted. Lemma nf_is_value : forall t, normal_form step t -> value t. Admitted. Inductive multi {X:Type} (R: relation X) : relation X := | multi_refl : forall (x : X), multi R x x | multi_step : forall (x y z : X), R x y -> multi R y z -> multi R x z.Notation " t '===>*' t' " := (multi step t t') (at level 40).Theorem multi_R : forall (X:Type) (R:relation X) (x y : X), R x y -> (multi R) x y. Admitted. Theorem multi_trans : forall (X:Type) (R: relation X) (x y z : X), multi R x y -> multi R y z -> multi R x z. 
((o_base_ derived base, o2) :: d) -> roff_canon s d. Proof. inversion 1; auto. Qed. Lemma roff_canon_o_sub_wf s d ty z o : roff_canon s ((o_sub_ ty z, o) :: d) -> z <> 0. Proof. move E: (_ :: _) => d' Hcn. elim: Hcn E; naive_solver eauto with lia. Qed. Lemma roff_canon_o_sub_no_dup s d o ty1 z ro : roff_canon s ((o_sub_ ty1 z, ro) :: o :: d) -> match o with | (o_sub_ ty2 _, _) => ty1 <> ty2 | _ => True end. Proof. move E: ((o_sub_ _ _, _) :: _) => d' Hcn. elim: Hcn z ro E; naive_solver. Qed. Definition offset_seg_cons (os : offset_seg) (oss : list offset_seg) : list offset_seg := match os, oss with | (o_sub_ ty1 n1, off1), _ => if decide (n1 = 0 /\ off1 = 0)%Z then oss else match oss with | (o_sub_ ty2 n2, off2) :: oss' => if decide (ty1 <> ty2) then os :: oss else if decide (n2 + n1 = 0 /\ off1 + off2 = 0)%Z then oss' else (o_sub_ ty1 (n2 + n1), (off2 + off1)%Z) :: oss' | _ => os :: oss end | (o_derived_ base1 der1, off1), (o_base_ der2 base2, off2) :: oss' => if decide (der1 = der2 /\ base1 = base2) then oss' else os :: oss | (o_invalid_, z), _ => [(o_invalid_, z)] | _, _ => os :: oss end. Definition raw_offset_collapse : raw_offset -> raw_offset := foldr offset_seg_cons []. Arguments raw_offset_collapse !_ /. Definition raw_offset_wf (ro : raw_offset) : Prop := raw_offset_collapse ro = ro. Arguments raw_offset_wf !_ /. #[global] Instance raw_offset_wf_pi ro : ProofIrrel (raw_offset_wf ro) := _. Lemma singleton_raw_offset_wf {os} (Hn0 : isnt os (o_sub_ _ 0, _)) : raw_offset_wf [os]. Proof. destruct os as [[] ?] => //=; case_decide; naive_solver. Qed. #[local] Hint Constructors roff_canon : core. Theorem canon_wf_0 src dst : roff_canon src dst -> roff_canon dst dst. Proof. intros Hrc; induction Hrc; eauto. inversion IHHrc; eauto 2; last have ?: z0 = 0 by [lia]; subst. all: by efeed pose proof roff_canon_o_sub_wf. Qed. Theorem canon_wf' src dst : roff_canon src dst -> raw_offset_collapse src = dst. Proof. rewrite /raw_offset_wf /raw_offset_collapse => Hc; induction Hc => //=; rewrite ?IHHc /offset_seg_cons //=. { by [ rewrite decide_True //=; repeat (lia || f_equal)]. } all: repeat ((case_decide || case_match); destruct_and?; subst => //). by rewrite !right_id_L. Qed. Theorem canon_wf src dst : roff_canon src dst -> raw_offset_wf dst. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). 
q; simpl; try reflexivity; rewrite ?IHp; destruct (sub_mask p q) as [|[r|r| ]|] || destruct p; auto. Qed.Inductive SubMaskSpec (p q : positive) : mask -> Prop := | SubIsNul : p = q -> SubMaskSpec p q IsNul | SubIsPos : forall r, q + r = p -> SubMaskSpec p q (IsPos r) | SubIsNeg : forall r, p + r = q -> SubMaskSpec p q IsNeg.Theorem sub_mask_spec p q : SubMaskSpec p q (sub_mask p q). Proof. revert q. induction p; destruct q; simpl; try constructor; trivial. destruct (IHp q); subst; try now constructor. now apply SubIsNeg with r~0. destruct (IHp q); subst; try now constructor. apply SubIsNeg with (pred_double r). symmetry. apply add_xI_pred_double. rewrite sub_mask_carry_spec. destruct (IHp q); subst; try constructor. now apply SubIsNeg with 1. destruct r; simpl; try constructor; simpl. now rewrite add_carry_spec, <- add_succ_r. now rewrite add_carry_spec, <- add_succ_r, succ_pred_double. now rewrite add_1_r. now apply SubIsNeg with r~1. destruct (IHp q); subst; try now constructor. now apply SubIsNeg with r~0. now rewrite add_1_l, succ_pred_double. now apply SubIsNeg with q~0. apply SubIsNeg with (pred_double q). now rewrite add_1_l, succ_pred_double. Qed.Theorem sub_mask_nul_iff p q : sub_mask p q = IsNul <-> p = q. Proof. split. now case sub_mask_spec. intros <-. induction p; simpl; now rewrite ?IHp. Qed.Theorem sub_mask_diag p : sub_mask p p = IsNul. Proof. now apply sub_mask_nul_iff. Qed.Lemma sub_mask_add p q r : sub_mask p q = IsPos r -> q + r = p. Proof. case sub_mask_spec; congruence. Qed.Lemma sub_mask_add_diag_l p q : sub_mask (p+q) p = IsPos q. Proof. case sub_mask_spec. intros H. rewrite add_comm in H. elim (add_no_neutral _ _ H). intros r H. apply add_cancel_l in H. now f_equal. intros r H. rewrite <- add_assoc, add_comm in H. elim (add_no_neutral _ _ H). Qed.Lemma sub_mask_pos_iff p q r : sub_mask p q = IsPos r <-> q + r = p. Proof. split. apply sub_mask_add. intros <-; apply sub_mask_add_diag_l. Qed.Lemma sub_mask_add_diag_r p q : sub_mask p (p+q) = IsNeg. Proof. case sub_mask_spec; trivial. intros H. symmetry in H; rewrite add_comm in H. elim (add_no_neutral _ _ H). intros r H. rewrite <- add_assoc, add_comm in H. elim (add_no_neutral _ _ H). Qed.Lemma sub_mask_neg_iff p q : sub_mask p q = IsNeg <-> exists r, p + r = q. Proof. split. case sub_mask_spec; try discriminate. intros r Hr _; now exists r. intros (r,<-). apply sub_mask_add_diag_r. Qed. Theorem eqb_eq p q : (p =? q) = true <-> p=q. 
_ _ _ _ co (_,,po)). exists Q. exists s. exists k. assert (e2 : j ¬∑ q = p ¬∑ 0). { rewrite a. now rewrite zeroRight. } assert (PO := iscontrpr1 (po R q 0 e2)). induction PO as [u [e3 e4]]. exists u. assert (ijs := ExactSequenceFromMono (i¬∑j) s L IJ). exists ijs. split. { use (ExactSequenceFromMono k u _ K). exists e4. intros T h e0. assert (e5 : j ¬∑ (s ¬∑ h) = 0). { rewrite assoc. rewrite e1. rewrite assoc'. rewrite e0. now rewrite zeroRight. } assert (W := co' T (s¬∑h) e5); cbn in W. use (iscontrweqf _ W). apply weqfibtototal; intros l. apply weqiff. rewrite <- e3. rewrite assoc'. split. { intros e. now apply (CokernelIsEpi (i¬∑j) s (EC_ExactToCokernel ijs)). } { intros e. now apply maponpaths. } + apply to_has_homsets. + apply to_has_homsets. } split. - exists e1. exact po. - exact e3. Defined. End Tmp. Lemma KernelSequence {M:ExactCategory} {A B C P R:M} (i : B --> A) (j : C --> B) (p : P --> B) (q : R --> C) : isExact2 p i -> isExact2 q j -> ‚àÉ Q (s : Q --> C) (k : Q --> P) (r : R --> Q), isExact2 s (j¬∑i) ‚àß isExact2 r k ‚àß isPullback' (M:=M) j p s k ‚àß r ¬∑ s = q. Proof. exact (CokernelSequence (M := oppositeExactCategory M) i j p q). Defined. Lemma ExactIso3 {M:ExactCategory} {A B C C':M} (i:A-->B) (p:B-->C) (t:z_iso C C') : isExact2 i p -> isExact2 i (p¬∑t). Proof. intros ex. use (EC_IsomorphicToExact _ ex). exists (identity_z_iso A). exists (identity_z_iso B). exists t. repeat split;cbn. - now rewrite id_left, id_right. - now rewrite id_left, id_right. - apply id_left. - apply pathsinv0, id_left. Qed. Lemma ExactIso2 {M:ExactCategory} {A B C B':M} (i:A-->B) (p:B-->C) (t:z_iso B B') : isExact2 i p -> isExact2 (i ¬∑ t) (z_iso_inv t ¬∑ p). Proof. intros ex. use (EC_IsomorphicToExact _ ex). exists (identity_z_iso A). exists t. exists (identity_z_iso C). repeat split;cbn. - exact (id_left _). - exact (! id_left _). - rewrite assoc. rewrite z_iso_inv_after_z_iso. rewrite id_left, id_right. reflexivity. - rewrite assoc. rewrite z_iso_inv_after_z_iso. rewrite id_left, id_right. reflexivity. Qed. Lemma ExactIso1 {M:ExactCategory} {A' A B C:M} (t:z_iso A' A) (i:A-->B) (p:B-->C) : isExact2 i p -> isExact2 (t¬∑i) p. Proof. exact (ExactIso3 (M:=oppositeExactCategory M) p i (opp_z_iso t)). Defined. End ExactCategoryFacts.Section EquivalenceOfTwoDefinitions. Theorem EquivalenceOfTwoDefinitions (D:ExactCategoryData) : ExactCategoryProperties D ‚áî ExactCategoryProperties_Quillen D. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. 
forward. Qed.Definition ext_link := ext_link_prog prog.#[export] Instance Espec : OracleKind := IO_Espec ext_link.Lemma prog_correct: semax_prog prog main_itree Vprog Gprog. Proof. prove_semax_prog. semax_func_cons_ext. { simpl; Intro i. apply typecheck_return_value with (t := Tint16signed); auto. } semax_func_cons_ext. { simpl; Intro i'. apply typecheck_return_value with (t := Tint16signed); auto. } semax_func_cons body_getchar_blocking. semax_func_cons body_putchar_blocking. semax_func_cons body_print_intr. semax_func_cons body_print_int. semax_func_cons body_main. Qed.Require Import VST.veric.SequentialClight. Require Import VST.progs.io_dry.Lemma init_mem_exists : { m | Genv.init_mem prog = Some m }. Proof. unfold Genv.init_mem; simpl. Ltac alloc_block m n := match n with | O => idtac | S ?n' => let m' := fresh "m" in let Hm' := fresh "Hm" in destruct (dry_mem_lemmas.drop_alloc m) as [m' Hm']; alloc_block m' n' end. try first [ alloc_block Mem.empty 62%nat; eexists; repeat match goal with H : ?a = _ |- match ?a with Some m' => _ | None => None end = _ => rewrite H end; reflexivity | alloc_block Mem.empty 60%nat; eexists; repeat match goal with H : ?a = _ |- match ?a with Some m' => _ | None => None end = _ => rewrite H end; reflexivity ]. Qed.Definition init_mem := proj1_sig init_mem_exists.Definition main_block_exists : {b | Genv.find_symbol (Genv.globalenv prog) (AST.prog_main prog) = Some b}. Proof. eexists; simpl. unfold Genv.find_symbol; simpl; reflexivity. Qed.Definition main_block := proj1_sig main_block_exists.Axiom (Jsub: forall ef se lv m t v m' (EFI : ef_inline ef = true) m1 (EFC : Events.external_call ef se lv m t v m'), juicy_mem.mem_sub m m1 -> exists m1' (EFC1 : Events.external_call ef se lv m1 t v m1'), juicy_mem.mem_sub m' m1' /\ proj1_sig (Clight_core.inline_external_call_mem_events _ _ _ _ _ _ _ EFI EFC1) = proj1_sig (Clight_core.inline_external_call_mem_events _ _ _ _ _ _ _ EFI EFC)).Theorem prog_ext_correct : exists q, semantics.initial_core (Clight_core.cl_core_sem (globalenv prog)) 0 init_mem q init_mem (Vptr main_block Ptrofs.zero) [] /\ forall n, @step_lemmas.dry_safeN _ _ _ _ semax.genv_symb_injective (Clight_core.cl_core_sem (globalenv prog)) (io_dry_spec ext_link) {| genv_genv := Genv.globalenv prog; genv_cenv := prog_comp_env prog |} n main_itree q init_mem. Proof. edestruct whole_program_sequential_safety_ext with (V := Vprog) as (b & q & Hb & Hq & Hsafe). - repeat intro; hnf. apply I. - apply Jsub. - apply add_funspecs_frame. - apply juicy_dry_specs. - apply dry_spec_mem. - intros; apply I. - apply CSHL_Sound.semax_prog_sound, prog_correct. - apply (proj2_sig init_mem_exists). - exists q. rewrite (proj2_sig main_block_exists) in Hb; inv Hb. split; auto. Qed.Require Import VST.progs.os_combine. Require Import VST.progs.io_combine. Require Import VST.progs.io_os_specs. Require Import VST.progs.io_os_connection. Theorem prog_OS_correct : forall {H : io_os_specs.ThreadsConfigurationOps}, exists q, semantics.initial_core (Clight_core.cl_core_sem (globalenv prog)) 0 init_mem q init_mem (Vptr main_block Ptrofs.zero) [] /\ forall n s0, s0.(io_log) = [] -> s0.(console) = {| cons_buf := []; rpos := 0 |} -> exists traces, OS_safeN_trace prog n Traces.TEnd traces main_itree s0 q init_mem /\ forall t s, traces (t, s) -> exists z', consume_trace main_itree z' t /\ t = trace_of_ostrace s.(io_log) /\ valid_trace_user s.(io_log). 
} iFrame. iApply "IH"; last by iFrame. iPureIntro. rewrite dom_delete_L -Hmlm dom_insert_L. assert (i ‚àâ dom m). { apply not_elem_of_dom. eauto. } set_solver. Qed. Theorem big_sepML_sepM_ex Œ¶ m l : big_sepML Œ¶ m l -‚àó big_opM _ (Œª k v, ‚àÉ lv, ‚åú lv ‚àà l ‚åù ‚àó Œ¶ k v lv) m. Proof. rewrite big_sepML_eq /big_sepML_def; iIntros "Hlm". iDestruct "Hlm" as (lm) "[% Hlm]". iDestruct (big_sepM2_sepM_1 with "Hlm") as "Hlm". iApply (big_sepM_mono with "Hlm"). iIntros (k x Hkx) "H". iDestruct "H" as (lv) "[% H]". iExists _. iFrame. iPureIntro. rewrite H0. eapply elem_of_map_to_list in H1. eapply (elem_of_list_fmap_1 snd) in H1. eapply H1. Qed. Theorem big_sepML_sepL_split Œ¶ (P : LV -> PROP) m l : big_sepML (Œª k v lv, Œ¶ k v lv ‚àó P lv) m l -‚àó big_sepML Œ¶ m l ‚àó big_opL _ (Œª i, P) l. Proof. rewrite big_sepML_eq. iIntros "Hlm". iDestruct "Hlm" as (lm) "[% Hlm]". iDestruct (big_sepM2_sep with "Hlm") as "[Hlm0 Hlm1]". iSplitL "Hlm0". + iExists _. iFrame. done. + iDestruct (big_sepM.big_sepM2_sepM_2 with "Hlm1") as "Hlm1". rewrite big_op.big_opM_unseal /big_op.big_opM_def H0 big_sepL_fmap. iApply big_sepL_mono; last by iFrame. iIntros (???) "H". destruct y. iDestruct "H" as (?) "[% H]". iFrame. Qed. Theorem big_sepML_sepL_combine Œ¶ (P : LV -> PROP) m l : big_sepML Œ¶ m l ‚àó big_opL _ (Œª i, P) l -‚àó big_sepML (Œª k v lv, Œ¶ k v lv ‚àó P lv) m l. Proof. rewrite big_sepML_eq. iIntros "Hlm". iDestruct "Hlm" as "[Hlm Hl]". iDestruct "Hlm" as (lm) "[% Hlm]". iExists _. iSplitR; first by eauto. rewrite big_op.big_sepM2_unseal /big_op.big_sepM2_def. iDestruct "Hlm" as "[% Hlm]". iSplit; eauto. rewrite H0. iApply big_sepM_sep; iFrame. clear H0. iInduction lm as [|i x lm] "IH" using map_ind forall (m H1). { rewrite map_zip_empty_r. iApply big_sepM_empty. done. } rewrite map_to_list_insert; eauto. rewrite fmap_cons /=. iDestruct "Hl" as "[Hx Hl]". assert (is_Some (m !! i)) as Hmi. { apply H1. rewrite lookup_insert. eauto. } destruct Hmi. replace m with (<[i:=x0]> (delete i m)). 2: { rewrite insert_delete; eauto. } rewrite map_zip_insert. iApply big_sepM_insert. { rewrite map_zip_lookup_none_2; eauto. } iFrame. iApply "IH"; last by iFrame. iPureIntro. split; intros. - destruct (decide (i = k)); subst. + rewrite lookup_delete in H3. inversion H3. congruence. + rewrite lookup_delete_ne in H3; eauto. apply H1 in H3. rewrite lookup_insert_ne in H3; eauto. - destruct (decide (i = k)); subst. + inversion H3. congruence. + rewrite lookup_delete_ne; eauto. eapply H1. rewrite lookup_insert_ne; eauto. Qed. Theorem big_sepML_sepL Œ¶ (P : LV -> PROP) m l : big_sepML (Œª k v lv, Œ¶ k v lv ‚àó P lv) m l ‚ä£‚ä¢ big_sepML Œ¶ m l ‚àó big_opL _ (Œª i, P) l. 
in Hr. destruct Hr as [env' Hsteps]. apply INV_implies_totalSupply_fixed with env' (E++E'). substH Hc with (create_INV _ _ _ _ _ Hc Hs). eapply steps_INV; eauto. Qed. Theorem Property_totalSupply_fixed_transfer: forall env C C' E' msg to v spec preP evP postP, spec = funcspec_transfer to v (w_a C) env msg -> preP = spec_require spec -> evP = spec_events spec -> postP = spec_trans spec -> preP (w_st C) /\ evP (w_st C) E' /\ postP (w_st C) (w_st C') -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. rewrite H in H2. simpl in H2. destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. destruct H33. auto. Qed. Lemma INV_step_total_Supply_fixed: forall env C C' E' msg , step env C msg C' E' -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. inversion H. - rewrite H2 in H5. simpl in H5. destruct H6 as [H61 [H62 H63]]. rewrite H5 in H63. destruct H63. auto. - destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. simpl in H33. destruct H33. auto. - destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. simpl in H33. destruct H33. auto. - destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. simpl in H33. destruct H33. auto. - destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. simpl in H33. destruct H33. auto. - destruct H3 as [H31 [H32 H33]]. rewrite H2 in H33. simpl in H33. destruct H33. auto. Qed.Theorem Property_totalSupply_fixed_after_initialization: forall env0 env msg C E C' E', create env0 msg C E -> step env C msg C' E' -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. apply INV_step_total_Supply_fixed with env E' msg. auto. Qed.Lemma INV_steps_total_supply_fixed: forall ml env0 C0 C E env, steps env0 C0 ml env C E -> (st_totalSupply (w_st C0)) = (st_totalSupply (w_st C)). Proof. intros ml. induction ml. + intros. unfold steps in H. destruct H. rewrite H. trivial. + intros. inversion_clear H. rename x into envx. inversion H0 as [C'' [E'' [E' [Hs1 [Hs2 [Hs3 Hs4]]]]]]. apply INV_step_total_Supply_fixed in Hs1. apply IHml in Hs2. rewrite Hs1. auto. Qed.Theorem Property_totalSupply_fixed_after_initialization1: forall env0 env msg ml C E C' E', create env0 msg C E -> run env C ml C' E' -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). Proof. intros. unfold run in H0. inversion H0 as [env' H0']. apply INV_steps_total_supply_fixed in H0'. auto. Qed. Theorem Property_totalSupply_fixed_delegate_transfer1: forall env C C' E' from msg to v spec, spec = funcspec_transferFrom_1 from to v (w_a C) env msg -> (spec_require spec) (w_st C) /\ (spec_events spec) (w_st C) E' /\ (spec_trans spec) (w_st C) (w_st C') -> (st_totalSupply (w_st C)) = (st_totalSupply (w_st C')). 
r)%R /\ isMax b radix r p. Theorem ToInfinityTotal : TotalP ToInfinityP. red in |- *; intros r; case (Rle_or_lt r 0); intros H1. case MinEx with (r := r) (3 := pGivesBound); auto with arith. intros x H'; exists x; red in |- *; auto. case MaxEx with (r := r) (3 := pGivesBound); auto with arith. intros x H'; exists x; red in |- *; right; split; auto. apply Rlt_le; auto. Qed. Theorem ToInfinityCompatible : CompatibleP ToInfinityP. red in |- *. intros r1 r2 p q H'; case H'. intros H'0 H'1 H'2; left; split; try apply MinCompatible with (p := p) (r1 := r1); try rewrite <- H'1; case H'0; auto. intros H'0 H'1 H'2; right; split; try apply MaxCompatible with (p := p) (r1 := r1); try rewrite <- H'1; case H'0; auto. Qed. Theorem ToInfinityMinOrMax : MinOrMaxP ToInfinityP. red in |- *. intros r p H'; case H'; clear H'; intros H'; case H'; auto. Qed. Theorem ToInfinityMonotone : MonotoneP radix ToInfinityP. red in |- *; simpl in |- *. cut (FtoR radix (Fzero (- dExp b)) = 0%R); [ intros Eq0 | unfold FtoR in |- *; simpl in |- * ]; auto with real. intros p q p' q' H' H'0; case H'0; clear H'0. intros H'0; elim H'0; intros H'1 H'2; clear H'0; intros H'0. case H'0; intros H'3; elim H'3; clear H'3; auto. intros H'3 H'4. apply (MonotoneMin b radix) with (p := p) (q := q); auto. intros H'3 H'4. apply Rle_trans with p; [ apply isMin_inv1 with (1 := H'2); auto | idtac ]. apply Rle_trans with q; [ auto | apply isMax_inv1 with (1 := H'4) ]; auto. apply Rlt_le; auto. intros H'0; elim H'0; intros H'1 H'2; clear H'0. intros H'0; case H'0; clear H'0; intros H'0; case H'0; intros H'3 H'4; clear H'0. 2: apply (MonotoneMax b radix) with (p := p) (q := q); auto. apply Rle_trans with (FtoRradix (Fzero (- dExp b))); auto. elim H'2. intros H'0 H'5; elim H'5; intros H'6 H'7; apply H'7; clear H'5; auto. repeat split; simpl in |- *; auto with zarith. apply Rle_trans with q; auto. apply Rlt_le; auto. rewrite Eq0; auto. elim H'4. intros H'0 H'5; elim H'5; intros H'6 H'7; apply H'7; clear H'5; auto. repeat split; simpl in |- *; auto with zarith. apply Rle_trans with p; auto. rewrite Eq0; auto. apply Rlt_le; auto. Qed. Theorem ToInfinityRoundedModeP : RoundedModeP ToInfinityP. 
Hxy0. rewrite round_0... ring. destruct (mag beta (x * y)) as (exy, Hexy). specialize (Hexy Hxy0). destruct (mag beta (f - x * y)) as (er, Her). specialize (Her Hz). destruct (mag beta x) as (ex, Hex). assert (Hx0: (x <> 0)%R). contradict Hxy0. now rewrite Hxy0, Rmult_0_l. specialize (Hex Hx0). destruct (mag beta y) as (ey, Hey). assert (Hy0: (y <> 0)%R). contradict Hxy0. now rewrite Hxy0, Rmult_0_r. specialize (Hey Hy0).assert (Hc1: (cexp (x * y)%R - prec <= cexp x + cexp y)%Z). unfold cexp, FLX_exp. rewrite mag_unique with (1 := Hex). rewrite mag_unique with (1 := Hey). rewrite mag_unique with (1 := Hexy). cut (exy - 1 < ex + ey)%Z. lia. apply (lt_bpow beta). apply Rle_lt_trans with (1 := proj1 Hexy). rewrite Rabs_mult. rewrite bpow_plus. apply Rmult_le_0_lt_compat. apply Rabs_pos. apply Rabs_pos. apply Hex. apply Hey.assert (Hc2: (cexp x + cexp y <= cexp (x * y)%R)%Z). unfold cexp, FLX_exp. rewrite mag_unique with (1 := Hex). rewrite mag_unique with (1 := Hey). rewrite mag_unique with (1 := Hexy). cut ((ex - 1) + (ey - 1) < exy)%Z. generalize (prec_gt_0 prec). clear ; lia. apply (lt_bpow beta). apply Rle_lt_trans with (2 := proj2 Hexy). rewrite Rabs_mult. rewrite bpow_plus. apply Rmult_le_compat. apply bpow_ge_0. apply bpow_ge_0. apply Hex. apply Hey.assert (Hr: ((F2R (Float beta (- (Ztrunc (scaled_mantissa beta (FLX_exp prec) x) * Ztrunc (scaled_mantissa beta (FLX_exp prec) y)) + rnd (scaled_mantissa beta (FLX_exp prec) (x * y)) * beta ^ (cexp (x * y)%R - (cexp x + cexp y))) (cexp x + cexp y))) = f - x * y)%R). rewrite Hx at 6. rewrite Hy at 6. rewrite <- F2R_mult. simpl. unfold f, round, Rminus. rewrite <- F2R_opp, Rplus_comm, <- F2R_plus. unfold Fplus. simpl. now rewrite Zle_imp_le_bool with (1 := Hc2).exists (Float beta (- (Ztrunc (scaled_mantissa beta (FLX_exp prec) x) * Ztrunc (scaled_mantissa beta (FLX_exp prec) y)) + rnd (scaled_mantissa beta (FLX_exp prec) (x * y)) * beta ^ (cexp (x * y)%R - (cexp x + cexp y))) (cexp x + cexp y)). split;[assumption|split]. rewrite Hr. simpl. clear Hr. apply Z.le_trans with (cexp (x * y)%R - prec)%Z. unfold cexp, FLX_exp. apply Zplus_le_compat_r. rewrite mag_unique with (1 := Hexy). apply mag_le_bpow with (1 := Hz). replace (bpow (exy - prec)) with (ulp beta (FLX_exp prec) (x * y)). apply error_lt_ulp... rewrite ulp_neq_0; trivial. unfold cexp. now rewrite mag_unique with (1 := Hexy). apply Hc1. reflexivity. Qed. Theorem mult_error_FLX : forall x y, format x -> format y -> format (round beta (FLX_exp prec) rnd (x * y) - (x * y))%R. 
intros (k & P & Q). exists k; auto. Qed. Lemma xelements_keys_norepet: forall (A: Type) (m: t A) (i: positive), list_norepet (xkeys m i). Proof. induction m; intros. - rewrite xkeys_leaf; constructor. - assert (NOTIN1: ~ In (prev i) (xkeys m1 (xO i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (NOTIN2: ~ In (prev i) (xkeys m2 (xI i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (DISJ: forall x, In x (xkeys m1 (xO i)) -> In x (xkeys m2 (xI i)) -> False). { intros. exploit in_xkeys. eexact H. intros (j1 & EQ1). exploit in_xkeys. eexact H0. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H0. destruct H0. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall (A: Type) (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil. Proof. induction m; intros. auto. rewrite xelements_node. rewrite IHm1, IHm2. destruct o; auto. generalize (H xH); simpl; congruence. intros. apply (H (xI i0)). intros. apply (H (xO i0)). Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros until n. unfold elements. generalize 1%positive. revert m n. induction m; intros. - simpl. rewrite xelements_empty. constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. - destruct n as [ | n1 o' n2 ]. + rewrite (xelements_empty (Node m1 o m2)). simpl; constructor. intros. specialize (H i). rewrite gempty in H. inv H; auto. + rewrite ! xelements_node. repeat apply list_forall2_app. apply IHm1. intros. apply (H (xO i)). generalize (H xH); simpl; intros OR; inv OR. constructor. constructor. auto. constructor. apply IHm2. intros. apply (H (xI i)). Qed. Theorem elements_canonical_order: forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) -> (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). 
bind (cons (x2, v) m) x1 v' -> bind m x1 v'' -> v' = v''. Admitted. Lemma update_shadow : forall (m: partial_map) v1 v2 x, update (x, v2) (update (x, v1) m) = update (x, v2) m. Admitted. Theorem update_same : forall v x (m : partial_map), bind m x v -> update (x, v) m = m. Admitted. Theorem update_permute : forall v1 v2 x1 x2 (m : partial_map), x2 <> x1 -> (update (x1,v1) (update (x2,v2) m)) = (update (x2,v2) (update (x1,v1) m)). Admitted. Definition total_map := (partial_map * nat)%type.Definition t_empty v : total_map := (empty, v).Definition t_update (m : total_map) (x : id) (v : nat) := let (pm,d) := m in (update (x, v) pm, d).Inductive t_bind : partial_map -> nat -> id -> nat -> Prop := | T_BindDef : forall x v, t_bind nil v x v | T_BindNow : forall x a m d, t_bind (cons (x, a) m) d x a | T_BindLater : forall x x' a a' m' d, ~ (x = x') -> t_bind m' d x a -> t_bind (cons (x',a') m') d x a.Derive ArbitrarySizedSuchThat for (fun x => t_bind m d x a). Derive SizeMonotonicSuchThatOpt for (fun x => t_bind m d x a).Instance adm_st' d m a : SuchThatCorrect (fun x => t_bind m d x a) (genST (fun x => t_bind m d x a)). Admitted.Lemma t_apply_empty: forall x v v', t_bind empty v x v' -> v = v'. Admitted. Fixpoint lookup m x : option nat := match m with | nil => None | (x',v)::t => if (x = x') ? then Some v else lookup t x end.Definition t_lookup (m : total_map) x := let (m, d) := m in match lookup m x with | Some v => v | None => d end.Lemma t_update_eq : forall (m: total_map) x v, t_lookup (t_update m x v) x = v. Admitted. Theorem t_update_neq : forall v x1 x2 (m : total_map), x1 <> x2 -> t_lookup (t_update m x1 v) x2 = t_lookup m x2. Admitted. Lemma t_update_shadow : forall (m: total_map) v1 v2 x, t_update (t_update m x v1) x v2 = t_update m x v2. Admitted. Lemma beq_idP : forall x y, reflect (x = y) (beq_id x y). Admitted. Theorem t_update_same : forall x (m : total_map), t_update m x (t_lookup m x) = m. Admitted. Theorem t_update_permute : forall v1 v2 x1 x2 (m : total_map), x2 <> x1 -> (t_update (t_update m x2 v2) x1 v1) = (t_update (t_update m x1 v1) x2 v2). 
: S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> ForAll_T Sini Pp bound. Proof. unfold ForAll_T in |- *; intros. apply H0. apply (H s t); assumption. Qed. Theorem Conj : forall (Sini : S) (P1 P2 : S -> Prop), ForAll Sini P1 -> ForAll Sini P2 -> ForAll Sini (fun s : S => P1 s /\ P2 s). Proof. unfold ForAll in |- *; intros. split; [ apply H | apply H0 ]; assumption. Qed. Theorem Conj_T : forall (Sini : S) (P1 P2 : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P1 bound -> ForAll_T Sini P2 bound -> ForAll_T Sini (fun s : S => P1 s /\ P2 s) bound. Proof. unfold ForAll_T in |- *; intros. split; [ apply (H s t) | apply (H0 s t) ]; assumption. Qed. Theorem Mon_I_EX : forall (Sini : S) (Pg Pp : S -> Prop), Exists Sini Pg -> (forall s : S, Pg s -> Pp s) -> Exists Sini Pp. Proof. intros. inversion_clear H. apply (exists_ H1 (H0 s H2)). Qed. Theorem Mon_I_EX_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), Exists_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> Exists_T Sini Pp bound. Proof. intros. inversion_clear H. apply (exists_T H1 H2 (H0 s H3)). Qed. Lemma RState_Trans : forall s1 s2 s3 : S, RState s1 s2 -> RState s2 s3 -> RState s1 s3. Proof. simple induction 2; intros. assumption. apply rsNextTick; trivial. apply (rsNextDisc H2 H3 H4). Qed. Lemma RState_Trans_T : forall (s1 s2 s3 : S) (t1 t2 : Instant), RState_T s1 s2 t1 -> RState_T s2 s3 t2 -> RState_T s1 s3 (plus_Ck t1 t2). Proof. simple induction 2; unfold plus_Ck in |- *; intros. rewrite (plus_comm t1 time0); unfold time0 in |- *; simpl in |- *; assumption. unfold Inc in |- *; unfold plus_Ck in |- *; rewrite (plus_assoc t1 t tick). apply (rsNextTick_T H2 H3). apply (rsNextDisc_T H2 H3 H4). Qed. Theorem StepsEX : forall (s1 s2 : S) (P : S -> Prop), RState s1 s2 -> Exists s2 P -> Exists s1 P. Proof. intros. inversion H0. apply (exists_ (RState_Trans H H1) H2). Qed. Require Import Classical. Theorem ForAll_EX : forall (Sini : S) (P : S -> Prop), ForAll Sini P <-> ~ Exists Sini (fun s : S => ~ P s). 
m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. apply PTree.gso. red; intros; elim H; apply X.index_inj; auto. Qed. Theorem gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then Some x else get i m. 
break_match; repeat find_inversion; simpl in *; intuition. - unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; repeat find_inversion; simpl in *; congruence. Qed. Lemma allEntries_votesWithLog_timeout : refined_raft_net_invariant_timeout allEntries_votesWithLog. Proof using aeli. red. unfold allEntries_votesWithLog. intros. simpl in *. repeat find_higher_order_rewrite. destruct_update; simpl in *. - find_rewrite_lem update_elections_data_timeout_allEntries. find_eapply_lem_hyp votesWithLog_update_elections_data_timeout'; eauto. intuition. + eapply_prop_hyp votesWithLog votesWithLog; eauto; intuition; right; break_exists_exists; intuition; find_higher_order_rewrite; destruct_update; simpl in *; auto. rewrite update_elections_data_timeout_leaderLogs. auto. + subst. find_copy_apply_lem_hyp handleTimeout_log_same. repeat find_rewrite. find_apply_lem_hyp allEntries_log_invariant; eauto. intuition. right. break_exists_exists; intuition; find_higher_order_rewrite; destruct_update; simpl in *; auto; rewrite update_elections_data_timeout_leaderLogs; auto. - eapply_prop_hyp votesWithLog votesWithLog; eauto; intuition; right; break_exists_exists; intuition; find_higher_order_rewrite; destruct_update; simpl in *; auto. rewrite update_elections_data_timeout_leaderLogs; auto. Qed. Lemma allEntries_votesWithLog_do_leader : refined_raft_net_invariant_do_leader allEntries_votesWithLog. Proof using. red. unfold allEntries_votesWithLog. intros. simpl in *. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. repeat find_higher_order_rewrite. destruct_update; simpl in *; eauto; eapply_prop_hyp votesWithLog votesWithLog; eauto; intuition; right; break_exists_exists; intuition; find_higher_order_rewrite; destruct_update; simpl in *; auto. Qed. Lemma allEntries_votesWithLog_do_generic_server : refined_raft_net_invariant_do_generic_server allEntries_votesWithLog. Proof using. red. unfold allEntries_votesWithLog. intros. simpl in *. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. repeat find_higher_order_rewrite. destruct_update; simpl in *; eauto; eapply_prop_hyp votesWithLog votesWithLog; eauto; intuition; right; break_exists_exists; intuition; find_higher_order_rewrite; destruct_update; simpl in *; auto. Qed. Lemma allEntries_votesWithLog_init : refined_raft_net_invariant_init allEntries_votesWithLog. Proof using. red. unfold allEntries_votesWithLog. intros. simpl in *. intuition. Qed. Lemma allEntries_votesWithLog_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset allEntries_votesWithLog. Proof using. red. unfold allEntries_votesWithLog in *. intros. repeat find_reverse_higher_order_rewrite. copy_eapply_prop_hyp votesWithLog votesWithLog; eauto. intuition. right. break_exists_exists. repeat find_higher_order_rewrite. auto. Qed. Lemma allEntries_votesWithLog_reboot : refined_raft_net_invariant_reboot allEntries_votesWithLog. Proof using. red. unfold allEntries_votesWithLog in *. intros. simpl in *. match goal with | H : nwState ?net ?h = (?gd, ?d) |- _ => replace gd with (fst (nwState net h)) in * by (rewrite H; reflexivity); replace d with (snd (nwState net h)) in * by (rewrite H; reflexivity); clear H end. repeat find_higher_order_rewrite. subst. unfold reboot in *. destruct_update; simpl in *; eauto; copy_eapply_prop_hyp votesWithLog votesWithLog; eauto; repeat find_rewrite; intuition; right; break_exists_exists; intuition; find_higher_order_rewrite; destruct_update; simpl in *; auto. Qed. Theorem allEntries_votesWithLog_invariant : forall net, refined_raft_intermediate_reachable net -> allEntries_votesWithLog net. 
M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof fun x H y z H0 H1 => let H2 : z + x = y + x := H1 || z + x = a @a by H0 in let H3 : z = y := op_cancel_r z y x H H2 in H3. Theorem op_inv_r_uniq : forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof fun x H y z H0 H1 => let H2 : x + z = x + y := H1 || x + z = a @a by H0 in let H3 : z = y := op_cancel_l z y x H H2 in H3. Theorem op_inv_uniq : forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y. Proof fun x y z H H0 => op_inv_l_uniq x (ex_intro (fun y => op_is_inv_r x y) y (proj2 H)) y z (proj1 H) (proj1 H0). Theorem op_inv_0_l : op_is_inv_l 0 0. Proof op_id_l 0 : 0 + 0 = 0. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof op_id_r 0 : 0 + 0 = 0. Theorem op_inv_0 : op_is_inv 0 0. Proof conj op_inv_0_l op_inv_0_r. Theorem op_has_inv_l_0 : has_inv_l 0. Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l. Theorem op_has_inv_r_0 : has_inv_r 0. Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r. Theorem op_has_inv_0 : has_inv 0. Proof ex_intro (op_is_inv 0) 0 op_inv_0. Theorem op_inv_0_eq_0 : forall x : M, op_is_inv x 0 -> x = 0. Proof fun x H => proj1 H || a = 0 @a by <- op_id_l x. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof conj op_inv_0 (fun x H => eq_sym (op_inv_0_eq_0 x H)). Definition op_neg_strong : forall x : M, has_inv x -> { y | op_is_inv x y } := fun x H => constructive_definite_description (op_is_inv x) (ex_ind (fun y (H0 : op_is_inv x y) => ex_intro (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z) y (conj H0 (fun z H1 => eq_sym (op_inv_uniq x y z H0 H1)))) H). Definition op_neg : forall x : M, has_inv x -> M := fun x H => proj1_sig (op_neg_strong x H).Notation "{-}" := (op_neg) : monoid_scope. Theorem op_neg_def : forall (x : M) (H : has_inv x), op_is_inv x ({-} x H). 
Require Import Raux Defs Round_pred Generic_fmt Float_prop. Require Import FLX FIX Ulp Round_NE. Require Import Psatz.Section RND_FLT.Variable beta : radix.Notation bpow e := (bpow beta e).Variable emin prec : Z.Context { prec_gt_0_ : Prec_gt_0 prec }.Inductive FLT_format (x : R) : Prop := FLT_spec (f : float beta) : x = F2R f -> (Z.abs (Fnum f) < Zpower beta prec)%Z -> (emin <= Fexp f)%Z -> FLT_format x.Definition FLT_exp e := Z.max (e - prec) emin. Global Instance FLT_exp_valid : Valid_exp FLT_exp. Proof. intros k. unfold FLT_exp. generalize (prec_gt_0 prec). repeat split ; intros ; zify ; omega. Qed.Theorem generic_format_FLT : forall x, FLT_format x -> generic_format beta FLT_exp x. Proof. clear prec_gt_0_. intros x [[mx ex] H1 H2 H3]. simpl in H2, H3. rewrite H1. apply generic_format_F2R. intros Zmx. unfold cexp, FLT_exp. rewrite mag_F2R with (1 := Zmx). apply Z.max_lub with (2 := H3). apply Zplus_le_reg_r with (prec - ex)%Z. ring_simplify. now apply mag_le_Zpower. Qed.Theorem FLT_format_generic : forall x, generic_format beta FLT_exp x -> FLT_format x. Proof. intros x. unfold generic_format. set (ex := cexp beta FLT_exp x). set (mx := Ztrunc (scaled_mantissa beta FLT_exp x)). intros Hx. rewrite Hx. eexists ; repeat split ; simpl. apply lt_IZR. rewrite IZR_Zpower. 2: now apply Zlt_le_weak. apply Rmult_lt_reg_r with (bpow ex). apply bpow_gt_0. rewrite <- bpow_plus. change (F2R (Float beta (Z.abs mx) ex) < bpow (prec + ex))%R. rewrite F2R_Zabs. rewrite <- Hx. destruct (Req_dec x 0) as [Hx0|Hx0]. rewrite Hx0, Rabs_R0. apply bpow_gt_0. unfold cexp in ex. destruct (mag beta x) as (ex', He). simpl in ex. specialize (He Hx0). apply Rlt_le_trans with (1 := proj2 He). apply bpow_le. cut (ex' - prec <= ex)%Z. omega. unfold ex, FLT_exp. apply Z.le_max_l. apply Z.le_max_r. Qed. Theorem FLT_format_bpow : forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e). Proof. intros e He. apply generic_format_bpow; unfold FLT_exp. apply Z.max_case; try assumption. unfold Prec_gt_0 in prec_gt_0_; omega. Qed. Theorem FLT_format_satisfies_any : satisfies_any FLT_format. 
Require Import Coq.Strings.String. Require Import Arith. Require Import Pred PredCrash. Require Import Word. Require Import Prog. Require Import Hoare. Require Import SepAuto. Require Import BasicProg. Require Import Omega. Require Import Log. Require Import Array. Require Import List ListUtils. Require Import Bool. Require Import Eqdep_dec. Require Import Setoid. Require Import Rec. Require Import NArith. Require Import WordAuto. Require Import RecArrayUtils LogRecArray. Require Import GenSepN. Require Import Balloc. Require Import ListPred. Require Import FSLayout. Require Import AsyncDisk. Require Import DiskSet. Require Import BlockPtr. Require Import GenSepAuto. Require Import Errno. Require Import SyncedMem.Import ListNotations. Open Scope list.Set Implicit Arguments. Module INODE. Definition iattrtype : Rec.type := Rec.RecF ([ ("bytes", Rec.WordF 64) ; ("uid", Rec.WordF 32) ; ("gid", Rec.WordF 32) ; ("dev", Rec.WordF 64) ; ("mtime", Rec.WordF 32) ; ("atime", Rec.WordF 32) ; ("ctime", Rec.WordF 32) ; ("itype", Rec.WordF 8) ; ("unused", Rec.WordF 24) ]). Definition NDirect := 7. Definition irectype : Rec.type := Rec.RecF ([ ("len", Rec.WordF addrlen); ("attrs", iattrtype); ("indptr", Rec.WordF addrlen); ("dindptr", Rec.WordF addrlen); ("tindptr", Rec.WordF addrlen); ("blocks", Rec.ArrayF (Rec.WordF addrlen) NDirect)]). Module IRecSig <: RASig. Definition xparams := inode_xparams. Definition RAStart := IXStart. Definition RALen := IXLen. Definition xparams_ok (_ : xparams) := True. Definition itemtype := irectype. Definition items_per_val := valulen / (Rec.len itemtype). Theorem blocksz_ok : valulen = Rec.len (Rec.ArrayF itemtype items_per_val). 
intuition. * repeat find_rewrite. eauto. * subst. unfold raft_data in *. repeat find_rewrite. discriminate. + eauto. Qed. Theorem leaderLogs_sublog_do_leader : refined_raft_net_invariant_do_leader leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_leader, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doLeader_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doLeader_same_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_do_generic_server : refined_raft_net_invariant_do_generic_server leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_do_generic_server, leaderLogs_sublog. simpl. intuition. repeat find_higher_order_rewrite. find_copy_apply_lem_hyp doGenericServer_type. intuition. repeat match goal with | [ H : _ |- _ ] => rewrite update_fun_comm with (f := fst) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := snd) in H | [ H : _ |- _ ] => rewrite update_fun_comm with (f := leaderLogs) in H end. rewrite update_fun_comm with (f := snd). simpl in *. rewrite update_fun_comm. rewrite update_nop_ext' by (find_apply_lem_hyp doGenericServer_log; repeat find_rewrite; auto). find_rewrite_lem update_fun_comm. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : context [ type ] |- _ => rewrite update_fun_comm in H; rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. match goal with | H : _ |- _ => rewrite update_nop_ext' in H by (repeat find_rewrite; auto) end. eauto. Qed. Theorem leaderLogs_sublog_state_same_packet_subset : refined_raft_net_invariant_state_same_packet_subset leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_state_same_packet_subset, leaderLogs_sublog. intuition. repeat find_reverse_higher_order_rewrite. eauto. Qed. Theorem leaderLogs_sublog_reboot : refined_raft_net_invariant_reboot leaderLogs_sublog. Proof using. unfold refined_raft_net_invariant_reboot, leaderLogs_sublog. unfold reboot. simpl. intuition. repeat find_higher_order_rewrite. subst. repeat update_destruct_max_simplify; simpl in *; try discriminate; match goal with | [ H : _, H' : _ |- _ ] => solve [eapply H; eauto; rewrite H'; eauto] end. Qed. Theorem leaderLogs_sublog_invariant : forall net, refined_raft_intermediate_reachable net -> leaderLogs_sublog net. 
auto. intros H'0; right; repeat split; simpl in |- *; auto with zarith. rewrite Zmult_comm; simpl in |- *; red in |- *; simpl in |- *; auto. intros H'1. case (min_or (precision - Fdigit radix p) (Zabs_nat (dExp b + Fexp p))); intros Min; case Min; clear Min; intros MinR MinL. intros H'2; left; split; auto. rewrite MinR; unfold Fshift in |- *; simpl in |- *. apply Zle_trans with (Zabs (radix * (Zpower_nat radix (pred (Fdigit radix p)) * Zpower_nat radix (precision - Fdigit radix p)))). pattern radix at 1 in |- *; rewrite <- (Zpower_nat_1 radix). repeat rewrite <- Zpower_nat_is_exp; auto with zarith. replace (1 + (pred (Fdigit radix p) + (precision - Fdigit radix p))) with precision; auto. rewrite pGivesBound; auto with real. rewrite Zabs_eq; auto with zarith. cut (Fdigit radix p <= precision); auto with float. unfold Fdigit in |- *. generalize (digitNotZero _ radixMoreThanOne _ H'1); case (digit radix (Fnum p)); simpl in |- *; auto. intros tmp; Contradict tmp; auto with arith. intros n H H0; change (precision = S n + (precision - S n)) in |- *. apply le_plus_minus; auto. apply pGivesDigit; auto. repeat rewrite Zabs_Zmult. apply Zle_Zmult_comp_l. apply Zle_ZERO_Zabs. apply Zle_Zmult_comp_r. apply Zle_ZERO_Zabs. rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith. unfold Fdigit in |- *; apply digitLess; auto. intros H'0; right; split; auto; split. rewrite MinR; clear MinR; auto. cut (- dExp b <= Fexp p)%Z; [ idtac | auto with float ]. case p; simpl in |- *. intros Fnum1 Fexp1 H'2; rewrite inj_abs; auto with zarith. rewrite MinR. rewrite <- (fun x => Zabs_eq (Zpos x)). unfold Fshift in |- *; simpl in |- *. apply Zlt_le_trans with (Zabs (radix * (Zpower_nat radix (Fdigit radix p) * Zpower_nat radix (Zabs_nat (dExp b + Fexp p))))). repeat rewrite Zabs_Zmult. apply Zmult_gt_0_lt_compat_l. apply Zlt_gt; rewrite Zabs_eq; auto with zarith. apply Zmult_gt_0_lt_compat_r. apply Zlt_gt; rewrite Zabs_eq; auto with zarith. rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith. unfold Fdigit in |- *; apply digitMore; auto. pattern radix at 1 in |- *; rewrite <- (Zpower_nat_1 radix). repeat rewrite <- Zpower_nat_is_exp; auto with zarith. apply Zle_trans with (Zabs (Zpower_nat radix precision)). repeat rewrite Zabs_eq; auto with zarith. rewrite pGivesBound. rewrite (fun x => Zabs_eq (Zpower_nat radix x)); auto with zarith. red in |- *; simpl in |- *; red in |- *; intros; discriminate. Qed. Theorem NormalAndSubNormalNotEq : forall p q : float, Fnormal p -> Fsubnormal q -> p <> q :>R. 
(Int.add n n1) Int.iwordsize) eqn:?. + exists (Val.shr v1 (Vint (Int.add n n1))); split. EvalOp. subst. destruct v1; simpl; auto. rewrite Heqb. destruct (Int.ltu n1 Int.iwordsize) eqn:?; simpl; auto. rewrite LT. rewrite Int.add_commut. rewrite Int.shr_shr; auto. rewrite Int.add_commut; auto. + TrivialExists. econstructor. EvalOp. simpl; eauto. constructor. simpl. auto. - TrivialExists. - intros; TrivialExists. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. generalize (Int.one_bits_decomp n) (Int.one_bits_range n); intros D R. destruct (Int.one_bits n) as [ | i l]. TrivialExists. destruct l as [ | j l ]. replace (Val.mul x (Vint n)) with (Val.shl x (Vint i)). apply eval_shlimm; auto. destruct x; auto; simpl. rewrite D; simpl; rewrite Int.add_zero. rewrite R by auto with coqlib. rewrite Int.shl_mul. auto. destruct l as [ | k l ]. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm j (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exploit eval_add. eexact A1. eexact A2. intros [v3 [A3 B3]]. exists v3; split. econstructor; eauto. rewrite D; simpl; rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. apply Val.lessdef_trans with (Val.add v1 v2); auto. apply Val.add_lessdef; auto. simpl. rewrite ! R by auto with coqlib. auto. TrivialExists. Qed.Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros until x; unfold mulimm. predSpec Int.eq Int.eq_spec n Int.zero. intros. exists (Vint Int.zero); split. EvalOp. destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto. predSpec Int.eq Int.eq_spec n Int.one. intros. exists x; split; auto. destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto. - case (mulimm_match a); intros; InvEval. + TrivialExists. simpl. rewrite Int.mul_commut; auto. + rewrite Val.mul_add_distr_l. exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]]. exploit (eval_addimm (Int.mul n (Int.repr n2)) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]]. exists v''; split; auto. eapply Val.lessdef_trans. eapply Val.add_lessdef; eauto. rewrite Val.mul_commut; auto. + apply eval_mulimm_base; auto. Qed.Theorem eval_mul: binary_constructor_sound mul Val.mul. Proof. red; intros until y. unfold mul; case (mul_match a b); intros; InvEval. - rewrite Val.mul_commut. apply eval_mulimm. auto. - apply eval_mulimm. auto. - TrivialExists. Qed.Theorem eval_mulhs: binary_constructor_sound mulhs Val.mulhs. Proof. unfold mulhs; red; intros; TrivialExists. Qed. Theorem eval_mulhu: binary_constructor_sound mulhu Val.mulhu. 
intros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith. Qed. Theorem le_bool_correct4 : forall a b : nat, le_bool a b = false -> b <= a. Proof using. intros a; elim a; simpl in |- *; auto. intros b; case b; simpl in |- *; try (intros; discriminate); auto with arith. intros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith. Qed. End LeBool. Section fold. Variables (A : Type) (B : Type). Variable f : A -> B -> A. Variable g : B -> A -> A. Variable h : A -> A. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Theorem fold_left_app : forall a l1 l2, fold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a). Proof using. intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1. Qed. Theorem fold_left_eta : forall l a f1, (forall a b, In b l -> f a b = f1 a b) -> fold_left f l a = fold_left f1 l a. Proof using. intros l; elim l; simpl in |- *; auto. intros a l0 H a0 f1 H0. rewrite H0; auto. Qed. Theorem fold_left_map : forall (C : Type) a l (k : C -> B), fold_left f (map k l) a = fold_left (fun a b => f a (k b)) l a. Proof using. intros C a l k; generalize a; elim l; simpl in |- *; auto. Qed. Theorem fold_right_app : forall a l1 l2, fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1. Proof using. intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1. intros a l H a0 l2; rewrite H; auto. Qed. Theorem fold_left_init : (forall (a : A) (b : B), h (f a b) = f (h a) b) -> forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a). Proof using. intros H a l; generalize a; elim l; clear l a; simpl in |- *; auto. intros a l H0 a0. rewrite <- H; auto. Qed. End fold. Section List. Variables (A : Type) (B : Type) (C : Type). Variable f : A -> B. Theorem list_length_ind : forall P : list A -> Prop, (forall l1 : list A, (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) -> forall l : list A, P l. 
Require Import DirName. Require Import Balloc. Require Import Prog. Require Import BasicProg. Require Import Bool. Require Import Word. Require Import BFile Bytes Rec Inode. Require Import String. Require Import FSLayout. Require Import Pred PredCrash. Require Import Arith. Require Import GenSepN. Require Import List ListUtils. Require Import Hoare. Require Import Log. Require Import SepAuto. Require Import Array. Require Import FunctionalExtensionality. Require Import AsyncDisk. Require Import DiskSet. Require Import SyncedMem. Require Import GenSepAuto. Require Import BFileCrash. Require Import Omega. Require Import DirTreeDef. Require Import DirTreeRep. Require Import DirTreePred. Require Import DirTreeNames. Require Import DirTreeInodes.Import ListNotations.Module SDIR := DirCache.CacheOneDir.Set Implicit Arguments.Module DTCrash. Definition file_crash (f f' : dirfile) : Prop := exists c c', BFILE.file_crash (BFILE.mk_bfile (DFData f) (DFAttr f) c) (BFILE.mk_bfile (DFData f') (DFAttr f') c'). Inductive tree_crash : dirtree -> dirtree -> Prop := | TCFile : forall inum f f', file_crash f f' -> tree_crash (TreeFile inum f) (TreeFile inum f') | TCDir : forall inum st st', map fst st = map fst st' -> Forall2 tree_crash (map snd st) (map snd st') -> tree_crash (TreeDir inum st) (TreeDir inum st'). Theorem tree_crash_trans : forall t1 t2 t3, tree_crash t1 t2 -> tree_crash t2 t3 -> tree_crash t1 t3. 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.HasDups. Require Import FCF.RndInList. Require Import FCF.CompFold. Require Import FCF.Tactics. Require Import Permutation. Require Import Lia. Section DRBG. Variable S : Set. Hypothesis S_EqDec : EqDec S. Variable RndS : Comp S. Variable R : Set. Hypothesis R_EqDec : EqDec R. Variable RndR : Comp R. Variable f : S -> R. Variable A : R -> Comp bool. Definition DRBG_G0 := s <-$ RndS ; A (f s). Definition DRBG_G1 := r <-$ RndR; A r. Definition DRBG_Advantage := | Pr[DRBG_G0] - Pr[DRBG_G1] |.End DRBG.Require Import FCF.PRF.Local Open Scope list_scope. Local Opaque evalDist.Section PRF_DRBG. Variable Key D : Set. Variable eta : nat. Hypothesis D_EqDec : EqDec D. Variable RndKey : Comp Key. Variable f : Key -> D -> Bvector eta. Variable injD : Bvector eta -> D. Hypothesis injD_correct : forall r1 r2, (injD r1) = (injD r2) -> r1 = r2. Variable l : nat. Hypothesis l_pos : l > 0. Variable r_init : Bvector eta. Definition v_init := injD r_init. Definition RndOut := compMap _ (fun _ => {0, 1}^eta) (forNats l). Fixpoint PRF_DRBG_f (v : D)(n : nat)(k : Key) := match n with | O => nil | S n' => r <- (f k v); r :: (PRF_DRBG_f (injD r) n' k) end. Definition PRF_DRBG (k : Key) := PRF_DRBG_f v_init l k. Variable A : list (Bvector eta) -> Comp bool. Hypothesis A_wf : forall c, well_formed_comp (A c). Definition PRF_DRBG_G1 := s <-$ RndKey ; A (PRF_DRBG_f v_init l s). Theorem PRF_DRBG_G1_equiv : Pr[DRBG_G0 RndKey PRF_DRBG A] == Pr[PRF_DRBG_G1]. reflexivity. Qed. Fixpoint PRF_DRBG_f_G2 (v : D)(n : nat) : OracleComp D (Bvector eta) (list (Bvector eta)) := match n with | O => $ ret nil | S n' => r <--$ (OC_Query _ v); ls' <--$ (PRF_DRBG_f_G2 (injD r) n'); $ ret (r :: ls') end. Definition PRF_A : OracleComp D (Bvector eta) bool := ls <--$ PRF_DRBG_f_G2 v_init l; $ A ls. Check A. Theorem PRF_DRBG_f_G2_wf : forall n v, well_formed_oc (PRF_DRBG_f_G2 v n). 
nth n (l++l') d = nth (n-length l) l' d. Proof. induction l. intros. simpl. destruct n; auto. intros l' d n. case n; simpl; auto. intros. inversion H. intros. rewrite IHl; auto with arith. Qed. Section Remove. Hypothesis eq_dec : forall x y : A, {x = y}+{x <> y}. Fixpoint remove (x : A) (l : list A){struct l} : list A := match l with | nil => nil | y::tl => if (eq_dec x y) then remove x tl else y::(remove x tl) end. Theorem remove_In : forall (l : list A) (x : A), ~ In x (remove x l). Proof. induction l as [|x l]; auto. intro y; simpl; destruct (eq_dec y x) as [yeqx | yneqx]. apply IHl. unfold not; intro HF; simpl in HF; destruct HF; auto. apply (IHl y); assumption. Qed. End Remove. Fixpoint last (l:list A) (d:A) {struct l} : A := match l with | nil => d | a :: nil => a | a :: l => last l d end. Fixpoint removelast (l:list A) {struct l} : list A := match l with | nil => nil | a :: nil => nil | a :: l => a :: removelast l end. Lemma app_removelast_last : forall l d, l<>nil -> l = removelast l ++ (last l d :: nil). Proof. induction l. destruct 1; auto. intros d _. destruct l; auto. pattern (a0::l) at 1; rewrite IHl with d; auto; discriminate. Qed. Lemma exists_last : forall l, l<>nil -> { l' : (list A) & { a : A | l = l'++a::nil}}. Proof. induction l. destruct 1; auto. intros _. destruct l. exists (@nil A); exists a; auto. destruct IHl as [l' (a',H)]; try discriminate. rewrite H. exists (a::l'); exists a'; auto. Qed. Lemma removelast_app : forall l l', l' <> nil -> removelast (l++l') = l ++ removelast l'. Proof. induction l. simpl; auto. simpl; intros. assert (l++l' <> nil). destruct l. simpl; auto. simpl; discriminate. specialize (IHl l' H). destruct (l++l'); [elim H0; auto|f_equal; auto]. Qed. Hypotheses eqA_dec : forall x y : A, {x = y}+{x <> y}. Fixpoint count_occ (l : list A) (x : A){struct l} : nat := match l with | nil => 0 | y :: tl => let n := count_occ tl x in if eqA_dec y x then S n else n end. Theorem count_occ_In : forall (l : list A) (x : A), In x l <-> count_occ l x > 0. 
end). Definition huni (h1 h2 : heap) : heap := fun k => match lookup h1 k with | Some x => Some x | None => lookup h2 k end. Definition hemp : assertion := fun h => h = empty_heap. Definition hpto (p x : nat) : assertion := fun h => h = add empty_heap p (Some x). Definition hstar (p q : assertion) : assertion := fun h => exists h1 h2, hdsj h1 h2 /\ hspt h h1 h2 /\ p h1 /\ q h2.Definition hand (p q : assertion) : assertion := fun h => p h /\ q h. Definition himp (p q : assertion) : Prop := forall h, p h -> q h. Definition heq (p q : assertion) : Prop := forall h, p h <-> q h. Definition hlift (p : Prop) : assertion := fun h => p.Infix "|->" := hpto (at level 30) : sep_scope. Infix "/~\" := hand (at level 40) : sep_scope. Infix "**" := hstar (at level 40) : sep_scope. Delimit Scope sep_scope with sep. Notation "p ==> q" := (himp p%sep q%sep) (no associativity, at level 70). Notation "p <==> q" := (heq p%sep q%sep) (no associativity, at level 70).Open Scope sep_scope.Ltac hsimpl := unfold hemp, empty_heap, hpto, hstar, hdsj, hspt, huni, hand, himp, heq, hlift, add, lookup in *. Ltac hsolver := match goal with | [ |- context[ if ?c then _ else _ ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ if ?c then _ else _ ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ |- context[ match ?c with Some _ => _ | None => _ end ] ] => let H := fresh "H" in destruct c eqn:H | [ H : context[ match ?c with Some _ => _ | None => _ end ] |- _ ] => let H := fresh "H" in destruct c eqn:H | [ H : (?x <? ?y) = true |- _ ] => rewrite Nat.ltb_lt in H | [ H : (?x <? ?y) = false |- _ ] => rewrite Nat.ltb_nlt in H end; subst; auto.Lemma heap_extensionality : forall (h1 h2 : heap), h1 = h2 -> forall (x : nat), h1 x = h2 x. Proof. crush. Qed.Module SeparationProperty. Theorem pt2same_sep : forall (p x y : nat), p |-> x ** p |-> y ==> hlift False. 
i1 i2 i a1 a2 stk, r#v = Some (value_cons a1 a2) -> estep p r ((instr_if_nil v i1 i2 ;; i) :: stk) r ((i2 ;; i) :: stk) | estep_call : forall p r v l i i' stk, r#v = Some (value_label l) -> p#l = Some i' -> estep p r ((instr_call v ;; i) :: stk) r ((i' ;; instr_assert x) :: i :: stk) | estep_return : forall p r stk i, estep p r ((instr_return ;; i) :: stk) r stk. Inductive estepstar : program X -> store -> list (instr X) -> store -> list (instr X) -> Prop := | estepstar_O: forall p s i, estepstar p s i s i | estepstar_S: forall p s i s' i' s'' i'', estep p s i s' i' -> estepstar p s' i' s'' i'' -> estepstar p s i s'' i''. Definition eventually_ehalts (p:program X) (r:store) (s:list (instr X)) : Prop := exists r', estepstar p r s r' nil. Definition erase_instr : instruction -> instr X := fmap_instr (fun _ => x). Definition erase_prog := map_fmap _ _ erase_instr. Theorem erase_step : forall p p' n r r' s s', step (K.squash (n,p)) p' r s r' s' -> estep (erase_prog p) r (List.map erase_instr s) r' (List.map erase_instr s') /\ exists n', p' = K.squash (n',p). Proof. intros. inv H; unfold erase_instr; simpl in *; try (split; econstructor; eauto; fail). split. eapply estep_call; eauto. unfold prog_lookup in H1. rewrite K.unsquash_squash in H1. simpl in H1. unfold KnotInput.fmap in H1. eapply fmap_eqn2 in H1. destruct H1 as [i'' [? ?]]. unfold erase_prog. erewrite fmap_eqn. 2: eauto. f_equal. subst i'. clear. unfold erase_instr. induction i''; simpl; congruence. hnf in H2. rewrite K.knot_age1 in H2. rewrite K.unsquash_squash in H2. destruct n; try discriminate. inv H2. exists n. apply K.unsquash_inj. repeat rewrite K.unsquash_squash. f_equal. rewrite K.fmap_fmap. change (S n) with (1 +n). rewrite <- K.approx_approx1. auto. Qed. Lemma erase_halt' : forall n p p' r r' s, stepstar (K.squash (n,p)) p' r s r' nil -> estepstar (erase_prog p) r (List.map erase_instr s) r' nil. Proof. intros. remember (K.squash (n,p)) as phat. remember (@nil instruction) as s'. revert Heqphat Heqs'. revert n. induction H; intros. subst i. simpl. econstructor. subst. apply erase_step in H. destruct H. destruct H1. subst p'. spec IHstepstar x0. spec IHstepstar; auto. spec IHstepstar; auto. eapply estepstar_S; eauto. Qed. Theorem erase_halt : forall p n r s, eventually_halts (K.squash (n,p)) r s -> eventually_ehalts (erase_prog p) r (List.map erase_instr s). 
name_in_fundefs_not_inlined': forall f fds im, name_in_fundefs fds f -> get_b f im = false -> bound_var_fundefs (inlined_fundefs_f fds im) f. Proof. induction fds; simpl; intros. - inv H. inv H1. rewrite H0. apply bound_var_fundefs_Fcons. auto. specialize (IHfds _ H1 H0). destruct (get_b v im); eauto with Ensembles_DB. - inv H. Qed. Theorem fundefs_ctx_append_num_occur: forall B1 B2, forall (x : var) (n m : nat), num_occur_fds B1 x n -> num_occur_fdc B2 x m -> num_occur_fdc (fundefs_ctx_append B1 B2) x (n + m). Proof. induction B1; intros. - simpl in H. inv H. simpl. eapply num_occur_fdc_n. constructor. eauto. apply IHB1; eauto. lia. - inv H. auto. Qed. Theorem fundefs_ctx_append_num_occur': forall (B1: fundefs) B2 (nm : nat) (x : var), num_occur_fdc (fundefs_ctx_append B1 B2) x nm -> exists n m : nat, num_occur_fds B1 x n /\ num_occur_fdc B2 x m /\ n + m = nm. Proof. induction B1; intros. - simpl in H. inv H. apply IHB1 in H8. destructAll. exists (n + x0), x1. split. constructor; auto. split; auto. lia. - simpl in H. exists 0, nm. split; auto. constructor. Qed. Theorem rename_all_fun_ns_inlined_fundefs: forall sig im fds, (rename_all_fun_ns sig (inlined_fundefs_f fds im)) = (inlined_fundefs_f (rename_all_fun_ns sig fds) im). Proof. induction fds; simpl. - destruct (get_b v im). + auto. + simpl. rewrite IHfds. auto. - auto. Qed. Theorem update_count_inlined_unaffected: forall v0 lx ly count, ~FromList lx v0 -> ~FromList ly v0 -> get_c v0 (update_count_inlined ly lx count) = get_c v0 count. Proof. induction lx; intros. destruct ly; simpl; auto. destruct ly. simpl. auto. simpl. erewrite IHlx. rewrite gdso. rewrite gdso. auto. intro; apply H. constructor; auto. intro; apply H0. constructor; auto. intro; apply H. constructor 2; auto. intro; apply H0. constructor 2; auto. Qed. Theorem update_count_inlined_dom: forall v0 lx ly count, List.length lx = List.length ly -> FromList lx v0 -> Disjoint _ (FromList ly) (FromList lx) -> get_c v0 (update_count_inlined ly lx count) = 0. Proof. induction lx; intros. inv H0. destruct ly; inv H. simpl. assert (Hlx := Decidable_FromList lx). inv Hlx. specialize (Dec v0). inv Dec. eapply IHlx. auto. auto. split; intro. intro. inv H1. specialize (H4 x). apply H4. inv H2. split; constructor 2; auto. inv H0. rewrite update_count_inlined_unaffected. rewrite gdso. rewrite gdss. auto. inv H1. specialize (H0 v0). intro; subst. apply H0. split; constructor; auto. auto. inv H1. specialize (H0 v0). intro; apply H0. split. constructor 2; auto. constructor. auto. exfalso; auto. Qed. Theorem dead_occur_fds_le_antimon: forall im im' : b_map, b_map_le im im' -> forall (f : var) (f4 : fundefs), num_occur_fds (inlined_fundefs_f f4 im) f 0 -> num_occur_fds (inlined_fundefs_f f4 im') f 0. 
_. hstep. { hsteps_cbn;cbn. intros yout. hintros (?&Hy&?&->&_&<-). set (y:=@ssrbool.isSome (boundary + Œ£) yout). refine (_ : Entails _ ‚âÉ‚âÉ([ y=match bs with [] => false | _ => true end],_)). subst y yout. tspec_ext. destruct bs;cbn in Hbs;eapply tape_local_l_move_left in Hbs;cbn in Hbs. now destruct (tape_move_left tin);cbn in Hbs|-*;congruence. destruct bs;cbn in Hbs;eapply tape_local_l_current_cons in Hbs. all:now rewrite Hbs. } 2:{destruct bs;hintros [=];[]. cbn in *. hsteps_cbn. tspec_ext. 1-2:assumption. destruct H0 as (?&?&?&?&->&?&<-). rewrite H0. erewrite tape_move_left_right. all:easy. } { destruct bs;hintros [=];[]. cbn in *. hsteps. { tspec_ext;cbn in *. contains_ext. } { intros. hsteps_cbn. tspec_ext. 1-3:easy. 2:now destruct H0 as (?&?&?&?&?);congruence. f_equal. destruct b0;decide _. all:congruence. } cbv. reflexivity. } cbn. intros ? ->. destruct bs. 2:reflexivity. nia. } split. - intros [Hres Hbs] _;cbn. split. 2:{ cbn. [c2]:exact 14. subst c2. fold plus. nia. } destruct bs as [ | ];cbn. 2:easy. apply midtape_tape_local_l_cons in Hbs. rewrite Hres in Hbs. rewrite Hbs. reflexivity. - intros H. destruct bs as [ | b' bs]. easy. intros Hres Hbs. cbn in Hbs. apply midtape_tape_local_l_cons in Hbs. rewrite Hres in Hbs. eexists ((bs,b'::res),tape_move_left tin). repeat eapply conj. +cbn. erewrite tape_right_move_left. 2:subst;reflexivity. erewrite tape_local_l_move_left. 2:subst;reflexivity. rewrite Hres. tspec_ext. easy. + subst c2;cbn;ring_simplify. [c1]:exact 15. unfold c1;fold plus;nia. + cbn. rewrite <- !app_assoc. reflexivity. Qed. Definition M : pTM (Œ£) ^+ unit 2 := (MoveToSymbol (fun _ => false) (fun x => x);;Move Lmove) @ [|Fin0|];; WriteValue (@nil bool)‚áë retr_list @ [|Fin1|];; M__loop. Lemma SpecT (H__neq : s <> b): { f : UpToC (fun bs => length bs + 1) & forall bs, TripleT (‚âÉ‚âÉ([],[| Custom (eq (encBoolsTM s b bs)); Void|]) ) (f bs) M (fun _ => ‚âÉ‚âÉ([],[|Custom (eq (encBoolsTM s b bs)) ; Contains _ bs|])) }. Proof. evar (f : nat -> nat). exists_UpToC (fun bs => f (length bs)). 2:now shelve. unfold M. intros bs. hstep. {hsteps_cbn. reflexivity. } hnf. intros _. hstep. {hsteps_cbn. reflexivity. } 2:reflexivity. cbn. intros _. { eapply ConsequenceT. eapply (projT2 (loop_SpecT H__neq)) with (bs:=_)(res:=_) (tin:=_). 3:reflexivity. 2:{ intro;cbn. rewrite rev_involutive,app_nil_r. reflexivity. } eapply EntailsI. intros tin. unfold encBoolsTM,encBoolsListTM. rewrite MoveToSymbol_correct_midtape_end. 2:easy. intros [_ H]%tspecE. specializeFin H. destruct H0 as (?&H0&<-). tspec_solve. 2:rewrite H0;reflexivity. cbn. split. easy. rewrite <- map_rev,map_map;cbn. destruct (rev bs);cbn. all:easy. } cbn - ["+"]. rewrite UpToC_le. ring_simplify. unfold encBoolsTM,encBoolsListTM. rewrite MoveToSymbol_steps_midtape_end. 2:easy. rewrite map_length,rev_length. [f]:intros n. now unfold f;set (n:=length bs);reflexivity. Unshelve. subst f;cbn beta. smpl_upToC_solve. Qed. Theorem Realise (H__neq : s <> b): Realise M (fun t '(r, t') => forall (l : list bool), t[@Fin0] = encBoolsTM s b l -> isVoid t[@Fin1] -> t[@Fin0] = t'[@Fin0] /\ t'[@Fin1] ‚âÉ l). 
Set Implicit Arguments.Require Export Notations.Notation "A -> B" := (forall (_ : A), B) : type_scope.Inductive True : Prop := I : True. Inductive False : Prop :=. Definition not (A:Prop) := A -> False.Notation "~ x" := (not x) : type_scope.Create HintDb core. Hint Variables Opaque : core. Hint Constants Opaque : core.Hint Unfold not: core. Inductive and (A B:Prop) : Prop := conj : A -> B -> A /\ Bwhere "A /\ B" := (and A B) : type_scope.Section Conjunction. Variables A B : Prop. Theorem proj1 : A /\ B -> A. Proof. destruct 1; trivial. Qed. Theorem proj2 : A /\ B -> B. 
Require Import Iron.Language.SystemF2.SubstTypeType. Require Import Iron.Language.SystemF2.TyJudge. Theorem subst_type_exp_ix : forall ix ke te x1 t1 t2 k2 , get ix ke = Some k2 -> TYPE ke te x1 t1 -> KIND (delete ix ke) t2 k2 -> TYPE (delete ix ke) (substTE ix t2 te) (substTX ix t2 x1) (substTT ix t2 t1). 
E : Set; E_0 : E; E_1 : E; sum : E -> E -> E; prod : E -> E -> E; distinct_0_1: E_0 <> E_1; sum_is_assoc : Monoid.is_assoc E sum; sum_is_comm : Abelian_Group.is_comm E sum; sum_id_l : Monoid.is_id_l E sum E_0; sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0; prod_is_assoc : Monoid.is_assoc E prod; prod_is_comm : Abelian_Group.is_comm E prod; prod_id_l : Monoid.is_id_l E prod E_1; prod_sum_distrib_l : Ring.is_distrib_l E prod sum }. Arguments E_0 {c}.Arguments E_1 {c}.Arguments sum {c} x y.Arguments prod {c} x y.Arguments distinct_0_1 {c} _.Arguments sum_is_assoc {c} x y z.Arguments sum_is_comm {c} x y.Arguments sum_id_l {c} x.Arguments sum_inv_l_ex {c} x.Arguments prod_is_assoc {c} x y z.Arguments prod_id_l {c} x.Arguments prod_sum_distrib_l {c} x y z.Arguments prod_is_comm {c} x y.Notation "0" := E_0 : commutative_ring_scope.Notation "1" := E_1 : commutative_ring_scope.Notation "x + y" := (sum x y) (at level 50, left associativity) : commutative_ring_scope.Notation "{+}" := sum : commutative_ring_scope.Notation "x # y" := (prod x y) (at level 50, left associativity) : commutative_ring_scope.Notation "{#}" := prod : commutative_ring_scope.Open Scope commutative_ring_scope.Section Theorems. Variable r : Commutative_Ring. Let E := E r. Definition sum_is_id_l := Monoid.is_id_l E {+}. Definition sum_is_id_r := Monoid.is_id_r E {+}. Definition sum_is_id := Monoid.is_id E {+}. Definition prod_is_id_l := Monoid.is_id_l E {#}. Definition prod_is_id_r := Monoid.is_id_r E {#}. Definition prod_is_id := Monoid.is_id E {#}. Theorem prod_id_r : prod_is_id_r 1. Proof fun x : E => eq_ind_r (fun a => a = x) (prod_id_l x) (prod_is_comm x 1). Theorem prod_sum_distrib_r : Ring.is_distrib_r E {#} {+}. Proof fun x y z : E => prod_sum_distrib_l x y z || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z || a = (y # x) + (z # x) @a by <- prod_is_comm x (y + z). Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r. Definition sum_abelian_group := Ring.sum_abelian_group ring. Definition sum_group := Ring.sum_group ring. Definition sum_monoid := Ring.sum_monoid ring. Definition prod_monoid := Ring.prod_monoid ring. Theorem distinct_1_0 : E_1 (c := r) <> E_0 (c := r). Proof fun H : E_1 = E_0 => distinct_0_1 (eq_sym H). Definition nonzero : E -> Prop := Ring.nonzero ring. Theorem sum_id_r : sum_is_id_r 0. Proof Ring.sum_id_r ring. Theorem sum_id : sum_is_id 0. 
permutation_trans with (1 := Hl3). rewrite Hl5. apply permutation_trans with ((l5 ++ node t0 t3 :: l6) ++ l3); auto. change (permutation ((l5 ++ node t0 t3 :: l6) ++ l3) ((node t0 t3 :: l5 ++ l6) ++ l3)) in |- *; auto. apply permutation_app_comp; auto. apply permutation_trans with ((node t0 t3 :: l6) ++ l5); auto. simpl in |- *; auto. Qed. Theorem cover_inv_app : forall t1 t2 l, cover l (node t1 t2) -> l = node t1 t2 :: nil \/ (exists l1 : _, (exists l2 : _, (cover l1 t1 /\ cover l2 t2) /\ permutation l (l1 ++ l2))). Proof using. intros t1 t2 l H; apply cover_inv_app_aux with (t := node t1 t2); auto. Qed. Theorem cover_app : forall t1 t2 l1 l2, cover l1 t1 -> cover l2 t2 -> cover (l1 ++ l2) (node t1 t2). Proof using. intros t1 t2 l1 l2 H1; generalize t2 l2; elim H1; clear t1 t2 l1 l2 H1; simpl in |- *; auto. intros t t2 l2 H; apply cover_cons_l; auto. intros l1 l2 t1 t2 t3 H H0 H1 t0 l0 H2. apply cover_node with (l2 := l2 ++ l0) (t1 := t1) (t2 := t2); auto. apply permutation_trans with ((t1 :: t2 :: l2) ++ l0); auto. Qed. Theorem cover_number_of_nodes : forall t l, cover l t -> number_of_nodes t = fold_left (fun x y => x + number_of_nodes y) l 0 + pred (length l). Proof using. intros t l H; elim H; clear H t l; simpl in |- *; auto. intros l1 l2 t1 t2 t3 H H0 H1. apply trans_equal with (1 := H1). rewrite fold_left_permutation with (2 := H); simpl in |- *; auto. rewrite permutation_length with (1 := H); simpl in |- *; auto. rewrite fold_left_init with (h := S); simpl in |- *; auto. intros a b1 b2; repeat rewrite plus_assoc_reverse. apply f_equal2 with (f := plus); auto; apply plus_comm. Qed. Fixpoint all_cover_aux (l : list (btree A)) (n : nat) {struct n} : list (btree A) := match n with | O => nil | S n1 => flat_map (fun l1 => match l1 with | nil => nil | a :: nil => a :: nil | a :: b :: l2 => all_cover_aux (node a b :: l2) n1 end) (all_permutations l) end. Definition all_cover l := all_cover_aux l (length l). Theorem all_cover_aux_cover : forall (n : nat) l t, n = length l -> In t (all_cover_aux l n) -> cover l t. 
redIn1; auto. apply zerop_red_spoly_r; auto. lapply (spolyp_addEnd_genPcPf l); [ intros H'4; elim (H'4 (genOCPf l) a a0); [ intros c E; elim E; intros H'11 H'12; elim H'12; intros H'13 H'14; elim H'13; [ intros H'15; clear H'13 H'12 E | intros H'15; clear H'13 H'12 E ] | idtac | idtac | idtac ] | idtac ]; auto. apply redIn2 with (c := c); auto. simpl in |- *; auto. apply redInInclQ with (Q := genOCPf l); auto. apply redInclP with (P := l); auto. apply H'; auto. apply incl_tran with (m := a :: l); simpl in |- *; auto. apply redIn2 with (c := c); auto. simpl in |- *; auto. apply redIn1; auto. apply red_incl with (p := addEnd A A0 eqA n ltM a l) (1 := cs); auto. apply addEnd_incl; auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. elim H'1; [ intros H'2; rewrite <- H'2; clear H'1 | intros H'2; clear H'1 ]; auto. case (zerop_dec A A0 eqA n ltM a); intros Z; auto. apply redIn1; auto. apply zerop_red_spoly_l; auto. case (zerop_dec A A0 eqA n ltM b); intros Z1; auto. apply redIn1; auto. apply zerop_red_spoly_r; auto. lapply (spolyp_addEnd_genPcPf l); [ intros H'4; elim (H'4 (genOCPf l) a b); [ intros c E; elim E; intros H'11 H'12; elim H'12; intros H'13 H'14; elim H'13; [ intros H'15; clear H'13 H'12 E | intros H'15; clear H'13 H'12 E ] | idtac | idtac | idtac ] | idtac ]; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redInInclQ with (Q := genOCPf l); auto. apply redInclP with (P := l); auto. apply H'; auto. apply incl_tran with (m := a :: l); simpl in |- *; auto. apply redIn2 with (c := c); simpl in |- *; auto. apply redIn1; auto. apply red_incl with (1 := cs) (p := addEnd A A0 eqA n ltM a l); auto. apply addEnd_incl; auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. apply redInclP with (P := l); auto. apply redInInclQ with (Q := genOCPf l); auto. apply H'; auto. apply incl_tran with (m := a :: l); auto. Qed. Theorem OBuch_Stable_f : forall P Q : list (poly A0 eqA ltM), OBuch P (genOCPf P) Q -> stable P Q. 
0). simpl. fcf_ident_expand_l. comp_skip. eapply comp_spec_ret; intuition. omega. simpl in H1. intuition; subst. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_close : | Pr[G1] - Pr[G2] | <= (q / 1) * k. rewrite G1_eq_Gi_q. rewrite G2_eq_Gi_0. rewrite ratDistance_comm. specialize (distance_le_prod_f (fun i => Pr[Gi i])); intuition. Qed.End OracleHybrid.Require Import FCF.CompFold. Require Import FCF.OracleCompFold. Require Import FCF.PRF.Section OracleMapHybrid. Variable A B C State S_A : Set. Variable b : B. Hypothesis eqdA : EqDec A. Hypothesis eqdB : EqDec B. Hypothesis eqdState : EqDec State. Hypothesis eqdS_A : EqDec S_A. Variable A1 : Comp (State * (list A * S_A)). Variable A2 : S_A -> list B -> Comp bool. Hypothesis A1_wf : well_formed_comp A1. Hypothesis A2_wf : forall s_A lsb, well_formed_comp (A2 s_A lsb). Variable q : nat. Variable k : Rat. Hypothesis max_queries : forall ls s s_A, In (s, (ls, s_A)) (getSupport A1) -> (length ls <= q)%nat. Variable O1 O2 : State -> A -> Comp (B * State). Hypothesis O1_wf : forall s a, well_formed_comp (O1 s a). Hypothesis O2_wf : forall s a, well_formed_comp (O2 s a). Definition OMH_G O := [s, p] <-$2 A1; [lsa, s_A] <-2 p; [lsb, _] <-$2 oracleMap _ _ O s lsa; A2 s_A lsb. Definition OMH_G_i i := [s, p] <-$2 A1; [lsa, s_A] <-2 p; [lsb1, s'] <-$2 oracleMap _ _ O1 s (firstn i lsa); [lsb2, _] <-$2 oracleMap _ _ O2 s' (skipn i lsa); A2 s_A (lsb1 ++ lsb2). Hypothesis adjacent_close : forall i, | Pr[OMH_G_i i] - Pr[OMH_G_i (S i)] | <= k. Definition OMH_G_oc (p : list A * S_A) := [lsa, s_A] <-2 p; lsb <--$ oc_compMap _ (fun a => OC_Query _ a) lsa; $ A2 s_A lsb. Theorem OMH_G_oc_wf : forall p, well_formed_oc (OMH_G_oc p). intuition. econstructor. apply oc_compMap_wf. intuition. econstructor. intuition. econstructor. auto. Qed. Theorem OMH_G_oc_equiv : forall O, Pr[OMH_G O] == Pr[ [s, s_A] <-$2 A1; [b, _] <-$2 (OMH_G_oc s_A) _ _ O s; ret b ]. intuition. unfold OMH_G, OMH_G_oc. fcf_skip. fcf_simp. fcf_to_prhl_eq. simpl. fcf_inline_first. fcf_skip. apply compFold_oc_equiv. subst. fcf_inline_first. fcf_ident_expand_l. fcf_skip. fcf_simp. fcf_spec_ret. Qed. Definition OMH_G1 := OMH_G O1. Definition OMH_G2 := OMH_G O2. Theorem OMH_G1_equiv: Pr[OMH_G1] == Pr[G1 _ O1 A1 OMH_G_oc]. unfold OMH_G1. rewrite OMH_G_oc_equiv. unfold G1, OMH_G_oc. reflexivity. Qed. Theorem OMH_G2_equiv: Pr[OMH_G2] == Pr[G2 _ O2 A1 OMH_G_oc]. unfold OMH_G2. rewrite OMH_G_oc_equiv. unfold G2, OMH_G_oc. reflexivity. Qed. Theorem OMH_G_oc_qam : forall p s, In (s, p) (getSupport A1) -> queries_at_most (OMH_G_oc p) q. 
Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, Q b -> prop a b)} : Checkable (forall a b, P a /\ Q b -> prop a b) := {| checker f := checker (fun a P b Q => f a b _ ) |}. Proof. split; auto. Defined.Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Admitted. Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. Admitted. Instance testSuchThat_Disj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, prop a b)} `{Checkable (forall b, Q b -> forall a, prop a b)} : Checkable (forall a b, P a \/ Q b -> prop a b) := {| checker f := disjoin (Datatypes.cons (checker (fun a P b => f a b _ )) (Datatypes.cons (checker (fun b Q a => f a b _)) Datatypes.nil)) |}. Proof. - left; auto. - right; auto. Defined. Lemma or_example : forall n m : nat, n = 0 \/ m = 0 -> n * m = 0. Admitted. Lemma or_intro : forall A B : Prop, A -> A \/ B. Admitted. Lemma zero_or_succ : forall n : nat, n = 0 \/ n = S (pred n). Admitted. Lemma mult_eq_0 : forall n m, n * m = 0 -> n = 0 \/ m = 0. Admitted. Theorem or_commut : forall P Q : Prop, P \/ Q -> Q \/ P. Admitted. Fact not_implies_our_not : forall (P:Prop), ~ P -> (forall (Q:Prop), P -> Q). Admitted. Theorem contradiction_implies_anything : forall P Q : Prop, (P /\ ~P) -> Q. Admitted. Theorem contrapositive : forall (P Q : Prop), (P -> Q) -> (~Q -> ~P). Admitted. Theorem not_both_true_and_false : forall P : Prop, ~ (P /\ ~P). Admitted. Theorem not_true_is_false : forall b : bool, b <> true -> b = false. 
key2 sk2 (keepGt ts key1 k) p2 end. Fixpoint stack (len key1 key2 : W) (tss : list (tuples * W)) (p : W) : HProp := match tss with | nil => [| p = 0 |] | (ts, tp) :: tss' => [| p <> 0 |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key1 key2 sk ts tp * stack len key1 key2 tss' p' end. Definition tuples2 (len key1 key2 : W) (ts : tuples) (c : W) : HProp := [| c <> 0 |] * [| freeable c 4 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key1, key2, p) * tree len key1 key2 sk ts p * [| key1 < len |] * [| key2 < len |]. Theorem stack_nil_fwd : forall len key1 key2 tss (p : W), p = 0 -> stack len key1 key2 tss p ===> [| tss = nil |]. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_nil_bwd : forall len key1 key2 tss (p : W), p = 0 -> [| tss = nil |] ===> stack len key1 key2 tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_fwd : forall len key1 key2 tss (p : W), p <> 0 -> stack len key1 key2 tss p ===> Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key1 key2 sk ts tp * stack len key1 key2 tss' p'. Proof. destruct tss as [ ? | [ ] ]; sepLemma. Qed. Theorem stack_cons_bwd : forall len key1 key2 tss (p : W), p <> 0 -> (Ex ts, Ex tp, Ex tss', [| tss = (ts, tp) :: tss' |] * [| freeable p 2 |] * [| functional ts |] * Ex sk, Ex p', (p ==*> tp, p') * tree len key1 key2 sk ts tp * stack len key1 key2 tss' p') ===> stack len key1 key2 tss p. Proof. destruct tss as [ ? | [ ] ]; sepLemma. injection H0; sepLemma; auto. injection H0; sepLemma. Qed. Theorem tuples2_fwd : forall len key1 key2 ts c, tuples2 len key1 key2 ts c ===> [| c <> 0 |] * [| freeable c 4 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key1, key2, p) * tree len key1 key2 sk ts p * [| key1 < len |] * [| key2 < len |]. 
Require Export List. Require Import Inclusion. Require Import Inverse_Image. Require Import Wf_nat. Require Import Relation_Definitions. Require Import Relation_Operators. Require Import Relation_Operators_compat. Require Import Lexicographic_Product. Require Import LetP. Require Export WfR0. Section Buch. Load "hCoefStructure". Load "hOrderStructure". Load "hWfRO". Inductive stable : list (poly A0 eqA ltM) -> list (poly A0 eqA ltM) -> Prop := stable0 : forall P Q : list (poly A0 eqA ltM), (forall a : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q) -> (forall a : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable P Q. Hint Resolve stable0. Theorem stable_refl : forall Q : list (poly A0 eqA ltM), stable Q Q. auto. Qed. Theorem stable_trans : forall Q y R : list (poly A0 eqA ltM), stable Q y -> stable y R -> stable Q R. intros Q y R H' H'0; inversion H'; inversion H'0; auto. Qed. Theorem stable_sym : forall Q R : list (poly A0 eqA ltM), stable R Q -> stable Q R. intros Q R H'; elim H'; auto. Qed. Hint Resolve (Cb_in _ _ _ _ _ _ _ _ _ cs eqA_dec _ _ ltM_dec os). Theorem Cb_stable : forall (a : poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a Q -> stable Q (addEnd A A0 eqA n ltM a Q). intros a Q H'0; apply stable0; auto. intros a0 H'1. apply Cb_trans with (b := a) (1 := cs); auto. Qed. Theorem in_incl : forall (A : Set) (p q : list A) (a b : A), incl p q -> In a p -> In a q. 
From RecordUpdate Require Import RecordSet.From Perennial.Helpers Require Import ModArith. From Perennial.goose_lang Require Import crash_modality recovery_lifting.From Goose.github_com.mit_pdos.perennial_examples Require Import toy. From Perennial.goose_lang Require Import crash_borrow. From Perennial.program_proof Require Import disk_lib. From Perennial.program_proof Require Import disk_prelude.Section goose. Context `{!heapGS Œ£}. Context `{!stagedG Œ£}. Definition EBlk (addr: u64) := (‚àÉ v n, "Ha" ‚à∑ int.Z addr d‚Ü¶ v ‚àó "%H0iseven" ‚à∑ ‚åú Block_to_vals v !! O = Some #(U8 n) ‚àß Z.even n ‚åù)%I. Definition written_slice : list val := <[int.nat 0:=#(U8 4)]> (replicate (int.nat 4096) (zero_val byteT)). Definition written_block : Block := list_to_vec (U8 4 :: replicate (int.nat 4095) (U8 0)). Lemma written_slice_to_written_block: written_slice = Block_to_vals written_block. Proof. rewrite /written_slice. change (zero_val byteT) with #(U8 0). change (int.nat 4095) with (Z.to_nat 4095). rewrite /Block_to_vals /written_block //=. Qed. Theorem wpc_consumeEvenBlock_seq {E1} (d_ref: loc) (addr: u64) : {{{ EBlk addr }}} consumeEvenBlock #d_ref #addr @ E1 {{{ RET #(); EBlk addr }}} {{{ EBlk addr }}}. 
f (get' i m1) (get' i m2). Proof using A B C f f_None_None. induction m1; destruct m2; intros; simpl; rewrite gNode; destruct i; simpl; auto using gcombine'_l, gcombine'_r. Qed. Lemma combine'_by_tac_eq: combine'_by_tac = combine'_direct. Proof using Type. reflexivity. Qed. Definition combine (m1: tree A) (m2: tree B) : tree C := match m1, m2 with | Empty, Empty => Empty | Empty, Nodes m2 => combine'_r m2 | Nodes m1, Empty => combine'_l m1 | Nodes m1, Nodes m2 => combine'_by_tac m1 m2 end. Theorem gcombine: forall (m1: tree A) (m2: tree B) (i: positive), get i (combine m1 m2) = f (get i m1) (get i m2). Proof using A B C f f_None_None. intros. destruct m1 as [ | m1], m2 as [ | m2]; simpl. - auto. - apply gcombine'_r. - apply gcombine'_l. - apply gcombine'_by_tac. Qed. Definition combine_view_gen (m1: tree A) (m2: tree B) : tree C := tree_rec (map_filter (fun b => f None (Some b))) (fun l1 lrec o1 r1 rrec => tree_case (map_filter (fun a => f (Some a) None) (Node l1 o1 r1)) (fun l2 o2 r2 => Node (lrec l2) (f o1 o2) (rrec r2))) m1 m2. Definition combine_view := Eval cbv [combine_view_gen tree_rec tree_rec' tree_case] in combine_view_gen. Theorem gcombine_view: forall (m1: tree A) (m2: tree B) (i: positive), get i (combine_view m1 m2) = f (get i m1) (get i m2). Proof using A B C f f_None_None. change combine_view with combine_view_gen. unfold combine_view_gen. induction m1 using tree_ind; intros. - simpl. rewrite gmap_filter. destruct (get i m2); auto. - rewrite unroll_tree_rec by auto. induction m2 using tree_ind; intros. + simpl. rewrite gmap_filter. destruct (get i (Node m1_1 o m1_2)); auto. + rewrite unroll_tree_case by auto. rewrite ! gNode. destruct i; auto. Qed. End COMBINE. Lemma tree'_not_empty: forall (A: Type) (m: tree' A), exists i, get' i m <> None. Proof. induction m; simpl; try destruct IHm as [p H]. - exists (xI p); auto. - exists xH; simpl; congruence. - exists xH; simpl; congruence. - exists (xO p); auto. - destruct IHm1 as [p H]; exists (xO p); auto. - exists xH; simpl; congruence. - exists xH; simpl; congruence. Qed. Corollary extensionality_empty: forall (A: Type) (m: tree A), (forall i, get i m = None) -> m = Empty. Proof. intros. destruct m as [ | m]; auto. destruct (tree'_not_empty m) as [i GET]. elim GET. apply H. Qed. Theorem extensionality: forall (A: Type) (m1 m2: tree A), (forall i, get i m1 = get i m2) -> m1 = m2. 
heapSizeLowerBound' : (3 <= heapSize')%nat. intros; unfold heapSize'; rewrite Hide.to_nat_eq. assert (heapSize >= 3)%N by (apply N.le_ge; auto); nomega. Qed. Definition size := heapSize' + 50 + 2. Hypothesis mem_size : goodSize (size * 4)%nat. Let heapSizeUpperBound : goodSize (heapSize' * 4). goodSize. Qed. Lemma heapSizeLowerBound'' : natToW 3 <= NToW heapSize. hnf; intros. red in H. pre_nomega. rewrite wordToNat_natToWord_idempotent in H by reflexivity. unfold heapSize' in *. rewrite Hide.to_nat_eq in *. unfold NToW in *. rewrite NToWord_nat in *. rewrite wordToNat_natToWord_idempotent in H. omega. rewrite N2Nat.id. eapply goodSize_weaken in mem_size. 2: instantiate (1 := N.to_nat heapSize); unfold size. Transparent goodSize. unfold goodSize in *. rewrite N2Nat.id in *. assumption. unfold heapSize'. rewrite Hide.to_nat_eq. omega. Qed. Hint Immediate heapSizeLowerBound''. Definition appmainS := SPEC reserving 49 PREonly[_] mallocHeap 0. Definition bootS := bootS heapSize' 2. Definition boot := bimport [[ "malloc"!"init" @ [Malloc.initS], "app"!"main" @ [appmainS] ]] bmodule "main" {{ bfunctionNoRet "main"() [bootS] Sp <- (heapSize * 4)%N;; Assert [PREmain[_] globalSched =?> 2 * 0 =?> heapSize'];; Call "malloc"!"init"(0, heapSize) [PREmain[_] globalSched =?> 2 * mallocHeap 0];; Goto "app"!"main" end }}. Lemma bootstrap_Sp_nonzero : forall sp : W, sp = 0 -> sp = (heapSize' * 4)%nat -> goodSize (heapSize' * 4) -> False. intros; eapply bootstrap_Sp_nonzero; try eassumption; eauto. Qed. Lemma bootstrap_Sp_freeable : forall sp : W, sp = (heapSize' * 4)%nat -> freeable sp 50. intros; eapply bootstrap_Sp_freeable; try eassumption; eauto. Qed. Lemma noWrap : noWrapAround 4 (wordToNat (NToW heapSize) - 1). intros. unfold NToW; rewrite NToWord_nat by auto. unfold heapSize' in *; rewrite Hide.to_nat_eq in *. rewrite wordToNat_natToWord_idempotent. apply noWrap; eauto. eapply goodSize_weaken. 2: instantiate (1 := (heapSize' * 4)%nat). unfold heapSize'; rewrite Hide.to_nat_eq; auto. unfold heapSize'; rewrite Hide.to_nat_eq; auto. Qed. Local Hint Immediate bootstrap_Sp_nonzero bootstrap_Sp_freeable noWrap. Lemma break : NToW ((heapSize + 50) * 4)%N = ((heapSize' + 50) * 4)%nat. intros. unfold NToW; rewrite NToWord_nat by auto. unfold heapSize'; rewrite N2Nat.inj_mul; auto. rewrite Hide.to_nat_eq; rewrite N2Nat.inj_add; auto. Qed. Lemma times4 : (Hide.heapSize4 heapSize : W) = (heapSize' * 4)%nat. rewrite Hide.heapSize4_eq; intros. unfold NToW; rewrite NToWord_nat by auto. unfold heapSize'; rewrite N2Nat.inj_mul; auto. rewrite Hide.to_nat_eq; auto. Qed. Lemma wordToNat_heapSize : wordToNat (NToW heapSize) = heapSize'. unfold heapSize'; rewrite Hide.to_nat_eq. unfold NToW. rewrite NToWord_nat. apply wordToNat_natToWord_idempotent. eapply goodSize_weaken. 2: instantiate (1 := (heapSize' * 4)%nat). auto. unfold heapSize'; rewrite Hide.to_nat_eq; auto. Qed. Hint Rewrite break times4 wordToNat_heapSize : sepFormula. Ltac t := unfold globalSched, localsInvariantMain, globalSched; genesis. Theorem ok0 : moduleOk boot. 
Require Import Verdi.GhostSimulations.Require Import VerdiRaft.CommonTheorems. Require Import VerdiRaft.Raft. Require Import VerdiRaft.SortedInterface. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.StateMachineSafetyPrimeInterface. Require Import VerdiRaft.LeaderCompletenessInterface. Require Import VerdiRaft.LeaderLogsContiguousInterface. Require Import VerdiRaft.AllEntriesLeaderLogsInterface. Require Import VerdiRaft.LogMatchingInterface. Require Import VerdiRaft.UniqueIndicesInterface. Require Import VerdiRaft.AppendEntriesRequestLeaderLogsInterface. Require Import VerdiRaft.LeaderLogsSortedInterface. Require Import VerdiRaft.LeaderLogsLogMatchingInterface. Require Import VerdiRaft.LogsLeaderLogsInterface. Require Import VerdiRaft.OneLeaderLogPerTermInterface. Require Import VerdiRaft.RefinedLogMatchingLemmasInterface.Local Arguments update {_} {_} {_} _ _ _ _ : simpl never.Section StateMachineSafety'. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lci : leader_completeness_interface}. Context {aelli : all_entries_leader_logs_interface}. Context {lmi : log_matching_interface}. Context {uii : unique_indices_interface}. Context {aerlli : append_entries_leaderLogs_interface}. Context {llsi : leaderLogs_sorted_interface}. Context {lsi : sorted_interface}. Context {llci : leaderLogs_contiguous_interface}. Context {lllmi : leaderLogs_entries_match_interface}. Context {llli : logs_leaderLogs_interface}. Context {ollpti : one_leaderLog_per_term_interface}. Context {rlmli : refined_log_matching_lemmas_interface}. Theorem lift_log_matching : forall net, refined_raft_intermediate_reachable net -> log_matching (deghost net). Proof using lmi rri. intros. eapply lift_prop; eauto using log_matching_invariant. Qed. Theorem lift_sorted : forall net, refined_raft_intermediate_reachable net -> logs_sorted (deghost net). 
a b H; right; left; exists l3; auto. intros a l H l2 l3 l4 a0 b; case l3; simpl in |- *. case l; simpl in |- *. intros H0; right; right; injection H0; split; auto. apply f_equal2 with (f := cons (A:=A)); auto. intros b0 l0 H0; left; exists l0; injection H0; intros; repeat apply f_equal2 with (f := cons (A:=A)); auto. intros b0 l0 H0; case (H l2 l0 l4 a0 b); auto. injection H0; auto. intros (l5, HH1); left; exists l5; apply f_equal2 with (f := cons (A:=A)); auto; injection H0; auto. intros [H1| (H1, H2)]; auto. right; right; split; auto; apply f_equal2 with (f := cons (A:=A)); auto; injection H0; auto. Qed. Theorem same_length_ex : forall (a : A) l1 l2 l3, length (l1 ++ a :: l2) = length l3 -> exists l4 : _, (exists l5 : _, (exists b : B, length l1 = length l4 /\ length l2 = length l5 /\ l3 = l4 ++ b :: l5)). Proof using. intros a l1; elim l1; simpl in |- *; auto. intros l2 l3; case l3; simpl in |- *; try (intros; discriminate). intros b l H; exists (nil (A:=B)); exists l; exists b; repeat (split; auto). intros a0 l H l2 l3; case l3; simpl in |- *; try (intros; discriminate). intros b l0 H0. case (H l2 l0); auto. intros l4 (l5, (b1, (HH1, (HH2, HH3)))). exists (b :: l4); exists l5; exists b1; repeat (simpl in |- *; split; auto). apply f_equal2 with (f := cons (A:=B)); auto. Qed. Theorem in_map_inv : forall (b : B) (l : list A), In b (map f l) -> exists a : A, In a l /\ b = f a. Proof using. intros b l; elim l; simpl in |- *; auto. intros tmp; case tmp. intros a0 l0 H [H1| H1]; auto. exists a0; auto. case (H H1); intros a1 (H2, H3); exists a1; auto. Qed. Theorem in_map_fst_inv : forall a (l : list (B * C)), In a (map (fst (B:=_)) l) -> exists c : _, In (a, c) l. Proof using. intros a l; elim l; simpl in |- *; auto. intros H; case H. intros a0 l0 H [H0| H0]; auto. exists (snd a0); left; rewrite <- H0; case a0; simpl in |- *; auto. case H; auto; intros l1 Hl1; exists l1; auto. Qed. Theorem length_map : forall l, length (map f l) = length l. 
Hmsg; inversion Hmsg). subst; simpl in *. destruct H5 as [[_ Howner] _]; auto. Qed. Theorem Property_unpause_only_by_owner: forall msg, m_func msg = mc_unpause -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C). Proof. intros msg Hmsg env C C' evts Hstep. inversion Hstep; try (subst msg; simpl in Hmsg; inversion Hmsg). subst; simpl in *. destruct H5 as [[_ Howner] _]; auto. Qed. Theorem Property_restricted_owner_for_transfer: forall msg to v, m_func msg = mc_transfer to v -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) /\ acct <> to -> st_balances (w_st C) acct = st_balances (w_st C') acct. Proof. intros msg to v Hfunc env C C' evts Hstep Hsender acct Hacct. destruct Hacct as [Hacct_owner Hacct_to]. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). subst; simpl in *. destruct H5 as [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]. rewrite Hbalances. unfold a2v_upd_dec, a2v_upd_inc. subst sender. apply neq_beq_false in Hacct_owner. apply neq_beq_false in Hacct_to. rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)). rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_owner)). reflexivity. Qed. Theorem Property_restricted_owner_for_transferFrom: forall msg from to v, m_func msg = mc_transferFrom from to v -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> from /\ acct <> to -> st_balances (w_st C) acct = st_balances (w_st C') acct. Proof. intros msg from to v Hfunc env C C' evts Hstep Hsender acct Hacct. destruct Hacct as [Hacct_from Hacct_to]. inversion Hstep; try (subst msg; simpl in Hfunc; inversion Hfunc). - subst; simpl in *. destruct H2 as [_ [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]]. rewrite Hbalances. unfold a2v_upd_dec, a2v_upd_inc. subst sender. apply neq_beq_false in Hacct_from. apply neq_beq_false in Hacct_to. rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)). rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_from)). reflexivity. - subst; simpl in *; destruct H2 as [_ [_ [_ [_ [_ [_ [_ [_ [Hbalances _]]]]]]]]]; rewrite Hbalances; unfold a2v_upd_dec, a2v_upd_inc; subst sender; apply neq_beq_false in Hacct_from; apply neq_beq_false in Hacct_to; rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_to)); rewrite (tmap_get_upd_ne _ _ _ _ (beq_sym _ _ Hacct_from)); reflexivity. Qed. Theorem Property_restricted_owner_for_approve: forall msg _spender _value, m_func msg = mc_approve _spender _value -> forall env C C' evts, step env C msg C' evts -> m_sender msg = st_owner (w_st C) -> forall acct, acct <> st_owner (w_st C) -> forall spender, st_allowed (w_st C) (acct, spender) = st_allowed (w_st C') (acct, spender). 
Require Export Qpositive_le. Require Export Qpositive_plus_mult.Ltac make_fraction w p q Heq := elim (interp_non_zero w); intros p (q, Heq).Ltac expand a b c d p q Heq Heq1 Heq2 := elim (construct_correct2' c a b); [ intros d; elim (interp_non_zero (Qpositive_c a b c)); intros p (q, Heq); rewrite Heq; unfold fst, snd in |- *; intros (Heq1, Heq2) | try (simpl in |- *; auto with arith; fail) | try (simpl in |- *; auto with arith; fail) | auto ]. Theorem Qpositive_le_add : forall w w' w'' : Qpositive, Qpositive_le w w' -> Qpositive_le (Qpositive_plus w w'') (Qpositive_plus w' w''). 
in *. unfold collidesWith in *. simpl in *. case_eq (eqb b3 b1); intuition. rewrite H1 in H0. simpl in *. case_eq (eqb a0 a); intuition. rewrite H2 in H0. simpl in *. rewrite eqb_leibniz in H1. rewrite eqb_leibniz in H2. subst. unfold eqbPair in *. simpl in *. repeat rewrite eqb_refl in H. simpl in *. trivial. rewrite H2 in H0. simpl in *. discriminate. rewrite H1 in H0. simpl in *. unfold eqbPair in *. simpl in *. rewrite H1 in H. case_eq (eqb a0 a); intuition. rewrite H2 in H. simpl in *. eapply IHx1; eauto. rewrite H2 in H. simpl in *. eapply IHx1; eauto. Qed. Theorem in_impl_collidesWith : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B), In (a, b) ls -> a <> a' -> collidesWith _ _ ls a' b = true. unfold collidesWith in *. induction ls; intuition; simpl in *. intuition. pairInv. case_eq (eqb a' a); intuition. rewrite eqb_leibniz in H. subst. intuition. rewrite eqb_refl. simpl in *. trivial. case_eq (eqb b1 b0); intuition. case_eq (eqb a' a0); intuition. simpl. eapply IHls; intuition. eauto. subst; intuition. simpl. eapply IHls; eauto. Qed. Theorem funcCollision_false_impl_collidesWith_false : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B), funcCollision _ _ ls = false -> In (a, b) ls -> collidesWith _ _ ls a b = false. induction ls; intuition; simpl in *. intuition. pairInv. unfold collidesWith, funcCollision in *. simpl in *. repeat rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b1); intuition. rewrite H0 in H. discriminate. unfold collidesWith, funcCollision in *. simpl in *. case_eq (eqb a0 a); intuition. rewrite eqb_leibniz in H0. subst. rewrite eqb_refl. simpl. case_eq (findCollision_1 eqda eqdb ls a b0); intuition; rewrite H0 in H. discriminate. case_eq (eqb b1 b0); intuition. simpl. eapply IHls; intuition. simpl. eapply IHls; intuition. assert (a <> a0). intuition. subst. rewrite eqb_refl in H0. discriminate. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H3. subst. intuition. simpl. case_eq (eqb b1 b0); intuition. simpl. rewrite eqb_leibniz in H4. subst. specialize (in_impl_collidesWith _ _ ls _ H1 H2); intuition. unfold collidesWith in H4. destruct (findCollision_1 eqda eqdb ls a0 b0); discriminate. simpl. case_eq (findCollision_1 eqda eqdb ls a0 b0); intuition. rewrite H5 in H. discriminate. rewrite H5 in H. eapply IHls; intuition. Qed. Theorem arrayLookup_Some_In_split: forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B), arrayLookup eqd arr a = Some b -> In a (fst (split arr)). 
i) + ‚àë n (fun i => b i * f i). Proof. rewrite <- msum_sum; auto. + apply msum_ext; intros; ring. + intros; ring. Qed.Section power_decomp. Variable (p : nat) (Hp : 2 <= p). Let power_nzero x : power x p <> 0. Proof. generalize (@power_ge_1 x p); lia. Qed. Fact power_decomp_lt n f a q : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> f i < q) -> (forall i, i < n -> a i < p) -> ‚àë n (fun i => a i * power (f i) p) < power q p. Proof using Hp. revert q; induction n as [ | n IHn ]; intros q Hf1 Hf2 Ha. + rewrite msum_0; apply power_ge_1; lia. + rewrite msum_plus1; auto. apply lt_le_trans with (1*power (f n) p + a n * power (f n) p). * apply plus_lt_le_compat; auto. rewrite Nat.mul_1_l. apply IHn. - intros; apply Hf1; lia. - intros; apply Hf1; lia. - intros; apply Ha; lia. * rewrite <- Nat.mul_add_distr_r. replace q with (S (q-1)). - rewrite power_S; apply mult_le_compat; auto. ++ apply Ha; auto. ++ apply power_mono_l; try lia. generalize (Hf2 n); intros; lia. - generalize (Hf2 0); intros; lia. Qed. Lemma power_decomp_is_digit n a f : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> forall i, i < n -> is_digit (‚àë n (fun i => a i * power (f i) p)) p (f i) (a i). Proof using Hp. intros Hf Ha. induction n as [ | n IHn ]; intros i Hi. + lia. + split; auto. exists (‚àë (n-i) (fun j => a (S i + j) * power (f (S i+j) - f i - 1) p)), (‚àë i (fun j => a j * power (f j) p)); split. - replace (S n) with (S i + (n-i)) by lia. rewrite msum_plus, msum_plus1; auto. rewrite <- plus_assoc, plus_comm; f_equal. rewrite Nat.mul_add_distr_r, plus_comm; f_equal. rewrite <- mult_assoc, mult_comm, <- sum_0n_scal_l. apply msum_ext. intros j Hj. rewrite (mult_comm (_ * _)); repeat rewrite <- mult_assoc; f_equal. rewrite <- power_S, <- power_plus; f_equal. generalize (Hf i (S i+j)); intros; lia. - apply power_decomp_lt; auto. * intros; apply Hf; lia. * intros; apply Ha; lia. Qed. Theorem power_decomp_unique n f a b : (forall i j, i < j < n -> f i < f j) -> (forall i, i < n -> a i < p) -> (forall i, i < n -> b i < p) -> ‚àë n (fun i => a i * power (f i) p) = ‚àë n (fun i => b i * power (f i) p) -> forall i, i < n -> a i = b i. 
(X & M2 & H1 & H2 & phi & H3). apply Œ£2_Œ£SSn1_enc_sound with (1 := H3); auto. + intros (Y & M21 & H1 & H2 & psi & H3). apply Œ£2_Œ£SSn1_enc_complete with (2 := H3); auto. Qed.Theorem FSAT_FUNnREL1_ANY Œ£ n f r : ar_syms Œ£ f = n -> ar_rels Œ£ r = 1 -> FSAT (Œ£n1 n) ‚™Ø·µ¢ FSAT Œ£. Proof. intros H1 H2. apply ireduces_dependent. intros A. exists (Œ£n1_Œ£ _ _ _ H1 H2 A). apply Œ£n1_Œ£_correct. Qed.Theorem FSAT_REL_2ton n : 2 <= n -> FSAT (Œ£rel 2) ‚™Ø·µ¢ FSAT (Œ£rel n). Proof. revert n; intros [ | [ | n ] ] H; try (exfalso; lia). exists (Œ£2_Œ£n n); intros A; split. + apply Œ£2_Œ£n_soundness. + apply Œ£2_Œ£n_completeness. Qed.Theorem FSAT_RELn_ANY Œ£ n r : ar_rels Œ£ r = n -> FSAT (Œ£rel n) ‚™Ø·µ¢ FSAT Œ£. Proof. intros Hr. destruct (SATn_SAT_reduction _ _ Hr) as (f & Hf). exists f; red; apply Hf. Qed.Section FINITARY_TO_BINARY. Variable (Œ£ : fo_signature) (HŒ£1 : finite_t (syms Œ£)) (HŒ£2 : discrete (syms Œ£)) (HŒ£3 : finite_t (rels Œ£)) (HŒ£4 : discrete (rels Œ£)). Let max_syms : { n | forall s, ar_syms Œ£ s <= n }. Proof. destruct HŒ£1 as (l & Hl). exists (lmax (map (ar_syms _) l)). intros s; apply lmax_prop, in_map_iff. exists s; auto. Qed. Let max_rels : { n | forall s, ar_rels Œ£ s <= n }. Proof. destruct HŒ£3 as (l & Hl). exists (lmax (map (ar_rels _) l)). intros r; apply lmax_prop, in_map_iff. exists r; auto. Qed. Hint Resolve finite_t_sum finite_sum finite_t_finite finite_t_unit : core. Theorem FINITARY_TO_BINARY : FSAT Œ£ ‚™Ø·µ¢ FSAT (Œ£rel 2). Proof using max_syms max_rels HŒ£4 HŒ£3 HŒ£2 HŒ£1. destruct max_syms as (ns & Hns). destruct max_rels as (nr & Hnr). set (m := lmax (2::(S ns)::nr::nil)). eapply ireduces_transitive. { apply FSAT_Œ£nosyms; auto. } eapply ireduces_transitive. { apply FSAT_UNIFORM with (n := m). intros [ [] | [] ]. + apply lmax_prop; simpl; auto. + apply le_trans with (S ns). * simpl; apply le_n_S, Hns. * apply lmax_prop; simpl; auto. + apply le_trans with nr. * simpl; auto. * apply lmax_prop; simpl; auto. } eapply ireduces_transitive. { apply FSAT_ONE_REL; simpl; auto; intros []. } eapply ireduces_transitive. { apply FSAT_NOCST; simpl; auto. } apply (FSAT_REL_nto2 (S m)). Qed.End FINITARY_TO_BINARY.Section DISCRETE_TO_BINARY. Variable (Œ£ : fo_signature) (HŒ£1 : discrete (syms Œ£)) (HŒ£2 : discrete (rels Œ£)). Hint Resolve finite_t_pos : core. Theorem DISCRETE_TO_BINARY : FSAT Œ£ ‚™Ø·µ¢ FSAT (Œ£rel 2). 
Inductive day : Type := | monday : day | tuesday : day | wednesday : day | thursday : day | friday : day | saturday : day | sunday : day .Definition tomorrow (d: day) : day := match d with | monday => tuesday | tuesday => wednesday | wednesday => thursday | thursday => friday | friday => saturday | saturday => sunday | sunday => monday end.Theorem test_tomorrow: tomorrow saturday = sunday. Proof. simpl. reflexivity. Qed. Inductive natlist : Type := | nil : natlist | cons : nat -> natlist -> natlist .Definition empty_list := nil.Definition singleton_list := cons 42 nil.Definition one_two_three := cons 1 (cons 2 (cons 3 nil)).Fixpoint concat (l1 l2 : natlist) : natlist := match l1 with | nil => l2 | cons h t => cons h (concat t l2) end.Theorem test_concat1: concat (cons 1 (cons 2 nil)) (cons 3 (cons 4 nil)) = (cons 1 (cons 2 (cons 3 (cons 4 nil)))). Proof. simpl. reflexivity. Qed. Theorem concat_nil_left : forall l : natlist, concat nil l = l. Proof. intros. simpl. reflexivity. Qed.Theorem concat_nil_right : forall l : natlist, concat l nil = l. Proof. intros. induction l. simpl. reflexivity. simpl. rewrite -> IHl. reflexivity. Qed. Theorem concat_associativity : forall l1 l2 l3 : natlist, concat (concat l1 l2) l3 = concat l1 (concat l2 l3). 
iFrame. - iIntros "_". wp_if. iApply ("IH" with "[HŒ¶]"). auto. Qed. Lemma acquire_spec lk R : {{{ is_lock lk R }}} lock.acquire lk {{{ RET #(); locked lk ‚àó R }}}. Proof. eapply acquire_spec'; auto. Qed. Lemma release_spec' stk E lk R : ‚ÜëN ‚äÜ E ‚Üí {{{ is_lock lk R ‚àó locked lk ‚àó ‚ñ∑ R }}} lock.release lk @ stk; E {{{ RET #(); True }}}. Proof. iIntros (? Œ¶) "(Hlock & Hlocked & HR) HŒ¶". iDestruct "Hlock" as (l ->) "#Hinv". rewrite /lock.release /=. wp_lam. wp_bind (CmpXchg _ _ _). iInv N as (b) "[>Hl _]". iDestruct (locked_loc with "Hlocked") as "Hl2". iDestruct (heap_mapsto_agree with "[$Hl $Hl2]") as %->. iCombine "Hl Hl2" as "Hl". rewrite Qp.quarter_three_quarter. wp_cmpxchg_suc. iModIntro. iSplitR "HŒ¶"; last by wp_seq; iApply "HŒ¶". iEval (rewrite -Qp.quarter_three_quarter) in "Hl". iDestruct (fractional.fractional_split_1 with "Hl") as "[Hl1 Hl2]". iNext. iExists false. iFrame. Qed. Lemma release_spec lk R : {{{ is_lock lk R ‚àó locked lk ‚àó ‚ñ∑ R }}} lock.release lk {{{ RET #(); True }}}. Proof. eapply release_spec'; auto. Qed. Lemma release_spec'' lk R : is_lock lk R -‚àó {{{ locked lk ‚àó ‚ñ∑ R }}} lock.release lk {{{ RET #(); True }}}. Proof. iIntros "#Hlock !# %Œ¶ [??] HŒ¶". iApply (release_spec with "[-HŒ¶]"); by iFrame. Qed. Definition is_cond (c: loc) (lk : val) : iProp Œ£ := readonly (c ‚Ü¶ lk). Global Instance is_cond_persistent c lk : Persistent (is_cond c lk) := _. Theorem wp_newCond' lk : {{{ is_free_lock lk }}} lock.newCond #lk {{{ (c: loc), RET #c; is_free_lock lk ‚àó is_cond c #lk }}}. Proof. rewrite /is_cond. iIntros (Œ¶) "Hl HŒ¶". wp_call. wp_apply wp_alloc_untyped; [ auto | ]. iIntros (c) "Hc". iMod (readonly_alloc_1 with "Hc") as "Hcond". wp_pures. iApply "HŒ¶". by iFrame. Qed. Theorem wp_newCond lk R : {{{ is_lock lk R }}} lock.newCond lk {{{ (c: loc), RET #c; is_cond c lk }}}. Proof. rewrite /is_cond. iIntros (Œ¶) "Hl HŒ¶". wp_call. iDestruct (is_lock_flat with "Hl") as %[l ->]. wp_apply wp_alloc_untyped; [ auto | ]. iIntros (c) "Hc". iMod (readonly_alloc_1 with "Hc") as "Hcond". wp_pures. by iApply "HŒ¶". Qed. Theorem wp_condSignal c lk : {{{ is_cond c lk }}} lock.condSignal #c {{{ RET #(); True }}}. Proof. iIntros (Œ¶) "Hc HŒ¶". wp_call. iApply ("HŒ¶" with "[//]"). Qed. Theorem wp_condBroadcast c lk : {{{ is_cond c lk }}} lock.condBroadcast #c {{{ RET #(); True }}}. Proof. iIntros (Œ¶) "Hc HŒ¶". wp_call. iApply ("HŒ¶" with "[//]"). Qed. Theorem wp_condWait c lk R : {{{ is_cond c lk ‚àó is_lock lk R ‚àó locked lk ‚àó R }}} lock.condWait #c {{{ RET #(); locked lk ‚àó R }}}. 
Cb_id with (1 := cs); auto. Qed. Theorem Cb_compo : forall (p : poly A0 eqA ltM) (L1 : list (poly A0 eqA ltM)), Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L1 -> forall L2 : list (poly A0 eqA ltM), (forall q : poly A0 eqA ltM, In q L1 -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec q L2) -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L2. intros p L1 H' L2 H'0. apply Cb_comp with (L1 := L1); auto. Qed. Definition reducep (L : list (poly A0 eqA ltM)) (p q : poly A0 eqA ltM) : Prop := reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec L (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM q). Theorem grobner_def : forall L : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L -> forall p : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L -> zerop A A0 eqA n ltM p \/ (exists q : poly A0 eqA ltM, reducep L p q). intros L H'; inversion H'; auto. intros p H'0. case (Reducef A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os L p). intros x H'1; inversion H'. lapply (H0 (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM x)); [ intros H'4; lapply H'4; [ clear H'4 | clear H'4 ] | idtac ]; auto. inversion H'1; auto. inversion H1; auto. intros H'2; left. cut (eqP A eqA n (s2p A A0 eqA n ltM p) (pO A n)); auto. case p; simpl in |- *; auto. intros x1; case x1; auto. intros a l H'3 H'4; inversion H'4. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := s2p A A0 eqA n ltM x); auto. intros H'2; right; cut (canonical A0 eqA ltM y); auto. intros H'3; exists (mks A A0 eqA n ltM y H'3); generalize H5; case p; simpl in |- *; auto. apply canonical_reduce with (1 := cs) (3 := H5); auto. generalize H'0; case p; simpl in |- *; auto. generalize H'0; case p; simpl in |- *; auto. Qed. Theorem def_grobner : forall L : list (poly A0 eqA ltM), (forall p : poly A0 eqA ltM, Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec p L -> zerop A A0 eqA n ltM p \/ (exists q : poly A0 eqA ltM, reducep L p q)) -> Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec L. 
le_plus_minus; auto. Qed. End Minus. Hint Resolve le_minus: arith. Section EqBool. Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}. intros a b; case a; case b; simpl in |- *; auto. right; red in |- *; intros; discriminate. Defined. End EqBool. Section LeBool. Fixpoint le_bool (a b : nat) {struct b} : bool := match a, b with | O, _ => true | S a1, S b1 => le_bool a1 b1 | _, _ => false end. Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true. Proof using. intros a; elim a; simpl in |- *; auto. intros b; case b; simpl in |- *; auto. intros n H b; case b; simpl in |- *. intros H1; inversion H1. intros n0 H0; apply H. apply le_S_n; auto. Qed. Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false. Proof using. intros a; elim a; simpl in |- *; auto. intros b H1; inversion H1. intros n H b; case b; simpl in |- *; auto. intros n0 H0; apply H. apply lt_S_n; auto. Qed. Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b. Proof using. intros a; elim a; simpl in |- *; auto. intros b; case b; simpl in |- *; auto with arith. intros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith. Qed. Theorem le_bool_correct4 : forall a b : nat, le_bool a b = false -> b <= a. Proof using. intros a; elim a; simpl in |- *; auto. intros b; case b; simpl in |- *; try (intros; discriminate); auto with arith. intros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith. Qed. End LeBool. Section fold. Variables (A : Type) (B : Type). Variable f : A -> B -> A. Variable g : B -> A -> A. Variable h : A -> A. Variable eqA_dec : forall a b : A, {a = b} + {a <> b}. Theorem fold_left_app : forall a l1 l2, fold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a). Proof using. intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1. Qed. Theorem fold_left_eta : forall l a f1, (forall a b, In b l -> f a b = f1 a b) -> fold_left f l a = fold_left f1 l a. 
[omega |]. cancel. eapply pimpl_trans; [| apply IHl ]. cancel. apply pimpl_refl. omega. Qed. Theorem listpred_extract : forall l i def, i < length l -> listpred l =p=> exists F, F * prd (selN l i def). Proof. intros; rewrite listpred_fwd with (def:=def) by eauto; cancel. Qed. Theorem listpred_pick : forall x l, In x l -> listpred l =p=> exists F, prd x * F. Proof. induction l; intro Hi. inversion Hi. simpl. destruct Hi. cancel. rewrite IHl by assumption. cancel. Qed. Theorem listpred_inj: forall l1 l2, l1 = l2 -> listpred l1 <=p=> listpred l2. Proof. intros; subst; auto. Qed. Definition sep_star_fold : (T -> @pred AT AEQ V -> @pred AT AEQ V) := fun x => sep_star (prd x). Definition listpred' := fold_right sep_star_fold emp. Theorem listpred_listpred': forall l, listpred l = listpred' l. Proof. induction l; unfold listpred, listpred', sep_star_fold, fold_right; auto. Qed. Theorem listpred'_app_fwd: forall l1 l2, listpred' (l1 ++ l2) =p=> listpred' l1 * listpred' l2. Proof. unfold listpred'. induction l1; destruct l2; unfold sep_star_fold; try cancel; rewrite IHl1; unfold sep_star_fold; cancel. Qed. Theorem listpred'_app_bwd: forall l1 l2, listpred' l1 * listpred' l2 =p=> listpred' (l1 ++ l2). Proof. unfold listpred'. induction l1; destruct l2; unfold sep_star_fold; try cancel; rewrite <- IHl1; unfold sep_star_fold; cancel. Qed. Theorem listpred_app: forall l1 l2, listpred (l1 ++ l2) <=p=> listpred l1 * listpred l2. Proof. intros; replace listpred with listpred'. unfold piff; split. apply listpred'_app_fwd. apply listpred'_app_bwd. apply functional_extensionality. apply listpred_listpred'. Qed. Theorem listpred_isolate : forall l i def, i < length l -> listpred l <=p=> listpred (removeN l i) * prd (selN l i def). Proof. intros. unfold removeN. rewrite listpred_app. unfold piff; split. rewrite listpred_fwd by eauto; cancel. eapply pimpl_trans2. apply listpred_bwd; eauto. cancel. Qed. Theorem listpred_split : forall l n, listpred l <=p=> listpred (firstn n l) * listpred (skipn n l). Proof. intros. setoid_rewrite <- firstn_skipn with (n := n) at 1. rewrite listpred_app. split; cancel. Qed. Theorem listpred_isolate_fwd : forall l i def, i < length l -> listpred l =p=> listpred (removeN l i) * prd (selN l i def). Proof. intros. apply listpred_isolate; auto. Qed. Theorem listpred_updN : forall l i v, i < length l -> listpred (updN l i v) <=p=> listpred (removeN l i) * prd v. Proof. intros; rewrite listpred_isolate with (def:=v); [ | rewrite length_updN; eauto]. rewrite removeN_updN. rewrite selN_updN_eq; auto. Qed. Theorem listpred_updN_selN: forall l i v def, i < length l -> prd (selN l i def) =p=> prd v -> listpred l =p=> listpred (updN l i v). 
flist_crash_xform_sep_star. rewrite flist_crash_xform_dirlist_pred by eauto. cancel. eassign (TreeDir inum tree_ents'). cancel. apply flist_crash_xform_tree_dir_names_pred; eauto. eapply Forall2_to_map_eq. apply tree_crash_preserves_dirtree_inum. eauto. eapply Forall2_to_map_eq. apply tree_crash_preserves_dirtree_isdir. eauto. constructor; eauto. Qed. Lemma flist_crash_xform_freelist : forall (FP : BFILE.bfile -> Prop) xp frees freepred ms, (forall f f', BFILE.file_crash f f' -> FP f -> FP f') -> IAlloc.Alloc.rep FP xp frees freepred ms =p=> IAlloc.Alloc.rep FP xp frees freepred ms * [[ flist_crash_xform freepred =p=> freepred ]]. Proof. unfold IAlloc.Alloc.rep, IAlloc.Alloc.Alloc.rep; intros. cancel. match goal with H: _ <=p=> _ |- _ => rewrite H end. repeat match goal with Hb: context [BFILE.file_crash], Hother: _ |- _ => clear Hother end. induction frees; simpl. rewrite flist_crash_xform_emp; auto. rewrite flist_crash_xform_sep_star. rewrite flist_crash_xform_exists. rewrite IHfrees. norml; unfold stars; simpl. rewrite flist_crash_xform_sep_star. rewrite flist_crash_xform_lift_empty. rewrite flist_crash_xform_ptsto. cancel. eauto. Qed. Lemma xform_tree_rep : forall xp F t ilist frees ms msll' sm, crash_xform (rep xp F t ilist frees ms sm) =p=> exists t', [[ tree_crash t t' ]] * rep xp (flist_crash_xform F) t' ilist frees (BFILE.ms_empty msll') sm_synced. Proof. unfold rep; intros. xform_norm. rewrite BFILE.xform_rep. rewrite IAlloc.xform_rep. rewrite flist_crash_xform_freelist. norml; unfold stars; simpl. eapply flist_crash_flist_crash_xform in H0; eauto. apply flist_crash_xform_sep_star in H0. rewrite flist_crash_xform_sep_star in H0. rewrite flist_crash_xform_tree_pred in H0. destruct_lift H0. unfold IAlloc.rep; cancel. rewrite <- BFILE.rep_clear_freelist. rewrite <- BFILE.rep_clear_icache. rewrite <- IAlloc.rep_clear_cache. cancel. eauto. pred_apply. cancel; auto. intros; eapply BFILE.freepred_file_crash; eauto. Grab Existential Variables. all: exact (LOG.mk_memstate0 (Cache.BUFCACHE.cache0 1)). Qed. Theorem tree_crash_find_name : forall fnlist t t' subtree, tree_crash t t' -> find_subtree fnlist t = Some subtree -> exists subtree', find_subtree fnlist t' = Some subtree' /\ tree_crash subtree subtree'. Proof. induction fnlist. - simpl; intros. eexists; intuition eauto. inversion H0; subst; auto. - intros. inversion H0. destruct t; try congruence. inversion H; subst. generalize dependent st'. induction l; intros. + simpl in *. congruence. + destruct st'; try solve [ simpl in *; congruence ]. destruct p. unfold find_subtree_helper in H2 at 1. destruct a0. simpl in H2. destruct (string_dec s0 a). * subst. edestruct IHfnlist. 2: apply H2. inversion H6; eauto. eexists. intuition eauto. inversion H4; subst. simpl; destruct (string_dec s s); try congruence. * edestruct IHl. eauto. eauto. all: try solve [ inversion H4; exact H5 ]. all: try solve [ inversion H6; eauto ]. constructor. inversion H4; eauto. inversion H. inversion H8; eauto. exists x. intuition. simpl. inversion H4; subst. destruct (string_dec s a); try congruence. apply H3. Qed. Theorem tree_crash_find_none : forall fnlist t t', tree_crash t t' -> find_subtree fnlist t = None -> find_subtree fnlist t' = None. 
H4; intros; elim H5; intros. elim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros. elim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19. rewrite (mult_opp_r H (Opp x) y H18 H1). rewrite (mult_opp_l H x y H0 H1). symmetry in |- *. exact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)). Qed. Definition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}. Definition is_unitary_commutative_ring := is_ring /\ commutativity S Mult /\ neutral S A Mult I.Definition divide (a b : S) := A a /\ A b /\ (b = O \/ a <> O /\ (exists q : S, A q /\ b = Mult a q)). Theorem div_O_O : is_ring -> divide O O. unfold divide in |- *; intros. elim H; intros; elim H1; intros; elim H2; intros; elim H5; intros. elim H7; intros; elim H8; intros. split. exact H10. split. exact H10. left; reflexivity. Qed. Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b). unfold divide in |- *; intros. split.elim H0; trivial. split.elim H; intros; elim H3; intros; elim H4; intros. elim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros. exact (H6 a b H10 H14).elim H; intros; elim H3; intros; elim H4; intros; elim H5; intros. elim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros. clear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16. elim H0; intros; elim H2; intros; clear H H0 H2. elim H1; intros; elim H0; intros; clear H H0 H1. elim H4; intros. rewrite H. elim (H17 b H2); intros. rewrite H1. exact H5. elim H5; intros. rewrite H0. elim (H17 a H3); intros. rewrite H1. exact H4. clear H2 H3 H4 H5 H17. right. elim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3. elim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3. split. exact H1. clear H1. exists (Add x x0). split. exact (H6 x x0 H4 H7). elim (H13 d x x0); intros. clear H4 H6 H7 H13. rewrite H0. clear H H0. elim H5; elim H8; reflexivity. Qed. Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b). 
Set Implicit Arguments.Require Import FCF.FCF. Require Import FCF.HasDups. Require Import FCF.RndInList. Require Import FCF.CompFold. Require Import FCF.Tactics. Require Import Permutation. Require Import Lia. Section DRBG. Variable S : Set. Hypothesis S_EqDec : EqDec S. Variable RndS : Comp S. Variable R : Set. Hypothesis R_EqDec : EqDec R. Variable RndR : Comp R. Variable f : S -> R. Variable A : R -> Comp bool. Definition DRBG_G0 := s <-$ RndS ; A (f s). Definition DRBG_G1 := r <-$ RndR; A r. Definition DRBG_Advantage := | Pr[DRBG_G0] - Pr[DRBG_G1] |.End DRBG.Require Import FCF.PRF.Local Open Scope list_scope. Local Opaque evalDist.Section PRF_DRBG. Variable Key D : Set. Variable eta : nat. Hypothesis D_EqDec : EqDec D. Variable RndKey : Comp Key. Variable f : Key -> D -> Bvector eta. Variable injD : Bvector eta -> D. Hypothesis injD_correct : forall r1 r2, (injD r1) = (injD r2) -> r1 = r2. Variable l : nat. Hypothesis l_pos : l > 0. Variable r_init : Bvector eta. Definition v_init := injD r_init. Definition RndOut := compMap _ (fun _ => {0, 1}^eta) (forNats l). Fixpoint PRF_DRBG_f (v : D)(n : nat)(k : Key) := match n with | O => nil | S n' => r <- (f k v); r :: (PRF_DRBG_f (injD r) n' k) end. Definition PRF_DRBG (k : Key) := PRF_DRBG_f v_init l k. Variable A : list (Bvector eta) -> Comp bool. Hypothesis A_wf : forall c, well_formed_comp (A c). Definition PRF_DRBG_G1 := s <-$ RndKey ; A (PRF_DRBG_f v_init l s). Theorem PRF_DRBG_G1_equiv : Pr[DRBG_G0 RndKey PRF_DRBG A] == Pr[PRF_DRBG_G1]. reflexivity. Qed. Fixpoint PRF_DRBG_f_G2 (v : D)(n : nat) : OracleComp D (Bvector eta) (list (Bvector eta)) := match n with | O => $ ret nil | S n' => r <--$ (OC_Query _ v); ls' <--$ (PRF_DRBG_f_G2 (injD r) n'); $ ret (r :: ls') end. Definition PRF_A : OracleComp D (Bvector eta) bool := ls <--$ PRF_DRBG_f_G2 v_init l; $ A ls. Check A. Theorem PRF_DRBG_f_G2_wf : forall n v, well_formed_oc (PRF_DRBG_f_G2 v n). induction n; intuition; simpl in *; fcf_well_formed. Qed. Theorem PRF_A_wf : well_formed_oc PRF_A. 
* Instant), isTraceFrom_T Sini x -> ForAllS (fun s : Stream (S * Instant) => bound (snd (hd s)) -> P s) x -> SafePath_T Sini P. Theorem Equiv1_T : forall (Sini : S * Instant) (P : Stream (S * Instant) -> Prop), Posible_T Sini P <-> EX_Until_bound Sini (fun _ : Stream (S * Instant) => True) P. Proof. unfold iff in |- *; intros; split; intro. inversion_clear H. apply ExUntil_bound with (P := fun _ : Stream (S * Instant) => True) (1 := H0). elim H1. simple destruct x0; simpl in |- *. simple destruct p; simple destruct 1; simpl in |- *; intros. constructor 2; assumption. simple destruct s; intros. constructor 1; trivial. inversion_clear H. apply posible_T with (1 := H0). elim H1. simple destruct s; intros. constructor 2; assumption. intros; constructor 1; simpl in |- *; split; assumption. Qed. Theorem Equiv2_T : forall (Sini : S * Instant) (P : Stream (S * Instant) -> Prop), Inevitable_T Sini P <-> FA_Until_bound Sini (fun _ : Stream (S * Instant) => True) P. Proof. unfold iff, Inevitable_T, FA_Until_bound in |- *; intros; split; intros. elim (H x H0); simple destruct x0. simple destruct p; intros. elim H1; intros. constructor 2; assumption. constructor 1; trivial. elim (H x H0); intros. constructor 2; assumption. constructor 1; split; assumption. Qed. Lemma ConsTrace_T : forall (s1 s2 : S * Instant) (x z : Stream (S * Instant)), isTraceFrom_T s2 z -> isTraceFrom_T s1 (s1 ^ s2 ^ x) -> isTraceFrom_T s1 (s1 ^ z). Proof. unfold isTraceFrom_T in |- *; simpl in |- *. simple destruct z; simple destruct 1; simple destruct 3; simpl in |- *; intros. compute in H0; rewrite H0 in H4. inversion_clear H4 in H1. split; [ trivial | apply (isTraceTick_T H5 H1) ]. split; [ trivial | apply (isTraceDisc_T H5 H6 H1) ]. Qed. Lemma notPosible_T : forall (P : Stream (S * Instant) -> Prop) (s1 : S * Instant), ~ Posible_T s1 P -> forall (z : Stream (S * Instant)) (s2 : S * Instant), isTraceFrom_T s1 (s1 ^ s2 ^ z) -> ~ Posible_T s2 P. Proof. unfold not at 2 in |- *; intros. elim H1; intros. apply H; cut (isTraceFrom_T s1 (s1 ^ x)). intro H4; apply (posible_T (P:=P) H4). apply Further; assumption. apply ConsTrace_T with (1 := H2) (2 := H0); assumption. Qed. Require Import Classical. Theorem Equiv3_T : forall (Sini : S * Instant) (P : Stream (S * Instant) -> Prop), Always_T Sini P <-> ~ Posible_T Sini (fun s : Stream (S * Instant) => ~ P s). 
unfold decidable; repeat decide equality. Defined. Inductive aexpEq : aexp' -> aexp' -> Prop := | ANumEq : forall n1 n2, n1 = n2 -> aexpEq (ANum n1) (ANum n2).Instance dec_aexpEq (x y : aexp') : Dec (aexpEq x y). constructor; unfold decidable. destruct x; destruct y; try solve [right => H; inversion H; eauto]. destruct ((n = n0)?) eqn:Eq; destruct dec; try solve [inversion Eq]. - left; econstructor; eauto. - right => H; inversion H; eauto. Defined. Conjecture aexpEq_refl : forall x, aexpEq x x. QuickChick aexpEq_refl.Derive ArbitrarySizedSuchThat for (fun x => aexpEq x x'). Derive SizedProofEqs for (fun x => aexpEq x x'). Derive SizeMonotonicSuchThatOpt for (fun x => aexpEq x x'). Derive GenSizedSuchThatSizeMonotonicOpt for (fun x => aexpEq x x'). Derive GenSizedSuchThatCorrect for (fun x => aexpEq x x').Conjecture aexpEq_eq : forall x x', aexpEq x x' -> x = x'. QuickChick aexpEq_eq. Inductive bexp' : Type := | BTrue : bexp' | BFalse : bexp' | BEq : aexp' -> aexp' -> bexp' | BLe : aexp' -> aexp' -> bexp' | BNot : bexp' -> bexp' | BAnd : bexp' -> bexp' -> bexp'.Derive (Arbitrary, Show) for bexp'. Derive (Sized, CanonicalSized) for bexp'. Derive SizeMonotonic for bexp' using genSbexp'. Derive SizedMonotonic for bexp'. Derive SizedCorrect for bexp' using genSbexp' and SizeMonotonicbexp'.Instance dec_eq_bexp (x y : bexp') : Dec (x = y). constructor; unfold decidable; repeat decide equality. Defined.Fixpoint aeval (a : aexp') : nat := match a with | ANum n => n | APlus a1 a2 => (aeval a1) + (aeval a2) | AMinus a1 a2 => (aeval a1) - (aeval a2) | AMult a1 a2 => (aeval a1) * (aeval a2) end.Fixpoint beval (b : bexp') : bool := match b with | BTrue => true | BFalse => false | BEq a1 a2 => beq_nat (aeval a1) (aeval a2) | BLe a1 a2 => leb (aeval a1) (aeval a2) | BNot b1 => negb (beval b1) | BAnd b1 b2 => andb (beval b1) (beval b2) end.Fixpoint optimize_0plus (a:aexp') : aexp' := match a with | ANum n => ANum n | APlus (ANum 0) e2 => optimize_0plus e2 | APlus e1 e2 => APlus (optimize_0plus e1) (optimize_0plus e2) | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2) | AMult e1 e2 => AMult (optimize_0plus e1) (optimize_0plus e2) end.End AExp.Import AExp.Theorem optimize_0plus_sound: forall a, aeval (optimize_0plus a) = aeval a. Admitted. Theorem silly1 : forall ae, aeval ae = aeval ae. 
ns F => list_ind (fun ms => forall (Hns : Forall (fun n => n < S (S radix)) (n :: ns)) (Hms : Forall (fun m => m < S (S radix)) ms), nat_decomp_chars radix encoding (n :: ns) Hns = nat_decomp_chars radix encoding ms Hms -> (n :: ns) = ms) (fun _ _ H => False_ind _ (app_cons_not_nil _ _ _ (eq_sym H))) (fun m ms G Hns Hms H => let H0 : ns = ms := F ms (Forall_inv_tail Hns) (Forall_inv_tail Hms) (proj1 (app_inj_tail (nat_decomp_chars radix encoding ns (Forall_inv_tail Hns)) (nat_decomp_chars radix encoding ms (Forall_inv_tail Hms)) (encoding n (Forall_inv Hns)) (encoding m (Forall_inv Hms)) H)) in sumbool_ind (fun _ => _) (fun H1 : n = m => ltac:(rewrite H0; rewrite H1; reflexivity) : (n :: ns) = (m :: ms)) (fun H1 : n <> m => let H2 : encoding n (Forall_inv Hns) = encoding m (Forall_inv Hms) := proj2 (app_inj_tail (nat_decomp_chars radix encoding ns (Forall_inv_tail Hns)) (nat_decomp_chars radix encoding ms (Forall_inv_tail Hms)) (encoding n (Forall_inv Hns)) (encoding m (Forall_inv Hms)) H) in False_ind _ (H1 (encoding_inj n m (Forall_inv Hns) (Forall_inv Hms) H2))) (Nat.eq_dec n m)))). Qed. Local Definition nat_chars (radix : nat) (encoding : forall n, n < S (S radix) -> ascii) (n : nat) : list ascii := nat_decomp_chars radix encoding (proj1_sig (nat_decomp radix n)) (proj1 (proj2_sig (nat_decomp radix n))). Local Theorem nat_chars_inj (radix : nat) (encoding : forall n, n < S (S radix) -> ascii) (encoding_inj : forall n m (Hn : n < S (S radix)) (Hm : m < S (S radix)), encoding n Hn = encoding m Hm -> n = m) : forall n m : nat, nat_chars radix encoding n = nat_chars radix encoding m -> n = m. Proof. intros n m H. assert ((proj1_sig (nat_decomp radix n)) = (proj1_sig (nat_decomp radix m))). apply (nat_decomp_chars_inj radix encoding encoding_inj (proj1_sig (nat_decomp radix n)) (proj1_sig (nat_decomp radix m)) (proj1 (proj2_sig (nat_decomp radix n))) (proj1 (proj2_sig (nat_decomp radix m))) H). apply (nat_decomp_inj radix n m H0). Qed. Local Definition nat_string (radix : nat) (encoding : forall n, n < S (S radix) -> ascii) (n : nat) : string := string_of_list_ascii (nat_chars radix encoding n). Local Lemma string_of_list_ascii_inj : forall xs ys : list ascii, string_of_list_ascii xs = string_of_list_ascii ys -> xs = ys. Proof. exact (inv_inj _ _ string_of_list_ascii list_ascii_of_string list_ascii_of_string_of_list_ascii). Qed. Local Theorem nat_string_inj (radix : nat) (encoding : forall n, n < S (S radix) -> ascii) (encoding_inj : forall n m (Hn : n < S (S radix)) (Hm : m < S (S radix)), encoding n Hn = encoding m Hm -> n = m) : forall n m : nat, nat_string radix encoding n = nat_string radix encoding m -> n = m. 
b in Zpos a = b * q + r /\ 0 <= r < b. Proof. intros b Hb a. Z.swap_greater. generalize (Z.pos_div_eucl_eq a b Hb) (Z.pos_div_eucl_bound a b Hb). destruct Z.pos_div_eucl. rewrite Z.mul_comm. auto. Qed.Theorem Z_div_mod a b : b > 0 -> let (q, r) := Z.div_eucl a b in a = b * q + r /\ 0 <= r < b. Proof. Z.swap_greater. intros Hb. assert (Hb' : b<>0) by (now destruct b). generalize (Z.div_eucl_eq a b Hb') (Z.mod_pos_bound a b Hb). unfold Z.modulo. destruct Z.div_eucl. auto. Qed.Definition Remainder r b := 0 <= r < b \/ b < r <= 0.Definition Remainder_alt r b := Z.abs r < Z.abs b /\ Z.sgn r <> - Z.sgn b.Lemma Remainder_equiv : forall r b, Remainder r b <-> Remainder_alt r b. Proof. intros; unfold Remainder, Remainder_alt; omega with *. Qed.Hint Unfold Remainder.Theorem Z_div_mod_full a b : b <> 0 -> let (q, r) := Z.div_eucl a b in a = b * q + r /\ Remainder r b. Proof. intros Hb. generalize (Z.div_eucl_eq a b Hb) (Z.mod_pos_bound a b) (Z.mod_neg_bound a b). unfold Z.modulo. destruct Z.div_eucl as (q,r). intros EQ POS NEG. split; auto. red; destruct b. now destruct Hb. left; now apply POS. right; now apply NEG. Qed.Lemma Z_mod_remainder a b : b<>0 -> Remainder (a mod b) b. Proof. unfold Z.modulo; intros Hb; generalize (Z_div_mod_full a b Hb); auto. destruct Z.div_eucl; tauto. Qed.Lemma Z_mod_lt a b : b > 0 -> 0 <= a mod b < b. Proof (fun Hb => Z.mod_pos_bound a b (Z.gt_lt _ _ Hb)).Lemma Z_mod_neg a b : b < 0 -> b < a mod b <= 0. Proof (Z.mod_neg_bound a b).Lemma Z_div_mod_eq a b : b > 0 -> a = b*(a/b) + (a mod b). Proof. intros Hb; apply Z.div_mod; auto with zarith. Qed.Lemma Zmod_eq_full a b : b<>0 -> a mod b = a - (a/b)*b. Proof. intros. rewrite Z.mul_comm. now apply Z.mod_eq. Qed.Lemma Zmod_eq a b : b>0 -> a mod b = a - (a/b)*b. Proof. intros. apply Zmod_eq_full. now destruct b. Qed.Theorem Zdiv_eucl_exist : forall (b:Z)(Hb:b>0)(a:Z), {qr : Z * Z | let (q, r) := qr in a = b * q + r /\ 0 <= r < b}. Proof. intros b Hb a. exists (Z.div_eucl a b). exact (Z_div_mod a b Hb). Qed.Arguments Zdiv_eucl_exist : default implicits. Theorem Zdiv_mod_unique b q1 q2 r1 r2 : 0 <= r1 < Z.abs b -> 0 <= r2 < Z.abs b -> b*q1+r1 = b*q2+r2 -> q1=q2 /\ r1=r2. 
Require Export Zaux. Require Import ZArithRing. Require Export Qpositive. Require Export Q_field. Require Import FunInd.Inductive fractionalAcc : Z -> Z -> Prop := | fractionalacc0 : forall m n : Z, m = n -> fractionalAcc m n | fractionalacc1 : forall m n : Z, (0 < m)%Z -> (m < n)%Z -> fractionalAcc m (n - m)%Z -> fractionalAcc m n | fractionalacc2 : forall m n : Z, (0 < n)%Z -> (n < m)%Z -> fractionalAcc (m - n)%Z n -> fractionalAcc m n.Lemma fractionalacc_0 : forall m : Z, fractionalAcc m m. Proof. intros; apply fractionalacc0; reflexivity. Defined.Lemma fractionalacc_1 : forall m n : Z, fractionalAcc m n -> (0 < m)%Z -> (m < n)%Z -> fractionalAcc m (n - m). Proof. simple destruct 1; intros; trivial; Falsum; apply (Z.lt_irrefl n0); [ rewrite H0 in H2 | apply Z.lt_trans with m0 ]; assumption. Defined. Lemma fractionalacc_2 : forall m n : Z, fractionalAcc m n -> (0 < n)%Z -> (n < m)%Z -> fractionalAcc (m - n) n. Proof. simple destruct 1; intros; trivial; Falsum; apply (Z.lt_irrefl n0); [ rewrite H0 in H2 | apply Z.lt_trans with m0 ]; assumption. Defined. Definition encoding_algorithm : forall (x y : Z) (h1 : (0 < x)%Z) (h2 : (0 < y)%Z) (H : fractionalAcc x y), Qpositive. fix encoding_algorithm 5. intros x y h1 h2 H.refine match Z_dec' x y with | inleft H_x_neq_y => match H_x_neq_y with | left Hx_lt_y => dL (encoding_algorithm x (y - x)%Z h1 _ (fractionalacc_1 x y H h1 Hx_lt_y)) | right Hy_lt_x => nR (encoding_algorithm (x - y)%Z y _ h2 (fractionalacc_2 x y H h2 Hy_lt_x)) end | inright _ => One end; unfold Zminus in |- *; apply Zlt_left_lt; assumption. Defined. Theorem Zminus2_wf : forall x y : Z, (0%nat < x)%Z -> (0 < y)%Z -> fractionalAcc x y. 
in H2. inv H2. inv H9. specialize (H2 x). apply H2. split; auto. inv H1. specialize (H2 x). apply H2. split. right; auto. auto. split; intro; intro. inv H. apply bound_var_ctx_comp_ctx in H2. inv H2. inv H11. specialize (H2 x); auto. inv H1. specialize (H2 x); apply H2. split; auto. apply IHc. split; auto. split; auto. eapply Disjoint_Included_l. 2: apply H1. eauto with Ensembles_DB. - split; intro. + inv H. apply IHfdc in H13. destructAll. split. constructor; auto. intro; apply H6. apply bound_var_ctx_comp_ctx. auto. eapply Disjoint_Included_l. 2: apply H8. intro; intro. apply bound_var_ctx_comp_ctx; auto. eapply Disjoint_Included_r. 2: apply H9. intro; intro. apply bound_var_ctx_comp_ctx; auto. split; auto. split. intro. intro. inv H2. inv H3. apply H6. inv H2. apply bound_var_ctx_comp_ctx; auto. inv H2. inv H8. specialize (H2 x). apply H2. split; auto. apply bound_var_ctx_comp_ctx; auto. inv H3. inv H9. specialize (H3 x). apply H3. split; auto. apply bound_var_ctx_comp_ctx; auto. inv H1. specialize (H3 x). apply H3; split; auto. + destructAll. inv H. constructor; auto. intro. apply bound_var_ctx_comp_ctx in H. inv H. auto. inv H1. specialize (H v). apply H. split; auto. split. intro; intro. inv H. apply bound_var_ctx_comp_ctx in H2. inv H2. inv H10. specialize (H2 x). apply H2; auto. inv H1. specialize (H2 x). apply H2; auto. split; intro; intro. inv H. apply bound_var_ctx_comp_ctx in H3. inv H3. inv H11. specialize (H3 x). apply H3; auto. inv H1. specialize (H3 x). apply H3. split. auto. auto. apply IHfdc. split; auto. split; auto. eapply Disjoint_Included_l. 2: apply H1. auto with Ensembles_DB. Qed. Theorem inlined_fundefs_f_staged: forall x im f4, (inlined_fundefs_f f4 (M.set x true im)) = (inlined_fundefs_f (inlined_fundefs_f f4 im) (M.set x true (M.empty bool))). Proof. induction f4; simpl; try rewrite IHf4; auto. destruct (var_dec v x). - subst. unfold get_b. rewrite M.gss. destruct (M.get x im). destruct b. auto. simpl. unfold get_b. rewrite M.gss. auto. simpl. unfold get_b. rewrite M.gss. auto. - unfold get_b. rewrite M.gso. destruct (M.get v im). destruct b. auto. simpl. unfold get_b. rewrite M.gso. rewrite M.gempty. auto. auto. simpl. unfold get_b. rewrite M.gso; auto. auto. Qed. Theorem inlined_ctx_f_staged_mut: forall x im, (forall c, inlined_ctx_f c (M.set x true im) = inlined_ctx_f (inlined_ctx_f c im) (M.set x true (M.empty bool))) /\ ( forall fc, inlined_fundefs_ctx_f fc (M.set x true im) = inlined_fundefs_ctx_f (inlined_fundefs_ctx_f fc im) (M.set x true (M.empty bool))). Proof. intros x im. apply exp_fundefs_ctx_mutual_ind; simpl; intros; try rewrite H; auto . rewrite <- inlined_fundefs_f_staged. auto. Qed. Theorem inlined_ctx_f_staged: forall x im, (forall c, inlined_ctx_f c (M.set x true im) = inlined_ctx_f (inlined_ctx_f c im) (M.set x true (M.empty bool))). 
_ _ _ = Some ?m', H2: Mem.extends ?m ?m'' |- _ ] => learn H; exploit Mem.free_parallel_extends; eauto; intros | [ H: Events.eval_builtin_args _ _ _ _ _ _, H2: regs_lessdef ?rs ?rs' |- _ ] => let H3 := fresh "H" in learn H; exploit Events.eval_builtin_args_lessdef; [apply H2 | | |]; eauto with rtlgp; intro H3; learn H3 | [ H: Events.external_call _ _ _ _ _ _ _ |- _ ] => let H2 := fresh "H" in learn H; exploit Events.external_call_mem_extends; eauto; intro H2; learn H2 | [ H: exists _, _ |- _ ] => inv H | _ => progress simplify end. Hint Resolve Events.eval_builtin_args_preserved : rtlgp. Hint Resolve Events.external_call_symbols_preserved : rtlgp. Hint Resolve set_res_lessdef : rtlgp. Hint Resolve set_reg_lessdef : rtlgp. Hint Resolve Op.eval_condition_lessdef : rtlgp. Hint Constructors Events.eval_builtin_arg: barg. Lemma eval_builtin_arg_eq: forall A ge a v1 m1 e1 e2 sp, (forall x, e1 x = e2 x) -> @Events.eval_builtin_arg A ge e1 sp m1 a v1 -> Events.eval_builtin_arg ge e2 sp m1 a v1. Proof. induction 2; try rewrite H; eauto with barg. Qed. Lemma eval_builtin_args_eq: forall A ge e1 sp m1 e2 al vl1, (forall x, e1 x = e2 x) -> @Events.eval_builtin_args A ge e1 sp m1 al vl1 -> Events.eval_builtin_args ge e2 sp m1 al vl1. Proof. induction 2. - econstructor; split. - exploit eval_builtin_arg_eq; eauto. intros. destruct IHlist_forall2 as [| y]. constructor; eauto. constructor. constructor; auto. constructor; eauto. Qed. Lemma step_cf_instr_correct: forall t s s' cf, step_cf_instr ge s cf t s' -> forall r, match_states s r -> exists r', step_cf_instr tge r cf t r' /\ match_states s' r'. Proof using TRANSL. Admitted. Theorem transl_step_correct : forall (S1 : RTLBlock.state) t S2, RTLBlock.step ge S1 t S2 -> forall (R1 : RTLPar.state), match_states S1 R1 -> exists R2, Smallstep.plus RTLPar.step tge R1 t R2 /\ match_states S2 R2. Proof. Admitted. Lemma transl_initial_states: forall S, RTLBlock.initial_state prog S -> exists R, RTLPar.initial_state tprog R /\ match_states S R. Proof. induction 1. exploit function_ptr_translated; eauto. intros [tf [A B]]. econstructor; split. econstructor. apply (Genv.init_mem_transf_partial TRANSL); eauto. replace (prog_main tprog) with (prog_main prog). rewrite symbols_preserved; eauto. symmetry; eapply match_program_main; eauto. eexact A. rewrite <- H2. apply sig_transl_function; auto. constructor. auto. constructor. Qed. Lemma transl_final_states: forall S R r, match_states S R -> RTLBlock.final_state S r -> RTLPar.final_state R r. Proof. intros. inv H0. inv H. inv STACKS. constructor. Qed. Theorem transf_program_correct: Smallstep.forward_simulation (RTLBlock.semantics prog) (RTLPar.semantics tprog). 
auto. Qed. Lemma simplify_fwd_ExistsX : forall G A s (p : propX pc state (A :: G)), interp specs (Substs s (ExX : A, p)) -> exists a, interp specs (Substs (SPush s a) p). induction s; simpl; intuition. apply ExistsX_sound; auto. Qed. Lemma simplify_fwd' : forall G (p : propX pc state G) s, interp specs (Substs s p) -> simplify p s. induction p; simpl; intuition; autorewrite with Substs in *. apply (Inj_sound H). apply Substs_Cptr_fwd in H0; apply (Cptr_sound H0). apply And_sound in H; intuition. apply And_sound in H; intuition. apply Or_sound in H; intuition. apply Substs_Forall_fwd in H0; specialize (Forall_sound H0); intuition. apply Substs_Exists_fwd in H0; specialize (Exists_sound H0); firstorder. assumption. auto. apply IHp; apply simplify_fwd_ForallX; auto. apply simplify_fwd_ExistsX in H; firstorder. Qed. Lemma simplify_fwd : forall p, interp specs p -> simplify p SNil. intros; apply simplify_fwd'; auto. Qed. Fixpoint simplifyH G (p : propX pc state G) : subs G -> Prop := match p with | Inj _ P => fun _ => P | Cptr _ f a => fun s => exists a', specs f = Some a' /\ forall x, a' x = Substs s (a x) | And _ p1 p2 => fun s => simplifyH p1 s /\ simplifyH p2 s | Or _ p1 p2 => fun s => simplifyH p1 s \/ simplifyH p2 s | _ => fun _ => True end. Lemma Substs_Cptr : forall G (s : subs G) f a, exists a', Substs s (Cptr f a) = Cptr f a' /\ forall x, a' x = Substs s (a x). induction s; simpl; intuition eauto. Qed. Lemma simplifyH_ok : forall G (p : propX pc state G) s PG p', In (Substs s p) PG -> (simplifyH p s -> valid specs PG (Substs s p')) -> valid specs PG (Substs s p'). induction p; simpl; intuition; autorewrite with Substs in *. eapply Inj_E; [ constructor; eauto | auto ]. destruct (Substs_Cptr s p p0) as [? [ Heq ] ]; rewrite Heq in *. eapply Cptr_E; [ constructor; eauto | eauto ]. assert (valid specs PG (Substs s p1 ---> Substs s p2 ---> Substs s p')%PropX). repeat apply Imply_I. apply IHp1. simpl; tauto. intro. apply IHp2. simpl; tauto. eauto. eapply Imply_E. eapply Imply_E. eassumption. eapply And_E1; econstructor; eauto. eapply And_E2; econstructor; eauto. eapply Or_E. constructor; eauto. intuition. intuition. Qed. Theorem simplify_Imply : forall p1 p2, (simplifyH p1 SNil -> simplify p2 SNil) -> interp specs (Imply p1 p2). 
-> ltT c b. intros a b c H' H'0; apply ltT_eqT with (a := c) (c := a); auto. Qed. Theorem multTerm_ltT_l : forall m1 m2 m3, ltT m1 m2 -> ltT (multTerm multA m3 m1) (multTerm multA m3 m2). intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto. intros a0 m a1 m0 a2 m1 H. apply ltM_plusl with (1 := os); auto. Qed. Theorem multTerm_ltT_r : forall m1 m2 m3, ltT m1 m2 -> ltT (multTerm multA m1 m3) (multTerm multA m2 m3). intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto. intros; apply ltM_plusr with (1 := os); auto. Qed. Theorem T1_is_min_ltT : forall a, ~ ltT a (T1 A1 n). intros a; case a; unfold ltT in |- *; simpl in |- *; auto. intros a0 m; unfold M1 in |- *; apply (M1_min _ _ _ _ os); auto. Qed. Theorem minusTerm_ltT_l : forall a b c, eqT a b -> ltT a c -> ltT (minusTerm minusA a b) c. intros a b c; case a; case b; case c; unfold ltT in |- *; simpl in |- *; auto. Qed. Theorem invTerm_ltT_l : forall a c, ltT a c -> ltT (invTerm invA a) c. intros a b; case a; case b; unfold ltT in |- *; simpl in |- *; auto. Qed. Set Implicit Arguments. Unset Strict Implicit. Definition pX := cons (A:=Term A n). Set Strict Implicit. Unset Implicit Arguments. Definition pO := nil (A:=Term A n). Let consA := cons (A:=mon n). Let nilA := nil (A:=mon n). Let listA := list (mon n). Hint Unfold consA nilA listA. Fixpoint fP (a : list (Term A n)) : listA := match a with | nil => nilA | b :: p => consA (T2M b) (fP p) end. Theorem fP_app : forall p q : list (Term A n), fP (p ++ q) = fP p ++ fP q. intros p; elim p; simpl in |- *; auto. intros a l H' q. rewrite (H' q); auto. Qed. Let DescA := Desc (mon n) ltM. Set Implicit Arguments. Unset Strict Implicit. Definition olist (p : list (Term A n)) := DescA (fP p). Hint Resolve d_nil d_one. Hint Unfold olist DescA. Set Strict Implicit. Unset Implicit Arguments. Theorem olistOne : forall a b : Term A n, ltT b a -> olist (pX a (pX b pO)). 
Add LoadPath "coq". Require Import List. Require Import Ornamental.Ornaments. Require Import Test. Require Import Infrastructure.Set DEVOID search smart eliminators.Configure Lift list vector { opaque f_equal }. Configure Lift vector list { opaque f_equal }.Definition nil' := @nil.Lift list vector in nil' as nil'_c. Theorem testNil: forall A, nil'_c A = existT (vector A) 0 (nilV A). Proof. intros. reflexivity. Qed.Definition nilV' (A : Type) := existT (vector A) 0 (nilV A).Lift vector list in nilV' as nilV'_c. Theorem testNilV: forall A, nilV'_c A = @nil A. Proof. intros. reflexivity. Qed.Definition cons' := @cons.Lift list vector in cons' as cons'_c. Theorem testCons: forall A a pv, cons'_c A a pv = existT (vector A) (S (projT1 pv)) (consV A (projT1 pv) a (projT2 pv)). 
a}. intros a b; case (D.lt_eq_lt_dec a b). intro d; case d; auto. left; apply D.lt_le_weak; trivial. simple induction 1; left; apply le_refl. right; trivial. Defined. Definition le_lt_eq_dec : forall a b : A, le a b -> {lt a b} + {a = b}. intros a b H. case (D.lt_eq_lt_dec a b). trivial. intro H0; case (le_not_lt a b H H0). Defined.End More_Dec_Orders. Module Forget_Order (D: DEC_ORDER) : KEY with Definition A := D.A. Module M := More_Dec_Orders D. Definition A := D.A. Definition eqdec : forall a b : A, {a = b} + {a <> b}. intros a b; case (D.lt_eq_lt_dec a b). intro H; case H. right; apply D.lt_diff; auto. left; trivial. intro d; right. intro e; rewrite e in d. apply (M.lt_irreflexive b); auto. Defined. End Forget_Order. Module Lexico (D1: DEC_ORDER) (D2: DEC_ORDER) <: DEC_ORDER with Definition A := (D1.A * D2.A)%type. Module M1 := More_Dec_Orders D1. Module M2 := More_Dec_Orders D2. Definition A := (D1.A * D2.A)%type. Definition le (a b : A) : Prop := let (a1, a2) := a in let (b1, b2) := b in D1.lt a1 b1 \/ a1 = b1 /\ D2.le a2 b2. Definition lt (a b : A) : Prop := let (a1, a2) := a in let (b1, b2) := b in D1.lt a1 b1 \/ a1 = b1 /\ D2.lt a2 b2. Theorem ordered : order A le. Proof. split. unfold reflexive in |- *; intros. unfold le in |- *; case x. right. split; [ trivial | apply M2.le_refl; auto ]. unfold le, transitive in |- *. simple destruct x; simple destruct y; simple destruct z. simple destruct 1; intro H1. simple destruct 1. left. eapply M1.lt_trans. eexact H1. assumption. simple destruct 1. simple destruct 1. auto. simple destruct 1. intro. case H1; intros e H3; rewrite e; auto. case H1; intros e H3; rewrite e; auto. simple destruct 1. simple destruct 1. right. split; try auto. eapply M2.le_trans; eauto. unfold antisymmetric, A, le in |- *. simple destruct x; simple destruct y. simple destruct 1; simple destruct 2. intro. absurd (D1.lt a1 a1). apply M1.lt_irreflexive. eapply M1.lt_trans; eauto. simple destruct 1; intros e H3. rewrite e in H0. case (M1.lt_irreflexive a H0). case H0; intros e H3. rewrite e; intro H2. case (M1.lt_irreflexive a1 H2). simple destruct 1; intros e H3; rewrite e. case (M2.le_antisym a2 a0). auto. case H0; auto. auto. Qed. Theorem lt_le_weak : forall a b : A, lt a b -> le a b. 
move=> ->. case=> /encode_word'_injective + /encode_list_injective. move=> -> ->. do 6 (move=> _). exists []. by constructor. } all: case: k=> [|k]. 1,3,5,7: move=> _ /=; case=> <- *; exfalso; apply: Hu; by eassumption. all: case: k=> [|k]. 2,4,6,8: by move=> /= /Forall_cons_iff [_] /Forall_cons_iff [/not_ŒìPCP_rrr]. all: rewrite substitute_arrP /arguments /target. all: move=> /Forall_cons_iff [Hder _]; rewrite ? substitute_pairP. { move=> [H0] [[_ [H123 H4]]] [_] [[_ [H5 Hv]]] [_ [H6 Hw]]. move: H123 HQ. case: Q; first done. move=> [v' w'] Q. rewrite /encode_list -/encode_list /encode_word_pair -/encode_word_pair. rewrite ? substitute_pairP. move=> [_ [[_ [H1 H2]] H3]]. move: Hder. rewrite ? transparent_encode_pair //. rewrite H1 H2 H4 H5 H6. move /IH => /(_ (incl_refl P)). move=> [A [HAP HxyA]]. move /(_ (v', w')). move /(_ (in_eq _ _)) => ?. move: v w Hv Hw => [|? ?] [|? ?]. { exists ((v', w') :: A). constructor; [by apply /incl_cons | by assumption]. } all: by rewrite /= H0. } { move=> [H0] [[_ [H12 H3]]] H4. move: H12 HQ. case: Q; first done. move=> ? Q. rewrite /encode_list -/encode_list ? substitute_pairP. move=> [_ [_ H2]]. move=> /incl_cons_inv [_ HQ]. move: Hder. rewrite ? transparent_encode_pair => //. rewrite H2 H3 H4. move /IH. by apply. } { move=> [H0] [H1] [_] [[_ [H2]]] H34 H5. move: H34. case: v; first done. move=> a v. rewrite /encode_list -/encode_list substitute_pairP. move=> [_ [H3 H4]]. move: Hder. rewrite ? transparent_encode_pair => //. rewrite H1 H2 H3 H4 H5 -encode_word'_last. move /IH. rewrite -/(app [a] v). move /(_ HQ) => [A [?]]. rewrite - ? app_assoc => ?. by exists A. } { move=> [H0] [H1] [_] [H5] [_ [H2 H34]]. move: H34. case: w; first done. move=> a w. rewrite /encode_list -/encode_list substitute_pairP. move=> [_ [H3 H4]]. move: Hder. rewrite ? transparent_encode_pair => //. rewrite H1 H2 H3 H4 H5 -encode_word'_last. move /IH. rewrite -/(app [a] w). move /(_ HQ) => [A [?]]. rewrite - ? app_assoc => ?. by exists A. } Qed. Lemma ŒìPCP_completeness {v w P} : hsc ŒìPCP (PCPf ((v, w) :: P) v w) -> MPCPb ((v, w), P). Proof. move /hsc_der => [n]. have -> : PCPf ((v, w) :: P) v w = PCPf' ((v, w) :: P) ((v, w) :: P) (encode_pair (encode_word' bullet v) (encode_list encode_bool [])) (encode_pair (encode_word' bullet w) (encode_list encode_bool [])) by done. move /ŒìPCP_completeness_ind. by apply. Qed.End Argument.Require Import Undecidability.Synthetic.Definitions. Theorem reduction : MPCPb ‚™Ø (HSC_PRV Argument.ŒìPCP). 
{tl:list A | l = x::tl}}+{l = []}. Proof. induction l as [|a tail]. right; reflexivity. left; exists a, tail; reflexivity. Qed. Lemma hd_error_tl_repr : forall l (a:A) r, hd_error l = Some a /\ tl l = r <-> l = a :: r. Proof. destruct l as [|x xs]. - unfold hd_error, tl; intros a r. split; firstorder discriminate. - intros. simpl. split. * intros (H1, H2). inversion H1. rewrite H2. reflexivity. * inversion 1. subst. auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. Proof. unfold not; intros a H; inversion_clear H. Qed. Theorem in_split : forall x (l:list A), In x l -> exists l1 l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists [], l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Qed. Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem in_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl; auto. destruct IHl; simpl; auto. right; unfold not; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), [] <> x ++ a :: y. Proof. unfold not. destruct x as [| a l]; simpl; intros. discriminate H. discriminate H. Qed. Theorem app_nil_l : forall l:list A, [] ++ l = l. 
From Coq Require Import ssreflect ssrbool ssrfun. From mathcomp Require Import ssrnat eqtype seq ssrnum ssralg rat bigop. Set Bullet Behavior "Strict Subproofs".Require Import Coq.Lists.List.Require Import GHC.Base. Import GHC.Base.Notations. Require Import GHC.Num. Import GHC.Num.Notations. Require Import Data.Functor. Import Data.Functor.Notations. Require Import Data.Foldable.Require Import Proofs.GHC.Base. Require Import Proofs.Data.Foldable.Require Import Control.Monad.Random.Class. Require Import Data.List.Shuffle.Theorem riffle_eq {m a} `{MonadRandom m} (xs0 : list a) (nx0 : Int) (ys0 : list a) (ny0 : Int) : riffle xs0 nx0 ys0 ny0 = match xs0 , nx0 , ys0 , ny0 with | xs, _, nil, _ => pure xs | nil, _, ys, _ => pure ys | x :: xs, nx, y :: ys, ny => getRandomR (pair #1 (nx + ny)) >>= fun k => if k <= nx then cons x <$> riffle xs (nx - #1) (y :: ys) ny else cons y <$> riffle (x :: xs) nx ys (ny - #1) end. Proof. Admitted.Open Scope ring_scope. Theorem halve_In {a : eqType} (zs : list a) (e : a) : let: (xs, ys) := halve zs in In e zs <-> In e xs \/ In e ys. 
_ cs n) with (y := plusTerm (A:=A) plusA (n:=n) a (plusTerm (A:=A) plusA (n:=n) (invTerm (A:=A) invA (n:=n) b) b)); auto. apply plusTerm_comp_r with (1 := cs); auto. apply (eqT_trans A n) with (plusTerm plusA b (invTerm invA b)); auto. apply (eqTerm_imp_eqT A eqA); auto. apply plusTerm_com with (1 := cs); auto. apply plusTerm_com with (1 := cs); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := plusTerm (A:=A) plusA (n:=n) (plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b)) b); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply plusTerm_assoc with (1 := cs); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply zeroP_plusTerml with (1 := cs); auto. apply (eqT_trans A n) with (invTerm invA b); auto. apply plusTerm_eqT2; auto. apply (eqT_sym A n); apply invTerm_eqT; auto. apply zeroP_comp_eqTerm with (1 := cs) (2 := H'0). apply eqTerm_minusTerm_plusTerm_invTerm with (1 := cs); auto. apply (eqT_trans A n) with (1 := eq1); auto. apply (eqT_sym A n); apply plusTerm_eqT2; auto. apply (eqT_trans A n) with (1 := H'); auto. Qed. Hint Unfold minuspf. Theorem minusTerm_zeroP_r : forall a b : Term A n, zeroP (A:=A) A0 eqA (n:=n) a -> eqT a b -> eqTerm (A:=A) eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) (invTerm (A:=A) invA (n:=n) b). intros a b H' H0; apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b)); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); apply zeroP_plusTerml with (1 := cs); auto. apply (eqT_trans A n) with (y := b); auto. Qed. Theorem minusTerm_zeroP : forall a b : Term A n, eqT a b -> zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (minusTerm (A:=A) minusA (n:=n) a b) a. intros a b H' H'0. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := plusTerm (A:=A) plusA (n:=n) a (invTerm (A:=A) invA (n:=n) b)); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply zeroP_plusTermr with (1 := cs); auto. apply (eqT_trans A n) with (y := b); auto. apply zeroP_invTerm_zeroP with (1 := cs); auto. Qed. Hint Resolve minusTerm_zeroP minusTerm_zeroP_r. Theorem minusP_pO_is_eqP : forall p q r : list (Term A n), minusP p q r -> eqP A eqA n r (pO A n) -> eqP A eqA n p q. 
list (A * B * C))(ls2 : list (B * C)) a b, list_pred (fun x y => fst (fst x) = a /\ snd (fst x) = fst y /\ snd x = snd y) ls1 ls2 -> arrayLookup _ ls1 (a, b) = arrayLookup _ ls2 b. induction ls1; intuition; simpl in *. inversion H; clear H; subst. simpl. trivial. inversion H; clear H; subst. simpl. intuition. subst. simpl in *. subst. destruct a2. simpl in *. unfold eqbPair. simpl. rewrite eqb_refl. simpl. case_eq (eqb b1 b); intuition. Qed.Theorem arrayLookup_pred_2 : forall (A B C: Set)(eqda : EqDec A) (P : list B -> list C -> Prop) (ls1 : list (A * list B))(ls2 : list (A * list C)) a, list_pred (fun x y => (fst x = a \/ fst y = a) -> (fst x = a /\ fst y = a /\ P (snd x) (snd y))) ls1 ls2 -> P nil nil -> P (arrayLookupList _ ls1 a) (arrayLookupList _ ls2 a). induction ls1; intuition; simpl in *. inversion H; clear H; subst. unfold arrayLookupList. simpl. trivial. inversion H; clear H; subst. unfold arrayLookupList. simpl. destruct a2. simpl in *. intuition. case_eq (eqb a a0); intuition. rewrite eqb_leibniz in H2. subst. intuition. subst. rewrite eqb_refl. trivial. case_eq (eqb a a1); intuition. rewrite eqb_leibniz in H3. subst. intuition. subst. rewrite eqb_refl in H2. discriminate. eapply IHls1; intuition. Qed.Theorem In_arrayLookupList : forall (A B : Set)(eqda : EqDec A)(a : A)(b : B) ls, In b (arrayLookupList _ ls a) -> exists ls', In (a, ls') ls /\ In b ls'. intuition. unfold arrayLookupList in *. case_eq (arrayLookup eqda ls a); intuition; rewrite H0 in H. eapply arrayLookup_Some_impl_In in H0. econstructor. split. eauto. trivial. simpl in *. intuition. Qed.Theorem arrayLookupList_pred' : forall (A B : Set) (eqda : EqDec A) (P : list B -> Type) (ls : list (A * list B)) (a : A), (forall x : list B, In (a, x) ls -> P x) -> (arrayLookup _ ls a = None -> P nil) -> P (arrayLookupList eqda ls a). induction ls; intuition; simpl in *. unfold arrayLookupList. simpl. case_eq (eqb a a0); intuition. eapply X. rewrite eqb_leibniz in H. subst. intuition. case_eq (arrayLookup eqda ls a); intuition. specialize (IHls a). unfold arrayLookupList in *. rewrite H0 in IHls. eapply IHls; eauto. intuition. discriminate. rewrite H in X0. intuition. Qed. Theorem arrayLookup_allNats_eq : forall (B : Set)(ls : list (nat * B)) i, fst (split ls) = allNatsLt (length ls) -> arrayLookup _ ls i = match nth_option ls i with | Some (_, v) => Some v | None => None end. 
m. iFrame. iIntros "Hda". iMod "HcloseE" as "_". iIntros "!> Hs". iApply "HŒ¶". iFrame. Qed. Lemma wpc_Read stk E1 (a: u64) aset q b : {{{ int.Z a d‚Ü¶{q}[aset] b }}} Read #a @ stk; E1 {{{ s, RET slice_val s; int.Z a d‚Ü¶{q}[aset] b ‚àó is_slice s byteT 1%Qp (Block_to_vals b) }}} {{{ int.Z a d‚Ü¶{q}[aset] b }}}. Proof. iIntros (Œ¶ Œ¶c) "Hda HŒ¶". rewrite /Read. wpc_pures. { by crash_case. } wpc_bind (ExternalOp _ _). assert (Atomic (StronglyAtomic) (ExternalOp ReadOp #a)). { solve_atomic. inversion H. subst. monad_inv. inversion H0. subst. inversion H2. subst. inversion H4. subst. inversion H6. subst. inversion H7. subst. eauto. } wpc_atomic; iFrame. wp_apply (wp_ReadOp with "Hda"). iIntros (l) "(Hda&Hl)". iDestruct (block_array_to_slice_raw with "Hl") as "Hs". iSplit. { iDestruct "HŒ¶" as "(HŒ¶&_)". iModIntro. iDestruct ("HŒ¶" with "[$]") as "H". repeat iModIntro; auto. } iModIntro. wpc_pures; first by crash_case. wpc_frame "Hda HŒ¶". { by crash_case. } wp_apply (wp_raw_slice with "Hs"). iIntros (s) "Hs". iIntros "(?&HŒ¶)". iApply "HŒ¶". iFrame. Qed.Theorem wpc_Write_ncfupd {stk E1} E1' (a: u64) s q b : ‚àÄ Œ¶ Œ¶c, is_block s q b -‚àó (Œ¶c ‚àß |NC={E1,E1'}=> ‚àÉ aset b0, int.Z a d‚Ü¶[aset] b0 ‚àó ‚ñ∑ (‚àÄ b', ‚åú b' = aset ‚à® b' = b ‚åù ‚àó int.Z a d‚Ü¶[b'] b -‚àó |NC={E1',E1}=> Œ¶c ‚àß (is_block s q b -‚àó Œ¶ #()))) -‚àó WPC Write #a (slice_val s) @ stk; E1 {{ Œ¶ }} {{ Œ¶c }}. Proof. iIntros (Œ¶ Œ¶c) "Hs Hfupd". rewrite /Write /slice.ptr. wpc_pures. { iLeft in "Hfupd". iFrame. } iDestruct (is_slice_small_sz with "Hs") as %Hsz. iDestruct (is_slice_small_wf with "Hs") as %Hwf. assert (Atomic StronglyAtomic (ExternalOp WriteOp (#a, #s.(Slice.ptr))%V)). { solve_atomic. inversion H. subst. monad_inv. inversion H0. subst. inversion H2. subst. inversion H4. subst. inversion H6. subst. inversion H7. inversion H8. subst. inversion H13. eauto. } wpc_atomic. iRight in "Hfupd". iMod "Hfupd" as (aset b0) "[Hda HQ]". wp_apply (wp_WriteOp with "[Hda Hs]"). { iIntros "!>". iFrame. by iApply slice_to_block_array. } iIntros "H". iDestruct "H" as (b' Hdisj) "[Hda Hmapsto]". iMod ("HQ" with "[$Hda]") as "HQ"; eauto. iModIntro. iSplit. - iDestruct "HQ" as "(HQ&_)". iModIntro. by repeat iModIntro. - iModIntro. iRight in "HQ". iApply "HQ". iFrame. destruct s; simpl in Hsz. replace sz with (U64 4096). + iDestruct (block_array_to_slice_raw with "Hmapsto") as "[? %]". rewrite /is_block /is_slice_small. iFrame. iPureIntro. simpl. split; first done. simpl in Hwf. word. + rewrite length_Block_to_vals in Hsz. change block_bytes with (Z.to_nat 4096) in Hsz. word. Qed. Theorem wpc_Write_fupd {stk E1} E1' (a: u64) s q b : ‚àÄ Œ¶ Œ¶c, is_block s q b -‚àó (Œ¶c ‚àß |={E1,E1'}=> ‚àÉ aset b0, int.Z a d‚Ü¶[aset] b0 ‚àó ‚ñ∑ (‚àÄ b', ‚åú b' = aset ‚à® b' = b ‚åù ‚àó int.Z a d‚Ü¶[b'] b ={E1',E1}=‚àó Œ¶c ‚àß (is_block s q b -‚àó Œ¶ #()))) -‚àó WPC Write #a (slice_val s) @ stk; E1 {{ Œ¶ }} {{ Œ¶c }}. 
Require Import List Arith Max Lia Wellfounded Bool.From Undecidability.Shared.Libs.DLW.Utils Require Import list_focus utils_tac utils_list utils_nat.Set Implicit Arguments.Section list_choose_d. Variable (X : Type) (P Q : X -> Prop). Theorem list_choose_d l : (forall x, In x l -> P x \/ Q x) -> (exists x, In x l /\ P x) \/ forall x, In x l -> Q x. Proof. induction l as [ | x l IHl ]; intros Hl. + right; intros _ []. + destruct (Hl x) as [ H1 | H1 ]. * left; auto. * left; exists x; simpl; auto. * destruct IHl as [ (y & H2 & H3) | H2 ]. - intros; apply Hl; right; auto. - left; exists y; simpl; auto. - right; intros ? [ <- | ]; auto. Qed.End list_choose_d.Section bounded_choose_d. Variable (P Q : nat -> Prop). Theorem bounded_choose_d n : (forall x, x < n -> P x \/ Q x) -> (exists x, x < n /\ P x) \/ forall x, x < n -> Q x. Proof. intros H. destruct list_choose_d with (P := P) (Q := Q) (l := list_an 0 n) as [ (x & H1 & H2) | H1 ]. + intro; rewrite list_an_spec; intro; apply H; lia. + left; exists x; split; auto. apply list_an_spec in H1; lia. + right; intros x Hx; apply H1, list_an_spec; lia. Qed. End bounded_choose_d.Section bounded_min. Variable (P Q : nat -> Prop). Theorem bounded_min_d n : (forall x, x < n -> P x \/ Q x) -> (exists x, x < n /\ P x /\ forall y, y < x -> Q y) \/ forall x, x < n -> Q x. 
ts c, tuples1 len key ts c ===> [| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]. Proof. unfold tuples1; sepLemma; eauto. Qed. Theorem tuples1_bwd : forall len key ts (c : W), ([| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |]) ===> tuples1 len key ts c. Proof. unfold tuples1; sepLemma; eauto. Qed. Theorem tuples1_eq : forall len key ts c, tuples1 len key ts c = ([| c <> 0 |] * [| freeable c 3 |] * [| $2 <= len |] * Ex p, Ex sk, (c ==*> len, key, p) * tree len key sk ts p * [| key < len |])%Sep. Proof. auto. Qed. Theorem tree_Equiv : forall len key sk ts1 ts2 p, Equiv ts1 ts2 -> tree len key sk ts1 p ===> tree len key sk ts2 p. Proof. induction sk; sepLemma. Equiv. repeat apply himp_star_frame; eauto. eapply tuples0_Equiv; eauto. Qed. Theorem tuples1_Equiv : forall len key ts1 ts2 p, Equiv ts1 ts2 -> tuples1 len key ts1 p ===> tuples1 len key ts2 p. Proof. unfold tuples1; sepLemma. eapply tree_Equiv; eauto. Qed. Theorem tree_leaf_fwd : forall len key sk ts (p : W), p = 0 -> tree len key sk ts p ===> [| sk = Leaf |] * [| empty ts |]. Proof. destruct sk; sepLemma. Qed. Theorem tree_leaf_bwd : forall len key sk ts (p : W), p = 0 -> [| sk = Leaf |] * [| empty ts |] ===> tree len key sk ts p. Proof. destruct sk; sepLemma. Qed. Theorem tree_node_fwd : forall len key sk ts (p : W), p <> 0 -> tree len key sk ts p ===> Ex sk1, Ex sk2, Ex p1, Ex k, Ex t0, Ex p2, [| sk = Node sk1 sk2 |] * (p ==*> p1, k, t0, p2) * tree len key sk1 (keepLt ts key k) p1 * tuples0 len (keepEq ts key k) t0 * tree len key sk2 (keepGt ts key k) p2. Proof. destruct sk; sepLemma. Qed. Theorem tree_node_bwd : forall len key sk ts (p : W), p <> 0 -> (Ex sk1, Ex sk2, Ex p1, Ex k, Ex t0, Ex p2, [| sk = Node sk1 sk2 |] * (p ==*> p1, k, t0, p2) * tree len key sk1 (keepLt ts key k) p1 * tuples0 len (keepEq ts key k) t0 * tree len key sk2 (keepGt ts key k) p2) ===> tree len key sk ts p. 
Œ≥ œÉs m0 : dom m' = dom m0 ‚Üí async_ctx Œ≥ 1 œÉs -‚àó ([‚àó map] k‚Ü¶v ‚àà m0, ephemeral_val_from Œ≥ (length (possible œÉs) - 1) k v) -‚àó |==> let œÉs' := (async_put (m' ‚à™ latest œÉs) œÉs) in async_ctx Œ≥ 1 œÉs' ‚àó ([‚àó map] k‚Ü¶v ‚àà m', ephemeral_val_from Œ≥ (length (possible œÉs') - 1) k v). Proof. iIntros (Hdom) "Hctx Hm". iDestruct (ephemeral_val_from_agree_latest_map with "Hctx Hm") as %Hm0. iDestruct "Hctx" as "(Halast & %Hdoms & Halist & _)". rewrite /async_ctx. iMod (fmlist_update with "Halist") as "[$ #Hflist]". { apply prefix_app_r. reflexivity. } iFrame "Hflist". rewrite /ephemeral_val_from [(own_last_auth _ _ _ ‚àó _)%I]comm. iEval (rewrite -assoc). iSplitR. { iPureIntro. rewrite possible_async_put /async_put /=. apply Forall_app. split. - eapply Forall_impl; first exact Hdoms. simpl. intros œÉ ->. rewrite dom_union_L Hdom. eapply subseteq_dom in Hm0. set_solver +Hm0. - apply Forall_singleton. done. } rewrite /ephemeral_val_from [(own_last_auth _ _ _ ‚àó _)%I]comm. iEval (rewrite big_sepM_sep -assoc). iSplitR. { iApply big_sepM_forall. iIntros "!>" (k v Hm'). iExists (m' ‚à™ latest œÉs). iSplit. - iPureIntro. rewrite lookup_union Hm'. destruct (latest œÉs !! k); done. - iApply fmlist_lb_to_idx; last done. rewrite lookup_possible_latest'. done. } iClear "Hflist". iDestruct (own_last_put with "Halast") as "Halast". rewrite length_possible_async_put. clear Hm0. iInduction m' as [|a v m] "IH" using map_ind forall (m0 Hdom). - assert (m0 = ‚à ) as ->. { apply dom_empty_iff. rewrite -Hdom dom_empty. done. } rewrite !big_sepM_empty. rewrite !left_id. by iFrame. - rewrite big_sepM_insert //. assert (is_Some (m0 !! a)) as [v0 Hv0]. { apply elem_of_dom. rewrite -Hdom dom_insert. set_solver+. } iDestruct (big_sepM_delete with "Hm") as "[[_ Hlast] Hm]"; first done. iMod ("IH" with "[] Hm Halast") as "[$ Halast]". { iPureIntro. rewrite dom_delete_L -Hdom dom_insert_L. assert (a ‚àâ dom m) as Hnotm. { apply not_elem_of_dom. done. } set_solver +Hnotm. } iClear "IH". iMod (own_last_update with "Halast Hlast") as "[Halast Hlast]". rewrite insert_union_l /ephemeral_val_from. iFrame. done. Qed. Theorem async_ctx_ephemeral_val_from_split Œ≥ œÉs i k v : async_ctx Œ≥ 1 œÉs -‚àó ephemeral_val_from Œ≥ i k v ==‚àó async_ctx Œ≥ 1 œÉs ‚àó ephemeral_txn_val_range Œ≥ i (length (possible œÉs)) k v ‚àó ephemeral_val_from Œ≥ (length (possible œÉs) - 1) k v. Proof. iIntros "Hctx Hi+". iDestruct (ephemeral_val_from_in_bounds with "Hctx Hi+") as %Hinbounds. iMod (ephemeral_val_from_split (length (possible œÉs) - 1) with "Hctx Hi+") as "(Hctx & Hold & H+)"; [lia..|]. assert (S (length (possible œÉs) - 1) = length (possible œÉs)) as -> by lia. by iFrame. Qed. Theorem async_ctx_ephemeral_val_from_map_split Œ≥ œÉs i m : async_ctx Œ≥ 1 œÉs -‚àó big_opM bi_sep (ephemeral_val_from Œ≥ i) m ==‚àó async_ctx Œ≥ 1 œÉs ‚àó big_opM bi_sep (ephemeral_txn_val_range Œ≥ i (length (possible œÉs))) m ‚àó big_opM bi_sep (ephemeral_val_from Œ≥ (length (possible œÉs) - 1)) m. 
: list A * S_A) := [lsa, s_A] <-2 p; lsb <--$ oc_compMap _ (fun a => OC_Query _ a) lsa; $ A2 s_A lsb. Theorem OMH_G_oc_wf : forall p, well_formed_oc (OMH_G_oc p). intuition. econstructor. apply oc_compMap_wf. intuition. econstructor. intuition. econstructor. auto. Qed. Theorem OMH_G_oc_equiv : forall O, Pr[OMH_G O] == Pr[ [s, s_A] <-$2 A1; [b, _] <-$2 (OMH_G_oc s_A) _ _ O s; ret b ]. intuition. unfold OMH_G, OMH_G_oc. fcf_skip. fcf_simp. fcf_to_prhl_eq. simpl. fcf_inline_first. fcf_skip. apply compFold_oc_equiv. subst. fcf_inline_first. fcf_ident_expand_l. fcf_skip. fcf_simp. fcf_spec_ret. Qed. Definition OMH_G1 := OMH_G O1. Definition OMH_G2 := OMH_G O2. Theorem OMH_G1_equiv: Pr[OMH_G1] == Pr[G1 _ O1 A1 OMH_G_oc]. unfold OMH_G1. rewrite OMH_G_oc_equiv. unfold G1, OMH_G_oc. reflexivity. Qed. Theorem OMH_G2_equiv: Pr[OMH_G2] == Pr[G2 _ O2 A1 OMH_G_oc]. unfold OMH_G2. rewrite OMH_G_oc_equiv. unfold G2, OMH_G_oc. reflexivity. Qed. Theorem OMH_G_oc_qam : forall p s, In (s, p) (getSupport A1) -> queries_at_most (OMH_G_oc p) q. intuition. unfold OMH_G_oc. econstructor. econstructor. eapply oc_compMap_qam. intuition. econstructor. intuition. econstructor. rewrite mult_1_r. rewrite plus_0_r. eapply max_queries. eauto. Qed. Definition Gi_oracleMap i := [s, p] <-$2 A1; [lsa, s_A] <-2 p; p <-$ oracleMap _ _ (Oi _ _ O1 O2 i) (s, 0)%nat lsa; A2 s_A (fst p). Definition Gi_oracleMap' i := [s, p] <-$2 A1; [lsa, s_A] <-2 p; p <-$ ( [lsb1, s'] <-$2 oracleMap _ _ (Oi _ _ O1 O2 i) (s, 0)%nat (firstn i lsa); [lsb2, s''] <-$2 oracleMap _ _ (Oi _ _ O1 O2 i) s'%nat (skipn i lsa); ret (lsb1 ++ lsb2, s'') ); A2 s_A (fst p). Theorem Gi_oracleMap_equiv : forall i, Pr[Gi _ _ O1 O2 A1 OMH_G_oc i] == Pr[Gi_oracleMap i]. intuition. unfold Gi, OMH_G_oc, Gi_oracleMap. fcf_skip. fcf_simp. fcf_to_prhl_eq. simpl. fcf_inline_first. eapply comp_spec_eq_symm. fcf_skip. eapply compFold_oc_equiv. subst. simpl. fcf_ident_expand_l. fcf_inline_first. fcf_skip. fcf_simp. fcf_spec_ret. Qed. Theorem Gi_oracleMap'_equiv : forall i, Pr[Gi_oracleMap i] == Pr[Gi_oracleMap' i]. intuition. unfold Gi_oracleMap, Gi_oracleMap'. fcf_skip. fcf_simp. fcf_skip. cutrewrite (l = (firstn i l ++ skipn i l)). eapply eqRat_trans. eapply compFold_app. fcf_skip. rewrite firstn_skipn. reflexivity. fcf_simp. fcf_ident_expand_l. fcf_to_prhl_eq. rewrite firstn_skipn. fcf_skip. eapply (compFold_spec' (fun a b c d => a = b /\ snd c = snd d /\ l0++ (fst d) = (fst c))); intuition. simpl. eapply app_nil_r. simpl in *. subst. destruct d. simpl in *. subst. unfold Oi. inversion H2; clear H2; subst. fcf_inline_first. fcf_skip. fcf_simp. fcf_spec_ret. simpl. rewrite app_assoc. trivial. fcf_simp. simpl in H3. intuition. subst. fcf_spec_ret. rewrite firstn_skipn. trivial. Qed. Theorem OMH_G_i_equiv : forall i, Pr[Gi_oracleMap' i] == Pr[OMH_G_i i]. 
with zarith. generalize (Z_eq_bool_correct (Fnum x) (nNormMin radix precision)); case (Z_eq_bool (Fnum x) (nNormMin radix precision)); intros H'2. generalize (Z_eq_bool_correct (Fexp x) (- dExp b)); case (Z_eq_bool (Fexp x) (- dExp b)); intros H'3. replace x with (Float (Fnum x) (Fexp x)). rewrite H'2; rewrite H'3; rewrite FPredSimpl3; unfold Fopp in |- *; simpl in |- *; rewrite FSuccSimpl3; simpl in |- *; auto. rewrite <- Zopp_Zpred_Zs; rewrite Zopp_involutive; auto. case x; simpl in |- *; auto. rewrite FPredSimpl2; auto; rewrite FSuccSimpl2; unfold Fopp in |- *; simpl in |- *; try rewrite Zopp_involutive; auto. rewrite H'2; auto. rewrite FPredSimpl4; auto; rewrite FSuccSimpl4; auto. unfold Fopp in |- *; simpl in |- *; rewrite <- Zopp_Zpred_Zs; rewrite Zopp_involutive; auto. unfold Fopp in |- *; simpl in |- *; Contradict H'1; rewrite <- H'1; rewrite Zopp_involutive; auto. unfold Fopp in |- *; simpl in |- *; Contradict H'2; auto with zarith. Qed. Theorem FPredDiff1 : forall x : float, Fnum x <> nNormMin radix precision -> Fminus radix x (FPred x) = Float 1%nat (Fexp x) :>R. intros x H'; rewrite (FPredFopFSucc x). pattern x at 1 in |- *; rewrite <- (Fopp_Fopp x). rewrite <- Fopp_Fminus_dist. rewrite Fopp_Fminus. unfold FtoRradix in |- *; rewrite FSuccDiff1; auto. replace (Fnum (Fopp x)) with (- Fnum x)%Z. Contradict H'; rewrite <- (Zopp_involutive (Fnum x)); rewrite H'; auto with zarith. case x; simpl in |- *; auto. Qed. Theorem FPredDiff2 : forall x : float, Fnum x = nNormMin radix precision -> Fexp x = (- dExp b)%Z -> Fminus radix x (FPred x) = Float 1%nat (Fexp x) :>R. intros x H' H'0; rewrite (FPredFopFSucc x). pattern x at 1 in |- *; rewrite <- (Fopp_Fopp x). rewrite <- Fopp_Fminus_dist. rewrite Fopp_Fminus. unfold FtoRradix in |- *; rewrite FSuccDiff2; auto. rewrite <- H'; case x; auto. Qed. Theorem FPredDiff3 : forall x : float, Fnum x = nNormMin radix precision -> Fexp x <> (- dExp b)%Z -> Fminus radix x (FPred x) = Float 1%nat (Zpred (Fexp x)) :>R. intros x H' H'0; rewrite (FPredFopFSucc x). pattern x at 1 in |- *; rewrite <- (Fopp_Fopp x). rewrite <- Fopp_Fminus_dist. rewrite Fopp_Fminus. unfold FtoRradix in |- *; rewrite FSuccDiff3; auto. rewrite <- H'; case x; auto. Qed. Theorem FBoundedPred : forall f : float, Fbounded b f -> Fbounded b (FPred f). intros f H'; rewrite (FPredFopFSucc f); auto with float. Qed. Theorem FPredCanonic : forall a : float, Fcanonic radix b a -> Fcanonic radix b (FPred a). 
p : float, FNeven p -> FNeven (Fopp p). intros p; unfold FNeven in |- *. rewrite Fnormalize_Fopp; auto with arith. intros; apply FevenFop; auto. Qed. Theorem FNoddFop : forall p : float, FNodd p -> FNodd (Fopp p). intros p; unfold FNodd in |- *. rewrite Fnormalize_Fopp; auto with arith. intros; apply FoddFop; auto. Qed. Theorem FNoddSuc : forall p : float, Fbounded b p -> FNodd p -> FNeven (FNSucc b radix precision p). unfold FNodd, FNeven, FNSucc in |- *. intros p H' H'0. rewrite FcanonicFnormalizeEq; auto with float arith. apply FoddSuc; auto with float arith. Qed. Theorem FNevenSuc : forall p : float, Fbounded b p -> FNeven p -> FNodd (FNSucc b radix precision p). unfold FNodd, FNeven, FNSucc in |- *. intros p H' H'0. rewrite FcanonicFnormalizeEq; auto with float arith. apply FevenSuc; auto. Qed. Theorem FNevenPred : forall p : float, Fbounded b p -> FNodd p -> FNeven (FNPred b radix precision p). unfold FNodd, FNeven, FNPred in |- *. intros p H' H'0. rewrite FcanonicFnormalizeEq; auto with float arith. apply FevenPred; auto. Qed. Theorem FNoddPred : forall p : float, Fbounded b p -> FNeven p -> FNodd (FNPred b radix precision p). unfold FNodd, FNeven, FNPred in |- *. intros p H' H'0. rewrite FcanonicFnormalizeEq; auto with float arith. apply FoddPred; auto. Qed. Theorem FNevenOrFNodd : forall p : float, FNeven p \/ FNodd p. intros p; unfold FNeven, FNodd in |- *; apply FevenOrFodd. Qed. Theorem FnOddNEven : forall n : float, FNodd n -> ~ FNeven n. intros n H'; unfold FNeven, Feven in |- *; apply OddNEven; auto. Qed. Theorem FEvenD : forall p : float, Fbounded b p -> Feven p -> exists q : float, Fbounded b q /\ p = (2%nat * q)%R :>R. intros p H H0; case H0. intros z Hz; exists (Float z (Fexp p)); split; auto. repeat split; simpl in |- *; auto with float. apply Zle_lt_trans with (Zabs (Fnum p)); auto with float zarith. rewrite Hz; rewrite Zabs_Zmult; replace (Zabs 2 * Zabs z)%Z with (Zabs z + Zabs z)%Z; auto with zarith arith. pattern (Zabs z) at 1 in |- *; replace (Zabs z) with (0 + Zabs z)%Z; auto with zarith. rewrite (Zabs_eq 2); auto with zarith. unfold FtoRradix, FtoR in |- *; simpl in |- *. rewrite Hz; rewrite Rmult_IZR; simpl in |- *; ring. Qed. Theorem FNEvenD : forall p : float, Fbounded b p -> FNeven p -> exists q : float, Fbounded b q /\ p = (2%nat * q)%R :>R. 
n (fr : W) b, fr <> 0 -> focusOnBack -> (Ex v1, Ex v2, Ex v1', Ex v2', Ex n', Ex p, [| n = S (S n') |] * [| (v1', v2') %in b |] * [| (v1, v2) %in b %- (v1', v2')|] * lseg (b %- (v1, v2) %- (v1', v2')) n' fr p * [| p <> 0 |] * [| freeable p 3 |] * (p ==*> v1, v2, ba) * [| ba <> 0 |] * [| freeable ba 3 |] * (ba ==*> v1', v2', $0)) ===> llist b n fr ba. End QUEUE.Module Queue : QUEUE. Open Scope Sep_scope. Fixpoint llist (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = 0 /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * [| ifZero n' fr ba |] * llist (b %- (v1, v2)) n' p ba end. Fixpoint lseg (b : bag) (n : nat) (fr ba : W) : HProp := match n with | O => [| fr = ba /\ b %= empty |] | S n' => [| fr <> 0 |] * Ex v1, Ex v2, Ex p, [| (v1, v2) %in b |] * (fr ==*> v1, v2, p) * [| freeable fr 3 |] * lseg (b %- (v1, v2)) n' p ba end. Definition queue (b : bag) (p : W) : HProp := Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. Theorem llist_extensional : forall b n fr ba, HProp_extensional (llist b n fr ba). destruct n; reflexivity. Qed. Theorem lseg_extensional : forall b n fr ba, HProp_extensional (lseg b n fr ba). destruct n; reflexivity. Qed. Theorem queue_extensional : forall b p, HProp_extensional (queue b p). reflexivity. Qed. Theorem lseg_extensional' : forall ba n b b' fr, b %= b' -> lseg b n fr ba ===> lseg b' n fr ba. induction n; sepLemma. Qed. Theorem llist_extensional' : forall ba n b b' fr, b %= b' -> llist b n fr ba ===> llist b' n fr ba. induction n; sepLemma. Qed. Theorem queue_fwd : forall b p, queue b p ===> Ex fr, Ex ba, Ex n, [| freeable p 2 |] * (p ==*> fr, ba) * llist b n fr ba. 
P)). Theorem FSAT_MONADIC_DEC : decidable (FSAT _ A). Proof using H2 H1. destruct Sig_discrete_to_pos with (A := A) as (n & m & i & j & B & HB). + simpl; intros s; destruct (H1 s). + apply H2. + assert (n = 0) as ->. { destruct n; auto. destruct (H1 (i pos0)). } simpl in *. destruct FSAT_Œ£P1_dec with (V := pos 0) (A := B) as [ H | H ]. * intros p; invert pos p. * left; apply HB; auto. * right; rewrite HB; auto. Qed.End FSAT_MONADIC_DEC.Section FSAT_MONADIC_11_FSAT_MONADIC_1. Variable (n : nat) (Y : Type) (HY : finite_t Y). Theorem FSAT_MONADIC_11_FSAT_MONADIC_1 : FSAT (Œ£11 (pos n) Y) ‚™Ø·µ¢ FSAT (Œ£11 Empty_set (list (pos n)*Y + Y)). Proof using HY. apply ireduces_dependent, Œ£11_Œ£1_reduction; auto. Qed.End FSAT_MONADIC_11_FSAT_MONADIC_1.Section FSAT_Œ£11_DEC. Variable (n : nat) (P : Type) (HP1 : finite_t P) (HP2 : discrete P) (A : fol_form (Œ£11 (pos n) P)). Theorem FSAT_Œ£11_DEC : decidable (FSAT _ A). Proof using HP2 HP1. destruct FSAT_MONADIC_11_FSAT_MONADIC_1 with (n := n) (1 := HP1) as (f & Hf). specialize (Hf A). destruct FSAT_MONADIC_DEC with (A := f A) as [ H | H ]; simpl; auto; try easy. + left; revert H; apply Hf. + right; contradict H; revert H; apply Hf. Qed.End FSAT_Œ£11_DEC.Section FSAT_FULL_Œ£11_DEC. Variable (F P : Type) (HF : discrete F) (HP : discrete P) (A : fol_form (Œ£11 F P)). Hint Resolve finite_t_pos : core. Theorem FSAT_FULL_Œ£11_DEC : decidable (FSAT _ A). Proof using HP HF. destruct Sig_discrete_to_pos with (A := A) as (n & m & i & j & B & HB); auto. destruct FSAT_Œ£11_DEC with (A := B) as [ H | H ]; auto. + left; apply HB; auto. + right; contradict H; apply HB; auto. Qed.End FSAT_FULL_Œ£11_DEC.Section FSAT_FULL_MONADIC_DEC. Variable (Œ£ : fo_signature) (H1 : discrete (syms Œ£)) (H2 : discrete (rels Œ£)) (H3 : forall s, ar_syms Œ£ s <= 1) (H4 : forall r, ar_rels Œ£ r <= 1). Theorem FSAT_FULL_MONADIC_DEC A : decidable (FSAT Œ£ A). Proof using H4 H3 H2 H1. destruct FSAT_FULL_MONADIC_FSAT_11 with Œ£ as (f & Hf); auto. destruct FSAT_FULL_Œ£11_DEC with (A := f A) as [ H | H ]; auto. + left; apply Hf, H. + right; contradict H; apply Hf, H. Qed. End FSAT_FULL_MONADIC_DEC.Section FSAT_PROP_ONLY_DEC. Variable (Œ£ : fo_signature) (H1 : discrete (rels Œ£)) (H2 : forall r, ar_rels Œ£ r = 0). Theorem FSAT_PROP_ONLY_DEC A : decidable (FSAT Œ£ A). 
split. EvalOp. simpl. rewrite mk_shift_amount_eq; auto. destruct v1; simpl; auto. destruct (Int.ltu n1 Int.iwordsize) eqn:?; simpl; auto. rewrite Heqb; rewrite Heqb0. rewrite Int.add_commut. rewrite Int.shru_shru; auto. rewrite Int.add_commut; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. TrivialExists. simpl. rewrite mk_shift_amount_eq; auto. intros; TrivialExists. simpl. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor. auto. Qed.Lemma eval_mulimm_base: forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros; unfold mulimm_base. assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\ Val.lessdef (Val.mul x (Vint n)) v). TrivialExists. econstructor. EvalOp. simpl; eauto. econstructor. eauto. constructor. rewrite Val.mul_commut. auto. generalize (Int.one_bits_decomp n). generalize (Int.one_bits_range n). destruct (Int.one_bits n). intros. auto. destruct l. intros. rewrite H1. simpl. rewrite Int.add_zero. replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul. apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib. destruct l. intros. rewrite H1. simpl. exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]]. exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]]. exploit (eval_add (x :: le)). eexact A1. eexact A2. intros [v [A B]]. exists v; split. econstructor; eauto. rewrite Int.add_zero. replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0))) with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))). rewrite Val.mul_add_distr_r. repeat rewrite Val.shl_mul. eapply Val.lessdef_trans. 2: eauto. apply Val.add_lessdef; auto. simpl. repeat rewrite H0; auto with coqlib. intros. auto. Qed. Theorem eval_mulimm: forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)). Proof. intros; red; intros until x; unfold mulimm. predSpec Int.eq Int.eq_spec n Int.zero. intros. exists (Vint Int.zero); split. EvalOp. destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto. predSpec Int.eq Int.eq_spec n Int.one. intros. exists x; split; auto. destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto. case (mulimm_match a); intros; InvEval. TrivialExists. simpl. rewrite Int.mul_commut; auto. subst. rewrite Val.mul_add_distr_l. exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]]. exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]]. exists v''; split; auto. eapply Val.lessdef_trans. eapply Val.add_lessdef; eauto. rewrite Val.mul_commut; auto. apply eval_mulimm_base; auto. Qed.Theorem eval_mul: binary_constructor_sound mul Val.mul. Proof. red; intros until y. unfold mul; case (mul_match a b); intros; InvEval. rewrite Val.mul_commut. apply eval_mulimm. auto. apply eval_mulimm. auto. TrivialExists. Qed.Theorem eval_mulhs: binary_constructor_sound mulhs Val.mulhs. Proof. unfold mulhs; red; intros; TrivialExists. Qed. Theorem eval_mulhu: binary_constructor_sound mulhu Val.mulhu. 
Require Import Arith Nat Omega List Bool.Require Import utils_tac utils_list rel_iter sums. Require Import dio_logic dio_expo dio_bounded.Set Implicit Arguments.Local Notation power := (mscal mult 1).Section df_seq. Variable (R : nat -> nat -> Prop) (HR : ùîªR (fun ŒΩ => R (ŒΩ 1) (ŒΩ 0))). Theorem dio_rel_is_seq c q n : ùîªP c -> ùîªP q -> ùîªP n -> ùîªR (fun ŒΩ => is_seq R (c ŒΩ) (q ŒΩ) (n ŒΩ)). 
m + n. Check forall n : nat, n = 2. Check 3 = 4. Theorem plus_2_2_is_4 : 2 + 2 = 4. Proof. reflexivity. Qed.Definition plus_fact : Prop := 2 + 2 = 4. Check plus_fact. Theorem plus_fact_is_true : plus_fact. Proof. reflexivity. Qed.Definition is_three (n : nat) : Prop := n = 3. Check is_three. Definition injective {A B} (f : A -> B) := forall x y : A, f x = f y -> x = y.Lemma succ_inj : injective S. Proof. intros n m H. inversion H. reflexivity. Qed.Check @eq. Example and_example : 3 + 4 = 7 /\ 2 * 2 = 4.Proof. split. - reflexivity. - reflexivity. Qed.Lemma and_intro : forall A B : Prop, A -> B -> A /\ B. Proof. intros A B HA HB. split. - apply HA. - apply HB. Qed.Example and_example' : 3 + 4 = 7 /\ 2 * 2 = 4. Proof. apply and_intro. - reflexivity. - reflexivity. Qed. Example and_exercise : forall n m : nat, n + m = 0 -> n = 0 /\ m = 0. Proof. Admitted. Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Proof. intros n m H. destruct H as [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example2' : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Proof. intros n m [Hn Hm]. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Proof. intros n m Hn Hm. rewrite Hn. rewrite Hm. reflexivity. Qed.Lemma and_example3 : forall n m : nat, n + m = 0 -> n * m = 0. Proof. intros n m H. assert (H' : n = 0 /\ m = 0). { apply and_exercise. apply H. } destruct H' as [Hn Hm]. rewrite Hn. reflexivity. Qed.Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Proof. intros P Q [HP HQ]. apply HP. Qed. Lemma proj2 : forall P Q : Prop, P /\ Q -> Q. Proof. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Proof. intros P Q [HP HQ]. split. - apply HQ. - apply HP. Qed. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. 
Require Import List Arith Omega.Require Import ILL.Definitions.Require Import utils pos vec. Require Import subcode sss mm_defs. Require Import eill eill_mm.Local Notation "P '/MM/' s ->> t" := (sss_compute (@mm_sss _) P s t) (at level 70, no associativity). Local Notation "P '/MM/' s ~~> t" := (sss_output (@mm_sss _) P s t) (at level 70, no associativity).Section MM_HALTING_EILL_PROVABILITY. Let f : MM_PROBLEM -> EILL_SEQUENT. Proof. intros (n & P & v). exact (Sig (1,P) 0, vec_map_list v (fun p : pos n => pos2nat p), 2 * n + 1). Defined. Theorem MM_HALTS_ON_ZERO_EILL_PROVABILITY : MM_HALTS_ON_ZERO ‚™Ø EILL_PROVABILITY. 
= y + z. Proof Abelian_Group.op_intro_r sum_abelian_group. Theorem sum_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Abelian_Group.op_cancel_l sum_abelian_group. Theorem sum_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Abelian_Group.op_cancel_r sum_abelian_group. Theorem sum_inv_l_uniq : forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y. Proof Abelian_Group.op_inv_l_uniq sum_abelian_group. Theorem sum_inv_r_uniq : forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y. Proof Abelian_Group.op_inv_r_uniq sum_abelian_group. Theorem sum_0_inv_l : sum_is_inv_l 0 0. Proof Abelian_Group.op_inv_0_l sum_abelian_group. Theorem sum_0_inv_r : sum_is_inv_r 0 0. Proof Abelian_Group.op_inv_0_r sum_abelian_group. Theorem sum_0_inv : sum_is_inv 0 0. Proof Abelian_Group.op_inv_0 sum_abelian_group. Theorem sum_has_inv_l_0 : sum_has_inv_l 0. Proof Abelian_Group.op_has_inv_l_0 sum_abelian_group. Theorem sum_has_inv_r_0 : sum_has_inv_r 0. Proof Abelian_Group.op_has_inv_r_0 sum_abelian_group. Theorem sum_has_inv_0 : sum_has_inv 0. Proof Abelian_Group.op_has_inv_0 sum_abelian_group. Theorem sum_inv_0_eq_0 : forall x : E, sum_is_inv x 0 -> x = 0. Proof Abelian_Group.op_inv_0_eq_0 sum_abelian_group. Theorem sum_inv_0_uniq : unique (fun x => sum_is_inv x 0) 0. Proof Abelian_Group.op_inv_0_uniq sum_abelian_group. Definition sum_neg_strong : forall x : E, { y | sum_is_inv x y } := Abelian_Group.op_neg_strong sum_abelian_group. Definition sum_neg : E -> E := Abelian_Group.op_neg sum_abelian_group.Notation "{-}" := (sum_neg) : ring_scope.Notation "- x" := (sum_neg x) : ring_scope. Definition sum_neg_def : forall x : E, sum_is_inv x (- x) := Abelian_Group.op_neg_def sum_abelian_group. Definition sum_neg_inj : is_injective E E {-} := Abelian_Group.op_neg_inj sum_abelian_group. Theorem sum_cancel_neg : forall x : E, - (- x) = x. Proof Abelian_Group.op_cancel_neg sum_abelian_group. Theorem sum_neg_onto : is_onto E E {-}. Proof Abelian_Group.op_neg_onto sum_abelian_group. Theorem sum_neg_bijective : is_bijective E E {-}. Proof Abelian_Group.op_neg_bijective sum_abelian_group. Theorem sum_neg_rev : forall x y : E, - x = y -> - y = x. Proof Abelian_Group.op_neg_rev sum_abelian_group. Theorem sum_neg_distrib_inv_l : forall x y : E, sum_is_inv_l (x + y) (- y + - x). Proof Abelian_Group.op_neg_distrib_inv_l sum_abelian_group. Theorem sum_neg_distrib_inv_r : forall x y : E, sum_is_inv_r (x + y) (- y + - x). Proof Abelian_Group.op_neg_distrib_inv_r sum_abelian_group. Theorem sum_neg_distrib_inv : forall x y : E, sum_is_inv (x + y) (- y + - x). Proof Abelian_Group.op_neg_distrib_inv sum_abelian_group. Theorem sum_neg_distrib : forall x y : E, - (x + y) = - y + - x. Proof Abelian_Group.op_neg_distrib sum_abelian_group. Theorem sum_0_neg : - 0 = 0. Proof proj2 (sum_neg_def 0) || a = 0 @a by <- sum_id_l (- 0). Theorem sum_neg_0 : forall x : E, - x = 0 -> x = 0. 
(vNum b)) (Zpred z))). unfold FtoRradix in |- *; apply maxMax; auto with zarith; unfold Zpred in |- *; auto with zarith. unfold FtoRradix, FtoR, nNormMin in |- *; simpl in |- *. pattern z at 2 in |- *; replace z with (Zsucc (Zpred z)); [ rewrite powerRZ_Zs; auto with real zarith | unfold Zsucc, Zpred in |- *; ring ]. rewrite <- Rmult_assoc. apply Rmult_le_compat_r; auto with real arith. pattern radix at 2 in |- *; rewrite <- (Zpower_nat_1 radix). rewrite <- Rmult_IZR. rewrite <- Zpower_nat_is_exp. replace (pred precision + 1) with precision. replace (INR (nat_of_P (vNum b))) with (IZR (Zpos (vNum b))). rewrite pGivesBound; auto with real. simpl; unfold IZR; rewrite <- INR_IPR; auto. generalize precisionNotZero; case precision; simpl in |- *; auto with arith. intros H'1; Contradict H'1; auto. intros; rewrite plus_comm; simpl in |- *; auto. Qed. Theorem FnormalLtFirstNormalPos : forall p : float, Fnormal p -> (0 <= p)%R -> (firstNormalPos <= p)%R. intros p H' H'0. case (Rle_or_lt firstNormalPos p); intros Lt0; auto with real. case (FnormalLtPos p firstNormalPos); auto. apply firstNormalPosNormal. intros H'1; Contradict H'1; unfold firstNormalPos in |- *; simpl in |- *. apply Zle_not_lt; auto with float. intros H'1; elim H'1; intros H'2 H'3; Contradict H'3. unfold firstNormalPos in |- *; simpl in |- *. apply Zle_not_lt. rewrite <- (Zabs_eq (Fnum p)); auto with float zarith. apply pNormal_absolu_min; auto. apply LeR0Fnum with (radix := radix); auto with arith. Qed. Theorem FnormalLtFirstNormalNeg : forall p : float, Fnormal p -> (p <= 0)%R -> (p <= Fopp firstNormalPos)%R. intros p H' H'0. rewrite <- (Ropp_involutive p); unfold FtoRradix in |- *; repeat rewrite Fopp_correct. apply Ropp_le_contravar; rewrite <- Fopp_correct. apply FnormalLtFirstNormalPos. apply FnormalFop; auto. replace 0%R with (-0)%R; unfold FtoRradix in |- *; try rewrite Fopp_correct; auto with real. Qed. Theorem FsubnormalDigit : forall p : float, Fsubnormal p -> Fdigit radix p < precision. intros p H; unfold Fdigit in |- *. case (Z_eq_dec (Fnum p) 0); intros Z1. rewrite Z1; simpl in |- *; auto with arith. apply lt_S_n; apply le_lt_n_Sm. rewrite <- digitPredVNumiSPrecision. replace (S (digit radix (Fnum p))) with (digit radix (Fnum p) + 1). rewrite <- digitAdd; auto with zarith. apply digit_monotone; auto with float. rewrite (fun x => Zabs_eq (Zpred x)); auto with float zarith. rewrite Zmult_comm; rewrite Zpower_nat_1; auto with float zarith. rewrite plus_comm; simpl in |- *; auto. Qed. Hint Resolve FsubnormalDigit: float. Theorem pSubnormal_absolu_min : forall p : float, Fsubnormal p -> (Zabs (Fnum p) < nNormMin)%Z. 
xp (Cached (dsupd_vecs ds avl)) ms' hm' >> XCRASH:hm' << F, would_recover_any: xp ds hm' -- >> \/ exists ms', << F, rep: xp (Cached (vsupd_vecs (fst (effective ds (length (MSTxns (fst ms))))) avl, nil)) ms' hm' >> >} dwrite_vecs' xp avl ms. Proof. unfold dwrite_vecs'. prestep; unfold rep; cancel. prestep; unfold rep; cancel. rewrite map_length. rewrite dsupd_vecs_nthd; cancel. rewrite effective_dsupd_vecs_comm. eapply dset_match_dsupd_vecs_nonoverlap; eauto. xcrash. or_l; xform_norm; cancel. xform_normr; cancel. erewrite dset_match_nthd_effective_fst by eauto. rewrite recover_before_any_fst by eauto; cancel. or_r; xform_norm; cancel. xform_normr; cancel. rewrite nthd_0. repeat erewrite dset_match_nthd_effective_fst by eauto. eassign (mk_mstate vmap0 nil x0_1); simpl; cancel. all: simpl; eauto. apply dset_match_nil. Qed. Hint Extern 1 ({{_}} Bind (dwrite_vecs' _ _ _) _) => apply dwrite_vecs'_ok : prog. Lemma effective_avl_addrs_ok : forall (avl : list (addr * valu)) ds ts xp, Forall (fun e => fst e < length (ds !!)) avl -> dset_match xp (effective ds (length ts)) ts -> Forall (fun e => fst e < length (nthd (length (snd ds) - length ts) ds)) avl. Proof. intros. erewrite dset_match_nthd_effective_fst by eauto. rewrite Forall_forall in *; intros. erewrite <- replay_seq_latest_length; eauto. rewrite latest_effective; eauto. unfold dset_match in *; intuition eauto. Qed. Theorem dwrite_vecs_ok: forall xp avl ms, {< F ds, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[ Forall (fun e => fst e < length (ds!!)) avl /\ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (dsupd_vecs ds avl)) ms' hm' >> XCRASH:hm' << F, would_recover_any: xp ds hm' -- >> \/ << F, would_recover_any: xp (dsupd_vecs ds avl) hm' -- >> >} dwrite_vecs xp avl ms. Proof. unfold dwrite_vecs, rep. step. prestep; unfold rep; cancel. prestep; unfold rep; safecancel. substl (MSVMap a). apply overlap_empty; apply map_empty_vmap0. eapply effective_avl_addrs_ok; eauto. auto. step. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. or_r; cancel. do 2 (xform_norm; cancel). repeat rewrite nthd_0; simpl. substl (MSTxns a); simpl. rewrite Nat.sub_0_r, <- latest_nthd. rewrite <- dsupd_vecs_latest. rewrite synced_recover_any; eauto. eassign (MSTxns a); substl (MSTxns a); simpl. unfold effective; rewrite popn_oob by omega. apply dset_match_nil. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. prestep; unfold rep; cancel. apply not_true_iff_false; auto. eapply effective_avl_addrs_ok; eauto. step. cancel. repeat xcrash_rewrite; xform_norm. or_l; cancel. xform_normr; cancel. or_r; cancel. do 2 (xform_norm; cancel). repeat rewrite nthd_0; simpl. erewrite dset_match_nthd_effective_fst by eauto. rewrite <- dsupd_vecs_fst, <- effective_dsupd_vecs_comm. rewrite MLog.synced_recover_before. rewrite recover_before_any_fst. auto. rewrite effective_dsupd_vecs_comm. eapply dset_match_dsupd_vecs_nonoverlap. apply not_true_is_false; eauto. all: eauto. Qed. Theorem dsync_vecs_ok: forall xp al ms, {< F ds, PRE:hm << F, rep: xp (Cached ds) ms hm >> * [[ Forall (fun e => e < length (ds!!)) al /\ sync_invariant F ]] POST:hm' RET:ms' << F, rep: xp (Cached (dssync_vecs ds al)) ms' hm' >> CRASH:hm' << F, would_recover_any: xp ds hm' -- >> >} dsync_vecs xp al ms. 
MAP. Definition elt := X.t. Definition elt_eq := X.eq. Definition t (A: Type) := X.t -> A. Definition init (A: Type) (v: A) := fun (_: X.t) => v. Definition get (A: Type) (x: X.t) (m: t A) := m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. Proof. intros. apply PTree.gempty. Qed. Theorem gss: forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x. Proof. intros. apply PTree.gss. Qed. Theorem gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. 
a0 (invA a0)) (invA (invA a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA A0 (invA (invA a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (invA (invA a0)) A0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. Qed. Theorem nZero_invTerm_nZero : forall a : Term, ~ zeroP a -> ~ zeroP (invTerm a). intros a H'; red in |- *; intros H'0; absurd (zeroP a); auto. apply zeroP_comp_eqTerm with (a := invTerm (invTerm a)); auto. apply zeroP_invTerm_zeroP; auto. apply eqTerm_sym; apply invTerm_invol; auto. Qed. Hint Resolve nZero_invTerm_nZero. Set Implicit Arguments. Unset Strict Implicit. Definition T1 : Term. exact (A1, M1). Defined. Set Strict Implicit. Unset Implicit Arguments. Theorem T1_nz : ~ zeroP T1. simpl in |- *; auto. apply A1_diff_A0 with (1 := cs). Qed. Theorem T1_multTerm_l : forall a b : Term, eqTerm a T1 -> eqTerm b (multTerm a b). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 H'; elim H'; intros H'0 H'1; rewrite H'1; clear H'; auto. split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA A1 a0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs). apply multA_A1_l with (1 := cs); auto. apply multA_eqA_comp with (1 := cs); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply sym_eq; unfold M1 in |- *; apply mult_mon_zero_l. Qed. Theorem T1_multTerm_r : forall a b : Term, eqTerm a T1 -> eqTerm b (multTerm b a). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0 H'; elim H'; intros H'0 H'1; rewrite H'1; clear H'. split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA a0 A1); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := multA A1 a0); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); apply multA_A1_l with (1 := cs); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply sym_eq; unfold M1 in |- *; apply mult_mon_zero_r. Qed. Theorem nZero_invTerm_T1 : ~ zeroP (invTerm T1). 
Qed.Lemma sizeof_struct_stable: forall m pos, complete_members env m = true -> sizeof_struct env' pos m = sizeof_struct env pos m. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. rewrite alignof_stable by auto. rewrite sizeof_stable by auto. rewrite IHm by auto. auto. Qed.Lemma sizeof_union_stable: forall m, complete_members env m = true -> sizeof_union env' m = sizeof_union env m. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. rewrite sizeof_stable by auto. rewrite IHm by auto. auto. Qed.Lemma sizeof_composite_stable: forall su m, complete_members env m = true -> sizeof_composite env' su m = sizeof_composite env su m. Proof. intros. destruct su; simpl. apply sizeof_struct_stable; auto. apply sizeof_union_stable; auto. Qed.Lemma complete_members_stable: forall m, complete_members env m = true -> complete_members env' m = true. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. rewrite complete_type_stable by auto. rewrite IHm by auto. auto. Qed.Lemma rank_members_stable: forall m, complete_members env m = true -> rank_members env' m = rank_members env m. Proof. induction m as [|[id t]]; simpl; intros. auto. InvBooleans. f_equal; auto. apply rank_type_stable; auto. Qed.End STABILITY.Lemma add_composite_definitions_incr: forall id co defs env1 env2, add_composite_definitions env1 defs = OK env2 -> env1!id = Some co -> env2!id = Some co. Proof. induction defs; simpl; intros. - inv H; auto. - destruct a; monadInv H. eapply IHdefs; eauto. rewrite PTree.gso; auto. red; intros; subst id0. unfold composite_of_def in EQ. rewrite H0 in EQ; discriminate. Qed.Record composite_consistent (env: composite_env) (co: composite) : Prop := { co_consistent_complete: complete_members env (co_members co) = true; co_consistent_alignof: co_alignof co = align_attr (co_attr co) (alignof_composite env (co_members co)); co_consistent_sizeof: co_sizeof co = align (sizeof_composite env (co_su co) (co_members co)) (co_alignof co); co_consistent_rank: co_rank co = rank_members env (co_members co) }.Definition composite_env_consistent (env: composite_env) : Prop := forall id co, env!id = Some co -> composite_consistent env co.Lemma composite_consistent_stable: forall (env env': composite_env) (EXTENDS: forall id co, env!id = Some co -> env'!id = Some co) co, composite_consistent env co -> composite_consistent env' co. Proof. intros. destruct H as [A B C D]. constructor. eapply complete_members_stable; eauto. symmetry; rewrite B. f_equal. apply alignof_composite_stable; auto. symmetry; rewrite C. f_equal. apply sizeof_composite_stable; auto. symmetry; rewrite D. apply rank_members_stable; auto. Qed.Lemma composite_of_def_consistent: forall env id su m a co, composite_of_def env id su m a = OK co -> composite_consistent env co. Proof. unfold composite_of_def; intros. destruct (env!id); try discriminate. destruct (complete_members env m) eqn:C; inv H. constructor; auto. Qed. Theorem build_composite_env_consistent: forall defs env, build_composite_env defs = OK env -> composite_env_consistent env. 
From Perennial.program_proof.mvcc Require Import tuple_prelude tuple_repr.Section proof. Context `{!heapGS Œ£, !mvcc_ghostG Œ£}.Definition post_tuple__Own ts key (ret : u64) Œ≥ : iProp Œ£ := match int.Z ret with | 0 => mods_token Œ≥ key ts | 200 | 400 => True | _ => False end. Theorem wp_tuple__Own tuple (tid : u64) (key : u64) (sid : u64) Œ≥ : is_tuple tuple key Œ≥ -‚àó {{{ active_tid Œ≥ tid sid }}} Tuple__Own #tuple #tid {{{ (ret : u64), RET #ret; active_tid Œ≥ tid sid ‚àó post_tuple__Own (int.nat tid) key ret Œ≥ }}}. 
H7. elim H7. intros. assumption. apply a. apply le_trans with (m := m). assumption. apply le_plus_l. apply pos_div_two'. assumption. apply pg. apply pos_div_two. assumption. Qed.Definition sup_tail_as_Cauchy := Build_CauchySeq OF (fun m : nat => sup_tail m) sup_tail_is_Cauchy.Let L := inf sup_tail_as_Cauchy. Lemma sup_tail_decrease : forall m n : nat, m <= n -> sup_tail n[<=]sup_tail m. Proof. intros. rewrite -> leEq_def; intro. case (Psup_unfolded2 (tail_seq g n) (sup_tail m)). assumption. intro xj. intros H2 H3. red in H2. case H2. intro j. intros. apply (less_irreflexive_unfolded _ xj). apply leEq_less_trans with (y := sup_tail m). apply leEq_wdl with (x := CS_seq OF (tail_seq g n) j). simpl in |- *. apply sup_tail_leEq. apply le_trans with (m := n). assumption. apply le_plus_l. apply eq_symmetric_unfolded. assumption. assumption. Qed.Lemma L_less_sup_n : forall n : nat, L[<=]sup_tail n. Proof. intros. unfold L in |- *. change (inf sup_tail_as_Cauchy[<=]CS_seq OF sup_tail_as_Cauchy n) in |- *. apply inf_geEq. Qed.Lemma Psup_unfolded2_informative : forall (h : CauchySeq OF) (b' : OF), b'[<]sup h -> {s : OF | seq2set h s | b'[<]s}. Proof. intros. apply Psup_unfolded2. assumption. Qed. Lemma Pinf_unfolded2_informative : forall (h : CauchySeq OF) (c' : OF), inf h[<]c' -> {s : OF | seq2set h s | s[<]c'}. Proof. intros. apply Pinf_unfolded2. assumption. Qed. Lemma convergent_subseq : forall k : nat, {N_k : nat | k <= N_k | AbsSmall (one_div_succ k) (g_ N_k[-]L)}. Proof. intros. case (Pinf_unfolded2_informative sup_tail_as_Cauchy (L[+]one_div_succ k)). change (L[<]L[+]one_div_succ k) in |- *. apply shift_less_plus'. rstepl ([0]:OF). apply one_div_succ_pos. intro sN. intros. red in s. case s. intro N. intros c0. case (Psup_unfolded2_informative (tail_seq g (k + N)) (L[-]one_div_succ k)). apply less_leEq_trans with (y := L). apply shift_minus_less. apply shift_less_plus'. rstepl ([0]:OF). apply one_div_succ_pos. change (L[<=]sup_tail (k + N)) in |- *. apply L_less_sup_n. intro xj. intros. case s0. intro j. intros. exists (k + N + j). apply le_trans with (m := k + N). apply le_plus_l. apply le_plus_l. split. apply shift_leEq_minus. rstepl (L[-]one_div_succ k). apply leEq_wdr with (y := xj). apply less_leEq; assumption. assumption. apply shift_minus_leEq. apply leEq_transitive with (y := sN). change (CS_seq OF (tail_seq g (k + N)) j[<=]sN) in |- *. apply leEq_transitive with (y := sup (tail_seq g (k + N))). apply sup_leEq. apply leEq_wdr with (y := sup (tail_seq g N)). change (sup_tail (k + N)[<=]sup_tail N) in |- *. apply sup_tail_decrease. apply le_plus_r. apply eq_symmetric_unfolded. assumption. apply less_leEq. astepr (L[+]one_div_succ k); auto. Qed. Theorem lubp_gives_Cauchy : SeqLimit g L. 
E -> E -> E; prod : E -> E -> E; distinct_0_1 : E_0 <> E_1; sum_is_assoc : Monoid.is_assoc E sum; sum_is_comm : Abelian_Group.is_comm E sum; sum_id_l : Monoid.is_id_l E sum E_0; sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0; prod_is_assoc : Monoid.is_assoc E prod; prod_id_l : Monoid.is_id_l E prod E_1; prod_id_r : Monoid.is_id_r E prod E_1; prod_sum_distrib_l : is_distrib_l E prod sum; prod_sum_distrib_r : is_distrib_r E prod sum }.Arguments E_0 {r}.Arguments E_1 {r}.Arguments sum {r} x y.Arguments prod {r} x y.Arguments distinct_0_1 {r} _.Arguments sum_is_assoc {r} x y z.Arguments sum_is_comm {r} x y.Arguments sum_id_l {r} x.Arguments sum_inv_l_ex {r} x.Arguments prod_is_assoc {r} x y z.Arguments prod_id_l {r} x.Arguments prod_id_r {r} x.Arguments prod_sum_distrib_l {r} x y z.Arguments prod_sum_distrib_r {r} x y z.Notation "0" := E_0 : ring_scope.Notation "1" := E_1 : ring_scope.Notation "x + y" := (sum x y) (at level 50, left associativity) : ring_scope.Notation "{+}" := sum : ring_scope.Notation "x # y" := (prod x y) (at level 50, left associativity) : ring_scope.Notation "{#}" := prod : ring_scope.Open Scope ring_scope.Section Theorems. Variable r : Ring. Let E := E r. Definition nonzero (x : E) : Prop := x <> 0. Definition sum_is_id_l := Monoid.is_id_l E sum. Definition sum_is_id_r := Monoid.is_id_r E sum. Definition sum_is_id := Monoid.is_id E sum. Definition sum_abelian_group := Abelian_Group.abelian_group E 0 {+} sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex. Definition sum_group := Abelian_Group.op_group sum_abelian_group. Definition sum_monoid := Abelian_Group.op_monoid sum_abelian_group. Theorem sum_id_r : sum_is_id_r 0. Proof Abelian_Group.op_id_r sum_abelian_group. Theorem sum_id : sum_is_id 0. Proof Abelian_Group.op_id sum_abelian_group. Definition sum_is_inv_l := Abelian_Group.op_is_inv_l sum_abelian_group. Definition sum_is_inv_r := Abelian_Group.op_is_inv_r sum_abelian_group. Definition sum_is_inv := Abelian_Group.op_is_inv sum_abelian_group. Definition sum_has_inv_l := Abelian_Group.has_inv_l sum_abelian_group. Definition sum_has_inv_r := Abelian_Group.has_inv_r sum_abelian_group. Definition sum_has_inv := Abelian_Group.has_inv sum_abelian_group. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Abelian_Group.op_inv_r_ex sum_abelian_group. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Abelian_Group.op_id_l_uniq sum_abelian_group. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Abelian_Group.op_id_r_uniq sum_abelian_group. Theorem sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Abelian_Group.op_id_uniq sum_abelian_group. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Abelian_Group.op_inv_l_r_eq sum_abelian_group. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Abelian_Group.op_inv_sym sum_abelian_group. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. 
intuition | intuition | intuition | ]. assert (b %= fold_left add l b' %+ v) by (eapply equiv_trans; [ eassumption | apply add_something ]); auto. apply add_to_del; auto. intro. apply setify_cases in H4; destruct H4; intuition. apply IHNoDup in H3; auto. intros. assert (v %in b' \/ v = x) by sets. tauto. Qed. Lemma setify_nuke : forall v ls b, NoDup ls -> In v ls -> b %= setify ls -> b %- v %= setify (nuke v ls). intros; apply setify_nuke'; auto. Qed. Theorem starS_del_fwd : forall b v, v %in b -> starS P b ===> P v * starS P (b %- v). intros; eapply Himp_trans; [ | apply exists_starR_bwd ]; cbv beta. to_himp; apply existsL; intro ls; apply existsR with (nuke v ls). specialize (starL_del_fwd v ls); generalize (starL P ls); generalize (P v); generalize (starL P (nuke v ls)). intros; from_himp. sepLemma. apply setify_nuke; eauto. transitivity (h0 * h)%Sep; eauto. sepLemma. Qed. Lemma fun_fun_fun : forall A P Q R, P * (Ex ls : A, Q ls * R ls) ===> (Ex ls : A, Q ls * (P * R ls)). sepLemma. Qed. Lemma del_to_add : forall b b' v, v %in b -> b %- v %= b' -> b %= b' %+ v. intros. assert (b %- v %+ v %= b' %+ v) by sets. clear H0. apply equiv_trans with (b %- v %+ v); auto. clear H1. unfold mem, equiv, del, add in *. intros. destruct (eq_dec v x); subst; intuition. Qed. Theorem starS_del_bwd : forall b v, v %in b -> P v * starS P (b %- v) ===> starS P b. unfold starS; intros. eapply Himp_trans; [ apply fun_fun_fun | ]; cbv beta. apply Himp'_ex; intro ls. apply Himp_ex_c; exists (v :: ls). simpl. apply Himp_star_frame; [ | apply Himp_refl ]. apply Himp_star_pure_c; intro. apply Himp_star_pure_cc. unfold setify in *; simpl. eapply equiv_trans; [ | apply equiv_symm; apply add_something ]. apply del_to_add; auto. sepLemma. constructor; auto. intro. eapply setify_include in H2; eauto. sets. Qed. Lemma star_cancel_right : forall a b c, b ===> c -> b * a ===> c * a. sepLemma. Qed. Lemma starS_equiv : forall P a b, a %= b -> starS P a ===> starS P b. intros; unfold starS; to_himp; apply existsL; intros; apply existsR with x; from_himp; eapply star_cancel_right; sepLemma. Qed. Variable P' : predS nil. Theorem starS_weaken : forall b, (forall x, x %in b -> P x ===> P' x) -> starS P b ===> starS P' b. 
rewrite HŒ≥, HŒ≥... intros y Hy. apply BUnionE in Hy as [|Hy]; [apply BUnionI1|apply BUnionI2]... apply UnionAx in Hy as [a [Ha Hy]]. apply UnionAx in Ha as [b [Hb Ha]]. apply UnionAx. exists a. split... apply UnionAx. exists b. split... apply ranE in Hb as [x Hp]. apply restrE2 in Hp as [Hp Hx]. apply (ranI _ x). apply restrI... apply segI. apply SepE in Hx as [_ Hxn]. eapply Lt_trans; eauto. apply binRelI... Qed.Lemma f_n : ‚àÄ A, ‚àÄn ‚àà œâ, (F A)[n‚Å∫] = A ‚à™ ‚ãÉ (F A)[n]. Proof with auto; try congruence. intros A n Hn. destruct (f_spec A) as [Hf [Hd HŒ≥]]. assert (Hnp: n‚Å∫ ‚àà œâ) by (apply œâ_inductive; auto). rewrite HŒ≥... apply ExtAx; intros y; split; intros Hy; (apply BUnionE in Hy as [|Hy]; [apply BUnionI1|apply BUnionI2])... - apply UnionAx in Hy as [a [Ha Hy]]. apply UnionAx in Ha as [b [Hb Ha]]. apply ranE in Hb as [c Hp]. apply restrE2 in Hp as [Hp Hc]. apply func_ap in Hp... subst. apply SepE in Hc as [_ Hc]. apply binRelE2 in Hc as [Hc [_ Hcn]]. apply UnionAx. exists a. split... apply le_iff_lt_suc in Hcn as []... apply (f_ap_preserve_lt _ c)... - apply UnionAx in Hy as [a [Ha Hy]]. apply UnionAx. exists a. split... apply UnionAx. exists ((F A)[n]). split... apply (ranI _ n). apply restrI. apply segI. apply binRelI... apply func_correct... Qed.Lemma f_inclusion : ‚àÄ A, ‚àÄn ‚àà œâ, ‚àÄa ‚àà (F A)[n], a ‚äÜ (F A)[n‚Å∫]. Proof with neauto. intros A n Hn. œâ_induction n; intros a Ha x Hx. - rewrite f_0 in Ha. rewrite f_1. apply BUnionI2. apply UnionAx. exists a. split... - rewrite f_n in Ha... rewrite f_n, f_n; [..|apply œâ_inductive]... apply BUnionE in Ha as []; apply BUnionI2. + apply UnionAx. exists a. split... apply BUnionI1... + apply UnionAx. exists a. split... apply BUnionI2... Qed.End TransitiveClosureDef.Definition TransitiveClosure := Œª A, ‚ãÉ (ran (F A)). Notation ùóßùóñ := TransitiveClosure. Theorem tc_trans : ‚àÄ A, trans (ùóßùóñ A). Proof with auto; try congruence. intros A x y Hxy Hy. destruct (f_spec A) as [Hf [Hd _]]. apply UnionAx in Hy as [a [Ha Hy]]. apply ranE in Ha as [n Hp]. apply domI in Hp as Hn. apply func_ap in Hp... subst a. apply f_inclusion in Hy... apply Hy in Hxy. apply UnionAx. exists ((F A)[n‚Å∫]). split... eapply ranI. apply func_point... rewrite Hd. apply œâ_inductive... Qed. Theorem tc_contains : ‚àÄ A, A ‚äÜ ùóßùóñ A. 
E {+}. Definition sum_is_id_r := Monoid.is_id_r E {+}. Definition sum_is_id := Monoid.is_id E {+}. Definition prod_is_id_l := Monoid.is_id_l E {#}. Definition prod_is_id_r := Monoid.is_id_r E {#}. Definition prod_is_id := Monoid.is_id E {#}. Theorem prod_id_r : prod_is_id_r 1. Proof fun x : E => eq_ind_r (fun a => a = x) (prod_id_l x) (prod_is_comm x 1). Theorem prod_sum_distrib_r : Ring.is_distrib_r E {#} {+}. Proof fun x y z : E => prod_sum_distrib_l x y z || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z || a = (y # x) + (z # x) @a by <- prod_is_comm x (y + z). Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r. Definition sum_abelian_group := Ring.sum_abelian_group ring. Definition sum_group := Ring.sum_group ring. Definition sum_monoid := Ring.sum_monoid ring. Definition prod_monoid := Ring.prod_monoid ring. Theorem distinct_1_0 : E_1 (c := r) <> E_0 (c := r). Proof fun H : E_1 = E_0 => distinct_0_1 (eq_sym H). Definition nonzero : E -> Prop := Ring.nonzero ring. Theorem sum_id_r : sum_is_id_r 0. Proof Ring.sum_id_r ring. Theorem sum_id : sum_is_id 0. Proof Ring.sum_id ring. Definition sum_is_inv_l := Ring.sum_is_inv_l ring. Definition sum_is_inv_r := Ring.sum_is_inv_r ring. Definition sum_is_inv := Ring.sum_is_inv ring. Definition sum_has_inv_l := Ring.sum_has_inv_l ring. Definition sum_has_inv_r := Ring.sum_has_inv_r ring. Definition sum_has_inv := Ring.sum_has_inv ring. Theorem sum_inv_r_ex : forall x : E, exists y : E, sum_is_inv_r x y. Proof Ring.sum_inv_r_ex ring. Theorem sum_id_l_uniq : forall x : E, Monoid.is_id_l E {+} x -> x = 0. Proof Ring.sum_id_l_uniq ring. Theorem sum_id_r_uniq : forall x : E, Monoid.is_id_r E {+} x -> x = 0. Proof Ring.sum_id_r_uniq ring. Theorem sum_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Ring.sum_id_uniq ring. Theorem sum_inv_l_r_eq : forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z. Proof Ring.sum_inv_l_r_eq ring. Theorem sum_inv_sym : forall x y : E, sum_is_inv x y <-> sum_is_inv y x. Proof Ring.sum_inv_sym ring. Theorem sum_inv_uniq : forall x y z : E, sum_is_inv x y -> sum_is_inv x z -> z = y. Proof Ring.sum_inv_uniq ring. Theorem sum_inv_ex : forall x : E, exists y : E, sum_is_inv x y. Proof Ring.sum_inv_ex ring. Theorem sum_inv_uniq_ex : forall x : E, exists! y : E, sum_is_inv x y. 
1-7: nauto. rewrite ordAdd_œâ_pow_absorption... apply ordExp_preserve_lt, suc_Œµ_lt_Œµ_suc... Qed. Lemma Œµ_square_lt_Œµ_suc : ‚àÄŒ± ‚ãµ ùêéùêç, Œµ Œ± ‚ã Œµ Œ± ‚àà Œµ Œ±‚Å∫. Proof with neauto. intros Œ± HŒ±. rewrite <- epsilon, ordExp_add, <- (epsilon Œ±‚Å∫)... apply ordExp_preserve_lt, Œµ_double_lt_Œµ_suc... Qed. Theorem Œµ_suc : ‚àÄŒ± ‚ãµ ùêéùêç, Œµ Œ±‚Å∫ = Œµ Œ± ^^·¥∏ œâ. Proof with neauto. intros Œ± HŒ±. rewrite <- Œµtœâ_normal_form... ord_ext... - apply Œµ_spec... apply Œµtœâ_is_Œµ_number... intros H. apply ReplAx in H as [x [Hx H]]. assert (Hox: x ‚ãµ ùêéùêç). apply (ord_is_ords Œ±‚Å∫)... cut (Œµ x ‚àà Œµtœâ Œ±). intros C. eapply ord_not_lt_self; revgoals... apply (FUnionI _ _ 1)... rewrite (pred 1), Œµ_tower_suc, Œµ_tower_0... eapply ord_trans_le_lt. auto. 2: apply ordExp_enlarge_r... apply ord_le_iff_lt_suc in Hx as []... left. apply Œµ_normal... right. congruence. - apply ord_le_iff_sub... intros x Hx. apply FUnionE in Hx as [n [Hn Hx]]. eapply ord_trans... clear Hx. œâ_destruct n. { rewrite Œµ_tower_0... apply Œµ_normal... } rewrite Œµ_tower_suc... rewrite <- epsilon at 1... rewrite <- (epsilon Œ±‚Å∫), ordExp_mul... apply ordExp_preserve_lt... œâ_destruct n. { rewrite Œµ_tower_0... apply Œµ_square_lt_Œµ_suc... } rewrite Œµ_tower_suc... rewrite <- epsilon at 1 2... rewrite <- (epsilon Œ±‚Å∫), ordExp_mul, ordExp_add... apply ordExp_preserve_lt... apply ordAdd_ran, ordMul_ran... œâ_induction n. + rewrite Œµ_tower_0, <- epsilon, ordExp_add, <- (epsilon Œ±‚Å∫)... rewrite ordAdd_œâ_pow_absorption... apply ordExp_preserve_lt, Œµ_double_lt_Œµ_suc... apply ordAdd_enlarge_r... + rewrite Œµ_tower_suc... rewrite <- epsilon at 1 2 3... rewrite <- (epsilon Œ±‚Å∫), ordExp_mul, ordExp_add... rewrite ordAdd_œâ_pow_absorption. 2: apply ordAdd_ran, ordMul_ran... * apply ordExp_preserve_lt... apply ordAdd_ran, ordMul_ran... * apply ordAdd_enlarge_r, ord_gt_0_neq_0... eapply ord_trans. auto. apply Œµ_has_n... apply ordMul_enlarge_r... Qed.Module Countability. Import Choice OrdinalCountability. Open Scope OrdArith_scope. Lemma œâ_tower_n_cntinf : AC_II ‚Üí ‚àÄn ‚àà œâ, |œâ ^^·¥∏ n| = ‚Ñµ‚ÇÄ. Proof with nauto. intros AC2 n Hn. œâ_induction n. rewrite ordTetL_0... rewrite ordTetL_suc, ordExp_limit... 2: apply ordTetL_is_limord_l... 2: apply œâ_tower_n_neq_nat... apply (add_one_member_to_funion 0). rewrite ordExp_0_r... apply countableI1, nat_finite... apply countable_union_of_cntinf... - exists œâ. apply ReplAx. exists 1. split. 2: rewrite ordExp_1_r... apply SepI. 2: apply SingNI... eapply ord_trans_lt_le. auto. apply embed_ran. apply œâ_tower_n_ge_œâ... - apply countableI2, eqnum_repl. + apply CardAx1. apply remove_one_member_from_cntinf, IH. + intros x1 H1 x2 H2 H. apply SepE1 in H1, H2. apply ordExp_cancel in H... 1-2: apply (ord_is_ords (œâ ^^·¥∏ m))... - intros A H. apply ReplAx in H as [Œ± [HŒ± H]]. subst. apply SepE in HŒ± as [HŒ± Hne]. apply SingNE in Hne. assert (HoŒ±: Œ± ‚ãµ ùêéùêç). apply (ord_is_ords (œâ ^^·¥∏ m))... apply ord_pow_cntinf... eapply dominate_rewrite_r. apply CardAx1. apply IH. apply dominate_sub. apply ord_lt_iff_psub... Qed. Theorem Œµ‚ÇÄ_cntinf : AC_II ‚Üí |Œµ‚ÇÄ| = ‚Ñµ‚ÇÄ. 
l1)) -> b = F x a)) in H0. eauto. intuition. unfold F_randomFunc in *. case_eq (arrayLookup_f (Bvector_EqDec b) c0 (F x d)); intuition. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. rewrite H11 in H7. repeat simp_in_support. simpl in *. remember (split c0) as z. destruct z. simpl in *. intuition. pairInv. trivial. intuition. simpl in *. intuition. trivial. assert (b0 = F x l). eapply H6. trivial. eapply H6 in H5. subst. rewrite H7. rewrite eqbBvector_complete. trivial. comp_simp. rewrite eqb_refl. simpl. eapply comp_spec_eq_refl. Qed. Theorem G2_3_4_close : | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <= Adv_WCR _ _ F (Rnd k) au_F_A. eapply leRat_trans. eapply fundamental_lemma_h. eapply G2_3_4_bad_eq . eapply G2_3_4_eq_until_bad. rewrite G2_3_bad_equiv. rewrite G2_3_bad_small. intuition. Qed. Definition G2_5 := [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil; ret b. Theorem G2_4_5_equiv : Pr[x <-$ G2_4; ret fst x] == Pr[G2_5]. unfold G2_4, G2_5. inline_first. comp_irr_l. wftac. inline_first. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a (z, (F x z)) = arrayLookup _ b z)). intuition. intuition. unfold randomFunc_mem. rewrite H0. case_eq ( arrayLookup (list_EqDec (Bvector_EqDec b)) x2 a); intuition. eapply comp_spec_ret; intuition. simpl in *. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H3. subst. rewrite eqbBvector_complete. trivial. simpl. eauto. comp_skip. apply (oneVector c). apply (oneVector c). eapply comp_spec_ret; intuition. simpl. unfold eqbPair. simpl. case_eq (eqb z a); intuition. simpl. rewrite eqb_leibniz in H5. subst. rewrite eqbBvector_complete. trivial. simpl. trivial. comp_simp. simpl in *. intuition; subst. eapply comp_spec_eq_refl. Qed. Theorem G2_5_equiv : Pr[G2_5] == Pr[G2]. unfold G2_5, G2. eapply comp_spec_eq_impl_eq. comp_skip. eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => forall z, arrayLookup _ a z = arrayLookup _ b z)). intuition. intuition. eapply randomFunc_mem_spec. intuition. simpl in *. intuition. subst. comp_simp. simpl. eapply comp_spec_eq_refl. Qed. Theorem G1_G2_equiv : | Pr[G1] - Pr[G2] | <= Adv_WCR _ _ F (Rnd k) au_F_A. rewrite G2_1_equiv. rewrite G2_1_2_equiv. rewrite G2_2_3_equiv. rewrite <- G2_5_equiv. rewrite <- G2_4_5_equiv. eapply G2_3_4_close. Qed. Theorem G2_equiv : Pr[G2] == Pr[PRF_G_B ({0, 1}^c) _ _ A]. reflexivity. Qed. Theorem hF_PRF : PRF_Advantage ({0, 1}^(c + k)) ({0, 1}^c) hF _ _ A <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A + Adv_WCR _ _ F (Rnd k) au_F_A. 
C) ), exists an a bn b c, p = ((an, a), ((bn, b), c)). Proof. intros. repeat destruct_prod. repeat eexists. Qed.Ltac destruct_varname1 := match goal with | [ H : VARNAME (_) * _ |- _ ] => let Hx := fresh in pose proof (destruct_varname1_0 H) as Hx; match type of Hx with | exists (_ : VARNAME (vn)) _, _ = _ => destruct Hx as [? [?vn Hx] ] end | [ H : VARNAME (_) * _ * _ |- _ ] => let Hx := fresh in pose proof (destruct_varname1_1 H) as Hx; match type of Hx with | exists (_ : VARNAME (vn)) _ _, _ = _ => destruct Hx as [? [?vn [? Hx] ] ] end | [ H : VARNAME (_) * _ * _ * _ |- _ ] => let Hx := fresh in pose proof (destruct_varname1_2 H) as Hx; match type of Hx with | exists (_ : VARNAME (vn)) _ _ _, _ = _ => destruct Hx as [? [?vn [? [? Hx] ] ] ] end | [ H : VARNAME (_) * _ * _ * _ * _ * _ |- _ ] => let Hx := fresh in pose proof (destruct_varname1_4 H) as Hx; match type of Hx with | exists (_ : VARNAME (vn)) _ _ _ _ _, _ = _ => destruct Hx as [? [?vn [? [? [? [? Hx] ] ] ] ] ] end | [ H : VARNAME (_) * _ * _ * _ * _ * _ * _ * _ |- _ ] => let Hx := fresh in pose proof (destruct_varname1_8 H) as Hx; match type of Hx with | exists (_ : VARNAME (vn)) _ _ _ _ _ _ _, _ = _ => destruct Hx as [? [?vn [? [? [? [? [? [? Hx] ] ] ] ] ] ] ] end end.Ltac destruct_varname2 := match goal with | [ H : VARNAME (_) * _ * ((VARNAME (_) * _) * _) |- _ ] => let Hx := fresh in pose proof (destruct_varname2 H) as Hx; match type of Hx with | exists (_ : VARNAME (vn1)) _ (_ : VARNAME (vn2)) _ _, _ = _ => destruct Hx as [? [?vn1 [? [?vn2 [? Hx] ] ] ] ] end end. Theorem destruct_varname4 : forall XN1 X1 XN2 X2 XN3 X3 XN4 X4 X5 (p : (XN1 * X1) * ((XN2 * X2) * ((XN3 * X3) * ((XN4 * X4) * X5)))), exists xn1 x1 xn2 x2 xn3 x3 xn4 x4 x5, p = ((xn1, x1), ((xn2, x2), ((xn3, x3), ((xn4, x4), x5)))). 
repnd. apply in_map_iff in Hc3. exrepnd. subst. allsimpl. dorn Hc2; sp. subst; sp. inverts HeqH99. allsimpl. pose proof (@allvars_sub_filter pp lvi lvo lv) as Halv. rewrite map_removevars_l. erewrite Hind with (p:=Halv); eauto. clear Hind. unfold lvmap_lapply. remember (free_vars nt) as fnt. pose proof (@transport _ _ _ (fun vs => subvars fnt vs) Heqfnt (subvars_refl fnt)) as Hsub. allsimpl. clear Heqfnt. repnd. induction fnt as [| vnt fnt Hfntind]; [ complete (rw remove_nvars_nil_r; refl) | simpl ]. apply subvars_cons_l in Hsub; repnd. rewrite Hfntind; auto. clear Hfntind. dest_intersect_vars. + f_equal. rewrite remove_nvars_cons_r. rewrite memvar_dmemvar. cases_if_sum Hmemdin;auto. rewrite sub_lmap_find in i. provefalse. apply disjoint_sym in Hdis3. destruct (lmap_find deq_nvar (sub_filter (var_ren lvi lvo) lv) vnt) as [ex | ?]; exrepnd; allsimpl; [ | rw intersect_single_l in i; sp]. subst. apply in_sub_filter in ex0; repnd. rewrite get_sub_dom_vars_ren in Hdis3; auto. clear Hdis Hdis1 Hdis2 Hdis4 Hdis0 Halv. apply in_combine in ex1. repnd. apply in_map_iff in ex1. exrepnd. subst; allsimpl. rw intersect_single_l in i. apply Hdis3 in i; sp. + rewrite remove_nvars_cons_r. rewrite memvar_dmemvar. cases_if_sum Hmemdin; auto. * provefalse. rewrite sub_lmap_find in d. destruct (lmap_find deq_nvar (sub_filter (var_ren lvi lvo) lv) vnt) as [ex | ?]; exrepnd; allsimpl. subst. apply in_sub_filter in ex0; repnd. apply in_combine in ex1. repnd. sp. rw disjoint_singleton_l in d; sp. * simpl. f_equal. rewrite sub_find_sub_filter_eta; auto. + clear Hfntind. rewrite get_sub_dom_vars_ren; auto. rewrite get_sub_dom_vars_ren in Hdis4; auto. rewrite remove_nvars_cons_r in Hdis4. revert Hdis4. cases_if; auto. rw disjoint_cons_r; sp. + remember ((sub_filter (var_ren lvi lvo) lv)) as Hsb. pose proof (get_sub_dom_vars_eta Hsb Halv) as ex. exrepnd. revert Halv. rewrite ex0. intro. rewrite ex0 in HeqHsb. rewrite get_sub_dom_vars_ren; auto. rewrite get_sub_dom_vars_ren in Hnr; auto. apply no_repeats_sub_filter in HeqHsb; trivial. + remember ((sub_filter (var_ren lvi lvo) lv)) as Hsb. pose proof (get_sub_dom_vars_eta Hsb Halv) as ex. exrepnd. revert Halv. rewrite ex0. intro. rewrite ex0 in HeqHsb. rewrite get_sub_dom_vars_ren; auto. rewrite get_sub_dom_vars_ren in Hdis2; auto. rewrite get_sub_dom_vars_ren in Hdis4; auto. rewrite get_sub_dom_vars_ren in Hdis3; auto. clear Hdis Hdis1 Hdis0 . assert (disjoint lvo (all_vars nt)) as Hvo. * apply disjoint_app_r. split; auto. introv Hin Hc. applydup Hdis4 in Hin. apply Hin0. apply in_remove_nvars. split; auto. * introv Hin Hc. apply (@lin_lift_vterm pp) in Hin. apply combine_in_right with (l1:=lvi0) in Hin. exrepnd. unfold var_ren in HeqHsb. rewrite HeqHsb in Hin0. apply in_sub_filter in Hin0. repnd. apply in_combine in Hin1. repnd. apply lin_lift_vterm in Hin1. apply Hvo in Hin1. sp. rewrite map_length. omega. Qed. Theorem no_repeats_subvars : forall lvi lvo, no_repeats lvi -> subvars lvo lvi -> no_repeats lvo. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. From Categories Require Import Ext_Cons.Prod_Cat.Prod_Cat Ext_Cons.Prod_Cat.Operations. From Categories Require Import Functor.Main. From Categories Require Import Functor.Representable.Hom_Func Functor.Representable.Hom_Func_Prop. From Categories Require Import NatTrans.Main.Local Open Scope functor_scope. Local Notation NID := NatTrans_id (only parsing). Local Notation FCAT := Func_Cat (only parsing). Notation Hom_Adj_Left C D F G := ((Hom_Func D) ‚àò (Prod_Functor (F^op) (@Functor_id D)))%functor (only parsing). Notation Hom_Adj_Right C D F G := ((Hom_Func C) ‚àò (Prod_Functor (@Functor_id (C^op)) G))%functor (only parsing).Local Obligation Tactic := idtac.Section Adjunction. Context {C D : Category} (F : C --> D) (G : D --> C). Record Adjunct : Type := { adj_unit : ((Functor_id C) --> (G ‚àò F))%nattrans; adj_morph_ex {c : C} {d : D} (f : (c --> (G _o d)%object)%morphism) : ((F _o c)%object --> d)%morphism; adj_morph_com {c : C} {d : D} (f : (c --> (G _o d))%morphism%object) : f = ((G _a (adj_morph_ex f)) ‚àò (Trans adj_unit c))%morphism; adj_morph_unique {c : C} {d : D} (f : (c --> (G _o d))%object%morphism) (g h : ((F _o c) --> d)%morphism%object) : f = ((G _a g) ‚àò (Trans adj_unit c))%morphism ‚Üí f = ((G _a h) ‚àò (Trans adj_unit c))%morphism ‚Üí g = h }. Arguments adj_unit : clear implicits. Arguments adj_morph_ex _ {_ _} _. Arguments adj_morph_com _ {_ _} _. Arguments adj_morph_unique _ {_ _} _ _ _ _ _. Theorem Adjunct_eq_simplify (adj adj' : Adjunct) : adj_unit adj = @adj_unit adj' ‚Üí @adj_morph_ex adj = @adj_morph_ex adj' ‚Üí adj = adj'. 
simpl; simpl in H; try congruence. rewrite (IHi m2 v H); congruence. rewrite (IHi m1 v H); congruence. Qed. Theorem set2: forall (A: Type) (i: elt) (m: t A) (v1 v2: A), set i v2 (set i v1 m) = set i v2 m. Proof. induction i; intros; destruct m; simpl; try (rewrite IHi); auto. Qed. Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf. Proof. destruct i; simpl; auto. Qed. Theorem grs: forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None. Proof. induction i; destruct m. simpl; auto. destruct m1; destruct o; destruct m2 as [ | ll oo rr]; simpl; auto. rewrite (rleaf A i); auto. cut (get i (remove i (Node ll oo rr)) = None). destruct (remove i (Node ll oo rr)); auto; apply IHi. apply IHi. simpl; auto. destruct m1 as [ | ll oo rr]; destruct o; destruct m2; simpl; auto. rewrite (rleaf A i); auto. cut (get i (remove i (Node ll oo rr)) = None). destruct (remove i (Node ll oo rr)); auto; apply IHi. apply IHi. simpl; auto. destruct m1; destruct m2; simpl; auto. Qed. Theorem gro: forall (A: Type) (i j: positive) (m: t A), i <> j -> get i (remove j m) = get i m. Proof. induction i; intros; destruct j; destruct m; try rewrite (rleaf A (xI j)); try rewrite (rleaf A (xO j)); try rewrite (rleaf A 1); auto; destruct m1; destruct o; destruct m2; simpl; try apply IHi; try congruence; try rewrite (rleaf A j); auto; try rewrite (gleaf A i); auto. cut (get i (remove j (Node m2_1 o m2_2)) = get i (Node m2_1 o m2_2)); [ destruct (remove j (Node m2_1 o m2_2)); try rewrite (gleaf A i); auto | apply IHi; congruence ]. destruct (remove j (Node m1_1 o0 m1_2)); simpl; try rewrite (gleaf A i); auto. destruct (remove j (Node m2_1 o m2_2)); simpl; try rewrite (gleaf A i); auto. cut (get i (remove j (Node m1_1 o0 m1_2)) = get i (Node m1_1 o0 m1_2)); [ destruct (remove j (Node m1_1 o0 m1_2)); try rewrite (gleaf A i); auto | apply IHi; congruence ]. destruct (remove j (Node m2_1 o m2_2)); simpl; try rewrite (gleaf A i); auto. destruct (remove j (Node m1_1 o0 m1_2)); simpl; try rewrite (gleaf A i); auto. Qed. Theorem grspec: forall (A: Type) (i j: elt) (m: t A), get i (remove j m) = if elt_eq i j then None else get i m. 
H'; case H'; auto. Defined. Let gm : mon n * bool -> mon n. intros H'; case H'; auto. Defined. Definition mk_clean : forall a b : mon n, {c : mon n * bool | c = div_mon_clean n a b}. intros a b; exists (div_mon_clean n a b); auto. Qed. Theorem divTerm_dec : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, {eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)} + {~ eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b)}. intros a b; case a; case b; simpl in |- *; auto. intros b2 c2 b3 c3. intros Zp1 Zp2. case (mk_clean c3 c2). intros x; case x. intros c b4; case b4. intros H0; left; simpl in |- *; auto. generalize (div_clean_dec1 n c3 c2); rewrite <- H0; simpl in |- *; auto. intros H1; case H1; auto; intros H2 H3; split; auto. apply divA_is_multA with (1 := cs); auto. intros H0; right; red in |- *; intros dviP_H; inversion dviP_H. generalize (div_clean_dec2 n c3 c2); simpl in |- *; auto. intros H'; lapply H'; [ intros H'0; apply H'0; clear H' | clear H' ]. rewrite <- H1; auto. rewrite <- H0; simpl in |- *; auto. Qed. Theorem zeroP_divTerm : forall a b : Term A n, zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, zeroP (A:=A) A0 eqA (n:=n) (divTerm a nZb). intros a b; case a; case b; simpl in |- *; auto. intros d H' A0' H'0 H'1 nZd; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := divA A0 d nZd); auto. apply divA_A0_l with (1 := cs). Qed. Theorem divTerm_on_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqTerm (A:=A) eqA (n:=n) a (multTerm (A:=A) multA (n:=n) (divTerm a nZb) b). intros a b; case a; case b; unfold eqT in |- *; simpl in |- *; auto. intros d c A0' c0 H' H'0 H'1; rewrite <- H'1. split; auto. apply divA_is_multA with (1 := cs); auto. rewrite mult_div_id; auto. rewrite mult_mon_zero_l; auto. Qed. Theorem divTerm_on_eqT_eqT : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> forall nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b, eqT a b -> eqT (divTerm a nZb) (T1 A1 n). 
list_norepet (xkeys m i). Proof. intros A; induction m using tree_ind; intros. - constructor. - assert (NOTIN1: ~ In (prev i) (xkeys l (xO i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (NOTIN2: ~ In (prev i) (xkeys r (xI i))). { red; intros. exploit in_xkeys; eauto. intros (j & EQ). rewrite prev_append_prev in EQ. simpl in EQ. apply prev_append_inj in EQ. discriminate. } assert (DISJ: forall x, In x (xkeys l (xO i)) -> In x (xkeys r (xI i)) -> False). { intros. exploit in_xkeys. eexact H0. intros (j1 & EQ1). exploit in_xkeys. eexact H1. intros (j2 & EQ2). rewrite prev_append_prev in *. simpl in *. rewrite EQ2 in EQ1. apply prev_append_inj in EQ1. discriminate. } rewrite xkeys_Node. apply list_norepet_append. auto. destruct o; simpl; auto. constructor; auto. red; intros. red; intros; subst y. destruct o; simpl in H1. destruct H1. subst x. tauto. eauto. eauto. Qed. Theorem elements_keys_norepet: forall A (m: t A), list_norepet (List.map (@fst elt A) (elements m)). Proof. intros. apply (xelements_keys_norepet m xH). Qed. Remark xelements_empty: forall A (m: t A) i, (forall i, get i m = None) -> xelements m i = nil. Proof. intros. replace m with (@Empty A). auto. apply extensionality; intros. symmetry; auto. Qed. Theorem elements_canonical_order': forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i, option_rel R (get i m) (get i n)) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). Proof. intros until n. change (elements m) with (xelements m xH). change (elements n) with (xelements n xH). generalize 1%positive. revert m n. induction m using tree_ind; [ | induction n using tree_ind]; intros until p; intros REL. - replace n with (@Empty B). constructor. apply extensionality; intros. specialize (REL i). simpl in *. inv REL; auto. - replace (Node l o r) with (@Empty A). constructor. apply extensionality; intros. specialize (REL i). simpl in *. inv REL; auto. - rewrite ! xelements_Node. repeat apply list_forall2_app. + apply IHm. intros. specialize (REL (xO i)). rewrite ! gNode in REL; auto. + specialize (REL xH). rewrite ! gNode in REL. inv REL; constructor; auto using list_forall2_nil. + apply IHm0. intros. specialize (REL (xI i)). rewrite ! gNode in REL; auto. Qed. Theorem elements_canonical_order: forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B), (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) -> (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) -> list_forall2 (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y)) (elements m) (elements n). 
: _ , paths ( g ( f w ) ) w ) . intro . apply ( invmaponpathsincl _ ( isinclpr1weq _ _ ) ) . apply funextfun . intro x . unfold f. unfold g . unfold invweq . simpl . unfold invmap . simpl . apply idpath . assert ( efg : forall w : _ , paths ( f ( g w ) ) w ) . intro . apply ( invmaponpathsincl _ ( isinclpr1weq _ _ ) ) . apply funextfun . intro x . unfold f. unfold g . unfold invweq . simpl . unfold invmap . simpl . apply idpath . apply ( gradth _ _ egf efg ) . Defined . Theorem isofhlevelsnweqtohlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq X Y ) . Proof . intros . apply ( isofhlevelsninclb n _ ( isinclpr1weq _ _ ) ) . apply impred . intro . apply is . Defined . Theorem isofhlevelsnweqfromhlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq Y X ) . Proof. intros . apply ( isofhlevelweqf ( S n ) ( weqinvweq X Y ) ( isofhlevelsnweqtohlevelsn n X Y is ) ) . Defined . Theorem isapropweqtocontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqfromcontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqtoprop ( X Y : UU ) ( is : isaprop Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ is ) . Defined . Theorem isapropweqfromprop ( X Y : UU )( is : isaprop Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ is ) . Defined . Theorem isasetweqtoset ( X Y : UU ) ( is : isaset Y ) : isaset ( weq X Y ) . 
machine. Variables pc state : Type. Inductive subs : list Type -> Type := | SNil : subs nil | SCons : forall T Ts, (last (T :: Ts) -> PropX pc state) -> subs (eatLast (T :: Ts)) -> subs (T :: Ts). Fixpoint SPush G T (s : subs G) (f : T -> PropX pc state) : subs (T :: G) := match s in subs G return subs (T :: G) with | SNil => SCons _ nil f SNil | SCons T' Ts f' s' => SCons T (T' :: Ts) f' (SPush s' f) end. Fixpoint SHead G (s : subs G) : hd (Empty_set : Type) G -> PropX pc state:= match s in subs G return hd (Empty_set : Type) G -> PropX pc state with | SNil => fun x => match x with end | SCons T G' f s' => match G' return (last (T :: G') -> _) -> (hd (Empty_set : Type) (eatLast (T :: G')) -> PropX pc state) -> (T -> PropX pc state) with | nil => fun f _ => f | _ :: _ => fun _ SHead_s' => SHead_s' end f (SHead s') end. Fixpoint STail G (s : subs G) : subs (tl G) := match s in subs G return subs (tl G) with | SNil => SNil | SCons T G' f s' => match G' return (last (T :: G') -> _) -> subs (tl (eatLast (T :: G'))) -> subs G' with | nil => fun _ _ => SNil | T' :: G'' => fun f STail_s' => SCons T' G'' f STail_s' end f (STail s') end. Fixpoint Substs G (s : subs G) : propX pc state G -> PropX pc state := match s in subs G return propX pc state G -> PropX pc state with | SNil => fun p => p | SCons _ _ f s' => fun p => Substs s' (subst p f) end. Section specs. Variable specs : codeSpec pc state. Section weaken. Hint Constructors valid. Hint Extern 1 (In _ _) => simpl; tauto. Hint Extern 3 (incl _ _) => let x := fresh "x" in intro x; repeat match goal with | [ H : incl _ _ |- _ ] => generalize (H x); clear H end; simpl; intuition (subst; assumption). Theorem incl_cons : forall A x (G G' : list A), incl G G' -> incl (x :: G) (x :: G'). 
set f := truncC _. set eta := 'chi_c0 => co_e_f etaNth muNlam; have [sNG nNG] := andP nsNG. have fE: f%:R = theta 1%g by rewrite truncCK ?Cnat_irr1. pose nu := cfDet eta; have lin_nu: nu \is a linear_char := cfDet_lin_char _. have nuNlam: 'Res nu = lambda by rewrite -cfDetRes ?irr_char ?etaNth. have lin_lam: lambda \is a linear_char := cfDet_lin_char _. have lin_mu: mu \is a linear_char. by have:= lin_lam; rewrite -muNlam; apply: cfRes_lin_lin; apply: irr_char. have [Unu Ulam] := (lin_char_unitr lin_nu, lin_char_unitr lin_lam). pose alpha := mu / nu. have alphaN_1: 'Res[N] alpha = 1 by rewrite rmorph_div //= muNlam nuNlam divrr. have lin_alpha: alpha \is a linear_char by apply: rpred_div. have alpha_e: alpha ^+ e = 1. have kerNalpha: N \subset cfker alpha. by rewrite -subsetIidl -cfker_Res ?lin_charW // alphaN_1 cfker_cfun1. apply/eqP; rewrite -(cfQuoK nsNG kerNalpha) -rmorphX cfMod_eq1 //. rewrite -dvdn_cforder /e -card_quotient //. by rewrite cforder_lin_char_dvdG ?cfQuo_lin_char. have det_alphaXeta b: cfDet (alpha ^+ b * eta) = alpha ^+ (b * f) * nu. by rewrite cfDet_mul_lin ?rpredX ?irr_char // -exprM -(cfRes1 N) etaNth. have [b bf_mod_e]: exists b, b * f = 1 %[mod e]. rewrite -(chinese_modl co_e_f 1 0) /chinese !mul0n addn0 !mul1n mulnC. by exists (egcdn f e).1. have alpha_bf: alpha ^+ (b * f) = alpha. by rewrite -(expr_mod _ alpha_e) bf_mod_e expr_mod. have /irrP[c Dc]: alpha ^+ b * eta \in irr G. by rewrite mul_lin_irr ?rpredX ?mem_irr. have chiN: 'Res 'chi_c = theta. by rewrite -Dc rmorphM rmorphX /= alphaN_1 expr1n mul1r. have det_chi: cfDet 'chi_c = mu by rewrite -Dc det_alphaXeta alpha_bf divrK. exists c => // c2 c2Nth det_c2_mu; apply: irr_inj. have [irrMc _ imMc _] := constt_Ind_ext nsNG chiN. have /codomP[s2 Dc2]: c2 \in codom (@mul_mod_Iirr G N c). by rewrite -imMc constt_Ind_Res c2Nth constt_irr ?inE. have{Dc2} Dc2: 'chi_c2 = ('chi_s2 %% N)%CF * 'chi_c. by rewrite Dc2 cfIirrE // mod_IirrE. have s2_lin: 'chi_s2 \is a linear_char. rewrite qualifE irr_char; apply/eqP/(mulIf (irr1_neq0 c)). rewrite mul1r -[in rhs in _ = rhs](cfRes1 N) chiN -c2Nth cfRes1. by rewrite Dc2 cfunE cfMod1. have s2Xf_1: 'chi_s2 ^+ f = 1. apply/(can_inj (cfModK nsNG))/(mulIr (lin_char_unitr lin_mu))/esym. rewrite rmorph1 rmorphX /= mul1r -{1}det_c2_mu Dc2 -det_chi. by rewrite cfDet_mul_lin ?cfMod_lin_char ?irr_char // -(cfRes1 N) chiN. suffices /eqP s2_1: 'chi_s2 == 1 by rewrite Dc2 s2_1 rmorph1 mul1r. rewrite -['chi_s2]expr1 -dvdn_cforder -(eqnP co_e_f) dvdn_gcd. by rewrite /e -card_quotient ?cforder_lin_char_dvdG //= dvdn_cforder s2Xf_1. Qed. Theorem solvable_irr_extendible_from_det G N s (theta := 'chi[N]_s) : N <| G -> solvable (G / N) -> G \subset 'I[theta] -> coprime #|G : N| (truncC (theta 1%g)) -> [exists c, 'Res 'chi[G]_c == theta] = [exists u, 'Res 'chi[G]_u == cfDet theta]. 
p * m)%R -> (n <= m)%R. intros n m p H H1; case (Rle_or_lt n m); auto; intros H2. absurd (p * n <= p * m)%R; auto with real. apply Rlt_not_le; apply Rmult_lt_compat_l; auto. Qed.Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R. intros n m p H H1; case (Rle_or_lt m n); auto; intros H2. absurd (p * n <= p * m)%R; auto with real. apply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto. Qed.Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R. intros n m p H H1; case (Rle_or_lt m n); auto; intros H2. absurd (p * n < p * m)%R; auto with real. apply Rle_not_lt; apply Rmult_le_compat_l; auto with real. Qed.Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R. intros n m p H H1; case (Rle_or_lt n m); auto; intros H2. absurd (p * n < p * m)%R; auto with real. apply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real. Qed.Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real. Qed.Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R. intros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R. intros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real. Qed.Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R. intros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real. Qed.Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). 
currentTerm st /\ type st' = type st) \/ currentTerm st' = S (currentTerm st). Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma handleClientRequest_candidate : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = Candidate -> st' = st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_candidate : forall st h os st' ms, doLeader st h = (os, st', ms) -> type st' = Candidate -> st' = st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; congruence. Qed. Lemma doLeader_term_votedFor : forall st h os st' ms, doLeader st h = (os, st', ms) -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. unfold doLeader, advanceCommitIndex in *. intros. repeat break_match; find_inversion; simpl in *; intuition. Qed. Lemma doGenericServer_log_type_term_votesReceived : forall h st os st' ps, doGenericServer h st = (os, st', ps) -> log st' = log st /\ type st' = type st /\ currentTerm st' = currentTerm st /\ votesReceived st' = votesReceived st /\ votedFor st' = votedFor st. Proof using. intros. unfold doGenericServer in *. repeat break_match; find_inversion; use_applyEntries_spec; simpl in *; subst; auto. Qed. Lemma handleClientRequest_term_votedFor : forall h st client id c os st' m, handleClientRequest h st client id c = (os, st', m) -> type st' = type st /\ currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleClientRequest in *. repeat break_match; find_inversion; simpl in *; intuition. Qed. Theorem handleAppendEntries_term_votedFor : forall h st t n pli plt es ci st' ps h', handleAppendEntries h st t n pli plt es ci = (st', ps) -> votedFor st' = Some h' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleAppendEntries, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto; congruence. Qed. Theorem handleAppendEntriesReply_term_votedFor : forall h st n t es r st' ps h', handleAppendEntriesReply h st n t es r = (st', ps) -> votedFor st' = Some h' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. Proof using. intros. unfold handleAppendEntriesReply, advanceCurrentTerm in *. repeat break_match; find_inversion; simpl in *; auto; congruence. Qed. Theorem handleRequestVoteReply_term_votedFor : forall h st t h' h'' r st', handleRequestVoteReply h st h' t r = st' -> votedFor st' = Some h'' -> currentTerm st' = currentTerm st /\ votedFor st' = votedFor st. 
Require Import Coq.Logic.FunctionalExtensionality. Require Import Monads.Monad. Require Import Tactics.CpdtTactics.Set Implicit Arguments. Module Type State <: Monad. Parameter S : Type. Definition m (A : Type) := S -> prod A S. Definition ret {A : Type} (a : A) := fun (s : S) => (a, s). Definition bind {A B : Type} (n : S -> prod A S) (f : A -> (S -> prod B S)) := fun (s : S) => let (r, s') := n s in f r s'. Infix ">>=" := bind (at level 50, left associativity). Ltac nake := unfold m; unfold ret; unfold bind. Theorem left_id : forall (A B : Type) (x : A) (f : A -> m B), ret x >>= f = f x. Proof. nake. crush. Qed. Theorem right_id : forall (A : Type) (x : m A), x >>= ret = x. 
lenv' xs vs7 -> (forall x, List.In x xs -> ~ (is_protected_tinfo_id x \/ x = tinfIdent)) -> protected_not_in_L lenv' L. Proof. intros. inv H; destructAll. exists x, x0, x1, x2, x3, x4, x5. repeat split; auto; try (eapply lenv_param_asgn_not_in with (L := fun x => (is_protected_tinfo_id x \/ x = tinfIdent)); eauto). left; inList. left; inList. left; inList. reflexivity. eapply H8; eauto. eapply H8; eauto. eapply H8; eauto. Qed. Definition Vint_or_Vconstr (v:cps.val): Prop := (exists i, v = cps.Vint i) \/ (exists c vs, v = cps.Vconstr c vs).Definition correct_fundef_id_info (m:mem) (fds:fundefs) (f:positive) := exists finfo t t' vs e, (find_def f fds = Some (t, vs, e) /\ M.get f finfo_env = Some (finfo , t') /\ t = t' /\ correct_fundef_info m f t vs e finfo). Definition rel_mem_L6_L7: exp -> L6.eval.env -> mem -> temp_env -> Prop := fun e rho m le => exists L, protected_not_in_L le L /\ (forall x, (occurs_free e x -> exists v6, M.get x rho = Some v6 /\ repr_val_id_L_L6_L7 v6 m L le x) /\ (forall rho' fds f v, M.get x rho = Some v -> subval_or_eq (Vfun rho' fds f) v -> repr_val_id_L_L6_L7 (Vfun rho' fds f) m L le f /\ closed_val (Vfun rho' fds f) /\ correct_fundef_id_info m fds f)). Definition unchanged_globals: mem -> mem -> Prop := fun m m' => forall x b, Genv.find_symbol (globalenv p) x = Some b -> forall i chunk, Mem.loadv chunk m (Vptr b i) = Mem.loadv chunk m' (Vptr b i).Theorem unchanged_globals_trans: forall m1 m2 m3, unchanged_globals m1 m2 -> unchanged_globals m2 m3 -> unchanged_globals m1 m3. Proof. intros. intro; intros. specialize (H _ _ H1 i chunk). specialize (H0 _ _ H1 i chunk). rewrite H; rewrite H0. reflexivity. Qed.Theorem correct_fundefs_unchanged_global: forall m m' fds f, correct_fundef_id_info m fds f -> unchanged_globals m m' -> correct_fundef_id_info m' fds f. Proof. intros. destruct H as [finfo [t [t' [vs [e H]]]]]. exists finfo, t, t', vs, e. destruct H. destruct H1. destruct H2. split; auto. split; auto. split; auto. destruct H3 as [n [l [b [fi_0 [fi_1 H3]]]]]. exists n, l, b, fi_0. destructAll. repeat split; auto. specialize (H0 finfo b); rewrite <- H0; auto. specialize (H0 finfo b); rewrite <- H0; auto. intros. apply H12 in H2. destruct H2 as [li H2]. exists li. destructAll. split; auto. specialize (H0 finfo b); rewrite <- H0; auto. Qed. Theorem store_globals_unchanged: forall b' i m m' a, Mem.store int_chunk m b' i a = Some m' -> (forall (x : ident) (b : block), Genv.find_symbol (globalenv p) x = Some b -> b <> b') -> unchanged_globals m m'. 
e sub). Proof. unfold map_get_r; intros. destruct (var_dec v x). + subst. rewrite M.gss. rewrite M.gss. reflexivity. + rewrite M.gso. rewrite M.gro. rewrite M.gso. reflexivity. assumption. assumption. assumption. Qed.Theorem proper_remove: forall t v, Proper (map_get_r t ==> map_get_r t) (M.remove v). Proof. intros t v r. unfold map_get_r; intros. destruct (var_dec v0 v). - subst. rewrite 2 M.grs. reflexivity. - rewrite 2 M.gro. apply H. assumption. assumption. Qed.Theorem proper_set: forall t v e, Proper (map_get_r t ==> map_get_r t) (M.set v e). Proof. intros t v e r. unfold map_get_r; intros. destruct (var_dec v0 v). - subst. rewrite 2 M.gss. reflexivity. - rewrite 2 M.gso. apply H. assumption. assumption. Qed.End EQMAP. Section GETD. Definition getd {A:Type} (d:A) := fun v sub => match M.get v sub with | None => d | Some e => e end. Theorem e_getd: forall A (d:A) v sub, exists e, getd d v sub = e. Proof. unfold getd; intros; destruct (M.get v sub); [ exists a; reflexivity | exists d; reflexivity]. Qed. Theorem getd_det: forall A v (a1 a2 d:A) sub, getd d v sub = a1 -> getd d v sub = a2 -> a1 = a2. Proof. unfold getd; intros; destruct (M.get v sub); subst; trivial. Qed. Theorem gdss: forall A (d:A) x c v, getd d x (M.set x v c) = v. Proof. intros. unfold getd. rewrite M.gss. reflexivity. Qed. Theorem gdso: forall A (d:A) x x' c v, x <> x' -> getd d x (M.set x' v c) = getd d x c. Proof. unfold getd. intros. rewrite M.gso. reflexivity. assumption. Qed. Theorem gdempty: forall A (d:A) x, getd d x (M.empty A) = d. Proof. unfold getd. symmetry. rewrite M.gempty. reflexivity. Qed. End GETD. Section EQDMAP. Definition map_getd_r: forall t d, relation (M.t t) := fun t d => fun sub sub' => forall v, getd d v sub = getd d v sub'. Theorem smgd_refl: forall t d, Reflexive (map_getd_r t d). Proof. do 4 intro; reflexivity. Qed. Theorem smgd_sym: forall t d, Symmetric (map_getd_r t d). Proof. do 6 intro; auto. Qed. Theorem smgd_trans: forall t d, Transitive (map_getd_r t d). Proof. intros t d sub sub' sub''; unfold map_get_r; intros; intro; specialize (H v); specialize (H0 v); rewrite H; assumption. Qed. Instance map_getd_r_equiv : forall t d, Equivalence (map_getd_r t d). Proof. intro. split; [apply smgd_refl | apply smgd_sym | apply smgd_trans]. Qed. Theorem remove_empty_d: forall t d x, map_getd_r t d (M.remove x (M.empty t)) (M.empty t). 
apply Rlt_sign_pos_pos_rev with x; auto with real. Qed.Theorem Rgt_sign_neg_neg_rev: forall x y: R, (0 > x -> x * y > 0-> 0 > y)%R. intros x y H1 H2; red; apply Rlt_sign_neg_neg_rev with x; auto with real. Qed.Theorem Rgt_sign_pos_neg_rev: forall x y: R, (x > 0 -> 0 > x * y -> 0 > y)%R. intros x y H1 H2; red; apply Rlt_sign_pos_neg_rev with x; auto with real. Qed.Theorem Rgt_sign_neg_pos_rev: forall x y: R, (0 > x -> 0 > x * y -> y > 0)%R. intros x y H1 H2; red; apply Rlt_sign_neg_pos_rev with x; auto with real. Qed.Theorem Rmult_le_compat_l: forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R. auto with real. Qed.Theorem Rmult_le_neg_compat_l: forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R. intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring. replace (p * m)%R with (-(-p * m))%R; auto with real; try ring. Qed.Theorem Ropp_lt: forall n m, (m < n -> -n < -m)%R. auto with real. Qed.Theorem Rmult_lt_neg_compat_l: forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R. intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring. replace (p * m)%R with (-(-p * m))%R; auto with real; try ring. Qed.Theorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R. auto with real. Qed.Theorem Rmult_ge_compat_l: forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R. intros n m p H H1; apply Rle_ge; auto with real. Qed.Theorem Rmult_ge_neg_compat_l: forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R. intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring. replace (p * m)%R with (-(-p * m))%R; auto with real;try ring. Qed.Theorem Ropp_gt: forall n m, (m > n -> -n > -m)%R. auto with real. Qed.Theorem Rmult_gt_compat_l: forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R. unfold Rgt; auto with real. Qed. Theorem Rmult_gt_neg_compat_l: forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Basics.Theorem plus_n_O_firsttry : forall n:nat, n = n + 0. Admitted. Theorem minus_diag : forall n, minus n n = 0. Admitted. Theorem mult_0_r : forall n:nat, n * 0 = 0. Admitted. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Admitted. Theorem plus_comm : forall n m : nat, n + m = m + n. Admitted. Theorem plus_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Fixpoint double (n:nat) := match n with | O => O | S n' => S (S (double n')) end.Lemma double_plus : forall n, double n = n + n . Admitted. Theorem evenb_S : forall n : nat, evenb (S n) = negb (evenb n). Admitted. Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m. Admitted. Theorem plus_rearrange : forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Admitted. Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Admitted. Theorem plus_swap : forall n m p : nat, n + (m + p) = m + (n + p). Admitted. Theorem mult_comm : forall m n : nat, m * n = n * m. Admitted. Theorem leb_refl : forall n:nat, true = leb n n. 
Set Warnings "-extraction-opaque-accessed,-extraction". Set Warnings "-notation-overridden,-parsing".Require Import String List. Open Scope string.From QuickChick Require Import QuickChick Tactics. From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq. Import QcDefaultNotation. Open Scope qc_scope.Set Bullet Behavior "Strict Subproofs".Require Export Tactics.Example and_exercise : forall n m : nat, n + m = 0 -> n = 0 /\ m = 0. Admitted. Instance testSuchThat_Conj {A B : Type} (P : A -> Prop) (Q : B -> Prop) (prop : A -> B -> Prop) `{Checkable (forall a, P a -> forall b, Q b -> prop a b)} : Checkable (forall a b, P a /\ Q b -> prop a b) := {| checker f := checker (fun a P b Q => f a b _ ) |}. Proof. split; auto. Defined.Lemma and_example2 : forall n m : nat, n = 0 /\ m = 0 -> n + m = 0. Admitted. Lemma and_example2'' : forall n m : nat, n = 0 -> m = 0 -> n + m = 0. Admitted. Lemma proj1 : forall P Q : Prop, P /\ Q -> P. Admitted. Theorem and_commut : forall P Q : Prop, P /\ Q -> Q /\ P. Admitted. Theorem and_assoc : forall P Q R : Prop, P /\ (Q /\ R) -> (P /\ Q) /\ R. 
+ {(forall l : list bool, ~ In (a, l) c)}. intros c a; elim c; simpl in |- *; auto. intros (a1, l1) l H; case (eqA_dec a1 a); intros H1. left; exists l1; rewrite H1; auto. case H. intros e; left; case e; intros l2 H2; exists l2; auto. intros n; right; intros l0; red in |- *; intros [H0| H0]; [ case H1 | case (n l0) ]; auto. injection H0; auto. Defined. Definition in_alphabet_dec : forall m c, {in_alphabet m c} + {~ in_alphabet m c}. intros m; elim m; simpl in |- *; auto. intros a l H c; case (H c); intros H1. case (code_dec c a); intros H2. left; red in |- *; simpl in |- *. intros a1 [H3| H3]; [ case H2; intros l1 Hl1; exists l1; rewrite <- H3 | idtac ]; auto. right; red in |- *; intros H3; case (H3 a); simpl in |- *; auto. right; Contradict H1; auto; red in |- *. intros a0 H0; case (H1 a0); simpl in |- *; auto. intros x H2; exists x; auto. Defined. Definition not_null (c : code) := forall a : A, ~ In (a, nil) c. Theorem not_null_inv : forall (a : A * list bool) l, not_null (a :: l) -> not_null l. Proof using. intros a l H; red in |- *. intros a0; red in |- *; intros H0; case (H a0); simpl in |- *; auto. Qed. Theorem not_null_cons : forall a b (l : list (A * list bool)), b <> nil -> not_null l -> not_null ((a, b) :: l). Proof using. intros a b l H H0; red in |- *. intros a1; simpl in |- *; red in |- *; intros [H1| H1]; auto. case H; injection H1; auto. case (H0 a1); simpl in |- *; auto. Qed. Hint Resolve not_null_cons : core. Theorem not_null_app : forall l1 l2 : list (A * list bool), not_null l1 -> not_null l2 -> not_null (l1 ++ l2). Proof using. intros l1; elim l1; simpl in |- *; auto. intros (a2, l2); case l2; auto. intros l H l0 H0 H1; case (H0 a2); simpl in |- *; auto. intros b l l0 H l3 H0 H1; apply not_null_cons; auto. red in |- *; intros H2; discriminate. apply H; auto. apply not_null_inv with (1 := H0). Qed. Hint Resolve not_null_app : core. Theorem not_null_map : forall (l : list (A * list bool)) b, not_null (map (fun v => match v with | (a1, b1) => (a1, b :: b1) end) l). 
apply ordE in H as [t [Ht H]]. exists t. split... apply ord_well_defined. rewrite seg_Œ±... Qed. Lemma ord_of_ord : ‚àÄ S, ord S = ord (Epsilon S). Proof. intros. apply ord_well_defined. apply iso_epsilon. Qed. Lemma ord_empty : ‚àÄ S, A S = ‚à ‚Üí ord S = ‚à . Proof. intros. apply e_empty in H. unfold ord, Œ±. rewrite H. apply ran_of_empty. Qed. Lemma ord_woset : ‚àÄŒ± ‚ãµ ùêéùêç, woset Œ± (MemberRel Œ±). Proof. intros Œ± [S H]. subst. apply (wo (Epsilon S)). Qed. Theorem transitive_set_well_ordered_by_epsilon_is_ord : ‚àÄ Œ±, trans Œ± ‚Üí woset Œ± (MemberRel Œ±) ‚Üí Œ± ‚ãµ ùêéùêç. Proof with eauto. intros Œ± Htr Hwo. set (constr Œ± (MemberRel Œ±) Hwo) as S. cut (‚àÄx ‚àà Œ±, (E S)[x] = x). { intros H. exists S. pose proof (e_bijective S) as [[Hf _] [Hd _]]... ext Hx. - apply (ranI _ x). apply func_point... rewrite Hd. apply Hx. - apply ranE in Hx as [w Hp]. apply domI in Hp as Hw. rewrite Hd in Hw. apply func_ap in Hp... rewrite H in Hp... subst... } intros x Hx. set {x ‚àä Œ± | (E S)[x] = x} as B. replace Œ± with B in Hx. apply SepE2 in Hx... clear Hx x. eapply transfinite_induction. apply (wo S). split. intros x Hx. apply SepE1 in Hx... intros t Ht Hsub. apply SepI... rewrite e_ap... ext Hx. - apply ReplAx in Hx as [s [Hs H1]]. apply Hsub in Hs as Hsb. apply SepE in Hsb as [_ H2]. apply SepE in Hs as [_ H]. rewrite <- H2, H1 in H. apply binRelE3 in H... - assert (x ‚àà seg t (R S)). { apply segI. apply binRelI... } apply ReplAx. exists x. split... apply Hsub in H. apply SepE2 in H... Qed. Theorem ord_is_ords : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± ‚™Ω ùêéùêç. Proof. intros Œ± [S H] x Hx. subst. apply ordE in Hx as [t [Ht Heqx]]. subst x. set (Seg t S) as T. exists T. symmetry. apply seg_Œ±. apply Ht. Qed. Theorem ord_trans : ‚àÄŒ± ‚ãµ ùêéùêç, trans Œ±. Proof. intros Œ± [S H]. subst. apply Œ±_trans. Qed. Theorem ord_irrefl : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± ‚àâ Œ±. Proof. intros Œ± [S H]. subst. intros H. pose proof (ordE _ _ H) as [s [Hs Heq]]. rewrite <- Heq in H. eapply e_irrefl; eauto. Qed.End OrdDef. Notation ùêéùêç := is_ord. Global Hint Immediate ord_is_ord : core. Theorem ord_trich : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± ‚àà Œ≤ ‚àß Œ± ‚â Œ≤ ‚àß Œ≤ ‚àâ Œ± ‚à® Œ± ‚àâ Œ≤ ‚àß Œ± = Œ≤ ‚àß Œ≤ ‚àâ Œ± ‚à® Œ± ‚àâ Œ≤ ‚àß Œ± ‚â Œ≤ ‚àß Œ≤ ‚àà Œ±. 
(S q'0) at 1 in |- *; rewrite <- (absolu_inj_nat (S q'0)). rewrite <- absolu_mult. apply f_equal with (f := Z.abs_nat). pattern (Z_of_nat (S q'0)) at 1 in |- *; rewrite <- Zmult_1_r. rewrite <- Heq7. replace (S q'0 * (a * S p0 + b * S q0))%Z with (S p0 * S q'0 * a + S q'0 * (b * S q0))%Z. rewrite <- (Znat.inj_mult (S p0)). rewrite Heq8. rewrite Znat.inj_mult; ring. ring. rewrite <- (absolu_inj_nat (S p0)). pattern (S p'0) at 1 in |- *; rewrite <- absolu_inj_nat. rewrite <- absolu_mult. apply f_equal with (f := Z.abs_nat). pattern (Z_of_nat (S p'0)) at 1 in |- *; rewrite <- Zmult_1_r. rewrite <- Heq7. replace (S p'0 * (a * S p0 + b * S q0))%Z with (S p'0 * S q0 * b + S p'0 * (a * S p0))%Z. rewrite <- (Znat.inj_mult (S p'0)). rewrite <- Heq8. rewrite Znat.inj_mult; ring. ring. apply mult_reg_l with (d' + d * S d'). replace (S (d' + d * S d')) with (S d * S d'). transitivity (S p0 * S d * (S q'0 * S d')). ring. rewrite H1. ring. auto. Qed. Theorem construct_correct4' : forall p q p' q' n n' : nat, 1 <= p -> 1 <= q -> 1 <= p' -> 1 <= q' -> p + q <= n -> p' + q' <= n' -> p * q' = p' * q -> Qpositive_c p q n = Qpositive_c p' q' n'. intros p; case p. intros q p' q' n n' H; inversion H. intros p0 q; case q. intros p' q' n n' H H1; inversion H1. intros q0 p'; case p'. intros q' n n' H H1 H2; inversion H2. intros p'0 q'; case q'. intros n n' H H1 H2 H3; inversion H3. intros q'0 n; case n. simpl in |- *; intros n' H H1 H2 H3 H4; inversion H4. intros n0 n'; case n'. simpl in |- *; intros H H1 H2 H3 H4 H5; inversion H5. intros; apply construct_correct4; auto. Qed. Theorem interp_inject : forall w w' : Qpositive, Qpositive_i w = Qpositive_i w' -> w = w'. intros w w' H; CaseEq (Qpositive_i w). intros p q Heq. rewrite <- construct_correct with (1 := Heq) (n := p + q). apply construct_correct; auto. rewrite <- H; auto. auto. Qed. Theorem minus_decompose : forall a b c d : nat, a = b -> c = d -> a - c = b - d. 
Require Import missing. Require Import division. Require Import euclide. Require Import power. Require Import Wf_nat.Unset Standard Proposition Elimination Names. Definition is_cd (d a b : nat) := (divides a d)/\(divides b d). Definition is_gcd (d a b:nat) := (is_cd d a b)/\(forall (d':nat),(is_cd d' a b)->(divides d d')). Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'. unfold is_gcd. intros. elim H;elim H0;intros. apply divides_antisym;auto. Qed. Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a). unfold is_gcd. intros. elim H;intros. split. red;red in H0;tauto. intros. apply H1. red;red in H2;tauto. Qed. Lemma gcd_zero : forall (a:nat),(is_gcd a O a). unfold is_gcd. intro. split. red;split;[apply zero_max_div | apply divides_refl]. unfold is_cd;tauto. Qed. Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a). unfold is_gcd. intros. split. red;split;[apply divides_refl | apply one_min_div]. unfold is_cd;tauto. Qed. Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))). intros. unfold is_gcd. split;intro. elim H0;intros. split. red in H1;red. elim H1;intros. split;try tauto. apply divides_minus;trivial. unfold is_cd;intros. apply H2;red;elim H3;intros. split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial]. elim H0;unfold is_cd;intros. split. split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial]. intros. elim H3;intros;apply H2. split;try (apply divides_minus);trivial. Qed. Lemma gcd_refl : forall (a:nat),(is_gcd a a a). unfold is_gcd. intros. unfold is_cd. split;try tauto. split;apply divides_refl. Qed. Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d). unfold is_gcd;unfold is_cd;intros;tauto. Qed. Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d). unfold is_gcd;unfold is_cd;intros;tauto. Qed. Definition f (x:nat*nat) := (fst x)+(snd x).Definition R (x y:nat*nat) := (f x)<(f y).Lemma Rwf : well_founded R. unfold R. apply (well_founded_ltof (nat*nat) f). Qed. Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}. apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})). unfold ltof. unfold f. intros. case (lt_eq_lt_dec (fst x) (snd x));intro. case s;intro. destruct (fst x). exists (snd x);apply gcd_zero. elim (H (S n,snd x-S n)). simpl;intro d;intro. exists d. elim (gcd_minus d (S n) (snd x));try (auto with arith). simpl. omega. rewrite e;exists (snd x);apply gcd_refl. destruct (snd x). exists (fst x);apply gcd_sym;apply gcd_zero. elim (H (S n,fst x-S n)). simpl;intro d;intro. exists d. apply gcd_sym. elim (gcd_minus d (S n) (fst x));try (auto with arith). simpl. omega. Qed. Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}. 
(paths x x')) end. Theorem hlevelretract (n:nat) { X Y : UU } ( p : X -> Y ) ( s : Y -> X ) ( eps : forall y : Y , paths ( p ( s y ) ) y ) : isofhlevel n X -> isofhlevel n Y . Proof. intro. induction n as [ | n IHn ]. intros X Y p s eps X0. unfold isofhlevel. apply ( iscontrretract p s eps X0). unfold isofhlevel. intros X Y p s eps X0 x x'. unfold isofhlevel in X0. assert (is: isofhlevel n (paths (s x) (s x'))). apply X0. set (s':= @maponpaths _ _ s x x'). set (p':= pathssec2 s p eps x x'). set (eps':= @pathssec3 _ _ s p eps x x' ). simpl. apply (IHn _ _ p' s' eps' is). Defined. Corollary isofhlevelweqf (n:nat) { X Y : UU } ( f : weq X Y ) : isofhlevel n X -> isofhlevel n Y . Proof. intros n X Y f X0. apply (hlevelretract n f (invmap f ) (homotweqinvweq f )). assumption. Defined. Corollary isofhlevelweqb (n:nat) { X Y : UU } ( f : weq X Y ) : isofhlevel n Y -> isofhlevel n X . Proof. intros n X Y f X0 . apply (hlevelretract n (invmap f ) f (homotinvweqweq f )). assumption. Defined. Lemma isofhlevelsn ( n : nat ) { X : UU } ( f : X -> isofhlevel ( S n ) X ) : isofhlevel ( S n ) X. Proof. intros . simpl . intros x x' . apply ( f x x x'). Defined.Lemma isofhlevelssn (n:nat) { X : UU } ( is : forall x:X, isofhlevel (S n) (paths x x)) : isofhlevel (S (S n)) X. Proof. intros . simpl. intros x x'. change ( forall ( x0 x'0 : paths x x' ), isofhlevel n ( paths x0 x'0 ) ) with ( isofhlevel (S n) (paths x x') ). assert ( X1 : paths x x' -> isofhlevel (S n) (paths x x') ) . intro X2. destruct X2. apply ( is x ). apply ( isofhlevelsn n X1 ). Defined. Definition isofhlevelf ( n : nat ) { X Y : UU } ( f : X -> Y ) : UU := forall y:Y, isofhlevel n (hfiber f y). Theorem isofhlevelfhomot ( n : nat ) { X Y : UU }(f f':X -> Y)(h: forall x:X, paths (f x) (f' x)): isofhlevelf n f -> isofhlevelf n f'. 
Lock_in_network_eventually_MsgLock, lb_step_execution_invar, weak_fairness_invar. Qed. Lemma Nth_snoc : forall A (l : list A) x, Nth (l ++ [x]) (length l) x. Proof using. intros. induction l; simpl in *; constructor; auto. Qed. Lemma MsgLock_in_queue_or_Locked : forall c s, lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (MsgLock c)) s -> next (fun s => In (mkPacket Server (Client c) Locked) (nwPackets (evt_a (hd s)))) s \/ exists n, next (fun s => Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c) s. Proof using. intros. invcs H. invcs H2. - monad_unfold. unfold NetHandler in *. break_match_hyp. + unfold occurred in *. find_apply_lem_hyp ClientNetHandler_lbcases; intuition; congruence. + unfold occurred in *. find_apply_lem_hyp ServerNetHandler_lbcases; intuition; break_exists; intuition; try congruence; [left|right]; fold LockServ_MultiParams in *; repeat find_rewrite; simpl. * left. congruence. * update_destruct_max_simplify; try congruence. find_inversion. repeat find_rewrite. destruct (queue (nwState (evt_a e) Server)) eqn:?; try congruence. exists (length l). simpl. constructor. apply Nth_snoc. - monad_unfold. find_apply_lem_hyp InputHandler_lbcases. intuition; try congruence. break_exists. intuition; congruence. - unfold occurred in *. congruence. Qed. Lemma MsgLock_Locked : forall c s, event_step_star step_async step_async_init (hd s) -> lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (MsgLock c)) s -> eventually (fun s => In (mkPacket Server (Client c) Locked) (nwPackets (evt_a (hd s)))) s. Proof using. intros. find_apply_lem_hyp MsgLock_in_queue_or_Locked; auto. intuition. - destruct s; simpl in *; eauto using E_next, E0. - break_exists. destruct s; simpl in *. apply E_next. eapply clients_get_lock_messages; eauto using lb_step_execution_invar, weak_fairness_invar. find_apply_lem_hyp step_async_star_lb_step_execution; auto. destruct s. simpl. do 2 (find_apply_lem_hyp always_Cons; intuition). Qed. Lemma MsgLock_eventually_MsgLocked : forall c s, event_step_star step_async step_async_init (hd s) -> lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (MsgLock c)) s -> eventually (now (occurred (MsgLocked c))) s. Proof using. intros c s Hss Hlbs Hfair. match goal with | H : _ (hd s) |- _ => pattern s in H end. match goal with | H1 : ?J1 s, H2 : ?J2 s, H3 : ?J3 s |- _ => assert ((J1 /\_ J2 /\_ J3) s) as Hand by (now unfold and_tl); clear H1; clear H2; clear H3 end; simpl in *. intros. eapply eventually_trans. 4:eapply MsgLock_Locked; eauto; unfold and_tl in *; intuition. 3:apply Hand. all:unfold and_tl in *. all:intuition eauto using lb_step_execution_invar, weak_fairness_invar. - find_apply_lem_hyp step_async_star_lb_step_execution; auto. destruct s0. simpl in *. find_apply_lem_hyp always_Cons. intuition. find_apply_lem_hyp always_Cons. intuition. - eauto using Locked_in_network_eventually_MsgLocked. Qed. Theorem locking_clients_eventually_receive_lock_lb : forall c s, event_step_star step_async step_async_init (hd s) -> lb_step_execution lb_step_async s -> weak_fairness lb_step_async label_silent s -> now (occurred (InputLock c)) s -> eventually (now (occurred (MsgLocked c))) s. 
xSz zRy ]. induction xSz as [ x | w x z xSw wSz IHh ]; intros x' xTx'. destruct (HR xTx' zRy) as [ y' yTy' x'SRy' ]; exists y'; auto. destruct (HS xTx' xSw) as [ w' wTw' x'Sw' ]. destruct wTw' as [ w | w1 w w' wTw1 w1Tw' ]. exists y; auto; exists z; auto; apply star_trans with w; assumption. elim IHh with w1; auto. intros z1 zTz1 w1Sz1. cut (forall w2, star TX w1 w2 -> forall w3 y2, TX w2 w3 -> SR w2 y2 -> exists2 y3, star TY y2 y3 & SR w3 y3). clear IH IHh xTx' xSw x wSz wTw1 w; intro IH; cgen w1Sz1; cgen zTz1; cgen z1. induction w1Tw' as [ w1 | w2 w1 w' w1Tw2 w2Tw' IHv ]; intros y1 yTy1 w1SRy1. destruct w1SRy1 as [ z1 w1Sz1 z1Ry1 ]. exists y1; auto; exists z1; auto; apply star_trans with w1; auto. elim IH with w1 w2 y1; auto; intros y2 y1Ty2 w2Sy2. elim IHv with y2; auto. intros y' y2Ty' w'SRy'. destruct w'SRy' as [ z' w'Sz' z'Ry' ]. exists y'; auto; exists z'; auto; apply star_trans with z1; assumption. intros w3 w2Tw3 w4 y3 w3Tw4 w3SRy3. elim IH with w3 w4 y3; auto. intros y4 y3Ty4 w4SRy4. destruct w4SRy4 as [ z4 w4Sz4 s4Ry4 ]. exists y4; auto; exists z4; auto; apply star_trans with w3; assumption. apply S_star with w2; assumption. apply star_trans with y1; assumption. intros w2 w1Tw2 w3 y2 w2Tw3 w2SRy2; destruct w2SRy2 as [ z2 w2Sz2 z2Ry2 ]. elim IH with w2 w3 y2; auto. intros y3 y2Ty3 w3SRy3. exists y3; auto. exists w; auto. exists w1; assumption. exists z2; assumption. intros w2 wSTw2 w3 y2 w2Tw3 w2SRy2; destruct w2SRy2 as [ z2 w2Sz2 z2Ry2 ]. destruct wSTw2 as [ u wSu uTw2 ]. elim IH with w2 w3 y2; auto. intros y3 y2Ty3 w3SRy3; destruct w3SRy3 as [ z3 w3Sz3 z3Ry3 ]. exists y3; auto. exists z3; auto. exists u; auto; exists w; auto. exists z2; assumption. Qed. Variables X' Y': Type. Variable TaX: relation2 X X'. Variable TaY: relation2 Y Y'. Variable S' : relation2 X' X'. Variable R' : relation2 X' Y'. Let SR' := comp (star S') R'. Let TAX := comp (star TX) TaX. Let TAY := comp (star TY) TaY. Hypothesis HT: diagram TaX S TAX (star S'). Hypothesis HRT: diagram TaX R TAY SR'. Theorem diagram_star_wf_2: diagram TAX SR TAY SR'. 
* list (poly A0 eqA ltM)) : Prop := Co (PtoS x) (PtoS y). Theorem wf_RL : well_founded RL. apply (wf_inverse_image _ _ Co PtoS); auto. try exact wf_Co. Qed. Definition pbuchf : forall PQ : list (poly A0 eqA ltM) * list (poly A0 eqA ltM), {R : list (poly A0 eqA ltM) | OBuch (fst PQ) (snd PQ) R}. intros pq; pattern pq in |- *. apply well_founded_induction with (A := (list (poly A0 eqA ltM) * list (poly A0 eqA ltM))%type) (R := RL). try exact wf_RL. intros x; elim x. intros P Q; case Q; simpl in |- *. intros H'; exists P; auto. intros a Q2 Rec. apply LetP with (A := poly A0 eqA ltM) (h := nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a P). intros a0 H'. case (zerop_dec A A0 eqA n ltM a0); intros red10. elim (Rec (P, Q2)); simpl in |- *; [ intros R E | idtac ]; auto. exists R; auto. apply OBuch2; auto. rewrite <- H'; auto. red in |- *; unfold Co in |- *; unfold PtoS in |- *. apply (right_lex _ _ (RO A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os) Fl); auto. red in |- *; red in |- *; simpl in |- *; auto. elim (Rec (addEnd A A0 eqA n ltM a0 P, genPcPf a0 P Q2)); simpl in |- *; [ intros R E0; try exact E0 | idtac ]. exists R; auto. apply OBuch1; auto. rewrite <- H'; auto. rewrite <- H'; auto. rewrite H'. red in |- *; unfold Co in |- *; unfold PtoS in |- *. apply (left_lex _ _ (RO A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os) Fl); auto. apply RO_lem; auto. rewrite <- H'; auto. Defined. Definition strip : forall P : list (poly A0 eqA ltM) -> Prop, sig P -> list (poly A0 eqA ltM). intros P H'; case H'. intros x H'0; try assumption. Defined. Theorem pbuchf_Stable : forall P R : list (poly A0 eqA ltM), R = strip _ (pbuchf (P, genOCPf P)) -> stable P R. simpl in |- *. intros P R H'; try assumption. apply OBuch_Stable_f; auto. rewrite H'. case (pbuchf (pair P (genOCPf P))); simpl in |- *; auto. Qed. Theorem pbuchf_Inv : forall P R : list (poly A0 eqA ltM), R = strip _ (pbuchf (P, genOCPf P)) -> forall a b : poly A0 eqA ltM, In a R -> In b R -> reds a b R. 
: hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. Proof. unfold not; intros a H; inversion_clear H. Qed. Theorem in_split : forall x (l:list A), In x l -> exists l1 l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists [], l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Qed. Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem in_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl; auto. destruct IHl; simpl; auto. right; unfold not; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), [] <> x ++ a :: y. Proof. unfold not. destruct x as [| a l]; simpl; intros. discriminate H. discriminate H. Qed. Theorem app_nil_l : forall l:list A, [] ++ l = l. Proof. reflexivity. Qed. Theorem app_nil_r : forall l:list A, l ++ [] = l. Proof. induction l; simpl; f_equal; auto. Qed. Theorem app_nil_end : forall (l:list A), l = l ++ []. Proof. symmetry; apply app_nil_r. Qed. Theorem app_assoc : forall l m n:list A, l ++ m ++ n = (l ++ m) ++ n. Proof. intros l m n; induction l; simpl; f_equal; auto. Qed. Theorem app_assoc_reverse : forall l m n:list A, (l ++ m) ++ n = l ++ m ++ n. Proof. auto using app_assoc. Qed. Hint Resolve app_assoc_reverse. Theorem app_comm_cons : forall (x y:list A) (a:A), a :: (x ++ y) = (a :: x) ++ y. Proof. auto. Qed. Theorem app_eq_nil : forall l l':list A, l ++ l' = [] -> l = [] /\ l' = []. 
Instant)), bound t -> Q ((s, t) ^ x) -> Until_bound P Q ((s, t) ^ x). Inductive EX_Until_bound (Sini : S * Instant) (P Q : Stream (S * Instant) -> Prop) : Prop := ExUntil_bound : forall x : Stream (S * Instant), isTraceFrom_T Sini x -> Until_bound P Q x -> EX_Until_bound Sini P Q. Definition FA_Until_bound (Sini : S * Instant) (P Q : Stream (S * Instant) -> Prop) := forall x : Stream (S * Instant), isTraceFrom_T Sini x -> Until_bound P Q x. Definition Always_T (Sini : S * Instant) (P : Stream (S * Instant) -> Prop) := forall x : Stream (S * Instant), isTraceFrom_T Sini x -> ForAllS (fun s : Stream (S * Instant) => bound (snd (hd s)) -> P s) x. Definition Inevitable_T (Sini : S * Instant) (P : Stream (S * Instant) -> Prop) := forall x : Stream (S * Instant), isTraceFrom_T Sini x -> ExistsS (fun s : Stream (S * Instant) => bound (snd (hd s)) /\ P s) x. Inductive Posible_T (Sini : S * Instant) (P : Stream (S * Instant) -> Prop) : Prop := posible_T : forall x : Stream (S * Instant), isTraceFrom_T Sini x -> ExistsS (fun s : Stream (S * Instant) => bound (snd (hd s)) /\ P s) x -> Posible_T Sini P. Inductive SafePath_T (Sini : S * Instant) (P : Stream (S * Instant) -> Prop) : Prop := safePath_T : forall x : Stream (S * Instant), isTraceFrom_T Sini x -> ForAllS (fun s : Stream (S * Instant) => bound (snd (hd s)) -> P s) x -> SafePath_T Sini P. Theorem Equiv1_T : forall (Sini : S * Instant) (P : Stream (S * Instant) -> Prop), Posible_T Sini P <-> EX_Until_bound Sini (fun _ : Stream (S * Instant) => True) P. Proof. unfold iff in |- *; intros; split; intro. inversion_clear H. apply ExUntil_bound with (P := fun _ : Stream (S * Instant) => True) (1 := H0). elim H1. simple destruct x0; simpl in |- *. simple destruct p; simple destruct 1; simpl in |- *; intros. constructor 2; assumption. simple destruct s; intros. constructor 1; trivial. inversion_clear H. apply posible_T with (1 := H0). elim H1. simple destruct s; intros. constructor 2; assumption. intros; constructor 1; simpl in |- *; split; assumption. Qed. Theorem Equiv2_T : forall (Sini : S * Instant) (P : Stream (S * Instant) -> Prop), Inevitable_T Sini P <-> FA_Until_bound Sini (fun _ : Stream (S * Instant) => True) P. 
orig_base_params}. Context {tsi : term_sanity_interface}. Theorem logs_sorted_init : raft_net_invariant_init logs_sorted. Proof using. unfold raft_net_invariant_init, logs_sorted, logs_sorted_host, logs_sorted_nw, packets_gt_prevIndex, packets_ge_prevTerm in *. intuition; simpl in *; intuition. Qed. Theorem handleClientRequest_packets : forall h st client id c out st' ps, handleClientRequest h st client id c = (out, st', ps) -> ps = []. Proof using. intros. find_apply_lem_hyp handleClientRequest_log. intuition. Qed. Theorem logs_sorted_nw_packets_unchanged : forall net ps' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_packets_unchanged : forall net ps' st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_ge_prevTerm_packets_unchanged : forall net ps' st', packets_ge_prevTerm net -> (forall p, In p ps' -> In p (nwPackets net) \/ False) -> packets_ge_prevTerm (mkNetwork ps' st'). Proof using. unfold packets_ge_prevTerm in *. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Lemma handleClientRequest_logs_sorted : forall h client id c out st l net, handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st). Proof using tsi. unfold logs_sorted_host. intros. find_apply_lem_hyp handleClientRequest_log. intuition. + repeat find_rewrite. eauto. + find_apply_lem_hyp no_entries_past_current_term_invariant. break_exists; intuition; repeat find_rewrite. simpl. intuition eauto. * find_eapply_lem_hyp maxIndex_is_max; eauto. omega. * unfold no_entries_past_current_term, no_entries_past_current_term_host in *. intuition. simpl in *. find_apply_hyp_hyp. omega. Qed. Theorem logs_sorted_client_request : raft_net_invariant_client_request logs_sorted. Proof using tsi. unfold raft_net_invariant_client_request. unfold logs_sorted. intuition. - unfold logs_sorted_host in *. simpl in *. intros. find_higher_order_rewrite. break_match; eauto. subst. eauto using handleClientRequest_logs_sorted. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using logs_sorted_nw_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_gt_prevIndex_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_ge_prevTerm_packets_unchanged. Qed. Theorem handleTimeout_log : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> log st' = log st. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; auto. Qed. Theorem logs_sorted_nw_only_new_packets_matter : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> logs_sorted_nw (mkNetwork l st') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem logs_sorted_nw_no_append_entries : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> logs_sorted_nw (mkNetwork ps' st'). 
H1 => op_intro_l (z + x) (z + y) u H0 || a = u + (z + y) @a by <- op_is_assoc u z x || (u + z) + x = a @a by <- op_is_assoc u z y || a + x = a + y @a by <- H1 || a = 0 + y @a by <- op_id_l x || x = a @a by <- op_id_l y) H. Theorem op_cancel_r : forall x y z : M, has_inv_r z -> x + z = y + z -> x = y. Proof fun x y z H H0 => ex_ind (fun u H1 => op_intro_r (x + z) (y + z) u H0 || a = (y + z) + u @a by op_is_assoc x z u || x + (z + u) = a @a by op_is_assoc y z u || x + a = y + a @a by <- H1 || a = y + 0 @a by <- op_id_r x || x = a @a by <- op_id_r y) H. Theorem op_inv_l_uniq : forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof fun x H y z H0 H1 => let H2 : z + x = y + x := H1 || z + x = a @a by H0 in let H3 : z = y := op_cancel_r z y x H H2 in H3. Theorem op_inv_r_uniq : forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof fun x H y z H0 H1 => let H2 : x + z = x + y := H1 || x + z = a @a by H0 in let H3 : z = y := op_cancel_l z y x H H2 in H3. Theorem op_inv_uniq : forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y. Proof fun x y z H H0 => op_inv_l_uniq x (ex_intro (fun y => op_is_inv_r x y) y (proj2 H)) y z (proj1 H) (proj1 H0). Theorem op_inv_0_l : op_is_inv_l 0 0. Proof op_id_l 0 : 0 + 0 = 0. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof op_id_r 0 : 0 + 0 = 0. Theorem op_inv_0 : op_is_inv 0 0. 
q H' H'0. inversion H'; inversion H'0; elim H0; elim H; clear H0 H; intros H'1 H'2 H'3 H'4. apply (MinUniqueP r); auto. cut (r = Fzero (- dExp b) :>R); [ intros Eq0 | apply Rle_antisym; unfold FtoRradix, Fzero, FtoR in |- *; simpl in |- * ]; try rewrite Rmult_0_l; auto with real. apply trans_eq with (FtoRradix (Fzero (- dExp b))). apply sym_eq; unfold FtoRradix in |- *; apply (RoundedProjector _ ToZeroRoundedModeP); auto with float. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. unfold FtoRradix in |- *; apply (RoundedProjector _ ToZeroRoundedModeP); auto with float. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. cut (r = Fzero (- dExp b) :>R); [ intros Eq0 | apply Rle_antisym; unfold FtoRradix, Fzero, FtoR in |- *; simpl in |- * ]; try rewrite Rmult_0_l; auto with real. apply trans_eq with (FtoRradix (Fzero (- dExp b))). apply sym_eq; unfold FtoRradix in |- *; apply (RoundedProjector _ ToZeroRoundedModeP); auto with float. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. unfold FtoRradix in |- *; apply (RoundedProjector _ ToZeroRoundedModeP); auto with float. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. apply (MaxUniqueP r); auto. Qed. Theorem ToInfinityUniqueP : UniqueP ToInfinityP. red in |- *. intros r p q H' H'0. inversion H'; inversion H'0; elim H0; elim H; clear H0 H; intros H'1 H'2 H'3 H'4. apply (MinUniqueP r); auto. cut (r = Fzero (- dExp b) :>R); [ intros Eq0 | apply Rle_antisym; unfold FtoRradix, Fzero, FtoR in |- *; simpl in |- * ]; try rewrite Rmult_0_l; auto with real. apply trans_eq with (FtoRradix (Fzero (- dExp b))). apply sym_eq; unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. cut (r = Fzero (- dExp b) :>R); [ intros Eq0 | apply Rle_antisym; unfold FtoRradix, Fzero, FtoR in |- *; simpl in |- * ]; try rewrite Rmult_0_l; auto with float. apply trans_eq with (FtoRradix (Fzero (- dExp b))). apply sym_eq; unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. unfold FtoRradix in |- *; apply (RoundedProjector _ ToInfinityRoundedModeP); auto. apply FboundedFzero; auto. unfold FtoRradix in Eq0; rewrite <- Eq0; auto. apply (MaxUniqueP r); auto. Qed. Theorem MinOrMaxRep : forall P, MinOrMaxP P -> forall p q : float, P p q -> exists m : Z, q = Float m (Fexp p) :>R. 
real zarith. rewrite FshiftCorrect; auto. unfold Fshift in |- *; simpl in |- *. rewrite (fun x y => inj_abs (x - y)); auto with zarith. simpl in |- *; auto. replace (Z_of_nat 1) with (Fnum (boundR r)). apply Rlt_Fexp_eq_Zlt with (radix := radix); auto with zarith. rewrite FshiftCorrect; auto. unfold Fshift in |- *; simpl in |- *. rewrite inj_abs; auto with zarith. generalize H'; simpl in |- *; auto with zarith. simpl in |- *; auto. intros p0; case p0; simpl in |- *; auto with zarith. intros H'0 H'1 H'2 H'3; unfold mBFloat in |- *. replace q with ((fun p : Z * Z => Float (fst p) (snd p)) (Fnum q, Fexp q)). apply in_map with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. apply mProd_correct; auto. apply mZlist_correct; auto with float. apply Zle_Zabs_inv1; auto with float. unfold pPred in |- *; apply Zle_Zpred; auto with float. apply Zle_Zabs_inv2; auto with float. unfold pPred in |- *; apply Zle_Zpred; auto with float. apply mZlist_correct; auto with float. auto with zarith. case q; simpl in |- *; auto with zarith. Qed. Theorem mBFadic_correct2 : forall r : R, In (boundR r) (mBFloat r). intros r; unfold mBFloat in |- *. replace (boundR r) with ((fun p : Z * Z => Float (fst p) (snd p)) (Fnum (boundR r), Fexp (boundR r))). apply in_map with (f := fun p : Z * Z => Float (fst p) (snd p)); auto. apply mProd_correct; auto. apply mZlist_correct; auto. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. apply Zle_trans with (- (0))%Z; auto with zarith. apply Zle_Zopp; unfold pPred in |- *; apply Zle_Zpred; simpl in |- *. apply Zlt_trans with 1%Z; auto with zarith. apply vNumbMoreThanOne with (3 := pGivesBound); auto. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. unfold pPred in |- *; apply Zle_Zpred; simpl in |- *. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. apply vNumbMoreThanOne with (3 := pGivesBound); auto. apply mZlist_correct; auto. unfold boundR, boundNat in |- *; simpl in |- *; auto with zarith. apply Zle_trans with 0%Z; auto with zarith arith. case (dExp b); auto with zarith. case (boundR r); simpl in |- *; auto with zarith. case (boundR r); simpl in |- *; auto with zarith. Qed. Theorem mBFadic_correct3 : forall r : R, In (Fopp (boundR r)) (mBFloat r). 
-> A -> B) (m: t A) (v: B) : B := match m with Empty => v | Nodes m' => fold1' f m' v end. Lemma fold1'_xelements': forall A B (f: B -> A -> B) m i v l, List.fold_left (fun a p => f a (snd p)) l (fold1' f m v) = List.fold_left (fun a p => f a (snd p)) (xelements' m i l) v. Proof. induction m; simpl; intros; auto. rewrite <- IHm1. rewrite <- IHm2. auto. rewrite <- IHm. auto. rewrite <- IHm1. simpl. rewrite <- IHm2. auto. Qed. Theorem fold1_spec: forall A B (f: B -> A -> B) (v: B) (m: t A), fold1 f m v = List.fold_left (fun a p => f a (snd p)) (elements m) v. Proof. intros. destruct m as [|m]. reflexivity. apply fold1'_xelements' with (l := @nil (positive * A)). Qed. Arguments empty A : simpl never. Arguments get {A} p m : simpl never. Arguments set {A} p x m : simpl never. Arguments remove {A} p m : simpl never.End PTree.Module PMap <: MAP. Definition elt := positive. Definition elt_eq := peq. Definition t (A : Type) : Type := (A * PTree.t A)%type. Definition init (A : Type) (x : A) := (x, PTree.empty A). Definition get (A : Type) (i : positive) (m : t A) := match PTree.get i (snd m) with | Some x => x | None => fst m end. Definition set (A : Type) (i : positive) (x : A) (m : t A) := (fst m, PTree.set i x (snd m)). Theorem gi: forall (A: Type) (i: positive) (x: A), get i (init x) = x. Proof. intros. reflexivity. Qed. Theorem gss: forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto. Qed. Theorem gso: forall (A: Type) (i j: positive) (x: A) (m: t A), i <> j -> get i (set j x m) = get i m. Proof. intros. unfold get. unfold set. simpl. rewrite PTree.gso; auto. Qed. Theorem gsspec: forall (A: Type) (i j: positive) (x: A) (m: t A), get i (set j x m) = if peq i j then x else get i m. Proof. intros. destruct (peq i j). rewrite e. apply gss. auto. apply gso. auto. Qed. Theorem gsident: forall (A: Type) (i j: positive) (m: t A), get j (set i (get i m) m) = get j m. 
B' C' : Point, A<>C' -> on_line C A B -> on_parallel B' A B A' -> on_inter_line_parallel C' A A' B' C A' -> parallel B C' B' C. Proof. area_method. Qed.Theorem Desargues : forall A B C X A' B' C' : Point, A' <>C' -> A' <> B' -> on_line A' X A -> on_inter_line_parallel B' A' X B A B -> on_inter_line_parallel C' A' X C A C -> parallel B C B' C'. Proof. area_method. Qed.Theorem ex1_6auto : forall A B C D E F G P : Point, inter_ll D B C A P -> inter_ll E A C B P -> inter_ll F A B C P -> A <> D -> B <> E -> C <> F -> parallel P D A D -> parallel P E B E -> parallel P F C F -> P ** D / A ** D + P ** E / B ** E + P ** F / C ** F = 1. Proof. area_method. Qed.Theorem th2_41 : forall A B C D P Q M : Point, on_line C A P -> on_inter_line_parallel D C B P A B -> inter_ll Q A D B C -> inter_ll M A B P Q -> B <> M -> parallel A M B M -> C<>D -> A ** M / B ** M = - (1). Proof. area_method. Qed.Theorem Prop51Hartsshorne : forall A B C D E : Point, is_midpoint D A B -> is_midpoint E A C -> parallel D E B C. Proof. area_method. Qed.Theorem is_midpoint_A : forall A B C A' B' : Point, is_midpoint A' B C -> is_midpoint B' A C -> parallel A' B' A B. Proof. area_method. Qed. Theorem Prop51Hartsshornebis : forall A B C D E : Point, ~ Col D A C -> ~ Col A B C -> is_midpoint D A B -> is_midpoint E A C -> parallel D E B C -> B <> C -> D ** E / B ** C = 1 / 2. Proof. area_method. Qed.Theorem th6_40_Centroid : forall A B C E F O : Point, is_midpoint F A B -> is_midpoint E B C -> inter_ll O A E C F -> O <> E -> parallel A O O E -> A ** O / O ** E = 2. Proof. area_method. Qed. Theorem Prop54Hartsshorne : forall A B C D E F G : Point, is_midpoint D A B -> is_midpoint E A C -> is_midpoint F B C -> inter_ll G E B C D -> Col A G F. 
Require Import Verdi.GhostSimulations.Require Import VerdiRaft.CommonTheorems. Require Import VerdiRaft.Raft. Require Import VerdiRaft.SortedInterface. Require Import VerdiRaft.RaftRefinementInterface. Require Import VerdiRaft.StateMachineSafetyPrimeInterface. Require Import VerdiRaft.LeaderCompletenessInterface. Require Import VerdiRaft.LeaderLogsContiguousInterface. Require Import VerdiRaft.AllEntriesLeaderLogsInterface. Require Import VerdiRaft.LogMatchingInterface. Require Import VerdiRaft.UniqueIndicesInterface. Require Import VerdiRaft.AppendEntriesRequestLeaderLogsInterface. Require Import VerdiRaft.LeaderLogsSortedInterface. Require Import VerdiRaft.LeaderLogsLogMatchingInterface. Require Import VerdiRaft.LogsLeaderLogsInterface. Require Import VerdiRaft.OneLeaderLogPerTermInterface. Require Import VerdiRaft.RefinedLogMatchingLemmasInterface.Local Arguments update {_} {_} {_} _ _ _ _ : simpl never.Section StateMachineSafety'. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Context {rri : raft_refinement_interface}. Context {lci : leader_completeness_interface}. Context {aelli : all_entries_leader_logs_interface}. Context {lmi : log_matching_interface}. Context {uii : unique_indices_interface}. Context {aerlli : append_entries_leaderLogs_interface}. Context {llsi : leaderLogs_sorted_interface}. Context {lsi : sorted_interface}. Context {llci : leaderLogs_contiguous_interface}. Context {lllmi : leaderLogs_entries_match_interface}. Context {llli : logs_leaderLogs_interface}. Context {ollpti : one_leaderLog_per_term_interface}. Context {rlmli : refined_log_matching_lemmas_interface}. Theorem lift_log_matching : forall net, refined_raft_intermediate_reachable net -> log_matching (deghost net). 
Œ≥ (1/2) key [Nil; Nil]) ‚àó "#HtuplesRP" ‚à∑ ([‚àó map] key ‚Ü¶ tuple ‚àà lockmM, is_tuple tuple key Œ≥) ‚àó "_" ‚à∑ True.#[local] Hint Extern 1 (environments.envs_entails _ (own_index_bucket _ _ _)) => unfold own_index_bucket : core. Definition is_index_bucket (bkt : loc) (hash : nat) (Œ≥ : mvcc_names) : iProp Œ£ := ‚àÉ (latch : loc), "#Hlatch" ‚à∑ readonly (bkt ‚Ü¶[IndexBucket :: "latch"] #latch) ‚àó "#HlatchRP" ‚à∑ is_lock mvccN #latch (own_index_bucket bkt hash Œ≥) ‚àó "_" ‚à∑ True.Definition is_index (idx : loc) (Œ≥ : mvcc_names) : iProp Œ£ := ‚àÉ (bkts : Slice.t) (bktsL : list loc) (p : proph_id), "#Hbkts" ‚à∑ readonly (idx ‚Ü¶[Index :: "buckets"] (to_val bkts)) ‚àó "#HbktsL" ‚à∑ readonly (is_slice_small bkts ptrT 1 (to_val <$> bktsL)) ‚àó "%HbktsLen" ‚à∑ ‚åúlength bktsL = N_IDX_BUCKET‚åù ‚àó "#HbktsRP" ‚à∑ ([‚àó list] i ‚Ü¶ bkt ‚àà bktsL, is_index_bucket bkt i Œ≥) ‚àó "#Hinvgc" ‚à∑ mvcc_inv_gc Œ≥ ‚àó "#Hinv" ‚à∑ mvcc_inv_sst Œ≥ p ‚àó "_" ‚à∑ True. Theorem wp_index__GetTuple idx (key : u64) Œ≥ : is_index idx Œ≥ -‚àó {{{ True }}} Index__GetTuple #idx #key {{{ (tuple : loc), RET #tuple; is_tuple tuple key Œ≥ }}}. Proof. iIntros "#Hindex !>" (Œ¶) "_ HŒ¶". iNamed "Hindex". wp_call. wp_lam. wp_pures. wp_loadField. iMod (readonly_load with "HbktsL") as (q) "HbktsL'". list_elem bktsL (int.nat (word.modu key 2048)) as bkt. { revert HbktsLen. rewrite /N_IDX_BUCKET. word. } wp_apply (wp_SliceGet with "[$HbktsL']"). { iPureIntro. rewrite list_lookup_fmap. by rewrite Hbkt_lookup. } iIntros "[HbktsL' _]". wp_pures. iDestruct (big_sepL_lookup with "HbktsRP") as "HbktRP"; first done. iNamed "HbktRP". wp_loadField. wp_apply (acquire_spec with "HlatchRP"). iIntros "[Hlocked HbktOwn]". iNamed "HbktOwn". wp_pures. wp_loadField. wp_apply (wp_MapGet with "HlockmOwn"). iIntros (tuple ok) "[%Hmap_get HlockmOwn]". wp_pures. wp_if_destruct. { wp_loadField. wp_apply (release_spec with "[-HŒ¶]"). { eauto 10 with iFrame . } wp_pures. iApply "HŒ¶". iApply (big_sepM_lookup with "HtuplesRP"). by apply map_get_true. } apply map_get_false in Hmap_get as [Hlookup _]. clear tuple. rewrite (big_sepS_delete _ _ key); last first. { unfold keys_hashed. rewrite -not_elem_of_dom in Hlookup. apply elem_of_difference. split; last done. rewrite elem_of_filter. split; [auto | set_solver]. } iDestruct "Hvchains" as "[Hvchain Hvchains]". wp_apply (wp_MkTuple with "Hinvgc Hinv Hvchain"). iIntros (tuple) "#HtupleRP". wp_pures. wp_loadField. wp_apply (wp_MapInsert with "HlockmOwn"); first done. iIntros "HlockmOwn". wp_pures. wp_loadField. wp_apply (release_spec with "[-HŒ¶ HtupleRP]"). { iFrame "Hlocked HlatchRP". iNext. rewrite /own_index_bucket. do 2 iExists _. iFrame. iSplit. { rewrite dom_insert_L. iApply (big_sepS_subseteq with "Hvchains"). set_solver. } iSplit; last done. iApply (big_sepM_insert with "[$HtuplesRP HtupleRP]"); first done. iFrame "HtupleRP". } wp_pures. by iApply "HŒ¶". Qed. #[local] Theorem wp_index__getKeys idx Œ≥ : is_index idx Œ≥ -‚àó {{{ True }}} Index__getKeys #idx {{{ (keysS : Slice.t) (keys : list u64), RET (to_val keysS); is_slice keysS uint64T 1 (to_val <$> keys) }}}. 
:= #|G : N|; set f := truncC _. set eta := 'chi_c0 => co_e_f etaNth muNlam; have [sNG nNG] := andP nsNG. have fE: f%:R = theta 1%g by rewrite truncCK ?Cnat_irr1. pose nu := cfDet eta; have lin_nu: nu \is a linear_char := cfDet_lin_char _. have nuNlam: 'Res nu = lambda by rewrite -cfDetRes ?irr_char ?etaNth. have lin_lam: lambda \is a linear_char := cfDet_lin_char _. have lin_mu: mu \is a linear_char. by have:= lin_lam; rewrite -muNlam; apply: cfRes_lin_lin; apply: irr_char. have [Unu Ulam] := (lin_char_unitr lin_nu, lin_char_unitr lin_lam). pose alpha := mu / nu. have alphaN_1: 'Res[N] alpha = 1 by rewrite rmorph_div //= muNlam nuNlam divrr. have lin_alpha: alpha \is a linear_char by apply: rpred_div. have alpha_e: alpha ^+ e = 1. have kerNalpha: N \subset cfker alpha. by rewrite -subsetIidl -cfker_Res ?lin_charW // alphaN_1 cfker_cfun1. apply/eqP; rewrite -(cfQuoK nsNG kerNalpha) -rmorphX cfMod_eq1 //. rewrite -dvdn_cforder /e -card_quotient //. by rewrite cforder_lin_char_dvdG ?cfQuo_lin_char. have det_alphaXeta b: cfDet (alpha ^+ b * eta) = alpha ^+ (b * f) * nu. by rewrite cfDet_mul_lin ?rpredX ?irr_char // -exprM -(cfRes1 N) etaNth. have [b bf_mod_e]: exists b, b * f = 1 %[mod e]. rewrite -(chinese_modl co_e_f 1 0) /chinese !mul0n addn0 !mul1n mulnC. by exists (egcdn f e).1. have alpha_bf: alpha ^+ (b * f) = alpha. by rewrite -(expr_mod _ alpha_e) bf_mod_e expr_mod. have /irrP[c Dc]: alpha ^+ b * eta \in irr G. by rewrite mul_lin_irr ?rpredX ?mem_irr. have chiN: 'Res 'chi_c = theta. by rewrite -Dc rmorphM rmorphX /= alphaN_1 expr1n mul1r. have det_chi: cfDet 'chi_c = mu by rewrite -Dc det_alphaXeta alpha_bf divrK. exists c => // c2 c2Nth det_c2_mu; apply: irr_inj. have [irrMc _ imMc _] := constt_Ind_ext nsNG chiN. have /codomP[s2 Dc2]: c2 \in codom (@mul_mod_Iirr G N c). by rewrite -imMc constt_Ind_Res c2Nth constt_irr ?inE. have{} Dc2: 'chi_c2 = ('chi_s2 %% N)%CF * 'chi_c. by rewrite Dc2 cfIirrE // mod_IirrE. have s2_lin: 'chi_s2 \is a linear_char. rewrite qualifE irr_char; apply/eqP/(mulIf (irr1_neq0 c)). rewrite mul1r -[in RHS](cfRes1 N) chiN -c2Nth cfRes1. by rewrite Dc2 cfunE cfMod1. have s2Xf_1: 'chi_s2 ^+ f = 1. apply/(can_inj (cfModK nsNG))/(mulIr (lin_char_unitr lin_mu))/esym. rewrite rmorph1 rmorphX /= mul1r -{1}det_c2_mu Dc2 -det_chi. by rewrite cfDet_mul_lin ?cfMod_lin_char ?irr_char // -(cfRes1 N) chiN. suffices /eqP s2_1: 'chi_s2 == 1 by rewrite Dc2 s2_1 rmorph1 mul1r. rewrite -['chi_s2]expr1 -dvdn_cforder -(eqnP co_e_f) dvdn_gcd. by rewrite /e -card_quotient ?cforder_lin_char_dvdG //= dvdn_cforder s2Xf_1. Qed. Theorem solvable_irr_extendible_from_det G N s (theta := 'chi[N]_s) : N <| G -> solvable (G / N) -> G \subset 'I[theta] -> coprime #|G : N| (truncC (theta 1%g)) -> [exists c, 'Res 'chi[G]_c == theta] = [exists u, 'Res 'chi[G]_u == cfDet theta]. 
Require Export Setoid.Axiom S1: Set. Axiom eqS1: S1 -> S1 -> Prop. Axiom SetoidS1 : Setoid_Theory S1 eqS1. Add Setoid S1 eqS1 SetoidS1 as S1setoid.Instance eqS1_default : DefaultRelation eqS1.Axiom eqS1': S1 -> S1 -> Prop. Axiom SetoidS1' : Setoid_Theory S1 eqS1'. Axiom SetoidS1'_bis : Setoid_Theory S1 eqS1'. Add Setoid S1 eqS1' SetoidS1' as S1setoid'. Add Setoid S1 eqS1' SetoidS1'_bis as S1setoid''.Axiom S2: Set. Axiom eqS2: S2 -> S2 -> Prop. Axiom SetoidS2 : Setoid_Theory S2 eqS2. Add Setoid S2 eqS2 SetoidS2 as S2setoid.Axiom f : S1 -> nat -> S2. Add Morphism f with signature (eqS1 ==> eq ==> eqS2) as f_compat. Admitted. Add Morphism f with signature (eqS1 ==> eq ==> eqS2) as f_compat2. Admitted.Theorem test1: forall x y, (eqS1 x y) -> (eqS2 (f x 0) (f y 0)). intros. rewrite H. reflexivity. Qed.Theorem test1': forall x y, (eqS1 x y) -> (eqS2 (f x 0) (f y 0)). intros. setoid_replace x with y. reflexivity. assumption. Qed.Axiom g : S1 -> S2 -> nat. Add Morphism g with signature (eqS1 ==> eqS2 ==> eq) as g_compat. Admitted.Axiom P : nat -> Prop. Theorem test2: forall x x' y y', (eqS1 x x') -> (eqS2 y y') -> (P (g x' y')) -> (P (g x y)). 
Theorem plus_0_r : forall n, n + 0 = n. Proof. induction n. { reflexivity. } { simpl. rewrite IHn. reflexivity. } Qed. Theorem rewriter : forall n m, (n + 0) + m = n + m. 
Require Import Reals. Require Import PolTac.Open Scope R_scope. Theorem pols_test1: forall (x y : R), x < y -> (x + x < y + x). intros. pols. auto. Qed. Theorem pols_test2: forall (x y : R), 0 < y -> (x < x + y). intros. pols. auto. Qed. Theorem pols_test3: forall (x y : R), 0 < y * y -> ((x + y) * (x - y) < x * x). 
end | Ropp ?e1 => match (RCst e1) with false => constr:(false) | ?e3 => eval vm_compute in (Z.opp e3) end | IZR ?e1 => match (ZCst e1) with false => constr:(false) | ?e3 => e3 end | _ => constr:(false) end. Ltac clean_zabs term := match term with context id [(Z.abs_nat ?X)] => match is_ZCst X with true => let x := eval vm_compute in (Z.abs_nat X) in let y := context id [x] in clean_zabs y | false => term end | _ => term end.Ltac clean_zabs_N term := match term with context id [(Z.abs_N ?X)] => match is_ZCst X with true => let x := eval vm_compute in (Z.abs_N X) in let y := context id [x] in clean_zabs_N y | false => term end | _ => term end.Ltac eqterm t1 t2 := match constr:((t1,t2)) with (?X, ?X) => true | _ => false end.Theorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z. intros; apply trans_equal with y; auto. Qed.Open Scope nat_scope.Theorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c. intros; apply f_equal2 with (f := plus); auto. Qed.Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c. intros a b c H H1; case H. apply plus_reg_l with a; auto. Qed.Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m. intros n m p H; unfold ge; apply plus_le_compat_l; auto. Qed.Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c. intros a b c H H1; case H; subst; auto. Qed.Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m. intros n m p H; unfold ge; apply plus_le_reg_l with p; auto. Qed. Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y). intros x y z H; rewrite H; auto. Qed. Theorem eq_lt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z). intros x y z H; rewrite H; auto. Qed. Theorem eq_gt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y). intros x y z H; rewrite H; auto. Qed. Theorem eq_gt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z). 
_ _ _ _ _ _ _ _ cs) with (multA a0 (plusA (invA a1) a1)); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA (plusA a1 (invA a1)) a0) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA A0 a0) (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA A0 (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (invA (multA a1 a0)) A0); auto. Qed. Theorem mult_invTerm_com_r : forall a b : Term, eqTerm (multTerm a (invTerm b)) (invTerm (multTerm a b)). intros a b; case a; case b; simpl in |- *; auto. intros a0 m a1 m0; split; auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (invA a0)) A0); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (invA a0)) (plusA (multA a1 a0) (invA (multA a1 a0)))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (plusA (multA a1 (invA a0)) (multA a1 a0)) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (plusA (invA a0) a0)) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 (plusA a0 (invA a0))) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA a1 A0) (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (multA A0 a1) (invA (multA a1 a0))); auto. apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA A0 (invA (multA a1 a0))); auto. apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (plusA (invA (multA a1 a0)) A0); auto. Qed. Theorem eqTerm_invTerm_comp : forall a b : Term, eqTerm a b -> eqTerm (invTerm a) (invTerm b). 
None = None -> (forall (i j: option A), f i j = g j i) -> forall (m1 m2: t A), combine f m1 m2 = combine g m2 m1. Proof. intros. apply extensionality; intros i. rewrite ! gcombine by auto. auto. Qed. Fixpoint xelements' {A} (m : tree' A) (i: positive) (k: list (positive * A)) {struct m} : list (positive * A) := match m with | Node001 r => xelements' r (xI i) k | Node010 x => (prev i, x) :: k | Node011 x r => (prev i, x) :: xelements' r (xI i) k | Node100 l => xelements' l (xO i) k | Node101 l r => xelements' l (xO i) (xelements' r (xI i) k) | Node110 l x => xelements' l (xO i) ((prev i, x)::k) | Node111 l x r => xelements' l (xO i) ((prev i, x):: (xelements' r (xI i) k)) end. Definition elements {A} (m : t A) : list (positive * A) := match m with Empty => nil | Nodes m' => xelements' m' xH nil end. Definition xelements {A} (m : t A) (i: positive) : list (positive * A) := match m with Empty => nil | Nodes m' => xelements' m' i nil end. Lemma xelements'_append: forall A (m: tree' A) i k1 k2, xelements' m i (k1 ++ k2) = xelements' m i k1 ++ k2. Proof. induction m; intros; simpl; auto. - f_equal; auto. - rewrite IHm2, IHm1. auto. - rewrite <- IHm. auto. - rewrite IHm2, <- IHm1. auto. Qed. Lemma xelements_Node: forall A (l: tree A) (o: option A) (r: tree A) i, xelements (Node l o r) i = xelements l (xO i) ++ match o with None => nil | Some v => (prev i, v) :: nil end ++ xelements r (xI i). Proof. Local Transparent Node. intros; destruct l, o, r; simpl; rewrite <- ? xelements'_append; auto. Qed. Lemma xelements_correct: forall A (m: tree A) i j v, get i m = Some v -> In (prev (prev_append i j), v) (xelements m j). Proof. intros A. induction m using tree_ind; intros. - discriminate. - rewrite xelements_Node, ! in_app. rewrite gNode in H0. destruct i. + right; right. apply (IHm2 i (xI j)); auto. + left. apply (IHm1 i (xO j)); auto. + right; left. subst o. rewrite prev_append_prev. auto with coqlib. Qed. Theorem elements_correct: forall A (m: t A) (i: positive) (v: A), get i m = Some v -> In (i, v) (elements m). 
(x y: N), {x = y} + {x <> y}. Proof. decide equality. apply peq. Qed. End NIndexed.Module NMap := IMap(NIndexed).Module Type EQUALITY_TYPE. Parameter t: Type. Parameter eq: forall (x y: t), {x = y} + {x <> y}. End EQUALITY_TYPE.Module EMap(X: EQUALITY_TYPE) <: MAP. Definition elt := X.t. Definition elt_eq := X.eq. Definition t (A: Type) := X.t -> A. Definition init (A: Type) (v: A) := fun (_: X.t) => v. Definition get (A: Type) (x: X.t) (m: t A) := m x. Definition set (A: Type) (x: X.t) (v: A) (m: t A) := fun (y: X.t) => if X.eq y x then v else m y. Lemma gi: forall (A: Type) (i: elt) (x: A), init x i = x. Proof. intros. reflexivity. Qed. Lemma gss: forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x. Proof. intros. unfold set. case (X.eq i i); intro. reflexivity. tauto. Qed. Lemma gso: forall (A: Type) (i j: elt) (x: A) (m: t A), i <> j -> (set j x m) i = m i. Proof. intros. unfold set. case (X.eq i j); intro. congruence. reflexivity. Qed. Lemma gsspec: forall (A: Type) (i j: elt) (x: A) (m: t A), get i (set j x m) = if elt_eq i j then x else get i m. Proof. intros. unfold get, set, elt_eq. reflexivity. Qed. Lemma gsident: forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m. Proof. intros. unfold get, set. case (X.eq j i); intro. congruence. reflexivity. Qed. Definition map (A B: Type) (f: A -> B) (m: t A) := fun (x: X.t) => f(m x). Lemma gmap: forall (A B: Type) (f: A -> B) (i: elt) (m: t A), get i (map f m) = f(get i m). Proof. intros. unfold get, map. reflexivity. Qed. End EMap.Module ITree(X: INDEXED_TYPE). Definition elt := X.t. Definition elt_eq := X.eq. Definition t : Type -> Type := PTree.t. Definition empty (A: Type): t A := PTree.empty A. Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m. Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m. Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m. Theorem gempty: forall (A: Type) (i: elt), get i (empty A) = None. 
H6. { intros H6. rewrite plus_comm in H3. apply divides_plus_inv in H3. + apply divides_1_inv, Hp in H3; trivial. + apply divides_mult; trivial. } apply prime_div_mult with (1 := Hp) in H5. destruct H5 as [ H5 | H5 ]; try tauto. apply H6, divides_fact. assert (p <> 0) as H7. { apply prime_ge_2 in Hp; lia. } destruct Hp. split; try lia. apply divides_le in H5; lia. Qed. Theorem seq_of_coprimes n i j : i <= n -> j <= n -> i <> j -> is_gcd (1+i*fact n) (1+j*fact n) 1. Proof. intros H1 H2 H3. destruct (lt_eq_lt_dec i j) as [ [] | ]; try tauto; [ | apply is_gcd_sym ]; apply seq_of_coprimes_lt; lia. Qed.End sequence_of_coprimes.Section Godel_beta. Definition godel_beta a b n := rem a (S ((S n)*b)). Theorem godel_beta_inv n (v : vec nat n) : { a : nat & { b | forall p, godel_beta a b (pos2nat p) = vec_pos v p } }. Proof. set (j := S (lmax (n :: vec_list v))). assert (n < j) as Hm1. { apply le_n_S, lmax_prop; left; auto. } assert (forall p, vec_pos v p < j) as Hm2. { intros p; apply le_n_S, lmax_prop. right; apply vec_list_In. } revert Hm1 Hm2; generalize j; clear j. intros j Hj1 Hj2. set (m := vec_set_pos (fun p : pos n => 1+(S (pos2nat p)*fact j))). destruct (CRT_informative m v) as (w & Hw). + intros p; unfold m; rewrite vec_pos_set; discriminate. + intros p q H; unfold m; repeat rewrite vec_pos_set. apply seq_of_coprimes. * generalize (pos2nat_prop p); lia. * generalize (pos2nat_prop q); lia. * contradict H; inversion H. apply pos2nat_inj; auto. + exists w, (fact j). intros p; unfold godel_beta. generalize (Hw p); unfold m; repeat rewrite vec_pos_set. intros E; unfold plus in E; rewrite E. apply rem_idem. apply lt_le_trans with (1 := Hj2 _). apply le_trans with (S (1*j)); try lia. apply le_n_S, mult_le_compat; try lia. apply divides_le. * generalize (fact_gt_0 j); lia. * apply divides_n_fact_n; lia. Qed. Corollary godel_beta_fun_inv n f : { a : _ & { b | forall p, p < n -> f p = godel_beta a b p } }. Proof. destruct godel_beta_inv with (v := vec_set_pos (fun p : pos n => f (pos2nat p))) as (a & b & H). exists a, b; intros p Hp. specialize (H (nat2pos Hp)). rewrite vec_pos_set, pos2nat_nat2pos in H. auto. Qed. Theorem godel_beta_fun_inv_triples n f : { a : _ & { b | forall p, p < n -> f p = (godel_beta a b ( 3*p), godel_beta a b (1+3*p), godel_beta a b (2+3*p)) } }. 
: poly A0 eqA ltM) (Q : list (poly A0 eqA ltM)), Cb a Q -> Cb b Q -> Cb (spolyp a b) Q. intros a b; case a; case b; simpl in |- *; auto. intros x; case x; auto. intros a0 l H' x0; case x0; auto. intros a1 l0 H'0 Q H'1 H'2. cut (~ zeroP (A:=A) A0 eqA (n:=n) a0); [ intros Z0 | apply canonical_nzeroP with (ltM := ltM) (p := l); auto ]. cut (~ zeroP (A:=A) A0 eqA (n:=n) a1); [ intros Z1 | apply canonical_nzeroP with (ltM := ltM) (p := l0); auto ]. apply CombLinear_comp with (1 := cs) (p := minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) Z0) (pX a0 l)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) Z1) (pX a1 l0))); auto. apply CombLinear_minuspf with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. apply CombLinear_mults1 with (1 := cs); auto. apply spolyf_canonical with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. change (eqP A eqA n (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX a0 l) (pX a1 l0) H' H'0) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) Z0) (pX a0 l)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) Z1) (pX a1 l0)))) in |- *. apply spoly_is_minus with (1 := cs); auto. Qed. Definition unit : poly A0 eqA ltM -> Term A n. intros p; case p. intros x; case x. intros H'; exact (T1 A1 n). intros a l; case a. intros co m H'; cut (~ eqA co A0). intros H'0; exact (divA A1 co H'0, M1 n). inversion H'; auto. simpl in H0. intuition. Defined. Theorem unit_T1 : forall p : poly A0 eqA ltM, eqT (unit p) (T1 A1 n). unfold eqT in |- *; intros p; case p. intros x; case x; simpl in |- *; auto. intros a l; case a; simpl in |- *; auto. Qed. Theorem divA_nZ : forall a b : A, ~ eqA b A0 -> forall nZa : ~ eqA a A0, ~ eqA (divA b a nZa) A0. 
-> x = 0. Proof Group.op_id_r_uniq op_group. Theorem op_id_uniq : forall x : E, Monoid.is_id E {+} x -> x = 0. Proof Group.op_id_uniq op_group. Theorem op_inv_l_r_eq : forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z. Proof Group.op_inv_l_r_eq op_group. Theorem op_inv_sym : forall x y : E, op_is_inv x y <-> op_is_inv y x. Proof Group.op_inv_sym op_group. Theorem op_inv_ex : forall x : E, exists y : E, op_is_inv x y. Proof Group.op_inv_ex op_group. Theorem op_intro_l : forall x y z : E, x = y -> z + x = z + y. Proof Group.op_intro_l op_group. Theorem op_intro_r : forall x y z : E, x = y -> x + z = y + z. Proof Group.op_intro_r op_group. Theorem op_cancel_l : forall x y z : E, z + x = z + y -> x = y. Proof Group.op_cancel_l op_group. Theorem op_cancel_r : forall x y z : E, x + z = y + z -> x = y. Proof Group.op_cancel_r op_group. Theorem op_inv_l_uniq : forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y. Proof Group.op_inv_l_uniq op_group. Theorem op_inv_r_uniq : forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y. Proof Group.op_inv_r_uniq op_group. Theorem op_inv_uniq : forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y. Proof Group.op_inv_uniq op_group. Theorem op_inv_uniq_ex : forall x : E, exists! y : E, op_is_inv x y. Proof Group.op_inv_uniq_ex op_group. Theorem op_inv_0_l : op_is_inv_l 0 0. Proof Group.op_inv_0_l op_group. Theorem op_inv_0_r : op_is_inv_r 0 0. Proof Group.op_inv_0_r op_group. Theorem op_inv_0 : op_is_inv 0 0. Proof Group.op_inv_0 op_group. Theorem op_has_inv_l_0 : has_inv_l 0. Proof Group.op_has_inv_l_0 op_group. Theorem op_has_inv_r_0 : has_inv_r 0. Proof Group.op_has_inv_r_0 op_group. Theorem op_has_inv_0 : has_inv 0. Proof Group.op_has_inv_0 op_group. Theorem op_inv_0_eq_0 : forall x : E, op_is_inv x 0 -> x = 0. Proof Group.op_inv_0_eq_0 op_group. Theorem op_inv_0_uniq : unique (fun x => op_is_inv x 0) 0. Proof Group.op_inv_0_uniq op_group. Definition op_neg_strong : forall x : E, { y | op_is_inv x y } := Group.op_neg_strong op_group. Definition op_neg : E -> E := Group.op_neg op_group.Close Scope nat_scope.Notation "{-}" := (op_neg) : abelian_group_scope.Notation "- x" := (op_neg x) : abelian_group_scope. Theorem op_neg_def : forall x : E, op_is_inv x (- x). Proof Group.op_neg_def op_group. Theorem op_neg_inj : is_injective E E op_neg. 
: ‚àÄ m n ‚àà œâ, m ‚ã n = (m ‚ã n)%œâ. Proof with nauto. intros m Hm n Hn. generalize dependent m. œâ_induction n; intros k Hk. - rewrite ordMul_0_r, mul_0_r... - rewrite ordMul_suc, IH, mul_suc, fin_ordAdd_eq_add, add_comm... Qed. Corollary fin_ordMul_ran : ‚àÄ m n ‚àà œâ, m ‚ã n ‚àà œâ. Proof. intros m Hm n Hn. rewrite fin_ordMul_eq_mul; auto. Qed. Definition PreOrdExp := Œª Œ±, Operation 1 (Œª Œæ, Œæ ‚ã Œ±). Notation "Œ± ^·µñ Œ≤" := (PreOrdExp Œ± Œ≤) (at level 30) : OrdArith_scope.Definition OrdExp : set ‚Üí set ‚Üí set := Œª Œ±, match (ixm (Œ± = 0)) with | inl _ => Œª Œæ, match (ixm (Œæ = 0)) with | inl _ => 1 | inr _ => 0 end | inr _ => PreOrdExp Œ± end. Notation "Œ± ^ Œ≤" := (OrdExp Œ± Œ≤) : OrdArith_scope.Lemma preOrdExp_0_r : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± ^·µñ 0 = 1. Proof. intros Œ± H. apply operation_0. Qed.Theorem ordExp_0_r : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± ^ 0 = 1. Proof with auto. intros Œ± H. unfold OrdExp. destruct (ixm (Œ± = 0)). - destruct (ixm (Embed 0 = 0))... exfalso... - rewrite preOrdExp_0_r... Qed.Lemma preOrdExp_suc : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± ^·µñ Œ≤‚Å∫ = (Œ± ^·µñ Œ≤) ‚ã Œ±. Proof. intros Œ± H. apply operation_suc. Qed.Theorem ordExp_suc : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± ^ Œ≤‚Å∫ = (Œ± ^ Œ≤) ‚ã Œ±. Proof with neauto. intros Œ± HŒ± Œ≤ HŒ≤. unfold OrdExp. destruct (ixm (Œ± = 0)). - destruct (ixm (Œ≤‚Å∫ = 0)). + exfalso. eapply suc_neq_0... + destruct (ixm (Œ≤ = 0)); subst; rewrite ordMul_0_r... - apply preOrdExp_suc... Qed.Lemma preOrdExp_limit : ‚àÄŒ± ‚ãµ ùêéùêç, continuous (PreOrdExp Œ±). Proof. intros Œ± H ùúÜ. apply operation_limit. Qed.Theorem ordExp_limit : ‚àÄŒ± ‚ãµ ùêéùêç, Œ± ‚â 0 ‚Üí continuous (OrdExp Œ±). Proof with nauto. intros Œ± HŒ± HŒ±0 ùúÜ HùúÜ HùúÜ0. unfold OrdExp. destruct (ixm (Œ± = 0)). exfalso... apply preOrdExp_limit... Qed.Lemma preOrdExp_ran : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± ^·µñ Œ≤ ‚ãµ ùêéùêç. Proof. intros Œ± HŒ± Œ≤ HŒ≤. apply operation_operative; nauto. Qed. Local Hint Resolve preOrdExp_ran : core.Theorem ordExp_ran : ‚àÄ Œ± Œ≤ ‚ãµ ùêéùêç, Œ± ^ Œ≤ ‚ãµ ùêéùêç. Proof with nauto. intros Œ± HŒ± Œ≤ HŒ≤. unfold OrdExp. destruct (ixm (Œ± = 0)). - destruct (ixm (Œ≤ = 0))... - apply preOrdExp_ran... Qed. Local Hint Resolve ordExp_ran : core. Local Hint Resolve exp_ran : core. Theorem fin_ordExp_eq_exp : ‚àÄ m n ‚àà œâ, m ^ n = (m ^ n)%œâ. 
eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a1 a0) (b:=a0) (canonical_nzeroP A A0 eqA n ltM a0 l Cpxa1)) l) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a1 a0) (b:=a1) (canonical_nzeroP A A0 eqA n ltM a1 l0 Cpxa0)) l0)))). apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply mults_comp with (1 := cs); auto. apply (eqp_trans _ _ _ _ _ _ _ _ _ cs n) with (y := pluspf (A:=A) A0 (eqA:=eqA) plusA eqA_dec (n:=n) (ltM:=ltM) ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a0) (canonical_nzeroP A A0 eqA n ltM a0 l Cpxa1)) l) (mults (A:=A) multA (n:=n) (invTerm (A:=A) invA (n:=n) (T1 A1 n)) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a0 a1) (b:=a1) (canonical_nzeroP A A0 eqA n ltM a1 l0 Cpxa0)) l0))); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply eqp_pluspf_com with (1 := cs); auto. apply (eqp_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem spolyf_def : forall (a b : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (p q : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX a p)) (Cpxb : canonical A0 eqA ltM (pX b q)), eqP A eqA n (spolyf (pX a p) (pX b q) Cpxa Cpxb) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a b) (b:=a) nZa) p) (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc (A:=A) A1 (n:=n) a b) (b:=b) nZb) q)). intros a b nZa nZb p q Cpxa Cpxb; simpl in |- *; auto. cut (canonical A0 eqA ltM p); [ intros Op1 | auto ]; auto. cut (canonical A0 eqA ltM q); [ intros Op2 | auto ]; unfold LetP in |- *; simpl in |- *; auto. apply canonical_imp_canonical with (a := b); auto. apply canonical_imp_canonical with (a := a); auto. Qed. Hint Resolve spolyf_def. Theorem eqTerm_spolyf_red2 : forall (a b c : Term A n) (nZa : ~ zeroP (A:=A) A0 eqA (n:=n) a) (nZb : ~ zeroP (A:=A) A0 eqA (n:=n) b) (nZppab : ~ zeroP (A:=A) A0 eqA (n:=n) (ppc (A:=A) A1 (n:=n) a b)), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX a p)) (Cpxb : canonical A0 eqA ltM (pX b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults (A:=A) multA (n:=n) (divTerm (A:=A) (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:=ppc (A:=A) A1 (n:=n) a b) nZppab) (spolyf (pX a p) (pX b q) Cpxa Cpxb)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)). 
Notation AxiomaticSpec := (@AxiomaticSpec ADTValue). Notation Value := (@Value ADTValue). Notation Sca := (@SCA ADTValue). Notation Adt := (@ADT ADTValue). Require Import Bedrock.Platform.Cito.WordMap. Import WordMap. Require Import Bedrock.Platform.Cito.WordMapFacts. Import FMapNotations. Local Open Scope fmap_scope. Require Import Bedrock.Platform.Facade.FacadeFacts. Notation CitoSafe := (@Semantics.Safe ADTValue). Ltac pick_related := try match goal with | |- related _ _ => eauto end. Hint Constructors NoDup. Require Bedrock.Platform.Cito.Inv. Lemma mapM_good_inputs args : forall words cinput input h h2 (st : State) vs, mapM (sel st) args = Some input -> cinput = input -> words = List.map vs args -> h2 <= h -> related st (vs, h2) -> NoDup args -> Semantics.good_inputs h (combine words cinput). Proof. simpl; induction args; destruct words; destruct cinput; destruct input; try solve [simpl in *; intros; eauto; try discriminate]; unfold Semantics.good_inputs, Semantics.disjoint_ptrs in *. - simpl in *. intros. intuition. - simpl in *. intros. intuition. - simpl in *. rename a into x. rename v into cv. rename v0 into v. intros h h2 st vs Hmm Hcin Hw Hsm Hr Hnd. destruct (option_dec (sel st x)) as [[y Hy] | Hn]. + rewrite Hy in *. destruct (option_dec (mapM (sel st) args)) as [[ys Hys] | Hn]. * rewrite Hys in *. inject Hmm. inject Hcin. inject Hw. inversion Hnd; subst. rename H1 into Hni. rename H2 into Hnd2. destruct v as [w | a]; simpl in *. { split. - econstructor. + unfold Semantics.word_adt_match. simpl. eapply Hr in Hy; simpl in *. eauto. + eapply IHargs; eauto. - eapply IHargs; eauto. } { split. - econstructor. + unfold Semantics.word_adt_match. simpl. eapply Hr in Hy; simpl in *. eauto. + eapply IHargs; eauto. - econstructor. + nintro. contradict Hni. eapply in_map_iff in H. destruct H as [[w cv] [Hw Hin]]; simpl in *. subst. eapply filter_In in Hin. destruct Hin as [Hin Hadt]; simpl in *. eapply is_adt_iff in Hadt. destruct Hadt as [a' Hcv]. subst. eapply in_nth_error in Hin. destruct Hin as [i Hnc]. eapply nth_error_combine_elim in Hnc. destruct Hnc as [Hia Hii]. eapply nth_error_map_elim in Hia. destruct Hia as [x' [Hia Hvs]]. eapply mapM_nth_error_1 in Hys; eauto. destruct Hys as [v [Hii' Hx']]. unif v. assert (x = x'). { eapply related_no_alias; eauto. } subst. eapply Locals.nth_error_In; eauto. + eapply IHargs; eauto. } * rewrite Hn in *; discriminate. + rewrite Hn in *; discriminate. Qed. Require Import Bedrock.Platform.Facade.Compile. Require Import Bedrock.Platform.Cito.GeneralTactics5. Require Import Bedrock.Platform.Cito.SemanticsFacts8. Theorem compile_safe : forall s_env s s_st, Safe s_env s s_st -> forall vs h h1, h1 <= h -> related s_st (vs, h1) -> forall t_env, cenv_impls_env t_env s_env -> let t := compile s in let t_st := (vs, h) in CitoSafe t_env t t_st. 
PartIR.Hypothesis HF : Derivative_I Hab' F F'. Hypothesis HA : Dom F a. Hypothesis HB : Dom F b. Lemma Law_of_the_Mean_I : forall e, [0] [<] e -> {x : IR | I x | forall Hx, AbsIR (F b HB[-]F a HA[-]F' x Hx[*] (b[-]a)) [<=] e}. Proof. intros e H. set (h := (FId{-} [-C-]a) {*} [-C-] (F b HB[-]F a HA) {-}F{*} [-C-] (b[-]a)) in *. set (h' := [-C-] (F b HB[-]F a HA) {-}F'{*} [-C-] (b[-]a)) in *. cut (Derivative_I Hab' h h'). intro H0. cut {x : IR | I x | forall Hx, AbsIR (h' x Hx) [<=] e}. intro H1. elim H1; intros x Ix Hx. exists x. assumption. intro. eapply leEq_wdl. apply (Hx (derivative_imp_inc' _ _ _ _ _ H0 x Ix)). apply AbsIR_wd; simpl in |- *; rational. unfold I, Hab in |- *; eapply Rolle with h (derivative_imp_inc _ _ _ _ _ H0 _ (compact_inc_lft _ _ _)) (derivative_imp_inc _ _ _ _ _ H0 _ (compact_inc_rht _ _ _)). assumption. simpl in |- *; rational. assumption. unfold h, h' in |- *; clear h h'. New_Deriv. apply Feq_reflexive. apply included_FMinus; Included. apply eq_imp_Feq. apply included_FMinus. apply included_FPlus; Included. Included. Included. intros. simpl in |- *; rational. Qed.End Law_of_the_Mean.Section Corollaries.Variables a b : IR. Hypothesis Hab' : a [<] b. Let Hab := less_leEq _ _ _ Hab'.Variable F : PartIR. Hypothesis HF : Diffble_I Hab' F. Theorem Rolle' : (forall Ha Hb, F a Ha [=] F b Hb) -> forall e, [0] [<] e -> {x : IR | Compact Hab x | forall Hx, AbsIR (PartInt (ProjT1 HF) x Hx) [<=] e}. Proof. intros. unfold Hab in |- *. apply Rolle with F (diffble_imp_inc _ _ _ _ HF _ (compact_inc_lft a b Hab)) (diffble_imp_inc _ _ _ _ HF _ (compact_inc_rht a b Hab)). apply projT2. apply H. assumption. Qed.Lemma Law_of_the_Mean'_I : forall HA HB e, [0] [<] e -> {x : IR | Compact Hab x | forall Hx, AbsIR (F b HB[-]F a HA[-]PartInt (ProjT1 HF) x Hx[*] (b[-]a)) [<=] e}. Proof. intros. unfold Hab in |- *. apply Law_of_the_Mean_I. apply projT2. assumption. Qed.End Corollaries.Section Generalizations.Variable I : interval. Hypothesis pI : proper I.Variables F F' : PartIR.Hypothesis derF : Derivative I pI F F'.Let incF := Derivative_imp_inc _ _ _ _ derF. Let incF' := Derivative_imp_inc' _ _ _ _ derF. Theorem Law_of_the_Mean : forall a b, I a -> I b -> forall e, [0] [<] e -> {x : IR | Compact (Min_leEq_Max a b) x | forall Ha Hb Hx, AbsIR (F b Hb[-]F a Ha[-]F' x Hx[*] (b[-]a)) [<=] e}. 
:: x1). split. rewrite M.gss; auto. split. constructor 2. auto. split. * intro; intros. destructAll. inv H10. inv H11. apply n; auto. apply H8. eexists; eexists; eexists. split; eauto. * intro; intros. destructAll. inv H10. inv H11. apply H6'. eexists. eexists. eexists. eexists. split. apply n. rewrite M.gss. reflexivity. eapply H9. eexists. eexists. eexists. split; eauto. + exists x0, x1. rewrite M.gso; auto. - exists x0, x1. rewrite M.gso. auto. intro; subst. rewrite H6 in Hi0a. inv Hi0a. } Qed. Corollary compute_domain_ienv: forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv) cenv (compute_ind_env cenv). Proof. assert ( forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv /\ correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv)) by apply compute_dc_ienv. simpl; intros. simpl in H. apply H in H0. destruct H0. auto. Qed. Corollary compute_correct_ienv: forall cenv, (fun cenv ienv => proper_cenv cenv -> correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv). Proof. assert ( forall cenv, (fun cenv ienv => proper_cenv cenv -> domain_ienv_cenv cenv ienv /\ correct_ienv_of_cenv cenv ienv) cenv (compute_ind_env cenv)) by apply compute_dc_ienv. simpl; intros. simpl in H. apply H in H0. destruct H0. auto. Qed. Definition correct_fenv_for_function (fenv:fun_env):= fun f (t:fun_tag) (ys:list L6.cps.var) (e:exp) => exists n l, M.get f fenv = Some (n, l) /\ n = N.of_nat (length l) /\ length l = length ys /\ NoDup l /\ Forall (fun i => 0 <= (Z.of_N i) < max_args)%Z l. SearchAbout fun_tag. Definition correct_fenv (fenv:fun_env) (fds:fundefs):= Forall_fundefs (correct_fenv_for_function fenv) fds. Theorem compute_correct_fenv: forall fds fenv, forall fenv', compute_fun_env_fds fds fenv' = fenv -> Forall_fundefs (correct_fenv_for_function fenv) fds. Proof. induction fds; intros. - simpl in H0. inv H. constructor. + admit. + eapply IHfds. auto. reflexivity. - constructor. Qed. *) Definition program_inv (p:program) := program_isPtr_inv p /\ program_threadinfo_inv p /\ program_gc_inv p. Theorem sizeof_uval: forall p, (sizeof p uval) = int_size. Proof. intro. unfold sizeof. chunk_red; archi_red; auto. Qed.Theorem sizeof_val: forall p, (sizeof p val) = int_size. Proof. intro. unfold sizeof. chunk_red; archi_red; auto. Qed. Theorem ptrofs_of_int64: forall x, Ptrofs.repr (Int64.unsigned (Int64.repr x)) = Ptrofs.repr x. Proof. intro. symmetry. eapply Ptrofs.eqm_samerepr. apply Int64.eqm_unsigned_repr. Qed.Theorem ptrofs_of_int: forall x, Archi.ptr64 = false -> Ptrofs.repr (Int.unsigned (Int.repr x)) = Ptrofs.repr x. Proof. intros. symmetry. eapply Ptrofs.eqm_samerepr. apply Ptrofs.eqm32; auto. apply Int.eqm_unsigned_repr. Qed.Theorem sem_cast_vint: forall n m, sem_cast (make_vint n) uval uval m = Some (make_vint n). Proof. intros. unfold sem_cast; chunk_red; simpl; archi_red; simpl; archi_red; auto. Qed. Theorem sem_notbool_val: forall n m, sem_notbool (Val.of_bool n) type_bool m = Some (Val.of_bool (negb n)). 
) ( weq X Y ) . Proof . intros . apply ( isofhlevelsninclb n _ ( isinclpr1weq _ _ ) ) . apply impred . intro . apply is . Defined . Theorem isofhlevelsnweqfromhlevelsn ( n : nat ) ( X Y : UU ) ( is : isofhlevel ( S n ) Y ) : isofhlevel ( S n ) ( weq Y X ) . Proof. intros . apply ( isofhlevelweqf ( S n ) ( weqinvweq X Y ) ( isofhlevelsnweqtohlevelsn n X Y is ) ) . Defined . Theorem isapropweqtocontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqfromcontr ( X : UU ) { Y : UU } ( is : iscontr Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ ( isapropifcontr is ) ) . Defined . Theorem isapropweqtoprop ( X Y : UU ) ( is : isaprop Y ) : isaprop ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ is ) . Defined . Theorem isapropweqfromprop ( X Y : UU )( is : isaprop Y ) : isaprop ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 0 X _ is ) . Defined . Theorem isasetweqtoset ( X Y : UU ) ( is : isaset Y ) : isaset ( weq X Y ) . Proof . intros . apply ( isofhlevelsnweqtohlevelsn 1 _ _ is ) . Defined . Theorem isasetweqfromset ( X Y : UU )( is : isaset Y ) : isaset ( weq Y X ) . Proof. intros . apply ( isofhlevelsnweqfromhlevelsn 1 X _ is ) . Defined . Theorem isapropweqtoempty ( X : UU ) : isaprop ( weq X empty ) . Proof . intro . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropempty ) ) . Defined . Theorem isapropweqtoempty2 ( X : UU ) { Y : UU } ( is : neg Y ) : isaprop ( weq X Y ) . Proof. intros . apply ( isofhlevelsnweqtohlevelsn 0 _ _ ( isapropifnegtrue is ) ) . Defined . Theorem isapropweqfromempty ( X : UU ) : isaprop ( weq empty X ) . 
elim w; clear w. intros w Hrec; elim Hrec; intros a Hrec2; elim Hrec2; intros b; simpl in |- *; case (Qpositive_i w); simpl in |- *. intros p q Heq; exists a; exists (b - a)%Z. rewrite <- Heq; repeat rewrite Znat.inj_plus; ring. intros w Hrec; elim Hrec; intros a Hrec2; elim Hrec2; intros b; simpl in |- *; case (Qpositive_i w); simpl in |- *. intros p q Heq; exists (a - b)%Z; exists b. rewrite <- Heq; repeat rewrite Znat.inj_plus; ring. exists 1%Z; exists 0%Z; simpl in |- *; omega. Qed. Fixpoint Qpositive_inv (w : Qpositive) : Qpositive := match w with | One => One | nR w' => dL (Qpositive_inv w') | dL w' => nR (Qpositive_inv w') end. Theorem inv_correct : forall (w : Qpositive) (p q : nat), Qpositive_i w = (p, q) -> Qpositive_i (Qpositive_inv w) = (q, p). let T_local := (intros w'; simpl in |- *; case (Qpositive_i w'); intros p' q' Hrec p q Heq; rewrite (Hrec p' q'); auto; injection Heq; intros H1 H2; rewrite <- H1; rewrite <- H2; rewrite plus_comm; auto) in (intros w; elim w; clear w; [ T_local | T_local | simpl in |- *; intros p q Heq; injection Heq; intros H1 H2; rewrite <- H1; rewrite <- H2; auto with * ]). Qed. Theorem interp_non_zero : forall w : Qpositive, exists p : nat, (exists q : nat, Qpositive_i w = (S p, S q)). simple induction w; simpl in |- *; (repeat exists 0; auto; fail) || (intros w' Hrec; elim Hrec; intros p' Hex; elim Hex; intros q' Heq; rewrite Heq). exists (p' + S q'); exists q'; auto. exists p'; exists (p' + S q'); auto. Qed. Fixpoint Qpositive_c (p q n : nat) {struct n} : Qpositive := match n with | O => One | S n' => match p - q with | O => match q - p with | O => One | v => dL (Qpositive_c p v n') end | v => nR (Qpositive_c v q n') end end. Theorem minus_O_le : forall n m : nat, n - m = 0 -> n <= m. intros n; elim n; clear n. auto with arith. intros n Hrec m; case m; clear m. simpl in |- *; intros Heq; discriminate Heq. simpl in |- *; intros; apply le_n_S; apply Hrec; auto. Qed. Theorem le_minus_O : forall n m : nat, n <= m -> n - m = 0. 
From Categories Require Import Essentials.Notations. From Categories Require Import Essentials.Types. From Categories Require Import Essentials.Facts_Tactics. From Categories Require Import Category.Main. Record Functor (C C' : Category) : Type := { FO : C ‚Üí C'; FA : ‚àÄ {a b}, (a ‚Äì‚âª b)%morphism ‚Üí ((FO a) ‚Äì‚âª (FO b))%morphism; F_id : ‚àÄ c, FA (id c) = id (FO c); F_compose : ‚àÄ {a b c} (f : (a ‚Äì‚âª b)%morphism) (g : (b ‚Äì‚âª c)%morphism), (FA (g ‚àò f) = (FA g) ‚àò (FA f))%morphism }.Arguments FO {_ _} _ _. Arguments FA {_ _} _ {_ _} _, {_ _} _ _ _ _. Arguments F_id {_ _} _ _. Arguments F_compose {_ _} _ {_ _ _} _ _.Notation "C ‚Äì‚âª D" := (Functor C D) : functor_scope.Bind Scope functor_scope with Functor.Notation "F '_o'" := (FO F) : object_scope.Notation "F '@_a'" := (@FA _ _ F) : morphism_scope.Notation "F '_a'" := (FA F) : morphism_scope.Hint Extern 2 => (apply F_id).Local Open Scope morphism_scope. Local Open Scope object_scope.Ltac Functor_Simplify := progress ( repeat rewrite F_id; ( repeat match goal with | [|- ?F _a ?A = id (?F _o ?x)] => (rewrite <- F_id; (cbn+idtac)) | [|- (id (?F _o ?x)) = ?F _a ?A] => (rewrite <- F_id; (cbn+idtac)) | [|- ?F _a ?A ‚àò ?F _a ?B = ?F _a ?C ‚àò ?F _a ?D] => (repeat rewrite <- F_compose; (cbn+idtac)) | [|- ?F _a ?A ‚àò ?F _a ?B = ?F _a ?C] => (rewrite <- F_compose; (cbn+idtac)) | [|- ?F _a ?C = ?F _a ?A ‚àò ?F _a ?B] => (rewrite <- F_compose; (cbn+idtac)) | [|- context [?F _a ?A ‚àò ?F _a ?B]] => (rewrite <- F_compose; (cbn+idtac)) end ) ) .Hint Extern 2 => Functor_Simplify.Section Functor_eq_simplification. Context {C C' : Category} (F G : (C ‚Äì‚âª C')%functor). Lemma Functor_eq_simplify (Oeq : F _o = G _o) : ((fun x y => match Oeq in _ = V return ((x ‚Äì‚âª y) ‚Üí ((V x) ‚Äì‚âª (V y)))%morphism with eq_refl => F @_a x y end) = G @_a) -> F = G. Proof. destruct F; destruct G. basic_simpl. ElimEq. PIR. trivial. Qed. Theorem FA_extensionality (Oeq : F _o = G _o) : ( ‚àÄ (a b : Obj) (h : (a ‚Äì‚âª b)%morphism), ( fun x y => match Oeq in _ = V return ((x ‚Äì‚âª y) ‚Üí ((V x) ‚Äì‚âª (V y)))%morphism with eq_refl => F @_a x y end ) _ _ h = G _a h ) ‚Üí ( fun x y => match Oeq in _ = V return ((x ‚Äì‚âª y) ‚Üí ((V x) ‚Äì‚âª (V y)))%morphism with eq_refl => F @_a x y end ) = G @_a. 
Require Import PeanoNat.Require Import VerdiRaft.RaftState. Require Import VerdiRaft.Raft.Local Arguments update {_} {_} _ _ _ _ _ : simpl never.Require Export VerdiRaft.CommonDefinitions.Require Import FunInd.Section CommonTheorems. Context {orig_base_params : BaseParams}. Context {one_node_params : OneNodeParams orig_base_params}. Context {raft_params : RaftParams orig_base_params}. Lemma uniqueIndices_elim_eq : forall xs x y, uniqueIndices xs -> In x xs -> In y xs -> eIndex x = eIndex y -> x = y. Proof using. unfold uniqueIndices. eauto using NoDup_map_elim. Qed. Lemma sorted_cons : forall xs a, sorted xs -> (forall a', In a' xs -> eIndex a > eIndex a' /\ eTerm a >= eTerm a') -> sorted (a :: xs). Proof using. intros. simpl in *. intuition; find_apply_hyp_hyp; intuition. Qed. Lemma sorted_subseq : forall ys xs, subseq xs ys -> sorted ys -> sorted xs. Proof using. induction ys; intros; simpl in *. - break_match; intuition. - break_match; intuition. subst. apply sorted_cons; eauto. intros. eauto using subseq_In. Qed. Theorem maxTerm_is_max : forall l e, sorted l -> In e l -> maxTerm l >= eTerm e. 
forall ls (c : W), c <> 0 -> (Ex x, Ex ls', [| ls = x :: ls' |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls' p') ===> lseq' ls c. Axiom lseq'_cons_fwd : forall x ls (c : W), lseq' (x :: ls) c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls p'. End ADT.Module Adt : ADT. Open Scope Sep_scope. Fixpoint lseq' (ls : list W) (p : W) : HProp := match ls with | nil => [| p = 0 |] | x :: ls' => [| p <> 0 |] * [| freeable p 2 |] * Ex p', (p ==*> x, p') * lseq' ls' p' end. Definition lseq (ls : list W) (c : W) : HProp := [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p. Theorem lseq_fwd : forall ls c, lseq ls c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p. unfold lseq; sepLemma. Qed. Theorem lseq_bwd : forall ls (c : W), ([| c <> 0 |] * [| freeable c 2 |] * Ex p, Ex junk, (c ==*> p, junk) * lseq' ls p) ===> lseq ls c. unfold lseq; sepLemma. Qed. Theorem lseq'_empty_fwd : forall ls (c : W), c = 0 -> lseq' ls c ===> [| ls = nil |]. destruct ls; sepLemma. Qed. Theorem lseq'_empty_bwd : forall ls (c : W), c = 0 -> [| ls = nil |] ===> lseq' ls c. destruct ls; sepLemma. Qed. Theorem lseq'_nonempty_fwd : forall ls (c : W), c <> 0 -> lseq' ls c ===> Ex x, Ex ls', [| ls = x :: ls' |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls' p'. destruct ls; sepLemma. Qed. Theorem lseq'_nonempty_bwd : forall ls (c : W), c <> 0 -> (Ex x, Ex ls', [| ls = x :: ls' |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls' p') ===> lseq' ls c. destruct ls; sepLemma. injection H0; sepLemma. Qed. Theorem lseq'_cons_fwd : forall x ls (c : W), lseq' (x :: ls) c ===> [| c <> 0 |] * [| freeable c 2 |] * Ex p', (c ==*> x, p') * lseq' ls p'. 
t t1 -> inpb t (pbleft t1) | inpb_right : forall t t1 t2 : pbtree, inpb t t1 -> inpb t (pbright t1) | inpb_node_l : forall t t1 t2 : pbtree, inpb t t1 -> inpb t (pbnode t1 t2) | inpb_node_r : forall t t1 t2 : pbtree, inpb t t2 -> inpb t (pbnode t1 t2). Hint Constructors inpb : core. Definition pbtree_dec : forall a b : pbtree, {a = b} + {a <> b}. intros a; elim a; simpl in |- *; auto. intros a0 b; case b; try (intros; right; red in |- *; intros; discriminate). intros a1; case (eqA_dec a0 a1); intros H1. left; rewrite H1; auto. right; red in |- *; Contradict H1; inversion H1; auto. intros p H b; case b; try (intros; right; red in |- *; intros; discriminate). intros p1; case (H p1). intros e; rewrite e; auto. intros H1; right; Contradict H1; inversion H1; auto. intros p H b; case b; try (intros; right; red in |- *; intros; discriminate). intros p1; case (H p1). intros e; rewrite e; auto. intros H1; right; Contradict H1; inversion H1; auto. intros p H p0 H0 b; case b; try (intros; right; red in |- *; intros; discriminate). intros p1 p2; case (H p1); intros H1. case (H0 p2); intros H2. left; rewrite H1; rewrite H2; auto. right; Contradict H2; injection H2; auto. right; Contradict H1; injection H1; auto. Defined. Definition inpb_dec : forall a b, {inpb a b} + {~ inpb a b}. intros a b; elim b. intros a0; case a; try (intros; right; red in |- *; intros HH; inversion HH; auto; fail). intros a1; case (eqA_dec a1 a0); intros HH. left; rewrite HH; auto. right; Contradict HH; inversion HH; auto. intros p Hp; case Hp; auto; intros HH. case (pbtree_dec a (pbleft p)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize HH HH1; inversion HH2; auto. intros p Hp; case Hp; auto; intros HH. case (pbtree_dec a (pbright p)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize HH HH1; inversion HH2; auto. intros p H p0 H0. case H; auto; intros H1. case H0; auto; intros H2. case (pbtree_dec a (pbnode p p0)); intros HH1. left; rewrite HH1; auto. right; red in |- *; intros HH2; generalize H1 H2 HH1; inversion HH2; auto. Defined. Theorem inpb_trans : forall t1 t2 t3, inpb t1 t2 -> inpb t2 t3 -> inpb t1 t3. 
Require Import Coq.Strings.String. Require Import Coq.Lists.List. Require Import Coq.Classes.Morphisms. Require Import ChargeCore.Logics.ILogic. Require Import ChargeCore.Tactics.Tactics.Section indexed. Context {L : Type} {ILO : ILogicOps L} {IL : ILogic L}. Theorem destruct_top : forall A B C D : L, A |-- B -->> C -->> D -> A |-- B //\\ C -->> D. 
Require Import Coq.Init.Byte. Require Import Coq.Lists.List.Require Import AesSpec.Sbox. Require Import Cava.Util.List.Section Spec. Variables bytes_per_word Nb : nat. Local Notation word := (list byte) (only parsing). Local Notation state := (list word) (only parsing). Definition sub_bytes : state -> state := map (map forward_sbox). Definition inv_sub_bytes : state -> state := map (map inverse_sbox). Section Properties. Lemma inverse_sbox_prop (x : byte) : inverse_sbox (forward_sbox x) = x. Proof. destruct x; reflexivity. Qed. Theorem inverse_sub_bytes (x : state) : inv_sub_bytes (sub_bytes x) = x. Proof. unfold inv_sub_bytes. unfold sub_bytes. induction x; [reflexivity|]. simpl. rewrite IHx. rewrite map_map. rewrite map_id_ext. { reflexivity. } { intro b. destruct b; reflexivity. } Qed. Theorem sub_bytes_length_outer (x : state) : length (sub_bytes x) = length x. Proof. cbv [sub_bytes]. autorewrite with push_length. reflexivity. Qed. Theorem sub_bytes_length_inner (x : state) n r : (forall r, In r x -> length r = n) -> In r (sub_bytes x) -> length r = n. 
Lemma unification_conservative_backward n (I: orduni n X): 1 <= n -> U X (unification_conservative I) -> OU n X I. Proof. intros Leq (Delta & sigma & T & H). unfold OU. eapply unification_downcast; eauto. Qed. Program Instance SU_monotone {n} (I: ordsysuni X n): ordsysuni X (S n) := { Gamma‚ÇÄ' := @Gamma‚ÇÄ' _ _ I; E‚ÇÄ' := @E‚ÇÄ' _ _ I ; L‚ÇÄ' := @L‚ÇÄ' _ _ I; }. Next Obligation. eapply eqs_ordertyping_step, @H‚ÇÄ'. Qed. Lemma SU_monotone_forward n (I: ordsysuni X n): SOU X n I -> SOU X (S n) (SU_monotone I). Proof. intros (Delta & sigma & T & H). exists Delta; exists sigma. intuition. eapply ordertypingSubst_monotone; eauto. Qed. Lemma SU_monotone_backward n (I: ordsysuni X n): 1 <= n -> SOU X (S n) (SU_monotone I) -> SOU X n I. Proof. intros Leq (Delta & sigma & T & H). unfold OU. edestruct unification_downcast_eqs as (Sigma & tau & H1); eauto using equiv_pointwise_eqs, @H‚ÇÄ'. intros ???; eapply ordertyping_soundness; eauto. exists Sigma, tau; intuition idtac. eauto using equiv_eqs_pointwise. Qed. Program Instance SU_conservative {n} (I: ordsysuni X n): sysuni X := { Gamma·µ§' := @Gamma‚ÇÄ' _ _ I; E·µ§' := @E‚ÇÄ' _ _ I ; L·µ§' := @L‚ÇÄ' _ _ I; }. Next Obligation. eapply eqs_ordertyping_soundness, H‚ÇÄ'. Qed. Lemma SU_conservative_forward n (I: ordsysuni X n): SOU X n I -> SU X (SU_conservative I). Proof. intros (Delta & sigma & T & H). exists Delta; exists sigma. intuition trivial. eapply ordertypingSubst_soundness; eauto. Qed. Lemma SU_conservative_backward n (I: ordsysuni X n): 1 <= n -> SU X (SU_conservative I) -> SOU X n I. Proof. intros Leq (Delta & sigma & T & H). edestruct unification_downcast_eqs as (Sigma & tau & H1); eauto using equiv_pointwise_eqs, @H‚ÇÄ'. exists Sigma, tau; intuition idtac. eauto using equiv_eqs_pointwise. Qed. Theorem unification_step n: 1 <= n -> OU n X ‚™Ø OU (S n) X. Proof. intros H; exists unification_monotone; split; eauto using unification_monotone_forward, unification_monotone_backward. Qed. Theorem unification_steps n m: 1 <= n <= m -> OU n X ‚™Ø OU m X. Proof. intros [H1 H2]; induction H2; eauto using unification_step, Arith.Le.le_trans. Qed. Theorem unification_conserve n: 1 <= n -> OU n X ‚™Ø U X. Proof. intros H; exists unification_conservative; split; eauto using unification_conservative_forward, unification_conservative_backward. Qed. Theorem systemunification_step n: 1 <= n -> @SOU X n ‚™Ø @SOU X (S n). Proof. intros H; exists SU_monotone; split; eauto using SU_monotone_forward, SU_monotone_backward. Qed. Theorem systemunification_steps n m: 1 <= n <= m -> @SOU X n ‚™Ø @SOU X m. 
Set Warnings "-notation-overridden,-parsing". Require Export IndProp.Print ev. Check ev_SS. Theorem ev_4 : ev 4. Proof. apply ev_SS. apply ev_SS. apply ev_0. Qed.Print ev_4. Check (ev_SS 2 (ev_SS 0 ev_0)). Theorem ev_4': ev 4. 
Producer' a m unit := fun _ _ => respond z in @go x' x.Notation "f ~> g" := (f />/ g) (at level 70). Notation "f <~ g" := (g ~> f) (at level 70).Definition await {a y' y m} : Proxy unit a y' y m a := let go : Consumer' a m a := fun _ _ => request tt in @go y' y.Notation "x >~ y" := ((fun _ : unit => x) >\\ y) (at level 70). Notation "x ~< y" := (y >~ x) (at level 70).Section Cat.Variable n : nat. Variable r : Type. Variable d : r.Definition cat `{Monad m} {a} : Pipe a a m r := pull (n:=n) (default:=d) tt.End Cat.Arguments cat {n r d m H a}.Definition connect `{Monad m} `(p1 : Proxy a' a unit b m r) `(p2 : Proxy unit b c' c m r) : Proxy a' a c' c m r := (fun _ : unit => p1) +>> p2.Notation "x >-> y" := (connect x y) (at level 60). Notation "x <-< y" := (y >-> x) (at level 60).Fixpoint next `{Monad m} `(p : Producer a m r) : m (Either r (a * Producer a m r)) := match p with | Request v _ => False_rect _ v | Respond a fu => return_ $ Right (a, fu tt) | M _ g h => h >>= (next \o g) | Pure r => return_ $ Left r end.Definition each `{Monad m} {a} (xs : seq a) : Producer' a m unit := fun _ _ => mapM_ yield xs. Arguments each {m _ a} xs {_ _}.Definition discard `{Monad m} {a} : a -> m unit := fun _ => return_ tt.Definition every `{Monad m} `(xs : seq a) : Producer' a m unit := fun _ _ => foldM (const yield) tt xs. Arguments every {m _ a} xs {_ _}.Module PipesLaws.Include PipesLawsCore.Require Import FunctionalExtensionality. Theorem for_yield_f `{MonadLaws m} : forall `(f : b -> Proxy x' x c' c m unit) x, forP (yield x) f = f x. Proof. move=> *. by rewrite /yield /respond /= /bind /funcomp join_fmap_pure_x. Qed. Theorem for_yield `{MonadLaws m} : forall `(s : Proxy x' x unit b m unit), forP s yield = s. Proof. move=> ? ? ?. by reduce_proxy IHx (rewrite /yield /respond /= /bind /=). Qed. Theorem nested_for_a `{MonadLaws m} : forall `(s : Proxy x' x b' b m a') `(f : b -> Proxy x' x c' c m b') `(g : c -> Proxy x' x d' d m c'), forP s (fun a => forP (f a) g) = forP (forP s f) g. 
H'0; case (Zle_lt_or_eq _ _ H'); intros Zlt1. apply Zmult_gt_0_le_compat_r; auto. apply Zlt_gt; auto. rewrite <- Zlt1; repeat rewrite <- Zmult_0_r_reverse; auto with zarith. Qed. Theorem Zle_Zmult_comp_l : forall x y z : Z, (0 <= z)%Z -> (x <= y)%Z -> (z * x <= z * y)%Z. intros x y z H' H'0; repeat rewrite (Zmult_comm z); apply Zle_Zmult_comp_r; auto. Qed. Theorem NotZmultZero : forall z1 z2 : Z, z1 <> 0%Z -> z2 <> 0%Z -> (z1 * z2)%Z <> 0%Z. intros z1 z2; case z1; case z2; simpl in |- *; intros; auto; try discriminate. Qed. Hint Resolve NotZmultZero: zarith. Theorem IZR_zero : forall p : Z, p = 0%Z -> IZR p = 0%R. intros p H'; rewrite H'; auto. Qed. Hint Resolve not_O_INR: real. Theorem IZR_zero_r : forall p : Z, IZR p = 0%R -> p = 0%Z. intros p; case p; simpl in |- *; auto. intros p1 H'; Contradict H'; auto with real zarith. intros p1 H'; absurd (INR (nat_of_P p1) = 0%R); auto with real zarith. rewrite <- (Ropp_involutive (INR (nat_of_P p1))). unfold IZR in H'; rewrite <- INR_IPR in H'. rewrite H'; auto with real. Qed. Theorem INR_lt_nm : forall n m : nat, n < m -> (INR n < INR m)%R. intros n m H'; elim H'; auto. replace (INR n) with (INR n + 0)%R; auto with real; rewrite S_INR; auto with real. intros m0 H'0 H'1. replace (INR n) with (INR n + 0)%R; auto with real; rewrite S_INR; auto with real. Qed. Hint Resolve INR_lt_nm: real. Theorem Rlt_INR1 : forall n : nat, 1 < n -> (1 < INR n)%R. replace 1%R with (INR 1); auto with real. Qed. Hint Resolve Rlt_INR1: real. Theorem NEq_INR : forall n m : nat, n <> m -> INR n <> INR m. intros n m H'; (case (le_or_lt n m); intros H'1). case (le_lt_or_eq _ _ H'1); intros H'2. apply Rlt_dichotomy_converse; auto with real. Contradict H'; auto. apply Compare.not_eq_sym; apply Rlt_dichotomy_converse; auto with real. Qed. Hint Resolve NEq_INR: real. Theorem NEq_INRO : forall n : nat, n <> 0 -> INR n <> 0%R. replace 0%R with (INR 0); auto with real. Qed. Hint Resolve NEq_INRO: real. Theorem NEq_INR1 : forall n : nat, n <> 1 -> INR n <> 1%R. replace 1%R with (INR 1); auto with real. Qed. Hint Resolve NEq_INR1: real. Theorem not_O_lt : forall n : nat, n <> 0 -> 0 < n. 
z)->(Rstar x z)->P] (H P [z:A][H1:(Rstar x z)][H2:(Rstar y z)](H0 z H2 H1))).Theorem Diagram: (x:A) ((u:A) (R x u) ->([x0:A] (y:A)(z:A)(Rstar x0 y)->(Rstar x0 z)->(coherence y z) u)) ->(y:A) (z:A) (u:A) (R x u) ->(Rstar u y) ->(v:A)(R x v)->(Rstar v z)->(coherence y z). Proof [x:A] [hyp_ind:(u:A) (R x u)->(y:A)(z:A)(Rstar u y)->(Rstar u z)->(coherence y z)] [y,z:A] [u:A] [t1:(R x u)] [t2:(Rstar u y)] [v:A] [u1:(R x v)] [u2:(Rstar v z)] (unf_coherence [P:A->A->Prop] ((x0:A)(y0:A)(z0:A)(R x0 y0)->(R x0 z0)->(P y0 z0)) ->((u0:A) (R x u0) ->(y0:A)(z0:A)(Rstar u0 y0)->(Rstar u0 z0)->(P y0 z0)) ->(coherence y z) [Hyp0:(x0:A) (y0:A) (z0:A) (R x0 y0) ->(R x0 z0) ->(P:Prop) ((z1:A)(Rstar y0 z1)->(Rstar z0 z1)->P)->P] [hyp_ind0:(u0:A) (R x u0) ->(y0:A) (z0:A) (Rstar u0 y0) ->(Rstar u0 z0) ->(P:Prop) ((z1:A) (Rstar y0 z1)->(Rstar z0 z1)->P) ->P] (Hyp0 x u v t1 u1 (coherence y z) [z0:A] [H:(Rstar u z0)] [H0:(Rstar v z0)] (hyp_ind0 u t1 y z0 t2 H (coherence y z) [z1:A] [H1:(Rstar y z1)] [H2:(Rstar z0 z1)] (hyp_ind0 v u1 z z1 u2 (Rstar_transitive v z0 z1 H0 H2) (coherence y z) [z2:A] [H3:(Rstar z z2)] [H4:(Rstar z1 z2)] (unf_coherence [P:A->A->Prop](P y z) [P:Prop] [H5:(z3:A)(Rstar y z3)->(Rstar z z3)->P] (H5 z2 (Rstar_transitive y z1 z2 H1 H4) H3))))) Hyp2 hyp_ind).Theorem caseRxy: (x:A) ((u:A) (R x u) ->(y:A)(z:A)(Rstar u y)->(Rstar u z)->(coherence y z)) ->(y:A) (z:A) (Rstar x y) ->(Rstar x z) ->(u:A)(R x u)->(Rstar u y)->(coherence y z). Proof [x:A] [hyp_ind:(u:A) (R x u)->(y:A)(z:A)(Rstar u y)->(Rstar u z)->(coherence y z)] [y,z:A] [h1:(Rstar x y)] [h2:(Rstar x z)] [u:A] [t1:(R x u)] [t2:(Rstar u y)] (unf_Rstar' [P:A->A->Prop](P x z)->(coherence y z) [hyp_:(P:A->A->Prop) (P x x) ->((u0:A)(R x u0)->(Rstar u0 z)->(P x z))->(P x z)] (hyp_ [_:A][a:A](coherence y a) (coherence_sym x y (Rstar_coherence x y h1)) (Diagram x hyp_ind y z u t1 t2)) (Rstar_Rstar' x z h2)). Theorem Ind_proof : (x:A) ((u:A) (R x u) ->(y:A)(z:A)(Rstar u y)->(Rstar u z)->(coherence y z)) ->(y:A)(z:A)(Rstar x y)->(Rstar x z)->(coherence y z). Proof [x:A] [hyp_ind:(u:A) (R x u)->(y:A)(z:A)(Rstar u y)->(Rstar u z)->(coherence y z)] [y,z:A] [h1:(Rstar x y)] [h2:(Rstar x z)] (unf_Rstar' [P:A->A->Prop](P x y)->(coherence y z) [hyp_:(P:A->A->Prop) (P x x)->((u:A)(R x u)->(Rstar u y)->(P x y))->(P x y)] (hyp_ [_:A][a:A](coherence a z) (Rstar_coherence x z h2) (caseRxy x hyp_ind y z h1 h2)) (Rstar_Rstar' x y h1)). Syntactic Definition local_confluent := (x:A)(y:A)(z:A)(R x y)->(R x z)->(coherence y z). Syntactic Definition noetherian := (x:A)(P:A->Prop)((y:A)((z:A)(R y z)->(P z))->(P y))->(P x). Theorem Newman : (x:A)(y:A)(z:A)(Rstar x y)->(Rstar x z)->(coherence y z). 
id c out st l net, handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st). Proof using tsi. unfold logs_sorted_host. intros. find_apply_lem_hyp handleClientRequest_log. intuition. + repeat find_rewrite. eauto. + find_apply_lem_hyp no_entries_past_current_term_invariant. break_exists; intuition; repeat find_rewrite. simpl. intuition eauto. * find_eapply_lem_hyp maxIndex_is_max; eauto. omega. * unfold no_entries_past_current_term, no_entries_past_current_term_host in *. intuition. simpl in *. find_apply_hyp_hyp. omega. Qed. Theorem logs_sorted_client_request : raft_net_invariant_client_request logs_sorted. Proof using tsi. unfold raft_net_invariant_client_request. unfold logs_sorted. intuition. - unfold logs_sorted_host in *. simpl in *. intros. find_higher_order_rewrite. break_match; eauto. subst. eauto using handleClientRequest_logs_sorted. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using logs_sorted_nw_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_gt_prevIndex_packets_unchanged. - find_apply_lem_hyp handleClientRequest_packets. subst. simpl in *. eauto using packets_ge_prevTerm_packets_unchanged. Qed. Theorem handleTimeout_log : forall h st out st' ps, handleTimeout h st = (out, st', ps) -> log st' = log st. Proof using. intros. unfold handleTimeout, tryToBecomeLeader in *. break_match; find_inversion; subst; auto. Qed. Theorem logs_sorted_nw_only_new_packets_matter : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> logs_sorted_nw (mkNetwork l st') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem logs_sorted_nw_no_append_entries : forall net ps' l st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. eapply logs_sorted_nw_only_new_packets_matter; eauto. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem logs_sorted_nw_not_append_entries : forall net ps' p' st', logs_sorted_nw net -> (forall p, In p ps' -> In p (nwPackets net) \/ p = p') -> ~ is_append_entries (pBody p') -> logs_sorted_nw (mkNetwork ps' st'). Proof using. intros. unfold logs_sorted_nw. intros. simpl in *. find_apply_hyp_hyp. intuition. - unfold logs_sorted_nw in *. eauto. - subst. exfalso. match goal with H : _ |- _ => apply H end. repeat eexists; eauto. Qed. Theorem packets_gt_prevIndex_only_new_packets_matter : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> packets_gt_prevIndex (mkNetwork l st') -> packets_gt_prevIndex (mkNetwork ps' st'). Proof using. unfold packets_gt_prevIndex. intros. simpl in *. find_apply_hyp_hyp. intuition eauto. Qed. Theorem packets_gt_prevIndex_no_append_entries : forall net ps' l st', packets_gt_prevIndex net -> (forall p, In p ps' -> In p (nwPackets net) \/ In p l) -> (forall p, In p l -> ~ is_append_entries (pBody p)) -> packets_gt_prevIndex (mkNetwork ps' st'). 
split; auto. rewrite H1. destruct H2 as (H2 & H3). mma sss DEC zero with (pos_right 2 x) (lnk j). ++ now generalize (f_equal (fun v => v#>x) H3); rew vec; intros ->. ++ mma sss stop. * intros a Ha. apply mma_sss_DEC1_inv with (u := a) in H; auto. destruct H as (-> & ->). revert v1 w1 a Ha. pattern x; revert x; apply pos_left_right_rect; intros x v1 w1 a Ha. - rewrite icomp_eq_3, mma_div_branch_length. intros H1 (H2 & H3). set (v' := let (v,_) := vec_split _ _ v1 in v); simpl in v'. exists (w1[(gc_enc gc (v'[a/x]))/pos1]); msplit 2; rew vec. ++ apply mma_div_branch_0_progress with (gc_enc gc (v'[a/x])); try easy. ** generalize (f_equal (fun v => v#>pos0) H2); rew vec. ** generalize (f_equal (fun v => v#>pos1) H2); rew vec; simpl; intros ->. rewrite mult_comm, gc_succ; f_equal; rew vec. unfold v'; rewrite <- Ha. apply vec_pos_ext; intros p; rewrite !vec_pos_set. destruct (pos_eq_dec p x) as [ -> | D ]; rew vec. ++ apply vec_pos_ext; intros p; repeat invert pos p; simpl; rew vec. ** generalize (f_equal (fun v => v#>pos0) H2); rew vec. ** f_equal; unfold v'. apply vec_pos_ext; intros p; rew vec; rewrite !vec_pos_set. destruct (pos_eq_dec p x) as [ -> | D ]; rew vec; rewrite vec_pos_set. rewrite vec_change_neq; auto. now contradict D; apply pos_left_inj in D. ++ apply vec_pos_ext; intros p; rew vec. generalize (f_equal (fun v => v#> p) H3); rew vec; rewrite ! vec_pos_set. simpl; intros ->; rewrite vec_change_neq; auto. apply pos_left_right_neq. - rewrite icomp_eq_4; simpl. intros H1 (H2 & H3). exists (w1[a/pos_right 2 x]); msplit 2; simpl pos_right; rew vec. ++ mma sss DEC S with (pos_right 2 x) (lnk j) a. ** now generalize (f_equal (fun v => v#>x) H3); rew vec; intros ->. ** mma sss stop. ++ apply vec_pos_ext; intros p; repeat invert pos p; rew vec. ** generalize (f_equal (fun v => v#>pos0) H2); rew vec. ** generalize (f_equal (fun v => v#>pos1) H2); rew vec; simpl; intros ->. f_equal; apply vec_pos_ext; intros p; rew vec. rewrite vec_change_neq; auto. intros E; symmetry in E; revert E; apply pos_left_right_neq. ++ apply vec_pos_ext; intros p; rewrite !vec_pos_set. destruct (pos_eq_dec x p) as [ -> | D ]; rew vec. rewrite !vec_change_neq; auto. 2,3: contradict D. 2: now apply pos_right_inj in D. 2: now repeat apply pos_nxt_inj in D. generalize (f_equal (fun v => v#>p) H3);rew vec. Qed. Theorem mma_k_mma_2_compiler : compiler_t (@mma_sss (k+n)) (@mma_sss (2+n)) simul. 
(t : rectype) (w : word (len (RecF t))) : recdata t := match t as t return word (len (RecF t)) -> recdata t with | nil => fun _ => tt | (_, ft) :: t' => fun w => (of_word (split1 (len ft) (len (RecF t')) w), word2rec t' (split2 (len ft) (len (RecF t')) w)) end w) rt ((fix rec2word {t : rectype} (r : recdata t) : word (len (RecF t)) := match t as t return recdata t -> word (len (RecF t)) with | nil => fun _ => WO | (_, _) :: _ => fun r => let (v, r') := r in combine (to_word v) (rec2word r') end r) rt v) = v). apply IHt. simpl. intros v t. destruct v. trivial. simpl. intro v. destruct v. intro Hrl. destruct Hrl. rewrite split1_combine. rewrite split2_combine. rewrite IHt0 by assumption. rewrite IHt by assumption. trivial. Qed. Theorem to_eq : forall ft a b, @to_word ft a = @to_word ft b -> well_formed a -> well_formed b -> a = b. Proof. intros. rewrite <- Rec.of_to_id with (v := a) by auto. rewrite <- Rec.of_to_id with (v := b) by auto. congruence. Qed. Theorem of_eq : forall ft a b, @of_word ft a = @of_word ft b -> a = b. Proof. intros. rewrite <- Rec.to_of_id with (w := a). rewrite <- Rec.to_of_id with (w := b). congruence. Qed. Lemma of_word_empty : forall t n w, n = 0 -> @of_word (ArrayF t n) w = nil. Proof. intros. generalize w. rewrite H. intros. simpl in w0. apply length_nil. reflexivity. Qed. Theorem of_word_length : forall ft w, well_formed (@of_word ft w). Proof. einduction ft using type_rect_nest. simpl. trivial. simpl. induction n. split; trivial. intro w. edestruct IHn. split. simpl. rewrite H. trivial. simpl. constructor. apply IHt. assumption. apply IHt. simpl. trivial. simpl. intro w. split. apply IHt. apply IHt0. Qed. Theorem of_word_well_formed : forall (ft:type) w, well_formed (@of_word ft w). Proof. apply of_word_length. Qed. Theorem array_of_word_length : forall ft n w, List.length (@of_word (ArrayF ft n) w) = n. Proof. induction n; intros; simpl. reflexivity. f_equal. apply IHn. Qed. Theorem to_word_append_any: forall sz l n l2, Datatypes.length l > n -> @to_word (ArrayF (WordF sz) n) (app l l2) = @to_word (ArrayF (WordF sz) n) l. Proof. simpl. induction l; simpl; induction n; intros; auto; try omega. f_equal. apply IHl. omega. Qed. Theorem to_word_append_zeroes: forall sz l n m, @to_word (ArrayF (WordF sz) n) (app l (repeat $0 m)) = @to_word (ArrayF (WordF sz) n) l. 
Sig_MONADIC_Sig_11. Variable (Œ£ : fo_signature) (HŒ£1 : forall s, ar_syms Œ£ s <= 1) (HŒ£2 : forall r, ar_rels Œ£ r <= 1). Theorem FSAT_FULL_MONADIC_FSAT_11 : FSAT Œ£ ‚™Ø·µ¢ FSAT (Œ£11 (syms Œ£) (rels Œ£)). Proof using HŒ£2 HŒ£1. apply ireduces_transitive with (Q := FSAT (Œ£no_props Œ£)). + exists (Œ£rem_props HŒ£2 0); intros A. apply exists_equiv; intro; apply Œ£rem_props_correct. + assert (forall s, ar_syms (Œ£no_props Œ£) s <= 1) as H1. { simpl; auto. } exists (Œ£rem_constants H1 0); intros A. apply exists_equiv; intro; apply Œ£rem_constants_correct. Qed.End Sig_MONADIC_Sig_11.Section Sig_MONADIC_PROP. Variable (Œ£ : fo_signature) (HŒ£ : forall r, ar_rels Œ£ r = 0). Theorem FSAT_PROP_FSAT_x0 : FSAT Œ£ ‚™Ø·µ¢ FSAT (Œ£0 Œ£). Proof using HŒ£. exists (@Œ£_Œ£0 Œ£); exact (Œ£_Œ£0_correct HŒ£). Qed. Theorem FSAT_x0_FSAT_PROP : FSAT (Œ£0 Œ£) ‚™Ø·µ¢ FSAT Œ£. Proof using HŒ£. exists (Œ£0_Œ£ HŒ£); exact (Œ£0_Œ£_correct HŒ£). Qed.End Sig_MONADIC_PROP.Section FSAT_MONADIC_DEC. Variable (F P : Type) (H1 : F -> False) (H2 : discrete P) (A : fol_form (Œ£11 F P)). Theorem FSAT_MONADIC_DEC : decidable (FSAT _ A). Proof using H2 H1. destruct Sig_discrete_to_pos with (A := A) as (n & m & i & j & B & HB). + simpl; intros s; destruct (H1 s). + apply H2. + assert (n = 0) as ->. { destruct n; auto. destruct (H1 (i pos0)). } simpl in *. destruct FSAT_Œ£P1_dec with (V := pos 0) (A := B) as [ H | H ]. * intros p; invert pos p. * left; apply HB; auto. * right; rewrite HB; auto. Qed.End FSAT_MONADIC_DEC.Section FSAT_MONADIC_11_FSAT_MONADIC_1. Variable (n : nat) (Y : Type) (HY : finite_t Y). Theorem FSAT_MONADIC_11_FSAT_MONADIC_1 : FSAT (Œ£11 (pos n) Y) ‚™Ø·µ¢ FSAT (Œ£11 Empty_set (list (pos n)*Y + Y)). Proof using HY. apply ireduces_dependent, Œ£11_Œ£1_reduction; auto. Qed.End FSAT_MONADIC_11_FSAT_MONADIC_1.Section FSAT_Œ£11_DEC. Variable (n : nat) (P : Type) (HP1 : finite_t P) (HP2 : discrete P) (A : fol_form (Œ£11 (pos n) P)). Theorem FSAT_Œ£11_DEC : decidable (FSAT _ A). Proof using HP2 HP1. destruct FSAT_MONADIC_11_FSAT_MONADIC_1 with (n := n) (1 := HP1) as (f & Hf). specialize (Hf A). destruct FSAT_MONADIC_DEC with (A := f A) as [ H | H ]; simpl; auto; try easy. + left; revert H; apply Hf. + right; contradict H; revert H; apply Hf. Qed.End FSAT_Œ£11_DEC.Section FSAT_FULL_Œ£11_DEC. Variable (F P : Type) (HF : discrete F) (HP : discrete P) (A : fol_form (Œ£11 F P)). Hint Resolve finite_t_pos : core. Theorem FSAT_FULL_Œ£11_DEC : decidable (FSAT _ A). 
n m, (m <= n -> -n <= -m)%Z. auto with zarith. Qed.Theorem Zle_pos_neg: forall x, (0 <= -x -> x <= 0)%Z. auto with zarith. Qed.Theorem Zle_sign_pos_neg: forall x y: Z, (0 <= x -> y <= 0 -> x * y <= 0)%Z. intros x y H1 H2; apply Zle_pos_neg; replace (- (x * y))%Z with (x * (- y))%Z; auto with zarith; ring. Qed.Theorem Zle_sign_neg_pos: forall x y: Z, (x <= 0 -> 0 <= y -> x * y <= 0)%Z. intros x y H1 H2; apply Zle_pos_neg; replace (- (x * y))%Z with (-x * y)%Z; auto with zarith; ring. Qed. Theorem Zlt_sign_pos_pos: forall x y: Z, (0 < x -> 0 < y -> 0 < x * y)%Z. intros; apply Zmult_lt_O_compat; auto with zarith. Qed.Theorem Zlt_sign_neg_neg: forall x y: Z, (x < 0 -> y < 0 -> 0 < x * y)%Z. intros x y H1 H2; replace (x * y)%Z with (-x * -y)%Z; auto with zarith; try ring. apply Zmult_lt_O_compat; auto with zarith. Qed.Theorem Zlt_pos_neg: forall x, (0 < -x -> x < 0)%Z. auto with zarith. Qed.Theorem Zlt_sign_pos_neg: forall x y: Z, (0 < x -> y < 0 -> x * y < 0)%Z. intros x y H1 H2; apply Zlt_pos_neg; replace (- (x * y))%Z with (x * (- y))%Z; auto with zarith; try ring. apply Zmult_lt_O_compat; auto with zarith. Qed.Theorem Zlt_sign_neg_pos: forall x y: Z, (x < 0 -> 0 < y -> x * y < 0)%Z. intros x y H1 H2; apply Zlt_pos_neg; replace (- (x * y))%Z with (-x * y)%Z; auto with zarith; try ring. apply Zmult_lt_O_compat; auto with zarith. Qed.Theorem Zge_sign_neg_neg: forall x y: Z, (0 >= x -> 0 >= y -> x * y >= 0)%Z. intros; apply Z.le_ge; apply Zle_sign_neg_neg; auto with zarith. Qed.Theorem Zge_sign_pos_pos: forall x y: Z, (x >= 0 -> y >= 0 -> x * y >= 0)%Z. intros; apply Z.le_ge; apply Zle_sign_pos_pos; auto with zarith. Qed.Theorem Zge_neg_pos: forall x, (0 >= -x -> x >= 0)%Z. auto with zarith. Qed.Theorem Zge_sign_neg_pos: forall x y: Z, (0 >= x -> y >= 0 -> 0>= x * y)%Z. intros; apply Z.le_ge; apply Zle_sign_neg_pos; auto with zarith. Qed.Theorem Zge_sign_pos_neg: forall x y: Z, (x >= 0 -> 0 >= y -> 0 >= x * y)%Z. intros; apply Z.le_ge; apply Zle_sign_pos_neg; auto with zarith. Qed. Theorem Zgt_sign_neg_neg: forall x y: Z, (0 > x -> 0 > y -> x * y > 0)%Z. 
[] ]; simpl; auto; lia. Qed. Hint Resolve bsm_instr_compile_length_eq bsm_instr_compile_length_geq : core. Lemma bsm_instr_compile_sound : instruction_compiler_sound bsm_instr_compile (@bsm_sss _) (@mm_sss _) bsm_state_enc. Proof using Hvr1 Hvr2 Hvr3 Hv12 Hv13 Hv23 Hreg. intros lnk I i1 v1 i2 v2 w1 H; revert H w1. change v1 with (snd (i1,v1)) at 2. change i1 with (fst (i1,v1)) at 2 3 4 6 7 8. change v2 with (snd (i2,v2)) at 2. change i2 with (fst (i2,v2)) at 2. generalize (i1,v1) (i2,v2); clear i1 v1 i2 v2. induction 1 as [ i p j k v Hv | i p j k v ll Hll | i p j k v ll Hll | i p [] v ]; simpl; intros w1 H0 H; generalize H; intros (H1 & H2 & Htmp3 & H3). + exists w1; split; auto. apply mm_pop_void_progress; auto using Hv12, Hvr1, Hvr2. rewrite H3, Hv; auto. + exists (w1[(stack_enc ll)/reg p]); repeat split; auto; rew vec. * apply mm_pop_Zero_progress; auto using Hv12, Hvr1, Hvr2. rewrite H3, Hll; auto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc ll)/reg p]); repeat split; auto; rew vec. * apply mm_pop_One_progress; auto using Hv12, Hvr1, Hvr2. rewrite H3, Hll; auto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc (One::v#>p))/reg p]); repeat split; auto; rew vec. 2:{ rewrite vec_change_neq. 2: congruence. eauto. } 2:{ rewrite vec_change_neq. 2: congruence. eauto. } 2:{ rewrite vec_change_neq. 2: congruence. eauto. } rewrite H0; apply mm_push_One_progress; auto using Hv12, Hvr1, Hvr2. intros q; dest p q. assert (reg p <> reg q); rew vec. + exists (w1[(stack_enc (Zero::v#>p))/reg p]); repeat split; auto; rew vec. rewrite H0; apply mm_push_Zero_progress; auto using Hv12, Hvr1, Hvr2. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * rewrite vec_change_neq. 2: congruence. eauto. * intros q; dest p q. assert (reg p <> reg q); rew vec. Qed. Hint Resolve bsm_instr_compile_sound : core. Theorem bsm_mm_compiler : compiler_t (@bsm_sss _) (@mm_sss _) bsm_state_enc. Proof using Hvr3 Hvr2 Hvr1 Hv23 Hv13 Hv12 Hreg. apply generic_compiler with (icomp := bsm_instr_compile) (ilen := bsm_instr_compile_length); auto. + apply bsm_sss_total'. + apply mm_sss_fun. Qed. Theorem bsm_mm_simulator i (P : list (@bsm_instr m)) j : { Q : list (@mm_instr (pos n)) | forall v w, bsm_state_enc v w -> (forall i' v', (i,P) /BSM/ (i,v) ~~> (i',v') -> exists w', (j,Q) /MM/ (j,w) ~~> (j+length Q,w') /\ bsm_state_enc v' w') /\ ((j,Q) /MM/ (j,w) ‚Üì -> (i,P) /BSM/ (i,v) ‚Üì) }. 
- tauto. - rewrite IHxs in H. rewrite andb_true_iff in H. split; try tauto. constructor; simpl; tauto. - dest. inv H. unfold utila_is_true in *; simpl in *. pose proof (conj H4 H3). rewrite <- IHxs in H. auto. Qed. Theorem fold_left_andb_forall : forall xs : list (Bool @# type), fold_left andb (map (@evalExpr _) xs) true = true <-> Forall utila_is_true xs. Proof. intros. rewrite fold_left_andb_forall'. tauto. Qed. Theorem utila_all_correct : forall xs : list (Bool @# type), utila_all xs ==> true <-> Forall utila_is_true xs. Proof. apply fold_left_andb_forall. Qed. Theorem fold_left_andb_forall_false' : forall (xs : list (Bool @# type)) a, fold_left andb (map (@evalExpr _) xs) a = false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs \/ a = false. Proof. induction xs; simpl; auto; intros; split; try tauto. - intros; auto. destruct H; auto. inv H. - rewrite IHxs. intros. rewrite andb_false_iff in H. destruct H. + left. right; auto. + destruct H. * auto. * left. left. auto. - intros. rewrite IHxs. rewrite andb_false_iff. destruct H. + inv H; auto. + auto. Qed. Theorem fold_left_andb_forall_false : forall xs : list (Bool @# type), fold_left andb (map (@evalExpr _) xs) true = false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. Proof. intros. rewrite fold_left_andb_forall_false'. split; intros. - destruct H; congruence. - auto. Qed. Theorem utila_all_correct_false : forall xs : list (Bool @# type), utila_all xs ==> false <-> Exists (fun x : Expr type (SyntaxKind Bool) => evalExpr x = false) xs. Proof. apply fold_left_andb_forall_false. Qed. Theorem fold_left_orb_exists' : forall (xs : list (Bool @# type)) a, fold_left orb (map (@evalExpr _) xs) a = true <-> Exists utila_is_true xs \/ a = true. Proof. induction xs; simpl; auto; split; intros; try discriminate. - auto. - destruct H; auto. inv H. - rewrite IHxs in H. rewrite orb_true_iff in H. destruct H. + left. right. auto. + destruct H; auto. - assert (sth: Exists utila_is_true xs \/ (a0||evalExpr a)%bool = true). { destruct H. - inv H. + right. rewrite orb_true_iff. auto. + auto. - right. rewrite orb_true_iff. auto. } rewrite <- IHxs in sth. auto. Qed. Theorem fold_left_orb_exists : forall xs : list (Bool @# type), fold_left orb (map (@evalExpr _) xs) false = true <-> Exists utila_is_true xs. Proof. intros. rewrite fold_left_orb_exists'. split; intros; auto. destruct H; congruence. Qed. Theorem utila_any_correct : forall xs : list (Bool @# type), utila_any xs ==> true <-> Exists utila_is_true xs. 
_) (_, _) (Exp_morph_ex z f, id c)))%morphism; Exp_morph_unique : ‚àÄ (z : C) (f : ((√ó·∂ ‚Åø·∂ú C) _o (z, c))%object --> d) (u u' : z --> exponential), f = (eval ‚àò ((√ó·∂ ‚Åø·∂ú C) @_a (_, _) (_, _) (u, id c)))%morphism ‚Üí f = (eval ‚àò ((√ó·∂ ‚Åø·∂ú C) @_a (_, _) (_, _) (u', id c)))%morphism ‚Üí u = u' }.Coercion exponential : Exponential >-> Obj.Arguments Exponential _ {_} _ _, {_ _} _ _.Arguments exponential {_ _ _ _} _, {_ _} _ _ {_}. Arguments eval {_ _ _ _} _, {_ _} _ _ {_}. Arguments Exp_morph_ex {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _. Arguments Exp_morph_com {_ _ _ _} _ _ _, {_ _} _ _ {_} _ _. Arguments Exp_morph_unique {_ _ _ _} _ _ _ _ _ _ _, {_ _} _ _ {_} _ _ _ _ _ _.Notation "a ‚áë b" := (Exponential a b) : object_scope. Theorem Exponential_iso {C : Category} {HP : Has_Products C} (c d : C) (E E' : (c ‚áë d)%object) : (E ‚âÉ E')%isomorphism. Proof. eapply (Build_Isomorphism _ _ _ (Exp_morph_ex E' _ (eval E)) (Exp_morph_ex E _ (eval E'))); eapply Exp_morph_unique; eauto; simpl_ids; match goal with [|- (_ ‚àò ?M)%morphism = _] => match M with (?U _a (?A ‚àò ?B, ?C))%morphism => assert (M = (U @_a (_, _) (_, _) (A, C)) ‚àò (U @_a (_, _) (_, _) (B, C)))%morphism as HM; [simpl_ids; rewrite <- F_compose; simpl; simpl_ids; trivial|rewrite HM] end end; rewrite <- assoc; repeat rewrite <- Exp_morph_com; auto. Qed.Definition Has_Exponentials (C : Category) {HP : Has_Products C} := ‚àÄ a b, (a ‚áë b)%object.Existing Class Has_Exponentials.Section Curry_UnCurry. Context (C : Category) {HP : Has_Products C} {HE : Has_Exponentials C}. Definition curry {a b c : C} : (((√ó·∂ ‚Åø·∂ú C) _o (a, b))%object --> c) ‚Üí (a --> (HE b c)) := fun (f : ((√ó·∂ ‚Åø·∂ú C) _o (a, b))%object --> c) => Exp_morph_ex (HE b c) _ f. Definition uncurry {a b c : C} : (a --> (HE b c)) ‚Üí (((√ó·∂ ‚Åø·∂ú C) _o (a, b))%object --> c) := fun (f : a --> (HE b c)) => ((eval (HE b c)) ‚àò ((√ó·∂ ‚Åø·∂ú C) @_a (_, _) (_, _) (f, id C b)))%morphism. Section inversion. Context {a b c : C}. Theorem curry_uncurry (f : a --> (HE b c)) : curry (uncurry f) = f. 
Require Import Setoid. Require Import RelationClasses. Require Import Morphisms.Set Implicit Arguments. Set Strict Implicit.Theorem Proper_red : forall T U (rT : relation T) (rU : relation U) (f : T -> U), (forall x x', rT x x' -> rU (f x) (f x')) -> Proper (rT ==> rU) f. intuition. Qed.Theorem respectful_red : forall T U (rT : relation T) (rU : relation U) (f g : T -> U), (forall x x', rT x x' -> rU (f x) (g x')) -> respectful rT rU f g. intuition. Qed. Theorem respectful_if_bool T : forall (x x' : bool) (t t' f f' : T) eqT, x = x' -> eqT t t' -> eqT f f' -> eqT (if x then t else f) (if x' then t' else f') . 
auto. Qed. Lemma hd_error_some_nil : forall l (a:A), hd_error l = Some a -> l <> nil. Proof. unfold hd_error. destruct l; now discriminate. Qed. Theorem length_zero_iff_nil (l : list A): length l = 0 <-> l=[]. Proof. split; [now destruct l | now intros ->]. Qed. Theorem hd_error_nil : hd_error (@nil A) = None. Proof. simpl; reflexivity. Qed. Theorem hd_error_cons : forall (l : list A) (x : A), hd_error (x::l) = Some x. Proof. intros; simpl; reflexivity. Qed. Theorem in_eq : forall (a:A) (l:list A), In a (a :: l). Proof. simpl; auto. Qed. Theorem in_cons : forall (a b:A) (l:list A), In b l -> In b (a :: l). Proof. simpl; auto. Qed. Theorem not_in_cons (x a : A) (l : list A): ~ In x (a::l) <-> x<>a /\ ~ In x l. Proof. simpl. intuition. Qed. Theorem in_nil : forall a:A, ~ In a []. Proof. unfold not; intros a H; inversion_clear H. Qed. Theorem in_split : forall x (l:list A), In x l -> exists l1 l2, l = l1++x::l2. Proof. induction l; simpl; destruct 1. subst a; auto. exists [], l; auto. destruct (IHl H) as (l1,(l2,H0)). exists (a::l1), l2; simpl. apply f_equal. auto. Qed. Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l. Proof. intros a b l H; inversion_clear H; auto. Qed. Theorem in_dec : (forall x y:A, {x = y} + {x <> y}) -> forall (a:A) (l:list A), {In a l} + {~ In a l}. Proof. intro H; induction l as [| a0 l IHl]. right; apply in_nil. destruct (H a0 a); simpl; auto. destruct IHl; simpl; auto. right; unfold not; intros [Hc1| Hc2]; auto. Defined. Theorem app_cons_not_nil : forall (x y:list A) (a:A), [] <> x ++ a :: y. Proof. unfold not. destruct x as [| a l]; simpl; intros. discriminate H. discriminate H. Qed. Theorem app_nil_l : forall l:list A, [] ++ l = l. Proof. reflexivity. Qed. Theorem app_nil_r : forall l:list A, l ++ [] = l. Proof. induction l; simpl; f_equal; auto. Qed. Theorem app_nil_end : forall (l:list A), l = l ++ []. Proof. symmetry; apply app_nil_r. Qed. Theorem app_assoc : forall l m n:list A, l ++ m ++ n = (l ++ m) ++ n. Proof. intros l m n; induction l; simpl; f_equal; auto. Qed. Theorem app_assoc_reverse : forall l m n:list A, (l ++ m) ++ n = l ++ m ++ n. 
n) Y) : isofhlevelf n (hfiberpr1 f y). Proof. intros. apply isofhlevelfhfiberpr1y. intro y'. apply (is y' y). Defined. Theorem isofhlevelff (n : nat) {X Y Z : UU} (f : X -> Y) (g : Y -> Z) : isofhlevelf n (Œª x : X, g (f x)) -> isofhlevelf (S n) g -> isofhlevelf n f. Proof. intros X0 X1. unfold isofhlevelf. intro y. set (ye := make_hfiber g y (idpath (g y))). apply (isofhlevelweqb n ( ezweqhf f g (g y) ye) (isofhlevelffromXY n _ (X0 (g y)) (X1 (g y)) ye)). Defined.Theorem isofhlevelfgf (n : nat) {X Y Z : UU} (f : X -> Y) (g : Y -> Z) : isofhlevelf n f -> isofhlevelf n g -> isofhlevelf n (Œª x : X, g (f x)). Proof. intros X0 X1. unfold isofhlevelf. intro z. assert (is1 : isofhlevelf n (hfibersgftog f g z)). { unfold isofhlevelf. intro ye. apply (isofhlevelweqf n (ezweqhf f g z ye) (X0 (pr1 ye))). } assert (is2 : isofhlevel n (hfiber g z)) by apply (X1 z). apply (isofhlevelXfromfY n _ is1 is2). Defined.Theorem isofhlevelfgwtog (n : nat) {X Y Z : UU} (w : X ‚âÉ Y) (g : Y -> Z) (is : isofhlevelf n (Œª x : X, g (w x))) : isofhlevelf n g. Proof. intros. intro z. assert (is' : isweq (hfibersgftog w g z)). { intro ye. apply (iscontrweqf (ezweqhf w g z ye) (pr2 w (pr1 ye))). } apply (isofhlevelweqf _ (make_weq _ is') (is _)). Defined.Theorem isofhlevelfgtogw (n : nat) {X Y Z : UU} (w : X ‚âÉ Y) (g : Y -> Z) (is : isofhlevelf n g) : isofhlevelf n (Œª x : X, g (w x)). Proof. intros. intro z. assert (is' : isweq (hfibersgftog w g z)). { intro ye. apply (iscontrweqf (ezweqhf w g z ye) (pr2 w (pr1 ye))). } apply (isofhlevelweqb _ (make_weq _ is') (is _)). Defined.Corollary isofhlevelfhomot2 (n : nat) {X X' Y : UU} (f : X -> Y) (f' : X' -> Y) (w : X ‚âÉ X') (h : ‚àè x : X, paths (f x) (f' (w x))) : isofhlevelf n f -> isofhlevelf n f'. Proof. intros X0. assert (X1 : isofhlevelf n (Œª x : X, f' (w x))) by apply (isofhlevelfhomot n _ _ h X0). apply (isofhlevelfgwtog n w f' X1). Defined. Theorem isofhlevelfonpaths (n : nat) {X Y : UU} (f : X -> Y) (x x' : X) : isofhlevelf (S n) f -> isofhlevelf n (@maponpaths _ _ f x x'). 
: Term A n, divP r p -> divP r q -> divP r s) -> divP s p -> divP s q -> ppcm p q s. Hint Resolve ppcm0. Theorem ppc_is_ppcm : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> ppcm a b (ppc a b). intros a b nZa nZb; apply ppcm0; auto. intros r H'1 H'2; inversion H'1; inversion H'2. cut (~ zeroP (A:=A) A0 eqA (n:=n) (ppc a b)); [ intros nZppab | auto ]. apply divTerm_def with (nZb := nZppab); auto. apply divTerm_ppc with (nZa := nZa) (nZb := nZb); auto. apply ppc_nZ; auto. apply divTerm_def with (nZb := nZa); auto. apply ppc_nZ; auto. apply divTerm_ppcl; auto. apply divTerm_def with (nZb := nZb); auto. apply ppc_nZ; auto. apply divTerm_ppcr; auto. Qed. Theorem ppc_multTerm_divP : forall a b : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> divP (multTerm (A:=A) multA (n:=n) a b) (ppc a b). intros a b H' H'0. elim ppc_is_ppcm; auto. Qed. Hint Resolve ppc_multTerm_divP. Theorem divP_comp : forall a b c d : Term A n, divP a c -> eqTerm (A:=A) eqA (n:=n) a b -> eqTerm (A:=A) eqA (n:=n) c d -> divP b d. intros a b c d H'; generalize b d; elim H'. intros a0 b0 nZa0 nZb0 H'2 b1 d0 H'3 H'4; auto. cut (~ zeroP (A:=A) A0 eqA (n:=n) d0); [ intros nZd0 | auto ]. apply divTerm_def with (nZb := nZd0); auto. red in |- *; intros nz1; absurd (zeroP (A:=A) A0 eqA (n:=n) a0); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := b1); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := a0); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. apply (eqTerm_trans _ _ _ _ _ _ _ _ _ cs n) with (y := multTerm (A:=A) multA (n:=n) (divTerm a0 nZb0) b0); auto. red in |- *; intros nz1; absurd (zeroP (A:=A) A0 eqA (n:=n) b0); auto. apply zeroP_comp_eqTerm with (1 := cs) (a := d0); auto. apply (eqTerm_sym _ _ _ _ _ _ _ _ _ cs n); auto. Qed. Theorem divP_multTerm_l : forall a b c : Term A n, ~ zeroP (A:=A) A0 eqA (n:=n) a -> ~ zeroP (A:=A) A0 eqA (n:=n) b -> eqTerm (A:=A) eqA (n:=n) (multTerm (A:=A) multA (n:=n) a b) c -> divP c a. 
'C_R(S) = R. Proof. move=> pR sSR esS sSR_S'; have [[defPhi defS'] _] := esS. have [pS [sPS nPS]] := (pgroupS sSR pR, andP (Phi_normal S : 'Phi(S) <| S)). have{esS} oZS: #|'Z(S)| = p := card_center_extraspecial pS esS. have nSR: R \subset 'N(S) by rewrite -commg_subl (subset_trans sSR_S') ?der_sub. have nsCR: 'C_R(S) <| R by rewrite (normalGI nSR) ?cent_normal. have nCS: S \subset 'N('C_R(S)) by rewrite cents_norm // centsC subsetIr. rewrite cprodE ?subsetIr //= -{2}(quotientGK nsCR) normC -?quotientK //. congr (_ @*^-1 _); apply/eqP; rewrite eqEcard quotientS //=. rewrite -(card_isog (second_isog nCS)) setIAC (setIidPr sSR) /= -/'Z(S) -defPhi. rewrite -ker_conj_aut (card_isog (first_isog_loc _ nSR)) //=; set A := _ @* R. have{pS} abelSb := Phi_quotient_abelem pS; have [pSb cSSb _] := and3P abelSb. have [/= Xb defSb oXb] := grank_witness (S / 'Phi(S)). pose X := (repr \o val : coset_of _ -> gT) @: Xb. have sXS: X \subset S; last have nPX := subset_trans sXS nPS. apply/subsetP=> x; case/imsetP=> xb Xxb ->; have nPx := repr_coset_norm xb. rewrite -sub1set -(quotientSGK _ sPS) ?sub1set ?quotient_set1 //= sub1set. by rewrite coset_reprK -defSb mem_gen. have defS: <<X>> = S. apply: Phi_nongen; apply/eqP; rewrite eqEsubset join_subG sPS sXS -joing_idr. rewrite -genM_join sub_gen // -quotientSK ?quotient_gen // -defSb genS //. apply/subsetP=> xb Xxb; apply/imsetP; rewrite (setIidPr nPX). by exists (repr xb); rewrite /= ?coset_reprK //; apply: mem_imset. pose f (a : {perm gT}) := [ffun x => if x \in X then x^-1 * a x else 1]. have injf: {in A &, injective f}. move=> _ _ /morphimP[y nSy Ry ->] /morphimP[z nSz Rz ->]. move/ffunP=> eq_fyz; apply: (@eq_Aut _ S); rewrite ?Aut_aut //= => x Sx. rewrite !norm_conj_autE //; apply: canRL (conjgKV z) _; rewrite -conjgM. rewrite /conjg -(centP _ x Sx) ?mulKg {x Sx}// -defS cent_gen -sub_cent1. apply/subsetP=> x Xx; have Sx := subsetP sXS x Xx. move/(_ x): eq_fyz; rewrite !ffunE Xx !norm_conj_autE // => /mulgI xy_xz. by rewrite cent1C inE conjg_set1 conjgM xy_xz conjgK. have sfA_XS': f @: A \subset pffun_on 1 X S^`(1). apply/subsetP=> _ /imsetP[_ /morphimP[y nSy Ry ->] ->]. apply/pffun_onP; split=> [|_ /imageP[x /= Xx ->]]. by apply/subsetP=> x; apply: contraR; rewrite ffunE => /negPf->. have Sx := subsetP sXS x Xx. by rewrite ffunE Xx norm_conj_autE // (subsetP sSR_S') ?mem_commg. rewrite -(card_in_imset injf) (leq_trans (subset_leq_card sfA_XS')) // defS'. rewrite card_pffun_on (card_pgroup pSb) -rank_abelem -?grank_abelian // -oXb. by rewrite -oZS ?leq_pexp2l ?cardG_gt0 ?leq_imset_card. Qed. Theorem extraspecial_structure S : p.-group S -> extraspecial S -> {Es | all (fun E => (#|E| == p ^ 3)%N && ('Z(E) == 'Z(S))) Es & \big[cprod/1%g]_(E <- Es) E \* 'Z(S) = S}. 
K (G IR y M1)). apply H6. constructor. apply less_imp_ap; auto. simpl in |- *. rational. apply x_is_SeqLimit_G. apply x_is_SeqLimit_G. apply x_is_SeqLimit_G. Qed. Section Concrete_iso_between_Creals.Variables R1 R2 : CReals. Lemma image_Cauchy12 : forall x : R1, Cauchy_prop (fun n : nat => inj_Q R2 (G R1 x n)). Proof. intros. change (Cauchy_prop (fun n : nat => inj_Q R2 (CS_seq Q_as_COrdField (G_as_CauchySeq R1 x) n))) in |- *. apply inj_Q_Cauchy. Qed.Lemma image_Cauchy21 : forall y : R2, Cauchy_prop (fun n : nat => inj_Q R1 (G R2 y n)). Proof. intros. change (Cauchy_prop (fun n : nat => inj_Q R1 (CS_seq Q_as_COrdField (G_as_CauchySeq R2 y) n))) in |- *. apply inj_Q_Cauchy. Qed.Definition image_G_as_CauchySeq12 (x : R1) := Build_CauchySeq R2 (fun n : nat => inj_Q R2 (G R1 x n)) (image_Cauchy12 x). Definition image_G_as_CauchySeq21 (y : R2) := Build_CauchySeq R1 (fun n : nat => inj_Q R1 (G R2 y n)) (image_Cauchy21 y).Definition f12 (x : R1) := Lim (image_G_as_CauchySeq12 x). Definition g21 (y : R2) := Lim (image_G_as_CauchySeq21 y). Theorem f12_is_inverse_g21 : forall y : R2, y[=]f12 (g21 y). Proof. intro. unfold f12 in |- *. cut (y[=]Lim (inj_Q_G_as_CauchySeq R2 y)). intro. apply eq_transitive_unfolded with (y := Lim (inj_Q_G_as_CauchySeq R2 y)). assumption. apply Lim_well_def. unfold inj_Q_G_as_CauchySeq in |- *. unfold image_G_as_CauchySeq12 in |- *. change ((Build_CauchySeq R2 (fun m : nat => inj_Q R2 (CS_seq Q_as_COrdField (G_as_CauchySeq R2 y) m)) (CS_seq_inj_Q_G R2 y) :R_COrdField R2)[=] Build_CauchySeq R2 (fun n : nat => inj_Q R2 (CS_seq Q_as_COrdField (G_as_CauchySeq R1 (g21 y)) n)) (image_Cauchy12 (g21 y))) in |- *. change ((Build_CauchySeq R2 (fun m : nat => inj_Q R2 (CS_seq Q_as_COrdField (G_as_CauchySeq R2 y) m)) (inj_Q_Cauchy R2 (G_as_CauchySeq R2 y)) :R_COrdField R2)[=] Build_CauchySeq R2 (fun n : nat => inj_Q R2 (CS_seq Q_as_COrdField (G_as_CauchySeq R1 (g21 y)) n)) (inj_Q_Cauchy R2 (G_as_CauchySeq R1 (g21 y)))) in |- *. apply inj_seq_well_def with (g := G_as_CauchySeq R2 y) (h := G_as_CauchySeq R1 (g21 y)). apply inj_Q_one_one with (IR := R1). change ((Build_CauchySeq R1 (fun m : nat => inj_Q R1 (G R2 y m)) (image_Cauchy21 y) :R_COrdField R1)[=] Build_CauchySeq R1 (fun n : nat => inj_Q R1 (G R1 (g21 y) n)) (CS_seq_inj_Q_G R1 (g21 y))) in |- *. change ((image_G_as_CauchySeq21 y:R_COrdField R1)[=] inj_Q_G_as_CauchySeq R1 (g21 y)) in |- *. apply Lim_one_one with (IR := R1). apply eq_transitive_unfolded with (y := g21 y). apply eq_reflexive_unfolded. apply SeqLimit_unique. apply x_is_SeqLimit_G. apply SeqLimit_unique. apply x_is_SeqLimit_G. Qed. Theorem f12_is_surjective : map_is_surjective R1 R2 f12. 
i j j' : prev_append i j = prev_append i j' -> j = j'. Proof. revert j j'. induction i as [i Hi|i Hi|]; intros j j' H; auto; specialize (Hi _ _ H); congruence. Qed. Fixpoint map' {A B} (f: positive -> A -> B) (m: tree' A) (i: positive) {struct m} : tree' B := match m with | Node001 r => Node001 (map' f r (xI i)) | Node010 x => Node010 (f (prev i) x) | Node011 x r => Node011 (f (prev i) x) (map' f r (xI i)) | Node100 l => Node100 (map' f l (xO i)) | Node101 l r => Node101 (map' f l (xO i)) (map' f r (xI i)) | Node110 l x => Node110 (map' f l (xO i)) (f (prev i) x) | Node111 l x r => Node111 (map' f l (xO i)) (f (prev i) x) (map' f r (xI i)) end. Definition map {A B} (f: positive -> A -> B) (m: tree A) := match m with | Empty => Empty | Nodes m => Nodes (map' f m xH) end. Lemma gmap': forall {A B} (f: positive -> A -> B) (i j : positive) (m: tree' A), get' i (map' f m j) = option_map (f (prev (prev_append i j))) (get' i m). Proof. induction i; intros; destruct m; simpl; auto. Qed. Theorem gmap: forall {A B} (f: positive -> A -> B) (i: positive) (m: t A), get i (map f m) = option_map (f i) (get i m). Proof. intros; destruct m as [|m]; simpl. auto. rewrite gmap'. repeat f_equal. exact (prev_involutive i). Qed. Fixpoint map1' {A B} (f: A -> B) (m: tree' A) {struct m} : tree' B := match m with | Node001 r => Node001 (map1' f r) | Node010 x => Node010 (f x) | Node011 x r => Node011 (f x) (map1' f r) | Node100 l => Node100 (map1' f l) | Node101 l r => Node101 (map1' f l) (map1' f r) | Node110 l x => Node110 (map1' f l) (f x) | Node111 l x r => Node111 (map1' f l) (f x) (map1' f r) end. Definition map1 {A B} (f: A -> B) (m: t A) : t B := match m with | Empty => Empty | Nodes m => Nodes (map1' f m) end. Theorem gmap1: forall {A B} (f: A -> B) (i: elt) (m: t A), get i (map1 f m) = option_map f (get i m). 
\* H1 **> H4. Proof. intros M1 M2 ? (s1 & s2 & (?&?&?&?)); apply M2; exists s1, s2; auto. Qed. Theorem state_pure_intro: forall P: Prop, P -> \[P] empty. Proof. intros ? P; exists P; hnf; auto. Qed. Theorem state_pure_inversion: forall P state, \[P] state -> P /\ state = empty. Proof. intros ?? A; hnf in A; naive_solver. Qed. Theorem state_star_pure_l P H state: (\[P] \* H) state <-> P /\ (H state). Proof. unfold state_pure, state_exists; split. - hnf. rewrite state_star_exists. - rewrite state_star_exists. rewrite* state_star_empty_l. iff (p&M) (p&M). { split~. } { exists~ p. } Qed. Theorem state_star_pure_r: forall P H h, (H \* \[P]) h = (H h /\ P). Proof. intros. rewrite hstar_comm. rewrite state_star_pure_l. apply* prop_ext. Qed. Theorem himpl_state_star_pure_r: forall P H H', P -> (H ==> H') -> H ==> (\[P] \* H'). Proof. introv HP W. intros h K. rewrite* state_star_pure_l. Qed. Theorem state_pure_inv_hempty: forall P h, \[P] h -> P /\ \[] h. Proof. introv M. rewrite <- state_star_pure_l. rewrite~ hstar_hempty_r. Qed. Theorem state_pure_intro_hempty: forall P h, \[] h -> P -> \[P] h. Proof. introv M N. rewrite <- (hstar_hempty_l \[P]). rewrite~ state_star_pure_r. Qed. Theorem himpl_hempty_state_pure: forall P, P -> \[] ==> \[P]. Proof. introv HP. intros h Hh. applys* state_pure_intro_hempty. Qed. Theorem himpl_state_star_pure_l: forall P H H', (P -> H ==> H') -> (\[P] \* H) ==> H'. Proof. introv W Hh. rewrite state_star_pure_l in Hh. applys* W. Qed. Theorem hempty_eq_state_pure_true : \[] = \[True]. Proof. applys himpl_antisym; intros h M. { applys* state_pure_intro_hempty. } { forwards*: state_pure_inv_hempty M. } Qed. Theorem hfalse_hstar_any: forall H, \[False] \* H = \[False]. Proof. intros. applys himpl_antisym; intros h; rewrite state_star_pure_l; intros M. { false*. } { lets: state_pure_inv_hempty M. false*. } Qed. Theorem state_register_intro: forall register value, ($register == value) (machine_state empty {[ register := value ]}). Proof. intros; hnf; auto. Qed. Theorem state_register_inversion: forall register value state, ($register == value) state -> state = (machine_state empty {[ register := value ]}). Proof. intros ??? A; hnf in A; auto. Qed. Theorem state_star_register_same register v1 v2: ($register == v1) \* ($register == v2) **> \[False]. Proof. hnf; intros ? (s1 & s2 & ?%state_register_inversion & ?%state_register_inversion & [] & _); elimtype False; subst; simpl in *; eapply map_disjoint_spec; trivial; apply lookup_singleton. Qed. Theorem state_counter_intro: forall counter, (pc_at counter) (machine_state {[ 0%fin := counter ]} empty). Proof. intros; hnf; auto. Qed. Theorem state_counter_inversion: forall counter state, (pc_at counter) state -> state = (machine_state {[ 0%fin := counter ]} empty). 
